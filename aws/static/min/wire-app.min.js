/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ArrayUtil = {
  chunk: (array, size) => {
    const chunks = [];
    for (let index = 0, length = array.length; index < length; index += size) {
      chunks.push(array.slice(index, index + size));
    }
    return chunks;
  },

  /**
   * Gets all the values that are in array2 which are not in array1.
   *
   * @param {Array} array1 - the base array
   * @param {Array} array2 - the array to compare with
   * @returns {Array} - the array containing values in array2 that are not in array1
   */
  getDifference: (array1, array2) => {
    return array2.filter(element => !array1.includes(element));
  },

  getNextItem: (array, currentItem) => {
    const currentIndex = array.indexOf(currentItem);

    // couldn't find the item
    if (currentIndex === -1) {
      return undefined;
    }

    const nextIndex = currentIndex + 1;

    // item is last item in the array
    if (nextIndex === array.length) {
      return currentIndex > 0 ? array[currentIndex - 1] : undefined;
    }

    return array[nextIndex];
  },

  /**
   * Interpolates an array of numbers using linear interpolation
   *
   * @param {Array<any>} array - source
   * @param {number} length - new length
   * @returns {Array<any>} new array with interpolated values
   */
  interpolate: (array, length) => {
    const newArray = [];
    const scale_factor = (array.length - 1) / (length - 1);

    newArray[0] = array[0];
    newArray[length - 1] = array[array.length - 1];

    for (let index = 1; index < length - 1; index++) {
      const original_index = index * scale_factor;
      const before = Math.floor(original_index).toFixed();
      const after = Math.ceil(original_index).toFixed();
      const point = original_index - before;
      newArray[index] = array[before] + (array[after] - array[before]) * point; // linear interpolation
    }

    return newArray;
  },

  isLastItem: (array, item) => array.indexOf(item) === array.length - 1,

  iterateIndex: (array, currentIndex, reverse = false) => {
    if (_.isArray(array) && array.length && _.isNumber(currentIndex)) {
      if (reverse) {
        const isZeroIndex = currentIndex === 0;
        return isZeroIndex ? array.length - 1 : (currentIndex - 1) % array.length;
      }

      return (currentIndex + 1) % array.length;
    }
  },

  iterateItem: (array, currentItem, reverse = false) => {
    if (_.isArray(array) && array.length) {
      const currentIndex = array.indexOf(currentItem);

      // If item could not be found
      const isNegativeIndex = currentIndex === -1;
      return isNegativeIndex ? undefined : array[z.util.ArrayUtil.iterateIndex(array, currentIndex, reverse)];
    }
  },

  /**
   * Returns random element
   * @param {Array} array - source
   * @returns {Object} random element
   */
  randomElement: (array = []) => array[Math.floor(Math.random() * array.length)],

  /**
   * Remove given element from array
   * @param {Array} array - source
   * @param {Object} element - Element which should be removed
   * @returns {Array|undefined} containing the removed element
   */
  removeElement: (array = [], element) => {
    const index = array.indexOf(element);
    if (index > -1) {
      return array.splice(index, 1);
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ClipboardUtil = {
  copyText: text => {
    if (z.util.Environment.browser.supports.clipboard) {
      return navigator.clipboard.writeText(text);
    }

    try {
      const fallbackSource = document.createElement('textarea');
      fallbackSource.value = text;

      let selectedRange;

      if (window.getSelection) {
        selectedRange = window.getSelection().rangeCount ? window.getSelection().getRangeAt(0) : false;
      }

      document.body.appendChild(fallbackSource);
      fallbackSource.select();
      document.execCommand('copy');
      document.body.removeChild(fallbackSource);

      if (window.getSelection && selectedRange) {
        const currentSelection = window.getSelection();
        currentSelection.removeAllRanges();
        currentSelection.addRange(selectedRange);
      }

      return Promise.resolve();
    } catch (error) {
      return Promise.reject(error);
    }
  },
  pasteText: () => {
    if (z.util.Environment.browser.supports.clipboard) {
      return navigator.clipboard.readText();
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Crypto = {
  Hashing: {
    joaatHash: string => {
      const uint32 = window.uint32;
      let hash = uint32.toUint32(0);
      const key = string.toLowerCase();

      for (let index = 0; index < key.length; index++) {
        hash = uint32.addMod32(hash, uint32.toUint32(key.charCodeAt(index)));
        hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 10));
        hash = uint32.xor(hash, uint32.shiftRight(hash, 6));
      }

      hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 3));
      hash = uint32.xor(hash, uint32.shiftRight(hash, 11));
      hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 15));

      return hash;
    },
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.DebugUtil = class DebugUtil {
  constructor(repositories) {
    const {calling, client, connection, conversation, cryptography, event, user, storage} = repositories;

    this.callingRepository = calling;
    this.clientRepository = client;
    this.conversationRepository = conversation;
    this.connectionRepository = connection;
    this.cryptographyRepository = cryptography;
    this.eventRepository = event;
    this.storageRepository = storage;
    this.userRepository = user;

    this.logger = new z.util.Logger('z.util.DebugUtil', z.config.LOGGER.OPTIONS);
  }

  blockAllConnections() {
    const blockUsers = this.userRepository.users().map(userEntity => this.connectionRepository.blockUser(userEntity));
    return Promise.all(blockUsers);
  }

  breakSession(userId, clientId) {
    const sessionId = `${userId}@${clientId}`;
    const cryptobox = this.cryptographyRepository.cryptobox;
    return cryptobox
      .session_load(sessionId)
      .then(cryptoboxSession => {
        cryptoboxSession.session.session_states = {};

        const record = {
          created: Date.now(),
          id: sessionId,
          serialised: cryptoboxSession.session.serialise(),
          version: 'broken_by_qa',
        };

        cryptobox.cachedSessions.set(sessionId, cryptoboxSession);

        const sessionStoreName = z.storage.StorageSchemata.OBJECT_STORE.SESSIONS;
        return this.storageRepository.storageService.update(sessionStoreName, sessionId, record);
      })
      .then(() => this.logger.log(`Corrupted Session ID '${sessionId}'`));
  }

  getLastMessagesFromDatabase(amount = 10, conversationId = this.conversationRepository.active_conversation().id) {
    return this.storageRepository.storageService.db.events.toArray(records => {
      const messages = records.filter(events => events.conversation === conversationId);
      return messages.slice(amount * -1).reverse();
    });
  }

  haveISentThisMessageToMyOtherClients(
    messageId,
    conversationId = this.conversationRepository.active_conversation().id
  ) {
    let recipients = [];

    const clientId = this.clientRepository.currentClient().id;
    const userId = this.userRepository.self().id;

    const isOTRMessage = notification => notification.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
    const isInCurrentConversation = notification => notification.conversation === conversationId;
    const wasSentByOurCurrentClient = notification =>
      notification.from === userId && (notification.data && notification.data.sender === clientId);
    const hasExpectedTimestamp = (notification, dateTime) => notification.time === dateTime.toISOString();

    return this.conversationRepository
      .get_conversation_by_id(conversationId)
      .then(conversation => {
        return this.conversationRepository.get_message_in_conversation_by_id(conversation, messageId);
      })
      .then(message => {
        return this.eventRepository.notificationService
          .getNotifications(undefined, undefined, z.event.EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX)
          .then(({notifications}) => ({
            message,
            notifications,
          }));
      })
      .then(({message, notifications}) => {
        const dateTime = new Date(message.timestamp());
        return notifications
          .reduce((accumulator, notification) => accumulator.concat(notification.payload), [])
          .filter(event => {
            return (
              isOTRMessage(event) &&
              isInCurrentConversation(event) &&
              wasSentByOurCurrentClient(event) &&
              hasExpectedTimestamp(event, dateTime)
            );
          });
      })
      .then(filteredEvents => {
        recipients = filteredEvents.map(event => event.data.recipient);
        return this.clientRepository.getClientsForSelf();
      })
      .then(selfClients => {
        const selfClientIds = selfClients.map(client => client.id);
        const missingClients = selfClientIds.filter(id => recipients.includes(id));
        const logMessage = missingClients.length
          ? `Message was sent to all other "${selfClients.length}" clients.`
          : `Message was NOT sent to the following own clients: ${missingClients.join(',')}`;
        this.logger.info(logMessage);
      })
      .catch(error => this.logger.info(`Message was not sent to other clients. Reason: ${error.message}`, error));
  }

  getEventInfo(event) {
    const debugInformation = {event};

    return this.conversationRepository
      .get_conversation_by_id(event.conversation)
      .then(conversation_et => {
        debugInformation.conversation = conversation_et;
        return this.userRepository.get_user_by_id(event.from);
      })
      .then(user_et => {
        debugInformation.user = user_et;
        const logMessage = `Hey ${this.userRepository.self().name()}, this is for you:`;
        this.logger.warn(logMessage, debugInformation);
        this.logger.warn(`Conversation: ${debugInformation.conversation.name()}`, debugInformation.conversation);
        this.logger.warn(`From: ${debugInformation.user.name()}`, debugInformation.user);
        return debugInformation;
      });
  }

  exportCryptobox() {
    const clientId = this.clientRepository.currentClient().id;
    const userId = this.userRepository.self().id;
    const fileName = `cryptobox-${userId}-${clientId}.json`;

    this.cryptographyRepository.cryptobox
      .serialize()
      .then(cryptobox => z.util.downloadText(JSON.stringify(cryptobox), fileName));
  }

  getNotificationFromStream(notificationId, notificationIdSince) {
    const clientId = this.clientRepository.currentClient().id;

    const _gotNotifications = ({hasMore, notifications}) => {
      const matchingNotifications = notifications.filter(notification => notification.id === notificationId);
      if (matchingNotifications.length) {
        return matchingNotifications[0];
      }

      if (hasMore) {
        const lastNotification = notifications[notifications.length - 1];
        return this.getNotificationFromStream(notificationId, lastNotification.id);
      }
      this.logger.log(`Notification '${notificationId}' was not found in encrypted notification stream`);
    };

    return wire.app.service.notification.getNotifications(clientId, notificationIdSince, 10000).then(_gotNotifications);
  }

  getNotificationsFromStream(remoteUserId, remoteClientId, matchingNotifications = [], notificationIdSince) {
    const localClientId = this.clientRepository.currentClient().id;
    const localUserId = this.userRepository.self().id;

    const _gotNotifications = ({hasMore, notifications}) => {
      const additionalNotifications = !remoteUserId
        ? notifications
        : notifications.filter(notification => {
            const payload = notification.payload;
            for (const {data, from} of payload) {
              if (data && [localUserId, remoteUserId].includes(from)) {
                const {sender, recipient} = data;
                const incoming_event = sender === remoteClientId && recipient === localClientId;
                const outgoing_event = sender === localClientId && recipient === remoteClientId;
                return incoming_event || outgoing_event;
              }
            }
            return false;
          });

      matchingNotifications = matchingNotifications.concat(additionalNotifications);

      if (hasMore) {
        const lastNotification = notifications[notifications.length - 1];
        return this.getNotificationsFromStream(
          remoteUserId,
          remoteClientId,
          matchingNotifications,
          lastNotification.id
        );
      }

      const logMessage = remoteUserId
        ? `Found '${matchingNotifications.length}' notifications between '${localClientId}' and '${remoteClientId}'`
        : `Found '${matchingNotifications.length}' notifications`;

      this.logger.log(logMessage, matchingNotifications);

      return matchingNotifications;
    };

    const clientScope = remoteUserId === localUserId ? undefined : localClientId;
    return wire.app.service.notification
      .getNotifications(clientScope, notificationIdSince, 10000)
      .then(_gotNotifications);
  }

  getObjectsForDecryptionErrors(sessionId, notificationId) {
    return Promise.all([
      this.getNotificationFromStream(notificationId.toLowerCase()),
      this.getSerialisedIdentity(),
      this.getSerialisedSession(sessionId.toLowerCase()),
    ]).then(resolveArray => {
      return JSON.stringify({
        identity: resolveArray[1],
        notification: resolveArray[0],
        session: resolveArray[2],
      });
    });
  }

  getInfoForClientDecryptionErrors(remoteUserId, remoteClientId) {
    return Promise.all([
      this.getNotificationsFromStream(remoteUserId, remoteClientId),
      this.getSerialisedIdentity(),
      this.getSerialisedSession(`${remoteUserId}@${remoteClientId}`),
    ]).then(resolveArray => {
      return JSON.stringify({
        identity: resolveArray[1],
        notifications: resolveArray[0],
        session: resolveArray[2],
      });
    });
  }

  /**
   * Print call log to console.
   * @returns {undefined} No return value
   */
  logCallMessages() {
    this.callingRepository.printLog();
  }

  logConnectionStatus() {
    this.logger.log('Online Status');
    this.logger.log(`-- Browser online: ${window.navigator.onLine}`);
    this.logger.log(`-- IndexedDB open: ${this.storageRepository.storageService.db.isOpen()}`);
    this.logger.log(`-- WebSocket ready state: ${window.wire.app.service.web_socket.socket.readyState}`);
  }

  reprocessNotificationStream(conversationId = this.conversationRepository.active_conversation().id) {
    const clientId = this.clientRepository.currentClient().id;

    return this.eventRepository.notificationService
      .getNotifications(clientId, undefined, z.event.EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX)
      .then(({notifications}) => {
        this.logger.info(`Fetched "${notifications.length}" notifications for client "${clientId}".`, notifications);

        const isOTRMessage = notification => notification.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
        const isInCurrentConversation = notification => notification.conversation === conversationId;

        return notifications
          .map(notification => notification.payload)
          .reduce((accumulator, payload) => accumulator.concat(payload))
          .filter(notification => {
            return isOTRMessage(notification) && isInCurrentConversation(notification);
          });
      })
      .then(events => {
        this.logger.info(`Reprocessing "${events.length}" OTR messages...`);
        events.forEach(event => this.eventRepository.processEvent(event, z.event.EventRepository.SOURCE.STREAM));
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.EmojiUtil = (() => {
  // http://www.unicode.org/Public/emoji/11.0/emoji-data.txt
  // This is the exact copy of unicode-range definition for `emoji` font in CSS.
  const UNICODE_RANGES = 'U+1f000-1f02b, U+1f004, U+1f02c-1f02f, U+1f030-1f093, U+1f094-1f09f, U+1f0a0-1f0ae, U+1f0af-1f0b0, U+1f0b1-1f0be, U+1f0bf, U+1f0c0, U+1f0c1-1f0cf, U+1f0cf, U+1f0d0, U+1f0d1-1f0df, U+1f0e0-1f0f5, U+1f0f6-1f0ff, U+1f10d-1f10f, U+1f12f, U+1f16c-1f16f, U+1f170-1f171, U+1f17e, U+1f17f, U+1f18e, U+1f191-1f19a, U+1f1ad-1f1e5, U+1f1e6-1f1ff, U+1f201, U+1f201-1f202, U+1f203-1f20f, U+1f21a, U+1f22f, U+1f232-1f236, U+1f232-1f23a, U+1f238-1f23a, U+1f23c-1f23f, U+1f249-1f24f, U+1f250-1f251, U+1f252-1f25f, U+1f260-1f265, U+1f266-1f2ff, U+1f300-1f320, U+1f321, U+1f321-1f32c, U+1f324-1f32c, U+1f32d-1f32f, U+1f330-1f335, U+1f336, U+1f337-1f37c, U+1f37d, U+1f37e-1f37f, U+1f380-1f393, U+1f385, U+1f394-1f39f, U+1f396-1f397, U+1f399-1f39b, U+1f39e-1f39f, U+1f3a0-1f3c4, U+1f3c2-1f3c4, U+1f3c5, U+1f3c6-1f3ca, U+1f3c7, U+1f3ca, U+1f3cb-1f3cc, U+1f3cb-1f3ce, U+1f3cf-1f3d3, U+1f3d4-1f3df, U+1f3e0-1f3f0, U+1f3f1-1f3f7, U+1f3f3-1f3f5, U+1f3f4, U+1f3f7, U+1f3f8-1f3fa, U+1f3f8-1f3ff, U+1f3fb-1f3ff, U+1f400-1f43e, U+1f43f, U+1f440, U+1f441, U+1f442-1f443, U+1f442-1f4f7, U+1f446-1f450, U+1f466-1f469, U+1f46e, U+1f470-1f478, U+1f47c, U+1f481-1f483, U+1f485-1f487, U+1f4aa, U+1f4f8, U+1f4f9-1f4fc, U+1f4fd, U+1f4fd-1f4fe, U+1f4ff, U+1f500-1f53d, U+1f546-1f54a, U+1f549-1f54a, U+1f54b-1f54e, U+1f54b-1f54f, U+1f550-1f567, U+1f568-1f579, U+1f56f-1f570, U+1f573-1f579, U+1f574-1f575, U+1f57a, U+1f57b-1f5a3, U+1f587, U+1f58a-1f58d, U+1f590, U+1f595-1f596, U+1f5a4, U+1f5a5, U+1f5a5-1f5fa, U+1f5a8, U+1f5b1-1f5b2, U+1f5bc, U+1f5c2-1f5c4, U+1f5d1-1f5d3, U+1f5dc-1f5de, U+1f5e1, U+1f5e3, U+1f5e8, U+1f5ef, U+1f5f3, U+1f5fa, U+1f5fb-1f5ff, U+1f600, U+1f601-1f610, U+1f611, U+1f612-1f614, U+1f615, U+1f616, U+1f617, U+1f618, U+1f619, U+1f61a, U+1f61b, U+1f61c-1f61e, U+1f61f, U+1f620-1f625, U+1f626-1f627, U+1f628-1f62b, U+1f62c, U+1f62d, U+1f62e-1f62f, U+1f630-1f633, U+1f634, U+1f635-1f640, U+1f641-1f642, U+1f643-1f644, U+1f645-1f647, U+1f645-1f64f, U+1f64b-1f64f, U+1f680-1f6c5, U+1f6a3, U+1f6b4-1f6b6, U+1f6c0, U+1f6c6-1f6cf, U+1f6cb-1f6cf, U+1f6cc, U+1f6d0, U+1f6d1-1f6d2, U+1f6d3-1f6d4, U+1f6d5-1f6df, U+1f6e0-1f6e5, U+1f6e0-1f6ec, U+1f6e9, U+1f6eb-1f6ec, U+1f6ed-1f6ef, U+1f6f0, U+1f6f0-1f6f3, U+1f6f3, U+1f6f4-1f6f6, U+1f6f7-1f6f8, U+1f6f9, U+1f6fa-1f6ff, U+1f774-1f77f, U+1f7d5-1f7d8, U+1f7d9-1f7ff, U+1f80c-1f80f, U+1f848-1f84f, U+1f85a-1f85f, U+1f888-1f88f, U+1f8ae-1f8ff, U+1f90c-1f90f, U+1f910-1f918, U+1f918, U+1f919-1f91c, U+1f919-1f91e, U+1f91e, U+1f91f, U+1f920-1f927, U+1f926, U+1f928-1f92f, U+1f930, U+1f931-1f932, U+1f933-1f939, U+1f933-1f93a, U+1f93c-1f93e, U+1f93d-1f93e, U+1f93f, U+1f940-1f945, U+1f947-1f94b, U+1f94c, U+1f94d-1f94f, U+1f950-1f95e, U+1f95f-1f96b, U+1f96c-1f970, U+1f971-1f972, U+1f973-1f976, U+1f977-1f979, U+1f97a, U+1f97b, U+1f97c-1f97f, U+1f980-1f984, U+1f985-1f991, U+1f992-1f997, U+1f998-1f9a2, U+1f9a3-1f9af, U+1f9b0-1f9b3, U+1f9b0-1f9b9, U+1f9b5-1f9b6, U+1f9b8-1f9b9, U+1f9ba-1f9bf, U+1f9c0, U+1f9c1-1f9c2, U+1f9c3-1f9cf, U+1f9d0-1f9e6, U+1f9d1-1f9dd, U+1f9e7-1f9ff, U+1fa00-1fa5f, U+1fa60-1fa6d, U+1fa6e-1fffd, U+200d, U+203c, U+2049, U+20e3, U+2139, U+2194-2199, U+21a9-21aa, U+231a-231b, U+2328, U+2388, U+23cf, U+23e9-23ec, U+23e9-23f3, U+23f0, U+23f3, U+23f8-23fa, U+24c2, U+25aa-25ab, U+25b6, U+25c0, U+25fb-25fe, U+25fd-25fe, U+2600-2604, U+2600-2605, U+2607-2612, U+260e, U+2611, U+2614-2615, U+2616-2617, U+2618, U+2619, U+261a-266f, U+261d, U+2620, U+2622-2623, U+2626, U+262a, U+262e-262f, U+2638-263a, U+2640, U+2642, U+2648-2653, U+265f-2660, U+2663, U+2665-2666, U+2668, U+2670-2671, U+2672-267d, U+267b, U+267e-267f, U+267f, U+2680-2685, U+2690-2691, U+2692-2697, U+2692-269c, U+2693, U+2699, U+269b-269c, U+269d, U+269e-269f, U+26a0-26a1, U+26a1, U+26a2-26b1, U+26aa-26ab, U+26b0-26b1, U+26b2, U+26b3-26bc, U+26bd-26be, U+26bd-26bf, U+26c0-26c3, U+26c4-26c5, U+26c4-26cd, U+26c8, U+26ce, U+26cf, U+26cf-26e1, U+26d1, U+26d3-26d4, U+26d4, U+26e2, U+26e3, U+26e4-26e7, U+26e8-26ff, U+26e9-26ea, U+26ea, U+26f0-26f5, U+26f2-26f3, U+26f5, U+26f7-26fa, U+26f9, U+26fa, U+26fd, U+2700, U+2701-2704, U+2702, U+2705, U+2708-2709, U+270a-270b, U+270c-270d, U+270c-2712, U+270f, U+2712, U+2714, U+2716, U+271d, U+2721, U+2728, U+2733-2734, U+2744, U+2747, U+274c, U+274e, U+2753-2755, U+2757, U+2763-2764, U+2763-2767, U+2795-2797, U+27a1, U+27b0, U+27bf, U+2934-2935, U+2b05-2b07, U+2b1b-2b1c, U+2b50, U+2b55, U+3030, U+303d, U+3297, U+3299, U+e0020-e007f, U+fe0f'
    .replace(/U\+/g, '')
    .split(', ')
    .reduce((list, codepoint) => {
      if (codepoint.indexOf('-') === -1) {
        list.push(String.fromCodePoint(`0x${codepoint}`));
      } else {
        const hex_base = 16;
        const [start, end] = codepoint.split('-').map(code => parseInt(code, hex_base));
        for (let code = start; code <= end; code++) {
          list.push(String.fromCodePoint(`0x${code.toString(hex_base)}`));
        }
      }
      return list;
    }, []);

  const UNICODE_RANGE_REGEXP = new RegExp(`[${UNICODE_RANGES.join('')}]`, 'g');

  return {
    UNICODE_RANGES,
    includesOnlyEmojies: text => {
      const isValidString = string => _.isString(string) && string.length > 0;
      const removeEmojies = string => string.replace(UNICODE_RANGE_REGEXP, '');
      const removeWhitespace = string => string.replace(/\s+/g, '');

      return isValidString(text) && removeEmojies(removeWhitespace(text)).length === 0;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Environment = (() => {
  const APP_ENV = {
    INTERNAL: 'wire-webapp-staging.wire.com',
    LOCALHOST: 'localhost',
    PRODUCTION: 'wire.com',
    VIRTUAL_HOST: 'wire.ms', // The domain "wire.ms" is our virtual host for testing contact uploads
  };

  const BROWSER_NAME = {
    CHROME: 'Chrome',
    EDGE: 'Microsoft Edge',
    ELECTRON: 'Electron',
    FIREFOX: 'Firefox',
    OPERA: 'Opera',
    WIRE: 'Wire',
  };

  const PLATFORM_NAME = {
    MACINTOSH: 'Mac',
    WINDOWS: 'Win',
  };

  const _getAppVersion = () => {
    const versionElement = document.head.querySelector("[property='wire:version']");
    const hasVersion = versionElement && versionElement.hasAttribute('version');
    return hasVersion ? versionElement.getAttribute('version').trim() : '';
  };

  const _getElectronVersion = userAgent => {
    // [match, app, version]
    const [, , electronVersion] = /(Wire|WireInternal)\/(\S+)/.exec(userAgent) || [];
    return electronVersion;
  };

  const _getFormattedAppVersion = () => {
    const [year, month, day, hour, minute] = _getAppVersion().split('-');
    return `${year}.${month}.${day}.${hour}${minute}`;
  };

  const _getVersion = () => {
    const browserVersion = window.platform.version || '';
    const [majorVersion] = browserVersion.split('.');
    return window.parseInt(majorVersion, 10);
  };

  const _isChrome = () => window.platform.name === BROWSER_NAME.CHROME || _isElectron();
  const _isDesktop = () => _isElectron() && window.platform.ua.includes(BROWSER_NAME.WIRE);
  const _isEdge = () => window.platform.name === BROWSER_NAME.EDGE;
  const _isElectron = () => window.platform.name === BROWSER_NAME.ELECTRON;
  const _isFirefox = () => window.platform.name === BROWSER_NAME.FIREFOX;
  const _isOpera = () => window.platform.name === BROWSER_NAME.OPERA;

  const _isMac = () => window.platform.ua.includes(PLATFORM_NAME.MACINTOSH);
  const _isWindows = () => window.platform.os.family && window.platform.os.family.includes(PLATFORM_NAME.WINDOWS);

  const isInternal = () => window.location.hostname === APP_ENV.INTERNAL;
  const isLocalhost = () => [APP_ENV.LOCALHOST, APP_ENV.VIRTUAL_HOST].includes(window.location.hostname);
  const isProduction = () => {
    const isProductionHost = window.wire.env.ENVIRONMENT === z.service.BackendEnvironment.PRODUCTION;
    return isProductionHost && !isInternal();
  };

  const _supportsAudioOutputSelection = () => _isChrome();
  const _supportsCalling = () => {
    if (!_supportsMediaDevices()) {
      return false;
    }

    if (window.WebSocket === undefined) {
      return false;
    }

    return _isEdge() ? false : _isChrome() || _isFirefox() || _isOpera();
  };

  const _supportsClipboard = () => !!navigator.clipboard;
  const _supportsIndexedDb = () => {
    try {
      return !!window.indexedDB;
    } catch (error) {
      return false;
    }
  };
  const _supportsMediaDevices = () => !!navigator.mediaDevices && !!navigator.mediaDevices.getUserMedia;

  const _supportsPermissions = () => !!navigator.permissions;
  const _supportsMediaPermissions = () => _supportsPermissions() && _isChrome() && _getVersion() >= 64;

  const _supportsNotifications = () => {
    const notificationNotSupported = window.Notification === undefined;
    if (notificationNotSupported) {
      return false;
    }

    const requestPermissionNotSupported = window.Notification.requestPermission === undefined;
    return requestPermissionNotSupported ? false : document.visibilityState !== undefined;
  };
  const _supportsScreenSharing = () => (window.desktopCapturer ? true : _isFirefox());

  // add body information
  const _osCssClass = _isMac() ? 'os-mac' : 'os-pc';
  const _platformCssClass = _isElectron() ? 'platform-electron' : 'platform-web';
  document.body.classList.add(_osCssClass, _platformCssClass);

  return {
    backend: {
      current: undefined,
    },
    browser: {
      chrome: _isChrome(),
      edge: _isEdge(),
      firefox: _isFirefox(),
      name: window.platform.name,
      opera: _isOpera(),
      supports: {
        audioOutputSelection: _supportsAudioOutputSelection(),
        calling: _supportsCalling(),
        clipboard: _supportsClipboard(),
        indexedDb: _supportsIndexedDb(),
        mediaDevices: _supportsMediaDevices(),
        mediaPermissions: _supportsMediaPermissions(),
        notifications: _supportsNotifications(),
        permissions: _supportsPermissions(),
        screenSharing: _supportsScreenSharing(),
      },
      version: _getVersion(),
    },
    desktop: _isDesktop(),
    electron: _isElectron(),
    electronVersion: _getElectronVersion,
    frontend: {
      isInternal,
      isLocalhost,
      isProduction,
    },
    os: {
      linux: !_isMac() && !_isWindows(),
      mac: _isMac(),
      win: _isWindows(),
    },
    version(showWrapperVersion = true, doNotFormat = false) {
      if (z.util.Environment.frontend.isLocalhost()) {
        return 'dev';
      }

      if (doNotFormat) {
        return _getAppVersion();
      }

      const electronVersion = _getElectronVersion(window.platform.ua);
      const showElectronVersion = electronVersion && showWrapperVersion;
      return showElectronVersion ? electronVersion : _getFormattedAppVersion();
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.checkIndexedDb = () => {
  if (!z.util.Environment.browser.supports.indexedDb) {
    const errorType = z.util.Environment.browser.edge
      ? z.error.AuthError.TYPE.PRIVATE_MODE
      : z.error.AuthError.TYPE.INDEXED_DB_UNSUPPORTED;
    return Promise.reject(new z.error.AuthError(errorType));
  }

  if (z.util.Environment.browser.firefox) {
    let dbOpenRequest;

    try {
      dbOpenRequest = window.indexedDB.open('test');
      dbOpenRequest.onerror = event => {
        if (dbOpenRequest.error) {
          event.preventDefault();
          return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
        }
      };
    } catch (error) {
      return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
    }

    return new Promise((resolve, reject) => {
      let currentAttempt = 0;
      const interval = 10;
      const maxRetry = 50;

      const interval_id = window.setInterval(() => {
        currentAttempt += 1;

        if (dbOpenRequest.readyState === 'done' && !dbOpenRequest.result) {
          window.clearInterval(interval_id);
          return reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
        }

        const tooManyAttempts = currentAttempt >= maxRetry;
        if (tooManyAttempts) {
          window.clearInterval(interval_id);
          resolve();
        }
      }, interval);
    });
  }

  return Promise.resolve();
};

z.util.isSameLocation = (pastLocation, currentLocation) => {
  return pastLocation !== '' && currentLocation.startsWith(pastLocation);
};

z.util.loadImage = function(blob) {
  return new Promise((resolve, reject) => {
    const object_url = window.URL.createObjectURL(blob);
    const img = new Image();
    img.onload = function() {
      resolve(this);
      window.URL.revokeObjectURL(object_url);
    };
    img.onerror = reject;
    img.src = object_url;
  });
};

z.util.loadDataUrl = file => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

z.util.loadFileBuffer = file => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
};

z.util.loadUrlBuffer = (url, xhrAccessorFunction) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';

    xhr.onload = () => {
      const isStatusOK = xhr.status === 200;
      return isStatusOK
        ? resolve({buffer: xhr.response, mimeType: xhr.getResponseHeader('content-type')})
        : reject(new Error(xhr.status));
    };

    xhr.onerror = reject;

    if (typeof xhrAccessorFunction === 'function') {
      xhrAccessorFunction(xhr);
    }
    xhr.send();
  });
};

z.util.loadUrlBlob = url => {
  return z.util.loadUrlBuffer(url).then(({buffer, mimeType}) => new Blob([new Uint8Array(buffer)], {type: mimeType}));
};

/**
 * Get extension of a filename.
 * @param {string} filename - filename including extension
 * @returns {string} File extension
 */
z.util.getFileExtension = filename => {
  if (!_.isString(filename) || !filename.includes('.')) {
    return '';
  }

  if (filename.endsWith('.tar.gz')) {
    return 'tar.gz';
  }

  return filename.substr(filename.lastIndexOf('.') + 1);
};

/**
 * Remove extension of a filename.
 * @param {string} filename - filename including extension
 * @returns {string} New String without extension
 */
z.util.trimFileExtension = filename => {
  if (_.isString(filename)) {
    if (filename.endsWith('.tar.gz')) {
      filename = filename.replace(/\.tar\.gz$/, '');
    }

    return filename.replace(/\.[^/.]+$/, '');
  }

  return '';
};

/**
 * Format bytes into a human readable string.
 * @param {number} bytes - bytes to format
 * @param {number} [decimals] - Number of decimals to keep
 * @returns {string} Bytes as a human readable string
 */
z.util.formatBytes = (bytes, decimals) => {
  if (bytes === 0) {
    return '0B';
  }

  const kilobytes = 1024;
  decimals = decimals + 1 || 2;
  const unit = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const index = Math.floor(Math.log(bytes) / Math.log(kilobytes));
  return parseFloat((bytes / Math.pow(kilobytes, index)).toFixed(decimals)) + unit[index];
};

z.util.getContentTypeFromDataUrl = data_url => {
  return data_url
    .split(',')[0]
    .split(':')[1]
    .split(';')[0];
};

z.util.stripDataUri = string => string.replace(/^data:.*,/, '');

/**
 * Convert base64 string to UInt8Array.
 * @note Function will remove "data-uri" attribute if present.
 * @param {string} base64 - base64 encoded string
 * @returns {UInt8Array} Typed array
 */
z.util.base64ToArray = base64 => bazinga64.Decoder.fromBase64(z.util.stripDataUri(base64)).asBytes;

/**
 * Convert ArrayBuffer or UInt8Array to base64 string
 * @param {ArrayBuffer|UInt8Array} array - raw binary data or bytes
 * @returns {string} Base64-encoded string
 */
z.util.arrayToBase64 = array => bazinga64.Encoder.toBase64(new Uint8Array(array)).asString;

/**
 * Returns base64 encoded md5 of the the given array.
 * @param {Uint8Array} array - Input array
 * @returns {string} MD5 hash
 */
z.util.arrayToMd5Base64 = array => {
  const wordArray = CryptoJS.lib.WordArray.create(array);
  return CryptoJS.MD5(wordArray).toString(CryptoJS.enc.Base64);
};

/**
 * Convert base64 dataURI to Blob
 * @param {string} base64 - base64 encoded data uri
 * @returns {Blob} Binary output
 */

z.util.base64ToBlob = base64 => {
  const mimeType = z.util.getContentTypeFromDataUrl(base64);
  const bytes = z.util.base64ToArray(base64);
  return new Blob([bytes], {type: mimeType});
};

/**
 * Downloads blob using a hidden link element.
 * @param {Blob} blob - Blob to store
 * @param {string} filename - Data will be saved under this name
 * @param {string} [mimeType] - Mime type of the generated download
 * @returns {number} Timeout identifier
 */

z.util.downloadBlob = (blob, filename, mimeType) => {
  if (blob) {
    const url = window.URL.createObjectURL(blob);
    return z.util.downloadFile(url, filename, mimeType);
  }

  throw new Error('Failed to download blob: Resource not provided');
};

z.util.downloadText = (text, filename = 'default.txt') => {
  const url = `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`;
  return z.util.downloadFile(url, filename);
};

z.util.downloadFile = (url, fileName, mimeType) => {
  const anchor = document.createElement('a');
  anchor.download = fileName;
  anchor.href = url;
  anchor.style = 'display: none';
  if (mimeType) {
    anchor.type = mimeType;
  }

  // Firefox needs the element to be in the DOM for the download to start:
  // @see https://stackoverflow.com/a/32226068
  document.body.appendChild(anchor);
  anchor.click();

  // Wait before removing resource and link. Needed in FF.
  return window.setTimeout(() => {
    const objectURL = anchor.href;
    document.body.removeChild(anchor);
    window.URL.revokeObjectURL(objectURL);
  }, 100);
};

z.util.phoneNumberToE164 = (phoneNumber, countryCode) => {
  return window.PhoneFormat.formatE164(`${countryCode}`.toUpperCase(), `${phoneNumber}`);
};

z.util.createRandomUuid = () => UUID.genV4().hexString;

z.util.encodeBase64 = text => window.btoa(text);

z.util.encodeSha256Base64 = text => CryptoJS.SHA256(text).toString(CryptoJS.enc.Base64);

// Note IE10 listens to "transitionend" instead of "animationend"
z.util.alias = {
  animationend: 'transitionend animationend oAnimationEnd MSAnimationEnd mozAnimationEnd webkitAnimationEnd',
};

// Note: We are using "Underscore.js" to escape HTML in the original message
z.util.renderMessage = (message, selfId, mentionEntities = []) => {
  const createMentionHash = mention => ` @${btoa(JSON.stringify(mention)).replace(/=/g, '')}`;
  const renderMention = mentionData => {
    const elementClasses = mentionData.isSelfMentioned ? ' self-mention' : '';
    const elementAttributes = mentionData.isSelfMentioned
      ? ' data-uie-name="label-self-mention"'
      : ` data-uie-name="label-other-mention" data-user-id="${mentionData.userId}"`;

    const mentionText = mentionData.text.replace(/^@/, '');
    const content = `<span class="mention-at-sign">@</span>${z.util.SanitizationUtil.escapeString(mentionText)}`;
    return `<span class="message-mention${elementClasses}"${elementAttributes}>${content}</span>`;
  };
  const mentionTexts = {};

  let mentionlessText = mentionEntities
    .slice()
    // sort mentions to start with the latest mention first (in order not to have to recompute the index everytime we modify the original text)
    .sort((mention1, mention2) => mention2.startIndex - mention1.startIndex)
    .reduce((strippedText, mention) => {
      const mentionText = message.slice(mention.startIndex, mention.startIndex + mention.length);
      const mentionKey = createMentionHash(mention);
      mentionTexts[mentionKey] = {
        isSelfMentioned: mention.targetsUser(selfId),
        text: mentionText,
        userId: mention.userId,
      };
      return z.util.StringUtil.replaceInRange(
        strippedText,
        mentionKey,
        mention.startIndex,
        mention.startIndex + mention.length
      );
    }, message);

  mentionlessText = marked(mentionlessText, {
    highlight: function(code) {
      const containsMentions = mentionEntities.some(mention => {
        const hash = createMentionHash(mention);
        return code.includes(hash);
      });
      if (containsMentions) {
        // disable code highlighting if there is a mention in there
        // highlighting will be wrong anyway because this is not valid code
        return code;
      }
      return hljs.highlightAuto(code).value;
    },
    sanitize: true,
  });

  // TODO: Remove this when this is merged: https://github.com/SoapBox/linkifyjs/pull/189
  mentionlessText = mentionlessText.replace(/\n/g, '<br />');

  // Remove <br /> if it is the last thing in a message
  if (z.util.StringUtil.getLastChars(mentionlessText, '<br />'.length) === '<br />') {
    mentionlessText = z.util.StringUtil.cutLastChars(mentionlessText, '<br />'.length);
  }

  const parsedText = Object.keys(mentionTexts).reduce((text, mentionHash) => {
    const mentionMarkup = renderMention(mentionTexts[mentionHash]);

    return text.replace(mentionHash, mentionMarkup);
  }, mentionlessText);

  return parsedText;
};

z.util.koArrayPushAll = (koArray, valuesToPush) => {
  // append array to knockout observableArray
  // https://github.com/knockout/knockout/issues/416
  const underlyingArray = koArray();
  koArray.valueWillMutate();
  ko.utils.arrayPushAll(underlyingArray, valuesToPush);
  koArray.valueHasMutated();
};

z.util.koArrayUnshiftAll = (koArray, valuesToShift) => {
  // prepend array to knockout observableArray
  const underlyingArray = koArray();
  koArray.valueWillMutate();
  Array.prototype.unshift.apply(underlyingArray, valuesToShift);
  koArray.valueHasMutated();
};

z.util.koPushDeferred = (target, src, number = 100, delay = 300) => {
  // push array deferred to knockout observableArray
  let interval;

  return (interval = window.setInterval(() => {
    const chunk = src.splice(0, number);
    z.util.koArrayPushAll(target, chunk);

    if (src.length === 0) {
      return window.clearInterval(interval);
    }
  }, delay));
};

/**
 * Add zero padding until limit is reached.
 * @param {string|number} value - Input
 * @param {number} length - Final output length
 * @returns {string} Input value with leading zeros (padding)
 */
z.util.zeroPadding = (value, length = 2) => {
  const zerosNeeded = Math.max(0, length - value.toString().length);
  return `${'0'.repeat(zerosNeeded)}${value}`;
};

/**
 * Test whether the given string is ISO 8601 format equally to date.toISOString()
 * @param {string} dateString - String with data
 * @returns {boolean} True, if input string follows ISO 8601
 */
z.util.isIsoString = dateString => {
  return /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/.test(dateString);
};

z.util.sortGroupsByLastEvent = (groupA, groupB) => groupB.last_event_timestamp() - groupA.last_event_timestamp();

z.util.sortObjectByKeys = (object, reverse) => {
  const keys = Object.keys(object);
  keys.sort();

  if (reverse) {
    keys.reverse();
  }

  // Returns a copy of an object, which is ordered by the keys of the original object.
  return keys.reduce((sortedObject, key) => {
    sortedObject[key] = object[key];
    return sortedObject;
  }, {});
};

// Removes url(' and url(" from the beginning of the string and also ") and ') from the end
z.util.stripUrlWrapper = url => url.replace(/^url\(["']?/, '').replace(/["']?\)$/, '');

z.util.validateProfileImageResolution = (file, minWidth, minHeight) => {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image.width >= minWidth && image.height >= minHeight);
    image.onerror = () => reject(new Error('Failed to load profile picture for size validation'));
    image.src = window.URL.createObjectURL(file);
  });
};

z.util.isValidEmail = email => {
  const regExp = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return regExp.test(email);
};

/**
 * Checks if input has the format of an international phone number
 * @note Begins with + and contains only numbers
 * @param {string} phoneNumber - Input
 * @returns {boolean} True, if the input a phone number
 */
z.util.isValidPhoneNumber = phoneNumber => {
  const allowDebugPhoneNumbers = window.wire.env.FEATURE.ENABLE_DEBUG;
  const regularExpression = allowDebugPhoneNumbers ? /^\+[0-9]\d{1,14}$/ : /^\+[1-9]\d{1,14}$/;

  return regularExpression.test(phoneNumber);
};

z.util.isValidUsername = username => {
  if (username.startsWith('@')) {
    username = username.substring(1);
  }
  return /^[a-z_0-9]{2,21}$/.test(username);
};

z.util.murmurhash3 = (key, seed) => {
  const remainder = key.length & 3; // key.length % 4
  const bytes = key.length - remainder;
  let h1 = seed;
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;
  let index = 0;

  while (index < bytes) {
    let k1 =
      (key.charCodeAt(index) & 0xff) |
      ((key.charCodeAt(++index) & 0xff) << 8) |
      ((key.charCodeAt(++index) & 0xff) << 16) |
      ((key.charCodeAt(++index) & 0xff) << 24);
    ++index;

    k1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;

    h1 ^= k1;
    h1 = (h1 << 13) | (h1 >>> 19);
    const h1b = ((h1 & 0xffff) * 5 + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16);
  }

  let k1 = 0;

  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(index + 2) & 0xff) << 16;
      break;
    case 2:
      k1 ^= (key.charCodeAt(index + 1) & 0xff) << 8;
      break;
    case 1:
      k1 ^= key.charCodeAt(index) & 0xff;

      k1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
      break;
    default:
      break;
  }

  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = ((h1 & 0xffff) * 0x85ebca6b + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((h1 & 0xffff) * 0xc2b2ae35 + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return h1 >>> 0;
};

z.util.printDevicesId = id => {
  if (!id) {
    return '';
  }

  const idWithPadding = z.util.zeroPadding(id, 16);
  const parts = idWithPadding.match(/.{1,2}/g) || [];
  const prettifiedId = parts.map(part => `<span class='device-id-part'>${part}</span>`);

  return prettifiedId.join('');
};

/**
 * Returns bucket for given value based on the specified bucket limits
 * @example z.util.bucketValues(13, [0, 5, 10, 15, 20, 25]) will return '11-15')
 * @param {number} value - Numeric value
 * @param {Array<number>} bucketLimits - Array with numeric values that define the upper limit of the bucket
 * @returns {string} Bucket
 */
z.util.bucketValues = (value, bucketLimits) => {
  if (value < bucketLimits[0] + 1) {
    return '0';
  }

  for (let index = 0; index < bucketLimits.length; index++) {
    const limit = bucketLimits[index];
    if (value < limit + 1) {
      const previous_limit = bucketLimits[index - 1];
      return `${previous_limit + 1}-${limit}`;
    }
  }

  const last_limit = bucketLimits[bucketLimits.length - 1];
  return `${last_limit + 1}-`;
};

// https://developer.mozilla.org/en-US/Firefox/Performance_best_practices_for_Firefox_fe_engineers
z.util.afterRender = callback => window.requestAnimationFrame(() => window.setTimeout(callback, 0));

/**
 * No operation
 * @returns {void}
 */
z.util.noop = () => {};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.SanitizationUtil = (() => {
  const _getSelfName = (declension = z.string.Declension.NOMINATIVE, bypassSanitization = false) => {
    const selfNameDeclensions = {
      [z.string.Declension.NOMINATIVE]: z.string.conversationYouNominative,
      [z.string.Declension.DATIVE]: z.string.conversationYouDative,
      [z.string.Declension.ACCUSATIVE]: z.string.conversationYouAccusative,
    };

    const selfName = z.l10n.text(selfNameDeclensions[declension]);
    return bypassSanitization ? selfName : z.util.SanitizationUtil.escapeString(selfName);
  };

  return {
    escapeRegex: string => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),

    escapeString: string => _.escape(string),

    getFirstName: (userEntity, declension, bypassSanitization = false) => {
      if (userEntity.is_me) {
        return _getSelfName(declension, bypassSanitization);
      }
      return bypassSanitization
        ? userEntity.first_name()
        : z.util.SanitizationUtil.escapeString(userEntity.first_name());
    },

    getSelfName: _getSelfName,

    safeMailtoOpen: (event, email) => {
      event.preventDefault();
      event.stopPropagation();

      if (!z.util.isValidEmail(email)) {
        return;
      }

      const newWindow = window.open(`mailto:${email}`);
      if (newWindow) {
        window.setTimeout(() => newWindow.close(), 10);
      }
    },

    /**
     * Opens a new browser tab (target="_blank") with a given URL in a safe environment.
     * @see https://mathiasbynens.github.io/rel-noopener/
     * @param {string} url - URL you want to open in a new browser tab
     * @param {boolean} focus - True, if the new windows should get browser focus
     * @returns {Object} New window handle
     */
    safeWindowOpen: (url, focus = true) => {
      const newWindow = window.open(z.util.URLUtil.prependProtocol(url));

      if (newWindow) {
        newWindow.opener = null;
        if (focus) {
          newWindow.focus();
        }
      }

      return newWindow;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

//@ts-check

'use strict';

/**
 * @typedef {object} DiscreteTimeUnit
 * @property {string} longUnit
 * @property {string} symbol
 * @property {number} value
 */

/**
 * @typedef {object} DurationUnit
 * @property {string} text
 * @property {string} symbol
 * @property {number} value
 */

window.z = window.z || {};
window.z.util = z.util || {};

z.util.TimeUtil = {
  UNITS_IN_MILLIS: {
    DAY: 1000 * 60 * 60 * 24,
    HOUR: 1000 * 60 * 60,
    MINUTE: 1000 * 60,
    SECOND: 1000,
    WEEK: 1000 * 60 * 60 * 24 * 7,
    YEAR: 1000 * 60 * 60 * 24 * 365,
  },

  durationUnits: () => {
    return [
      {
        plural: 'ephemeralUnitsYears',
        singular: 'ephemeralUnitsYear',
        symbol: 'y',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.YEAR,
      },
      {
        plural: 'ephemeralUnitsWeeks',
        singular: 'ephemeralUnitsWeek',
        symbol: 'w',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      },
      {
        plural: 'ephemeralUnitsDays',
        singular: 'ephemeralUnitsDay',
        symbol: 'd',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      },
      {
        plural: 'ephemeralUnitsHours',
        singular: 'ephemeralUnitsHour',
        symbol: 'h',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR,
      },
      {
        plural: 'ephemeralUnitsMinutes',
        singular: 'ephemeralUnitsMinute',
        symbol: 'm',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
      },
      {
        plural: 'ephemeralUnitsSeconds',
        singular: 'ephemeralUnitsSecond',
        symbol: 's',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    ];
  },

  /**
   * Format milliseconds into 15s, 2m.
   * @param {number} duration - Duration to format in milliseconds
   * @returns {DurationUnit} Unit, value and localized string
   */
  formatDuration: duration => {
    const mappedUnits = z.util.TimeUtil.mapUnits(duration, true);
    const firstNonZeroUnit = mappedUnits.find(unit => unit.value > 0);
    return {
      symbol: firstNonZeroUnit.symbol,
      text: `${firstNonZeroUnit.value} ${z.l10n.text(firstNonZeroUnit.longUnit)}`,
      value: firstNonZeroUnit.value,
    };
  },

  /**
   * Generate a human readable string of the remaining time
   * @param {number} duration - the remaining time in milliseconds
   * @returns {string} readable representation of the remaining time
   */
  formatDurationCaption: duration => {
    const mappedUnits = z.util.TimeUtil.mapUnits(duration, false);
    const hours = mappedUnits.find(unit => unit.symbol === 'h');
    const minutes = mappedUnits.find(unit => unit.symbol === 'm');
    const hasHours = hours.value > 0;
    const validUnitStrings = [];
    for (let index = 0; index < mappedUnits.length; index++) {
      const unit = mappedUnits[index];
      if (unit === hours && hasHours) {
        validUnitStrings.push(`${z.util.zeroPadding(hours.value)}:${z.util.zeroPadding(minutes.value)}`);
        break;
      }
      if (unit.value > 0) {
        validUnitStrings.push(`${unit.value} ${unit.longUnit}`);
      }
      if (validUnitStrings.length === 2) {
        break;
      }
      const nextUnit = mappedUnits[index + 1];
      if (validUnitStrings.length > 0 && nextUnit && nextUnit.value === 0) {
        break;
      }
    }
    const joiner = ` ${z.l10n.text(z.string.and)} `;
    return `${validUnitStrings.join(joiner)} ${z.l10n.text(z.string.ephemeralRemaining)}`;
  },

  /**
   * Format seconds into hh:mm:ss.
   * @param {number} duration - duration to format in seconds
   * @returns {string} Formatted string
   */
  formatSeconds: duration => {
    duration = Math.round(duration || 0);

    const hours = Math.floor(duration / (60 * 60));

    const divisorForMinutes = duration % (60 * 60);
    const minutes = Math.floor(divisorForMinutes / 60);

    const divisor_for_seconds = divisorForMinutes % 60;
    const seconds = Math.ceil(divisor_for_seconds);

    const components = [z.util.zeroPadding(minutes), z.util.zeroPadding(seconds)];

    if (hours > 0) {
      components.unshift(hours);
    }

    return components.join(':');
  },

  /**
   * Human readable format of a timestamp.
   * @note: Not testable due to timezones :(
   * @param {number} timestamp - Timestamp
   * @param {boolean} longFormat - True, if output should have leading numbers
   * @returns {string} Human readable format of a timestamp.
   */
  formatTimestamp: (timestamp, longFormat = true) => {
    const time = moment(timestamp);
    let format = 'DD.MM.YYYY (HH:mm:ss)';

    if (longFormat) {
      format = moment().year() === time.year() ? 'ddd D MMM, HH:mm' : 'ddd D MMM YYYY, HH:mm';
    }

    return time.format(format);
  },

  getCurrentDate: () => new Date().toISOString().substring(0, 10),

  getUnixTimestamp: () => Math.floor(Date.now() / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND),

  /**
   * Calculate the discrete time units (years, weeks, days, hours, minutes, seconds) for a given duration
   * @note Implementation based on: https://gist.github.com/deanrobertcook/7168b38150c303a2b4196216913d34c1
   * @param {number} duration - duration in milliseconds
   * @param {boolean} rounded - should the units be rounded as opposed to floored
   * @returns {DiscreteTimeUnit[]} calculated time units
   */
  mapUnits: (duration, rounded) => {
    const mappedUnits = z.util.TimeUtil.durationUnits().map((unit, index, units) => {
      let value = duration;
      if (index > 0) {
        value %= units[index - 1].value;
      }
      value /= unit.value;
      value = rounded && value >= 1 ? Math.round(value) : Math.floor(value);
      const longUnit = z.string[value === 1 ? unit.singular : unit.plural];
      return {
        longUnit,
        symbol: unit.symbol,
        value,
      };
    });
    return mappedUnits;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.protobuf = {
  loadProtos: file => {
    return new Promise((resolve, reject) => {
      dcodeIO.ProtoBuf.loadProtoFile(file, (error, builder) => {
        if (error) {
          return reject(new Error(`Loading protocol buffer file failed: ${error.message}`));
        }

        z.proto = z.proto || {};
        _.extend(z.proto, builder.build());
        resolve();
      });
    });
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.KeyboardUtil = (() => {
  const KEY_DEFAULT = {
    ARROW_DOWN: 'ArrowDown',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    BACKSPACE: 'Backspace',
    DELETE: 'Delete',
    ENTER: 'Enter',
    ESC: 'Escape',
    KEY_V: 'v',
    SPACE: ' ',
    TAB: 'Tab',
  };

  const KEY_EDGE = {
    ARROW_DOWN: 'Down',
    ARROW_LEFT: 'Left',
    ARROW_RIGHT: 'Right',
    ARROW_UP: 'Up',
  };

  const KEYBOARD_KEY = z.util.Environment.browser.edge ? Object.assign(KEY_DEFAULT, KEY_EDGE) : KEY_DEFAULT;

  const _insertAtCaret = (areaId, text) => {
    // http://stackoverflow.com/a/1064139
    const textArea = document.getElementById(areaId);
    if (!textArea) {
      return;
    }

    const scrollPos = textArea.scrollTop;
    let strPos = 0;
    const br = textArea.selectionStart || textArea.selectionStart === '0' ? 'ff' : document.selection ? 'ie' : false;

    if (br === 'ie') {
      textArea.focus();
      const range = document.selection.createRange();
      range.moveStart('character', -textArea.value.length);
      strPos = range.text.length;
    } else if (br === 'ff') {
      strPos = textArea.selectionStart;
    }

    const front = textArea.value.substring(0, strPos);
    const back = textArea.value.substring(strPos, textArea.value.length);

    textArea.value = `${front}${text}${back}`;
    strPos = strPos + text.length;

    if (br === 'ie') {
      textArea.focus();
      const ieRange = document.selection.createRange();
      ieRange.moveStart('character', -textArea.value.length);
      ieRange.moveStart('character', strPos);
      ieRange.moveEnd('character', 0);
      ieRange.select();
    } else if (br === 'ff') {
      textArea.selectionStart = strPos;
      textArea.selectionEnd = strPos;
      textArea.focus();
    }

    textArea.scrollTop = scrollPos;
  };

  const _isArrowKey = keyboardEvent => {
    return _isOneOfKeys(keyboardEvent, [
      KEYBOARD_KEY.ARROW_DOWN,
      KEYBOARD_KEY.ARROW_LEFT,
      KEYBOARD_KEY.ARROW_RIGHT,
      KEYBOARD_KEY.ARROW_UP,
    ]);
  };

  const _isBackspaceKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.BACKSPACE);
  const _isDeleteKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.DELETE);
  const _isEnterKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.ENTER);
  const _isEscapeKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.ESC);

  const _isFunctionKey = keyboardEvent => {
    return keyboardEvent.altKey || keyboardEvent.ctrlKey || keyboardEvent.metaKey || keyboardEvent.shiftKey;
  };

  const _isKey = (keyboardEvent = {}, expectedKey = '') => {
    const eventKey = keyboardEvent.key ? keyboardEvent.key.toLowerCase() : '';
    return eventKey === expectedKey.toLowerCase();
  };

  const _isMetaKey = keyboardEvent => keyboardEvent.metaKey || keyboardEvent.ctrlKey;

  const _isOneOfKeys = (keyboardEvent, expectedKeys = []) => {
    expectedKeys = expectedKeys.map(key => key.toLowerCase());

    const eventKey = keyboardEvent.key ? keyboardEvent.key.toLowerCase() : '';
    return !!expectedKeys.find(key => key === eventKey);
  };

  const _isPasteAction = keyboardEvent => {
    return _isMetaKey(keyboardEvent) && _isKey(keyboardEvent, KEYBOARD_KEY.KEY_V);
  };

  const _isRemovalAction = keyboardEvent => {
    return _isOneOfKeys(keyboardEvent, [KEYBOARD_KEY.BACKSPACE, KEYBOARD_KEY.DELETE]);
  };

  return {
    KEY: KEYBOARD_KEY,
    insertAtCaret: _insertAtCaret,
    isArrowKey: _isArrowKey,
    isBackspaceKey: _isBackspaceKey,
    isDeleteKey: _isDeleteKey,
    isEnterKey: _isEnterKey,
    isEscapeKey: _isEscapeKey,
    isFunctionKey: _isFunctionKey,
    isKey: _isKey,
    isMetaKey: _isMetaKey,
    isOneOfKeys: _isOneOfKeys,
    isPasteAction: _isPasteAction,
    isRemovalAction: _isRemovalAction,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.LocalizerUtil = {
  joinNames: (userEntities, declension = z.string.Declension.ACCUSATIVE, skipAnd = false, boldNames = false) => {
    const containsSelfUser = userEntities.some(userEntity => userEntity.is_me);
    if (containsSelfUser) {
      userEntities = userEntities.filter(userEntity => !userEntity.is_me);
    }

    const firstNames = userEntities
      .map(userEntity => {
        const firstName = userEntity.first_name();
        return boldNames ? `[bold]${firstName}[/bold]` : firstName;
      })
      .sort((userNameA, userNameB) => z.util.StringUtil.sortByPriority(userNameA, userNameB));

    if (containsSelfUser) {
      firstNames.push(z.util.SanitizationUtil.getSelfName(declension));
    }

    const numberOfNames = firstNames.length;
    const joinByAnd = !skipAnd && numberOfNames >= 2;
    if (joinByAnd) {
      const [secondLastName, lastName] = firstNames.splice(firstNames.length - 2, 2);

      const exactlyTwoNames = numberOfNames === 2;
      const additionalNames = exactlyTwoNames
        ? `${secondLastName} ${z.l10n.text(z.string.and)} ${lastName}`
        : `${secondLastName}${z.l10n.text(z.string.enumerationAnd)}${lastName}`;
      firstNames.push(additionalNames);
    }

    return firstNames.join(', ');
  },
};

/* eslint-disable */
(function() {
  'use strict';

  const _typeof =
    typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
      ? function(obj) {
          return typeof obj;
        }
      : function(obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype
            ? 'symbol'
            : typeof obj;
        };

  (function(exports) {
    'use strict';

    function inherits(parent, child) {
      const props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      const extended = Object.create(parent.prototype);
      for (const p in props) {
        extended[p] = props[p];
      }
      extended.constructor = child;
      child.prototype = extended;
      return child;
    }

    const defaults = {
      defaultProtocol: 'http',
      events: null,
      format: noop,
      formatHref: noop,
      nl2br: false,
      tagName: 'a',
      target: typeToTarget,
      validate: true,
      ignoreTags: [],
      attributes: null,
      className: 'linkified', // Deprecated value - no default class will be provided in the future
    };

    function Options(opts) {
      opts = opts || {};

      this.defaultProtocol = opts.hasOwnProperty('defaultProtocol') ? opts.defaultProtocol : defaults.defaultProtocol;
      this.events = opts.hasOwnProperty('events') ? opts.events : defaults.events;
      this.format = opts.hasOwnProperty('format') ? opts.format : defaults.format;
      this.formatHref = opts.hasOwnProperty('formatHref') ? opts.formatHref : defaults.formatHref;
      this.nl2br = opts.hasOwnProperty('nl2br') ? opts.nl2br : defaults.nl2br;
      this.tagName = opts.hasOwnProperty('tagName') ? opts.tagName : defaults.tagName;
      this.target = opts.hasOwnProperty('target') ? opts.target : defaults.target;
      this.validate = opts.hasOwnProperty('validate') ? opts.validate : defaults.validate;
      this.ignoreTags = [];

      // linkAttributes and linkClass is deprecated
      this.attributes = opts.attributes || opts.linkAttributes || defaults.attributes;
      this.className = opts.hasOwnProperty('className') ? opts.className : opts.linkClass || defaults.className;

      // Make all tags names upper case
      const ignoredTags = opts.hasOwnProperty('ignoreTags') ? opts.ignoreTags : defaults.ignoreTags;
      for (let i = 0; i < ignoredTags.length; i++) {
        this.ignoreTags.push(ignoredTags[i].toUpperCase());
      }
    }

    Options.prototype = {
      /**
       * Given the token, return all options for how it should be displayed
       */
      resolve: function resolve(token) {
        const href = token.toHref(this.defaultProtocol);
        return {
          formatted: this.get('format', token.toString(), token),
          formattedHref: this.get('formatHref', href, token),
          tagName: this.get('tagName', href, token),
          className: this.get('className', href, token),
          target: this.get('target', href, token),
          events: this.getObject('events', href, token),
          attributes: this.getObject('attributes', href, token),
        };
      },

      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options. By default,
       */
      check: function check(token) {
        return this.get('validate', token.toString(), token);
      },

      // Private methods

      /**
       * Resolve an option's value based on the value of the option and the given
       * params.
       * @param {string} key - Name of option to use
       * @param operator - will be passed to the target option if it's method
       * @param {MultiToken} token - The token from linkify.tokenize
       */
      get: function get(key, operator, token) {
        let optionValue = void 0;

        const option = this[key];
        if (!option) {
          return option;
        }

        switch (typeof option === 'undefined' ? 'undefined' : _typeof(option)) {
          case 'function':
            return option(operator, token.type);
          case 'object':
            optionValue = option.hasOwnProperty(token.type) ? option[token.type] : defaults[key];
            return typeof optionValue === 'function' ? optionValue(operator, token.type) : optionValue;
        }

        return option;
      },
      getObject: function getObject(key, operator, token) {
        const option = this[key];
        return typeof option === 'function' ? option(operator, token.type) : option;
      },
    };

    /**
     * Quick indexOf replacement for checking the ignoreTags option
     */
    function contains(arr, value) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
          return true;
        }
      }
      return false;
    }

    function noop(val) {
      return val;
    }

    function typeToTarget(href, type) {
      return type === 'url' ? '_blank' : null;
    }

    const options = Object.freeze({
      defaults: defaults,
      Options: Options,
      contains: contains,
    });

    function createStateClass() {
      return function(tClass) {
        this.j = [];
        this.T = tClass || null;
      };
    }

    /**
 	A simple state machine that can emit token classes

 	The `j` property in this class refers to state jumps. It's a
 	multidimensional array where for each element:

 	* index [0] is a symbol or class of symbols to transition to.
 	* index [1] is a State instance which matches

 	The type of symbol will depend on the target implementation for this class.
 	In Linkify, we have a two-stage scanner. Each stage uses this state machine
 	but with a slighly different (polymorphic) implementation.

 	The `T` property refers to the token class.

 	TODO: Can the `on` and `next` methods be combined?

 	@class BaseState
 */
    const BaseState = createStateClass();
    BaseState.prototype = {
      defaultTransition: false,

      /**
  	@method constructor
  	@param {Class} tClass Pass in the kind of token to emit if there are
  		no jumps after this state and the state is accepting.
  */

      /**
  	On the given symbol(s), this machine should go to the given state
  		@method on
  	@param {Array|Mixed} symbol
  	@param {BaseState} state Note that the type of this state should be the
  		same as the current instance (i.e., don't pass in a different
  		subclass)
  */
      on: function on(symbol, state) {
        if (symbol instanceof Array) {
          for (let i = 0; i < symbol.length; i++) {
            this.j.push([symbol[i], state]);
          }
          return this;
        }
        this.j.push([symbol, state]);
        return this;
      },

      /**
  	Given the next item, returns next state for that item
  	@method next
  	@param {Mixed} item Should be an instance of the symbols handled by
  		this particular machine.
  	@returns {State} state Returns false if no jumps are available
  */
      next: function next(item) {
        for (let i = 0; i < this.j.length; i++) {
          const jump = this.j[i];
          const symbol = jump[0]; // Next item to check for
          const state = jump[1]; // State to jump to if items match

          // compare item with symbol
          if (this.test(item, symbol)) {
            return state;
          }
        }

        // Nowhere left to jump!
        return this.defaultTransition;
      },

      /**
  	Does this state accept?
  	`true` only of `this.T` exists
  		@method accepts
  	@returns {boolean}
  */
      accepts: function accepts() {
        return !!this.T;
      },

      /**
  	Determine whether a given item "symbolizes" the symbol, where symbol is
  	a class of items handled by this state machine.
  		This method should be overriden in extended classes.
  		@method test
  	@param {Mixed} item - Does this item match the given symbol?
  	@param {Mixed} symbol
  	@returns {boolean}
  */
      test: function test(item, symbol) {
        return item === symbol;
      },

      /**
  	Emit the token for this State (just return it in this case)
  	If this emits a token, this instance is an accepting state
  	@method emit
  	@returns {Class} T
  */
      emit: function emit() {
        return this.T;
      },
    };

    /**
 	State machine for string-based input

 	@class CharacterState
 	@extends BaseState
 */
    const CharacterState = inherits(BaseState, createStateClass(), {
      /**
  	Does the given character match the given character or regular
  	expression?
  		@method test
  	@param {string} char
  	@param {string|RegExp} charOrRegExp
  	@returns {boolean}
  */
      test: function test(character, charOrRegExp) {
        return character === charOrRegExp || (charOrRegExp instanceof RegExp && charOrRegExp.test(character));
      },
    });

    /**
 	State machine for input in the form of TextTokens

 	@class TokenState
 	@extends BaseState
 */
    const TokenState = inherits(BaseState, createStateClass(), {
      /**
       * Similar to `on`, but returns the state the results in the transition from
       * the given item
       * @method jump
       * @param {Mixed} item
       * @param {Token} [token]
       * @returns state
       */
      jump: function jump(token) {
        const tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        let state = this.next(new token('')); // dummy temp token
        if (state === this.defaultTransition) {
          // Make a new state!
          state = new this.constructor(tClass);
          this.on(token, state);
        } else if (tClass) {
          state.T = tClass;
        }
        return state;
      },

      /**
  	Is the given token an instance of the given token class?
  		@method test
  	@param {TextToken} token
  	@param {Class} tokenClass
  	@returns {boolean}
  */
      test: function test(token, tokenClass) {
        return token instanceof tokenClass;
      },
    });

    /**
 	Given a non-empty target string, generates states (if required) for each
 	consecutive substring of characters in str starting from the beginning of
 	the string. The final state will have a special value, as specified in
 	options. All other "in between" substrings will have a default end state.

 	This turns the state machine into a Trie-like data structure (rather than a
 	intelligently-designed DFA).

 	Note that I haven't really tried these with any strings other than
 	DOMAIN.

 	@param {string} str
 	@param {CharacterState} start - State to jump from the first character
 	@param {Class} endToken Token class to emit when the given string has been
 		matched and no more jumps exist.
 	@param {Class} defaultToken "Filler token", or which token type to emit when
 		we don't have a full match
 	@returns {Array} list of newly-created states
 */
    function stateify(str, start, endToken, defaultToken) {
      let i = 0;

      const len = str.length;

      let state = start;

      const newStates = [];

      let nextState = void 0;

      // Find the next state without a jump to the next character
      while (i < len && (nextState = state.next(str[i]))) {
        state = nextState;
        i++;
      }

      if (i >= len) {
        return [];
      } // no new tokens were added

      while (i < len - 1) {
        nextState = new CharacterState(defaultToken);
        newStates.push(nextState);
        state.on(str[i], nextState);
        state = nextState;
        i++;
      }

      nextState = new CharacterState(endToken);
      newStates.push(nextState);
      state.on(str[len - 1], nextState);

      return newStates;
    }

    function createTokenClass() {
      return function(value) {
        if (value) {
          this.v = value;
        }
      };
    }

    /******************************************************************************
 	Text Tokens
 	Tokens composed of strings
 ******************************************************************************/

    /**
 	Abstract class used for manufacturing text tokens.
 	Pass in the value this token represents

 	@class TextToken
 	@abstract
 */
    const TextToken = createTokenClass();
    TextToken.prototype = {
      toString: function toString() {
        return `${this.v}`;
      },
    };

    function inheritsToken(value) {
      const props = value ? {v: value} : {};
      return inherits(TextToken, createTokenClass(), props);
    }

    /**
 	A valid domain token
 	@class DOMAIN
 	@extends TextToken
 */
    const DOMAIN = inheritsToken();

    /**
 	@class AT
 	@extends TextToken
 */
    const AT = inheritsToken('@');

    /**
 	Represents a single colon `:` character

 	@class COLON
 	@extends TextToken
 */
    const COLON = inheritsToken(':');

    /**
 	@class DOT
 	@extends TextToken
 */
    const DOT = inheritsToken('.');

    /**
 	A character class that can surround the URL, but which the URL cannot begin
 	or end with. Does not include certain English punctuation like parentheses.

 	@class PUNCTUATION
 	@extends TextToken
 */
    const PUNCTUATION = inheritsToken();

    /**
 	The word localhost (by itself)
 	@class LOCALHOST
 	@extends TextToken
 */
    const LOCALHOST = inheritsToken();

    /**
 	Newline token
 	@class NL
 	@extends TextToken
 */
    const NL = inheritsToken('\n');

    /**
 	@class NUM
 	@extends TextToken
 */
    const NUM = inheritsToken();

    /**
 	@class PLUS
 	@extends TextToken
 */
    const PLUS = inheritsToken('+');

    /**
 	@class POUND
 	@extends TextToken
 */
    const POUND = inheritsToken('#');

    /**
 	Represents a web URL protocol. Supported types include

 	* `http:`
 	* `https:`
 	* `ftp:`
 	* `ftps:`

 	@class PROTOCOL
 	@extends TextToken
 */
    const PROTOCOL = inheritsToken();

    /**
 	Represents the start of the email URI protocol

 	@class MAILTO
 	@extends TextToken
 */
    const MAILTO = inheritsToken('mailto:');

    /**
 	@class QUERY
 	@extends TextToken
 */
    const QUERY = inheritsToken('?');

    /**
 	@class SLASH
 	@extends TextToken
 */
    const SLASH = inheritsToken('/');

    /**
 	@class UNDERSCORE
 	@extends TextToken
 */
    const UNDERSCORE = inheritsToken('_');

    /**
 	One ore more non-whitespace symbol.
 	@class SYM
 	@extends TextToken
 */
    const SYM = inheritsToken();

    /**
 	@class TLD
 	@extends TextToken
 */
    const TLD = inheritsToken();

    /**
 	Represents a string of consecutive whitespace characters

 	@class WS
 	@extends TextToken
 */
    const WS = inheritsToken();

    /**
 	Opening/closing bracket classes
 */

    const OPENBRACE = inheritsToken('{');
    const OPENBRACKET = inheritsToken('[');
    const OPENANGLEBRACKET = inheritsToken('<');
    const OPENPAREN = inheritsToken('(');
    const CLOSEBRACE = inheritsToken('}');
    const CLOSEBRACKET = inheritsToken(']');
    const CLOSEANGLEBRACKET = inheritsToken('>');
    const CLOSEPAREN = inheritsToken(')');

    const AMPERSAND = inheritsToken('&');

    const text = Object.freeze({
      Base: TextToken,
      DOMAIN: DOMAIN,
      AT: AT,
      COLON: COLON,
      DOT: DOT,
      PUNCTUATION: PUNCTUATION,
      LOCALHOST: LOCALHOST,
      NL: NL,
      NUM: NUM,
      PLUS: PLUS,
      POUND: POUND,
      QUERY: QUERY,
      PROTOCOL: PROTOCOL,
      MAILTO: MAILTO,
      SLASH: SLASH,
      UNDERSCORE: UNDERSCORE,
      SYM: SYM,
      TLD: TLD,
      WS: WS,
      OPENBRACE: OPENBRACE,
      OPENBRACKET: OPENBRACKET,
      OPENANGLEBRACKET: OPENANGLEBRACKET,
      OPENPAREN: OPENPAREN,
      CLOSEBRACE: CLOSEBRACE,
      CLOSEBRACKET: CLOSEBRACKET,
      CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
      CLOSEPAREN: CLOSEPAREN,
      AMPERSAND: AMPERSAND,
    });

    /**
 	The scanner provides an interface that takes a string of text as input, and
 	outputs an array of tokens instances that can be used for easy URL parsing.

 	@module linkify
 	@submodule scanner
 	@main scanner
 */

    const tlds = 'aaa|aarp|abarth|abb|abbott|abbvie|abc|able|abogado|abudhabi|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|aetna|af|afamilycompany|afl|africa|ag|agakhan|agency|ai|aig|aigo|airbus|airforce|airtel|akdn|al|alfaromeo|alibaba|alipay|allfinanz|allstate|ally|alsace|alstom|am|americanexpress|americanfamily|amex|amfam|amica|amsterdam|analytics|android|anquan|anz|ao|aol|apartments|app|apple|aq|aquarelle|ar|arab|aramco|archi|army|arpa|art|arte|as|asda|asia|associates|at|athleta|attorney|au|auction|audi|audible|audio|auspost|author|auto|autos|avianca|aw|aws|ax|axa|az|azure|ba|baby|baidu|banamex|bananarepublic|band|bank|bar|barcelona|barclaycard|barclays|barefoot|bargains|baseball|basketball|bauhaus|bayern|bb|bbc|bbt|bbva|bcg|bcn|bd|be|beats|beauty|beer|bentley|berlin|best|bestbuy|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|blanco|blockbuster|blog|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bofa|bom|bond|boo|book|booking|boots|bosch|bostik|boston|bot|boutique|box|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|calvinklein|cam|camera|camp|cancerresearch|canon|capetown|capital|capitalone|car|caravan|cards|care|career|careers|cars|cartier|casa|case|caseih|cash|casino|cat|catering|catholic|cba|cbn|cbre|cbs|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chintai|chloe|christmas|chrome|chrysler|church|ci|cipriani|circle|cisco|citadel|citi|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|comcast|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cookingchannel|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruise|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|data|date|dating|datsun|day|dclk|dds|de|deal|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|dhl|diamonds|diet|digital|direct|directory|discount|discover|dish|diy|dj|dk|dm|dnp|do|docs|doctor|dodge|dog|doha|domains|dot|download|drive|dtv|dubai|duck|dunlop|duns|dupont|durban|dvag|dvr|dz|earth|eat|ec|eco|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epost|epson|equipment|er|ericsson|erni|es|esq|estate|esurance|et|etisalat|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|extraspace|fage|fail|fairwinds|faith|family|fan|fans|farm|farmers|fashion|fast|fedex|feedback|ferrari|ferrero|fi|fiat|fidelity|fido|film|final|finance|financial|fire|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|flir|florist|flowers|fly|fm|fo|foo|food|foodnetwork|football|ford|forex|forsale|forum|foundation|fox|fr|free|fresenius|frl|frogans|frontdoor|frontier|ftr|fujitsu|fujixerox|fun|fund|furniture|futbol|fyi|ga|gal|gallery|gallo|gallup|game|games|gap|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|george|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glade|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|godaddy|gold|goldpoint|golf|goo|goodhands|goodyear|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|grocery|group|gs|gt|gu|guardian|gucci|guge|guide|guitars|guru|gw|gy|hair|hamburg|hangout|haus|hbo|hdfc|hdfcbank|health|healthcare|help|helsinki|here|hermes|hgtv|hiphop|hisamitsu|hitachi|hiv|hk|hkt|hm|hn|hockey|holdings|holiday|homedepot|homegoods|homes|homesense|honda|honeywell|horse|hospital|host|hosting|hot|hoteles|hotels|hotmail|house|how|hr|hsbc|ht|htc|hu|hughes|hyatt|hyundai|ibm|icbc|ice|icu|id|ie|ieee|ifm|ikano|il|im|imamat|imdb|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|intel|international|intuit|investments|io|ipiranga|iq|ir|irish|is|iselect|ismaili|ist|istanbul|it|itau|itv|iveco|iwc|jaguar|java|jcb|jcp|je|jeep|jetzt|jewelry|jio|jlc|jll|jm|jmp|jnj|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|juniper|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kindle|kitchen|kiwi|km|kn|koeln|komatsu|kosher|kp|kpmg|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|ladbrokes|lamborghini|lamer|lancaster|lancia|lancome|land|landrover|lanxess|lasalle|lat|latino|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|lefrak|legal|lego|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|lilly|limited|limo|lincoln|linde|link|lipsy|live|living|lixil|lk|loan|loans|locker|locus|loft|lol|london|lotte|lotto|love|lpl|lplfinancial|lr|ls|lt|ltd|ltda|lu|lundbeck|lupin|luxe|luxury|lv|ly|ma|macys|madrid|maif|maison|makeup|man|management|mango|map|market|marketing|markets|marriott|marshalls|maserati|mattel|mba|mc|mckinsey|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|merckmsd|metlife|mg|mh|miami|microsoft|mil|mini|mint|mit|mitsubishi|mk|ml|mlb|mls|mm|mma|mn|mo|mobi|mobile|mobily|moda|moe|moi|mom|monash|money|monster|mopar|mormon|mortgage|moscow|moto|motorcycles|mov|movie|movistar|mp|mq|mr|ms|msd|mt|mtn|mtr|mu|museum|mutual|mv|mw|mx|my|mz|na|nab|nadex|nagoya|name|nationwide|natura|navy|nba|nc|ne|nec|net|netbank|netflix|network|neustar|new|newholland|news|next|nextdirect|nexus|nf|nfl|ng|ngo|nhk|ni|nico|nike|nikon|ninja|nissan|nissay|nl|no|nokia|northwesternmutual|norton|now|nowruz|nowtv|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|observer|off|office|okinawa|olayan|olayangroup|oldnavy|ollo|om|omega|one|ong|onl|online|onyourside|ooo|open|oracle|orange|org|organic|origins|osaka|otsuka|ott|ovh|pa|page|panasonic|panerai|paris|pars|partners|parts|party|passagens|pay|pccw|pe|pet|pf|pfizer|pg|ph|pharmacy|phd|philips|phone|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pioneer|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pnc|pohl|poker|politie|porn|post|pr|pramerica|praxi|press|prime|pro|prod|productions|prof|progressive|promo|properties|property|protection|pru|prudential|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|qvc|racing|radio|raid|re|read|realestate|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|reliance|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|richardli|ricoh|rightathome|ril|rio|rip|rmit|ro|rocher|rocks|rodeo|rogers|room|rs|rsvp|ru|rugby|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsclub|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|save|saxo|sb|sbi|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scjohnson|scor|scot|sd|se|search|seat|secure|security|seek|select|sener|services|ses|seven|sew|sex|sexy|sfr|sg|sh|shangrila|sharp|shaw|shell|shia|shiksha|shoes|shop|shopping|shouji|show|showtime|shriram|si|silk|sina|singles|site|sj|sk|ski|skin|sky|skype|sl|sling|sm|smart|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|srt|st|stada|staples|star|starhub|statebank|statefarm|statoil|stc|stcgroup|stockholm|storage|store|stream|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiftcover|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|talk|taobao|target|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|tdk|team|tech|technology|tel|telecity|telefonica|temasek|tennis|teva|tf|tg|th|thd|theater|theatre|tiaa|tickets|tienda|tiffany|tips|tires|tirol|tj|tjmaxx|tjx|tk|tkmaxx|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tr|trade|trading|training|travel|travelchannel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubank|ubs|uconnect|ug|uk|unicom|university|uno|uol|ups|us|uy|uz|va|vacations|vana|vanguard|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|vig|viking|villas|vin|vip|virgin|visa|vision|vista|vistaprint|viva|vivo|vlaanderen|vn|vodka|volkswagen|volvo|vote|voting|voto|voyage|vu|vuelos|wales|walmart|walter|wang|wanggou|warman|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weibo|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|winners|wme|wolterskluwer|woodside|work|works|world|wow|ws|wtc|wtf|xbox|xerox|xfinity|xihuan|xin|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--30rr7y|xn--3bst00m|xn--3ds443g|xn--3e0b707e|xn--3hcrj9c|xn--3oq18vl8pn36a|xn--3pxu8k|xn--42c2d9a|xn--45br5cyl|xn--45brj9c|xn--45q11c|xn--4gbrim|xn--54b7fta0cc|xn--55qw42g|xn--55qx5d|xn--5su34j936bgsg|xn--5tzm5g|xn--6frz82g|xn--6qq986b3xl|xn--80adxhks|xn--80ao21a|xn--80aqecdr1a|xn--80asehdb|xn--80aswg|xn--8y0a063a|xn--90a3ac|xn--90ae|xn--90ais|xn--9dbq2a|xn--9et52u|xn--9krt00a|xn--b4w605ferd|xn--bck1b9a5dre4c|xn--c1avg|xn--c2br7g|xn--cck2b3b|xn--cg4bki|xn--clchc0ea0b2g2a9gcd|xn--czr694b|xn--czrs0t|xn--czru2d|xn--d1acj3b|xn--d1alf|xn--e1a4c|xn--eckvdtc9d|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fhbei|xn--fiq228c5hs|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--fjq720a|xn--flw351e|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--fzys8d69uvgm|xn--g2xx48c|xn--gckr3f0f|xn--gecrj9c|xn--gk3at1e|xn--h2breg3eve|xn--h2brj9c|xn--h2brj9c8c|xn--hxt814e|xn--i1b6b1a6a2e|xn--imr513n|xn--io0a7i|xn--j1aef|xn--j1amh|xn--j6w193g|xn--jlq61u9w7b|xn--jvr189m|xn--kcrx77d1x4a|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--kput3i|xn--l1acc|xn--lgbbat1ad8j|xn--mgb9awbf|xn--mgba3a3ejt|xn--mgba3a4f16a|xn--mgba7c0bbn0a|xn--mgbaakc7dvf|xn--mgbaam7a8h|xn--mgbab2bd|xn--mgbai9azgqp6j|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a|xn--mgbbh1a71e|xn--mgbc0a9azcg|xn--mgbca7dzdo|xn--mgberp4a5d4ar|xn--mgbgu82a|xn--mgbi4ecexp|xn--mgbpl2fh|xn--mgbt3dhd|xn--mgbtx2b|xn--mgbx4cd0ab|xn--mix891f|xn--mk1bu44c|xn--mxtq1m|xn--ngbc5azd|xn--ngbe9e0a|xn--ngbrx|xn--node|xn--nqv7f|xn--nqv7fs00ema|xn--nyqy26a|xn--o3cw4h|xn--ogbpf8fl|xn--p1acf|xn--p1ai|xn--pbt977c|xn--pgbs0dh|xn--pssy2u|xn--q9jyb4c|xn--qcka1pmc|xn--qxam|xn--rhqv96g|xn--rovu88b|xn--rvc1e0am3e|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--tckwe|xn--tiq49xqyj|xn--unup4y|xn--vermgensberater-ctb|xn--vermgensberatung-pwb|xn--vhquv|xn--vuq861b|xn--w4r85el8fhu5dnra|xn--w4rs40l|xn--wgbh1c|xn--wgbl6a|xn--xhq521b|xn--xkc2al3hye2a|xn--xkc2dl3a5ee0h|xn--y9a3aq|xn--yfro4i67o|xn--ygbi2ammx|xn--zfr164b|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|you|youtube|yt|yun|za|zappos|zara|zero|zip|zippo|zm|zone|zuerich|zw'.split(
      '|'
    ); // macro, see gulpfile.js

    const NUMBERS = '0123456789'.split('');
    const ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
    const WHITESPACE = [' ', '\f', '\r', '\t', '\v', '\xA0', '\u1680', '\u180E']; // excluding line breaks

    const domainStates = []; // states that jump to DOMAIN on /[a-z0-9]/
    const makeState = function makeState(tokenClass) {
      return new CharacterState(tokenClass);
    };

    // Frequently used states
    const S_START = makeState();
    const S_NUM = makeState(NUM);
    const S_DOMAIN = makeState(DOMAIN);
    const S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters
    const S_WS = makeState(WS);

    // States for special URL symbols
    S_START.on('@', makeState(AT))
      .on('.', makeState(DOT))
      .on('+', makeState(PLUS))
      .on('#', makeState(POUND))
      .on('?', makeState(QUERY))
      .on('/', makeState(SLASH))
      .on('_', makeState(UNDERSCORE))
      .on(':', makeState(COLON))
      .on('{', makeState(OPENBRACE))
      .on('[', makeState(OPENBRACKET))
      .on('<', makeState(OPENANGLEBRACKET))
      .on('(', makeState(OPENPAREN))
      .on('}', makeState(CLOSEBRACE))
      .on(']', makeState(CLOSEBRACKET))
      .on('>', makeState(CLOSEANGLEBRACKET))
      .on(')', makeState(CLOSEPAREN))
      .on('&', makeState(AMPERSAND))
      .on([',', ';', '!', '"', "'"], makeState(PUNCTUATION));

    // Whitespace jumps
    // Tokens of only non-newline whitespace are arbitrarily long
    S_START.on('\n', makeState(NL)).on(WHITESPACE, S_WS);

    // If any whitespace except newline, more whitespace!
    S_WS.on(WHITESPACE, S_WS);

    // Generates states for top-level domains
    // Note that this is most accurate when tlds are in alphabetical order
    for (let i = 0; i < tlds.length; i++) {
      const newStates = stateify(tlds[i], S_START, TLD, DOMAIN);
      domainStates.push(...newStates);
    }

    // Collect the states generated by different protocls
    const partialProtocolFileStates = stateify('file', S_START, DOMAIN, DOMAIN);
    const partialProtocolFtpStates = stateify('ftp', S_START, DOMAIN, DOMAIN);
    const partialProtocolHttpStates = stateify('http', S_START, DOMAIN, DOMAIN);
    const partialProtocolMailtoStates = stateify('mailto', S_START, DOMAIN, DOMAIN);

    // Add the states to the array of DOMAINeric states
    domainStates.push(...partialProtocolFileStates);
    domainStates.push(...partialProtocolFtpStates);
    domainStates.push(...partialProtocolHttpStates);
    domainStates.push(...partialProtocolMailtoStates);

    // Protocol states
    const S_PROTOCOL_FILE = partialProtocolFileStates.pop();
    const S_PROTOCOL_FTP = partialProtocolFtpStates.pop();
    const S_PROTOCOL_HTTP = partialProtocolHttpStates.pop();
    const S_MAILTO = partialProtocolMailtoStates.pop();
    const S_PROTOCOL_SECURE = makeState(DOMAIN);
    const S_FULL_PROTOCOL = makeState(PROTOCOL); // Full protocol ends with COLON
    const S_FULL_MAILTO = makeState(MAILTO); // Mailto ends with COLON

    // Secure protocols (end with 's')
    S_PROTOCOL_FTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

    S_PROTOCOL_HTTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

    domainStates.push(S_PROTOCOL_SECURE);

    // Become protocol tokens after a COLON
    S_PROTOCOL_FILE.on(':', S_FULL_PROTOCOL);
    S_PROTOCOL_SECURE.on(':', S_FULL_PROTOCOL);
    S_MAILTO.on(':', S_FULL_MAILTO);

    // Localhost
    const partialLocalhostStates = stateify('localhost', S_START, LOCALHOST, DOMAIN);
    domainStates.push(...partialLocalhostStates);

    // Everything else
    // DOMAINs make more DOMAINs
    // Number and character transitions
    S_START.on(NUMBERS, S_NUM);
    S_NUM.on('-', S_DOMAIN_HYPHEN)
      .on(NUMBERS, S_NUM)
      .on(ALPHANUM, S_DOMAIN); // number becomes DOMAIN

    S_DOMAIN.on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);

    // All the generated states should have a jump to DOMAIN
    for (let _i = 0; _i < domainStates.length; _i++) {
      domainStates[_i].on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
    }

    S_DOMAIN_HYPHEN.on('-', S_DOMAIN_HYPHEN)
      .on(NUMBERS, S_DOMAIN)
      .on(ALPHANUM, S_DOMAIN);

    // Set default transition
    S_START.defaultTransition = makeState(SYM);

    /**
 	Given a string, returns an array of TOKEN instances representing the
 	composition of that string.

 	@method run
 	@param {string} str - Input string to scan
 	@returns {Array} Array of TOKEN instances
 */
    const run = function run(str) {
      // The state machine only looks at lowercase strings.
      // This selective `toLowerCase` is used because lowercasing the entire
      // string causes the length and character position to vary in some in some
      // non-English strings. This happens only on V8-based runtimes.
      const lowerStr = str.replace(/[A-Z]/g, c => {
        return c.toLowerCase();
      });
      const len = str.length;
      const tokens = []; // return value

      let cursor = 0;

      // Tokenize the string
      while (cursor < len) {
        let state = S_START;
        let nextState = null;
        let tokenLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;

        while (cursor < len && (nextState = state.next(lowerStr[cursor]))) {
          state = nextState;

          // Keep track of the latest accepting state
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }

          tokenLength++;
          cursor++;
        }

        if (sinceAccepts < 0) {
          continue;
        } // Should never happen

        // Roll back to the latest accepting state
        cursor -= sinceAccepts;
        tokenLength -= sinceAccepts;

        // Get the class for the new token
        const TOKEN = latestAccepting.emit(); // Current token class

        // No more jumps, just make a new token
        tokens.push(new TOKEN(str.substr(cursor - tokenLength, tokenLength)));
      }

      return tokens;
    };

    const start = S_START;

    const scanner = Object.freeze({
      State: CharacterState,
      TOKENS: text,
      run: run,
      start: start,
    });

    /******************************************************************************
 	Multi-Tokens
 	Tokens composed of arrays of TextTokens
 ******************************************************************************/

    // Is the given token a valid domain token?
    // Should nums be included here?
    function isDomainToken(token) {
      return token instanceof DOMAIN || token instanceof TLD;
    }

    /**
 	Abstract class used for manufacturing tokens of text tokens. That is rather
 	than the value for a token being a small string of text, it's value an array
 	of text tokens.

 	Used for grouping together URLs, emails, hashtags, and other potential
 	creations.

 	@class MultiToken
 	@abstract
 */
    const MultiToken = createTokenClass();

    MultiToken.prototype = {
      /**
  	String representing the type for this token
  	@property type
  	@default 'TOKEN'
  */
      type: 'token',

      /**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
      isLink: false,

      /**
  	Return the string this token represents.
  	@method toString
  	@returns {string}
  */
      toString: function toString() {
        const result = [];
        for (let _i2 = 0; _i2 < this.v.length; _i2++) {
          result.push(this.v[_i2].toString());
        }
        return result.join('');
      },

      /**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@returns {string}
  */
      toHref: function toHref() {
        return this.toString();
      },

      /**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] - `'http'` by default
  	@returns {Object}
  */
      toObject: function toObject() {
        const protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

        return {
          type: this.type,
          value: this.toString(),
          href: this.toHref(protocol),
        };
      },
    };

    /**
 	Represents an arbitrarily mailto email address with the prefix included
 	@class MAILTO
 	@extends MultiToken
 */
    const MAILTOEMAIL = inherits(MultiToken, createTokenClass(), {
      type: 'email',
      isLink: true,
    });

    /**
 	Represents a list of tokens making up a valid email address
 	@class EMAIL
 	@extends MultiToken
 */
    const EMAIL = inherits(MultiToken, createTokenClass(), {
      type: 'email',
      isLink: true,
      toHref: function toHref() {
        return `mailto:${this.toString()}`;
      },
    });

    /**
 	Represents some plain text
 	@class TEXT
 	@extends MultiToken
 */
    const TEXT = inherits(MultiToken, createTokenClass(), {type: 'text'});

    /**
 	Multi-linebreak token - represents a line break
 	@class NL
 	@extends MultiToken
 */
    const NL$1 = inherits(MultiToken, createTokenClass(), {type: 'nl'});

    /**
 	Represents a list of tokens making up a valid URL
 	@class URL
 	@extends MultiToken
 */
    const URL = inherits(MultiToken, createTokenClass(), {
      type: 'url',
      isLink: true,

      /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@returns {string}
  */
      toHref: function toHref() {
        const protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

        let hasProtocol = false;
        let hasSlashSlash = false;
        const tokens = this.v;
        let result = [];
        let i = 0;

        // Make the first part of the domain lowercase
        // Lowercase protocol
        while (tokens[i] instanceof PROTOCOL) {
          hasProtocol = true;
          result.push(tokens[i].toString().toLowerCase());
          i++;
        }

        // Skip slash-slash
        while (tokens[i] instanceof SLASH) {
          hasSlashSlash = true;
          result.push(tokens[i].toString());
          i++;
        }

        // Lowercase all other characters in the domain
        while (isDomainToken(tokens[i])) {
          result.push(tokens[i].toString().toLowerCase());
          i++;
        }

        // Leave all other characters as they were written
        for (; i < tokens.length; i++) {
          result.push(tokens[i].toString());
        }

        result = result.join('');

        if (!(hasProtocol || hasSlashSlash)) {
          result = `${protocol}://${result}`;
        }

        return result;
      },
      hasProtocol: function hasProtocol() {
        return this.v[0] instanceof PROTOCOL;
      },
    });

    const multi = Object.freeze({
      Base: MultiToken,
      MAILTOEMAIL: MAILTOEMAIL,
      EMAIL: EMAIL,
      NL: NL$1,
      TEXT: TEXT,
      URL: URL,
    });

    /**
 	Not exactly parser, more like the second-stage scanner (although we can
 	theoretically hotswap the code here with a real parser in the future... but
 	for a little URL-finding utility abstract syntax trees may be a little
 	overkill).

 	URL format: http://en.wikipedia.org/wiki/URI_scheme
 	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
 	reference)

 	@module linkify
 	@submodule parser
 	@main parser
 */

    const makeState$1 = function makeState$1(tokenClass) {
      return new TokenState(tokenClass);
    };

    // The universal starting state.
    const S_START$1 = makeState$1();

    // Intermediate states for URLs. Note that domains that begin with a protocol
    // are treated slighly differently from those that don't.
    const S_PROTOCOL = makeState$1(); // e.g., 'http:'
    const S_MAILTO$1 = makeState$1(); // 'mailto:'
    const S_PROTOCOL_SLASH = makeState$1(); // e.g., '/', 'http:/''
    const S_PROTOCOL_SLASH_SLASH = makeState$1(); // e.g., '//', 'http://'
    const S_DOMAIN$1 = makeState$1(); // parsed string ends with a potential domain name (A)
    const S_DOMAIN_DOT = makeState$1(); // (A) domain followed by DOT
    const S_TLD = makeState$1(URL); // (A) Simplest possible URL with no query string
    const S_TLD_COLON = makeState$1(); // (A) URL followed by colon (potential port number here)
    const S_TLD_PORT = makeState$1(URL); // TLD followed by a port number
    const S_URL = makeState$1(URL); // Long URL with optional port and maybe query string
    const S_URL_NON_ACCEPTING = makeState$1(); // URL followed by some symbols (will not be part of the final URL)
    const S_URL_OPENBRACE = makeState$1(); // URL followed by {
    const S_URL_OPENBRACKET = makeState$1(); // URL followed by [
    const S_URL_OPENANGLEBRACKET = makeState$1(); // URL followed by <
    const S_URL_OPENPAREN = makeState$1(); // URL followed by (
    const S_URL_OPENBRACE_Q = makeState$1(URL); // URL followed by { and some symbols that the URL can end it
    const S_URL_OPENBRACKET_Q = makeState$1(URL); // URL followed by [ and some symbols that the URL can end it
    const S_URL_OPENANGLEBRACKET_Q = makeState$1(URL); // URL followed by < and some symbols that the URL can end it
    const S_URL_OPENPAREN_Q = makeState$1(URL); // URL followed by ( and some symbols that the URL can end it
    const S_URL_OPENBRACE_SYMS = makeState$1(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it
    const S_URL_OPENBRACKET_SYMS = makeState$1(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it
    const S_URL_OPENANGLEBRACKET_SYMS = makeState$1(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it
    const S_URL_OPENPAREN_SYMS = makeState$1(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it
    const S_EMAIL_DOMAIN = makeState$1(); // parsed string starts with local email info + @ with a potential domain name (C)
    const S_EMAIL_DOMAIN_DOT = makeState$1(); // (C) domain followed by DOT
    const S_EMAIL = makeState$1(EMAIL); // (C) Possible email address (could have more tlds)
    const S_EMAIL_COLON = makeState$1(); // (C) URL followed by colon (potential port number here)
    const S_EMAIL_PORT = makeState$1(EMAIL); // (C) Email address with a port
    const S_MAILTO_EMAIL = makeState$1(MAILTOEMAIL); // Email that begins with the mailto prefix (D)
    const S_MAILTO_EMAIL_NON_ACCEPTING = makeState$1(); // (D) Followed by some non-query string chars
    const S_LOCALPART = makeState$1(); // Local part of the email address
    const S_LOCALPART_AT = makeState$1(); // Local part of the email address plus @
    const S_LOCALPART_DOT = makeState$1(); // Local part of the email address plus '.' (localpart cannot end in .)
    const S_NL = makeState$1(NL$1); // single new line

    // Make path from start to protocol (with '//')
    S_START$1.on(NL, S_NL)
      .on(PROTOCOL, S_PROTOCOL)
      .on(MAILTO, S_MAILTO$1)
      .on(SLASH, S_PROTOCOL_SLASH);

    S_PROTOCOL.on(SLASH, S_PROTOCOL_SLASH);
    S_PROTOCOL_SLASH.on(SLASH, S_PROTOCOL_SLASH_SLASH);

    // The very first potential domain name
    S_START$1.on(TLD, S_DOMAIN$1)
      .on(DOMAIN, S_DOMAIN$1)
      .on(LOCALHOST, S_TLD)
      .on(NUM, S_DOMAIN$1);

    // Force URL for protocol followed by anything sane
    S_PROTOCOL_SLASH_SLASH.on(TLD, S_URL)
      .on(DOMAIN, S_URL)
      .on(NUM, S_URL)
      .on(LOCALHOST, S_URL);

    // Account for dots and hyphens
    // hyphens are usually parts of domain names
    S_DOMAIN$1.on(DOT, S_DOMAIN_DOT);
    S_EMAIL_DOMAIN.on(DOT, S_EMAIL_DOMAIN_DOT);

    // Hyphen can jump back to a domain name

    // After the first domain and a dot, we can find either a URL or another domain
    S_DOMAIN_DOT.on(TLD, S_TLD)
      .on(DOMAIN, S_DOMAIN$1)
      .on(NUM, S_DOMAIN$1)
      .on(LOCALHOST, S_DOMAIN$1);

    S_EMAIL_DOMAIN_DOT.on(TLD, S_EMAIL)
      .on(DOMAIN, S_EMAIL_DOMAIN)
      .on(NUM, S_EMAIL_DOMAIN)
      .on(LOCALHOST, S_EMAIL_DOMAIN);

    // S_TLD accepts! But the URL could be longer, try to find a match greedily
    // The `run` function should be able to "rollback" to the accepting state
    S_TLD.on(DOT, S_DOMAIN_DOT);
    S_EMAIL.on(DOT, S_EMAIL_DOMAIN_DOT);

    // Become real URLs after `SLASH` or `COLON NUM SLASH`
    // Here PSS and non-PSS converge
    S_TLD.on(COLON, S_TLD_COLON).on(SLASH, S_URL);
    S_TLD_COLON.on(NUM, S_TLD_PORT);
    S_TLD_PORT.on(SLASH, S_URL);
    S_EMAIL.on(COLON, S_EMAIL_COLON);
    S_EMAIL_COLON.on(NUM, S_EMAIL_PORT);

    // Types of characters the URL can definitely end in
    const qsAccepting = [DOMAIN, AT, LOCALHOST, NUM, PLUS, POUND, PROTOCOL, SLASH, TLD, UNDERSCORE, SYM, AMPERSAND];

    // Types of tokens that can follow a URL and be part of the query string
    // but cannot be the very last characters
    // Characters that cannot appear in the URL at all should be excluded
    const qsNonAccepting = [
      COLON,
      DOT,
      QUERY,
      PUNCTUATION,
      CLOSEBRACE,
      CLOSEBRACKET,
      CLOSEANGLEBRACKET,
      CLOSEPAREN,
      OPENBRACE,
      OPENBRACKET,
      OPENANGLEBRACKET,
      OPENPAREN,
    ];

    // These states are responsible primarily for determining whether or not to
    // include the final round bracket.

    // URL, followed by an opening bracket
    S_URL.on(OPENBRACE, S_URL_OPENBRACE)
      .on(OPENBRACKET, S_URL_OPENBRACKET)
      .on(OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET)
      .on(OPENPAREN, S_URL_OPENPAREN);

    // URL with extra symbols at the end, followed by an opening bracket
    S_URL_NON_ACCEPTING.on(OPENBRACE, S_URL_OPENBRACE)
      .on(OPENBRACKET, S_URL_OPENBRACKET)
      .on(OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET)
      .on(OPENPAREN, S_URL_OPENPAREN);

    // Closing bracket component. This character WILL be included in the URL
    S_URL_OPENBRACE.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN.on(CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_Q.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_Q.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_Q.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_Q.on(CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_SYMS.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_SYMS.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_SYMS.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_SYMS.on(CLOSEPAREN, S_URL);

    // URL that beings with an opening bracket, followed by a symbols.
    // Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
    // has a single opening bracket for some reason).
    S_URL_OPENBRACE.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

    // URL that begins with an opening bracket, followed by some symbols
    S_URL_OPENBRACE_Q.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_Q.on(qsNonAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsNonAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsNonAccepting, S_URL_OPENPAREN_Q);

    S_URL_OPENBRACE_SYMS.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_SYMS.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_SYMS.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_SYMS.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN_SYMS.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

    // Account for the query string
    S_URL.on(qsAccepting, S_URL);
    S_URL_NON_ACCEPTING.on(qsAccepting, S_URL);

    S_URL.on(qsNonAccepting, S_URL_NON_ACCEPTING);
    S_URL_NON_ACCEPTING.on(qsNonAccepting, S_URL_NON_ACCEPTING);

    // Email address-specific state definitions
    // Note: We are not allowing '/' in email addresses since this would interfere
    // with real URLs

    // For addresses with the mailto prefix
    // 'mailto:' followed by anything sane is a valid email
    S_MAILTO$1.on(TLD, S_MAILTO_EMAIL)
      .on(DOMAIN, S_MAILTO_EMAIL)
      .on(NUM, S_MAILTO_EMAIL)
      .on(LOCALHOST, S_MAILTO_EMAIL);

    // Greedily get more potential valid email values
    S_MAILTO_EMAIL.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    S_MAILTO_EMAIL_NON_ACCEPTING.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);

    // For addresses without the mailto prefix
    // Tokens allowed in the localpart of the email
    const localpartAccepting = [DOMAIN, NUM, PLUS, POUND, QUERY, UNDERSCORE, SYM, AMPERSAND, TLD];

    // Some of the tokens in `localpartAccepting` are already accounted for here and
    // will not be overwritten (don't worry)
    S_DOMAIN$1.on(localpartAccepting, S_LOCALPART).on(AT, S_LOCALPART_AT);
    S_TLD.on(localpartAccepting, S_LOCALPART).on(AT, S_LOCALPART_AT);
    S_DOMAIN_DOT.on(localpartAccepting, S_LOCALPART);

    // Okay we're on a localpart. Now what?
    // TODO: IP addresses and what if the email starts with numbers?
    S_LOCALPART.on(localpartAccepting, S_LOCALPART)
      .on(AT, S_LOCALPART_AT) // close to an email address now
      .on(DOT, S_LOCALPART_DOT);
    S_LOCALPART_DOT.on(localpartAccepting, S_LOCALPART);
    S_LOCALPART_AT.on(TLD, S_EMAIL_DOMAIN)
      .on(DOMAIN, S_EMAIL_DOMAIN)
      .on(LOCALHOST, S_EMAIL);
    // States following `@` defined above

    const run$1 = function run$1(tokens) {
      const len = tokens.length;
      let cursor = 0;
      const multis = [];
      let textTokens = [];

      while (cursor < len) {
        let state = S_START$1;
        let secondState = null;
        let nextState = null;
        let multiLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;

        while (cursor < len && !(secondState = state.next(tokens[cursor]))) {
          // Starting tokens with nowhere to jump to.
          // Consider these to be just plain text
          textTokens.push(tokens[cursor++]);
        }

        while (cursor < len && (nextState = secondState || state.next(tokens[cursor]))) {
          // Get the next state
          secondState = null;
          state = nextState;

          // Keep track of the latest accepting state
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }

          cursor++;
          multiLength++;
        }

        if (sinceAccepts < 0) {
          // No accepting state was found, part of a regular text token
          // Add all the tokens we looked at to the text tokens array
          for (let _i3 = cursor - multiLength; _i3 < cursor; _i3++) {
            textTokens.push(tokens[_i3]);
          }
        } else {
          // Accepting state!

          // First close off the textTokens (if available)
          if (textTokens.length > 0) {
            multis.push(new TEXT(textTokens));
            textTokens = [];
          }

          // Roll back to the latest accepting state
          cursor -= sinceAccepts;
          multiLength -= sinceAccepts;

          // Create a new multitoken
          const MULTI = latestAccepting.emit();
          multis.push(new MULTI(tokens.slice(cursor - multiLength, cursor)));
        }
      }

      // Finally close off the textTokens (if available)
      if (textTokens.length > 0) {
        multis.push(new TEXT(textTokens));
      }

      return multis;
    };

    const parser = Object.freeze({
      State: TokenState,
      TOKENS: multi,
      run: run$1,
      start: S_START$1,
    });

    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      };
    }

    /**
 	Converts a string into tokens that represent linkable and non-linkable bits
 	@method tokenize
 	@param {string} str
 	@returns {Array} tokens
 */
    const tokenize = function tokenize(str) {
      return run$1(run(str));
    };

    /**
 	Returns a list of linkable items in the given string.
 */
    const find = function find(str) {
      const type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      const tokens = tokenize(str);
      const filtered = [];

      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.isLink && (!type || token.type === type)) {
          filtered.push(token.toObject());
        }
      }

      return filtered;
    };

    /**
 	Is the given string valid linkable text of some sort
 	Note that this does not trim the text for you.

 	Optionally pass in a second `type` param, which is the type of link to test
 	for.

 	For example,

 		test(str, 'email');

 	Will return `true` if str is a valid email.
 */
    const test = function test(str) {
      const type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      const tokens = tokenize(str);
      return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].type === type);
    };

    exports.find = find;
    exports.inherits = inherits;
    exports.options = options;
    exports.parser = parser;
    exports.scanner = scanner;
    exports.test = test;
    exports.tokenize = tokenize;
  })((self.linkify = self.linkify || {}));
})();

/* eslint-disable */
'use strict';

(function(window, linkify) {
  const linkifyHtml = (function(linkify) {
    'use strict';

    const HTML5NamedCharRefs = {
      // We don't need the complete named character reference because linkifyHtml
      // does not modify the escape sequences. We do need &nbsp; so that
      // whitespace is parsed properly. Other types of whitespace should already
      // be accounted for
      nbsp: '\xA0',
    };

    function EntityParser(named) {
      this.named = named;
    }

    const HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    const CHARCODE = /^#([0-9]+)$/;
    const NAMED = /^([A-Za-z0-9]+)$/;

    EntityParser.prototype.parse = function(entity) {
      if (!entity) {
        return;
      }
      let matches = entity.match(HEXCHARCODE);
      if (matches) {
        return `&#x${matches[1]};`;
      }
      matches = entity.match(CHARCODE);
      if (matches) {
        return `&#${matches[1]};`;
      }
      matches = entity.match(NAMED);
      if (matches) {
        return this.named[matches[1]] || `&${matches[1]};`;
      }
    };

    const WSP = /[\t\n\f ]/;
    const ALPHA = /[A-Za-z]/;
    const CRLF = /\r\n?/g;

    function isSpace(char) {
      return WSP.test(char);
    }

    function isAlpha(char) {
      return ALPHA.test(char);
    }

    function preprocessInput(input) {
      return input.replace(CRLF, '\n');
    }

    function EventedTokenizer(delegate, entityParser) {
      this.delegate = delegate;
      this.entityParser = entityParser;

      this.state = null;
      this.input = null;

      this.index = -1;
      this.line = -1;
      this.column = -1;
      this.tagLine = -1;
      this.tagColumn = -1;

      this.reset();
    }

    EventedTokenizer.prototype = {
      reset: function reset() {
        this.state = 'beforeData';
        this.input = '';

        this.index = 0;
        this.line = 1;
        this.column = 0;

        this.tagLine = -1;
        this.tagColumn = -1;

        this.delegate.reset();
      },

      tokenize: function tokenize(input) {
        this.reset();
        this.tokenizePart(input);
        this.tokenizeEOF();
      },

      tokenizePart: function tokenizePart(input) {
        this.input += preprocessInput(input);

        while (this.index < this.input.length) {
          this.states[this.state].call(this);
        }
      },

      tokenizeEOF: function tokenizeEOF() {
        this.flushData();
      },

      flushData: function flushData() {
        if (this.state === 'data') {
          this.delegate.finishData();
          this.state = 'beforeData';
        }
      },

      peek: function peek() {
        return this.input.charAt(this.index);
      },

      consume: function consume() {
        const char = this.peek();

        this.index++;

        if (char === '\n') {
          this.line++;
          this.column = 0;
        } else {
          this.column++;
        }

        return char;
      },

      consumeCharRef: function consumeCharRef() {
        const endIndex = this.input.indexOf(';', this.index);
        if (endIndex === -1) {
          return;
        }
        const entity = this.input.slice(this.index, endIndex);
        const chars = this.entityParser.parse(entity);
        if (chars) {
          let count = entity.length;
          // consume the entity chars
          while (count) {
            this.consume();
            count--;
          }
          // consume the `;`
          this.consume();

          return chars;
        }
      },

      markTagStart: function markTagStart() {
        // these properties to be removed in next major bump
        this.tagLine = this.line;
        this.tagColumn = this.column;

        if (this.delegate.tagOpen) {
          this.delegate.tagOpen();
        }
      },

      states: {
        beforeData: function beforeData() {
          const char = this.peek();

          if (char === '<') {
            this.state = 'tagOpen';
            this.markTagStart();
            this.consume();
          } else {
            this.state = 'data';
            this.delegate.beginData();
          }
        },

        data: function data() {
          const char = this.peek();

          if (char === '<') {
            this.delegate.finishData();
            this.state = 'tagOpen';
            this.markTagStart();
            this.consume();
          } else if (char === '&') {
            this.consume();
            this.delegate.appendToData(this.consumeCharRef() || '&');
          } else {
            this.consume();
            this.delegate.appendToData(char);
          }
        },

        tagOpen: function tagOpen() {
          const char = this.consume();

          if (char === '!') {
            this.state = 'markupDeclaration';
          } else if (char === '/') {
            this.state = 'endTagOpen';
          } else if (isAlpha(char)) {
            this.state = 'tagName';
            this.delegate.beginStartTag();
            this.delegate.appendToTagName(char.toLowerCase());
          }
        },

        markupDeclaration: function markupDeclaration() {
          const char = this.consume();

          if (char === '-' && this.input.charAt(this.index) === '-') {
            this.consume();
            this.state = 'commentStart';
            this.delegate.beginComment();
          }
        },

        commentStart: function commentStart() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentStartDash';
          } else if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData(char);
            this.state = 'comment';
          }
        },

        commentStartDash: function commentStartDash() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEnd';
          } else if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData('-');
            this.state = 'comment';
          }
        },

        comment: function comment() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEndDash';
          } else {
            this.delegate.appendToCommentData(char);
          }
        },

        commentEndDash: function commentEndDash() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEnd';
          } else {
            this.delegate.appendToCommentData(`-${char}`);
            this.state = 'comment';
          }
        },

        commentEnd: function commentEnd() {
          const char = this.consume();

          if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData(`--${char}`);
            this.state = 'comment';
          }
        },

        tagName: function tagName() {
          const char = this.consume();

          if (isSpace(char)) {
            this.state = 'beforeAttributeName';
          } else if (char === '/') {
            this.state = 'selfClosingStartTag';
          } else if (char === '>') {
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToTagName(char);
          }
        },

        beforeAttributeName: function beforeAttributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '/') {
            this.state = 'selfClosingStartTag';
            this.consume();
          } else if (char === '>') {
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'attributeName';
            this.delegate.beginAttribute();
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },

        attributeName: function attributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.state = 'afterAttributeName';
            this.consume();
          } else if (char === '/') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '=') {
            this.state = 'beforeAttributeValue';
            this.consume();
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },

        afterAttributeName: function afterAttributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '/') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '=') {
            this.consume();
            this.state = 'beforeAttributeValue';
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'attributeName';
            this.delegate.beginAttribute();
            this.delegate.appendToAttributeName(char);
          }
        },

        beforeAttributeValue: function beforeAttributeValue() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '"') {
            this.state = 'attributeValueDoubleQuoted';
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === "'") {
            this.state = 'attributeValueSingleQuoted';
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'attributeValueUnquoted';
            this.delegate.beginAttributeValue(false);
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
          const char = this.consume();

          if (char === '"') {
            this.delegate.finishAttributeValue();
            this.state = 'afterAttributeValueQuoted';
          } else if (char === '&') {
            this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueSingleQuoted: function attributeValueSingleQuoted() {
          const char = this.consume();

          if (char === "'") {
            this.delegate.finishAttributeValue();
            this.state = 'afterAttributeValueQuoted';
          } else if (char === '&') {
            this.delegate.appendToAttributeValue(this.consumeCharRef("'") || '&');
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueUnquoted: function attributeValueUnquoted() {
          const char = this.peek();

          if (isSpace(char)) {
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'beforeAttributeName';
          } else if (char === '&') {
            this.consume();
            this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
          } else if (char === '>') {
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },

        afterAttributeValueQuoted: function afterAttributeValueQuoted() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
            this.state = 'beforeAttributeName';
          } else if (char === '/') {
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '>') {
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'beforeAttributeName';
          }
        },

        selfClosingStartTag: function selfClosingStartTag() {
          const char = this.peek();

          if (char === '>') {
            this.consume();
            this.delegate.markTagAsSelfClosing();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'beforeAttributeName';
          }
        },

        endTagOpen: function endTagOpen() {
          const char = this.consume();

          if (isAlpha(char)) {
            this.state = 'tagName';
            this.delegate.beginEndTag();
            this.delegate.appendToTagName(char.toLowerCase());
          }
        },
      },
    };

    function Tokenizer(entityParser, options) {
      this.token = null;
      this.startLine = 1;
      this.startColumn = 0;
      this.options = options || {};
      this.tokenizer = new EventedTokenizer(this, entityParser);
    }

    Tokenizer.prototype = {
      tokenize: function tokenize(input) {
        this.tokens = [];
        this.tokenizer.tokenize(input);
        return this.tokens;
      },

      tokenizePart: function tokenizePart(input) {
        this.tokens = [];
        this.tokenizer.tokenizePart(input);
        return this.tokens;
      },

      tokenizeEOF: function tokenizeEOF() {
        this.tokens = [];
        this.tokenizer.tokenizeEOF();
        return this.tokens[0];
      },

      reset: function reset() {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
      },

      addLocInfo: function addLocInfo() {
        if (this.options.loc) {
          this.token.loc = {
            start: {
              line: this.startLine,
              column: this.startColumn,
            },
            end: {
              line: this.tokenizer.line,
              column: this.tokenizer.column,
            },
          };
        }
        this.startLine = this.tokenizer.line;
        this.startColumn = this.tokenizer.column;
      },

      // Data

      beginData: function beginData() {
        this.token = {
          type: 'Chars',
          chars: '',
        };
        this.tokens.push(this.token);
      },

      appendToData: function appendToData(char) {
        this.token.chars += char;
      },

      finishData: function finishData() {
        this.addLocInfo();
      },

      // Comment

      beginComment: function beginComment() {
        this.token = {
          type: 'Comment',
          chars: '',
        };
        this.tokens.push(this.token);
      },

      appendToCommentData: function appendToCommentData(char) {
        this.token.chars += char;
      },

      finishComment: function finishComment() {
        this.addLocInfo();
      },

      // Tags - basic

      beginStartTag: function beginStartTag() {
        this.token = {
          type: 'StartTag',
          tagName: '',
          attributes: [],
          selfClosing: false,
        };
        this.tokens.push(this.token);
      },

      beginEndTag: function beginEndTag() {
        this.token = {
          type: 'EndTag',
          tagName: '',
        };
        this.tokens.push(this.token);
      },

      finishTag: function finishTag() {
        this.addLocInfo();
      },

      markTagAsSelfClosing: function markTagAsSelfClosing() {
        this.token.selfClosing = true;
      },

      // Tags - name

      appendToTagName: function appendToTagName(char) {
        this.token.tagName += char;
      },

      // Tags - attributes

      beginAttribute: function beginAttribute() {
        this._currentAttribute = ['', '', null];
        this.token.attributes.push(this._currentAttribute);
      },

      appendToAttributeName: function appendToAttributeName(char) {
        this._currentAttribute[0] += char;
      },

      beginAttributeValue: function beginAttributeValue(isQuoted) {
        this._currentAttribute[2] = isQuoted;
      },

      appendToAttributeValue: function appendToAttributeValue(char) {
        this._currentAttribute[1] = this._currentAttribute[1] || '';
        this._currentAttribute[1] += char;
      },

      finishAttributeValue: function finishAttributeValue() {},
    };

    function tokenize$1(input, options) {
      const tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);
      return tokenizer.tokenize(input);
    }

    const HTML5Tokenizer = {
      HTML5NamedCharRefs: HTML5NamedCharRefs,
      EntityParser: EntityParser,
      EventedTokenizer: EventedTokenizer,
      Tokenizer: Tokenizer,
      tokenize: tokenize$1,
    };

    const options = linkify.options;
    const Options = options.Options;

    const StartTag = 'StartTag';
    const EndTag = 'EndTag';
    const Chars = 'Chars';
    const Comment = 'Comment';

    /**
    	`tokens` and `token` in this section refer to tokens generated by the HTML
    	parser.
    */
    function linkifyHtml(str) {
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      const tokens = HTML5Tokenizer.tokenize(str);
      const linkifiedTokens = [];
      const linkified = [];
      let i;

      opts = new Options(opts);

      // Linkify the tokens given by the parser
      for (i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === StartTag) {
          linkifiedTokens.push(token);

          // Ignore all the contents of ignored tags
          const tagName = token.tagName.toUpperCase();
          const isIgnored = tagName === 'A' || options.contains(opts.ignoreTags, tagName);
          if (!isIgnored) {
            continue;
          }

          const preskipLen = linkifiedTokens.length;
          skipTagTokens(tagName, tokens, ++i, linkifiedTokens);
          i += linkifiedTokens.length - preskipLen - 1;
          continue;
        } else if (token.type !== Chars) {
          // Skip this token, it's not important
          linkifiedTokens.push(token);
          continue;
        }

        // Valid text token, linkify it!
        const linkifedChars = linkifyChars(token.chars, opts);
        linkifiedTokens.push(...linkifedChars);
      }

      // Convert the tokens back into a string
      for (i = 0; i < linkifiedTokens.length; i++) {
        const _token = linkifiedTokens[i];
        switch (_token.type) {
          case StartTag: {
            let link = `<${_token.tagName}`;
            if (_token.attributes.length > 0) {
              const attrs = attrsToStrings(_token.attributes);
              link += ` ${attrs.join(' ')}`;
            }
            link += '>';
            linkified.push(link);
            break;
          }
          case EndTag:
            linkified.push(`</${_token.tagName}>`);
            break;
          case Chars:
            linkified.push(escapeText(_token.chars));
            break;
          case Comment:
            linkified.push(`<!--${escapeText(_token.chars)}-->`);
            break;
        }
      }

      return linkified.join('');
    }

    /**
    	`tokens` and `token` in this section referes to tokens returned by
    	`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens
    */
    function linkifyChars(str, opts) {
      const tokens = linkify.tokenize(str);
      const result = [];

      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === 'nl' && opts.nl2br) {
          result.push({
            type: StartTag,
            tagName: 'br',
            attributes: [],
            selfClosing: true,
          });
          continue;
        } else if (!token.isLink || !opts.check(token)) {
          result.push({type: Chars, chars: token.toString()});
          continue;
        }

        const _opts$resolve = opts.resolve(token);

        const formatted = _opts$resolve.formatted;

        const formattedHref = _opts$resolve.formattedHref;

        const tagName = _opts$resolve.tagName;

        const className = _opts$resolve.className;

        const target = _opts$resolve.target;

        const attributes = _opts$resolve.attributes;

        // Build up attributes

        const attributeArray = [['href', formattedHref]];

        if (className) {
          attributeArray.push(['class', className]);
        }

        if (target) {
          attributeArray.push(['target', target]);
        }

        for (const attr in attributes) {
          attributeArray.push([attr, attributes[attr]]);
        }

        // Add the required tokens
        result.push({
          type: StartTag,
          tagName: tagName,
          attributes: attributeArray,
          selfClosing: false,
        });
        result.push({type: Chars, chars: formatted});
        result.push({type: EndTag, tagName: tagName});
      }

      return result;
    }

    /**
    	Returns a list of tokens skipped until the closing tag of tagName.

    	* `tagName` is the closing tag which will prompt us to stop skipping
    	* `tokens` is the array of tokens generated by HTML5Tokenizer which
    	* `i` is the index immediately after the opening tag to skip
    	* `skippedTokens` is an array which skipped tokens are being pushed into

    	Caveats

    	* Assumes that i is the first token after the given opening tagName
    	* The closing tag will be skipped, but nothing after it
    	* Will track whether there is a nested tag of the same type
    */
    function skipTagTokens(tagName, tokens, i, skippedTokens) {
      // number of tokens of this type on the [fictional] stack
      let stackCount = 1;

      while (i < tokens.length && stackCount > 0) {
        const token = tokens[i];

        if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {
          // Nested tag of the same type, "add to stack"
          stackCount++;
        } else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {
          // Closing tag
          stackCount--;
        }

        skippedTokens.push(token);
        i++;
      }

      // Note that if stackCount > 0 here, the HTML is probably invalid
      return skippedTokens;
    }

    function escapeText(text) {
      // Not required, HTML tokenizer ensures this occurs properly
      return text;
    }

    function escapeAttr(attr) {
      return attr.replace(/"/g, '&quot;');
    }

    function attrsToStrings(attrs) {
      const attrStrs = [];
      for (let i = 0; i < attrs.length; i++) {
        const _attrs$i = attrs[i];

        const name = _attrs$i[0];

        const value = _attrs$i[1];

        attrStrs.push(`${name}="${escapeAttr(value)}"`);
      }
      return attrStrs;
    }

    return linkifyHtml;
  })(linkify);

  window.linkifyHtml = linkifyHtml;
})(window, linkify);

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */
/*global define*/

(function() {
  /**
   * Block-Level Grammar
   */

  const block = {
    blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
    code: noop,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
    fences: noop,
    hr: /^( *[-*_]){3,} *(?:\n+|$)/,
    html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    newline: /^\n+/,
    paragraph: /^((?:[^\n]+\n?(?!hr|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/,
  };

  block.bullet = /(?:[*+-]|\d+\.)/;
  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
  block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();

  block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')(
    'def',
    '\\n+(?=' + block.def.source + ')' //eslint-disable-line
  )();

  block.blockquote = replace(block.blockquote)('def', block.def)();

  block._tag =
    '(?!(?:' +
    'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' +
    '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' +
    '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

  block.html = replace(block.html)('comment', /<!--[\s\S]*?-->/)('closed', /<(tag)[\s\S]+?<\/\1>/)(
    'closing',
    /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/
  )(/tag/g, block._tag)();

  block.paragraph = replace(block.paragraph)('blockquote', block.blockquote)('tag', `<${block._tag}`)(
    'def',
    block.def
  )();

  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);

  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
    paragraph: /^/,
  });

  block.gfm.paragraph = replace(block.paragraph)(
    '(?!',
    `(?!${block.gfm.fences.source.replace('\\1', '\\2')}|${block.list.source.replace('\\1', '\\3')}|`
  )();

  /**
   * Block Lexer
   */

  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = {};
    this.options = options || marked.defaults;
    this.rules = block.normal;

    if (this.options.gfm) {
      this.rules = block.gfm;
    }
  }

  /**
   * Expose Block Rules
   */

  Lexer.rules = block;

  /**
   * Static Lex Method
   */

  Lexer.lex = function(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  };

  /**
   * Preprocessing
   */

  Lexer.prototype.lex = function(src) {
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ')
      .replace(/\u00a0/g, ' ')
      .replace(/\u2424/g, '\n');

    return this.token(src, true);
  };

  /**
   * Lexing
   */

  Lexer.prototype.token = function(src, top, bq) {
    src = src.replace(/^ +$/gm, '');
    let cap;

    while (src) {
      // newline
      if ((cap = this.rules.newline.exec(src))) {
        src = src.substring(cap[0].length);
        if (cap[0].length > 1) {
          this.tokens.push({
            type: 'space',
          });
        }
      }

      // code
      if ((cap = this.rules.code.exec(src))) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap,
          type: 'code',
        });
        continue;
      }

      // fences (gfm)
      if ((cap = this.rules.fences.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          lang: cap[2],
          text: cap[3] || '',
          type: 'code',
        });
        continue;
      }

      // html
      if ((cap = this.rules.html.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0],
          type: this.options.sanitize ? 'paragraph' : 'html',
        });
        continue;
      }

      // def
      if (!bq && top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.links[cap[1].toLowerCase()] = {
          href: cap[2],
          title: cap[3],
        };
        continue;
      }

      // top-level paragraph
      if (top && (cap = this.rules.paragraph.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          text: cap[0],
          type: 'paragraph',
        });
        continue;
      }

      // text
      if ((cap = this.rules.text.exec(src))) {
        // Top-level should never reach here.
        src = src.substring(cap[0].length);
        this.tokens.push({
          text: cap[0],
          type: 'text',
        });
        continue;
      }

      if (src) {
        throw new Error(`Infinite loop on byte: ${src.charCodeAt(0)}`);
      }
    }

    return this.tokens;
  };

  /**
   * Inline-Level Grammar
   */

  const inline = {
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    br: /^ {2,}\n(?!\s*$)/,
    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
    del: noop,
    em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
    link: /^!?\[(inside)\]\(href\)/,
    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
    text: /^[_*` ]|^[\s\S]+?\s(?=[_*`])|^[\s\S]+?(?=[\\<!\[]| {2,}\n|$)/,
    url: noop,
  };

  inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
  inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

  inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();

  inline.reflink = replace(inline.reflink)('inside', inline._inside)();

  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);

  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  });

  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    del: /^~~(?=\S)([\s\S]*?\S)~~/,
    escape: replace(inline.escape)('])', '~|])')(),
    text: replace(inline.text)(']|', '~]|')('|', '|https?://|')(),
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  });

  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: replace(inline.br)('{2,}', '*')(),
    text: replace(inline.gfm.text)('{2,}', '*')(),
  });

  /**
   * Inline Lexer & Compiler
   */

  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer();
    this.renderer.options = this.options;

    if (!this.links) {
      throw new Error('Tokens array requires a `links` property.');
    }

    if (this.options.gfm) {
      this.rules = this.options.breaks ? inline.breaks : inline.gfm;
    } else if (this.options.pedantic) {
      this.rules = inline.pedantic;
    }
  }

  /**
   * Expose Inline Rules
   */

  InlineLexer.rules = inline;

  /**
   * Static Lexing/Compiling Method
   */

  InlineLexer.output = function(src, links, options) {
    const newInline = new InlineLexer(links, options);
    return newInline.output(src);
  };

  /**
   * Lexing/Compiling
   */

  InlineLexer.prototype.output = function(src) {
    let out = '';
    let cap;

    while (src) {
      // escape
      if ((cap = this.rules.escape.exec(src))) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      }

      // tag
      if ((cap = this.rules.tag.exec(src))) {
        if (!this.inLink && /^<a /i.test(cap[0])) {
          this.inLink = true;
        } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
          this.inLink = false;
        }
        src = src.substring(cap[0].length);
        out += this.options.sanitize
          ? this.options.sanitizer
            ? this.options.sanitizer(cap[0])
            : escape(cap[0])
          : cap[0];
        continue;
      }

      // strong
      if ((cap = this.rules.strong.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.strong(this.output(cap[2] || cap[1]));
        continue;
      }

      // em
      if ((cap = this.rules.em.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.em(this.output(cap[2] || cap[1]));
        continue;
      }

      // code
      if ((cap = this.rules.code.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.codespan(escape(cap[2], true));
        continue;
      }

      // br
      if ((cap = this.rules.br.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.br();
        continue;
      }

      if ((cap = linkify.find(src)[0])) {
        const pos = Math.max(0, src.indexOf(cap.value));
        const preString = this.output(src.substring(0, pos));
        if (!/[_*`]$/.test(preString)) {
          src = src.substring(pos + cap.value.length);
          const cleanHref = escape(cap.href);
          const cleanValue = escape(cap.value);
          out +=
            cap.type === 'email'
              ? `${preString}<a href="${cleanHref}" onclick="z.util.SanitizationUtil.safeMailtoOpen(event, '${cleanHref.replace(
                  /^mailto:/,
                  ''
                )}')">${cleanValue}</a>`
              : `${preString}<a href="${cleanHref}" target="_blank" rel="nofollow noopener noreferrer">${cleanValue}</a>`;
          continue;
        }
      }

      // text
      if ((cap = this.rules.text.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.text(escape(this.smartypants(cap[0])));
        continue;
      }

      if (src) {
        throw new Error(`Infinite loop on byte: ${src.charCodeAt(0)}`);
      }
    }

    return out;
  };

  /**
   * Compile Link
   */

  InlineLexer.prototype.outputLink = function(cap, link) {
    const href = escape(link.href);
    const title = link.title ? escape(link.title) : null;

    return cap[0].charAt(0) !== '!'
      ? this.renderer.link(href, title, cap[1])
      : this.renderer.image(href, title, escape(cap[1]));
  };

  /**
   * Smartypants Transformations
   */

  InlineLexer.prototype.smartypants = function(text) {
    if (!this.options.smartypants) {
      return text;
    }
    return (
      text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026')
    );
  };

  /**
   * Mangle Links
   */

  InlineLexer.prototype.mangle = function(text) {
    if (!this.options.mangle) {
      return text;
    }
    let out = '';
    const l = text.length;
    let i = 0;
    let ch;

    for (; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = `x${ch.toString(16)}`;
      }
      out += `&#${ch};`;
    }

    return out;
  };

  /**
   * Renderer
   */

  function Renderer(options) {
    this.options = options || {};
  }

  Renderer.prototype.code = function(code, lang, escaped) {
    code = _.unescape(code);
    code = code.replace(/&#x27;/g, "'");

    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    if (!lang) {
      return `<pre><code>${escaped ? code : escape(code, true)}\n</code></pre>`;
    }

    return `<pre><code class="${this.options.langPrefix}${escape(lang, true)}">${
      escaped ? code : escape(code, true)
    }\n</code></pre>\n`;
  };

  Renderer.prototype.blockquote = function(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  };

  Renderer.prototype.html = function(html) {
    return html;
  };

  Renderer.prototype.hr = function() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };

  Renderer.prototype.list = function(body, ordered) {
    const type = ordered ? 'ol' : 'ul';
    return `<${type}>\n${body}</${type}>\n`;
  };

  Renderer.prototype.listitem = function(text) {
    return `<li>${text}</li>\n`;
  };

  Renderer.prototype.paragraph = function(text) {
    return `${text.replace(/\n$/, '')}\n`;
  };

  // span level renderer
  Renderer.prototype.strong = function(text) {
    return `<strong>${text}</strong>`;
  };

  Renderer.prototype.em = function(text) {
    return `<em>${text}</em>`;
  };

  Renderer.prototype.codespan = function(text) {
    return `<code>${text}</code>`;
  };

  Renderer.prototype.br = function() {
    return this.options.xhtml ? '<br/>' : '<br>';
  };

  Renderer.prototype.del = function(text) {
    return `<del>${text}</del>`;
  };

  Renderer.prototype.link = function(href, title, text) {
    if (this.options.sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape(href))
          .replace(/[^\w:]/g, '')
          .toLowerCase();
      } catch (e) {
        return '';
      }
      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return '';
      }
    }
    let out = `<a href="${href}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ` target="_blank" rel="nofollow noopener noreferrer">${text}</a>`;
    return out;
  };

  Renderer.prototype.image = function(href, title, text) {
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  };

  Renderer.prototype.text = function(text) {
    return text;
  };

  /**
   * Parsing & Compiling
   */

  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
  }

  /**
   * Static Parse Method
   */

  Parser.parse = function(src, options, renderer) {
    const parser = new Parser(options, renderer);
    return parser.parse(src);
  };

  /**
   * Parse Loop
   */

  Parser.prototype.parse = function(src) {
    this.inline = new InlineLexer(src.links, this.options, this.renderer);
    this.tokens = src.reverse();

    let out = '';
    while (this.next()) {
      out += this.tok();
    }

    return out;
  };

  /**
   * Next Token
   */

  Parser.prototype.next = function() {
    return (this.token = this.tokens.pop());
  };

  /**
   * Preview Next Token
   */

  Parser.prototype.peek = function() {
    return this.tokens[this.tokens.length - 1] || 0;
  };

  /**
   * Parse Text Tokens
   */

  Parser.prototype.parseText = function() {
    let body = this.token.text;

    while (this.peek().type === 'text') {
      body += `\n${this.next().text}`;
    }

    return this.inline.output(body);
  };

  /**
   * Parse Current Token
   */

  Parser.prototype.tok = function() {
    switch (this.token.type) {
      case 'space': {
        return '';
      }
      case 'hr': {
        return this.renderer.hr();
      }
      case 'code': {
        return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
      }
      case 'blockquote_start': {
        let body = '';

        while (this.next().type !== 'blockquote_end') {
          body += this.tok();
        }

        return this.renderer.blockquote(body);
      }
      case 'list_start': {
        let body = '';
        const ordered = this.token.ordered;

        while (this.next().type !== 'list_end') {
          body += this.tok();
        }

        return this.renderer.list(body, ordered);
      }
      case 'list_item_start': {
        let body = '';

        while (this.next().type !== 'list_item_end') {
          body += this.token.type === 'text' ? this.parseText() : this.tok();
        }

        return this.renderer.listitem(body);
      }
      case 'loose_item_start': {
        let body = '';

        while (this.next().type !== 'list_item_end') {
          body += this.tok();
        }

        return this.renderer.listitem(body);
      }
      case 'html': {
        const html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
        return this.renderer.html(html);
      }
      case 'paragraph': {
        return this.renderer.paragraph(this.inline.output(this.token.text));
      }
      case 'text': {
        return this.renderer.paragraph(this.parseText());
      }
    }
  };

  /**
   * Helpers
   */

  function escape(html, encode) {
    return html
      .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, (_, n) => {
      n = n.toLowerCase();
      if (n === 'colon') {
        return ':';
      }
      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x'
          ? String.fromCharCode(parseInt(n.substring(2), 16))
          : String.fromCharCode(+n.substring(1));
      }
      return '';
    });
  }

  function replace(regex, opt) {
    regex = regex.source;
    opt = opt || '';
    return function self(name, val) {
      if (!name) {
        return new RegExp(regex, opt);
      }
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return self;
    };
  }

  function noop() {}
  noop.exec = noop;

  function merge(obj) {
    let i = 1;
    let target;
    let key;

    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  /**
   * Marked
   */

  function marked(src, opt, callback) {
    if (callback || typeof opt === 'function') {
      if (!callback) {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});

      const highlight = opt.highlight;
      let tokens;
      let pending;
      let i = 0;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      pending = tokens.length;

      const done = function(err) {
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }

        let out;

        try {
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }

        opt.highlight = highlight;

        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;

      if (!pending) {
        return done();
      }

      for (; i < tokens.length; i++) {
        (function(token) {
          if (token.type !== 'code') {
            return --pending || done();
          }
          return highlight(token.text, token.lang, (err, code) => {
            if (err) {
              return done(err);
            }
            if (code == null || code === token.text) {
              return --pending || done();
            }
            token.text = code;
            token.escaped = true;
            return --pending || done();
          });
        })(tokens[i]);
      }

      return;
    }

    try {
      if (opt) {
        opt = merge({}, marked.defaults, opt);
      }
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/chjj/marked.';
      if ((opt || marked.defaults).silent) {
        return `<p>An error occured:</p><pre>${escape(`${e.message}`, true)}</pre>`;
      }
      throw e;
    }
  }

  /**
   * Options
   */

  marked.options = marked.setOptions = function(opt) {
    merge(marked.defaults, opt);
    return marked;
  };

  marked.defaults = {
    breaks: false,
    gfm: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'lang-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    xhtml: false,
  };

  /**
   * Expose
   */

  marked.Parser = Parser;
  marked.parser = Parser.parse;

  marked.Renderer = Renderer;

  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;

  marked.InlineLexer = InlineLexer;
  marked.inlineLexer = InlineLexer.output;

  marked.parse = marked;

  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = marked;
  } else if (typeof define === 'function' && define.amd) {
    define(() => {
      return marked;
    });
  } else {
    this.marked = marked;
  }
}.call(
  (function() {
    return this || (typeof window !== 'undefined' ? window : global);
  })()
));

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.MessageComparator = {
  /**
   * Checks if two arrays with mentions contain different values.
   *
   * @param {z.entity.Message} originalMessageEntity - Message entity
   * @param {Array<z.message.MentionEntity>} [updatedMentions] - Updated mentions
   * @returns {boolean} Are the mentions different from each other
   */
  areMentionsDifferent: (originalMessageEntity, updatedMentions) => {
    const flattenToUserId = mentions => mentions.map(mention => mention.userId).sort();

    const existingMentions = flattenToUserId(originalMessageEntity.get_first_asset().mentions());
    updatedMentions = flattenToUserId(updatedMentions);

    const hasDifferentAmount = existingMentions.length !== updatedMentions.length;
    const hasDifferentUserIDs = existingMentions.some((userId, index) => userId !== updatedMentions[index]);

    return hasDifferentAmount || hasDifferentUserIDs;
  },
  /**
   * Checks if a given text is different from an already existing text on the message entity.
   *
   * @param {z.entity.Message} originalMessageEntity - Message entity
   * @param {string} textMessage - Message to compare with
   * @returns {boolean} Are text the same
   */
  isTextDifferent: (originalMessageEntity, textMessage) => {
    return textMessage !== originalMessageEntity.get_first_asset().text;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

moment.fn.isToday = function() {
  return this.isSame(new Date(), 'd');
};

moment.fn.isCurrentYear = function() {
  return this.isSame(new Date(), 'y');
};

moment.fn.isSameDay = function(date) {
  return this.isSame(date, 'd');
};

moment.fn.isSameMonth = function(date) {
  return this.isSame(date, 'M');
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.util.NumberUtil = {
  capToByte: value => {
    const MAX_VALUE = 255;
    return Math.min(Math.abs(parseInt(value * MAX_VALUE, 10)), MAX_VALUE);
  },

  clamp: (value, min, max) => {
    return Math.max(min, Math.min(max, value));
  },

  getRandomNumber: (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum),

  inRange: (value, lowerBound, upperBound) => value >= lowerBound && value <= upperBound,

  rootMeanSquare: floatArray => {
    const pow = floatArray.map(number => Math.pow(number, 2));
    const sum = pow.reduce((power, number) => power + number);
    return Math.sqrt(sum) / floatArray.length;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ObjectUtil = {
  /**
   * Escapes all properties of a given object.
   * @param {Object} object - Base object
   * @returns {Object} Object copy with escaped properties
   */
  escapeProperties: object => z.util.ObjectUtil.mapRecursive(object, _.escape),

  /**
   * Creates an object copy and applies a mapping functions to all properties of that object.
   *
   * @param {Object} object - Base object
   * @param {Function} mappingFunction - Mapping function
   * @returns {Object} Object copy with mapped properties
   */
  mapRecursive: (object, mappingFunction) => {
    if (typeof object !== 'object') {
      return mappingFunction(object);
    }

    const newObject = {};

    Object.entries(object).forEach(([propertyName, value]) => {
      newObject[propertyName] = z.util.ObjectUtil.mapRecursive(value, mappingFunction);
    });

    return newObject;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.util.PeerConnectionUtil = {
  getIceCandidatesTypes(iceCandidates) {
    return iceCandidates.reduce((types, candidateStr) => {
      const typeMatches = candidateStr.match(/typ (\w+)/);
      if (!typeMatches) {
        return types;
      }
      const candidateType = typeMatches[1];
      types[candidateType] = types[candidateType] + 1 || 1;
      return types;
    }, {});
  },

  /**
   * Returns true if the number and types of ice candidates gathered are sufficient to start a call
   *
   * @param {RTCConfiguration} peerConnectionConfig - the configuration of the peerConnection that initiated the ICE candidate gathering
   * @param {Array<string>} iceCandidates - ICE candidate strings from SDP
   * @returns {boolean} True if the candidates gathered are enough to send a SDP
   */
  isValidIceCandidatesGathering(peerConnectionConfig, iceCandidates) {
    if (iceCandidates.length <= 0) {
      // if there are no candidates, no need to check for more conditions
      // the call cannot work
      return false;
    }
    const numberOfRelays = iceCandidates.filter(candidate => candidate.toLowerCase().includes('relay')).length;
    const numberOfIceServers = (peerConnectionConfig.iceServers || []).length;
    if (numberOfIceServers <= 0) {
      return true;
    }
    if (numberOfIceServers === 1 && numberOfRelays >= 1) {
      return true;
    }
    if (numberOfIceServers >= 2 && numberOfRelays >= 2) {
      return true;
    }
    return false;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.PromiseQueue = class PromiseQueue {
  static get CONFIG() {
    return {
      UNBLOCK_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  /**
   * Construct a new Promise Queue.
   *
   * @param {Object} [options={}] - Initialization options
   * @param {boolean} [options.concurrent=1] - Concurrent promise execution
   * @param {string} options.name - Name for Promise queue
   * @param {boolean} [options.paused=false] - Initial paused state
   * @param {number} [options.timeout=PromiseQueue.CONFIG.UNBLOCK_INTERVAL] - Timeout in ms
   * @returns {PromiseQueue} Process Promises sequentially
   */
  constructor(options = {}) {
    const {concurrent = 1, name, paused = false, timeout = PromiseQueue.CONFIG.UNBLOCK_INTERVAL} = options;

    const loggerName = `z.util.PromiseQueue${name ? ` (${name})` : ''}`;
    this.logger = new z.util.Logger(loggerName, z.config.LOGGER.OPTIONS);

    this._blocked = false;
    this._concurrent = concurrent;
    this._current = 0;
    this._interval = undefined;
    this._paused = paused;
    this._queue = [];
    this._timeout = timeout;
  }

  /**
   * Executes first function in the queue.
   * @returns {undefined} No return value
   */
  execute() {
    if (this._paused || this._blocked) {
      return;
    }

    const queueEntry = this._queue.shift();
    if (queueEntry) {
      this._clearInterval();

      this._current = this._current + 1;
      if (this._current >= this._concurrent) {
        this._blocked = true;
      }

      this._interval = window.setInterval(() => {
        if (!this._paused) {
          const logObject = {pendingEntry: queueEntry, queueState: this._queue};
          this.logger.error('Promise queue failed, unblocking queue', logObject);
          this.resume();
        }
      }, this._timeout);

      queueEntry
        .fn()
        .catch(error => {
          queueEntry.resolveFn = undefined;
          queueEntry.rejectFn(error);
        })
        .then(response => {
          if (queueEntry.resolveFn) {
            queueEntry.resolveFn(response);
          }

          this._clearInterval();

          this._current = this._current - 1;
          if (this._current < this._concurrent) {
            this._blocked = false;
          }

          window.setTimeout(() => this.execute(), 0);
        });
    }
  }

  /**
   * Get the number of queued functions.
   * @returns {number} Number of queued functions
   */
  getLength() {
    return this._queue.length;
  }

  /**
   * Pause or resume the execution.
   * @param {boolean} [shouldPause=true] - Pause queue
   * @returns {z.util.PromiseQueue} PromiseQueue
   */
  pause(shouldPause = true) {
    this._paused = shouldPause;
    if (!this._paused) {
      this.execute();
    }

    return this;
  }

  /**
   * Queued function is executed when queue is empty or previous functions are executed.
   * @param {Function} fn - Function to be executed in queue order
   * @returns {Promise} Resolves when function was executed
   */
  push(fn) {
    return new Promise((resolve, reject) => {
      const queueEntry = {
        fn: fn,
        rejectFn: reject,
        resolveFn: resolve,
      };

      this._queue.push(queueEntry);
      this.execute();
    });
  }

  /**
   * Resume execution of queue.
   * @returns {undefined} No return value
   */
  resume() {
    this._clearInterval();
    this._blocked = false;
    this.pause(false);
  }

  /**
   * Queued function is executed.
   * @param {Function} fn - Function to be executed in queue order
   * @returns {Promise} Resolves when function was executed
   */
  unshift(fn) {
    return new Promise((resolve, reject) => {
      const queueEntry = {
        fn: fn,
        rejectFn: reject,
        resolveFn: resolve,
      };

      this._queue.unshift(queueEntry);
      this.execute();
    });
  }

  _clearInterval() {
    if (this._interval) {
      window.clearInterval(this._interval);
      this._interval = undefined;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

$.fn.scrollEnd = function() {
  const element = $(this).get(0);
  if (!element) {
    return;
  }
  return element.scrollHeight - element.clientHeight;
};

$.fn.scrollToBottom = function() {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  $element.scrollTop($element[0].scrollHeight);
  return window.setTimeout(() => {
    if (!$(this).isScrolledBottom()) {
      return $element.scrollTop($element[0].scrollHeight);
    }
  }, 200);
};

$.fn.scrollBy = function(distance) {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  const scrollTop = $element[0].scrollTop;
  return $element.scrollTop(scrollTop + distance);
};

$.fn.isScrolledBottom = function(offset) {
  if (offset == null) {
    offset = 0;
  }
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  const scrollTop = Math.ceil($element.scrollTop());
  const scrollHeight = $element[0].scrollHeight;
  const height = $element[0].clientHeight;
  return scrollTop + height + offset >= scrollHeight;
};

$.fn.isScrolledTop = function() {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  return $element.scrollTop() === 0;
};

$.fn.isScrollable = function() {
  const element = $(this).get(0);
  if (!element) {
    return;
  }
  return element.scrollHeight > element.clientHeight;
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.StorageUtil = {
  getValue: function(key) {
    return amplify.store(key);
  },
  resetValue: function(key) {
    return z.util.StorageUtil.setValue(key, null);
  },
  setValue: function(key, value, secondsToExpire) {
    const config = secondsToExpire ? {expires: secondsToExpire * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND} : undefined;
    return amplify.store(key, value, config);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.StringUtil = {
  /**
   * @param {ArrayLike} bytes - bytes to convert
   * @returns {string} bytes as hex string
   */
  bytesToHex: bytes => {
    bytes = Array.from(bytes);

    const hexBase = 16;
    const padIndex = 2;

    return bytes
      .map(byte => {
        const stringByte = byte.toString(hexBase);
        return z.util.StringUtil.padStart(stringByte, padIndex, '0');
      })
      .join('');
  },

  capitalizeFirstChar: (string = '') => `${string.charAt(0).toUpperCase()}${string.substring(1)}`,

  /**
   * Returns true if the string and the query match by applying transliteration first.
   *
   * @param {string} string - the string to compare the query against
   * @param {string} query - the query to compare to the string
   * @param {Object} excludedChars - extra characters to ignore when creating a slug ({[string]: string})
   * @param {boolean} fromStart=false - should the query match the string from the beginning of the string
   * @returns {boolean} does the string matches the query
   */
  compareTransliteration: (string, query, excludedChars = {}, fromStart = false) => {
    const nameSlug = z.util.StringUtil.computeTransliteration(string, excludedChars);
    const querySlug = z.util.StringUtil.computeTransliteration(query, excludedChars);
    return fromStart ? nameSlug.startsWith(querySlug) : z.util.StringUtil.includes(nameSlug, querySlug);
  },

  computeTransliteration: (string, excludedChars = {}) => {
    const options = {custom: excludedChars, uric: true};
    return window.getSlug(string, options);
  },

  cutLastChars: (string, length) => string.substring(0, string.length - length),

  format: (...args) => {
    let [string] = args;

    for (let index = 0; index < args.length; ++index) {
      const reg = new RegExp(`\\{${index}\\}`, 'gm');
      string = string.replace(reg, args[index + 1]);
    }

    return string;
  },

  getFirstChar: string => [...string][0],

  getLastChars: (string, length) => (string.length < length ? false : string.substring(string.length - length)),

  getRandomChar: () => {
    let charIndex;
    while (
      !z.util.NumberUtil.inRange(charIndex, 1, 9) &&
      !z.util.NumberUtil.inRange(charIndex, 65, 90) &&
      !z.util.NumberUtil.inRange(charIndex, 97, 122)
    ) {
      charIndex = Math.floor(Math.random() * 122);
    }

    // Returns random alphanumeric character [A-Z, a-z, 0-9]
    return charIndex <= 9 ? charIndex : String.fromCharCode(charIndex);
  },

  /**
   * @param {string} hexString - string to convert
   * @returns {number[]} bytes as array
   */
  hexToBytes: hexString => {
    const bytes = [];
    const hexBase = 16;

    for (let charIndex = 0; charIndex < hexString.length; charIndex += 2) {
      const parsedInt = parseInt(hexString.substr(charIndex, 2), hexBase);
      bytes.push(parsedInt);
    }

    return bytes;
  },

  includes: (string = '', query = '') => string.toLowerCase().includes(query.toLowerCase()),

  obfuscate: text => {
    const alphabet = Array.from('abcdefghijklmnopqrstuvwxyz');
    let obfuscated = '';

    for (const character of text) {
      if (character.match(/[\n\r\s]+/gi)) {
        obfuscated += character;
      } else {
        obfuscated += z.util.ArrayUtil.randomElement(alphabet);
      }
    }

    return obfuscated;
  },

  /**
   * @param {string} str - string to pad
   * @param {number} length - maximum length to pad
   * @param {string} [padCharacter] - character to pad with (default is space)
   * @returns {string} The padded string
   */
  padStart(str, length, padCharacter = ' ') {
    if (str.length >= length) {
      return str;
    }
    return padCharacter.repeat(length - str.length) + str;
  },

  removeLineBreaks: (string = '') => string.replace(/(\r\n|\n|\r)/gm, ''),

  replaceInRange(text, replacement, startIndex, endIndex) {
    const beforePartial = text.slice(0, startIndex);
    const afterPartial = text.slice(endIndex);
    return `${beforePartial}${replacement}${afterPartial}`;
  },

  sortByPriority: (stringA = '', stringB = '', query) => {
    stringA = stringA.toLowerCase();
    stringB = stringB.toLowerCase();

    if (query) {
      if (z.util.StringUtil.startsWith(stringA, query)) {
        if (!z.util.StringUtil.startsWith(stringB, query)) {
          return -1;
        }
      } else if (z.util.StringUtil.startsWith(stringB, query)) {
        if (!z.util.StringUtil.startsWith(stringA, query)) {
          return 1;
        }
      }
    }

    if (stringA < stringB) {
      return -1;
    }

    if (stringA > stringB) {
      return 1;
    }

    return 0;
  },

  splitAtPivotElement: (text, pivot, replacement) => {
    if (!pivot) {
      return [
        {
          isStyled: false,
          text,
        },
      ];
    }

    const findPivot = pivot === '?' ? new RegExp('(\\?)') : new RegExp(`(${pivot})`);

    return text
      .split(findPivot)
      .map(value => {
        return value
          ? {
              isStyled: value === pivot,
              text: value === pivot ? replacement : value,
            }
          : undefined;
      })
      .filter(item => item);
  },

  startsWith: (string = '', query) => string.toLowerCase().startsWith(query.toLowerCase()),

  trimEnd: (string = '') => string.replace(/\s*$/, ''),
  trimStart: (string = '') => string.replace(/^\s*/, ''),

  truncate: (string, outputLength, wordBoundary = true) => {
    if (string.length > outputLength) {
      let truncateIndex = outputLength - 1;
      if (wordBoundary && string.lastIndexOf(' ', outputLength - 1) > outputLength - 25) {
        truncateIndex = string.lastIndexOf(' ', outputLength - 1);
      }
      string = `${string.substr(0, truncateIndex)}`;
    }
    return string;
  },

  /**
   * @param {string} str - The string to convert
   * @returns {number[]} Converted string as byte array
   */
  utf8ToUtf16BE: str => {
    const BOMChar = '\uFEFF';

    str = `${BOMChar}${str}`;

    const bytes = [];

    for (let i = 0; i < str.length; ++i) {
      const charCode = str.charCodeAt(i);
      bytes.push((charCode & 0xff00) >> 8);
      bytes.push(charCode & 0xff);
    }

    return bytes;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.CountryCodes = (() => {
  const COUNTRY_CODES = [
    {
      code: 93,
      iso: 'AF',
      name: 'Afghanistan',
      population: 31,
    },
    {
      code: 355,
      iso: 'AL',
      name: 'Albania',
      population: 2,
    },
    {
      code: 213,
      iso: 'DZ',
      name: 'Algeria',
      population: 34,
    },
    {
      code: 1684,
      iso: 'AS',
      name: 'American Samoa',
      population: 0,
    },
    {
      code: 376,
      iso: 'AD',
      name: 'Andorra',
      population: 0,
    },
    {
      code: 244,
      iso: 'AO',
      name: 'Angola',
      population: 13,
    },
    {
      code: 1264,
      iso: 'AI',
      name: 'Anguilla',
      population: 0,
    },
    {
      code: 672,
      iso: 'AQ',
      name: 'Antarctica',
      population: 0,
    },
    {
      code: 1268,
      iso: 'AG',
      name: 'Antigua and Barbuda',
      population: 0,
    },
    {
      code: 54,
      iso: 'AR',
      name: 'Argentina',
      population: 41,
    },
    {
      code: 374,
      iso: 'AM',
      name: 'Armenia',
      population: 2,
    },
    {
      code: 297,
      iso: 'AW',
      name: 'Aruba',
      population: 0,
    },
    {
      code: 61,
      iso: 'AU',
      name: 'Australia',
      population: 21,
    },
    {
      code: 43,
      iso: 'AT',
      name: 'Austria',
      population: 8,
    },
    {
      code: 994,
      iso: 'AZ',
      name: 'Azerbaijan',
      population: 8,
    },
    {
      code: 1242,
      iso: 'BS',
      name: 'Bahamas',
      population: 0,
    },
    {
      code: 973,
      iso: 'BH',
      name: 'Bahrain',
      population: 0,
    },
    {
      code: 880,
      iso: 'BD',
      name: 'Bangladesh',
      population: 171,
    },
    {
      code: 1246,
      iso: 'BB',
      name: 'Barbados',
      population: 0,
    },
    {
      code: 375,
      iso: 'BY',
      name: 'Belarus',
      population: 9,
    },
    {
      code: 32,
      iso: 'BE',
      name: 'Belgium',
      population: 10,
    },
    {
      code: 501,
      iso: 'BZ',
      name: 'Belize',
      population: 0,
    },
    {
      code: 229,
      iso: 'BJ',
      name: 'Benin',
      population: 9,
    },
    {
      code: 1441,
      iso: 'BM',
      name: 'Bermuda',
      population: 0,
    },
    {
      code: 975,
      iso: 'BT',
      name: 'Bhutan',
      population: 0,
    },
    {
      code: 591,
      iso: 'BO',
      name: 'Bolivia',
      population: 9,
    },
    {
      code: 387,
      iso: 'BA',
      name: 'Bosnia and Herzegovina',
      population: 4,
    },
    {
      code: 267,
      iso: 'BW',
      name: 'Botswana',
      population: 2,
    },
    {
      code: 55,
      iso: 'BR',
      name: 'Brazil',
      population: 201,
    },
    {
      code: 246,
      iso: 'IO',
      name: 'British Indian Ocean Territory',
      population: 0,
    },
    {
      code: 1284,
      iso: 'VG',
      name: 'British Virgin Islands',
      population: 0,
    },
    {
      code: 673,
      iso: 'BN',
      name: 'Brunei',
      population: 0,
    },
    {
      code: 359,
      iso: 'BG',
      name: 'Bulgaria',
      population: 7,
    },
    {
      code: 226,
      iso: 'BF',
      name: 'Burkina Faso',
      population: 16,
    },
    {
      code: 257,
      iso: 'BI',
      name: 'Burundi',
      population: 9,
    },
    {
      code: 855,
      iso: 'KH',
      name: 'Cambodia',
      population: 14,
    },
    {
      code: 237,
      iso: 'CM',
      name: 'Cameroon',
      population: 19,
    },
    {
      code: 1,
      iso: 'CA',
      name: 'Canada',
      population: 33,
    },
    {
      code: 238,
      iso: 'CV',
      name: 'Cape Verde',
      population: 0,
    },
    {
      code: 1345,
      iso: 'KY',
      name: 'Cayman Islands',
      population: 0,
    },
    {
      code: 236,
      iso: 'CF',
      name: 'Central African Republic',
      population: 4,
    },
    {
      code: 235,
      iso: 'TD',
      name: 'Chad',
      population: 10,
    },
    {
      code: 56,
      iso: 'CL',
      name: 'Chile',
      population: 16,
    },
    {
      code: 86,
      iso: 'CN',
      name: 'China',
      population: 1376,
    },
    {
      code: 61,
      iso: 'CX',
      name: 'Christmas Island',
      population: 0,
    },
    {
      code: 61,
      iso: 'CC',
      name: 'Cocos Islands',
      population: 0,
    },
    {
      code: 57,
      iso: 'CO',
      name: 'Colombia',
      population: 47,
    },
    {
      code: 269,
      iso: 'KM',
      name: 'Comoros',
      population: 0,
    },
    {
      code: 682,
      iso: 'CK',
      name: 'Cook Islands',
      population: 0,
    },
    {
      code: 506,
      iso: 'CR',
      name: 'Costa Rica',
      population: 4,
    },
    {
      code: 385,
      iso: 'HR',
      name: 'Croatia',
      population: 4,
    },
    {
      code: 53,
      iso: 'CU',
      name: 'Cuba',
      population: 11,
    },
    {
      code: 599,
      iso: 'CW',
      name: 'Curacao',
      population: 0,
    },
    {
      code: 357,
      iso: 'CY',
      name: 'Cyprus',
      population: 1,
    },
    {
      code: 420,
      iso: 'CZ',
      name: 'Czech Republic',
      population: 10,
    },
    {
      code: 243,
      iso: 'CD',
      name: 'Democratic Republic of the Congo',
      population: 81,
    },
    {
      code: 45,
      iso: 'DK',
      name: 'Denmark',
      population: 5,
    },
    {
      code: 253,
      iso: 'DJ',
      name: 'Djibouti',
      population: 0,
    },
    {
      code: 1767,
      iso: 'DM',
      name: 'Dominica',
      population: 0,
    },
    {
      code: 1809,
      iso: 'DO',
      name: 'Dominican Republic',
      population: 9,
    },
    {
      code: 670,
      iso: 'TL',
      name: 'East Timor',
      population: 1,
    },
    {
      code: 593,
      iso: 'EC',
      name: 'Ecuador',
      population: 14,
    },
    {
      code: 20,
      iso: 'EG',
      name: 'Egypt',
      population: 91,
    },
    {
      code: 503,
      iso: 'SV',
      name: 'El Salvador',
      population: 6,
    },
    {
      code: 240,
      iso: 'GQ',
      name: 'Equatorial Guinea',
      population: 1,
    },
    {
      code: 291,
      iso: 'ER',
      name: 'Eritrea',
      population: 5,
    },
    {
      code: 372,
      iso: 'EE',
      name: 'Estonia',
      population: 1,
    },
    {
      code: 251,
      iso: 'ET',
      name: 'Ethiopia',
      population: 88,
    },
    {
      code: 500,
      iso: 'FK',
      name: 'Falkland Islands',
      population: 0,
    },
    {
      code: 298,
      iso: 'FO',
      name: 'Faroe Islands',
      population: 0,
    },
    {
      code: 679,
      iso: 'FJ',
      name: 'Fiji',
      population: 0,
    },
    {
      code: 358,
      iso: 'FI',
      name: 'Finland',
      population: 5,
    },
    {
      code: 33,
      iso: 'FR',
      name: 'France',
      population: 64,
    },
    {
      code: 689,
      iso: 'PF',
      name: 'French Polynesia',
      population: 0,
    },
    {
      code: 241,
      iso: 'GA',
      name: 'Gabon',
      population: 1,
    },
    {
      code: 220,
      iso: 'GM',
      name: 'Gambia',
      population: 1,
    },
    {
      code: 995,
      iso: 'GE',
      name: 'Georgia',
      population: 4,
    },
    {
      code: 49,
      iso: 'DE',
      name: 'Germany',
      population: 81,
    },
    {
      code: 233,
      iso: 'GH',
      name: 'Ghana',
      population: 24,
    },
    {
      code: 350,
      iso: 'GI',
      name: 'Gibraltar',
      population: 0,
    },
    {
      code: 30,
      iso: 'GR',
      name: 'Greece',
      population: 11,
    },
    {
      code: 299,
      iso: 'GL',
      name: 'Greenland',
      population: 0,
    },
    {
      code: 1473,
      iso: 'GD',
      name: 'Grenada',
      population: 0,
    },
    {
      code: 1671,
      iso: 'GU',
      name: 'Guam',
      population: 0,
    },
    {
      code: 502,
      iso: 'GT',
      name: 'Guatemala',
      population: 13,
    },
    {
      code: 441481,
      iso: 'GG',
      name: 'Guernsey',
      population: 0,
    },
    {
      code: 224,
      iso: 'GN',
      name: 'Guinea',
      population: 10,
    },
    {
      code: 245,
      iso: 'GW',
      name: 'Guinea-Bissau',
      population: 1,
    },
    {
      code: 592,
      iso: 'GY',
      name: 'Guyana',
      population: 0,
    },
    {
      code: 509,
      iso: 'HT',
      name: 'Haiti',
      population: 9,
    },
    {
      code: 504,
      iso: 'HN',
      name: 'Honduras',
      population: 7,
    },
    {
      code: 852,
      iso: 'HK',
      name: 'Hong Kong',
      population: 6,
    },
    {
      code: 36,
      iso: 'HU',
      name: 'Hungary',
      population: 9,
    },
    {
      code: 354,
      iso: 'IS',
      name: 'Iceland',
      population: 0,
    },
    {
      code: 91,
      iso: 'IN',
      name: 'India',
      population: 1173,
    },
    {
      code: 62,
      iso: 'ID',
      name: 'Indonesia',
      population: 242,
    },
    {
      code: 98,
      iso: 'IR',
      name: 'Iran',
      population: 76,
    },
    {
      code: 964,
      iso: 'IQ',
      name: 'Iraq',
      population: 29,
    },
    {
      code: 353,
      iso: 'IE',
      name: 'Ireland',
      population: 4,
    },
    {
      code: 441624,
      iso: 'IM',
      name: 'Isle of Man',
      population: 0,
    },
    {
      code: 972,
      iso: 'IL',
      name: 'Israel',
      population: 7,
    },
    {
      code: 39,
      iso: 'IT',
      name: 'Italy',
      population: 60,
    },
    {
      code: 225,
      iso: 'CI',
      name: 'Ivory Coast',
      population: 21,
    },
    {
      code: 1876,
      iso: 'JM',
      name: 'Jamaica',
      population: 2,
    },
    {
      code: 81,
      iso: 'JP',
      name: 'Japan',
      population: 127,
    },
    {
      code: 441534,
      iso: 'JE',
      name: 'Jersey',
      population: 0,
    },
    {
      code: 962,
      iso: 'JO',
      name: 'Jordan',
      population: 6,
    },
    {
      code: 7,
      iso: 'KZ',
      name: 'Kazakhstan',
      population: 15,
    },
    {
      code: 254,
      iso: 'KE',
      name: 'Kenya',
      population: 40,
    },
    {
      code: 686,
      iso: 'KI',
      name: 'Kiribati',
      population: 0,
    },
    {
      code: 383,
      iso: 'XK',
      name: 'Kosovo',
      population: 1,
    },
    {
      code: 965,
      iso: 'KW',
      name: 'Kuwait',
      population: 2,
    },
    {
      code: 996,
      iso: 'KG',
      name: 'Kyrgyzstan',
      population: 5,
    },
    {
      code: 856,
      iso: 'LA',
      name: 'Laos',
      population: 6,
    },
    {
      code: 371,
      iso: 'LV',
      name: 'Latvia',
      population: 2,
    },
    {
      code: 961,
      iso: 'LB',
      name: 'Lebanon',
      population: 4,
    },
    {
      code: 266,
      iso: 'LS',
      name: 'Lesotho',
      population: 1,
    },
    {
      code: 231,
      iso: 'LR',
      name: 'Liberia',
      population: 3,
    },
    {
      code: 218,
      iso: 'LY',
      name: 'Libya',
      population: 6,
    },
    {
      code: 423,
      iso: 'LI',
      name: 'Liechtenstein',
      population: 0,
    },
    {
      code: 370,
      iso: 'LT',
      name: 'Lithuania',
      population: 2,
    },
    {
      code: 352,
      iso: 'LU',
      name: 'Luxembourg',
      population: 0,
    },
    {
      code: 853,
      iso: 'MO',
      name: 'Macao',
      population: 0,
    },
    {
      code: 389,
      iso: 'MK',
      name: 'Macedonia',
      population: 2,
    },
    {
      code: 261,
      iso: 'MG',
      name: 'Madagascar',
      population: 21,
    },
    {
      code: 265,
      iso: 'MW',
      name: 'Malawi',
      population: 15,
    },
    {
      code: 60,
      iso: 'MY',
      name: 'Malaysia',
      population: 28,
    },
    {
      code: 960,
      iso: 'MV',
      name: 'Maldives',
      population: 0,
    },
    {
      code: 223,
      iso: 'ML',
      name: 'Mali',
      population: 13,
    },
    {
      code: 356,
      iso: 'MT',
      name: 'Malta',
      population: 0,
    },
    {
      code: 692,
      iso: 'MH',
      name: 'Marshall Islands',
      population: 0,
    },
    {
      code: 222,
      iso: 'MR',
      name: 'Mauritania',
      population: 3,
    },
    {
      code: 230,
      iso: 'MU',
      name: 'Mauritius',
      population: 1,
    },
    {
      code: 262,
      iso: 'YT',
      name: 'Mayotte',
      population: 0,
    },
    {
      code: 52,
      iso: 'MX',
      name: 'Mexico',
      population: 112,
    },
    {
      code: 691,
      iso: 'FM',
      name: 'Micronesia',
      population: 0,
    },
    {
      code: 373,
      iso: 'MD',
      name: 'Moldova',
      population: 4,
    },
    {
      code: 377,
      iso: 'MC',
      name: 'Monaco',
      population: 0,
    },
    {
      code: 976,
      iso: 'MN',
      name: 'Mongolia',
      population: 3,
    },
    {
      code: 382,
      iso: 'ME',
      name: 'Montenegro',
      population: 0,
    },
    {
      code: 1664,
      iso: 'MS',
      name: 'Montserrat',
      population: 0,
    },
    {
      code: 212,
      iso: 'MA',
      name: 'Morocco',
      population: 33,
    },
    {
      code: 258,
      iso: 'MZ',
      name: 'Mozambique',
      population: 22,
    },
    {
      code: 95,
      iso: 'MM',
      name: 'Myanmar',
      population: 53,
    },
    {
      code: 264,
      iso: 'NA',
      name: 'Namibia',
      population: 2,
    },
    {
      code: 674,
      iso: 'NR',
      name: 'Nauru',
      population: 0,
    },
    {
      code: 977,
      iso: 'NP',
      name: 'Nepal',
      population: 28,
    },
    {
      code: 31,
      iso: 'NL',
      name: 'Netherlands',
      population: 16,
    },
    {
      code: 599,
      iso: 'AN',
      name: 'Netherlands Antilles',
      population: 0,
    },
    {
      code: 687,
      iso: 'NC',
      name: 'New Caledonia',
      population: 0,
    },
    {
      code: 64,
      iso: 'NZ',
      name: 'New Zealand',
      population: 4,
    },
    {
      code: 505,
      iso: 'NI',
      name: 'Nicaragua',
      population: 5,
    },
    {
      code: 227,
      iso: 'NE',
      name: 'Niger',
      population: 15,
    },
    {
      code: 234,
      iso: 'NG',
      name: 'Nigeria',
      population: 182,
    },
    {
      code: 683,
      iso: 'NU',
      name: 'Niue',
      population: 0,
    },
    {
      code: 850,
      iso: 'KP',
      name: 'North Korea',
      population: 22,
    },
    {
      code: 1670,
      iso: 'MP',
      name: 'Northern Mariana Islands',
      population: 0,
    },
    {
      code: 47,
      iso: 'NO',
      name: 'Norway',
      population: 5,
    },
    {
      code: 968,
      iso: 'OM',
      name: 'Oman',
      population: 2,
    },
    {
      code: 92,
      iso: 'PK',
      name: 'Pakistan',
      population: 184,
    },
    {
      code: 680,
      iso: 'PW',
      name: 'Palau',
      population: 0,
    },
    {
      code: 970,
      iso: 'PS',
      name: 'Palestine',
      population: 3,
    },
    {
      code: 507,
      iso: 'PA',
      name: 'Panama',
      population: 3,
    },
    {
      code: 675,
      iso: 'PG',
      name: 'Papua New Guinea',
      population: 6,
    },
    {
      code: 595,
      iso: 'PY',
      name: 'Paraguay',
      population: 6,
    },
    {
      code: 51,
      iso: 'PE',
      name: 'Peru',
      population: 29,
    },
    {
      code: 63,
      iso: 'PH',
      name: 'Philippines',
      population: 102,
    },
    {
      code: 64,
      iso: 'PN',
      name: 'Pitcairn',
      population: 0,
    },
    {
      code: 48,
      iso: 'PL',
      name: 'Poland',
      population: 38,
    },
    {
      code: 351,
      iso: 'PT',
      name: 'Portugal',
      population: 10,
    },
    {
      code: 1787,
      iso: 'PR',
      name: 'Puerto Rico',
      population: 3,
    },
    {
      code: 974,
      iso: 'QA',
      name: 'Qatar',
      population: 0,
    },
    {
      code: 242,
      iso: 'CG',
      name: 'Republic of the Congo',
      population: 3,
    },
    {
      code: 262,
      iso: 'RE',
      name: 'Reunion',
      population: 0,
    },
    {
      code: 40,
      iso: 'RO',
      name: 'Romania',
      population: 21,
    },
    {
      code: 7,
      iso: 'RU',
      name: 'Russia',
      population: 140,
    },
    {
      code: 250,
      iso: 'RW',
      name: 'Rwanda',
      population: 11,
    },
    {
      code: 590,
      iso: 'BL',
      name: 'Saint Barthelemy',
      population: 0,
    },
    {
      code: 290,
      iso: 'SH',
      name: 'Saint Helena',
      population: 0,
    },
    {
      code: 1869,
      iso: 'KN',
      name: 'Saint Kitts and Nevis',
      population: 0,
    },
    {
      code: 1758,
      iso: 'LC',
      name: 'Saint Lucia',
      population: 0,
    },
    {
      code: 590,
      iso: 'MF',
      name: 'Saint Martin',
      population: 0,
    },
    {
      code: 508,
      iso: 'PM',
      name: 'Saint Pierre and Miquelon',
      population: 0,
    },
    {
      code: 1784,
      iso: 'VC',
      name: 'Saint Vincent and the Grenadines',
      population: 0,
    },
    {
      code: 685,
      iso: 'WS',
      name: 'Samoa',
      population: 0,
    },
    {
      code: 378,
      iso: 'SM',
      name: 'San Marino',
      population: 0,
    },
    {
      code: 239,
      iso: 'ST',
      name: 'Sao Tome and Principe',
      population: 0,
    },
    {
      code: 966,
      iso: 'SA',
      name: 'Saudi Arabia',
      population: 25,
    },
    {
      code: 221,
      iso: 'SN',
      name: 'Senegal',
      population: 12,
    },
    {
      code: 381,
      iso: 'RS',
      name: 'Serbia',
      population: 7,
    },
    {
      code: 248,
      iso: 'SC',
      name: 'Seychelles',
      population: 0,
    },
    {
      code: 232,
      iso: 'SL',
      name: 'Sierra Leone',
      population: 5,
    },
    {
      code: 65,
      iso: 'SG',
      name: 'Singapore',
      population: 4,
    },
    {
      code: 1721,
      iso: 'SX',
      name: 'Sint Maarten',
      population: 0,
    },
    {
      code: 421,
      iso: 'SK',
      name: 'Slovakia',
      population: 5,
    },
    {
      code: 386,
      iso: 'SI',
      name: 'Slovenia',
      population: 2,
    },
    {
      code: 677,
      iso: 'SB',
      name: 'Solomon Islands',
      population: 0,
    },
    {
      code: 252,
      iso: 'SO',
      name: 'Somalia',
      population: 10,
    },
    {
      code: 27,
      iso: 'ZA',
      name: 'South Africa',
      population: 54,
    },
    {
      code: 82,
      iso: 'KR',
      name: 'South Korea',
      population: 48,
    },
    {
      code: 211,
      iso: 'SS',
      name: 'South Sudan',
      population: 8,
    },
    {
      code: 34,
      iso: 'ES',
      name: 'Spain',
      population: 46,
    },
    {
      code: 94,
      iso: 'LK',
      name: 'Sri Lanka',
      population: 21,
    },
    {
      code: 249,
      iso: 'SD',
      name: 'Sudan',
      population: 35,
    },
    {
      code: 597,
      iso: 'SR',
      name: 'Suriname',
      population: 0,
    },
    {
      code: 47,
      iso: 'SJ',
      name: 'Svalbard and Jan Mayen',
      population: 0,
    },
    {
      code: 268,
      iso: 'SZ',
      name: 'Swaziland',
      population: 1,
    },
    {
      code: 46,
      iso: 'SE',
      name: 'Sweden',
      population: 9,
    },
    {
      code: 41,
      iso: 'CH',
      name: 'Switzerland',
      population: 8,
    },
    {
      code: 963,
      iso: 'SY',
      name: 'Syria',
      population: 22,
    },
    {
      code: 886,
      iso: 'TW',
      name: 'Taiwan',
      population: 22,
    },
    {
      code: 992,
      iso: 'TJ',
      name: 'Tajikistan',
      population: 7,
    },
    {
      code: 255,
      iso: 'TZ',
      name: 'Tanzania',
      population: 41,
    },
    {
      code: 66,
      iso: 'TH',
      name: 'Thailand',
      population: 67,
    },
    {
      code: 228,
      iso: 'TG',
      name: 'Togo',
      population: 6,
    },
    {
      code: 690,
      iso: 'TK',
      name: 'Tokelau',
      population: 0,
    },
    {
      code: 676,
      iso: 'TO',
      name: 'Tonga',
      population: 0,
    },
    {
      code: 1868,
      iso: 'TT',
      name: 'Trinidad and Tobago',
      population: 1,
    },
    {
      code: 216,
      iso: 'TN',
      name: 'Tunisia',
      population: 10,
    },
    {
      code: 90,
      iso: 'TR',
      name: 'Turkey',
      population: 77,
    },
    {
      code: 993,
      iso: 'TM',
      name: 'Turkmenistan',
      population: 4,
    },
    {
      code: 1649,
      iso: 'TC',
      name: 'Turks and Caicos Islands',
      population: 0,
    },
    {
      code: 688,
      iso: 'TV',
      name: 'Tuvalu',
      population: 0,
    },
    {
      code: 1340,
      iso: 'VI',
      name: 'U.S. Virgin Islands',
      population: 0,
    },
    {
      code: 256,
      iso: 'UG',
      name: 'Uganda',
      population: 33,
    },
    {
      code: 380,
      iso: 'UA',
      name: 'Ukraine',
      population: 45,
    },
    {
      code: 971,
      iso: 'AE',
      name: 'United Arab Emirates',
      population: 4,
    },
    {
      code: 44,
      iso: 'GB',
      name: 'United Kingdom',
      population: 65,
    },
    {
      code: 1,
      iso: 'US',
      name: 'United States',
      population: 324,
    },
    {
      code: 598,
      iso: 'UY',
      name: 'Uruguay',
      population: 3,
    },
    {
      code: 998,
      iso: 'UZ',
      name: 'Uzbekistan',
      population: 27,
    },
    {
      code: 678,
      iso: 'VU',
      name: 'Vanuatu',
      population: 0,
    },
    {
      code: 379,
      iso: 'VA',
      name: 'Vatican',
      population: 0,
    },
    {
      code: 58,
      iso: 'VE',
      name: 'Venezuela',
      population: 26,
    },
    {
      code: 84,
      iso: 'VN',
      name: 'Vietnam',
      population: 91,
    },
    {
      code: 681,
      iso: 'WF',
      name: 'Wallis and Futuna',
      population: 0,
    },
    {
      code: 212,
      iso: 'EH',
      name: 'Western Sahara',
      population: 0,
    },
    {
      code: 967,
      iso: 'YE',
      name: 'Yemen',
      population: 24,
    },
    {
      code: 260,
      iso: 'ZM',
      name: 'Zambia',
      population: 16,
    },
    {
      code: 263,
      iso: 'ZW',
      name: 'Zimbabwe',
      population: 12,
    },
  ];

  return {
    COUNTRY_CODES: COUNTRY_CODES,
    /**
     * Get the country code matching to an ISO name
     * @param {number} code - Country code
     * @returns {string} Returns the ISO standard country name of the most populated country with the matching country code
     */
    getCountryByCode: code => {
      let countries = [];

      for (const country of COUNTRY_CODES) {
        if (country.code === window.parseInt(code, 10)) {
          countries.push(country);
        }
      }

      countries = countries.sort((countryA, countryB) => countryA.population - countryB.population);

      const country = countries.pop();
      if (country) {
        return country.iso;
      }
    },

    /**
     * Get the country code matching an ISO name
     * @param {string} isoName - ISO standard country name
     * @returns {number} Matching country code
     */
    getCountryCode: isoName => {
      for (const country of COUNTRY_CODES) {
        if (country.iso === isoName) {
          return country.code;
        }
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Worker = class Worker {
  constructor(uri) {
    this.post = data => {
      return new Promise((resolve, reject) => {
        const worker = new window.Worker(uri);
        worker.onmessage = event => resolve(event.data);
        worker.onerror = error => reject(error);
        worker.postMessage(data);
      });
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.URLUtil = (() => {
  const TYPE = {
    ACCOUNT: 'TYPE.ACCOUNT',
    SUPPORT: 'TYPE.SUPPORT',
    TEAM_SETTINGS: 'TYPE.TEAM_SETTINGS',
    WEBAPP: 'TYPE.WEBAPP',
    WEBSITE: 'TYPE.WEBSITE',
  };

  const _appendParameter = (url, parameter) => {
    const separator = z.util.StringUtil.includes(url, '?') ? '&' : '?';
    return `${url}${separator}${parameter}`;
  };

  const _buildSupportUrl = support_id => {
    const urlPath = _.isNumber(support_id) ? z.string.urlSupportArticles : z.string.urlSupportRequests;
    return `${_getDomain(TYPE.SUPPORT)}${z.l10n.text(urlPath)}${support_id}`;
  };

  const _buildUrl = (type, path = '') => `${_getDomain(type)}${path && path.startsWith('/') ? path : ''}`;

  const _forwardParameter = (url, parameterName, locationSearch = window.location.search) => {
    const parameterValue = _getParameter(parameterName, locationSearch);
    const hasValue = parameterValue != null;
    return hasValue ? _appendParameter(url, `${parameterName}=${parameterValue}`) : url;
  };

  const _getDomain = urlType => {
    const isProduction = _isProductionBackend();

    switch (urlType) {
      case TYPE.ACCOUNT:
        return isProduction ? window.wire.env.URL.ACCOUNT_BASE : z.config.URL.ACCOUNT.STAGING;
      case TYPE.SUPPORT:
        return z.config.URL.SUPPORT;
      case TYPE.TEAM_SETTINGS:
        return isProduction ? window.wire.env.URL.TEAMS_BASE : z.config.URL.TEAM_SETTINGS.STAGING;
      case TYPE.WEBAPP:
        return isProduction ? window.wire.env.APP_BASE : z.config.URL.WEBAPP.STAGING;
      case TYPE.WEBSITE:
        return isProduction ? window.wire.env.URL.WEBSITE_BASE : z.config.URL.WEBSITE.STAGING;
      default:
        throw new Error('Unknown URL type');
    }
  };

  /**
   * Removes protocol, www and trailing slashes in the given url
   * @param {string} url - URL
   * @returns {string} Plain URL
   */
  const _getDomainName = (url = '') => {
    // force a protocol if there is none
    url = url.replace(/^(?!https?:\/\/)/i, 'http://');
    try {
      const {hostname, pathname, search, hash} = new URL(url);
      return hostname.replace(/^www./, '') + pathname.replace(/\/$/, '') + search + hash;
    } catch (error) {
      return '';
    }
  };

  const _getParameter = (parameterName, locationSearch = window.location.search) => {
    const searchParameters = locationSearch.substring(1).split('&');
    for (const searchParam of searchParameters) {
      const [parameter, value] = searchParam.split('=');
      const isExpectedParameter = parameter === parameterName;
      if (isExpectedParameter) {
        if (value) {
          const decodedValue = window.decodeURI(value);

          if (decodedValue === 'false') {
            return false;
          }

          if (decodedValue === 'true') {
            return true;
          }

          return value;
        }

        return true;
      }
    }

    return null;
  };

  const _getLinksFromHtml = html => {
    if (!html) {
      return [];
    }

    const anchorTags = new RegExp(/<a[\s]+([^>]+)>((?:.(?!\<\/a\>))*.)<\/a>/, 'g');
    const links = html.match(anchorTags);

    const hasLinks = links && links.length;
    return hasLinks ? links.map(element => $(element)[0]) : [];
  };

  const _isProductionBackend = () => z.util.Environment.backend.current === z.service.BackendEnvironment.PRODUCTION;

  /**
   * Prepends http to given url if protocol missing
   * @param {string} url - URL you want to open in a new browser tab
   * @returns {undefined} No return value
   */
  const _prependProtocol = url => (!url.match(/^http[s]?:\/\//i) ? `http://${url}` : url);

  return {
    TYPE: TYPE,
    appendParameter: _appendParameter,
    buildSupportUrl: _buildSupportUrl,
    buildUrl: _buildUrl,
    forwardParameter: _forwardParameter,
    getDomainName: _getDomainName,
    getLinksFromHtml: _getLinksFromHtml,
    getParameter: _getParameter,
    prependProtocol: _prependProtocol,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ValidationUtil = {
  // ToDo: Move z.util.isValidUsername here
  // ToDo: Move z.util.isValidPhoneNumber here
  // ToDo: Move z.util.isIsoString here
  // ToDo: Move z.util.isValidEmail here
  // ToDo: Move z.util.isSameLocation here
  asset: {
    legacy: (assetId, conversationId) => {
      if (!z.util.ValidationUtil.isUUID(assetId) || !z.util.ValidationUtil.isUUID(conversationId)) {
        throw new z.util.ValidationUtilError('Invalid assetId / conversationId');
      }
      return true;
    },

    // https://github.com/wireapp/wire-server/blob/dc3e9a8af5250c0d045e96a31aa23c255b4e01a3/libs/cargohold-types/src/CargoHold/Types/V3.hs#L156-L177
    retentionPolicy: policyId => policyId > 0 && policyId < Object.keys(z.assets.AssetRetentionPolicy).length + 1,

    v3: (assetKey, assetToken) => {
      if (!assetKey) {
        throw new z.util.ValidationUtilError('Asset key not defined');
      }

      const SEPARATOR = '-';
      const [version, type, ...uuid] = assetKey.split(SEPARATOR);

      if (version !== '3') {
        throw new z.util.ValidationUtilError('Invalid asset key (version)');
      }
      if (!z.util.ValidationUtil.asset.retentionPolicy(type)) {
        throw new z.util.ValidationUtilError('Invalid asset key (type)');
      }
      if (!z.util.ValidationUtil.isUUID(uuid.join(SEPARATOR))) {
        throw new z.util.ValidationUtilError('Invalid asset key (UUID)');
      }
      if (assetToken && !z.util.ValidationUtil.isBearerToken(assetToken)) {
        throw new z.util.ValidationUtilError('Invalid asset token');
      }
      return true;
    },
  },

  isBase64: string => {
    try {
      // Will raise a DOM exception if base64 string is invalid
      window.atob(string);
    } catch (error) {
      return false;
    }
    return true;
  },

  // Since some special chars are allowed, remember to always encode Bearer tokens using encodeURIComponents afterwards!
  isBearerToken: token => /^[a-zA-Z0-9\-._~+/]+[=]{0,2}$/.test(token),

  isUUID: string => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(string),

  isValidApiPath: path => {
    const [urlPath] = path.split('?');
    if (!/^\/[a-zA-Z0-9\-_/,]+$/.test(urlPath)) {
      throw new z.util.ValidationUtilError(`Non-compliant path creation attempt. Details: ${path}`);
    }
    return true;
  },

  urls: {
    isTweet: url => {
      const regex = /^http(?:s)?:\/\/(?:(?:www|mobile|0)\.)?twitter\.com\/(?:(?:\w{1,15})\/status(?:es|\/i)?|i\/moments)\/(?:\d{2,21})(?:(?:\?|\/).*)?$/;
      return regex.test(url);
    },
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ValidationUtilError = class ValidationUtilError extends Error {
  constructor(message = 'Unknown ValidationUtilError') {
    super();

    this.message = message;
    this.name = this.constructor.name;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.popup = {
  getCursorPixelPosition: input => {
    const css = getComputedStyle(input);
    const boundingRectangleInput = input.getBoundingClientRect();
    const mask = document.createElement('div');
    const span = document.createElement('span');
    const text = document.createTextNode(input.value);

    mask.appendChild(text);
    mask.style.font = css.font;
    mask.style.position = 'fixed';
    mask.style.left = `${input.clientLeft + boundingRectangleInput.left}px`;
    mask.style.top = `${input.clientTop + boundingRectangleInput.top}px`;
    mask.style.color = 'red';
    mask.style.overflow = 'scroll';
    mask.style.visibility = 'hidden';
    mask.style.whiteSpace = 'pre-wrap';
    mask.style.padding = css.padding;
    mask.style.width = css.width;
    mask.style.height = css.height;
    span.innerText = 'I';

    const position = input.selectionStart;
    if (position === input.value.length) {
      mask.appendChild(span);
    } else {
      mask.insertBefore(span, mask.childNodes[0].splitText(position));
    }
    document.body.appendChild(mask);
    span.scrollIntoView();

    const boundingRectangleSpan = span.getBoundingClientRect();

    mask.remove();
    return boundingRectangleSpan;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};

window.z.config = {
  ACCENT_ID: {
    BLUE: 1,
    GREEN: 2,
    ORANGE: 5,
    PINK: 6,
    PURPLE: 7,
    RED: 4,
    YELLOW: 3,
  },

  LOGGER: {
    OPTIONS: {
      domains: {
        'app.wire.com': () => 0,
        localhost: () => 300,
        'wire.ms': () => 300,
        'wire-webapp-staging.wire.com': () => 300,
        'zinfra.io': () => 300,
      },
      name_length: 65,
    },
  },

  // 10 seconds until phone code expires
  LOGIN_CODE_EXPIRATION: 10 * 60,

  // 25 megabyte upload limit for personal use
  MAXIMUM_ASSET_FILE_SIZE_PERSONAL: 25 * 1024 * 1024,

  // 100 megabyte upload limit for organizations
  MAXIMUM_ASSET_FILE_SIZE_TEAM: 100 * 1024 * 1024,

  // 15 megabyte image upload limit
  MAXIMUM_IMAGE_FILE_SIZE: 15 * 1024 * 1024,

  // Maximum characters per sent message
  MAXIMUM_MESSAGE_LENGTH: 8000,

  // Maximum characters per received message
  // Encryption is approx. +40% of the original payload so let's round it at +50%
  MAXIMUM_MESSAGE_LENGTH_RECEIVING: 12000 * 1.5,

  // bigger requests will be split in chunks with a maximum size as defined
  MAXIMUM_USERS_PER_REQUEST: 200,

  // number of messages that will be pulled
  MESSAGES_FETCH_LIMIT: 30,

  MINIMUM_PASSWORD_LENGTH: 8,

  // measured in pixel
  SCROLL_TO_LAST_MESSAGE_THRESHOLD: 100,

  SUPPORT: {
    FORM: {
      BUG: 'new?ticket_form_id=101615',
      CONTACT: 'new',
    },
    ID: {
      CALLING: 202969412,
      CAMERA_ACCESS_DENIED: 202935412,
      DEVICE_ACCESS_DENIED: 213512545,
      DEVICE_NOT_FOUND: 202970662,
      HISTORY: 207834645,
      MICROPHONE_ACCESS_DENIED: 202590081,
      SCREEN_ACCESS_DENIED: 202935412,
    },
  },

  UNSPLASH_URL: 'https://source.unsplash.com/1200x1200/?landscape',

  URL: {
    ACCOUNT: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.ACCOUNT_BASE) || 'https://account.wire.com',
      STAGING: 'https://wire-account-staging.zinfra.io',
    },
    SUPPORT: 'https://support.wire.com',
    TEAM_SETTINGS: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.TEAMS_BASE) || 'https://teams.wire.com',
      STAGING: 'https://wire-admin-staging.zinfra.io',
    },
    WEBAPP: {
      INTERNAL: 'https://wire-webapp-staging.wire.com',
      PRODUCTION: window.wire.env.APP_BASE || 'https://app.wire.com',
      STAGING: 'https://wire-webapp-staging.zinfra.io',
    },
    WEBSITE: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.WEBSITE_BASE) || 'https://wire.com',
      STAGING: 'https://wire-website-staging.zinfra.io',
    },
  },

  URL_PATH: {
    CREATE_TEAM: '/create-team/',
    DECRYPT_ERROR_1: '/privacy/error-1/',
    DECRYPT_ERROR_2: '/privacy/error-2/',
    MANAGE_SERVICES: '/services/',
    MANAGE_TEAM: '/login/',
    PASSWORD_RESET: '/forgot/',
    PRIVACY_HOW: '/privacy/how/',
    PRIVACY_WHY: '/privacy/why/',
    SUPPORT_USERNAME: '/support/username/',
    TERMS_OF_USE: '/legal/terms/',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.BaseError = class BaseError extends Error {
  constructor(name, type, message) {
    super();

    this.name = this.constructor.name;
    this.stack = new Error().stack;

    const ErrorInstanceClass = z.error[name];
    const knownTypes = Object.assign({}, BaseError.TYPE, ErrorInstanceClass.TYPE);
    const isValidType = Object.values(knownTypes).includes(type);

    this.type = isValidType ? type : BaseError.TYPE.UNKNOWN;

    this.message = message || ErrorInstanceClass.MESSAGE[this.type] || BaseError.MESSAGE[this.type];
    if (!this.message) {
      this.message = `${BaseError.MESSAGE.UNKNOWN} ${name}`;
    }
  }

  static get MESSAGE() {
    return {
      INVALID_PARAMETER: 'Invalid parameter passed',
      MISSING_PARAMETER: 'Required parameter is not defined',
      UNKNOWN: 'Unknown',
    };
  }

  static get TYPE() {
    return {
      INVALID_PARAMETER: 'INVALID_PARAMETER',
      MISSING_PARAMETER: 'MISSING_PARAMETER',
      UNKNOWN: 'UNKNOWN',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AccessTokenError = class AccessTokenError extends z.error.BaseError {
  constructor(type, message) {
    super('AccessTokenError', type, message);
  }

  static get MESSAGE() {
    return {
      NOT_FOUND_IN_CACHE: 'No cached access token found in Local Storage',
      REQUEST_FAILED: 'Exceeded allowed number of retries to get Access Token',
      REQUEST_FORBIDDEN: 'Request to POST for access token failed',
      RETRIES_EXCEEDED: 'Request to POST for access token forbidden',
    };
  }

  static get TYPE() {
    return {
      NOT_FOUND_IN_CACHE: 'NOT_FOUND_IN_CACHE',
      REQUEST_FAILED: 'REQUEST_FAILED',
      REQUEST_FORBIDDEN: 'REQUEST_FORBIDDEN',
      RETRIES_EXCEEDED: 'RETRIES_EXCEEDED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AuthError = class AuthError extends z.error.BaseError {
  constructor(type, message) {
    super('AuthError', type, message);
  }

  static get MESSAGE() {
    return {
      COOKIES_DISABLED: 'Cookies are disabled',
      INDEXED_DB_UNSUPPORTED: 'IndexedDB is not supported',
      MULTIPLE_TABS: 'Cannot open in multiple tabs simultaneously',
      PRIVATE_MODE: 'Unsupported Private Mode',
    };
  }

  static get TYPE() {
    return {
      COOKIES_DISABLED: 'COOKIES_DISABLED',
      INDEXED_DB_UNSUPPORTED: 'INDEXED_DB_UNSUPPORTED',
      MULTIPLE_TABS: 'MULTIPLE_TABS',
      PRIVATE_MODE: 'PRIVATE_MODE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AudioError = class AudioError extends z.error.BaseError {
  constructor(type, message) {
    super('AudioError', type, message);
  }

  static get MESSAGE() {
    return {
      ALREADY_PLAYING: 'Sound is already playing',
      FAILED_TO_PLAY: 'Failed to play sound',
      IGNORED_SOUND: 'Ignored request to play sound',
      NOT_FOUND: 'AudioElement or ID not found',
    };
  }

  static get TYPE() {
    return {
      ALREADY_PLAYING: 'ALREADY_PLAYING',
      FAILED_TO_PLAY: 'FAILED_TO_PLAY',
      IGNORED_SOUND: 'IGNORED_SOUND',
      NOT_FOUND: 'NOT_FOUND',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.BackendClientError = class BackendClientError extends z.error.BaseError {
  constructor(params) {
    const message = params.message || `${params}`;

    super('BackendClientError', BackendClientError.TYPE.GENERIC, message);

    if (_.isObject(params)) {
      this.code = params.code;
      this.label = params.label;
    } else if (_.isNumber(params)) {
      this.code = params;
    }
  }

  static get LABEL() {
    return {
      BAD_GATEWAY: 'bad-gateway',
      BAD_REQUEST: 'bad-request',
      BLACKLISTED_EMAIL: 'blacklisted-email',
      BLACKLISTED_PHONE: 'blacklisted-phone',
      CLIENT_ERROR: 'client-error',
      CONNECTIVITY_PROBLEM: 'connectivity-problem',
      INVALID_CREDENTIALS: 'invalid-credentials',
      INVALID_EMAIL: 'invalid-email',
      INVALID_INVITATION_CODE: 'invalid-invitation-code',
      INVALID_PHONE: 'invalid-phone',
      KEY_EXISTS: 'key-exists',
      MISSING_AUTH: 'missing-auth',
      MISSING_IDENTITY: 'missing-identity',
      NOT_CONNECTED: 'not-connected',
      NOT_FOUND: 'not-found',
      PASSWORD_EXISTS: 'password-exists',
      PENDING_ACTIVATION: 'pending-activation',
      PENDING_LOGIN: 'pending-login',
      PHONE_BUDGET_EXHAUSTED: 'phone-budget-exhausted',
      SERVER_ERROR: 'server-error',
      SERVICE_DISABLED: 'service-disabled',
      SUSPENDED: 'suspended',
      TOO_MANY_BOTS: 'too-many-bots',
      TOO_MANY_CLIENTS: 'too-many-clients',
      TOO_MANY_MEMBERS: 'too-many-members',
      UNAUTHORIZED: 'unauthorized',
      UNKNOWN_CLIENT: 'unknown-client',
    };
  }

  static get STATUS_CODE() {
    return {
      ACCEPTED: 202,
      BAD_GATEWAY: 502,
      BAD_REQUEST: 400,
      CONFLICT: 409,
      CONNECTIVITY_PROBLEM: 0,
      CREATED: 201,
      FORBIDDEN: 403,
      INTERNAL_SERVER_ERROR: 500,
      NO_CONTENT: 204,
      NOT_FOUND: 404,
      OK: 200,
      PRECONDITION_FAILED: 412,
      REQUEST_TIMEOUT: 408,
      REQUEST_TOO_LARGE: 413,
      TOO_MANY_REQUESTS: 429,
      UNAUTHORIZED: 401,
    };
  }

  static get TYPE() {
    return {
      GENERIC: 'GENERIC',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.CallError = class CallError extends z.error.BaseError {
  constructor(type, message) {
    super('CallError', type, message);
  }

  static get MESSAGE() {
    return {
      MISTARGETED_MESSAGE: 'Message targeted at another client',
      NO_CONVERSATION_ID: 'No conversation ID given',
      NO_DATA_CHANNEL: 'No established data channel for call',
      NO_REPLACEABLE_TRACK: 'No replaceable MediaStreamTrack found',
      NO_USER_ID: 'Missing user ID to target message',
      NOT_FOUND: 'No call for conversation ID found',
      NOT_SUPPORTED: 'Calling is not supported',
      RTP_SENDER_NOT_SUPPORTED: 'PeerConnection does not support RtcRtpSender extension',
      UNSUPPORTED_VERSION: 'Unsupported version of the call protocol',
      WRONG_CONVERSATION_TYPE: 'Wrong conversation type for call message',
      WRONG_PAYLOAD_FORMAT: 'Payload for a call message is in wrong format',
      WRONG_SENDER: 'Call change from wrong sender',
      WRONG_STATE: 'Call in wrong state for change',
    };
  }

  static get TYPE() {
    return {
      MISTARGETED_MESSAGE: 'MISTARGETED_MESSAGE',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_DATA_CHANNEL: 'NO_DATA_CHANNEL',
      NO_REPLACEABLE_TRACK: 'NO_REPLACEABLE_TRACK',
      NO_USER_ID: 'NO_USER_ID',
      NOT_FOUND: 'NOT_FOUND',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      RTP_SENDER_NOT_SUPPORTED: 'RTP_SENDER_NOT_SUPPORTED',
      UNSUPPORTED_VERSION: 'UNSUPPORTED_VERSION',
      WRONG_CONVERSATION_TYPE: 'WRONG_CONVERSATION_TYPE',
      WRONG_PAYLOAD_FORMAT: 'WRONG_PAYLOAD_FORMAT',
      WRONG_SENDER: 'WRONG_SENDER',
      WRONG_STATE: 'WRONG_STATE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ClientError = class ClientError extends z.error.BaseError {
  constructor(type, message) {
    super('ClientError', type, message);
  }

  static get MESSAGE() {
    return {
      CLIENT_NOT_SET: 'Local client is not yet set',
      DATABASE_FAILURE: 'Client related database transaction failed',
      NO_CLIENT_ID: 'Client ID is not defined',
      NO_USER_ID: 'User ID is not defined',
      NO_VALID_CLIENT: 'No valid local client found',
      REQUEST_FAILURE: 'Client related backend request failed',
      REQUEST_FORBIDDEN: 'Client related backend request forbidden',
      TOO_MANY_CLIENTS: 'User has reached the maximum of allowed clients',
    };
  }

  static get TYPE() {
    return {
      CLIENT_NOT_SET: 'CLIENT_NOT_SET',
      DATABASE_FAILURE: 'DATABASE_FAILURE',
      NO_CLIENT_ID: 'NO_CLIENT_ID',
      NO_USER_ID: 'NO_USER_ID',
      NO_VALID_CLIENT: 'NO_VALID_CLIENT',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      REQUEST_FORBIDDEN: 'REQUEST_FORBIDDEN',
      TOO_MANY_CLIENTS: 'TOO_MANY_CLIENTS',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConnectError = class ConnectError extends z.error.BaseError {
  constructor(type, message) {
    super('ConnectError', type, message);
  }

  static get MESSAGE() {
    return {
      NO_CONTACTS: 'No contacts found for matching',
      NOT_SUPPORTED: 'Source not supported',
      UPLOAD: 'Address book upload failed',
    };
  }

  static get TYPE() {
    return {
      NO_CONTACTS: 'NO_CONTACTS',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      UPLOAD: 'UPLOAD',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConnectionError = class ConnectionError extends z.error.BaseError {
  constructor(type, message) {
    super('ConnectionError', type, message);
  }

  static get MESSAGE() {
    return {};
  }

  static get TYPE() {
    return {};
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConversationError = class ConversationError extends z.error.BaseError {
  constructor(type, message) {
    super('ConversationError', type, message);
  }

  static get MESSAGE() {
    return {
      CONVERSATION_NOT_FOUND: 'Conversation not found',
      DEGRADED_CONVERSATION_CANCELLATION: 'Sending to degraded conversation was canceled by user',
      MESSAGE_NOT_FOUND: 'Message not found in conversation',
      NO_CHANGES: 'Missing changes to message',
      NO_CONVERSATION_ID: 'Conversation ID is not defined',
      NO_MESSAGE_CHANGES: 'Edited message equals original message',
      REQUEST_FAILURE: 'Conversation related backend request failed',
      WRONG_CHANGE: 'Attempted unsupported change on conversation',
      WRONG_CONVERSATION: 'Message was sent in the wrong conversation',
      WRONG_TYPE: 'Wrong message to for action',
      WRONG_USER: 'Wrong user tried to change or delete a message',
    };
  }

  static get TYPE() {
    return {
      CONVERSATION_NOT_FOUND: 'CONVERSATION_NOT_FOUND',
      DEGRADED_CONVERSATION_CANCELLATION: 'DEGRADED_CONVERSATION_CANCELLATION',
      MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',
      NO_CHANGES: 'NO_CHANGES',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_MESSAGE_CHANGES: 'NO_MESSAGE_CHANGES',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      WRONG_CHANGE: 'WRONG_CHANGE',
      WRONG_CONVERSATION: 'WRONG_CONVERSATION',
      WRONG_TYPE: 'WRONG_TYPE',
      WRONG_USER: 'WRONG_USER',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.CryptographyError = class CryptographyError extends z.error.BaseError {
  constructor(type, message) {
    super('CryptographyError', type, message);
  }

  static get MESSAGE() {
    return {
      BROKEN_EXTERNAL: 'Failed to map external message',
      IGNORED_ASSET: 'Ignored asset preview',
      IGNORED_PREVIEW: 'Ignored image preview',
      NO_DATA_CONTENT: 'No message data content found',
      NO_GENERIC_MESSAGE: 'No GenericMessage found',
      PREVIOUSLY_STORED: 'Message was previously stored',
      UNHANDLED_TYPE: 'Unhandled event type',
    };
  }

  static get TYPE() {
    return {
      BROKEN_EXTERNAL: 'BROKEN_EXTERNAL',
      IGNORED_ASSET: 'IGNORED_ASSET',
      IGNORED_PREVIEW: 'IGNORED_PREVIEW',
      NO_DATA_CONTENT: 'NO_DATA_CONTENT',
      NO_GENERIC_MESSAGE: 'NO_GENERIC_MESSAGE',
      PREVIOUSLY_STORED: 'PREVIOUSLY_STORED',
      UNHANDLED_TYPE: 'UNHANDLED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.EventError = class EventError extends z.error.BaseError {
  constructor(type, message) {
    super('EventError', type, message);
  }

  static get MESSAGE() {
    return {
      DATABASE_FAILURE: 'Event related database transaction failure',
      DEPRECATED_SCHEMA: 'Event type is deprecated',
      NO_CLIENT_ID: 'Missing client id',
      NO_EVENT: 'Event is missing',
      NO_LAST_DATE: 'Last event date not found in storage',
      NO_LAST_ID: 'Last notification ID not found in storage',
      NO_NOTIFICATIONS: 'No notifications found',
      OUTDATED_E_CALL_EVENT: 'Ignoring outdated e-call event',
      REQUEST_FAILURE: 'Event related backend request failure',
      VALIDATION_FAILED: 'Event failed validation',
    };
  }

  static get TYPE() {
    return {
      DATABASE_FAILURE: 'DATABASE_FAILURE',
      DEPRECATED_SCHEMA: 'DEPRECATED_SCHEMA',
      NO_CLIENT_ID: 'NO_CLIENT_ID',
      NO_EVENT: 'NO_EVENT',
      NO_LAST_DATE: 'NO_LAST_DATE',
      NO_LAST_ID: 'NO_LAST_ID',
      NO_NOTIFICATIONS: 'NO_NOTIFICATIONS',
      OUTDATED_E_CALL_EVENT: 'EventError.OUTDATED_E_CALL_EVENT',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      VALIDATION_FAILED: 'VALIDATION_FAILED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.LinkPreviewError = class LinkPreviewError extends z.error.BaseError {
  constructor(type, message) {
    super('LinkPreviewError', type, message);
  }

  static get MESSAGE() {
    return {
      BLACKLISTED: 'Skipped preview for blacklisted link',
      NO_DATA_AVAILABLE: 'Link does not provide Open Graph data.',
      NOT_SUPPORTED: 'Your client cannot render link previews using Open Graph data.',
      UNSUPPORTED_TYPE: 'Open Graph data from the given link does not provide necessary attributes.',
    };
  }

  static get TYPE() {
    return {
      BLACKLISTED: 'BLACKLISTED',
      NO_DATA_AVAILABLE: 'NO_DATA_AVAILABLE',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      UNSUPPORTED_TYPE: 'UNSUPPORTED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.LocationError = class LocationError extends z.error.BaseError {
  constructor(type, message) {
    super('LocationError', type, message);
  }

  static get MESSAGE() {
    return {
      REQUEST_FAILED: 'Location related request failed',
    };
  }

  static get TYPE() {
    return {
      REQUEST_FAILED: 'REQUEST_FAILED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.MediaError = class MediaError extends z.error.BaseError {
  constructor(type, mediaType, message) {
    super('MediaError', type, message);

    this.mediaType = mediaType;
  }

  static get MESSAGE() {
    return {
      MEDIA_STREAM_DEVICE: 'Device related failure when getting MediaStream',
      MEDIA_STREAM_MISC: 'Other failure when getting MediaStream',
      MEDIA_STREAM_PERMISSION: 'Permission related failure when getting MediaStream',
      NO_MEDIA_DEVICES_FOUND: 'No MediaDevices found',
      SCREEN_NOT_SUPPORTED: 'Screen sharing is not yet supported by this browser',
      STREAM_NOT_FOUND: 'No local MediaStream found',
      UNHANDLED_MEDIA_TYPE: 'Media type unknown',
    };
  }

  static get TYPE() {
    return {
      MEDIA_STREAM_DEVICE: 'MEDIA_STREAM_DEVICE',
      MEDIA_STREAM_MISC: 'MEDIA_STREAM_MISC',
      MEDIA_STREAM_PERMISSION: 'MEDIA_STREAM_PERMISSION',
      NO_MEDIA_DEVICES_FOUND: 'NO_MEDIA_DEVICES_FOUND',
      SCREEN_NOT_SUPPORTED: 'SCREEN_NOT_SUPPORTED',
      STREAM_NOT_FOUND: 'STREAM_NOT_FOUND',
      UNHANDLED_MEDIA_TYPE: 'MediaError.UNHANDLED_MEDIA_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.NotificationError = class NotificationError extends z.error.BaseError {
  constructor(type, message) {
    super('NotificationError', type, message);
  }

  static get MESSAGE() {
    return {
      HIDE_NOTIFICATION: 'Do not show notification for this message',
    };
  }

  static get TYPE() {
    return {
      HIDE_NOTIFICATION: 'HIDE_NOTIFICATION',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.PermissionError = class PermissionError extends z.error.BaseError {
  constructor(type, message) {
    super('PermissionError', type, message);
  }

  static get MESSAGE() {
    return {
      DENIED: 'Permission was denied',
      UNSUPPORTED: 'Permissions API is not supported',
      UNSUPPORTED_TYPE: 'Permissions API does not support requested type',
    };
  }

  static get TYPE() {
    return {
      DENIED: 'DENIED',
      UNSUPPORTED: 'UNSUPPORTED',
      UNSUPPORTED_TYPE: 'UNSUPPORTED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.StorageError = class StorageError extends z.error.BaseError {
  constructor(type, message) {
    super('StorageError', type, message);
  }

  static get MESSAGE() {
    return {
      DATA_STORE_NOT_FOUND: 'Data store not found',
      FAILED_TO_OPEN: 'Failed to open database',
      INVALID_TIME: 'Event time needs to be ISO 8601',
      INVALID_TIMESTAMP: 'Invalid timestamp',
      NO_CONVERSATION_ID: 'Missing conversation ID',
      NO_DATA: 'Storage value is undefined or null',
      NO_SENDER_ID: 'Missing sender ID',
      NO_TIME: 'Missing time',
      NON_SEQUENTIAL_UPDATE: 'Update is non sequential',
      NOT_FOUND: 'Record matching primary key was not found',
    };
  }

  static get TYPE() {
    return {
      DATA_STORE_NOT_FOUND: 'DATA_STORE_NOT_FOUND',
      FAILED_TO_OPEN: 'FAILED_TO_OPEN',
      INVALID_TIME: 'INVALID_TIME',
      INVALID_TIMESTAMP: 'INVALID_TIMESTAMP',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_DATA: 'NO_DATA',
      NO_SENDER_ID: 'NO_SENDER_ID',
      NO_TIME: 'NO_TIME',
      NON_SEQUENTIAL_UPDATE: 'NON_SEQUENTIAL_UPDATE',
      NOT_FOUND: 'NOT_FOUND',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.TeamError = class TeamError extends z.error.BaseError {
  constructor(type, message) {
    super('TeamError', type, message);
  }

  static get MESSAGE() {
    return {
      NO_PERMISSIONS: 'No permissions provided',
    };
  }

  static get TYPE() {
    return {
      NO_PERMISSIONS: 'NO_PERMISSIONS',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.UserError = class UserError extends z.error.BaseError {
  constructor(type, message) {
    super('UserError', type, message);
  }

  static get MESSAGE() {
    return {
      INVALID_UPDATE: 'False input data for requested update',
      PRE_KEY_NOT_FOUND: 'Pre-key not found',
      REQUEST_FAILURE: 'User related backend request failure',
      USER_MISSING_EMAIL: 'Self user has not set email address',
      USER_NOT_FOUND: 'User not found',
      USERNAME_TAKEN: 'Username is already taken',
    };
  }

  static get TYPE() {
    return {
      INVALID_UPDATE: 'INVALID_UPDATE',
      PRE_KEY_NOT_FOUND: 'PRE_KEY_NOT_FOUND',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      USER_MISSING_EMAIL: 'USER_MISSING_EMAIL',
      USER_NOT_FOUND: 'USER_NOT_FOUND',
      USERNAME_TAKEN: 'USERNAME_TAKEN',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

window.z.audio.AudioRepository = class AudioRepository {
  constructor() {
    this.logger = new z.util.Logger('z.audio.AudioRepository', z.config.LOGGER.OPTIONS);
    this.audioElements = {};
    this.currentlyLooping = {};
    this.audioPreference = ko.observable(z.audio.AudioPreference.ALL);
    this.audioPreference.subscribe(audioPreference => {
      if (audioPreference === z.audio.AudioPreference.NONE) {
        this._stopAll();
      }
    });
    this.muted = true;
    this._subscribeToEvents();
  }

  /**
   * Check if sound should be played with current setting.
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {Promise} Resolves if the sound should be played.
   */
  _checkSoundSetting(audioId) {
    if (this.muted && !z.audio.AudioPlayingType.MUTED.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    const preferenceIsNone = this.audioPreference() === z.audio.AudioPreference.NONE;
    if (preferenceIsNone && !z.audio.AudioPlayingType.NONE.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    const preferenceIsSome = this.audioPreference() === z.audio.AudioPreference.SOME;
    if (preferenceIsSome && !z.audio.AudioPlayingType.SOME.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    return Promise.resolve();
  }

  /**
   * Create HTMLAudioElement.
   * @private
   * @param {string} sourcePath - Source for HTMLAudioElement
   * @returns {HTMLAudioElement} Returns the audio element.
   */
  _createAudioElement(sourcePath) {
    const audioElement = new Audio();
    audioElement.preload = 'none';
    audioElement.src = sourcePath;
    return audioElement;
  }

  /**
   * Get the sound object
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {Promise} Resolves with the HTMLAudioElement.
   */
  _getSoundById(audioId) {
    if (this.audioElements[audioId]) {
      return Promise.resolve(this.audioElements[audioId]);
    }
    return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.NOT_FOUND));
  }

  /**
   * Initialize all sounds.
   * @private
   * @returns {undefined}
   */
  _initSounds() {
    Object.values(z.audio.AudioType).forEach(audioId => {
      this.audioElements[audioId] = this._createAudioElement(`/audio/${audioId}.mp3`);
    });

    this.logger.info('Initialized sounds');
  }

  /**
   * Start playback of a sound.
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @param {HTMLAudioElement} audioElement - AudioElement to play
   * @param {boolean} playInLoop - Play sound in loop
   * @returns {Promise} Resolves with the HTMLAudioElement
   */
  _play(audioId, audioElement, playInLoop = false) {
    if (!audioId || !audioElement) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.NOT_FOUND));
    }

    return new Promise((resolve, reject) => {
      if (audioElement.paused) {
        audioElement.loop = playInLoop;

        if (audioElement.currentTime !== 0) {
          audioElement.currentTime = 0;
        }

        const _playSuccess = () => {
          if (playInLoop) {
            this.currentlyLooping[audioId] = audioId;
          }
          resolve(audioElement);
        };

        const playPromise = audioElement.play();

        if (playPromise) {
          return playPromise
            .then(_playSuccess)
            .catch(() => reject(new z.error.AudioError(z.error.AudioError.TYPE.FAILED_TO_PLAY)));
        }

        _playSuccess();
      } else {
        reject(new z.error.AudioError(z.error.AudioError.TYPE.ALREADY_PLAYING));
      }
    });
  }

  /**
   * Preload all sounds for immediate playback.
   * @private
   * @returns {undefined}
   */
  _preLoad() {
    Object.values(this.audioElements).forEach(audioElement => {
      audioElement.preload = 'auto';
      audioElement.load();
    });

    this.logger.info('Pre-loading audio files for immediate playback');
  }

  /**
   * Stop all sounds playing in loop.
   * @private
   * @returns {undefined}
   */
  _stopAll() {
    Object.keys(this.currentlyLooping).forEach(audioId => this.stop(audioId));
  }

  /**
   * Use Amplify to subscribe to all audio playback related events.
   * @private
   * @returns {undefined}
   */
  _subscribeToAudioEvents() {
    amplify.subscribe(z.event.WebApp.AUDIO.PLAY, this.play.bind(this));
    amplify.subscribe(z.event.WebApp.AUDIO.PLAY_IN_LOOP, this.loop.bind(this));
    amplify.subscribe(z.event.WebApp.AUDIO.STOP, this.stop.bind(this));
  }

  /**
   * Use Amplify to subscribe to required events.
   * @private
   * @returns {undefined}
   */
  _subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setMutedState.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updatedProperties.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.SOUND_ALERTS, this.setAudioPreference.bind(this));
  }

  /**
   * Initialize the repository.
   * @param {boolean} preLoad - Should sounds be pre-loaded with false as default
   * @returns {undefined}
   */
  init(preLoad = false) {
    this._initSounds();
    this._subscribeToAudioEvents();
    if (preLoad) {
      this._preLoad();
    }
  }

  /**
   * Start playback of a sound in a loop.
   * @note Prevent playing multiples instances of looping sounds
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {undefined}
   */
  loop(audioId) {
    this.play(audioId, true);
  }

  /**
   * Start playback of a sound.
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @param {boolean} playInLoop - Play sound in loop
   * @returns {undefined}
   */
  play(audioId, playInLoop = false) {
    this._checkSoundSetting(audioId)
      .then(() => this._getSoundById(audioId))
      .then(audioElement => this._play(audioId, audioElement, playInLoop))
      .then(audioElement => this.logger.info(`Playing sound '${audioId}' (loop: '${playInLoop}')`, audioElement))
      .catch(error => {
        if (!(error instanceof z.error.AudioError)) {
          this.logger.error(`Failed playing sound '${audioId}': ${error.message}`);
          throw error;
        }
      });
  }

  setAudioPreference(audioPreference) {
    this.audioPreference(audioPreference);
  }

  setMutedState(handlingNotifications) {
    const updatedMutedState = handlingNotifications !== z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.muted !== updatedMutedState;
    if (isStateChange) {
      this.muted = updatedMutedState;
      this.logger.debug(`Set muted state to '${this.muted}'`);
    }
  }

  /**
   * Stop playback of a sound.
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {undefined}
   */
  stop(audioId) {
    this._getSoundById(audioId)
      .then(audioElement => {
        if (!audioElement.paused) {
          this.logger.info(`Stopping sound '${audioId}'`, audioElement);
          audioElement.pause();
        }

        if (this.currentlyLooping[audioId]) {
          delete this.currentlyLooping[audioId];
        }
      })
      .catch(error => {
        this.logger.error(`Failed stopping sound '${audioId}': ${error.message}`);
        throw error;
      });
  }

  updatedProperties(properties) {
    this.setAudioPreference(properties.settings.sound.alerts);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioPreference = {
  ALL: 'all',
  NONE: 'none',
  SOME: 'some',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioType = {
  ALERT: 'alert',
  CALL_DROP: 'call_drop',
  INCOMING_CALL: 'ringing_from_them',
  INCOMING_PING: 'ping_from_them',
  NETWORK_INTERRUPTION: 'nw_interruption',
  NEW_MESSAGE: 'new_message',
  OUTGOING_CALL: 'ringing_from_me',
  OUTGOING_PING: 'ping_from_me',
  READY_TO_TALK: 'ready_to_talk',
  TALK_LATER: 'talk_later',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioPlayingType = {
  MUTED: [z.audio.AudioType.CALL_DROP, z.audio.AudioType.NETWORK_INTERRUPTION],
  NONE: [
    z.audio.AudioType.CALL_DROP,
    z.audio.AudioType.NETWORK_INTERRUPTION,
    z.audio.AudioType.OUTGOING_CALL,
    z.audio.AudioType.READY_TO_TALK,
    z.audio.AudioType.TALK_LATER,
  ],
  SOME: [
    z.audio.AudioType.CALL_DROP,
    z.audio.AudioType.INCOMING_CALL,
    z.audio.AudioType.INCOMING_PING,
    z.audio.AudioType.NETWORK_INTERRUPTION,
    z.audio.AudioType.OUTGOING_CALL,
    z.audio.AudioType.OUTGOING_PING,
    z.audio.AudioType.READY_TO_TALK,
    z.audio.AudioType.TALK_LATER,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.AuthService = class AuthService {
  static get CONFIG() {
    return {
      POST_ACCESS_RETRY: {
        LIMIT: 10,
        TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.5,
      },
      URL_ACCESS: '/access',
      URL_COOKIES: '/cookies',
      URL_LOGIN: '/login',
    };
  }

  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.auth.AuthService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Get all cookies for a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//getCookies
   * @returns {Promise} Promise that resolves with an array of cookies.
   */
  getCookies() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: AuthService.CONFIG.URL_COOKIES,
    });
  }

  /**
   * Get access token if a valid cookie is provided.
   *
   * @example Access token data we expect:
   *  access_token: Lt-IRHxkY9JLA5UuBR3Exxj5lCUf... - Token
   *  expires_in: 900 - Expiration in seconds
   *  token_type: Bearer - Token type
   *  user: 4363e274-69c9-... - User ID
   *
   * @note Don't use our client wrapper here, because to query "/access" we need to set "withCredentials" to "true" in order to send the cookie.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//newAccessToken
   * @param {number} retryAttempt - Retry attempts when a request fails
   * @returns {Promise} Promise which resolves with access token data (token_type, etc.).
   */
  postAccess(retryAttempt = 1) {
    return new Promise((resolve, reject) => {
      const ajaxConfig = {
        crossDomain: true,
        type: 'POST',
        url: this.backendClient.createUrl(AuthService.CONFIG.URL_ACCESS),
        xhrFields: {
          withCredentials: true,
        },
      };

      if (this.backendClient.accessToken) {
        const {accessToken, accessTokenType} = this.backendClient;
        ajaxConfig.headers = {
          Authorization: `${accessTokenType} ${window.decodeURIComponent(accessToken)}`,
        };
      }

      ajaxConfig.success = accessTokenResponse => {
        const {access_token: accessToken, token_type: accessTokenType} = accessTokenResponse;
        this.backendClient.clearQueueUnblockTimeout();
        this.saveAccessTokenInClient(accessTokenType, accessToken);
        resolve(accessTokenResponse);
      };

      ajaxConfig.error = (jqXHR, textStatus, errorThrown) => {
        const isRequestForbidden = jqXHR.status === z.error.BackendClientError.STATUS_CODE.FORBIDDEN;
        if (isRequestForbidden) {
          this.logger.warn(`Request for access token forbidden (Attempt '${retryAttempt}'): ${errorThrown}`, jqXHR);
          return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN));
        }

        const exceededRetries = retryAttempt > AuthService.CONFIG.POST_ACCESS_RETRY.LIMIT;
        if (exceededRetries) {
          this.saveAccessTokenInClient();
          this.logger.warn(`Exceeded limit of attempts to refresh access token': ${errorThrown}`, jqXHR);
          return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.RETRIES_EXCEEDED));
        }

        retryAttempt++;

        const _retry = () => {
          return this.postAccess(retryAttempt)
            .then(resolve)
            .catch(reject);
        };

        const isConnectivityProblem = jqXHR.status === z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM;
        if (isConnectivityProblem) {
          this.logger.warn('Delaying request for access token due to suspected connectivity issue');
          this.backendClient.clearQueueUnblockTimeout();

          return this.backendClient
            .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_REFRESH)
            .then(() => {
              this.logger.info('Continuing to request access token after verifying connectivity');
              this.backendClient.queueState(z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH);
              this.backendClient.scheduleQueueUnblock();
              return _retry();
            });
        }

        return window.setTimeout(() => {
          this.logger.info(`Trying to request a new access token (Attempt '${retryAttempt}')`);
          return _retry();
        }, AuthService.CONFIG.POST_ACCESS_RETRY.TIMEOUT);
      };

      $.ajax(ajaxConfig);
    });
  }

  /**
   * Delete cookies on backend.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//rmCookies
   *
   * @param {string} email - Email address of user
   * @param {string} password - Password of user
   * @param {string[]} [labels] - A list of cookie labels to remove from the system (optional)
   * @returns {jQuery.jqXHR} A superset of the XMLHTTPRequest object.
   */
  postCookiesRemove(email, password, labels) {
    return this.backendClient.sendJson({
      data: {
        email: email,
        labels: labels,
        password: password,
      },
      type: 'POST',
      url: `${AuthService.CONFIG.URL_COOKIES}/remove`,
    });
  }

  /**
   * Login in order to obtain an access-token and cookie.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//login
   *
   * @param {Object} login - Containing sign in information
   * @param {string} login.email - The email address for a password login
   * @param {string} login.phone - The phone number for a password or SMS login
   * @param {string} login.password - The password for a password login
   * @param {string} login.code - The login code for an SMS login
   * @param {boolean} persist - Request a persistent cookie instead of a session cookie
   * @returns {Promise} Promise that resolves with access token
   */
  postLogin(login, persist) {
    const persistParam = window.encodeURIComponent(persist.toString());
    return new Promise((resolve, reject) => {
      $.ajax({
        contentType: 'application/json; charset=utf-8',
        crossDomain: true,
        data: pako.gzip(JSON.stringify(login)),
        headers: {
          'Content-Encoding': 'gzip',
        },
        processData: false,
        type: 'POST',
        url: this.backendClient.createUrl(`${AuthService.CONFIG.URL_LOGIN}?persist=${persistParam}`),
        xhrFields: {
          withCredentials: true,
        },
      })
        .done(resolve)
        .fail((jqXHR, textStatus, errorThrown) => reject(jqXHR.responseJSON || errorThrown));
    });
  }

  /**
   * A login code can be used only once and times out after 10 minutes.
   *
   * @note Only one login code may be pending at a time.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//sendLoginCode
   *
   * @param {Object} requestCode - Containing the phone number in E.164 format and whether a code should be forced
   * @returns {Promise} Promise that resolves on successful login code request
   */
  postLoginSend(requestCode) {
    return this.backendClient.sendJson({
      data: requestCode,
      type: 'POST',
      url: `${AuthService.CONFIG.URL_LOGIN}/send`,
    });
  }

  /**
   * Logout on the backend side.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/auth/logout
   * @returns {jQuery.jqXHR} A superset of the XMLHTTPRequest object.
   */
  postLogout() {
    return this.backendClient.sendRequest({
      type: 'POST',
      url: `${AuthService.CONFIG.URL_ACCESS}/logout`,
      withCredentials: true,
    });
  }

  /**
   * Save the access token date in the client.
   *
   * @param {string} tokenType - Access token type
   * @param {string} token - Access token
   * @returns {undefined}
   */
  saveAccessTokenInClient(tokenType = '', token = '') {
    this.backendClient.accessTokenType = tokenType;
    this.backendClient.accessToken = token;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.AuthRepository = class AuthRepository {
  static get CONFIG() {
    return {
      REFRESH_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  static get ACCESS_TOKEN_TRIGGER() {
    return {
      IMMEDIATE: 'AuthRepository.ACCESS_TOKEN_TRIGGER.IMMEDIATE',
      SCHEDULED: 'AuthRepository.ACCESS_TOKEN_TRIGGER.SCHEDULED',
      TEAMS_REGISTRATION: 'AuthRepository.ACCESS_TOKEN_TRIGGER.TEAMS_REGISTRATION',
      UNAUTHORIZED_REQUEST: 'AuthRepository.ACCESS_TOKEN_TRIGGER.UNAUTHORIZED_REQUEST',
      WEB_SOCKET: 'AuthRepository.ACCESS_TOKEN_TRIGGER.WEB_SOCKET',
    };
  }

  /**
   * Construct a new AuthService
   * @param {z.auth.AuthService} authService - Service for authentication interactions with the backend
   */
  constructor(authService) {
    this.accessTokenRefresh = undefined;
    this.authService = authService;
    this.logger = new z.util.Logger('z.auth.AuthRepository', z.config.LOGGER.OPTIONS);

    this.queueState = this.authService.backendClient.queueState;

    amplify.subscribe(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW, this.renewAccessToken.bind(this));
  }

  /**
   * Print all cookies for a user in the console.
   * @returns {undefined} No return value
   */
  listCookies() {
    this.authService
      .getCookies()
      .then(({cookies}) => {
        this.logger.force_log('Backend cookies:');
        cookies.forEach((cookie, index) => {
          const expirationDate = z.util.TimeUtil.formatTimestamp(cookie.time, false);
          const log = `Label: ${cookie.label} | Type: ${cookie.type} |  Expiration: ${expirationDate}`;
          this.logger.force_log(`Cookie No. ${index + 1} | ${log}`);
        });
      })
      .catch(error => this.logger.force_log('Could not list user cookies', error));
  }

  /**
   * Login (with email or phone) in order to obtain an access-token and cookie.
   *
   * @param {Object} login - Containing sign in information
   * @param {string} login.email - Email address for a password login
   * @param {string} login.phone - Phone number for a password or SMS login
   * @param {string} login.password - Password for a password login
   * @param {string} login.code - Login code for an SMS login
   * @param {boolean} persist - Request a persistent cookie instead of a session cookie
   * @returns {Promise} Promise that resolves with the received access token
   */
  login(login, persist) {
    return this.authService.postLogin(login, persist).then(accessTokenResponse => {
      this.saveAccessToken(accessTokenResponse);
      z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.PERSIST, persist);
      z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.SHOW_LOGIN, true);
      return accessTokenResponse;
    });
  }

  /**
   * Logout the user on the backend.
   * @returns {Promise} Will always resolve
   */
  logout() {
    return this.authService
      .postLogout()
      .then(() => this.logger.info('Log out on backend successful'))
      .catch(error => this.logger.warn(`Log out on backend failed: ${error.message}`, error));
  }

  /**
   * Request SMS validation code.
   * @param {Object} requestCode - Containing the phone number in E.164 format and whether a code should be forced
   * @returns {Promise} Resolves on success
   */
  requestLoginCode(requestCode) {
    return this.authService.postLoginSend(requestCode);
  }

  /**
   * Renew access-token provided a valid cookie.
   * @param {AuthRepository.ACCESS_TOKEN_TRIGGER} renewalTrigger - Trigger for access token renewal
   * @returns {undefined} No return value
   */
  renewAccessToken(renewalTrigger) {
    const isRefreshingToken = this.queueState() === z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH;

    if (!isRefreshingToken) {
      this.queueState(z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH);
      this.authService.backendClient.scheduleQueueUnblock();
      this.logger.info(`Access token renewal started. Source: ${renewalTrigger}`);

      this.getAccessToken()
        .then(() => {
          this.authService.backendClient.executeRequestQueue();
          amplify.publish(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEWED);
        })
        .catch(error => {
          const {message, type} = error;
          const isRequestForbidden = type === z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN;
          if (isRequestForbidden || z.util.Environment.frontend.isLocalhost()) {
            this.logger.warn(`Session expired on access token refresh: ${message}`, error);
            Raygun.send(error);
            return amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.SESSION_EXPIRED, false);
          }

          this.queueState(z.service.QUEUE_STATE.READY);
          this.logger.error(`Refreshing access token failed: '${type}'`, error);
          amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        });
    }
  }

  /**
   * Deletes all access token data stored on the client.
   * @returns {undefined} No return value
   */
  deleteAccessToken() {
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE);
  }

  /**
   * Get the cached access token from the Amplify store.
   * @returns {Promise} Resolves when the access token was retrieved
   */
  getCachedAccessToken() {
    return new Promise((resolve, reject) => {
      const accessToken = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE);
      const accessTokenType = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE);

      if (accessToken) {
        this.logger.info('Cached access token found in Local Storage', {accessToken});
        this.authService.saveAccessTokenInClient(accessTokenType, accessToken);
        this._scheduleTokenRefresh(z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION));
        return resolve();
      }

      return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE));
    });
  }

  /**
   * Initially get access-token provided a valid cookie.
   * @returns {Promise} Resolves with the access token data
   */
  getAccessToken() {
    return this.authService.postAccess().then(accessToken => this.saveAccessToken(accessToken));
  }

  /**
   * Store the access token using Amplify.
   *
   * @param {Object} accessTokenResponse - Access token data structure
   * @param {string} accessTokenResponse.access_token - Access token
   * @param {string} accessTokenResponse.expires_in - Expiration of access token in seconds
   * @param {string} accessTokenResponse.token_type - Type of access token
   * @returns {Object} Access token data
   */
  saveAccessToken(accessTokenResponse) {
    const {access_token: accessToken, expires_in: expiresIn, token_type: accessTokenType} = accessTokenResponse;
    const expiresInMillis = expiresIn * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    const expirationTimestamp = Date.now() + expiresInMillis;

    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE, accessToken, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION, expirationTimestamp, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL, expiresInMillis, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE, accessTokenType, expiresIn);

    this.authService.saveAccessTokenInClient(accessTokenType, accessToken);

    this._logAccessTokenUpdate(accessTokenResponse, expirationTimestamp);
    this._scheduleTokenRefresh(expirationTimestamp);
    return accessTokenResponse;
  }

  /**
   * Logs the update of the access token.
   *
   * @private
   * @param {Object} accessTokenResponse - Access token data structure
   * @param {number} expirationTimestamp - Timestamp when access token expires
   * @returns {undefined}
   */
  _logAccessTokenUpdate(accessTokenResponse, expirationTimestamp) {
    const expirationDate = z.util.TimeUtil.formatTimestamp(expirationTimestamp, false);
    this.logger.info(`Saved updated access token. It will expire on: ${expirationDate}`, accessTokenResponse);
  }

  /**
   * Refreshes the access token in time before it expires.
   *
   * @private
   * @note Access token will be refreshed 1 minute (60000ms) before it expires
   * @param {number} expirationTimestamp - The expiration date (and time) as timestamp
   * @returns {undefined} No undefined value
   */
  _scheduleTokenRefresh(expirationTimestamp) {
    if (this.accessTokenRefresh) {
      window.clearTimeout(this.accessTokenRefresh);
    }
    const callbackTimestamp = expirationTimestamp - AuthRepository.CONFIG.REFRESH_THRESHOLD;

    if (callbackTimestamp < Date.now()) {
      return this.renewAccessToken(AuthRepository.ACCESS_TOKEN_TRIGGER.IMMEDIATE);
    }
    const refreshDate = z.util.TimeUtil.formatTimestamp(callbackTimestamp, false);
    this.logger.info(`Scheduling next access token refresh for '${refreshDate}'`);

    this.accessTokenRefresh = window.setTimeout(() => {
      if (callbackTimestamp > Date.now() + 15000) {
        this.logger.info(`Access token refresh scheduled for '${refreshDate}' skipped because it was executed late`);
      }

      if (navigator.onLine) {
        return this.renewAccessToken(`Schedule for '${refreshDate}'`);
      }

      this.logger.info(`Access token refresh scheduled for '${refreshDate}' skipped because we are offline`);
    }, callbackTimestamp - Date.now());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.SIGN_OUT_REASON = {
  ACCOUNT_DELETED: 'deleted',
  APP_INIT: 'app_init',
  CLIENT_REMOVED: 'client_removed',
  INDEXED_DB: 'indexedDb',
  MULTIPLE_TABS: 'multiple_tabs',
  NOT_SIGNED_IN: 'not_signed_in',
  SESSION_EXPIRED: 'expired',
  USER_REQUESTED: 'user_requested',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.URLParameter = {
  ENVIRONMENT: 'env',
  LOCALE: 'hl',
  MODE: 'mode',
  REASON: 'reason',
  TRACKING: 'tracking',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.BackendClient = class BackendClient {
  static get CONFIG() {
    return {
      CONNECTIVITY_CHECK: {
        INITIAL_TIMEOUT: 0,
        RECHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
        REQUEST_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.5,
      },
      QUEUE_CHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  static get CONNECTIVITY_CHECK_TRIGGER() {
    return {
      ACCESS_TOKEN_REFRESH: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_REFRESH',
      ACCESS_TOKEN_RETRIEVAL: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_RETRIEVAL',
      APP_INIT_RELOAD: '.BackendClient.CONNECTIVITY_CHECK_TRIGGER.APP_INIT_RELOAD',
      CONNECTION_REGAINED: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.CONNECTION_REGAINED',
      LOGIN_REDIRECT: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.LOGIN_REDIRECT',
      REQUEST_FAILURE: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.REQUEST_FAILURE',
      UNKNOWN: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN',
    };
  }

  static get IGNORED_BACKEND_ERRORS() {
    return [
      z.error.BackendClientError.STATUS_CODE.BAD_GATEWAY,
      z.error.BackendClientError.STATUS_CODE.CONFLICT,
      z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM,
      z.error.BackendClientError.STATUS_CODE.INTERNAL_SERVER_ERROR,
      z.error.BackendClientError.STATUS_CODE.NOT_FOUND,
      z.error.BackendClientError.STATUS_CODE.PRECONDITION_FAILED,
      z.error.BackendClientError.STATUS_CODE.REQUEST_TIMEOUT,
      z.error.BackendClientError.STATUS_CODE.REQUEST_TOO_LARGE,
      z.error.BackendClientError.STATUS_CODE.TOO_MANY_REQUESTS,
    ];
  }

  static get IGNORED_BACKEND_LABELS() {
    return [
      z.error.BackendClientError.LABEL.INVALID_CREDENTIALS,
      z.error.BackendClientError.LABEL.PASSWORD_EXISTS,
      z.error.BackendClientError.LABEL.TOO_MANY_CLIENTS,
      z.error.BackendClientError.LABEL.TOO_MANY_MEMBERS,
      z.error.BackendClientError.LABEL.UNKNOWN_CLIENT,
    ];
  }

  /**
   * Construct a new client.
   *
   * @param {Object} settings - Settings for different backend environments
   * @param {string} settings.environment - Backend environment used
   * @param {string} settings.restUrl - Backend REST URL
   * @param {string} settings.webSocketUrl - Backend WebSocket URL
   */
  constructor(settings) {
    this.logger = new z.util.Logger('z.service.BackendClient', z.config.LOGGER.OPTIONS);

    z.util.Environment.backend.current = settings.environment;
    this.restUrl = settings.restUrl;
    this.webSocketUrl = settings.webSocketUrl;

    this.connectivityTimeout = undefined;
    this.connectivityQueue = new z.util.PromiseQueue({name: 'BackendClient.Connectivity'});

    this.requestQueue = new z.util.PromiseQueue({concurrent: 4, name: 'BackendClient.Request'});
    this.queueState = ko.observable(z.service.QUEUE_STATE.READY);
    this.queueTimeout = undefined;

    this.accessToken = '';
    this.accessTokenType = '';

    this.numberOfRequests = ko.observable(0);
    this.numberOfRequests.subscribe(newValue => amplify.publish(z.event.WebApp.TELEMETRY.BACKEND_REQUESTS, newValue));

    // Only allow JSON response by default
    $.ajaxSetup({
      contents: {javascript: false},
      dataType: 'json',
    });

    // http://stackoverflow.com/a/18996758/451634
    $.ajaxPrefilter((options, originalOptions, jqXHR) => {
      jqXHR.wireRequest = {
        originalRequestOptions: originalOptions,
        requestDate: new Date(),
        requestId: this.numberOfRequests(),
      };
    });
  }

  /**
   * Create a request URL.
   * @param {string} path - API endpoint path to be suffixed to REST API environment
   * @returns {string} REST API endpoint URL
   */
  createUrl(path) {
    z.util.ValidationUtil.isValidApiPath(path);
    return `${this.restUrl}${path}`;
  }

  /**
   * Request backend status.
   * @returns {$.Promise} jQuery AJAX promise
   */
  status() {
    return $.ajax({
      timeout: BackendClient.CONFIG.CONNECTIVITY_CHECK.REQUEST_TIMEOUT,
      type: 'HEAD',
      url: this.createUrl('/self'),
    });
  }

  /**
   * Delay a function call until backend connectivity is guaranteed.
   * @param {BackendClient.CONNECTIVITY_CHECK_TRIGGER} [source=BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN] - Trigger that requested connectivity check
   * @returns {Promise} Resolves once the connectivity is verified
   */
  executeOnConnectivity(source = BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN) {
    this.logger.info(`Connectivity check requested by '${source}'`);
    const {INITIAL_TIMEOUT, RECHECK_TIMEOUT} = BackendClient.CONFIG.CONNECTIVITY_CHECK;

    const _resetQueue = () => {
      if (this.connectivityTimeout) {
        window.clearTimeout(this.connectivityTimeout);
        this.connectivityQueue.pause(false);
      }
      this.connectivityTimeout = undefined;
    };

    const _checkStatus = () => {
      return this.status()
        .done(jqXHR => {
          this.logger.info('Connectivity verified', jqXHR);
          _resetQueue();
        })
        .fail(jqXHR => {
          if (jqXHR.readyState === 4) {
            this.logger.info(`Connectivity verified by server error '${jqXHR.status}'`, jqXHR);
            _resetQueue();
          } else {
            this.logger.warn('Connectivity could not be verified... retrying');
            this.connectivityQueue.pause();
            this.connectivityTimeout = window.setTimeout(_checkStatus, RECHECK_TIMEOUT);
          }
        });
    };

    this.connectivityQueue.pause();
    const queuedPromise = this.connectivityQueue.push(() => Promise.resolve());
    if (!this.connectivityTimeout) {
      this.connectivityTimeout = window.setTimeout(_checkStatus, INITIAL_TIMEOUT);
    }

    return queuedPromise;
  }

  /**
   * Execute queued requests.
   * @returns {undefined} No return value
   */
  executeRequestQueue() {
    this.queueState(z.service.QUEUE_STATE.READY);
    if (this.accessToken && this.requestQueue.getLength()) {
      this.logger.info(`Executing '${this.requestQueue.getLength()}' queued requests`);
      this.requestQueue.resume();
    }
  }

  clearQueueUnblockTimeout() {
    if (this.queueTimeout) {
      window.clearTimeout(this.queueTimeout);
      this.queueTimeout = undefined;
    }
  }

  scheduleQueueUnblock() {
    this.clearQueueUnblockTimeout();
    this.queueTimeout = window.setTimeout(() => {
      const isRefreshingToken = this.queueState() === z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH;
      if (isRefreshingToken) {
        this.logger.log(`Unblocked queue on timeout during '${this.queueState()}'`);
        this.queueState(z.service.QUEUE_STATE.READY);
      }
    }, BackendClient.CONFIG.QUEUE_CHECK_TIMEOUT);
  }

  /**
   * Send jQuery AJAX request with compressed JSON body.
   *
   * @note ContentType will be overwritten with 'application/json; charset=utf-8'
   * @see sendRequest for valid parameters
   *
   * @param {Object} config - AJAX request configuration
   * @returns {Promise} Resolves when the request has been executed
   */
  sendJson(config) {
    const jsonConfig = {
      contentType: 'application/json; charset=utf-8',
      data: config.data ? pako.gzip(JSON.stringify(config.data)) : undefined,
      headers: {'Content-Encoding': 'gzip'},
      processData: false,
    };

    return this.sendRequest($.extend(config, jsonConfig, true));
  }

  /**
   * Queue jQuery AJAX request.
   * @param {Object} config - AJAX request configuration
   * @returns {Promise} Resolves when the request has been executed
   */
  sendRequest(config) {
    if (this.queueState() !== z.service.QUEUE_STATE.READY) {
      const logMessage = `Adding '${config.type}' request to '${config.url}' to queue due to '${this.queueState()}'`;
      this.logger.info(logMessage, config);
    }

    return this.requestQueue.push(() => this._sendRequest(config));
  }

  _prependRequestQueue(config, resolveFn, rejectFn) {
    this.requestQueue.pause().unshift(() => {
      return this._sendRequest(config)
        .then(resolveFn)
        .catch(rejectFn);
    });
  }

  /**
   * Send jQuery AJAX request.
   *
   * @see http://api.jquery.com/jquery.ajax/#jQuery-ajax-settings
   *
   * @private
   * @param {Object} config - Request configuration
   * @param {string} config.contentType - Request content type
   * @param {boolean} config.crossDomain - Cross domain request
   * @param {Object} config.data - Request data payload
   * @param {Object} config.headers - Request headers
   * @param {boolean} config.processData - Process data before sending
   * @param {number} config.timeout - Request timeout
   * @param {string} config.type - Request type
   * @param {string} config.url - Request URL
   * @param {boolean} config.withCredentials - Request send with credentials
   * @returns {Promise} Resolves when the request has been executed
   */
  _sendRequest(config) {
    const {cache, contentType, crossDomain, data, headers, processData, timeout, type, url, withCredentials} = config;
    const ajaxConfig = {cache, contentType, crossDomain, data, headers, processData, timeout, type};

    if (this.accessToken) {
      const authorizationHeader = `${this.accessTokenType} ${window.decodeURIComponent(this.accessToken)}`;
      ajaxConfig.headers = Object.assign({}, headers, {Authorization: authorizationHeader});
    }

    if (url) {
      ajaxConfig.url = this.createUrl(url);
    }

    if (withCredentials) {
      ajaxConfig.xhrFields = {withCredentials: true};
    }

    this.numberOfRequests(this.numberOfRequests() + 1);

    return new Promise((resolve, reject) => {
      $.ajax(ajaxConfig)
        .done((responseData, textStatus, {wireRequest}) => {
          const requestId = wireRequest ? wireRequest.requestId : 'ID not set';
          const logMessage = `Server response to '${config.type}' request '${config.url}' - '${requestId}':`;
          this.logger.debug(this.logger.levels.OFF, logMessage, responseData);

          resolve(responseData);
        })
        .fail(({responseJSON: response, status: statusCode, wireRequest}) => {
          switch (statusCode) {
            case z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM: {
              this.queueState(z.service.QUEUE_STATE.CONNECTIVITY_PROBLEM);
              this._prependRequestQueue(config, resolve, reject);

              return this.executeOnConnectivity().then(() => this.executeRequestQueue());
            }

            case z.error.BackendClientError.STATUS_CODE.FORBIDDEN: {
              if (response) {
                const errorLabel = response.label;
                const errorMessage = `Server request forbidden: ${errorLabel}`;

                if (BackendClient.IGNORED_BACKEND_LABELS.includes(errorLabel)) {
                  this.logger.warn(errorMessage);
                } else {
                  const requestId = wireRequest ? wireRequest.requestId : undefined;
                  const customData = {
                    endpoint: config.url,
                    method: config.type,
                    requestId,
                  };

                  Raygun.send(new Error(errorMessage), customData);
                }
              }
              break;
            }

            case z.error.BackendClientError.STATUS_CODE.ACCEPTED:
            case z.error.BackendClientError.STATUS_CODE.CREATED:
            case z.error.BackendClientError.STATUS_CODE.NO_CONTENT:
            case z.error.BackendClientError.STATUS_CODE.OK: {
              // Prevent empty valid response from being rejected
              if (!response) {
                return resolve({});
              }
              break;
            }

            case z.error.BackendClientError.STATUS_CODE.UNAUTHORIZED: {
              if (!config.skipRetry) {
                this._prependRequestQueue(config, resolve, reject);

                const trigger = z.auth.AuthRepository.ACCESS_TOKEN_TRIGGER.UNAUTHORIZED_REQUEST;
                return amplify.publish(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW, trigger);
              }
            }

            default: {
              if (!BackendClient.IGNORED_BACKEND_ERRORS.includes(statusCode)) {
                const requestId = wireRequest ? wireRequest.requestId : undefined;
                const customData = {
                  endpoint: config.url,
                  method: config.type,
                  requestId,
                };

                Raygun.send(new Error(`Server request failed: ${statusCode}`), customData);
              }
            }
          }

          reject(response || new z.error.BackendClientError(statusCode));
        });
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.BackendEnvironment = {
  DEVELOPMENT: 'development',
  PRODUCTION: 'production',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.QUEUE_STATE = {
  ACCESS_TOKEN_REFRESH: 'z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH',
  CONNECTIVITY_PROBLEM: 'z.service.QUEUE_STATE.CONNECTIVITY_PROBLEM',
  READY: 'z.service.QUEUE_STATE.READY',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.Auth = class Auth {
  /**
   * Constructs objects needed for app authentication.
   *
   * @param {Object} settings - Collection of URL settings
   * @param {string} settings.environment - Handle of the backend environment (staging, etc.)
   * @param {string} settings.webSocketUrl - URL to the backend's WebSocket
   * @param {string} settings.restUrl - URL to the backend's REST service
   * @param {string} settings.parameter - Additional parameters for the webapp's login URL
   * @returns {Auth} New authentication object
   */
  constructor(settings) {
    this.settings = settings;
    this.audio = new z.audio.AudioRepository();
    this.backendClient = new z.service.BackendClient(this.settings);
    this.service = new z.auth.AuthService(this.backendClient);
    this.repository = new z.auth.AuthRepository(this.service);
    return this;
  }
};

//##############################################################################
// Setting up the Environment (DIST)
//##############################################################################
$(() => {
  const defaultEnvironment = z.util.Environment.frontend.isProduction()
    ? z.service.BackendEnvironment.PRODUCTION
    : z.service.BackendEnvironment.DEVELOPMENT;
  const env = z.util.URLUtil.getParameter(z.auth.URLParameter.ENVIRONMENT) || defaultEnvironment;

  const isStaging = env === z.service.BackendEnvironment.DEVELOPMENT;
  const settings = isStaging
    ? {
        environment: z.service.BackendEnvironment.DEVELOPMENT,
        restUrl: 'https://staging-nginz-https.zinfra.io',
        webSocketUrl: 'wss://staging-nginz-ssl.zinfra.io',
      }
    : {
        environment: z.service.BackendEnvironment.PRODUCTION,
        restUrl: window.wire.env.BACKEND_REST || 'https://prod-nginz-https.wire.com',
        webSocketUrl: window.wire.env.BACKEND_WS || 'wss://prod-nginz-ssl.wire.com',
      };

  window.wire = Object.assign(window.wire || {}, {
    auth: new z.main.Auth(settings),
  });
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageKey = {
  AUTH: {
    ACCESS_TOKEN: {
      EXPIRATION: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION',
      TTL: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL',
      TYPE: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE',
      VALUE: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE',
    },
    COOKIE_LABEL: 'z.storage.StorageKey.AUTH.COOKIE_LABEL',
    PERSIST: 'z.storage.StorageKey.AUTH.PERSIST',
    SHOW_LOGIN: 'z.storage.StorageKey.AUTH.SHOW_LOGIN',
  },
  CONVERSATION: {
    EMOJI_USAGE_COUNT: 'z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT',
    INPUT: 'z.storage.StorageKey.CONVERSATION.INPUT',
  },
  LOCALIZATION: {
    LOCALE: 'z.storage.StorageKey.LOCALIZATION.LOCALE',
  },
  SEARCH: {
    SUGGESTED_SEARCH_ETS: 'z.storage.StorageKey.SEARCH.SUGGESTED_SEARCH_ETS',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageRepository = class StorageRepository {
  static get CONFIG() {
    return {
      CRYPTOGRAPHY_TABLES: [
        z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY,
        z.storage.StorageSchemata.OBJECT_STORE.CLIENTS,
        z.storage.StorageSchemata.OBJECT_STORE.KEYS,
        z.storage.StorageSchemata.OBJECT_STORE.SESSIONS,
        z.storage.StorageSchemata.OBJECT_STORE.PRE_KEYS,
      ],
    };
  }

  /**
   * Construct an new Storage Repository.
   * @param {z.storage.StorageService} storageService - Service for all storage related interactions
   */
  constructor(storageService) {
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.storage.StorageRepository', z.config.LOGGER.OPTIONS);

    this.AMPLIFY_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY;
  }

  /**
   * Clear all database stores.
   * @returns {Promise} Resolves when stores have been deleted
   */
  clearStores() {
    return this.storageService
      .clearStores()
      .then(() => this.logger.info(`Cleared database '${this.storageService.dbName}'`));
  }

  /**
   * Delete cryptography related information.
   * @note Retain history but clean other information.
   * @returns {Promise} Resolves when stores have been deleted
   */
  deleteCryptographyStores() {
    return this.storageService.deleteStores(StorageRepository.CONFIG.CRYPTOGRAPHY_TABLES);
  }

  /**
   * Delete everything from the database
   * @note Nukes it - no way to recover data
   * @returns {Promise} Resolves when database has been deleted
   */
  deleteDatabase() {
    this.logger.warn(`Deleting database '${this.storageService.dbName}'`);
    return this.storageService.deleteDatabase();
  }

  /**
   * Get a value for a given primary key from the amplify value store.
   *
   * @param {string} primaryKey - Primary key to retrieve the object for
   * @returns {Promise} Resolves with the retrieved value
   */
  getValue(primaryKey) {
    return this.storageService.load(this.AMPLIFY_STORE_NAME, primaryKey).then(record => {
      if (record && record.value) {
        return record.value;
      }
      throw new z.error.StorageError(z.error.StorageError.TYPE.NOT_FOUND);
    });
  }

  /**
   * Save a value in the amplify value store.
   *
   * @param {string} primaryKey - Primary key to save the object with
   * @param {value} value - Object to be stored
   * @returns {Promise} Resolves with the primary key
   */
  saveValue(primaryKey, value) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, primaryKey, {value: value});
  }

  /**
   * Closes the database connection.
   * @param {string} reason - Cause for the termination
   * @returns {undefined} No return value
   */
  terminate(reason) {
    this.storageService.terminate(reason);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageSchemata = class StorageSchemata {
  static get OBJECT_STORE() {
    return {
      AMPLIFY: 'amplify',
      CLIENTS: 'clients',
      CONVERSATION_EVENTS: 'conversation_events',
      CONVERSATIONS: 'conversations',
      EVENTS: 'events',
      KEYS: 'keys',
      PRE_KEYS: 'prekeys',
      SESSIONS: 'sessions',
      USERS: 'users',
    };
  }

  // @see https://github.com/dfahlander/Dexie.js/wiki/Version.stores()
  // @see https://github.com/dfahlander/Dexie.js/wiki/Version.upgrade()
  // @see https://github.com/dfahlander/Dexie.js/wiki/WriteableCollection.modify()
  static get SCHEMATA() {
    return [
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 1,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 2,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 3,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CLIENTS].toCollection().modify(client => {
            client.meta = {is_verified: true, primary_key: 'local_identity'};
          });
        },
        version: 4,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 5,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: (transaction, database) => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATIONS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.CONVERSATIONS].update(key, {id: key});
          });
          transaction[StorageSchemata.OBJECT_STORE.SESSIONS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.SESSIONS].update(key, {id: key});
          });
          transaction[StorageSchemata.OBJECT_STORE.PRE_KEYS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.PRE_KEYS].update(key, {id: key});
          });
        },
        version: 6,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            const mappedEvent = event.mapped || event.raw;
            delete event.mapped;
            delete event.raw;
            delete event.meta;
            Object.assign(event, mappedEvent);
          });
        },
        version: 7,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            const isTypeDeleteEveryWhere = event.type === 'conversation.delete-everywhere';
            if (isTypeDeleteEveryWhere) {
              event.time = new Date(event.time).toISOString();
            }
          });
        },
        version: 8,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type, [conversation+time]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 9,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            event.category = z.message.MessageCategorization.categoryFromEvent(event);
          });
        },
        version: 10,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          const localClientPrimaryKey = 'local_identity';

          transaction[StorageSchemata.OBJECT_STORE.CLIENTS].toCollection().each((client, cursor) => {
            const isExpectedMetaPrimaryKey = client.meta.primary_key === localClientPrimaryKey;
            const isExpectedPrimaryKey = client.primary_key === localClientPrimaryKey;

            const isExpectedClient = isExpectedMetaPrimaryKey && isExpectedPrimaryKey;
            if (isExpectedClient) {
              transaction[StorageSchemata.OBJECT_STORE.CLIENTS].delete(cursor.primaryKey);
              transaction[StorageSchemata.OBJECT_STORE.CLIENTS].put(client, localClientPrimaryKey);
            }
          });
        },
        version: 11,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.KEYS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
          transaction[StorageSchemata.OBJECT_STORE.PRE_KEYS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
          transaction[StorageSchemata.OBJECT_STORE.SESSIONS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
        },
        version: 12,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: (transaction, database) => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]
            .toCollection()
            .toArray()
            .then(items => database[StorageSchemata.OBJECT_STORE.EVENTS].bulkPut(items));
        },
        version: 13,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.EVENTS].toCollection().modify(event => {
            const isTypeAssetMeta = event.type === 'conversation.asset-meta';
            if (isTypeAssetMeta) {
              event.type = 'conversation.asset-add';
            }
          });
        },
        version: 14,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
          [StorageSchemata.OBJECT_STORE.USERS]: ', id',
        },
        version: 15,
      },
    ];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageService = class StorageService {
  // Construct an new StorageService.
  constructor() {
    this.logger = new z.util.Logger('z.storage.StorageService', z.config.LOGGER.OPTIONS);

    this.db = undefined;
    this.dbName = undefined;
    this.userId = undefined;
  }

  //##############################################################################
  // Initialization
  //##############################################################################

  /**
   * Initialize the IndexedDB for a user.
   *
   * @param {string} userId - User ID
   * @returns {Promise} Resolves with the database name
   */
  init(userId = this.userId) {
    return Promise.resolve().then(() => {
      const isPermanent = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.PERSIST);
      const clientType = isPermanent ? z.client.ClientType.PERMANENT : z.client.ClientType.TEMPORARY;

      this.userId = userId;
      this.dbName = `wire@${z.util.Environment.backend.current}@${userId}@${clientType}`;

      this.db = new Dexie(this.dbName);

      this.db.on('blocked', () => this.logger.error('Database is blocked'));

      this._upgradeStores();

      return this.db
        .open()
        .then(() => {
          this.logger.info(`Storage Service initialized with database '${this.dbName}' version '${this.db.verno}'`);
          return this.dbName;
        })
        .catch(error => {
          const logMessage = `Failed to initialize database '${this.dbName}': ${error.message || error}`;
          this.logger.error(logMessage, {error: error});
          throw new z.error.StorageError(z.error.StorageError.TYPE.FAILED_TO_OPEN);
        });
    });
  }

  _upgradeStores() {
    z.storage.StorageSchemata.SCHEMATA.forEach(({schema, upgrade, version}) => {
      if (upgrade) {
        return this.db
          .version(version)
          .stores(schema)
          .upgrade(transaction => {
            this.logger.warn(`Database upgrade to version '${version}'`);
            upgrade(transaction, this.db);
          });
      }

      this.db.version(version).stores(schema);
    });
  }

  //##############################################################################
  // Interactions
  //##############################################################################

  /**
   * Clear all stores.
   * @returns {Promise} Resolves when all stores have been cleared
   */
  clearStores() {
    const deleteStorePromises = Object.keys(this.db._dbSchema).map(storeName => this.deleteStore(storeName));
    return Promise.all(deleteStorePromises);
  }

  /**
   * Removes persisted data.
   *
   * @param {string} storeName - Name of the object store
   * @param {string} primaryKey - Primary key
   * @returns {Promise} Resolves when the object is deleted
   */
  delete(storeName, primaryKey) {
    if (this.db[storeName]) {
      return this.db[storeName]
        .delete(primaryKey)
        .then(() => {
          this.logger.info(`Deleted '${primaryKey}' from object store '${storeName}'`);
          return primaryKey;
        })
        .catch(error => {
          this.logger.error(`Failed to delete '${primaryKey}' from store '${storeName}'`, error);
          throw error;
        });
    }

    return Promise.reject(new z.error.StorageError(z.error.StorageError.TYPE.DATA_STORE_NOT_FOUND));
  }

  /**
   * Delete the IndexedDB with all its stores.
   * @returns {Promise} Resolves if a database is found and cleared
   */
  deleteDatabase() {
    if (this.db) {
      return this.db
        .delete()
        .then(() => {
          this.logger.info(`Clearing IndexedDB '${this.dbName}' successful`);
          return true;
        })
        .catch(error => {
          this.logger.error(`Clearing IndexedDB '${this.dbName}' failed`);
          throw error;
        });
    }
    this.logger.error(`IndexedDB '${this.dbName}' not found`);
    return Promise.resolve(true);
  }

  /**
   * Delete a database store.
   * @param {string} storeName - Name of database store to delete
   * @returns {Promise} Resolves when the store has been deleted
   */
  deleteStore(storeName) {
    this.logger.info(`Clearing object store '${storeName}' in database '${this.dbName}'`);
    return this.db[storeName].clear();
  }

  /**
   * Delete multiple database stores.
   * @param {Array<string>} storeNames - Names of database stores to delete
   * @returns {Promise} Resolves when the stores have been deleted
   */
  deleteStores(storeNames) {
    const deleteStorePromises = storeNames.map(storeName => this.deleteStore(storeName));
    return Promise.all(deleteStorePromises);
  }

  /**
   * Returns an array of all records for a given object store.
   *
   * @param {string} storeName - Name of object store
   * @returns {Promise} Resolves with the records from the object store
   */
  getAll(storeName) {
    return this.db[storeName]
      .toArray()
      .then(resultArray => resultArray.filter(result => result))
      .catch(error => {
        this.logger.error(`Failed to load objects from store '${storeName}'`, error);
        throw error;
      });
  }

  /**
   * @param {Array<string>} tableNames - Names of tables to get
   * @returns {Array<Table>} Matching tables
   */
  getTables(tableNames) {
    return tableNames.map(tableName => this.db[tableName]);
  }

  /**
   * Loads persisted data via a promise.
   * @note If a key cannot be found, it resolves and returns "undefined".
   *
   * @param {string} storeName - Name of object store
   * @param {string} primaryKey - Primary key of object to be retrieved
   * @returns {Promise} Resolves with the record matching the primary key
   */
  load(storeName, primaryKey) {
    return this.db[storeName].get(primaryKey).catch(error => {
      this.logger.error(`Failed to load '${primaryKey}' from store '${storeName}'`, error);
      throw error;
    });
  }

  /**
   * Saves objects in the local database.
   *
   * @param {string} storeName - Name of object store where to save the object
   * @param {string} primaryKey - Primary key which should be used to store the object
   * @param {Object} entity - Data to store in object store
   * @returns {Promise} Resolves with the primary key of the persisted object
   */
  save(storeName, primaryKey, entity) {
    if (!entity) {
      return Promise.reject(new z.error.StorageError(z.error.StorageError.TYPE.NO_DATA));
    }

    return this.db[storeName].put(entity, primaryKey).catch(error => {
      this.logger.error(`Failed to put '${primaryKey}' into store '${storeName}'`, error);
      throw error;
    });
  }

  /**
   * Closes the database. This operation completes immediately and there is no returned Promise.
   * @see https://github.com/dfahlander/Dexie.js/wiki/Dexie.close()
   * @param {string} [reason='unknown reason'] - Cause for the termination
   * @returns {undefined} No return value
   */
  terminate(reason = 'unknown reason') {
    this.logger.info(`Closing database connection with '${this.db.name}' because of '${reason}'.`);
    this.db.close();
  }

  /**
   * Update previously persisted data via a promise.
   *
   * @param {string} storeName - Name of object store
   * @param {string} primaryKey - Primary key of object to be updated
   * @param {Object} changes - Object containing the key paths to each property you want to change
   * @returns {Promise} Promise with the number of updated records (0 if no records were changed).
   */
  update(storeName, primaryKey, changes) {
    return this.db[storeName]
      .update(primaryKey, changes)
      .then(numberOfUpdates => {
        const logMessage = `Updated ${numberOfUpdates} record(s) with key '${primaryKey}' in store '${storeName}'`;
        this.logger.info(logMessage, changes);
        return numberOfUpdates;
      })
      .catch(error => {
        this.logger.error(`Failed to update '${primaryKey}' in store '${storeName}'`, error);
        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
z.string = z.string || {};
z.string.da = z.string.da || {};
z.string.cs = z.string.cs || {};
z.string.de = z.string.de || {};
z.string.el = z.string.el || {};
z.string.es = z.string.es || {};
z.string.et = z.string.et || {};
z.string.fi = z.string.fi || {};
z.string.fr = z.string.fr || {};
z.string.hr = z.string.hr || {};
z.string.hu = z.string.hu || {};
z.string.it = z.string.it || {};
z.string.lt = z.string.lt || {};
z.string.nl = z.string.nl || {};
z.string.pl = z.string.pl || {};
z.string.pt = z.string.pt || {};
z.string.ro = z.string.ro || {};
z.string.ru = z.string.ru || {};
z.string.sk = z.string.sk || {};
z.string.sl = z.string.sl || {};
z.string.tr = z.string.tr || {};
z.string.uk = z.string.uk || {};

z.string.Declension = {
  ACCUSATIVE: 'accusative',
  DATIVE: 'dative',
  NOMINATIVE: 'nominative',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.cs.wireMacos = 'Wire pro macOS';
z.string.cs.wireWindows = 'Wire pro Windows';
z.string.cs.wireLinux = 'Wire pro Linux';
z.string.cs.nonexistentUser = 'Smazan uivatel';
z.string.cs.and = 'a';

z.string.cs.authAccountCountryCode = 'Kd zem';
z.string.cs.authAccountPasswordForgot = 'Zapomenut heslo';
z.string.cs.authAccountPublicComputer = 'Toto je veejn pota';
z.string.cs.authAccountSignIn = 'Pihlsit se';
z.string.cs.authAccountSignInPhone = 'Telefon';

z.string.cs.authBlockedCookies = 'Pro pihlen k Wire povolte soubory cookie.';
z.string.cs.authBlockedDatabase = 'Pro zobrazen zprv potebuje Wire potebuje pstup k loiti. loit nen k dispozici v anonymnm reimu.';
z.string.cs.authBlockedTabs = 'Wire je ji oteven na jin zloce.';

z.string.cs.authVerifyAccountAdd = 'Pidat';
z.string.cs.authVerifyAccountDetail = 'To umouje pouvat Wire na vce zazench.';
z.string.cs.authVerifyAccountHeadline = 'Pidat emailovou adresu a heslo.';
z.string.cs.authVerifyAccountLogout = 'Odhlsit se';
z.string.cs.authVerifyCodeDescription = 'Zadejte ovovac kd,\nkter byl zasln na {{number}}.';
z.string.cs.authVerifyCodeResend = 'Kd nedoel?';
z.string.cs.authVerifyCodeResendDetail = 'Odeslat znovu';
z.string.cs.authVerifyCodeResendTimer = 'Mete si vydat nov kd {{expiration}}.';
z.string.cs.authVerifyCodeChangePhone = 'Zmnit telefonn slo';
z.string.cs.authVerifyPasswordHeadline = 'Zadejte sv heslo';

z.string.cs.authLimitDevicesHeadline = 'Pstroje';
z.string.cs.authLimitDescription = 'Odeberte jeden ze svch pstroj abyste mohli zat pouvat Wire na tomto zazen.';
z.string.cs.authLimitButtonManage = 'Spravovat pstroje';
z.string.cs.authLimitButtonSignOut = 'Odhlsit se';
z.string.cs.authLimitDevicesCurrent = '(Aktuln)';

z.string.cs.authHistoryHeadline = 'Toto je poprv kdy pouvte Wire na tomto pstroji.';
z.string.cs.authHistoryDescription = 'Z dvod ochrany soukrom se zde nezobraz historie va konverzace.';
z.string.cs.authHistoryReuseHeadline = 'Ji jste dve pouili Wire na tomto zazen.';
z.string.cs.authHistoryReuseDescription = 'Zprvy odeslan v meziase se zde nezobraz.';
z.string.cs.authHistoryButton = 'OK';

z.string.cs.authPostedResend = 'Znovu odeslat na {{email}}';
z.string.cs.authPostedResendAction = 'dn email nedoel?';
z.string.cs.authPostedResendDetail = 'Zkontrolujte doruenou potu a postupujte dle instrukc.';
z.string.cs.authPostedResendHeadline = 'Piel ti email.';

z.string.cs.authPlaceholderEmail = 'Email';
z.string.cs.authPlaceholderPasswordPut = 'Heslo';
z.string.cs.authPlaceholderPasswordSet = 'Heslo (alespo 8 znak)';
z.string.cs.authPlaceholderPhone = 'Telefonn slo';

z.string.cs.authErrorCode = 'Neplatn kd';
z.string.cs.authErrorCountryCodeInvalid = 'Neplatn kd zem';
z.string.cs.authErrorEmailExists = 'Emailov adresa je ji pouvna';
z.string.cs.authErrorEmailForbidden = 'Omlouvme se. Tato emailov adresa byla zakzna.';
z.string.cs.authErrorEmailMalformed = 'Zadejte prosm platnou emailovou adresu.';
z.string.cs.authErrorEmailMissing = 'Zadejte prosm emailovou adresu.';
z.string.cs.authErrorMisc = 'Problmy s pipojenm. Prosm opakujte akci.';
z.string.cs.authErrorNameShort = 'Zadejte jmno s alespo 2 znaky';
z.string.cs.authErrorOffline = 'Nejste pipojeni k Internetu';
z.string.cs.authErrorPasswordShort = 'Zadejte heslo obsahujc alespo 8 znak.';
z.string.cs.authErrorPasswordWrong = 'Neplatn heslo. Zkuste to prosm znovu.';
z.string.cs.authErrorPhoneNumberBudget = 'Pli asto se pihlaujete. Opakujte akci pozdji.';
z.string.cs.authErrorPhoneNumberForbidden = 'Omlouvme se. Toto telefonn slo bylo zakzno.';
z.string.cs.authErrorPhoneNumberInvalid = 'Neplatn telefonn slo';
z.string.cs.authErrorPhoneNumberUnknown = 'Neznm telefonn slo';
z.string.cs.authErrorSuspended = 'Pro tento et ji nen povoleno se pihlsit.';
z.string.cs.authErrorSignIn = 'Zkontrolujte sv daje a zkuste znovu.';

z.string.cs.callStateOutgoing = 'Zvon';
z.string.cs.callStateConnecting = 'Pipojuji';
z.string.cs.callStateIncoming = 'Vol';
z.string.cs.callDecline = 'Zamtnout';
z.string.cs.callAccept = 'Pijmout';
z.string.cs.callJoin = 'Vstoupit';
z.string.cs.callChooseSharedScreen = 'Vybrat obrazovku ke sdlen';
z.string.cs.callParticipants = '{{number}} se astn hovoru';

z.string.cs.videoCallOverlayMute = 'Ztlumit';
z.string.cs.videoCallOverlayHangUp = 'Zavsit';

z.string.cs.modalAcknowledgeAction = 'Ok';
z.string.cs.modalConfirmSecondary = 'Zruit';
z.string.cs.modalOptionSecondary = 'Zruit';

z.string.cs.modalAccountCreateAction = 'OK';

z.string.cs.modalAccountDeletionAction = 'Smazat';
z.string.cs.modalAccountDeletionHeadline = 'Smazat et';
z.string.cs.modalAccountDeletionMessage = 'Obdrte od ns zprvu pes email nebo SMS. Pro trval smazn svho tu otevete zaslan odkaz.';

z.string.cs.modalAccountLeaveGuestRoomAction = 'Odejt';

z.string.cs.modalAccountLogoutAction = 'Odhlsit se';
z.string.cs.modalAccountLogoutHeadline = 'Vyistit data?';
z.string.cs.modalAccountLogoutOption = 'Smazat vechny osobn informace a konverzace z tohoto pstroje.';

z.string.cs.modalAccountNewDevicesSecondary = 'Spravovat pstroje';
z.string.cs.modalAccountNewDevicesHeadline = 'V et byl naposledy pouit:';
z.string.cs.modalAccountNewDevicesFrom = 'Od:';
z.string.cs.modalAccountNewDevicesMessage = 'Pokud jste to nebyli vy sami, odeberte pouit zazen a zmte si heslo.';

z.string.cs.modalAccountRemoveDeviceAction = 'Odstranit pstroj';
z.string.cs.modalAccountRemoveDeviceHeadline = 'Odstranit "{{device}}"';
z.string.cs.modalAccountRemoveDeviceMessage = 'Pro odstrann pstroje je vyadovno heslo.';
z.string.cs.modalAccountRemoveDevicePlaceholder = 'Heslo';

z.string.cs.modalAssetTooLargeMessage = 'Mete poslat soubory a do velikosti {{number}}';

z.string.cs.modalAssetParallelUploadsMessage = 'Najednou mete poslat a {{number}} soubor.';

z.string.cs.modalCallEmptyConversationHeadline = 'Nikdo pro voln';
z.string.cs.modalCallEmptyConversationMessage = 'Ji zde nikdo jin nen.';

z.string.cs.modalCallNoGroupVideoHeadline = 'dn videohovory ve skupinch';
z.string.cs.modalCallNoGroupVideoMessage = 'Videohovory nejsou dostupn pro skupinov konverzace.';

z.string.cs.modalCallNoMicrophoneAction = 'Jak na to';
z.string.cs.modalCallNoMicrophoneMessage = 'Pro voln potebuje prohle pstup k mikrofonu.';
z.string.cs.modalCallNoMicrophoneHeadline = 'Nelze volat bez mikrofonu';

z.string.cs.modalCallSecondIncomingAction = 'Pijmout';
z.string.cs.modalCallSecondIncomingHeadline = 'Pijmout hovor?';
z.string.cs.modalCallSecondIncomingMessage = 'Aktuln hovor bude ukonen.';

z.string.cs.modalCallSecondOngoingAction = 'Zavsit';
z.string.cs.modalCallSecondOngoingHeadline = 'Zavsit hovor na jinm zazen?';
z.string.cs.modalCallSecondOngoingMessage = 'V jednom okamiku me bt pouze v jednom hovoru.';

z.string.cs.modalCallSecondOutgoingAction = 'Zavsit';
z.string.cs.modalCallSecondOutgoingHeadline = 'Zavsit aktuln hovor?';
z.string.cs.modalCallSecondOutgoingMessage = 'V jednom okamiku me bt pouze v jednom hovoru.';

z.string.cs.modalConnectCancelAction = 'Ano';
z.string.cs.modalConnectCancelHeadline = 'Zruit poadavek?';
z.string.cs.modalConnectCancelMessage = 'Odeberte poadavek na pipojen s {{user}}.';
z.string.cs.modalConnectCancelSecondary = 'Ne';

z.string.cs.modalConnectAcceptAction = 'Pipojit';
z.string.cs.modalConnectAcceptHeadline = 'Pijmout?';
z.string.cs.modalConnectAcceptMessage = 'Toto nave spojen a oteve konverzaci s {{user}}.';
z.string.cs.modalConnectAcceptSecondary = 'Ignorovat';

z.string.cs.modalConversationClearAction = 'Smazat';
z.string.cs.modalConversationClearHeadline = 'Vymazat obsah?';
z.string.cs.modalConversationClearOption = 'Tak opustit konverzaci';

z.string.cs.modalConversationDeleteMessageAction = 'Smazat';
z.string.cs.modalConversationDeleteMessageHeadline = 'Smazat pouze u mn?';
z.string.cs.modalConversationDeleteMessageMessage = 'Tuto operaci nelze vrtit.';

z.string.cs.modalConversationDeleteMessageEveryoneAction = 'Smazat';
z.string.cs.modalConversationDeleteMessageEveryoneHeadline = 'Smazat pro vechny?';
z.string.cs.modalConversationDeleteMessageEveryoneMessage = 'Tuto operaci nelze vrtit.';

z.string.cs.modalConversationLeaveAction = 'Odejt';
z.string.cs.modalConversationLeaveMessage = 'Nebudete moct odeslat ani pijmat zprvy v tto konverzaci.';

z.string.cs.modalConversationMessageTooLongHeadline = 'Zprva je pli dlouh';
z.string.cs.modalConversationMessageTooLongMessage = 'Mete poslat zprvy dlouh a {{number}} znak.';

z.string.cs.modalConversationNewDeviceHeadlineOne = '{{user}} zaal(a) pouvat nov zazen';
z.string.cs.modalConversationNewDeviceHeadlineMany = '{{users}} zaali pouvat nov zazen';
z.string.cs.modalConversationNewDeviceHeadlineYou = '{{user}} zaal(a) pouvat nov zazen';
z.string.cs.modalConversationNewDeviceIncomingCallAction = 'Pijmout voln';
z.string.cs.modalConversationNewDeviceIncomingCallMessage = 'Chcete pesto pijmout hovor?';
z.string.cs.modalConversationNewDeviceMessage = 'Chcete pesto odeslat sv zprvy?';
z.string.cs.modalConversationNewDeviceOutgoingCallAction = 'Pesto zavolat';
z.string.cs.modalConversationNewDeviceOutgoingCallMessage = 'Chcete pesto volat?';

z.string.cs.modalConversationNotConnectedHeadline = 'Do konverzace nebyl nikdo pidn';
z.string.cs.modalConversationNotConnectedMessageOne = '{{name}} nem zjem bt pidn(a) do konverzace.';
z.string.cs.modalConversationNotConnectedMessageMany = 'Jeden z lid kter jste vybrali nechce bt pidn do konverzace.';

z.string.cs.modalConversationRemoveAction = 'Odstranit';
z.string.cs.modalConversationRemoveHeadline = 'Odstranit?';
z.string.cs.modalConversationRemoveMessage = '{{user}} nebude moci odeslat nebo pijmat zprvy v tto konverzaci.';

z.string.cs.modalConversationRemoveGuestsAction = 'Odstranit';

z.string.cs.modalConversationTooManyMembersHeadline = 'Peplnn kup';

z.string.cs.modalIntegrationUnavailableHeadline = 'Roboti jsou momentln nedostupn';
z.string.cs.modalIntegrationUnavailableMessage = 'Dkujeme vm za v zjem o roboty. Sluba je pozastavena, zatmco pracujeme na dal verzi.';


z.string.cs.modalImproveWireAction = 'Pijmout';
z.string.cs.modalImproveWireSecondary = 'Ne';

z.string.cs.modalSessionResetHeadline = 'Sezen bylo zresetovno';
z.string.cs.modalSessionResetMessage1 = 'Pokud problm nen vyeen,';
z.string.cs.modalSessionResetMessageLink = 'kontaktujte';
z.string.cs.modalSessionResetMessage2 = 'ns.';

z.string.cs.modalUploadContactsAction = 'Zkusit znovu';
z.string.cs.modalUploadContactsMessage = 'Neobdreli jsme vae data. Zkuste prosm kontakty importovat znovu.';

z.string.cs.modalUserBlockAction = 'Blokovat';
z.string.cs.modalUserBlockHeadline = 'Blokovat {{user}}?';
z.string.cs.modalUserBlockMessage = '{{user}} vs nebude moci kontaktovat nebo pizvat ke skupinov konverzaci.';

z.string.cs.modalUserUnblockAction = 'Odblokovat';
z.string.cs.modalUserUnblockHeadline = 'Odblokovat?';
z.string.cs.modalUserUnblockMessage = '{{user}} vs nebude moci kontaktovat nebo pizvat ke skupinov konverzaci.';

z.string.cs.connectionRequestConnect = 'Pipojit';
z.string.cs.connectionRequestIgnore = 'Ignorovat';

z.string.cs.conversationGuestIndicator = 'Host';

z.string.cs.conversationYouNominative = 'jste';
z.string.cs.conversationYouDative = 'jste';
z.string.cs.conversationYouAccusative = 'jste';

z.string.cs.conversationConnectionAccepted = 'Pipojeno';
z.string.cs.conversationConnectionBlocked = 'Blokovno';
z.string.cs.conversationConnectionCancelRequest = 'Zruit dost o pipojen';
z.string.cs.conversationDeviceStartedUsingOne = ' zaal(a) pouvat';
z.string.cs.conversationDeviceStartedUsingMany = ' zaal(a) pouvat';
z.string.cs.conversationDeviceUnverified = ' neoven jeden ze';
z.string.cs.conversationDeviceYourDevices = ' vae pstroje';
z.string.cs.conversationDeviceUserDevices = ' pstroje uivatele {{user}}';
z.string.cs.conversationDeviceNewDeviceOne = ' nov zazen';
z.string.cs.conversationDeviceNewDeviceMany = ' nov zazen';
z.string.cs.conversationDeviceNewPeopleJoinedVerify = ' ovit zazen';
z.string.cs.conversationJustNow = 'Prv te';
z.string.cs.conversationLocationLink = 'Otevt mapu';
z.string.cs.conversationMessageDelivered = 'Dorueno';
z.string.cs.conversationRename = ' pejmenoval(a) konverzaci';
z.string.cs.conversationRenameYou = ' pejmenoval(a) konverzaci';
z.string.cs.conversationResume = 'Zat konverzovat s {{users}}';
z.string.cs.conversationPing = ' pingl(a)';
z.string.cs.conversationPingYou = ' pingl(a)';
z.string.cs.conversationToday = 'dnes';
z.string.cs.conversationVoiceChannelDeactivate = ' volal(a)';
z.string.cs.conversationVoiceChannelDeactivateYou = ' volal(a)';
z.string.cs.conversationYesterday = 'Vera';
z.string.cs.conversationUnableToDecrypt1 = 'zprva od uivatele {{user}} nebyla pijata.';
z.string.cs.conversationUnableToDecrypt2 = 'Identita uivatele {{user}} se zmnila. Zprva nedoruena.';
z.string.cs.conversationUnableToDecryptLink = 'Pro?';
z.string.cs.conversationUnableToDecryptErrorMessage = 'Chyba';
z.string.cs.conversationUnableToDecryptResetSession = 'Resetovat sezen';
z.string.cs.conversationMissedMessages = 'Toto zazen jste njakou dobu nepouval(a). Nkter zprvy se nemus zobrazit.';
z.string.cs.conversationAssetDownloading = 'Stahovn';
z.string.cs.conversationAssetUploadFailed = 'Nahrn selhalo';
z.string.cs.conversationPlaybackError = 'Nelze pehrt';
z.string.cs.conversationContextMenuCopy = 'Vloit';
z.string.cs.conversationContextMenuEdit = 'Upravit';
z.string.cs.conversationContextMenuDelete = 'Odstranit pro m';
z.string.cs.conversationContextMenuDeleteEveryone = 'Odstranit pro vechny';
z.string.cs.conversationContextMenuDownload = 'Sthnout';
z.string.cs.conversationContextMenuLike = 'Lb';
z.string.cs.conversationContextMenuUnlike = 'Nelb';
z.string.cs.conversationDeleteTimestamp = 'Smazno v {{date}}';
z.string.cs.conversationEditTimestamp = 'Upraveno v {{date}}';
z.string.cs.conversationLikesCaption = '{{number}} lid';
z.string.cs.conversationSendPastedFile = 'Obrzek vloen {{date}}';
z.string.cs.conversationSomeone = 'Nkdo';
z.string.cs.conversationTweetAuthor = ' na Twittru';

z.string.cs.groupCreationPreferencesAction = 'Dal';
z.string.cs.groupCreationParticipantsPlaceholder = 'Hledat podle jmna';


z.string.cs.collectionShowAll = 'Zobrazit vechny {{number}}';
z.string.cs.collectionSectionLinks = 'Odkazy';
z.string.cs.collectionSectionImages = 'Obrzky';
z.string.cs.collectionSectionFiles = 'Soubory';
z.string.cs.collectionSectionAudio = 'Zvukov zprvy';

z.string.cs.fullsearchPlaceholder = 'Prohledat zprvy';
z.string.cs.fullsearchNoResults = 'dn vsledky.';

z.string.cs.archiveHeader = 'Archivovat';

z.string.cs.conversationsAllArchived = 'Ve archivovno';
z.string.cs.conversationsContacts = 'Kontakty';
z.string.cs.conversationsConnectionRequestMany = '{{number}} ekajcch osob';
z.string.cs.conversationsConnectionRequestOne = '1 ekajc osoba';
z.string.cs.conversationsEmptyConversation = 'Skupinov konverzace';
z.string.cs.conversationsNoConversations = 'Zatm dn konverzace';
z.string.cs.conversationsPopoverArchive = 'Archivovat';
z.string.cs.conversationsPopoverCancel = 'Zruit dost';
z.string.cs.conversationsPopoverNotify = 'Zapnout zvuk';
z.string.cs.conversationsPopoverSilence = 'Ztlumit';
z.string.cs.conversationsPopoverUnarchive = 'Obnovit';

z.string.cs.conversationsSecondaryLineEphemeralMessage = 'Vm poslal zprvu';
z.string.cs.conversationsSecondaryLinePeopleLeft = '{{number}} lid opustilo konverzaci';
z.string.cs.conversationsSecondaryLinePersonLeft = '{{user}} opustil(a) konverzaci';
z.string.cs.conversationsSecondaryLinePersonRemoved = '{{user}} byl odebrn';
z.string.cs.conversationsSecondaryLinePeopleAdded = '{{user}} lid byli pidni';
z.string.cs.conversationsSecondaryLinePersonAdded = '{{user}} byl pdn';
z.string.cs.conversationsSecondaryLinePersonAddedYou = '{{user}} vs pidal';
z.string.cs.conversationsSecondaryLineRenamed = '{{user}} pejmenoval konverzaci';
z.string.cs.conversationsSecondaryLineYouLeft = 'Opustil(a) jste konverzaci';
z.string.cs.conversationsSecondaryLineYouWereRemoved = 'Byl(a) jste odebrn(a)';

z.string.cs.takeoverSub = 'Vytvote si vae jedinen jmno na Wire.';
z.string.cs.takeoverLink = 'Dozvdt se vce';
z.string.cs.takeoverButtonChoose = 'Vyberte sv vlastn';
z.string.cs.takeoverButtonKeep = 'Ponechat tento';

z.string.cs.inviteMetaKeyMac = 'Cmd';
z.string.cs.inviteMetaKeyPc = 'Ctrl';
z.string.cs.inviteHeadline = 'Pozvat lidi do aplikace Wire';
z.string.cs.inviteMessage = 'Jsem na Wire, hledejte {{username}} nebo navtivte get.wire.com.';
z.string.cs.inviteMessageNoEmail = 'Jsem k zastien na sti Wire. K navzn kontaktu navtivte https://get.wire.com.';

z.string.cs.extensionsBubbleButtonGif = 'Gif';

z.string.cs.extensionsGiphyButtonOk = 'Odeslat';
z.string.cs.extensionsGiphyButtonMore = 'Zkusit jin';
z.string.cs.extensionsGiphyMessage = '{{tag}}  pes giphy.com';
z.string.cs.extensionsGiphyNoGifs = 'Uups, dn gify';
z.string.cs.extensionsGiphyRandom = 'Nhodn';

z.string.cs.addParticipantsConfirmLabel = 'Pidat';
z.string.cs.addParticipantsSearchPlaceholder = 'Hledat podle jmna';
z.string.cs.addParticipantsTabsPeople = 'Kontakty';
z.string.cs.addParticipantsTabsServices = 'Sluby';

z.string.cs.conversationDetailsActionArchive = 'Archivovat';
z.string.cs.conversationDetailsActionCancelRequest = 'Zruit dost';
z.string.cs.conversationDetailsActionDevices = 'Pstroje';
z.string.cs.conversationDetailsActionNotifications = 'Upozornn';
z.string.cs.conversationDetailsGuestsOff = 'Vypnout';
z.string.cs.conversationDetailsOptions = 'Nastaven';
z.string.cs.conversationDetailsParticipantsServicesMany = 'Sluby';
z.string.cs.conversationDetailsParticipantsUsersMany = 'Kontakty';
z.string.cs.conversationDetailsPeople = 'Kontakty';
z.string.cs.conversationDetailsServices = 'Sluby';

z.string.cs.conversationParticipantsTitle = 'Kontakty';
z.string.cs.conversationParticipantsSearchPlaceholder = 'Hledat podle jmna';

z.string.cs.groupParticipantActionCancelRequest = 'Zruit dost';
z.string.cs.groupParticipantActionDevices = 'Pstroje';
z.string.cs.groupParticipantActionPending = 'Nevyzen';
z.string.cs.groupParticipantActionSendRequest = 'Pipojit';

z.string.cs.notificationSettingsTitle = 'Upozornn';

z.string.cs.participantDevicesDetailHeadline = 'Ovte, e to odpovd identifiktoru zobrazenm na {{html1}}uivatele {{user}}{{html2}}.';
z.string.cs.participantDevicesDetailHowTo = 'Jak to mm udlat?';
z.string.cs.participantDevicesDetailResetSession = 'Resetovat sezen';
z.string.cs.participantDevicesDetailShowMyDevice = 'Zorazit identifiktor mho pstroje';
z.string.cs.participantDevicesDetailVerify = 'Ovreno';

z.string.cs.participantDevicesHeader = 'Pstroje';
z.string.cs.participantDevicesHeadline = 'Wire piazuje kadmu pstroji jedinen identifiktor. Porovnejte je s {{user}} a ovte svou konverzaci.';
z.string.cs.participantDevicesLearnMore = 'Dozvdt se vce';
z.string.cs.participantDevicesWhyVerify = 'Pro mm ovovat konverzaci?';
z.string.cs.participantDevicesOutdatedClientMessage = '{{user}} pouv star verzi aplikace Wire. Nejsou zde zobrazeny dn pstroje.';

z.string.cs.participantDevicesSelfAllDevices = 'Zobrazit vechny m pstroje';
z.string.cs.participantDevicesSelfFingerprint = 'Identifiktor pstoje';

z.string.cs.userProfileButtonConnect = 'Pipojit';
z.string.cs.userProfileButtonIgnore = 'Ignorovat';
z.string.cs.userProfileButtonUnblock = 'Odblokovat';

z.string.cs.preferencesAbout = 'O aplikaci';
z.string.cs.preferencesAccount = 'et';
z.string.cs.preferencesAV = 'Audio / Video';
z.string.cs.preferencesDeviceDetails = 'Podrobnosti o pstroji';
z.string.cs.preferencesDevices = 'Pstroje';
z.string.cs.preferencesHeadline = 'Pedvolby';
z.string.cs.preferencesOptions = 'Nastaven';

z.string.cs.preferencesAboutPrivacyPolicy = 'Ochrana osobnch daj';
z.string.cs.preferencesAboutSupport = 'Podpora';
z.string.cs.preferencesAboutSupportWebsite = 'Webov strnky podpory';
z.string.cs.preferencesAboutSupportContact = 'Kontaktovat podporu';
z.string.cs.preferencesAboutTermsOfUse = 'Podmnky pouvn';
z.string.cs.preferencesAboutVersion = 'Verze {{version}}';
z.string.cs.preferencesAboutWebsite = 'Wire webov strnky';

z.string.cs.preferencesAccountCreateTeam = 'Vytvoit tm';
z.string.cs.preferencesAccountDelete = 'Smazat et';
z.string.cs.preferencesAccountLogOut = 'Odhlsit se';
z.string.cs.preferencesAccountManageTeam = 'Spravovat tm';
z.string.cs.preferencesAccountResetPassword = 'Resetovat heslo';
z.string.cs.preferencesAccountTeam = 'v {{name}}';
z.string.cs.preferencesAccountUsernamePlaceholder = 'Cel jmno';
z.string.cs.preferencesAccountUsernameHint = 'Alespo 2 znaky. Pouze az, 09 a _';
z.string.cs.preferencesAccountUsernameAvailable = 'Dostupn';
z.string.cs.preferencesAccountUsernameErrorTaken = 'Ji udleno';

z.string.cs.preferencesAVCamera = 'Kamera';
z.string.cs.preferencesAVMicrophone = 'Mikrofon';
z.string.cs.preferencesAVPermissionDetail = 'Povolte v pedvolbch prohlee';
z.string.cs.preferencesAVSpeakers = 'Reproduktory';

z.string.cs.preferencesDevicesActivatedOn = 'Aktivovno v {{date}}';
z.string.cs.preferencesDevicesActive = 'Aktivn';
z.string.cs.preferencesDevicesActiveDetail = 'Pokud nepoznvte pstroj ve, odstrate ho a zmte sv heslo.';
z.string.cs.preferencesDevicesCurrent = 'Aktuln';
z.string.cs.preferencesDevicesFingerprint = 'Identifiktor kle';
z.string.cs.preferencesDevicesFingerprintDetail = 'Aplikace Wire pidluje kadmu pstroji uniktn identifiktor. Jejich porovnnm ovte sv pstroje a konverzace.';
z.string.cs.preferencesDevicesId = 'ID: ';
z.string.cs.preferencesDevicesRemoveCancel = 'Zruit';
z.string.cs.preferencesDevicesRemoveDetail = 'Jestlie jste pestali pouvat toto zazen, odeberte jej. Pot z nj budete okamit odhleni.';
z.string.cs.preferencesDevicesSessionConfirmation = 'Sezen bylo zresetovno.';
z.string.cs.preferencesDevicesSessionDetail = 'Pokud se identifiktory neshoduj, resetujte sv sezen pro vygenerovn novch kl na obou stranch.';
z.string.cs.preferencesDevicesSessionReset = 'Resetovat sezen';
z.string.cs.preferencesDevicesSessionOngoing = 'Obnoven relace';
z.string.cs.preferencesDevicesVerification = 'Ovreno';

z.string.cs.preferencesOptionsAudio = 'Zvukov upozornn';
z.string.cs.preferencesOptionsAudioAll = 'Ve';
z.string.cs.preferencesOptionsAudioAllDetail = 'Vechny zvuky';
z.string.cs.preferencesOptionsAudioNone = 'dn';
z.string.cs.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.cs.preferencesOptionsAudioSome = 'Nkter';
z.string.cs.preferencesOptionsAudioSomeDetail = 'Chaty a hovory';
z.string.cs.preferencesOptionsContacts = 'Kontakty';
z.string.cs.preferencesOptionsContactsGmail = 'Importovat ze sluby Gmail';
z.string.cs.preferencesOptionsContactsMacos = 'Import z kontakt';
z.string.cs.preferencesOptionsContactsDetail = 'Vae daje o kontaktech pouvme k propojen s ostatnmi uivateli. Vechny informace anonymizujeme a nesdlme je s nikm dalm.';
z.string.cs.preferencesOptionsPopular = 'Podle popularity poptvky';
z.string.cs.preferencesOptionsEmojiReplaceCheckbox = 'Nahradit psan emotikony pomoc emojis';
z.string.cs.preferencesOptionsPreviewsSendCheckbox = 'Vytvoit nhledy pro odeslan odkazy';
z.string.cs.preferencesOptionsPreviewsSendDetail = 'Nhledy mohou bt zobrazeny i pro odkazy od jinch lid.';
z.string.cs.preferencesOptionsNotifications = 'Upozornn';
z.string.cs.preferencesOptionsNotificationsNone = 'Vypnout';
z.string.cs.preferencesOptionsNotificationsObfuscate = 'Skrt detaily';
z.string.cs.preferencesOptionsNotificationsObfuscateMessage = 'Zobrazit odeslatele';
z.string.cs.preferencesOptionsNotificationsOn = 'Zobrazit odeslatele a zprvu';

z.string.cs.backupCancel = 'Zruit';

z.string.cs.searchConnect = 'Pipojit';
z.string.cs.searchConnections = 'Kontakty';
z.string.cs.searchContacts = 'Kontakty';
z.string.cs.searchCreateGroup = 'Vytvoit skupinu';
z.string.cs.searchGroups = 'Skupiny';
z.string.cs.searchPeople = 'Kontakty';
z.string.cs.searchPlaceholder = 'Hledat podle jmno nebo uivatelskho jmno';
z.string.cs.searchServicePlaceholder = 'Hledat podle jmna';
z.string.cs.searchServices = 'Sluby';
z.string.cs.searchTeamGroups = 'Tmov konverzace';
z.string.cs.searchTeamMembers = 'lenov tmu';
z.string.cs.searchTopPeople = 'Nejaktivnj kontakty';
z.string.cs.searchTrySearch = 'Vyhledvn osob podle\nvlastnho nebo uivatelskho jmna';
z.string.cs.searchNoContactsOnWire = 'V aplikaci Wire nemte dn kontakty.\nZkuste vyhledat kontakty podle jmna nebo\nuivatelskho jmna.';
z.string.cs.searchOthers = 'Pipojit';

z.string.cs.searchInvite = 'Pozvat lidi do aplikace Wire';
z.string.cs.searchInviteDetail = 'Sdlenm svch kontakt si zjednodute propojen s ostatnmi. Vechny informace anonymizujeme a nikdy je neposkytujeme nikomu dalmu.';
z.string.cs.searchInviteButtonContacts = 'Z kontakt';
z.string.cs.searchInviteButtonGmail = 'Z Gmailu';
z.string.cs.searchInviteHeadline = 'Pivete sv ptele';
z.string.cs.searchInviteShare = 'Sdlet kontakty';

z.string.cs.searchListEveryoneParticipates = 'Vichni, kter znte\njsou ji pipojeni\nk tto konverzaci.';
z.string.cs.searchListNoMatches = 'dn odpovdajc vsledky.\nZkuste jin jmno.';


z.string.cs.uploadGoogleHeadline = 'Najt kontakty\npro konverzaci.';
z.string.cs.uploadGoogleMessage = 'Vae daje o kontaktech pouvme k propojen s ostatnmi uivateli. Vechny informace anonymizujeme a nesdlme je s nikm dalm.';

z.string.cs.warningCallUnsupportedIncoming = 'Vol {{user}}. Tento prohle nepodporuje voln.';
z.string.cs.warningCallUnsupportedOutgoing = 'Nemete volat, protoe prohle nepodporuje voln.';
z.string.cs.warningCallIssues = 'Tato verze aplikace Wire se neme astnit voln. Pouijte prosm';
z.string.cs.warningCallUpgradeBrowser = 'Pro voln prosm aktualizujte Google Chrome.';
z.string.cs.warningConnectivityConnectionLost = 'Pokoume se o pipojen. Wire nemus bt schopen doruit zprvy.';
z.string.cs.warningConnectivityNoInternet = 'Chyb pipojen k internetu. Nebudete moci odeslat ani pijmat zprvy.';
z.string.cs.warningLearnMore = 'Dozvdt se vce';
z.string.cs.warningLifecycleUpdate = 'Je dostupn nov verze aplikace Wire.';
z.string.cs.warningLifecycleUpdateNotes = 'Co je novho';
z.string.cs.warningLifecycleUpdateLink = 'Aktualizovat nyn';
z.string.cs.warningNotFoundCamera = 'Nelze volat, protoe tento pota nem kameru.';
z.string.cs.warningNotFoundMicrophone = 'Nelze volat, protoe tento pota nem mikrofon.';
z.string.cs.warningPermissionDeniedCamera = 'Nelze volat, protoe prohle nem pstup ke kamee.';
z.string.cs.warningPermissionDeniedMicrophone = 'Nelze volat, protoe prohle nem pstup k mikrofonu.';
z.string.cs.warningPermissionDeniedScreen = 'Prohle potebuje oprvnn ke sdlen obrazovku.';
z.string.cs.warningPermissionRequestCamera = '{{icon}} Povolit pstup ke kamee';
z.string.cs.warningPermissionRequestMicrophone = '{{icon}} Povolit pstup k mikrofonu';
z.string.cs.warningPermissionRequestNotification = '{{icon}} Povolit upozornn';
z.string.cs.warningPermissionRequestScreen = '{{icon}} Povolit pstup k obrazovce';

z.string.cs.userAvailabilityAvailable = 'Dostupn';
z.string.cs.userAvailabilityNone = 'dn';

z.string.cs.notificationAssetAdd = 'Sdlel(a) obrzek';
z.string.cs.notificationConnectionAccepted = 'Pijal(a) v poadavek na pipojen';
z.string.cs.notificationConnectionConnected = 'Nyn jste pipojeni';
z.string.cs.notificationConnectionRequest = 'd o pipojen';
z.string.cs.notificationConversationCreate = '{{user}} zahjil(a) rozhovor';
z.string.cs.notificationConversationRename = '{{user}} pejmenoval(a) rozhovor na {{name}}';
z.string.cs.notificationMemberJoinMany = '{{user}} pidal(a) {{number}} kontakty do konverzace';
z.string.cs.notificationMemberJoinOne = '{{user1}} pidal(a) {{user2}} do konverzace';
z.string.cs.notificationMemberLeaveRemovedYou = '{{user}} t odebral(a) z konverzace';
z.string.cs.notificationObfuscated = 'Vm poslal zprvu';
z.string.cs.notificationObfuscatedTitle = 'Nkdo';
z.string.cs.notificationPing = 'Pingnut';
z.string.cs.notificationReaction = '{{reaction}} tvou zprvu';
z.string.cs.notificationSharedAudio = 'Sdlel(a) zvukovou zprvu';
z.string.cs.notificationSharedFile = 'Sdlel(a) soubor';
z.string.cs.notificationSharedLocation = 'Sdlel(a) polohu';
z.string.cs.notificationSharedVideo = 'Sdlel(a) video';
z.string.cs.notificationVoiceChannelActivate = 'Vol';
z.string.cs.notificationVoiceChannelDeactivate = 'Volal(a)';

z.string.cs.tooltipConversationAllVerified = 'Vechny identifiktory jsou oveny';
z.string.cs.tooltipConversationCall = 'Hovor';
z.string.cs.tooltipConversationEphemeral = 'asovan zprvy';
z.string.cs.tooltipConversationFile = 'Pidat soubor';
z.string.cs.tooltipConversationInputPlaceholder = 'Napsat zprvu';
z.string.cs.tooltipConversationPeople = 'Kontakty ({{shortcut}})';
z.string.cs.tooltipConversationPicture = 'Pidat obrzek';
z.string.cs.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.cs.tooltipConversationSearch = 'Hledat';
z.string.cs.tooltipConversationVideoCall = 'Videohovor';

z.string.cs.tooltipConversationsArchive = 'Archivovat ({{shortcut}})';
z.string.cs.tooltipConversationsArchived = 'Zobrazit archiv ({{number}})';
z.string.cs.tooltipConversationsMore = 'Dal';
z.string.cs.tooltipConversationsNotify = 'Zapnout zvuk ({{shortcut}})';
z.string.cs.tooltipConversationsPreferences = 'Otevt pedvolby';
z.string.cs.tooltipConversationsSilence = 'Ztlumit ({{shortcut}})';
z.string.cs.tooltipConversationsStart = 'Spustit konverzaci ({{shortcut}})';

z.string.cs.tooltipConversationDetailsRename = 'Zmnit nzev konverzace';

z.string.cs.tooltipPreferencesContactsGmail = 'Pihlaste se ke svmu Gmail tu pro sdlen kontakt';
z.string.cs.tooltipPreferencesContactsMacos = 'Sdlejte vechny sv kontakty z aplikace kontakt systmu macOS';
z.string.cs.tooltipPreferencesPassword = 'Pro zmnu hesla otevete dal webovou strnku';
z.string.cs.tooltipPreferencesPicture = 'Zmnit obrzek';
z.string.cs.tooltipPreferencesRename = 'Zmnit jmno';

z.string.cs.tooltipSearchClose = 'Zavt (Esc)';

z.string.cs.initReceivedSelfUser = 'Ahoj, {{user}}.';
z.string.cs.initReceivedUserData = 'Kontrola novch zprv';
z.string.cs.initDecryption = 'Deifrovat zprvu';
z.string.cs.initEvents = 'Zprvy se nataj';

z.string.cs.ephemeralUnitsNone = 'Vypnout';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.da.wireMacos = 'Wire til macOS';
z.string.da.wireWindows = 'Wire til Windows';
z.string.da.wireLinux = 'Wire til Linux';
z.string.da.nonexistentUser = 'Slet bruger';
z.string.da.and = 'og';
z.string.da.enumerationAnd = ', og ';

z.string.da.authAccountCountryCode = 'Landekode';
z.string.da.authAccountPasswordForgot = 'Glemt adgangskode';
z.string.da.authAccountPublicComputer = 'Dette er en offentlig computer';
z.string.da.authAccountSignIn = 'Log ind';
z.string.da.authAccountSignInPhone = 'Telefon';

z.string.da.authBlockedCookies = 'Aktiver cookies for at logge p Wire.';
z.string.da.authBlockedDatabase = 'Wire skal have adgang til lokal lagring til at vise dine meddelelser. Lokal lagring er ikke tilgngelig i privat tilstand.';
z.string.da.authBlockedTabs = 'Wire er allerede ben i en anden fane.';
z.string.da.authBlockedTabsAction = 'Brug denne fane i stedet';

z.string.da.authVerifyAccountAdd = 'Tilfj';
z.string.da.authVerifyAccountDetail = 'Dette gr, at du kan bruge Wire p flere enheder.';
z.string.da.authVerifyAccountHeadline = 'Tilfj email adresse og adgangskode.';
z.string.da.authVerifyAccountLogout = 'Log ud';
z.string.da.authVerifyCodeDescription = 'Indtast bekrftelseskoden vi sendte til {{number}}.';
z.string.da.authVerifyCodeResend = 'Ingen kode vist?';
z.string.da.authVerifyCodeResendDetail = 'Gensend';
z.string.da.authVerifyCodeResendTimer = 'Du kan anmode om en ny kode {{expiration}}.';
z.string.da.authVerifyCodeChangePhone = 'ndre telefon nummer';
z.string.da.authVerifyPasswordHeadline = 'Indtast din adgangskode';

z.string.da.authLimitDevicesHeadline = 'Enheder';
z.string.da.authLimitDescription = 'Fjern en af dine andre enheder for at begynde at bruge Wire p denne.';
z.string.da.authLimitButtonManage = 'Administrr enheder';
z.string.da.authLimitButtonSignOut = 'Log ud';
z.string.da.authLimitDevicesCurrent = '(Nuvrende)';

z.string.da.authHistoryHeadline = 'Det er frste gang du bruger Wire p denne enhed.';
z.string.da.authHistoryDescription = 'Af hensyn til fortrolighed, vil din chathistorik ikke vises her.';
z.string.da.authHistoryReuseHeadline = 'Du har brugt Wire p denne enhed fr.';
z.string.da.authHistoryReuseDescription = 'Beskeder sendt i mellemtiden vises ikke.';
z.string.da.authHistoryButton = 'OK';

z.string.da.authPostedResend = 'Gensend til {{email}}';
z.string.da.authPostedResendAction = 'Ingen email modtaget?';
z.string.da.authPostedResendDetail = 'Tjek din email indbakke og flg anvisningerne.';
z.string.da.authPostedResendHeadline = 'Du har post.';

z.string.da.authPlaceholderEmail = 'Email';
z.string.da.authPlaceholderPasswordPut = 'Adgangskode';
z.string.da.authPlaceholderPasswordSet = 'Adgangskode (mindst 8 tegn)';
z.string.da.authPlaceholderPhone = 'Telefon Nummer';

z.string.da.authErrorCode = 'Ugyldig Kode';
z.string.da.authErrorCountryCodeInvalid = 'Ugyldig Lande Kode';
z.string.da.authErrorEmailExists = 'Email adresse allerede brugt';
z.string.da.authErrorEmailForbidden = 'Beklager. Denne email adresse er forbudt.';
z.string.da.authErrorEmailMalformed = 'Indtast venligst en gyldig email adresse.';
z.string.da.authErrorEmailMissing = 'Indtast venligst en e-mailadresse.';
z.string.da.authErrorMisc = 'Problemer med forbindelsen. Prv venligst igen.';
z.string.da.authErrorNameShort = 'Indtast et navn p mindst to karakterer';
z.string.da.authErrorOffline = 'Ingen internetforbindelse';
z.string.da.authErrorPasswordShort = 'Vlg en adgangskode p mindst 8 karakterer.';
z.string.da.authErrorPasswordWrong = 'Forkert adgangskode. Prv igen.';
z.string.da.authErrorPending = 'Kontoen er ikke bekrftet endnu';
z.string.da.authErrorPhoneNumberBudget = 'Du har logget ind alt for ofte. Prv igen senere.';
z.string.da.authErrorPhoneNumberForbidden = 'Beklager. Dette telefonnummer er ikke tilladt.';
z.string.da.authErrorPhoneNumberInvalid = 'Ugyldigt telefonnummer';
z.string.da.authErrorPhoneNumberUnknown = 'Ukendt telefonnummer';
z.string.da.authErrorSuspended = 'Denne konto har ikke lngere tilladelse til at logge ind.';
z.string.da.authErrorSignIn = 'Bekrft venligst dine detaljer og prv igen.';

z.string.da.callStateOutgoing = 'Ringer op';
z.string.da.callStateConnecting = 'Forbinder';
z.string.da.callStateIncoming = 'Ringer op';
z.string.da.callDecline = 'Afvis';
z.string.da.callAccept = 'Besvar';
z.string.da.callJoin = 'Deltag';
z.string.da.callChooseSharedScreen = 'Vlg en skrm som du vil dele';
z.string.da.callParticipants = '{{number}} i samtalen';

z.string.da.videoCallOverlayMute = 'Stum samtale';
z.string.da.videoCallOverlayHangUp = 'Lg P';

z.string.da.modalAcknowledgeAction = 'Ok';
z.string.da.modalAcknowledgeHeadline = 'Noget gik galt';
z.string.da.modalConfirmSecondary = 'Annuller';
z.string.da.modalOptionSecondary = 'Annuller';

z.string.da.modalAccountCreateAction = 'OK';
z.string.da.modalAccountCreateHeadline = 'Opret en konto?';
z.string.da.modalAccountCreateMessage = 'Ved at oprette en konto vil du miste samtaleoversigten i dette gsterum.';

z.string.da.modalAccountDeletionAction = 'Slet';
z.string.da.modalAccountDeletionHeadline = 'Slet konto';
z.string.da.modalAccountDeletionMessage = 'Vi vil sende dig en besked via email eller SMS. Flg linket for at permanent slette din konto.';

z.string.da.modalAccountLeaveGuestRoomAction = 'Forlad';
z.string.da.modalAccountLeaveGuestRoomHeadline = 'Forlade gsterummet?';
z.string.da.modalAccountLeaveGuestRoomMessage = 'Samtaleoversigten vil blive slettet. For at beholde det, oprett en konto nste gang.';

z.string.da.modalAccountLogoutAction = 'Log ud';
z.string.da.modalAccountLogoutHeadline = 'Ryd Data?';
z.string.da.modalAccountLogoutOption = 'Slet alle dine personlige informationer og samtaler p denne enhed.';

z.string.da.modalAccountNewDevicesSecondary = 'Administrr enheder';
z.string.da.modalAccountNewDevicesHeadline = 'Din konto blev brugt p:';
z.string.da.modalAccountNewDevicesFrom = 'Fra:';
z.string.da.modalAccountNewDevicesMessage = 'Hvis du ikke gjorde dette, slet enheden og nulstil din adgangskode.';

z.string.da.modalAccountRemoveDeviceAction = 'Fjern enhed';
z.string.da.modalAccountRemoveDeviceHeadline = 'Fjern "{{device}}"';
z.string.da.modalAccountRemoveDeviceMessage = 'Din adgangskode er krvet for at fjerne denne enhed.';
z.string.da.modalAccountRemoveDevicePlaceholder = 'Adgangskode';

z.string.da.modalAssetTooLargeHeadline = 'Filen er for stor';
z.string.da.modalAssetTooLargeMessage = 'Du kan sende filer med strrelse op til {{number}}';

z.string.da.modalAssetParallelUploadsHeadline = 'Alt for mange filer p en gang';
z.string.da.modalAssetParallelUploadsMessage = 'Du kan sende op til {{number}} filer p n gang.';

z.string.da.modalCallEmptyConversationHeadline = 'Ingen at ringe til';
z.string.da.modalCallEmptyConversationMessage = 'Der er ingen tilbage her.';

z.string.da.modalCallNoGroupVideoHeadline = 'Ingen video opkald i grupper';
z.string.da.modalCallNoGroupVideoMessage = 'Video opkald er ikke tilgngelig i gruppe samtaler.';

z.string.da.modalCallNoMicrophoneAction = 'Fortl mig hvordan';
z.string.da.modalCallNoMicrophoneMessage = 'Din browser skal have adgang til mikrofonen for at foretage opkald.';
z.string.da.modalCallNoMicrophoneHeadline = 'Kan ikke ringe uden mikrofon';

z.string.da.modalCallSecondIncomingAction = 'Besvar';
z.string.da.modalCallSecondIncomingHeadline = 'Besvar opkald?';
z.string.da.modalCallSecondIncomingMessage = 'Dit nuvrende opkald vil afsluttes.';

z.string.da.modalCallSecondOngoingAction = 'Lg P';
z.string.da.modalCallSecondOngoingHeadline = 'Lg p fra en anden enhed?';
z.string.da.modalCallSecondOngoingMessage = 'Du kan kun vre i et opkald af gangen.';

z.string.da.modalCallSecondOutgoingAction = 'Lg P';
z.string.da.modalCallSecondOutgoingHeadline = 'Lg nuvrende opkald p?';
z.string.da.modalCallSecondOutgoingMessage = 'Du kan kun vre i et opkald af gangen.';

z.string.da.modalConnectCancelAction = 'Ja';
z.string.da.modalConnectCancelHeadline = 'Annuller anmodning?';
z.string.da.modalConnectCancelMessage = 'Fjern anmodning om forbindelse til {{user}}.';
z.string.da.modalConnectCancelSecondary = 'Nej';

z.string.da.modalConnectAcceptAction = 'Forbind';
z.string.da.modalConnectAcceptHeadline = 'Acceptr?';
z.string.da.modalConnectAcceptMessage = 'Dette vil forbinde jer og bne en samtale med {{user}}.';
z.string.da.modalConnectAcceptSecondary = 'Ignorr';

z.string.da.modalConversationClearAction = 'Slet';
z.string.da.modalConversationClearHeadline = 'Slet indhold?';
z.string.da.modalConversationClearMessage = 'Dette vil fjerne samtaleoversigten p alle dine enheder.';
z.string.da.modalConversationClearOption = 'Forlad ogs samtalen';

z.string.da.modalConversationDeleteMessageAction = 'Slet';
z.string.da.modalConversationDeleteMessageHeadline = 'Slet kun for mig?';
z.string.da.modalConversationDeleteMessageMessage = 'Dette kan ikke fortrydes.';

z.string.da.modalConversationDeleteMessageEveryoneAction = 'Slet';
z.string.da.modalConversationDeleteMessageEveryoneHeadline = 'Slet for alle?';
z.string.da.modalConversationDeleteMessageEveryoneMessage = 'Dette kan ikke fortrydes.';

z.string.da.modalConversationLeaveAction = 'Forlad';
z.string.da.modalConversationLeaveHeadline = 'Forlad {{name}} samtale?';
z.string.da.modalConversationLeaveMessage = 'Du vil ikke vre i stand til at sende og modtage beskeder i denne samtale.';

z.string.da.modalConversationMessageTooLongHeadline = 'Besked for lang';
z.string.da.modalConversationMessageTooLongMessage = 'Du kan sende beskeder p op til {{number}} tegn.';

z.string.da.modalConversationNewDeviceAction = 'Send alligevel';
z.string.da.modalConversationNewDeviceHeadlineOne = '{{user}} er begyndt at bruge en ny enhed';
z.string.da.modalConversationNewDeviceHeadlineMany = '{{user}}s er begyndt at bruge nye enheder';
z.string.da.modalConversationNewDeviceHeadlineYou = '{{user}} er begyndt at bruge en ny enhed';
z.string.da.modalConversationNewDeviceIncomingCallAction = 'Besvar opkald';
z.string.da.modalConversationNewDeviceIncomingCallMessage = 'Vil du stadig besvare opkaldet?';
z.string.da.modalConversationNewDeviceMessage = 'Vil du stadig sende dine beskeder?';
z.string.da.modalConversationNewDeviceOutgoingCallAction = 'Ring alligevel';
z.string.da.modalConversationNewDeviceOutgoingCallMessage = 'Vil du stadig placere opkaldet?';

z.string.da.modalConversationNotConnectedHeadline = 'Ingen tilfjet til samtale';
z.string.da.modalConversationNotConnectedMessageOne = '{{name}} vil ikke tilfjes til samtalen.';
z.string.da.modalConversationNotConnectedMessageMany = 'En af de valgte personer vil ikke tilfjes til samtalen.';

z.string.da.modalConversationRemoveAction = 'Fjern';
z.string.da.modalConversationRemoveHeadline = 'Fjern?';
z.string.da.modalConversationRemoveMessage = '{{user}} vil ikke vre i stand til at sende eller modtage beskeder i denne samtale.';

z.string.da.modalConversationRemoveGuestsAction = 'Fjern gster';
z.string.da.modalConversationRemoveGuestsHeadline = 'At deaktivere gsteadgang?';
z.string.da.modalConversationRemoveGuestsMessage = 'Aktuel gst vil blive fjernet fra samtalen. Nye gster vil ikke vre tilladt.';

z.string.da.modalConversationRevokeLinkAction = 'Tilbagekalde link';
z.string.da.modalConversationRevokeLinkHeadline = 'Tilbagekalde linket?';
z.string.da.modalConversationRevokeLinkMessage = 'Nye gster vil ikke kunne tilslutte med dette link. Aktuelle gster vil stadig have adgang.';

z.string.da.modalConversationGuestOptionsAllowGuestMessage = 'Kunne ikke tillade gster. Prv venligst igen.';
z.string.da.modalConversationGuestOptionsDisableGuestMessage = 'Gsterne kunne ikke fjernes. Prv venligst igen.';
z.string.da.modalConversationGuestOptionsGetCodeMessage = 'Kunne ikke f adgangslink.';
z.string.da.modalConversationGuestOptionsRequestCodeMessage = 'Kunne ikke anmode om adgangslink. Prv venligst igen.';
z.string.da.modalConversationGuestOptionsRevokeCodeMessage = 'Kunne ikke tilbagekalde adgangslink. Prv venligst igen.';
z.string.da.modalConversationGuestOptionsToggleGuestsMessage = 'Kunne ikke ndre gsterne tilstand.';

z.string.da.modalConversationTooManyMembersHeadline = 'Fuldt hus';
z.string.da.modalConversationTooManyMembersMessage = 'Op til {{number1}} personer kan deltage i en samtale. I jeblikket er der kun plads til {{number2}} mere.';

z.string.da.modalGifTooLargeHeadline = 'Valgte animation er for stor';
z.string.da.modalGifTooLargeMessage = 'Maksimale strrelse er {{number}} MB.';

z.string.da.modalIntegrationUnavailableHeadline = 'Bots er ikke tilgngelig i jeblikket';
z.string.da.modalIntegrationUnavailableMessage = 'Tak for din interesse for bots. Tjenesten er i jeblikket suspenderet, mens vi arbejder p den nste version. Bliv her.';

z.string.da.modalPictureFileFormatHeadline = 'Kan ikke bruge dette billede';
z.string.da.modalPictureFileFormatMessage = 'Vlg venligst en PNG eller JPEG-fil.';

z.string.da.modalPictureTooLargeHeadline = 'Valgte billede er for stor';
z.string.da.modalPictureTooLargeMessage = 'Du kan bruge billeder op til {{number}} MB.';

z.string.da.modalPictureTooSmallHeadline = 'Billede for lille';
z.string.da.modalPictureTooSmallMessage = 'Vlg venligst et billede, der er mindst 320 x 320 px.';

z.string.da.modalImproveWireAction = 'Besvar';
z.string.da.modalImproveWireSecondary = 'Nej';

z.string.da.modalServiceUnavailableHeadline = 'Tilfje tjeneste ikke muligt';
z.string.da.modalServiceUnavailableMessage = 'Tjenesten er utilgngelig i jeblikket.';

z.string.da.modalSessionResetHeadline = 'Sessionen er blevet nulstillet';
z.string.da.modalSessionResetMessage1 = 'Hvis problemet ikke er lst,';
z.string.da.modalSessionResetMessageLink = 'kontakt';
z.string.da.modalSessionResetMessage2 = 'os.';

z.string.da.modalUploadContactsAction = 'Prv igen';
z.string.da.modalUploadContactsMessage = 'Vi har ikke modtaget dine oplysninger. Venligst prv at importere dine kontakter igen.';

z.string.da.modalUserBlockAction = 'Blokr';
z.string.da.modalUserBlockHeadline = 'Blokkr {{user}}?';
z.string.da.modalUserBlockMessage = '{{user}} vil ikke kunne kontakte dig eller tilfje dig til gruppesamtaler.';

z.string.da.modalUserUnblockAction = 'Fjern Blokering';
z.string.da.modalUserUnblockHeadline = 'Fjern Blokering?';
z.string.da.modalUserUnblockMessage = '{{user}} vil igen kunne kontakte dig og tilfje dig til gruppesamtaler.';

z.string.da.connectionRequestConnect = 'Forbind';
z.string.da.connectionRequestIgnore = 'Ignorr';

z.string.da.conversationGuestIndicator = 'Gst';
z.string.da.userRemainingTimeHours = '{{time}}t tilbage';
z.string.da.userRemainingTimeMinutes = 'Mindre end {{time}}m tilbage';

z.string.da.conversationYouNominative = 'dig';
z.string.da.conversationYouDative = 'dig';
z.string.da.conversationYouAccusative = 'dig';

z.string.da.conversationConnectionAccepted = 'Forbundet';
z.string.da.conversationConnectionBlocked = 'Blokeret';
z.string.da.conversationConnectionCancelRequest = 'Annullr anmodning om forbindelse';
z.string.da.conversationCreateTemporary = 'Du tilsluttede dig til samtalen';
z.string.da.conversationCreateWith = 'med {{users}}';
z.string.da.conversationDeviceStartedUsingOne = ' begyndte at bruge';
z.string.da.conversationDeviceStartedUsingMany = ' begyndte at bruge';
z.string.da.conversationDeviceUnverified = ' har afbekrftet en af';
z.string.da.conversationDeviceYourDevices = ' dine enheder';
z.string.da.conversationDeviceUserDevices = ' {{user}}s enheder';
z.string.da.conversationDeviceNewDeviceOne = ' en ny enhed';
z.string.da.conversationDeviceNewDeviceMany = ' nye enheder';
z.string.da.conversationDeviceNewPeopleJoined = 'Nye mennesker tilsluttede.';
z.string.da.conversationDeviceNewPeopleJoinedVerify = ' verificer enheder';
z.string.da.conversationJustNow = 'Lige nu';
z.string.da.conversationLocationLink = 'ben Kort';
z.string.da.conversationMessageDelivered = 'Leveret';
z.string.da.conversationRename = ' omdbte samtalen';
z.string.da.conversationRenameYou = ' omdbte samtalen';
z.string.da.conversationResume = 'Start en samtale med {{users}}';
z.string.da.conversationPing = ' pingede';
z.string.da.conversationPingYou = ' pingede';
z.string.da.conversationToday = 'i dag';
z.string.da.conversationVoiceChannelDeactivate = ' ringede';
z.string.da.conversationVoiceChannelDeactivateYou = ' ringede';
z.string.da.conversationYesterday = 'I gr';
z.string.da.conversationUnableToDecrypt1 = 'en besked fra {{user}} blev ikke modtaget.';
z.string.da.conversationUnableToDecrypt2 = '{{user}}s enheds identitet er ndret. Uleveret besked.';
z.string.da.conversationUnableToDecryptLink = 'Hvorfor?';
z.string.da.conversationUnableToDecryptErrorMessage = 'Fejl';
z.string.da.conversationUnableToDecryptResetSession = 'Nulstil session';
z.string.da.conversationMissedMessages = 'Du har ikke brugt denne enhed i et stykke tid. Nogle meddelelser vises mske ikke her.';
z.string.da.conversationAssetUploading = 'Uploader';
z.string.da.conversationAssetDownloading = 'Downloader';
z.string.da.conversationAssetUploadFailed = 'Upload Mislykkedes';
z.string.da.conversationPlaybackError = 'Ikke i stand til at afspille';
z.string.da.conversationContextMenuCopy = 'Kopir';
z.string.da.conversationContextMenuEdit = 'Redigr';
z.string.da.conversationContextMenuDelete = 'Slet for mig';
z.string.da.conversationContextMenuDeleteEveryone = 'Slet for alle';
z.string.da.conversationContextMenuDownload = 'Download';
z.string.da.conversationContextMenuLike = 'Synes Om';
z.string.da.conversationContextMenuUnlike = 'Synes Ikke Om';
z.string.da.conversationDeleteTimestamp = 'Slettet p {{date}}';
z.string.da.conversationEditTimestamp = 'Redigeret p {{date}}';
z.string.da.conversationLikesCaption = '{{number}} personer';
z.string.da.conversationSendPastedFile = 'Indsatte billede d. {{date}}';
z.string.da.conversationSomeone = 'Nogen';
z.string.da.conversationTweetAuthor = ' p Twitter';

z.string.da.groupCreationPreferencesAction = 'Nste';
z.string.da.groupCreationPreferencesErrorNameShort = 'Mindst 1 tegn';
z.string.da.groupCreationPreferencesErrorNameLong = 'For mange tegn';
z.string.da.groupCreationPreferencesHeader = 'Opret gruppe';
z.string.da.groupCreationPreferencesPlaceholder = 'Gruppenavn';
z.string.da.groupCreationParticipantsActionCreate = 'Frdig';
z.string.da.groupCreationParticipantsActionSkip = 'Spring over';
z.string.da.groupCreationParticipantsHeader = 'Tilfj personer';
z.string.da.groupCreationParticipantsHeaderWithCounter = 'Tilfj personer ({{number}})';
z.string.da.groupCreationParticipantsPlaceholder = 'Sg ved navn';

z.string.da.guestRoomConversationName = 'Gsterum';
z.string.da.guestRoomToggleName = 'Tillad gster';
z.string.da.guestRoomToggleInfo = 'bn denne samtale for personer uden for dit team.';
z.string.da.guestRoomToggleInfoExtended = 'bn denne samtale for personer uden for dit team. Du kan altid ndre det senere.';

z.string.da.guestRoomConversationBadge = 'Gster er til stede';

z.string.da.guestRoomConversationHead = 'Folk uden for dit team kan deltage i denne samtale.';
z.string.da.guestRoomConversationButton = 'Inviter personer';

z.string.da.collectionShowAll = 'Vis alle {{number}}';
z.string.da.collectionSectionLinks = 'Links';
z.string.da.collectionSectionImages = 'Billeder';
z.string.da.collectionSectionFiles = 'Filer';
z.string.da.collectionSectionAudio = 'Lydbeskeder';

z.string.da.fullsearchPlaceholder = 'Sg i tekstbeskeder';
z.string.da.fullsearchNoResults = 'Ingen resultater.';

z.string.da.archiveHeader = 'Arkivr';

z.string.da.conversationsAllArchived = 'Alt arkiveret';
z.string.da.conversationsContacts = 'Kontakter';
z.string.da.conversationsConnectionRequestMany = '{{number}} personer venter';
z.string.da.conversationsConnectionRequestOne = '1 person venter';
z.string.da.conversationsEmptyConversation = 'Gruppesamtale';
z.string.da.conversationsNoConversations = 'Ingen samtaler';
z.string.da.conversationsPopoverArchive = 'Arkiver samtale';
z.string.da.conversationsPopoverBlock = 'Bloker kontakt';
z.string.da.conversationsPopoverCancel = 'Annuller anmodning';
z.string.da.conversationsPopoverClear = 'Slet indhold';
z.string.da.conversationsPopoverLeave = 'Forlad gruppen';
z.string.da.conversationsPopoverNotify = 'Lyd til samtale';
z.string.da.conversationsPopoverSilence = 'Stum samtale';
z.string.da.conversationsPopoverUnarchive = 'Genopret samtale';

z.string.da.conversationsSecondaryLineEphemeralMessage = 'Sendte dig en besked';
z.string.da.conversationsSecondaryLinePeopleLeft = '{{number}} personer forlod';
z.string.da.conversationsSecondaryLinePersonLeft = '{{user}} forlod';
z.string.da.conversationsSecondaryLinePersonRemoved = '{{user}} blev fjernet';
z.string.da.conversationsSecondaryLinePersonRemovedTeam = '{{user}} blev fjernet fra teamet';
z.string.da.conversationsSecondaryLinePeopleAdded = '{{user}} personer blev tilfjet';
z.string.da.conversationsSecondaryLinePersonAdded = '{{user}} blev tilfjet';
z.string.da.conversationsSecondaryLinePersonAddedSelf = '{{user}} tilsluttede';
z.string.da.conversationsSecondaryLinePersonAddedYou = '{{user}} har tilfjet dig';
z.string.da.conversationsSecondaryLineRenamed = '{{user}} omdbte samtalen';
z.string.da.conversationsSecondaryLineYouLeft = 'Du forlod';
z.string.da.conversationsSecondaryLineYouWereRemoved = 'Du blev fjernet';

z.string.da.takeoverSub = 'Vlg dit unikke navn p Wire.';
z.string.da.takeoverLink = 'Lr mere';
z.string.da.takeoverButtonChoose = 'Vlg dit eget';
z.string.da.takeoverButtonKeep = 'Behold denne';

z.string.da.inviteMetaKeyMac = 'Cmd';
z.string.da.inviteMetaKeyPc = 'Ctrl';
z.string.da.inviteHintSelected = 'Tryk {{metaKey}} + C for at kopiere';
z.string.da.inviteHintUnselected = 'Vlg og tryk p {{metaKey}} + C';
z.string.da.inviteHeadline = 'Inviter personer til Wire';
z.string.da.inviteMessage = 'Jeg er p Wire, sg efter {{username}} eller besg get.wire.com.';
z.string.da.inviteMessageNoEmail = 'Jeg er p Wire. Besg get.wire.com for at forbinde dig med mig.';

z.string.da.extensionsBubbleButtonGif = 'Gif';

z.string.da.extensionsGiphyButtonOk = 'Send';
z.string.da.extensionsGiphyButtonMore = 'Prv en anden';
z.string.da.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.da.extensionsGiphyNoGifs = 'Ups, ingen gifs';
z.string.da.extensionsGiphyRandom = 'Tilfldig';

z.string.da.addParticipantsConfirmLabel = 'Tilfj';
z.string.da.addParticipantsHeader = 'Tilfj personer';
z.string.da.addParticipantsHeaderWithCounter = 'Tilfj personer ({{number}})';
z.string.da.addParticipantsSearchPlaceholder = 'Sg ved navn';
z.string.da.addParticipantsServiceConfirmButton = 'Tilfj tjeneste';
z.string.da.addParticipantsTabsPeople = 'Personer';
z.string.da.addParticipantsTabsServices = 'Tjenester';

z.string.da.conversationDetailsActionArchive = 'Arkiver samtale';
z.string.da.conversationDetailsActionAddParticipants = 'Tilfj deltagere';
z.string.da.conversationDetailsActionBlock = 'Bloker kontakt';
z.string.da.conversationDetailsActionCancelRequest = 'Annuller anmodning';
z.string.da.conversationDetailsActionClear = 'Slet indhold';
z.string.da.conversationDetailsActionCreateGroup = 'Opret gruppe';
z.string.da.conversationDetailsActionDevices = 'Enheder';
z.string.da.conversationDetailsActionGuestOptions = 'Gst indstillinger';
z.string.da.conversationDetailsActionNotifications = 'Notifikationer';
z.string.da.conversationDetailsActionLeave = 'Forlad gruppen';
z.string.da.conversationDetailsGuestsOff = 'Slet Fra';
z.string.da.conversationDetailsGuestsOn = 'Aktiv';
z.string.da.conversationDetailsOptions = 'Egenskaber';
z.string.da.conversationDetailsParticipantsServicesOne = 'Tjeneste';
z.string.da.conversationDetailsParticipantsServicesMany = 'Tjenester';
z.string.da.conversationDetailsParticipantsUsersOne = 'Person';
z.string.da.conversationDetailsParticipantsUsersMany = 'Personer';
z.string.da.conversationDetailsPeople = 'Personer';
z.string.da.conversationDetailsServices = 'Tjenester';

z.string.da.conversationParticipantsTitle = 'Personer';
z.string.da.conversationParticipantsSearchPlaceholder = 'Sg ved navn';

z.string.da.groupParticipantActionBlock = 'Bloker kontakt';
z.string.da.groupParticipantActionCancelRequest = 'Annuller anmodning';
z.string.da.groupParticipantActionDevices = 'Enheder';
z.string.da.groupParticipantActionIgnoreRequest = 'Ignorer foresprgsel';
z.string.da.groupParticipantActionIncomingRequest = 'Accepter anmodning';
z.string.da.groupParticipantActionLeave = 'Forlad gruppen';
z.string.da.groupParticipantActionOpenConversation = 'bn samtale';
z.string.da.groupParticipantActionPending = 'Afventer';
z.string.da.groupParticipantActionRemove = 'Fjern fra gruppe';
z.string.da.groupParticipantActionSelfProfile = 'bn Profil';
z.string.da.groupParticipantActionSendRequest = 'Forbind';
z.string.da.groupParticipantActionUnblock = 'Fjern blokering af kontakt';

z.string.da.guestOptionsCopyLink = 'Kopier link';
z.string.da.guestOptionsCopyLinkDone = 'Link kopieret!';
z.string.da.guestOptionsCreateLink = 'Opret link';
z.string.da.guestOptionsInfoHeader = 'Inviter andre med et link';
z.string.da.guestOptionsInfoText = 'Alle med linket kan tilfje sig til samtalen, ogs selvom de ikke har Wire.';
z.string.da.guestOptionsRevokeLink = 'Tilbagekald link';
z.string.da.guestOptionsTitle = 'Gst indstillinger';

z.string.da.notificationSettingsTitle = 'Notifikationer';

z.string.da.participantDevicesDetailHeadline = 'Bekrft at dette passer med fingeraftrykket vist p {{html1}}{{user}}s enhed{{html2}}.';
z.string.da.participantDevicesDetailHowTo = 'Hvordan gr jeg det?';
z.string.da.participantDevicesDetailResetSession = 'Nulstil session';
z.string.da.participantDevicesDetailShowMyDevice = 'Vis min enheds fingeraftryk';
z.string.da.participantDevicesDetailVerify = 'Bekrftet';

z.string.da.participantDevicesHeader = 'Enheder';
z.string.da.participantDevicesHeadline = 'Wire giver hver enhed et unikt fingeraftryk. Sammenlign dem med {{user}} og bekrft din samtale.';
z.string.da.participantDevicesLearnMore = 'Lr mere';
z.string.da.participantDevicesWhyVerify = 'Hvorfor verificere samtaler?';
z.string.da.participantDevicesOutdatedClientMessage = '{{user}} bruger en gammel version af Wire. Ingen enheder er vist her.';

z.string.da.participantDevicesSelfAllDevices = 'Vis alle mine enheder';
z.string.da.participantDevicesSelfFingerprint = 'Enheds fingeraftryk';

z.string.da.userProfileButtonConnect = 'Forbind';
z.string.da.userProfileButtonIgnore = 'Ignorr';
z.string.da.userProfileButtonUnblock = 'Fjern Blokering';

z.string.da.preferencesAbout = 'Om';
z.string.da.preferencesAccount = 'Konto';
z.string.da.preferencesAV = 'Lyd / Video';
z.string.da.preferencesDeviceDetails = 'Enheds Detaljer';
z.string.da.preferencesDevices = 'Enheder';
z.string.da.preferencesHeadline = 'Indstillinger';
z.string.da.preferencesOptions = 'Egenskaber';

z.string.da.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.da.preferencesAboutPrivacyPolicy = 'Privatlivspolitik';
z.string.da.preferencesAboutSupport = 'Support';
z.string.da.preferencesAboutSupportWebsite = 'Support hjemmeside';
z.string.da.preferencesAboutSupportContact = 'Kontakt Support';
z.string.da.preferencesAboutTermsOfUse = 'Vilkr for anvendelse';
z.string.da.preferencesAboutVersion = 'Version {{version}}';
z.string.da.preferencesAboutWebsite = 'Wire hjemmeside';

z.string.da.preferencesAccountAvaibilityUnset = 'St en status';
z.string.da.preferencesAccountCreateTeam = 'Opret team';
z.string.da.preferencesAccountDelete = 'Slet konto';
z.string.da.preferencesAccountLeaveGuestRoom = 'Forlad gsterummet';
z.string.da.preferencesAccountLeaveGuestRoomDescription = 'Du vil ikke lngere have mulighed for at f adgang til beskederne i denne samtale.';
z.string.da.preferencesAccountLogOut = 'Log ud';
z.string.da.preferencesAccountManageTeam = 'Administrer arbejdsgrupper';
z.string.da.preferencesAccountResetPassword = 'Nulstil adgangskode';
z.string.da.preferencesAccountTeam = 'i {{name}}';
z.string.da.preferencesAccountUsernamePlaceholder = 'Dit fulde navn';
z.string.da.preferencesAccountUsernameHint = 'Mindst to tegn. Kun a-z, 0-9 og _.';
z.string.da.preferencesAccountUsernameAvailable = 'Ledig';
z.string.da.preferencesAccountUsernameErrorTaken = 'Allerede i brug';

z.string.da.preferencesAVCamera = 'Kamera';
z.string.da.preferencesAVMicrophone = 'Mikrofon';
z.string.da.preferencesAVPermissionDetail = 'Aktivr fra din browser indstillinger';
z.string.da.preferencesAVSpeakers = 'Hjtalere';
z.string.da.preferencesAVTryAgain = 'Prv Igen';

z.string.da.preferencesDevicesActivatedOn = 'Aktiveret p {{date}}';
z.string.da.preferencesDevicesActive = 'Aktiv';
z.string.da.preferencesDevicesActiveDetail = 'Hvis du ikke kan genkende en enhed ovenfor, fjern den og nulstil din adgangskode.';
z.string.da.preferencesDevicesCurrent = 'Aktuel';
z.string.da.preferencesDevicesFingerprint = 'Ngle fingeraftryk';
z.string.da.preferencesDevicesFingerprintDetail = 'Wire giver hver enhed et unikt fingeraftryk. Sammenlign dem og bekrft dine enheder og samtaler.';
z.string.da.preferencesDevicesId = 'ID: ';
z.string.da.preferencesDevicesRemove = 'Fjern';
z.string.da.preferencesDevicesRemoveCancel = 'Annuller';
z.string.da.preferencesDevicesRemoveDetail = 'Fjern denne enhed, hvis du ikke bruger den lngere. Du bliver logget ud af enheden med det samme.';
z.string.da.preferencesDevicesSessionConfirmation = 'Sessionen er blevet nulstillet.';
z.string.da.preferencesDevicesSessionDetail = 'Hvis fingeraftrykkene ikke stemmer overens, nulstil sessionen for at generere nye krypteringsngler hos begge parter.';
z.string.da.preferencesDevicesSessionReset = 'Nulstil session';
z.string.da.preferencesDevicesSessionOngoing = 'Nulstiller session';
z.string.da.preferencesDevicesVerification = 'Bekrftet';

z.string.da.preferencesOptionsAudio = 'Lyd advarsler';
z.string.da.preferencesOptionsAudioAll = 'Alle';
z.string.da.preferencesOptionsAudioAllDetail = 'Alle lyde';
z.string.da.preferencesOptionsAudioNone = 'Ingen';
z.string.da.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.da.preferencesOptionsAudioSome = 'Nogle';
z.string.da.preferencesOptionsAudioSomeDetail = 'Ping og opkald';
z.string.da.preferencesOptionsContacts = 'Kontakter';
z.string.da.preferencesOptionsContactsGmail = 'Importr fra Gmail';
z.string.da.preferencesOptionsContactsMacos = 'Omportr fra Kontakter';
z.string.da.preferencesOptionsContactsDetail = 'Vi bruger dine kontaktdata til at forbinde dig med andre. Vi anonymisere alle oplysninger og deler ikke det med alle andre.';
z.string.da.preferencesOptionsPopular = 'Ved populr eftersprgsel';
z.string.da.preferencesOptionsEmojiReplaceCheckbox = 'Erstat type emoticons med emoji';
z.string.da.preferencesOptionsPreviewsSendCheckbox = 'Lav previews til links du sender';
z.string.da.preferencesOptionsPreviewsSendDetail = 'Previews kan stadig blive vist for link fra andre.';
z.string.da.preferencesOptionsNotifications = 'Notifikationer';
z.string.da.preferencesOptionsNotificationsNone = 'Slet Fra';
z.string.da.preferencesOptionsNotificationsObfuscate = 'Skjul detaljer';
z.string.da.preferencesOptionsNotificationsObfuscateMessage = 'Vis afsender';
z.string.da.preferencesOptionsNotificationsOn = 'Vis afsender og besked';
z.string.da.preferencesOptionsCallLogs = 'Fejlfinding';
z.string.da.preferencesOptionsCallLogsGet = 'Gem samtale debug rapporten';
z.string.da.preferencesOptionsCallLogsDetail = 'Denne information hjlper Wire Support med at diagnosticere opkaldsproblemer.';

z.string.da.preferencesOptionsBackupHeader = 'Historik';
z.string.da.preferencesOptionsBackupExportHeadline = 'Sikkerhedskopier samtaler';
z.string.da.preferencesOptionsBackupExportSecondary = 'Lav en sikkerhedskopi for at gemme din samtale historik. Du kan bruge den til at gendanne historikken hvis du mister din computer eller skifter til en ny.\nSikkerhedskopi filen er ikke beskyttet af Wire end-to-end kryptering, s gem den it sikkert sted.';
z.string.da.preferencesOptionsBackupImportHeadline = 'Gendan fra sikkerhedskopi';
z.string.da.preferencesOptionsBackupImportSecondary = 'Du kan kun gendanne historik fra en sikkerhedskopi til den samme platform. Din sikkerhedskopi vil overskrive samtaler du allerede har p denne enhed.';

z.string.da.backupExportGenericErrorHeadline = 'Filen kunne ikke gemmes';
z.string.da.backupExportGenericErrorSecondary = 'Sikkerhedskopiering blev ikke frdiggjort.';
z.string.da.backupExportProgressHeadline = 'Forbereder';
z.string.da.backupExportProgressSecondary = 'Sikkerhedskopierer  {{processed}} af {{total}}  {{progress}}%';
z.string.da.backupExportSuccessHeadline = 'Sikkerhedskopiering fuldfrt';
z.string.da.backupExportSuccessSecondary = 'Du kan bruge dette til at gendanne din historik hvis du mister din computer eller skifter til en ny.';
z.string.da.backupImportGenericErrorHeadline = 'Noget gik galt';
z.string.da.backupImportGenericErrorSecondary = 'Din historik kunne ikke gendannes.';
z.string.da.backupImportAccountErrorHeadline = 'Forkert sikkerhedskopi';
z.string.da.backupImportAccountErrorSecondary = 'Du kan ikke gendanne historik fra en anden konto.';
z.string.da.backupImportVersionErrorHeadline = 'Ukompatibel sikkerhedskopi';
z.string.da.backupImportVersionErrorSecondary = 'Denne sikkerhedskopi er lavet p en nyere eller uddateret version af Wire og kan ikke blive gendannet her.';
z.string.da.backupImportIncompatibleErrorHeadline = 'Forkert sikkerhedskopi';
z.string.da.backupImportIncompatibleErrorSecondary = 'Du kan ikke gendanne historik fra en anden konto.';
z.string.da.backupImportOutdatedErrorHeadline = 'Ukompatibel sikkerhedskopi';
z.string.da.backupImportOutdatedErrorSecondary = 'Denne sikkerhedskopi er lavet p en nyere eller uddateret version af Wire og kan ikke blive gendannet her.';
z.string.da.backupImportProgressHeadline = 'Forbereder';
z.string.da.backupImportProgressSecondary = 'Gendanner historik  {{processed}} af {{total}}  {{progress}}%';
z.string.da.backupImportSuccessHeadline = 'Historik gendannet.';
z.string.da.backupCancel = 'Annuller';
z.string.da.backupTryAgain = 'Prv Igen';

z.string.da.searchConnect = 'Forbind';
z.string.da.searchConnections = 'Forbindelser';
z.string.da.searchContacts = 'Kontakter';
z.string.da.searchCreateGroup = 'Opret gruppe';
z.string.da.searchCreateGuestRoom = 'Opret gsterum';
z.string.da.searchGroups = 'Grupper';
z.string.da.searchPeople = 'Personer';
z.string.da.searchPlaceholder = 'Sg p navn eller brugernavn';
z.string.da.searchServicePlaceholder = 'Sg ved navn';
z.string.da.searchServices = 'Tjenester';
z.string.da.searchTeamGroups = 'Team samtaler';
z.string.da.searchTeamMembers = 'Team medlemmer';
z.string.da.searchTopPeople = 'Top personer';
z.string.da.searchTrySearch = 'Find personer ved navn eller Brugernavn';
z.string.da.searchNoContactsOnWire = 'Du har ingen kontakter p Wire. Prv at finde folk ved navn eller brugernavn.';
z.string.da.searchMemberInvite = 'Inviter personer til holdet';
z.string.da.searchOthers = 'Forbind';

z.string.da.searchInvite = 'Inviter personer til Wire';
z.string.da.searchInviteDetail = 'At dele dine kontakter hjlper med at forbinde til andre. Vi anonymiserer al information og deler det ikke med nogen andre.';
z.string.da.searchInviteButtonContacts = 'Fra Kontakter';
z.string.da.searchInviteButtonGmail = 'Fra Gmail';
z.string.da.searchInviteHeadline = 'F dine venner med';
z.string.da.searchInviteShare = 'Del Kontakter';

z.string.da.searchServiceConfirmButton = 'Tilfj tjeneste';

z.string.da.searchListEveryoneParticipates = 'Alle du er \nforbundet med er allerede i \ndenne samtale.';
z.string.da.searchListNoMatches = 'Ingen passende resultater.\nPrv at indtaste et andet navn.';

z.string.da.temporaryGuestCta = 'Opret en konto';
z.string.da.temporaryGuestDescription = 'Sikrer din virksomhed med krypteret gruppe chat og konference opkald.';
z.string.da.temporaryGuestTimeRemaining = ' tilbage i dette gsterum';

z.string.da.temporaryGuestJoinMessage = 'Denne samtale vil vre tilgngelig for dig i 24 timer.';
z.string.da.temporaryGuestJoinDescription = 'Hvis du lukker eller opdaterer denne side, vil du miste adgang.';

z.string.da.temporaryGuestLeaveMessage = ' er ikke lngere med i denne samtale.';
z.string.da.temporaryGuestLeaveDescription = 'Hvis du lukker eller opdaterer denne side, vil du miste adgang til samtale historikken.';

z.string.da.uploadGoogleHeadline = 'Finde personer at snakke med.';
z.string.da.uploadGoogleMessage = 'Vi bruger dine kontaktdata til at forbinde dig med andre. Vi anonymisere alle oplysninger og deler ikke det med alle andre.';

z.string.da.warningCallUnsupportedIncoming = '{{user}} ringer. Din browser understtter ikke opkald.';
z.string.da.warningCallUnsupportedOutgoing = 'Du kan ikke ringe, fordi din browser ikke understtter opkald.';
z.string.da.warningCallIssues = 'Denne version af Wire kan ikke deltage i opkaldet. Brug venligst';
z.string.da.warningCallUpgradeBrowser = 'Venligst opdater Google Chrome for at ringe.';
z.string.da.warningConnectivityConnectionLost = 'Forsger at forbinde. Wire kan muligvis ikke levere beskeder.';
z.string.da.warningConnectivityNoInternet = 'Ingen Internet. Du vil ikke kunne sende eller modtage beskeder.';
z.string.da.warningLearnMore = 'Lr mere';
z.string.da.warningLifecycleUpdate = 'En ny version af Wire er tilgngelig.';
z.string.da.warningLifecycleUpdateNotes = 'Hvad er nyt';
z.string.da.warningLifecycleUpdateLink = 'Opdatr nu';
z.string.da.warningNotFoundCamera = 'Du kan ikke ringe, fordi din computer har ikke et kamera.';
z.string.da.warningNotFoundMicrophone = 'Du kan ikke ringe, fordi din computer har ikke en mikrofon.';
z.string.da.warningPermissionDeniedCamera = 'Du kan ikke ringe, fordi din browser ikke har adgang til kameraet.';
z.string.da.warningPermissionDeniedMicrophone = 'Du kan ikke ringe, fordi din browser ikke har adgang til mikrofonen.';
z.string.da.warningPermissionDeniedScreen = 'Din browser skal have tilladelse til at dele din skrm.';
z.string.da.warningPermissionRequestCamera = '{{icon}} Tillad adgang til kamera';
z.string.da.warningPermissionRequestMicrophone = '{{icon}} Tillad adgang til mikrofon';
z.string.da.warningPermissionRequestNotification = '{{icon}} Tillad meddelelser';
z.string.da.warningPermissionRequestScreen = '{{icon}} Tillad adgang til skrm';

z.string.da.userAvailabilityAvailable = 'Ledig';
z.string.da.userAvailabilityAway = 'Ikke til stede';
z.string.da.userAvailabilityBusy = 'Optaget';
z.string.da.userAvailabilityNone = 'Ingen';

z.string.da.notificationAssetAdd = 'Delte et billede';
z.string.da.notificationConnectionAccepted = 'Accepterede din anmodning om forbindelse';
z.string.da.notificationConnectionConnected = 'Du er nu forbundet';
z.string.da.notificationConnectionRequest = 'nsker at forbinde';
z.string.da.notificationConversationCreate = '{{user}} startede en samtale';
z.string.da.notificationConversationRename = '{{user}} omdbte samtalen til {{name}}';
z.string.da.notificationMemberJoinMany = '{{user}} tilfjede {{number}} personer til samtalen';
z.string.da.notificationMemberJoinSelf = '{{user}} tilsluttede sig samtalen';
z.string.da.notificationMemberJoinOne = '{{user1}} tilfjede {{user2}} til samtalen';
z.string.da.notificationMemberLeaveRemovedYou = '{{user}} har fjernet dig fra en samtale';
z.string.da.notificationObfuscated = 'Sendte dig en besked';
z.string.da.notificationObfuscatedTitle = 'Nogen';
z.string.da.notificationPing = 'Pingede';
z.string.da.notificationReaction = '{{reaction}} din besked';
z.string.da.notificationSharedAudio = 'Delte en lyd besked';
z.string.da.notificationSharedFile = 'Delte en fil';
z.string.da.notificationSharedLocation = 'Delte en placering';
z.string.da.notificationSharedVideo = 'Delte en video';
z.string.da.notificationVoiceChannelActivate = 'Ringer';
z.string.da.notificationVoiceChannelDeactivate = 'Ringede';

z.string.da.tooltipConversationAllVerified = 'Alle fingeraftryk er bekrftede';
z.string.da.tooltipConversationCall = 'Ring op';
z.string.da.tooltipConversationEphemeral = 'Tidsbestemt besked';
z.string.da.tooltipConversationFile = 'Tilfj fil';
z.string.da.tooltipConversationInputPlaceholder = 'Skriv en besked';
z.string.da.tooltipConversationInputPlaceholderAvailable = '{{user}} er tilgngelig';
z.string.da.tooltipConversationInputPlaceholderAway = '{{user}} er ikke til stede';
z.string.da.tooltipConversationInputPlaceholderBusy = '{{user}} er optaget';
z.string.da.tooltipConversationPeople = 'Personer ({{shortcut}})';
z.string.da.tooltipConversationPicture = 'Tilfj billede';
z.string.da.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.da.tooltipConversationSearch = 'Sg';
z.string.da.tooltipConversationVideoCall = 'Videoopkald';

z.string.da.tooltipConversationsArchive = 'Arkiv ({{shortcut}})';
z.string.da.tooltipConversationsArchived = 'Vis arkiv ({{number}})';
z.string.da.tooltipConversationsMore = 'Mere';
z.string.da.tooltipConversationsNotify = 'Unmute ({{shortcut}})';
z.string.da.tooltipConversationsPreferences = 'bn indstillinger';
z.string.da.tooltipConversationsSilence = 'Mute ({{shortcut}})';
z.string.da.tooltipConversationsStart = 'Start samtale ({{shortcut}})';

z.string.da.tooltipConversationDetailsAddPeople = 'Tilfj deltagere til samtalen ({{shortcut}})';
z.string.da.tooltipConversationDetailsRename = 'ndre samtalens navn';

z.string.da.tooltipPreferencesContactsGmail = 'Log ind p din Gmail konto for at dele kontakter';
z.string.da.tooltipPreferencesContactsMacos = 'Del alle dine kontakter fra macOS Kontakter app';
z.string.da.tooltipPreferencesPassword = 'bn en anden hjemmeside for at nulstille din adgangskode';
z.string.da.tooltipPreferencesPicture = 'ndre dit billede';
z.string.da.tooltipPreferencesRename = 'ndre dit navn';

z.string.da.tooltipSearchClose = 'Luk (Esc)';

z.string.da.initReceivedSelfUser = 'Hej, {{user}}.';
z.string.da.initValidatedClient = 'Henter dine forbindelser og samtaler';
z.string.da.initReceivedUserData = 'Tjekker for nye beskeder';
z.string.da.initDecryption = 'Dekrypterer beskeder';
z.string.da.initEvents = 'Indlser meddelelser';
z.string.da.initUpdatedFromNotifications = 'Snart frdig - God fornjelse med Wire';
z.string.da.initProgress = '  {{number1}} af {{number2}}';

z.string.da.ephemeralUnitsNone = 'Slet Fra';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.de.wire = 'Wire';
z.string.de.wireMacos = 'Wire fr macOS';
z.string.de.wireWindows = 'Wire fr Windows';
z.string.de.wireLinux = 'Wire fr Linux';
z.string.de.nonexistentUser = 'Gelschte Person';
z.string.de.and = 'und';
z.string.de.enumerationAnd = ' und ';

z.string.de.authAccountCountryCode = 'Landesvorwahl';
z.string.de.authAccountPasswordForgot = 'Passwort vergessen';
z.string.de.authAccountPublicComputer = 'Dies ist ein ffentlicher Computer';
z.string.de.authAccountSignIn = 'Login';
z.string.de.authAccountSignInPhone = 'Handy Login';

z.string.de.authBlockedCookies = 'Aktiviere Cookies, um dich bei Wire einzuloggen.';
z.string.de.authBlockedDatabase = 'Wire bentigt zum Anzeigen deiner Nachrichten Zugriff auf den lokalen Speicher. In Privaten Fenstern ist dieser nicht verfgbar.';
z.string.de.authBlockedTabs = 'Wire ist bereits in einem anderen Tab geffnet.';
z.string.de.authBlockedTabsAction = 'Stattdessen diesen Tab verwenden';

z.string.de.authVerifyAccountAdd = 'Hinzufgen';
z.string.de.authVerifyAccountDetail = 'Hiermit kannst du Wire auf mehreren Gerten verwenden.';
z.string.de.authVerifyAccountHeadline = 'E-Mail-Adresse und Passwort hinzufgen.';
z.string.de.authVerifyAccountLogout = 'Abmelden';
z.string.de.authVerifyCodeDescription = 'Gib den Code ein, den wir an \n{{number}} gesendet haben.';
z.string.de.authVerifyCodeResend = 'Keinen Code erhalten?';
z.string.de.authVerifyCodeResendDetail = 'Erneut senden';
z.string.de.authVerifyCodeResendTimer = 'Du kannst {{expiration}} einen neuen Code anfordern.';
z.string.de.authVerifyCodeChangePhone = 'Telefonnummer ndern';
z.string.de.authVerifyPasswordHeadline = 'Passwort eingeben';

z.string.de.authLimitDevicesHeadline = 'Gerte';
z.string.de.authLimitDescription = 'Entferne eines deiner anderen Gerte, um Wire hier zu nutzen.';
z.string.de.authLimitButtonManage = 'Gerte verwalten';
z.string.de.authLimitButtonSignOut = 'Abmelden';
z.string.de.authLimitDevicesCurrent = '(Aktuelles Gert)';

z.string.de.authHistoryHeadline = 'Du benutzt Wire zum ersten Mal auf diesem Gert.';
z.string.de.authHistoryDescription = 'Aus Datenschutzgrnden wird dein bisheriger Gesprchsverlauf nicht angezeigt.';
z.string.de.authHistoryReuseHeadline = 'Du hast Wire auf diesem Gert bereits frher genutzt.';
z.string.de.authHistoryReuseDescription = 'Nachrichten, die in der Zwischenzeit gesendet wurden, werden nicht angezeigt.';
z.string.de.authHistoryButton = 'Verstanden';

z.string.de.authPostedResend = 'Erneut an {{email}} senden';
z.string.de.authPostedResendAction = 'E-Mail nicht erhalten?';
z.string.de.authPostedResendDetail = 'Schaue in deinen Posteingang und folge den Anweisungen.';
z.string.de.authPostedResendHeadline = 'Du hast Post.';

z.string.de.authPlaceholderEmail = 'E-Mail';
z.string.de.authPlaceholderPasswordPut = 'Passwort';
z.string.de.authPlaceholderPasswordSet = 'Passwort (min. acht Zeichen)';
z.string.de.authPlaceholderPhone = 'Telefonnummer';

z.string.de.authErrorCode = 'Ungltiger Verifizierungs-Code';
z.string.de.authErrorCountryCodeInvalid = 'Ungltige Landesvorwahl';
z.string.de.authErrorEmailExists = 'E-Mail-Adresse bereits vergeben';
z.string.de.authErrorEmailForbidden = 'Es tut uns leid. Diese E-Mail-Adresse ist verboten.';
z.string.de.authErrorEmailMalformed = 'Bitte gib eine gltige E-Mail-Adresse ein.';
z.string.de.authErrorEmailMissing = 'Bitte gib eine E-Mail-Adresse ein.';
z.string.de.authErrorMisc = 'Probleme mit der Verbindung. Versuche es erneut.';
z.string.de.authErrorNameShort = 'Gib einen Namen mit mindestens zwei Zeichen ein';
z.string.de.authErrorOffline = 'Keine Internetverbindung';
z.string.de.authErrorPasswordShort = 'Whle ein Passwort mit mindestens acht Zeichen.';
z.string.de.authErrorPasswordWrong = 'Falsches Passwort. Bitte versuche es erneut.';
z.string.de.authErrorPending = 'Benutzerkonto noch nicht verifiziert';
z.string.de.authErrorPhoneNumberBudget = 'Du hast dich zu oft eingeloggt. Versuche es spter erneut.';
z.string.de.authErrorPhoneNumberForbidden = 'Diese Telefonnummer ist leider nicht nutzbar.';
z.string.de.authErrorPhoneNumberInvalid = 'Ungltige Telefonnummer';
z.string.de.authErrorPhoneNumberUnknown = 'Unbekannte Telefonnummer';
z.string.de.authErrorSuspended = 'Benutzerkonto ist nicht mehr zum Login berechtigt.';
z.string.de.authErrorSignIn = 'berprfe deine Eingaben und versuche es erneut.';

z.string.de.callStateOutgoing = 'Klingeln';
z.string.de.callStateConnecting = 'Verbinde';
z.string.de.callStateIncoming = 'Ruft an';
z.string.de.callStateIncomingGroup = '{{user}} ruft an';
z.string.de.callDecline = 'Ablehnen';
z.string.de.callAccept = 'Annehmen';
z.string.de.callJoin = 'Beitreten';
z.string.de.callChooseSharedScreen = 'Whle einen Bildschirm aus';
z.string.de.callParticipants = '{{number}} im Anruf';
z.string.de.callNoCameraAccess = 'Kein Kamerazugriff';

z.string.de.videoCallOverlayFitVideoLabel = 'Das Video per Doppelklick anpassen';
z.string.de.videoCallOverlayConversations = 'Unterhaltungen';
z.string.de.videoCallOverlayMute = 'Stummschalten';
z.string.de.videoCallOverlayVideo = 'Video';
z.string.de.videoCallOverlayShareScreen = 'Bildschirm teilen';
z.string.de.videoCallOverlayHangUp = 'Beenden';
z.string.de.videoCallPaused = 'Video wurde angehalten';
z.string.de.videoCallScreenShareNotSupported = 'Bildschirmfreigabe wird von diesem Browser nicht untersttzt';

z.string.de.modalAcknowledgeAction = 'Ok';
z.string.de.modalAcknowledgeHeadline = 'Fehler aufgetreten';
z.string.de.modalConfirmSecondary = 'Abbrechen';
z.string.de.modalOptionSecondary = 'Abbrechen';

z.string.de.modalAccountCreateAction = 'Verstanden';
z.string.de.modalAccountCreateHeadline = 'Benutzerkonto erstellen?';
z.string.de.modalAccountCreateMessage = 'Wenn du ein Benutzerkonto erstellst, verlierst du den Unterhaltungsverlauf dieses Gstebereichs.';

z.string.de.modalAccountDeletionAction = 'Lschen';
z.string.de.modalAccountDeletionHeadline = 'Benutzerkonto lschen';
z.string.de.modalAccountDeletionMessage = 'In Krze erhltst du eine Nachricht per E-Mail oder SMS. Folge dem Link darin, um dein Konto zu lschen.';

z.string.de.modalAccountLeaveGuestRoomAction = 'Verlassen';
z.string.de.modalAccountLeaveGuestRoomHeadline = 'Gstebereich verlassen?';
z.string.de.modalAccountLeaveGuestRoomMessage = 'Der Unterhaltungsverlauf wird gelscht. Erstelle beim nchsten Mal ein Benutzerkonto, um ihn zu behalten.';

z.string.de.modalAccountLogoutAction = 'Abmelden';
z.string.de.modalAccountLogoutHeadline = 'Daten lschen?';
z.string.de.modalAccountLogoutOption = 'Deine persnlichen Daten und Unterhaltungen vollstndig von diesem Gert entfernen.';

z.string.de.modalAccountNewDevicesSecondary = 'Gerte verwalten';
z.string.de.modalAccountNewDevicesHeadline = 'Dein Benutzerkonto wurde verwendet:';
z.string.de.modalAccountNewDevicesFrom = 'Mit:';
z.string.de.modalAccountNewDevicesMessage = 'Falls du dieses Gert nicht hinzugefgt hast, entferne es und setze dein Passwort zurck.';

z.string.de.modalAccountRemoveDeviceAction = 'Gert entfernen';
z.string.de.modalAccountRemoveDeviceHeadline = 'Entferne "{{device}}"';
z.string.de.modalAccountRemoveDeviceMessage = 'Dein Passwort wird zum Entfernen des Gertes bentigt.';
z.string.de.modalAccountRemoveDevicePlaceholder = 'Passwort';

z.string.de.modalAssetTooLargeHeadline = 'Datei zu gro';
z.string.de.modalAssetTooLargeMessage = 'Du kannst Dateien bis zu {{number}} senden.';

z.string.de.modalAssetParallelUploadsHeadline = 'Zu viele Dateien auf einmal';
z.string.de.modalAssetParallelUploadsMessage = 'Du kannst bis zu {{number}} Dateien auf einmal senden.';

z.string.de.modalCallEmptyConversationHeadline = 'Niemand um anzurufen';
z.string.de.modalCallEmptyConversationMessage = 'Es ist niemand mehr in der Unterhaltung.';

z.string.de.modalCallEmptyLogHeadline = 'Keine Anrufe';
z.string.de.modalCallEmptyLogMessage = 'Es gab keine Anrufe, fr die der Debug-Bericht erstellt werden kann.';

z.string.de.modalCallNoGroupVideoHeadline = 'Keine Videoanrufe in Gruppen';
z.string.de.modalCallNoGroupVideoMessage = 'Videoanrufe sind in Gruppen nicht verfgbar.';

z.string.de.modalCallNoMicrophoneAction = 'Zeig mir wie';
z.string.de.modalCallNoMicrophoneMessage = 'Dein Browser bentigt fr Anrufe Zugriff auf das Mikrofon.';
z.string.de.modalCallNoMicrophoneHeadline = 'Anrufe sind ohne Mikrofon nicht mglich';

z.string.de.modalCallSecondIncomingAction = 'Annehmen';
z.string.de.modalCallSecondIncomingHeadline = 'Anruf annehmen?';
z.string.de.modalCallSecondIncomingMessage = 'Dein aktueller Anruf wird beendet.';

z.string.de.modalCallSecondOngoingAction = 'Beenden';
z.string.de.modalCallSecondOngoingHeadline = 'Anruf auf einem anderen Gert beenden?';
z.string.de.modalCallSecondOngoingMessage = 'Nur ein zeitgleicher Anruf mglich.';

z.string.de.modalCallSecondOutgoingAction = 'Beenden';
z.string.de.modalCallSecondOutgoingHeadline = 'Aktuellen Anruf beenden?';
z.string.de.modalCallSecondOutgoingMessage = 'Nur ein zeitgleicher Anruf mglich.';

z.string.de.modalConnectCancelAction = 'Ja';
z.string.de.modalConnectCancelHeadline = 'Kontaktanfrage abbrechen?';
z.string.de.modalConnectCancelMessage = 'Ziehe die Kontaktanfrage an {{user}} zurck.';
z.string.de.modalConnectCancelSecondary = 'Nein';

z.string.de.modalConnectAcceptAction = 'Kontakt hinzufgen';
z.string.de.modalConnectAcceptHeadline = 'Annehmen?';
z.string.de.modalConnectAcceptMessage = '{{user}} wird zu deinen Kontakten hinzugefgt und die Unterhaltung mit ihm geffnet.';
z.string.de.modalConnectAcceptSecondary = 'Ignorieren';

z.string.de.modalConversationClearAction = 'Lschen';
z.string.de.modalConversationClearHeadline = 'Unterhaltungsverlauf lschen?';
z.string.de.modalConversationClearMessage = 'Der Unterhaltungsverlauf wird auf all deinen Gerten gelscht.';
z.string.de.modalConversationClearOption = 'Unterhaltung auch verlassen';

z.string.de.modalConversationDeleteMessageAction = 'Lschen';
z.string.de.modalConversationDeleteMessageHeadline = 'Nur fr mich lschen?';
z.string.de.modalConversationDeleteMessageMessage = 'Dies kann nicht rckgngig gemacht werden.';

z.string.de.modalConversationDeleteMessageEveryoneAction = 'Lschen';
z.string.de.modalConversationDeleteMessageEveryoneHeadline = 'Fr alle lschen?';
z.string.de.modalConversationDeleteMessageEveryoneMessage = 'Dies kann nicht rckgngig gemacht werden.';

z.string.de.modalConversationLeaveAction = 'Verlassen';
z.string.de.modalConversationLeaveHeadline = 'Unterhaltung {{name}} verlassen?';
z.string.de.modalConversationLeaveMessage = 'Du wirst keine Nachrichten in dieser Unterhaltung senden oder empfangen knnen.';

z.string.de.modalConversationMessageTooLongHeadline = 'Nachricht zu lang';
z.string.de.modalConversationMessageTooLongMessage = 'Du kannst Nachrichten mit bis zu {{number}} Zeichen senden.';

z.string.de.modalConversationNewDeviceAction = 'Dennoch senden';
z.string.de.modalConversationNewDeviceHeadlineOne = '{{user}} hat begonnen ein neues Gert zu nutzen';
z.string.de.modalConversationNewDeviceHeadlineMany = '{{users}} haben begonnen neue Gerte zu nutzen';
z.string.de.modalConversationNewDeviceHeadlineYou = '{{user}} hast begonnen ein neues Gert zu nutzen';
z.string.de.modalConversationNewDeviceIncomingCallAction = 'Anruf annehmen';
z.string.de.modalConversationNewDeviceIncomingCallMessage = 'Mchtest du den Anruf dennoch annehmen?';
z.string.de.modalConversationNewDeviceMessage = 'Mchtest du deine Nachricht dennoch senden?';
z.string.de.modalConversationNewDeviceOutgoingCallAction = 'Dennoch anrufen';
z.string.de.modalConversationNewDeviceOutgoingCallMessage = 'Mchtest du wirklich anrufen?';

z.string.de.modalConversationNotConnectedHeadline = 'Niemand wurde zur Unterhaltung hinzugefgt';
z.string.de.modalConversationNotConnectedMessageOne = '{{name}} will nicht zur Unterhaltung hinzugefgt werden.';
z.string.de.modalConversationNotConnectedMessageMany = 'Eine der ausgewhlten Personen will nicht zur Unterhaltung hinzugefgt werden.';

z.string.de.modalConversationRemoveAction = 'Entfernen';
z.string.de.modalConversationRemoveHeadline = 'Entfernen?';
z.string.de.modalConversationRemoveMessage = '{{user}} wird in dieser Unterhaltung keine Nachrichten schicken oder empfangen knnen.';

z.string.de.modalConversationRemoveGuestsAction = 'Entfernen';
z.string.de.modalConversationRemoveGuestsHeadline = 'Zugang deaktivieren?';
z.string.de.modalConversationRemoveGuestsMessage = 'Aktuelle Gste und Dienste werden aus der Unterhaltung entfernt. Neue Gste und Dienste knnen nicht hinzugefgt werden.';

z.string.de.modalConversationRevokeLinkAction = 'Link widerrufen';
z.string.de.modalConversationRevokeLinkHeadline = 'Link widerrufen?';
z.string.de.modalConversationRevokeLinkMessage = 'Neue Gste werden nicht mehr mit diesem Link beitreten knnen. Aktuelle Gste haben weiterhin Zugriff auf die Unterhaltung.';

z.string.de.modalConversationGuestOptionsAllowGuestMessage = 'Gste und Dienste konnten nicht zugelassen werden. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsDisableGuestMessage = 'Gste und Dienste konnten nicht entfernt werden. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsGetCodeMessage = 'Konnte Zugangs-Link nicht laden.';
z.string.de.modalConversationGuestOptionsRequestCodeMessage = 'Konnte Zugangs-Link nicht erstellen. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsRevokeCodeMessage = 'Konnte Zugangs-Link nicht widerrufen. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsToggleGuestsMessage = 'Konnte den Gast-Status nicht wechseln.';

z.string.de.modalConversationTooManyMembersHeadline = 'Die Gruppe ist voll';
z.string.de.modalConversationTooManyMembersMessage = 'An einer Gruppe knnen bis zu {{number1}} Personen teilnehmen. Hier ist nur noch Platz fr {{number2}} Personen.';

z.string.de.modalGifTooLargeHeadline = 'Ausgewhlte Animation zu gro';
z.string.de.modalGifTooLargeMessage = 'Maximale Gre betrgt {{number}} MB.';

z.string.de.modalIntegrationUnavailableHeadline = 'Bots momentan nicht verfgbar';
z.string.de.modalIntegrationUnavailableMessage = 'Vielen Dank fr dein Interesse an Bots. Der Dienst ist derzeit ausgesetzt, whrend wir an der nchsten Generation arbeiten. Bleib gespannt.';

z.string.de.modalPictureFileFormatHeadline = 'Bild kann nicht verwendet werden';
z.string.de.modalPictureFileFormatMessage = 'Bitte whle eine PNG- oder JPEG-Datei.';

z.string.de.modalPictureTooLargeHeadline = 'Ausgewhltes Bild zu gro';
z.string.de.modalPictureTooLargeMessage = 'Du kannst Bilder mit bis zu {{number}} MB verwenden.';

z.string.de.modalPictureTooSmallHeadline = 'Ausgewhltes Bild zu klein';
z.string.de.modalPictureTooSmallMessage = 'Whle ein Bild mit mindestens 320  320 Pixeln.';

z.string.de.modalImproveWireAction = 'Ich willige ein';
z.string.de.modalImproveWireSecondary = 'Nein';
z.string.de.modalImproveWireHeadline = 'Hilf uns, Wire zu verbessern';
z.string.de.modalImproveWireMessage = 'Ich willige ein, dass Wire anonymisierte Nutzungs- und Fehlerberichte erstellen und verwenden darf, um die Wire-App zu verbessern. Ich kann diese Einwilligung jederzeit widerrufen.';

z.string.de.modalServiceUnavailableHeadline = 'Hinzufgen des Dienstes nicht mglich';
z.string.de.modalServiceUnavailableMessage = 'Der Dienst ist derzeit nicht verfgbar.';

z.string.de.modalSessionResetHeadline = 'Die Session wurde zurckgesetzt';
z.string.de.modalSessionResetMessage1 = 'Wenn das Problem weiterhin besteht,';
z.string.de.modalSessionResetMessageLink = 'kontaktiere';
z.string.de.modalSessionResetMessage2 = 'uns.';

z.string.de.modalUploadContactsAction = 'Erneut versuchen';
z.string.de.modalUploadContactsMessage = 'Wir haben die Informationen nicht erhalten. Bitte importiere deine Kontakte erneut.';

z.string.de.modalUserBlockAction = 'Blockieren';
z.string.de.modalUserBlockHeadline = '{{user}} blockieren?';
z.string.de.modalUserBlockMessage = '{{user}} wird dich nicht lnger kontaktieren oder zu Gruppen hinzufgen knnen.';

z.string.de.modalUserUnblockAction = 'Freigeben';
z.string.de.modalUserUnblockHeadline = 'Freigeben?';
z.string.de.modalUserUnblockMessage = '{{user}} wird dich wieder kontaktieren und zu Gruppen hinzufgen knnen.';

z.string.de.modalNoCameraTitle = 'Kein Kamerazugriff';
z.string.de.modalNoCameraMessage = 'Wire hat keinen Zugriff auf die Kamera.[br][faqLink]Zur Behebung bitte diesen Support Artikel anschauen[/faqLink].';

z.string.de.connectionRequestConnect = 'Kontakt hinzufgen';
z.string.de.connectionRequestIgnore = 'Ignorieren';

z.string.de.conversationGuestIndicator = 'Gast';
z.string.de.userRemainingTimeHours = '{{time}}h verbleibend';
z.string.de.userRemainingTimeMinutes = 'Weniger als {{time}}m verbleibend';

z.string.de.conversationYouNominative = 'du';
z.string.de.conversationYouDative = 'dir';
z.string.de.conversationYouAccusative = 'dich';

z.string.de.conversationConnectionAccepted = 'Hinzugefgt';
z.string.de.conversationConnectionBlocked = 'Blockiert';
z.string.de.conversationConnectionCancelRequest = 'Kontaktanfrage abbrechen';
z.string.de.conversationCreateTemporary = 'Du bist der Unterhaltung beigetreten';
z.string.de.conversationCreateWith = 'mit {{users}}';
z.string.de.conversationDeviceStartedUsingOne = ' benutzt';
z.string.de.conversationDeviceStartedUsingMany = ' benutzen';
z.string.de.conversationDeviceUnverified = ' hat die berprfung widerrufen fr';
z.string.de.conversationDeviceYourDevices = ' eines deiner Gerte';
z.string.de.conversationDeviceUserDevices = ' ein Gert von {{user}}';
z.string.de.conversationDeviceNewDeviceOne = ' ein neues Gert';
z.string.de.conversationDeviceNewDeviceMany = ' neue Gerte';
z.string.de.conversationDeviceNewPeopleJoined = 'Neue Personen beigetreten.';
z.string.de.conversationDeviceNewPeopleJoinedVerify = 'berprfe Gerte';
z.string.de.conversationJustNow = 'Gerade eben';
z.string.de.conversationLocationLink = 'Zeige Standort';
z.string.de.conversationCreated = '[bold]{{name}}[/bold] hat eine Unterhaltung mit {{users}} begonnen';
z.string.de.conversationCreatedMore = '[bold]{{name}}[/bold] hat eine Unterhaltung mit {{users}} und [showmore]{{count}} anderen[/showmore] begonnen';
z.string.de.conversationCreatedName = '[bold]{{name}}[/bold] hat eine Unterhaltung begonnen';
z.string.de.conversationCreatedNameYou = '[bold]Du[/bold] hast eine Unterhaltung begonnen';
z.string.de.conversationCreatedYou = 'Du hast eine Unterhaltung mit {{users}} begonnen';
z.string.de.conversationCreatedYouMore = 'Du hast eine Unterhaltung mit {{users}} und [showmore]{{count}} anderen[/showmore] begonnen';
z.string.de.conversationCreateWithMore = 'mit {{users}} und [showmore]{{count}} anderen[/showmore]';
z.string.de.conversationCreateTeam = 'mit [showmore]allen Team-Mitgliedern[/showmore]';
z.string.de.conversationCreateTeamGuest = 'mit [showmore]allen Team-Mitgliedern und einem Gast[/showmore]';
z.string.de.conversationCreateTeamGuests = 'mit [showmore]allen Team-Mitgliedern und {{count}} Gsten[/showmore]';
z.string.de.conversationMemberJoined = '[bold]{{name}}[/bold] hat {{users}} hinzugefgt';
z.string.de.conversationMemberJoinedYou = '[bold]Du[/bold] hast {{users}} hinzugefgt';
z.string.de.conversationMemberJoinedMore = '[bold]{{name}}[/bold] hat {{users}} und [showmore]{{count}} andere[/showmore] hinzugefgt';
z.string.de.conversationMemberJoinedYouMore = '[bold]Du[/bold] hast {{users}} und [showmore]{{count}} andere[/showmore] hinzugefgt';
z.string.de.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] ist beigetreten';
z.string.de.conversationMemberJoinedSelfYou = '[bold]Du[/bold] bist beigetreten';
z.string.de.conversationMemberLeft = '[bold]{{name}}[/bold] hat die Unterhaltung verlassen';
z.string.de.conversationMemberLeftYou = '[bold]Du[/bold] hast die Unterhaltung verlassen';
z.string.de.conversationMemberRemoved = '[bold]{{name}}[/bold] hat {{users}} entfernt';
z.string.de.conversationMemberRemovedYou = '[bold]Du[/bold] hast {{users}} entfernt';
z.string.de.conversationTeamLeft = '[bold]{{name}}[/bold] wurde aus dem Team entfernt';
z.string.de.conversationMessageDelivered = 'Zugestellt';
z.string.de.conversationRename = ' hat die Unterhaltung umbenannt';
z.string.de.conversationRenameYou = ' hast die Unterhaltung umbenannt';
z.string.de.conversationUpdatedTimer = ' hat temporre Nachrichten auf {{time}} gestellt';
z.string.de.conversationUpdatedTimerYou = ' hast temporre Nachrichten auf {{time}} gestellt';
z.string.de.conversationResetTimer = ' hat temporre Nachrichten ausgeschaltet';
z.string.de.conversationResetTimerYou = ' hast temporre Nachrichten ausgeschaltet';
z.string.de.conversationResume = 'Beginne eine Unterhaltung mit {{users}}';
z.string.de.conversationPing = ' hat gepingt';
z.string.de.conversationPingYou = ' hast gepingt';
z.string.de.conversationToday = 'Heute';
z.string.de.conversationVoiceChannelDeactivate = ' hat versucht anzurufen';
z.string.de.conversationVoiceChannelDeactivateYou = ' hast versucht anzurufen';
z.string.de.conversationYesterday = 'Gestern';
z.string.de.conversationUnableToDecrypt1 = 'Eine Nachricht von [highlight]{{user}}[/highlight] wurde nicht empfangen.';
z.string.de.conversationUnableToDecrypt2 = '[highlight]{{users}}s[/highlight] Gerte-Identitt hat sich gendert. Nachricht kann nicht entschlsselt werden.';
z.string.de.conversationUnableToDecryptLink = 'Warum?';
z.string.de.conversationUnableToDecryptErrorMessage = 'Fehler';
z.string.de.conversationUnableToDecryptResetSession = 'Session zurcksetzen';
z.string.de.conversationMissedMessages = 'Du hast Wire eine Weile nicht benutzt. Einige ltere Nachrichten knnten nicht angezeigt werden.';
z.string.de.conversationAssetUploading = 'Hochladen';
z.string.de.conversationAssetDownloading = 'Herunterladen';
z.string.de.conversationAssetUploadFailed = 'Hochladen fehlgeschlagen';
z.string.de.conversationPlaybackError = 'Konnte nicht abgespielt werden';
z.string.de.conversationContextMenuCopy = 'Kopieren';
z.string.de.conversationContextMenuEdit = 'Bearbeiten';
z.string.de.conversationContextMenuDelete = 'Fr mich lschen';
z.string.de.conversationContextMenuDeleteEveryone = 'Fr alle lschen';
z.string.de.conversationContextMenuDownload = 'Herunterladen';
z.string.de.conversationContextMenuLike = 'Gefllt mir';
z.string.de.conversationContextMenuReply = 'Antworten';
z.string.de.conversationContextMenuUnlike = 'Gefllt mir nicht mehr';
z.string.de.conversationDeleteTimestamp = 'Gelscht: {{date}}';
z.string.de.conversationEditTimestamp = 'Editiert: {{date}}';
z.string.de.conversationLikesCaption = '{{number}} Personen';
z.string.de.conversationSendPastedFile = 'Bild eingefgt am {{date}}';
z.string.de.conversationSomeone = 'Jemand';
z.string.de.conversationTweetAuthor = ' auf Twitter';
z.string.de.conversationServicesWarning = 'Dienste haben Zugriff auf den Inhalt dieser Unterhaltung';

z.string.de.groupCreationPreferencesAction = 'Weiter';
z.string.de.groupCreationPreferencesErrorNameShort = 'Gib mindestens ein Zeichen ein';
z.string.de.groupCreationPreferencesErrorNameLong = 'Der eingegebene Gruppenname ist zu lang';
z.string.de.groupCreationPreferencesHeader = 'Gruppe erstellen';
z.string.de.groupCreationPreferencesPlaceholder = 'Gruppenname';
z.string.de.groupCreationParticipantsActionCreate = 'Fertig';
z.string.de.groupCreationParticipantsActionSkip = 'berspringen';
z.string.de.groupCreationParticipantsHeader = 'Personen hinzufgen';
z.string.de.groupCreationParticipantsHeaderWithCounter = 'Personen hinzufgen ({{number}})';
z.string.de.groupCreationParticipantsPlaceholder = 'Nach Namen suchen';
z.string.de.groupSizeInfo = 'Bis zu {{count}} Personen knnen an einer Unterhaltung teilnehmen. Videoanrufe funktionieren mit bis zu 3 anderen Personen und dir.';

z.string.de.guestRoomConversationName = 'Gstebereich';
z.string.de.guestRoomToggleName = 'Gste und Dienste zulassen';
z.string.de.guestRoomToggleInfo = 'ffne diese Unterhaltung fr Dienste und Personen auerhalb des Teams.';
z.string.de.guestRoomToggleInfoExtended = 'ffne diese Unterhaltung fr Dienste und Personen auerhalb des Teams. Diese Einstellung kann spter jederzeit gendert werden.';

z.string.de.guestRoomConversationBadge = 'Gste anwesend';
z.string.de.guestRoomConversationBadgeService = 'Dienste aktiv';
z.string.de.guestRoomConversationBadgeGuestAndService = 'Gste und Dienste anwesend';

z.string.de.guestRoomConversationHead = 'Personen auerhalb des Teams knnen an dieser Unterhaltung teilnehmen.';
z.string.de.guestRoomConversationButton = 'Personen einladen';

z.string.de.collectionShowAll = 'Zeige alle {{number}}';
z.string.de.collectionSectionLinks = 'Links';
z.string.de.collectionSectionImages = 'Bilder';
z.string.de.collectionSectionFiles = 'Dateien';
z.string.de.collectionSectionAudio = 'Audio-Nachrichten';

z.string.de.fullsearchPlaceholder = 'Nachrichten durchsuchen';
z.string.de.fullsearchNoResults = 'Kein Treffer';

z.string.de.archiveHeader = 'Archivieren';

z.string.de.conversationsAllArchived = 'Alle Unterhaltungen archiviert';
z.string.de.conversationsContacts = 'Kontakte';
z.string.de.conversationsConnectionRequestMany = '{{number}} Kontaktanfragen';
z.string.de.conversationsConnectionRequestOne = 'Eine Kontaktanfrage';
z.string.de.conversationsEmptyConversation = 'Gruppenunterhaltung';
z.string.de.conversationsNoConversations = 'Beginne eine Unterhaltung oder erstelle eine Gruppe.';
z.string.de.conversationsPopoverArchive = 'Archivieren';
z.string.de.conversationsPopoverBlock = 'Blockieren';
z.string.de.conversationsPopoverCancel = 'Anfrage abbrechen';
z.string.de.conversationsPopoverClear = 'Unterhaltungsverlauf lschen';
z.string.de.conversationsPopoverLeave = 'Gruppe verlassen';
z.string.de.conversationsPopoverNotificationSettings = 'Benachrichtigungen';
z.string.de.conversationsPopoverNotify = 'Benachrichtigen';
z.string.de.conversationsPopoverSilence = 'Stummschalten';
z.string.de.conversationsPopoverUnarchive = 'Reaktivieren';

z.string.de.conversationsSecondaryLineEphemeralMention = 'Hat dich erwhnt';
z.string.de.conversationsSecondaryLineEphemeralMentionGroup = 'Jemand hat dich erwhnt';
z.string.de.conversationsSecondaryLineEphemeralMessage = 'Hat eine Nachricht gesendet';
z.string.de.conversationsSecondaryLineEphemeralMessageGroup = 'Jemand hat eine Nachricht gesendet';
z.string.de.conversationsSecondaryLineEphemeralReply = 'Hat dir geantwortet';
z.string.de.conversationsSecondaryLineEphemeralReplyGroup = 'Jemand hat dir geantwortet';
z.string.de.conversationsSecondaryLineIncomingCall = '{{user}} ruft an';
z.string.de.conversationsSecondaryLinePeopleLeft = '{{number}} Personen entfernt';
z.string.de.conversationsSecondaryLinePersonLeft = '{{user}} hat die Unterhaltung verlassen';
z.string.de.conversationsSecondaryLinePersonRemoved = '{{user}} wurde entfernt';
z.string.de.conversationsSecondaryLinePersonRemovedTeam = '{{user}} wurde aus dem Team entfernt';
z.string.de.conversationsSecondaryLinePeopleAdded = '{{user}} Personen wurden hinzugefgt';
z.string.de.conversationsSecondaryLinePersonAdded = '{{user}} wurde hinzugefgt';
z.string.de.conversationsSecondaryLinePersonAddedSelf = '{{user}} ist beigetreten';
z.string.de.conversationsSecondaryLinePersonAddedYou = '{{user}} hat dich hinzugefgt';
z.string.de.conversationsSecondaryLineRenamed = '{{user}} hat die Unterhaltung umbenannt';
z.string.de.conversationsSecondaryLineSummaryMessage = '{{number}} Nachricht';
z.string.de.conversationsSecondaryLineSummaryMessages = '{{number}} Nachrichten';
z.string.de.conversationsSecondaryLineSummaryMention = '{{number}} Erwhnung';
z.string.de.conversationsSecondaryLineSummaryMentions = '{{number}} Erwhnungen';
z.string.de.conversationsSecondaryLineSummaryMissedCall = '{{number}} verpasster Anruf';
z.string.de.conversationsSecondaryLineSummaryMissedCalls = '{{number}} verpasste Anrufe';
z.string.de.conversationsSecondaryLineSummaryPing = '{{number}} Ping';
z.string.de.conversationsSecondaryLineSummaryPings = '{{number}} Pings'
z.string.de.conversationsSecondaryLineSummaryReply = '{{number}} Antwort';
z.string.de.conversationsSecondaryLineSummaryReplies = '{{number}} Antworten';
z.string.de.conversationsSecondaryLineYouLeft = 'Du hast die Unterhaltung verlassen';
z.string.de.conversationsSecondaryLineYouWereRemoved = 'Du wurdest entfent';

z.string.de.takeoverSub = 'Sichere dir deinen persnlichen Benutzernamen auf Wire.';
z.string.de.takeoverLink = 'Erfahre mehr';
z.string.de.takeoverButtonChoose = 'Whle deinen eigenen';
z.string.de.takeoverButtonKeep = 'Behalte diesen';

z.string.de.inviteMetaKeyMac = 'Cmd';
z.string.de.inviteMetaKeyPc = 'Strg';
z.string.de.inviteHintSelected = 'Zum Kopieren {{metaKey}} + C drcken';
z.string.de.inviteHintUnselected = 'Markieren und {{metaKey}} + C drcken';
z.string.de.inviteHeadline = 'Lade Freunde zu Wire ein';
z.string.de.inviteMessage = 'Ich benutze Wire. Suche nach {{username}} oder gehe auf get.wire.com.';
z.string.de.inviteMessageNoEmail = 'Ich benutze Wire. Gehe auf get.wire.com, um mich als Kontakt hinzuzufgen.';

z.string.de.extensionsBubbleButtonGif = 'Gif';

z.string.de.extensionsGiphyButtonOk = 'Senden';
z.string.de.extensionsGiphyButtonMore = 'Neues Gif';
z.string.de.extensionsGiphyMessage = '{{tag}}  ber giphy.com';
z.string.de.extensionsGiphyNoGifs = 'Ups, kein GIF';
z.string.de.extensionsGiphyRandom = 'Zufllig';

z.string.de.addParticipantsConfirmLabel = 'Hinzufgen';
z.string.de.addParticipantsHeader = 'Teilnehmer hinzufgen';
z.string.de.addParticipantsHeaderWithCounter = 'Teilnehmer hinzufgen ({{number}})';
z.string.de.addParticipantsManageServices = 'Dienste verwalten';
z.string.de.addParticipantsManageServicesNoResults = 'Dienste verwalten';
z.string.de.addParticipantsNoServicesManager = 'Dienste sind Helfer, die den Workflow verbessern knnen.';
z.string.de.addParticipantsNoServicesMember = 'Dienste sind Helfer, die den Workflow verbessern knnen. Bitte an den Administrator wenden, um diese zu aktivieren.';
z.string.de.addParticipantsSearchPlaceholder = 'Nach Namen suchen';
z.string.de.addParticipantsServiceConfirmButton = 'Dienst hinzufgen';
z.string.de.addParticipantsTabsPeople = 'Kontakte';
z.string.de.addParticipantsTabsServices = 'Dienste';

z.string.de.conversationDetailsActionArchive = 'Archivieren';
z.string.de.conversationDetailsActionAddParticipants = 'Teilnehmer hinzufgen';
z.string.de.conversationDetailsActionBlock = 'Kontakt blockieren';
z.string.de.conversationDetailsActionCancelRequest = 'Anfrage abbrechen';
z.string.de.conversationDetailsActionClear = 'Unterhaltungsverlauf lschen';
z.string.de.conversationDetailsActionConversationParticipants = 'Zeige alle ({{number}})';
z.string.de.conversationDetailsActionCreateGroup = 'Gruppe erstellen';
z.string.de.conversationDetailsActionDevices = 'Gerte';
z.string.de.conversationDetailsActionGuestOptions = 'Gste und Dienste';
z.string.de.conversationDetailsActionTimedMessages = 'Temporre Nachrichten';
z.string.de.conversationDetailsActionNotifications = 'Benachrichtigungen';
z.string.de.conversationDetailsActionLeave = 'Gruppe verlassen';
z.string.de.conversationDetailsGuestsOff = 'Aus';
z.string.de.conversationDetailsGuestsOn = 'An';
z.string.de.conversationDetailsOptions = 'Optionen';
z.string.de.conversationDetailsParticipantsServicesOne = 'Dienst';
z.string.de.conversationDetailsParticipantsServicesMany = 'Dienste';
z.string.de.conversationDetailsParticipantsUsersOne = 'Person';
z.string.de.conversationDetailsParticipantsUsersMany = 'Personen';
z.string.de.conversationDetailsPeople = 'Personen';
z.string.de.conversationDetailsServices = 'Dienste';

z.string.de.conversationParticipantsTitle = 'Unterhaltungsbersicht';
z.string.de.conversationParticipantsSearchPlaceholder = 'Nach Namen suchen';

z.string.de.groupParticipantActionBlock = 'Kontakt blockieren';
z.string.de.groupParticipantActionCancelRequest = 'Anfrage abbrechen';
z.string.de.groupParticipantActionDevices = 'Gerte';
z.string.de.groupParticipantActionIgnoreRequest = 'Anfrage ignorieren';
z.string.de.groupParticipantActionIncomingRequest = 'Anfrage akzeptieren';
z.string.de.groupParticipantActionLeave = 'Gruppe verlassen';
z.string.de.groupParticipantActionOpenConversation = 'Unterhaltung ffnen';
z.string.de.groupParticipantActionPending = 'Ausstehend';
z.string.de.groupParticipantActionRemove = 'Aus Gruppe entfernen';
z.string.de.groupParticipantActionSelfProfile = 'Profil ffnen';
z.string.de.groupParticipantActionSendRequest = 'Kontakt hinzufgen';
z.string.de.groupParticipantActionUnblock = 'Freigeben';

z.string.de.guestOptionsCopyLink = 'Link kopieren';
z.string.de.guestOptionsCopyLinkDone = 'Link kopiert!';
z.string.de.guestOptionsCreateLink = 'Link erstellen';
z.string.de.guestOptionsInfoHeader = 'Andere per Link einladen';
z.string.de.guestOptionsInfoText = 'Jeder kann der Gruppe mit diesem Link beitreten - auch ohne eine Wire-Benutzerkonto.';
z.string.de.guestOptionsRevokeLink = 'Link widerrufen';
z.string.de.guestOptionsTitle = 'Gste und Dienste';

z.string.de.notificationSettingsTitle = 'Benachrichtigungen';
z.string.de.notificationSettingsDisclaimer = 'Immer benachrichtigen (einschlielich Audio- und Videoanrufe) oder nur bei Erwhnungen oder wenn jemand auf eine deiner Nachrichten antwortet.';
z.string.de.notificationSettingsEverything = 'Alles';
z.string.de.notificationSettingsMentionsAndReplies = 'Erwhnungen und Antworten';
z.string.de.notificationSettingsNothing = 'Nichts';

z.string.de.timedMessagesTitle = 'Temporre Nachrichten';
z.string.de.timedMessageDisclaimer = 'Temporre Nachrichten werden fr alle Teilnehmer dieser Unterhaltung eingeschaltet.';

z.string.de.participantDevicesDetailHeadline = 'berprfe, ob dieser Fingerabdruck mit dem auf {{html1}}{{user}}s Gert{{html2}} bereinstimmt.';
z.string.de.participantDevicesDetailHowTo = 'Wie mache ich das?';
z.string.de.participantDevicesDetailResetSession = 'Session zurcksetzen';
z.string.de.participantDevicesDetailShowMyDevice = 'Zeige meinen Fingerabdruck';
z.string.de.participantDevicesDetailVerify = 'Ok';

z.string.de.participantDevicesHeader = 'Gerte';
z.string.de.participantDevicesHeadline = 'Wire gibt jedem Gert einen einzigartigen Fingerabdruck. Vergleiche diese mit {{user}} und berprfe deine Unterhaltung.';
z.string.de.participantDevicesLearnMore = 'Erfahre mehr';
z.string.de.participantDevicesWhyVerify = 'Warum sollte ich meine Unterhaltungen verifizieren?';
z.string.de.participantDevicesOutdatedClientMessage = '{{user}} benutzt eine ltere Version von Wire. Es werden keine Gerte angezeigt.';

z.string.de.participantDevicesSelfAllDevices = 'Alle meine Gerte anzeigen';
z.string.de.participantDevicesSelfFingerprint = 'Fingerabdruck des Gerts';

z.string.de.userProfileButtonConnect = 'Kontakt hinzufgen';
z.string.de.userProfileButtonIgnore = 'Ignorieren';
z.string.de.userProfileButtonUnblock = 'Freigeben';

z.string.de.preferencesAbout = 'ber Wire';
z.string.de.preferencesAccount = 'Benutzerkonto';
z.string.de.preferencesAV = 'Audio / Video';
z.string.de.preferencesDeviceDetails = 'Gertedetails';
z.string.de.preferencesDevices = 'Gerte';
z.string.de.preferencesHeadline = 'Einstellungen';
z.string.de.preferencesOptions = 'Optionen';

z.string.de.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.de.preferencesAboutPrivacyPolicy = 'Datenschutzrichtlinie';
z.string.de.preferencesAboutSupport = 'Support';
z.string.de.preferencesAboutSupportWebsite = 'Support-Webseite';
z.string.de.preferencesAboutSupportContact = 'Kontaktiere den Support';
z.string.de.preferencesAboutTermsOfUse = 'Nutzungsbedingungen';
z.string.de.preferencesAboutVersion = 'Version {{version}}';
z.string.de.preferencesAboutWebsite = 'Wire-Webseite';

z.string.de.preferencesAccountAvaibilityUnset = 'Whle einen Status';
z.string.de.preferencesAccountCreateTeam = 'Team erstellen';
z.string.de.preferencesAccountData = 'Datennutzung';
z.string.de.preferencesAccountDataCheckbox = 'Anonyme Nutzungsdaten senden';
z.string.de.preferencesAccountDataDetail = 'Anonymisierte Nutzungs- und Fehlerberichte schicken, um Wire zu verbessern.';
z.string.de.preferencesAccountDelete = 'Benutzerkonto lschen';
z.string.de.preferencesAccountLeaveGuestRoom = 'Gstebereich verlassen';
z.string.de.preferencesAccountLeaveGuestRoomDescription = 'Du wirst nicht lnger auf die Nachrichten dieser Unterhaltung zugreifen knnen.';
z.string.de.preferencesAccountLogOut = 'Abmelden';
z.string.de.preferencesAccountManageTeam = 'Team verwalten';
z.string.de.preferencesAccountMarketingConsentCheckbox = 'Newsletter abonnieren';
z.string.de.preferencesAccountMarketingConsentDetail = 'Neuigkeiten und Informationen zu Produktaktualisierungen von Wire per E-Mail erhalten.';
z.string.de.preferencesAccountResetPassword = 'Passwort zurcksetzen';
z.string.de.preferencesAccountTeam = 'in {{name}}';
z.string.de.preferencesAccountUsernamePlaceholder = 'Dein vollstndiger Name';
z.string.de.preferencesAccountUsernameHint = 'Mindestens zwei Zeichen. az, 09, und _.';
z.string.de.preferencesAccountUsernameAvailable = 'Verfgbar';
z.string.de.preferencesAccountUsernameErrorTaken = 'Bereits vergeben';

z.string.de.preferencesAVCamera = 'Kamera';
z.string.de.preferencesAVMicrophone = 'Mikrofon';
z.string.de.preferencesAVPermissionDetail = 'In deinen Browser-Einstellungen aktivieren';
z.string.de.preferencesAVSpeakers = 'Lautsprecher';
z.string.de.preferencesAVTemporaryDisclaimer = 'Gste knnen Videokonferenzen nicht selbst starten. Whle die Kamera aus, die bei der Teilnahme verwendet werden soll.';
z.string.de.preferencesAVNoCamera = 'Wire hat keinen Zugriff auf die Kamera.[br][faqLink]Zur Behebung bitte diesen Support Artikel anschauen[/faqLink].';
z.string.de.preferencesAVTryAgain = 'Erneut versuchen';

z.string.de.preferencesDevicesActivatedOn = 'Aktiviert {{date}}';
z.string.de.preferencesDevicesActive = 'Aktiv';
z.string.de.preferencesDevicesActiveDetail = 'Falls du eines dieser Gerte nicht erkennst, entferne es und setze dein Passwort zurck.';
z.string.de.preferencesDevicesCurrent = 'Dieses Gert';
z.string.de.preferencesDevicesFingerprint = 'Schlssel-Fingerabdruck';
z.string.de.preferencesDevicesFingerprintDetail = 'Wire gibt jedem Gert einen einzigartigen Fingerabdruck. Vergleiche diese und verifiziere deine Gerte und Unterhaltungen.';
z.string.de.preferencesDevicesId = 'ID: ';
z.string.de.preferencesDevicesRemove = 'Entfernen';
z.string.de.preferencesDevicesRemoveCancel = 'Abbrechen';
z.string.de.preferencesDevicesRemoveDetail = 'Entferne das Gert, wenn du es nicht mehr nutzt. Du wirst auf diesem Gert umgehend abgemeldet.';
z.string.de.preferencesDevicesSessionConfirmation = 'Die Session wurde zurckgesetzt.';
z.string.de.preferencesDevicesSessionDetail = 'Falls die Fingerabdrcke nicht bereinstimmen, setze die Session zurck um neue Verschlsselungs-Schlssel auf beiden Seiten zu erstellen.';
z.string.de.preferencesDevicesSessionReset = 'Session zurcksetzen';
z.string.de.preferencesDevicesSessionOngoing = 'Setze Session zurck';
z.string.de.preferencesDevicesVerification = 'Verifiziert';

z.string.de.preferencesOptionsAudio = 'Benachrichtigungstne';
z.string.de.preferencesOptionsAudioAll = 'Alle';
z.string.de.preferencesOptionsAudioAllDetail = 'Alle Tne';
z.string.de.preferencesOptionsAudioNone = 'Keine';
z.string.de.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.de.preferencesOptionsAudioSome = 'Einige';
z.string.de.preferencesOptionsAudioSomeDetail = 'Pings und Anrufe';
z.string.de.preferencesOptionsContacts = 'Kontakte';
z.string.de.preferencesOptionsContactsGmail = 'Aus Gmail importieren';
z.string.de.preferencesOptionsContactsMacos = 'Aus Kontakte importieren';
z.string.de.preferencesOptionsContactsDetail = 'Wir verwenden deine Daten, um Kontakte fr dich zu erstellen. Wir anonymisieren alle Informationen und teilen sie mit niemand anderem.';
z.string.de.preferencesOptionsPopular = 'Auf allgemeinen Wunsch';
z.string.de.preferencesOptionsEmojiReplaceCheckbox = 'Schrift-Emoticons mit Emojis ersetzen';
z.string.de.preferencesOptionsEmojiReplaceDetail = ':-)  [icon]';
z.string.de.preferencesOptionsPreviewsSendCheckbox = 'Vorschau beim Senden von Links erstellen';
z.string.de.preferencesOptionsPreviewsSendDetail = 'Vorschauen knnen weiterhin fr von anderen Personen gesendete Links angezeigt werden.';
z.string.de.preferencesOptionsNotifications = 'Benachrichtigungen';
z.string.de.preferencesOptionsNotificationsNone = 'Aus';
z.string.de.preferencesOptionsNotificationsObfuscate = 'Details verbergen';
z.string.de.preferencesOptionsNotificationsObfuscateMessage = 'Absendername zeigen';
z.string.de.preferencesOptionsNotificationsOn = 'Zeige Absendername und Nachricht';
z.string.de.preferencesOptionsCallLogs = 'Fehlerbehebung';
z.string.de.preferencesOptionsCallLogsGet = 'Anruf-Fehlerbericht speichern';
z.string.de.preferencesOptionsCallLogsDetail = 'Diese Informationen helfen uns, Probleme bei Anrufen zu diagnostizieren.';

z.string.de.preferencesOptionsBackupHeader = 'Gesprchsverlauf';
z.string.de.preferencesOptionsBackupExportHeadline = 'Unterhaltungen sichern';
z.string.de.preferencesOptionsBackupExportSecondary = 'Erstelle ein Backup, um den Gesprchsverlauf zu sichern. Damit knnen Unterhaltungen wiederhergestellt werden, falls du deinen Computer verlierst oder einen neuen nutzen mchtest.\n\nWhle ein sicheres Passwort, um die Backup-Datei zu schtzen.';
z.string.de.preferencesOptionsBackupImportHeadline = 'Backup wiederherstellen';
z.string.de.preferencesOptionsBackupImportSecondary = 'Es knnen nur Backup-Dateien derselben Plattform wiederhergestellt werden. Der Inhalt der Backup-Datei ersetzt den Gesprchsverlauf auf diesem Gert.';

z.string.de.backupExportGenericErrorHeadline = 'Datei nicht gespeichert';
z.string.de.backupExportGenericErrorSecondary = 'Das Backup wurde nicht abgeschlossen.';
z.string.de.backupExportProgressHeadline = 'Vorbereiten';
z.string.de.backupExportProgressSecondary = 'Erstelle Backup  {{processed}} von {{total}}  {{progress}}%';
z.string.de.backupExportProgressCompressing = 'Backup-Datei wird erstellt';
z.string.de.backupExportSaveFileAction = 'Backup speichern';
z.string.de.backupExportSuccessHeadline = 'Backup erstellt';
z.string.de.backupExportSuccessSecondary = 'Mit diesem Backup kann der Gesprchsverlauf wiederhergestellt werden, wenn du dein Gert verlierst oder zu einem neuen wechselst.';
z.string.de.backupImportGenericErrorHeadline = 'Fehler aufgetreten';
z.string.de.backupImportGenericErrorSecondary = 'Der Gesprchsverlauf konnte nicht wiederhergestellt werden.';
z.string.de.backupImportAccountErrorHeadline = 'Falsches Backup';
z.string.de.backupImportAccountErrorSecondary = 'Der Gesprchsverlauf eines anderen Kontos kann nicht wiederhergestellt werden.';
z.string.de.backupImportVersionErrorHeadline = 'Inkompatibles Backup';
z.string.de.backupImportVersionErrorSecondary = 'Diese Backup-Datei wurde von einer anderen Version von Wire erstellt und kann deshalb nicht wiederhergestellt werden.';
z.string.de.backupImportIncompatibleErrorHeadline = 'Falsches Backup';
z.string.de.backupImportIncompatibleErrorSecondary = 'Der Gesprchsverlauf eines anderen Benutzerkontos kann nicht wiederhergestellt werden.';
z.string.de.backupImportOutdatedErrorHeadline = 'Inkompatibles Backup';
z.string.de.backupImportOutdatedErrorSecondary = 'Diese Backup-Datei wurde von einer anderen Version von Wire erstellt und kann deshalb nicht wiederhergestellt werden.';
z.string.de.backupImportProgressHeadline = 'Vorbereiten';
z.string.de.backupImportProgressSecondary = 'Stelle Gesprchsverlauf wieder her  {{processed}} von {{total}}  {{progress}}%';
z.string.de.backupImportSuccessHeadline = 'Gesprchsverlauf wiederhergestellt.';
z.string.de.backupCancel = 'Abbrechen';
z.string.de.backupTryAgain = 'Erneut versuchen';

z.string.de.searchConnect = 'Vorschlge';
z.string.de.searchConnections = 'Kontakte';
z.string.de.searchContacts = 'Kontakte';
z.string.de.searchCreateGroup = 'Gruppe erstellen';
z.string.de.searchCreateGuestRoom = 'Gstebereich erstellen';
z.string.de.searchGroups = 'Gruppen';
z.string.de.searchPeople = 'Kontakte';
z.string.de.searchPlaceholder = 'Name oder Benutzername suchen';
z.string.de.searchServicePlaceholder = 'Nach Namen suchen';
z.string.de.searchServices = 'Dienste';
z.string.de.searchManageServices = 'Dienste verwalten';
z.string.de.searchManageServicesNoResults = 'Dienste verwalten';
z.string.de.searchNoServicesManager = 'Dienste sind Helfer, die den Workflow verbessern knnen.';
z.string.de.searchNoServicesMember = 'Dienste sind Helfer, die den Workflow verbessern knnen. Bitte an den Administrator wenden, um diese fr das Team zu aktivieren.';
z.string.de.searchTeamGroups = 'Team-Gruppen';
z.string.de.searchTeamMembers = 'Team-Mitglieder';
z.string.de.searchTopPeople = 'Top Kontakte';
z.string.de.searchTrySearch = 'Finde Kontakte anhand ihres\nNamens oder Benutzernamens';
z.string.de.searchNoContactsOnWire = 'Du hast keine Kontakte auf Wire.\nSuche nach Namen\noder Benutzernamen.';
z.string.de.searchMemberInvite = 'Lade weitere Mitglieder ein';
z.string.de.searchOthers = 'Suchergebnisse';

z.string.de.searchInvite = 'Lade Freunde zu Wire ein';
z.string.de.searchInviteDetail = 'Wir verwenden deine Kontaktdaten, um Kontakte fr dich zu erstellen. Wir anonymisieren alle Informationen und geben sie nicht weiter.';
z.string.de.searchInviteButtonContacts = 'Aus Kontakte';
z.string.de.searchInviteButtonGmail = 'Aus Gmail';
z.string.de.searchInviteHeadline = 'Hole deine Freunde';
z.string.de.searchInviteShare = 'Teile deine Kontakte';

z.string.de.searchServiceConfirmButton = 'Unterhaltung ffnen';

z.string.de.searchListEveryoneParticipates = 'Alle deine Kontakte\nsind bereits in\ndieser Unterhaltung.';
z.string.de.searchListNoMatches = 'Kein passendes Ergebnis.\nSuche nach einen\nanderen Namen.';

z.string.de.temporaryGuestCta = 'Erstelle ein Benutzerkonto';
z.string.de.temporaryGuestDescription = 'Fr sichere Unternehmen mit verschlsselter Kommunikation in Gruppen und Telefonkonferenzen.';
z.string.de.temporaryGuestTimeRemaining = ' verbleibend in diesem Gstebereich';

z.string.de.temporaryGuestJoinMessage = 'Diese Unterhaltung steht fr dich 24 Stunden lang zur Verfgung.';
z.string.de.temporaryGuestJoinDescription = 'Wenn du diese Seite schliet oder neu ldst, verlierst du den Zugriff.';

z.string.de.temporaryGuestLeaveMessage = ' bist nicht lnger Teil dieser Unterhaltung.';
z.string.de.temporaryGuestLeaveDescription = 'Wenn du diese Seite schliet oder neu ldst, verlierst du den Zugriff auf den Unterhaltungsverlauf.';

z.string.de.uploadGoogleHeadline = 'Finde Kontakte \nauf Wire.';
z.string.de.uploadGoogleMessage = 'Wir verwenden deine Daten, um Kontakte fr dich zu erstellen. Wir anonymisieren alle Informationen und teilen sie mit niemand anderem.';

z.string.de.urlSupportRoot = '/hc/de/';
z.string.de.urlSupportArticles = '/hc/de/articles/';
z.string.de.urlSupportRequests = '/hc/de/requests/';
z.string.de.urlWebappRoot = '/?hl=de';
z.string.de.urlWebsiteRoot = '/de/';
z.string.de.urlWebsiteCreateTeam = '/de/create-team/';
z.string.de.urlWebsitePrivacy = '/de/privacy/';
z.string.de.warningCallUnsupportedIncoming = '{{user}} ruft an. Dein Browser untersttzt keine Anrufe.';
z.string.de.warningCallUnsupportedOutgoing = 'Du kannst nicht anrufen, da dein Browser keine Anfrufe untersttzt.';
z.string.de.warningCallIssues = 'Diese Version von Wire kann nicht an Anrufen teilnehmen. Nutze';
z.string.de.warningCallUpgradeBrowser = 'Fr Anrufe aktualisiere Google Chrome.';
z.string.de.warningConnectivityConnectionLost = 'Verbindung wird wiederhergestellt. Wire kann Nachrichten mglicherweise nicht empfangen.';
z.string.de.warningConnectivityNoInternet = 'Keine Internetverbindung. Du kannst keine Nachrichten senden und empfangen.';
z.string.de.warningLearnMore = 'Erfahre mehr';
z.string.de.warningLifecycleUpdate = 'Eine neue Version von Wire ist verfgbar.';
z.string.de.warningLifecycleUpdateNotes = 'Was ist neu';
z.string.de.warningLifecycleUpdateLink = 'Jetzt aktualisieren';
z.string.de.warningNotFoundCamera = 'Du kannst nicht anrufen, da dein Computer keine Kamera hat.';
z.string.de.warningNotFoundMicrophone = 'Du kannst nicht anrufen, da dein Computer kein Mikrofon hat.';
z.string.de.warningPermissionDeniedCamera = 'Du kannst nicht anrufen, da dein Browser keinen Zugriff auf die Kamera hat.';
z.string.de.warningPermissionDeniedMicrophone = 'Du kannst nicht anrufen, da dein Browser keinen Zugriff auf das Mikrofon hat.';
z.string.de.warningPermissionDeniedScreen = 'Der Browser braucht die Berechtigung zur Bildschirmfreigabe.';
z.string.de.warningPermissionRequestCamera = '[icon] Zugriff auf Kamera gewhren';
z.string.de.warningPermissionRequestMicrophone = '[icon] Zugriff auf Mikrofon gewhren';
z.string.de.warningPermissionRequestNotification = '[icon] Benachrichtigungen zulassen';
z.string.de.warningPermissionRequestScreen = '[icon] Zugriff auf Bildschirm gewhren';

z.string.de.userAvailabilityAvailable = 'Verfgbar';
z.string.de.userAvailabilityAway = 'Abwesend';
z.string.de.userAvailabilityBusy = 'Beschftigt';
z.string.de.userAvailabilityNone = 'Keine';

z.string.de.notificationAssetAdd = 'Hat ein Bild geteilt';
z.string.de.notificationConnectionAccepted = 'Hat deine Kontaktanfrage akzeptiert';
z.string.de.notificationConnectionConnected = 'Ist jetzt ein Kontakt von dir';
z.string.de.notificationConnectionRequest = 'Mchte dich als Kontakt hinzufgen';
z.string.de.notificationConversationCreate = '{{user}} hat eine Unterhaltung begonnen';
z.string.de.notificationConversationMessageTimerUpdate = '{{user}} hat temporre Nachrichten auf {{time}} gestellt';
z.string.de.notificationConversationMessageTimerReset = '{{user}} hat temporre Nachrichten ausgeschaltet';
z.string.de.notificationConversationRename = '{{user}} hat die Unterhaltung in {{name}} umbenannt';
z.string.de.notificationMemberJoinMany = '{{user}} hat {{number}} Kontakte zur Unterhaltung hinzugefgt';
z.string.de.notificationMemberJoinSelf = '{{user}} ist der Unterhaltung beigetreten';
z.string.de.notificationMemberJoinOne = '{{user1}} hat {{user2}} zur Unterhaltung hinzugefgt';
z.string.de.notificationMemberLeaveRemovedYou = '{{user}} hat dich aus der Unterhaltung entfernt';
z.string.de.notificationMention = 'Erwhnung: {{text}}';
z.string.de.notificationObfuscated = 'Hat eine Nachricht gesendet';
z.string.de.notificationObfuscatedMention = 'Hat dich erwhnt';
z.string.de.notificationObfuscatedReply = 'Hat dir geantwortet';
z.string.de.notificationObfuscatedTitle = 'Jemand';
z.string.de.notificationPing = 'Hat gepingt';
z.string.de.notificationReaction = '{{reaction}} deine Nachricht';
z.string.de.notificationReply = 'Antwort: {{text}}';
z.string.de.notificationSharedAudio = 'Hat eine Audio-Nachricht geteilt';
z.string.de.notificationSharedFile = 'Hat eine Datei geteilt';
z.string.de.notificationSharedLocation = 'Hat einen Standort geteilt';
z.string.de.notificationSharedVideo = 'Hat ein Video geteilt';
z.string.de.notificationTitleGroup = '{{user}} in {{conversation}}';
z.string.de.notificationVoiceChannelActivate = 'Ruft an';
z.string.de.notificationVoiceChannelDeactivate = 'Hat versucht anzurufen';

z.string.de.tooltipConversationAllVerified = 'Alle Fingerabdrcke sind berprft';
z.string.de.tooltipConversationCall = 'Anruf';
z.string.de.tooltipConversationEphemeral = 'Temporre Nachricht';
z.string.de.tooltipConversationFile = 'Datei senden';
z.string.de.tooltipConversationInputPlaceholder = 'Schreibe eine Nachricht';
z.string.de.tooltipConversationInputPlaceholderAvailable = '{{user}} ist verfgbar';
z.string.de.tooltipConversationInputPlaceholderAway = '{{user}} ist abwesend';
z.string.de.tooltipConversationInputPlaceholderBusy = '{{user}} ist beschftigt';
z.string.de.tooltipConversationPeople = 'Unterhaltungsbersicht ({{shortcut}})';
z.string.de.tooltipConversationPicture = 'Bild senden';
z.string.de.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.de.tooltipConversationSearch = 'Suche';
z.string.de.tooltipConversationVideoCall = 'Videoanruf';

z.string.de.tooltipConversationsArchive = 'Archivieren ({{shortcut}})';
z.string.de.tooltipConversationsArchived = 'Archiv anzeigen ({{number}})';
z.string.de.tooltipConversationsMore = 'Mehr';
z.string.de.tooltipConversationsNotifications = 'Benachrichtigungseinstellungen ffnen ({{shortcut}})';
z.string.de.tooltipConversationsNotify = 'Benachrichtigen ({{shortcut}})';
z.string.de.tooltipConversationsPreferences = 'Einstellungen ffnen';
z.string.de.tooltipConversationsSilence = 'Stummschalten ({{shortcut}})';
z.string.de.tooltipConversationsStart = 'Unterhaltung beginnen ({{shortcut}})';

z.string.de.tooltipConversationDetailsAddPeople = 'Teilnehmer zur Unterhaltung hinzufgen ({{shortcut}})';
z.string.de.tooltipConversationDetailsRename = 'Unterhaltung umbenennen';

z.string.de.tooltipPreferencesContactsGmail = 'Melde dich an deinem Gmail-Konto an, um deine Kontakte zu teilen';
z.string.de.tooltipPreferencesContactsMacos = 'Teile alle deine Kontakte aus der macOS Kontakte-App';
z.string.de.tooltipPreferencesPassword = 'ffne eine andere Website, um dein Passwort zurckzusetzen';
z.string.de.tooltipPreferencesPicture = 'ndere dein Bild';
z.string.de.tooltipPreferencesRename = 'ndere deinen Namen';

z.string.de.tooltipSearchClose = 'Schlieen (Esc)';

z.string.de.initReceivedSelfUser = 'Hallo, {{user}}.';
z.string.de.initValidatedClient = 'Lade deine Kontakte und Unterhaltungen';
z.string.de.initReceivedUserData = 'Suche nach neuen Events';
z.string.de.initDecryption = 'Entschlssele Events';
z.string.de.initEvents = 'Lade Nachrichten';
z.string.de.initUpdatedFromNotifications = 'Fast fertig - viel Spa mit Wire';
z.string.de.initProgress = '  {{number1}} von {{number2}}';

z.string.de.ephemeralUnitsNone = 'Aus';
z.string.de.ephemeralUnitsSecond = 'Sekunde';
z.string.de.ephemeralUnitsSeconds = 'Sekunden';
z.string.de.ephemeralUnitsMinute = 'Minute';
z.string.de.ephemeralUnitsMinutes = 'Minuten';
z.string.de.ephemeralUnitsHour = 'Stunde';
z.string.de.ephemeralUnitsHours = 'Stunden';
z.string.de.ephemeralUnitsDay = 'Tag';
z.string.de.ephemeralUnitsDays = 'Tage';
z.string.de.ephemeralUnitsWeek = 'Woche';
z.string.de.ephemeralUnitsWeeks = 'Wochen';
z.string.de.ephemeralUnitsYear = 'Jahr';
z.string.de.ephemeralUnitsYears = 'Jahre';
z.string.de.ephemeralRemaining = 'verbleibend';

z.string.de.replyAudioMessage = 'Audionachricht';
z.string.de.replyQuoteError = 'Diese Nachricht ist nicht sichtbar.';
z.string.de.replyQuoteShowMore = 'Mehr anzeigen';
z.string.de.replyQuoteShowLess = 'Weniger anzeigen';
z.string.de.replyQuoteTimeStampDate = 'Ursprngliche Nachricht vom {{date}}';
z.string.de.replyQuoteTimeStampTime = 'Ursprngliche Nachricht von {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.el.wireMacos = 'Wire  macOS';
z.string.el.wireWindows = 'Wire  Windows';
z.string.el.wireLinux = 'Wire  Linux';
z.string.el.nonexistentUser = ' ';
z.string.el.and = '';
z.string.el.enumerationAnd = ',  ';

z.string.el.authAccountCountryCode = ' ';
z.string.el.authAccountPasswordForgot = '   ';
z.string.el.authAccountPublicComputer = '    ';
z.string.el.authAccountSignIn = '';
z.string.el.authAccountSignInPhone = '';

z.string.el.authBlockedCookies = '  cookies     Wire.';
z.string.el.authBlockedDatabase = ' Wire            .         .';
z.string.el.authBlockedTabs = ' Wire      .';

z.string.el.authVerifyAccountAdd = '';
z.string.el.authVerifyAccountDetail = '      Wire   .';
z.string.el.authVerifyAccountHeadline = ' email   .';
z.string.el.authVerifyAccountLogout = '';
z.string.el.authVerifyCodeDescription = '       {{number}}.';
z.string.el.authVerifyCodeResend = '   ;';
z.string.el.authVerifyCodeResendDetail = '';
z.string.el.authVerifyCodeResendTimer = '     {{expiration}}.';
z.string.el.authVerifyCodeChangePhone = '  ';
z.string.el.authVerifyPasswordHeadline = '   ';

z.string.el.authLimitDevicesHeadline = '';
z.string.el.authLimitDescription = '             Wire  .';
z.string.el.authLimitButtonManage = ' ';
z.string.el.authLimitButtonSignOut = '';
z.string.el.authLimitDevicesCurrent = '()';

z.string.el.authHistoryHeadline = '       Wire    .';
z.string.el.authHistoryDescription = '  ,        .';
z.string.el.authHistoryReuseHeadline = '    Wire    .';
z.string.el.authHistoryReuseDescription = '           .';
z.string.el.authHistoryButton = '';

z.string.el.authPostedResend = '  {{email}}';
z.string.el.authPostedResendAction = '   email;';
z.string.el.authPostedResendDetail = '  email        .';
z.string.el.authPostedResendHeadline = ' .';

z.string.el.authPlaceholderEmail = 'Email';
z.string.el.authPlaceholderPasswordPut = ' ';
z.string.el.authPlaceholderPasswordSet = '  (  8 )';
z.string.el.authPlaceholderPhone = '  ';

z.string.el.authErrorCode = '  ';
z.string.el.authErrorCountryCodeInvalid = '   ';
z.string.el.authErrorEmailExists = '  .   ';
z.string.el.authErrorEmailForbidden = '.    email  .';
z.string.el.authErrorEmailMalformed = '     email.';
z.string.el.authErrorEmailMissing = '    email.';
z.string.el.authErrorMisc = ' .   .';
z.string.el.authErrorNameShort = '     2 ';
z.string.el.authErrorOffline = '    ';
z.string.el.authErrorPasswordShort = '      8 .';
z.string.el.authErrorPasswordWrong = ' .   .';
z.string.el.authErrorPhoneNumberBudget = '   .   .';
z.string.el.authErrorPhoneNumberForbidden = '.       .';
z.string.el.authErrorPhoneNumberInvalid = '   ';
z.string.el.authErrorPhoneNumberUnknown = '  ';
z.string.el.authErrorSuspended = '        .';
z.string.el.authErrorSignIn = '       .';

z.string.el.callStateOutgoing = '';
z.string.el.callStateConnecting = '';
z.string.el.callStateIncoming = '';
z.string.el.callDecline = '';
z.string.el.callAccept = '';
z.string.el.callJoin = '';
z.string.el.callChooseSharedScreen = '     ';
z.string.el.callParticipants = '{{number}}  ';

z.string.el.videoCallOverlayMute = '';
z.string.el.videoCallOverlayHangUp = ' ';

z.string.el.modalAcknowledgeAction = '';
z.string.el.modalAcknowledgeHeadline = '  ';
z.string.el.modalConfirmSecondary = '';
z.string.el.modalOptionSecondary = '';

z.string.el.modalAccountCreateAction = '';
z.string.el.modalAccountCreateHeadline = ' ;';

z.string.el.modalAccountDeletionAction = '';
z.string.el.modalAccountDeletionHeadline = ' ';
z.string.el.modalAccountDeletionMessage = '      email  SMS.            .';

z.string.el.modalAccountLeaveGuestRoomAction = '';

z.string.el.modalAccountLogoutAction = '';
z.string.el.modalAccountLogoutHeadline = ' ;';
z.string.el.modalAccountLogoutOption = '           .';

z.string.el.modalAccountNewDevicesSecondary = ' ';
z.string.el.modalAccountNewDevicesHeadline = '    :';
z.string.el.modalAccountNewDevicesFrom = ':';
z.string.el.modalAccountNewDevicesMessage = '    ,        .';

z.string.el.modalAccountRemoveDeviceAction = ' ';
z.string.el.modalAccountRemoveDeviceHeadline = ' "{{device}}"';
z.string.el.modalAccountRemoveDeviceMessage = '         .';
z.string.el.modalAccountRemoveDevicePlaceholder = ' ';

z.string.el.modalAssetTooLargeHeadline = '    ';
z.string.el.modalAssetTooLargeMessage = '     {{number}}';

z.string.el.modalAssetParallelUploadsHeadline = '   ';
z.string.el.modalAssetParallelUploadsMessage = '     {{number}}  .';

z.string.el.modalCallEmptyConversationHeadline = '  ';
z.string.el.modalCallEmptyConversationMessage = '   .';

z.string.el.modalCallNoGroupVideoHeadline = '   ';
z.string.el.modalCallNoGroupVideoMessage = '       .';

z.string.el.modalCallNoMicrophoneAction = '  ';
z.string.el.modalCallNoMicrophoneMessage = '           .';
z.string.el.modalCallNoMicrophoneHeadline = '    ';

z.string.el.modalCallSecondIncomingAction = '';
z.string.el.modalCallSecondIncomingHeadline = ' ;';
z.string.el.modalCallSecondIncomingMessage = '     .';

z.string.el.modalCallSecondOngoingAction = ' ';
z.string.el.modalCallSecondOngoingHeadline = '    ;';
z.string.el.modalCallSecondOngoingMessage = '       .';

z.string.el.modalCallSecondOutgoingAction = ' ';
z.string.el.modalCallSecondOutgoingHeadline = '  ;';
z.string.el.modalCallSecondOutgoingMessage = '       .';

z.string.el.modalConnectCancelAction = '';
z.string.el.modalConnectCancelHeadline = ' ;';
z.string.el.modalConnectCancelMessage = '    {{user}}.';
z.string.el.modalConnectCancelSecondary = '';

z.string.el.modalConnectAcceptAction = '';
z.string.el.modalConnectAcceptHeadline = ';';
z.string.el.modalConnectAcceptMessage = '         {{user}}.';
z.string.el.modalConnectAcceptSecondary = '';

z.string.el.modalConversationClearAction = '';
z.string.el.modalConversationClearHeadline = ' ;';
z.string.el.modalConversationClearOption = '     ';

z.string.el.modalConversationDeleteMessageAction = '';
z.string.el.modalConversationDeleteMessageHeadline = '   ;';
z.string.el.modalConversationDeleteMessageMessage = '      .';

z.string.el.modalConversationDeleteMessageEveryoneAction = '';
z.string.el.modalConversationDeleteMessageEveryoneHeadline = '  ;';
z.string.el.modalConversationDeleteMessageEveryoneMessage = '      .';

z.string.el.modalConversationLeaveAction = '';
z.string.el.modalConversationLeaveMessage = '            .';

z.string.el.modalConversationMessageTooLongHeadline = ' ';
z.string.el.modalConversationMessageTooLongMessage = '     {{number}} .';

z.string.el.modalConversationNewDeviceAction = '   ';
z.string.el.modalConversationNewDeviceHeadlineOne = '{{user}}      ';
z.string.el.modalConversationNewDeviceHeadlineMany = '{{users}}     ';
z.string.el.modalConversationNewDeviceHeadlineYou = '{{user}}      ';
z.string.el.modalConversationNewDeviceIncomingCallAction = ' ';
z.string.el.modalConversationNewDeviceIncomingCallMessage = '       ;';
z.string.el.modalConversationNewDeviceMessage = '     ;';
z.string.el.modalConversationNewDeviceOutgoingCallAction = '   ';
z.string.el.modalConversationNewDeviceOutgoingCallMessage = '       ;';

z.string.el.modalConversationNotConnectedMessageOne = '{{name}}      .';
z.string.el.modalConversationNotConnectedMessageMany = '           .';

z.string.el.modalConversationRemoveAction = '';
z.string.el.modalConversationRemoveHeadline = ';';
z.string.el.modalConversationRemoveMessage = '{{user}}             .';

z.string.el.modalConversationRemoveGuestsAction = '  ';

z.string.el.modalConversationRevokeLinkAction = ' ';

z.string.el.modalConversationTooManyMembersHeadline = 'Full house';

z.string.el.modalIntegrationUnavailableHeadline = '   ';

z.string.el.modalPictureFileFormatMessage = '    PNG  JPEG.';

z.string.el.modalImproveWireAction = '';
z.string.el.modalImproveWireSecondary = '';

z.string.el.modalSessionResetHeadline = '     ';
z.string.el.modalSessionResetMessage1 = '    ,';
z.string.el.modalSessionResetMessageLink = '';
z.string.el.modalSessionResetMessage2 = '.';

z.string.el.modalUploadContactsAction = ' ';
z.string.el.modalUploadContactsMessage = '   .        .';

z.string.el.modalUserBlockAction = '';
z.string.el.modalUserBlockHeadline = ' {{user}};';
z.string.el.modalUserBlockMessage = '{{user}}              .';

z.string.el.modalUserUnblockAction = ' ';
z.string.el.modalUserUnblockHeadline = ' ';
z.string.el.modalUserUnblockMessage = '{{user}}              .';

z.string.el.connectionRequestConnect = '';
z.string.el.connectionRequestIgnore = '';

z.string.el.conversationGuestIndicator = '';

z.string.el.conversationYouNominative = '';
z.string.el.conversationYouDative = '';
z.string.el.conversationYouAccusative = '';

z.string.el.conversationConnectionAccepted = '';
z.string.el.conversationConnectionBlocked = '';
z.string.el.conversationConnectionCancelRequest = '  ';
z.string.el.conversationDeviceStartedUsingOne = ' ';
z.string.el.conversationDeviceStartedUsingMany = ' ';
z.string.el.conversationDeviceUnverified = '      ';
z.string.el.conversationDeviceYourDevices = '  ';
z.string.el.conversationDeviceUserDevices = ' {{user}} ';
z.string.el.conversationDeviceNewDeviceOne = '  ';
z.string.el.conversationDeviceNewDeviceMany = '  ';
z.string.el.conversationDeviceNewPeopleJoinedVerify = ' ';
z.string.el.conversationJustNow = ' ';
z.string.el.conversationLocationLink = ' ';
z.string.el.conversationMessageDelivered = '';
z.string.el.conversationRename = '   ';
z.string.el.conversationRenameYou = '   ';
z.string.el.conversationResume = '    {{users}}';
z.string.el.conversationPing = ' ';
z.string.el.conversationPingYou = ' ';
z.string.el.conversationToday = '';
z.string.el.conversationVoiceChannelDeactivate = ' ';
z.string.el.conversationVoiceChannelDeactivateYou = ' ';
z.string.el.conversationYesterday = '';
z.string.el.conversationUnableToDecrypt1 = '    {{user}}  .';
z.string.el.conversationUnableToDecrypt2 = '{{user}}    .  .';
z.string.el.conversationUnableToDecryptLink = ';';
z.string.el.conversationUnableToDecryptErrorMessage = '';
z.string.el.conversationUnableToDecryptResetSession = '  ';
z.string.el.conversationMissedMessages = '         .       .';
z.string.el.conversationAssetDownloading = ' ';
z.string.el.conversationAssetUploadFailed = '  ';
z.string.el.conversationPlaybackError = '  ';
z.string.el.conversationContextMenuCopy = '';
z.string.el.conversationContextMenuEdit = 'E';
z.string.el.conversationContextMenuDelete = '  ';
z.string.el.conversationContextMenuDeleteEveryone = '  ';
z.string.el.conversationContextMenuDownload = '';
z.string.el.conversationContextMenuLike = ' ';
z.string.el.conversationContextMenuUnlike = '  ';
z.string.el.conversationDeleteTimestamp = '  {{date}}';
z.string.el.conversationEditTimestamp = '  {{date}}';
z.string.el.conversationLikesCaption = '{{number}} ';
z.string.el.conversationSendPastedFile = '   {{date}}';
z.string.el.conversationSomeone = '';
z.string.el.conversationTweetAuthor = '  Twitter';

z.string.el.groupCreationPreferencesAction = '';
z.string.el.groupCreationPreferencesHeader = ' ';
z.string.el.groupCreationPreferencesPlaceholder = ' ';
z.string.el.groupCreationParticipantsActionCreate = '';
z.string.el.groupCreationParticipantsActionSkip = '';
z.string.el.groupCreationParticipantsHeader = ' ';
z.string.el.groupCreationParticipantsHeaderWithCounter = '  ({{number}})';
z.string.el.groupCreationParticipantsPlaceholder = '  ';

z.string.el.guestRoomConversationName = ' ';

z.string.el.guestRoomConversationButton = ' ';

z.string.el.collectionShowAll = '  {{number}}';
z.string.el.collectionSectionLinks = '';
z.string.el.collectionSectionImages = '';
z.string.el.collectionSectionFiles = '';
z.string.el.collectionSectionAudio = ' ';

z.string.el.fullsearchPlaceholder = '  ';
z.string.el.fullsearchNoResults = ' .';

z.string.el.archiveHeader = '';

z.string.el.conversationsAllArchived = '  ';
z.string.el.conversationsContacts = '';
z.string.el.conversationsConnectionRequestMany = '{{number}}   ';
z.string.el.conversationsConnectionRequestOne = '1   ';
z.string.el.conversationsEmptyConversation = ' ';
z.string.el.conversationsNoConversations = '   ';
z.string.el.conversationsPopoverArchive = '';
z.string.el.conversationsPopoverCancel = ' ';
z.string.el.conversationsPopoverClear = ' ';
z.string.el.conversationsPopoverNotify = ' ';
z.string.el.conversationsPopoverSilence = '';
z.string.el.conversationsPopoverUnarchive = ' ';

z.string.el.conversationsSecondaryLineEphemeralMessage = '   ';
z.string.el.conversationsSecondaryLinePeopleLeft = '{{number}}  ';
z.string.el.conversationsSecondaryLinePersonLeft = '{{user}} ';
z.string.el.conversationsSecondaryLinePersonRemoved = '{{user}} ';
z.string.el.conversationsSecondaryLinePeopleAdded = '{{user}}  ';
z.string.el.conversationsSecondaryLinePersonAdded = '{{user}} ';
z.string.el.conversationsSecondaryLinePersonAddedYou = '{{user}}  ';
z.string.el.conversationsSecondaryLineRenamed = '{{user}}   ';
z.string.el.conversationsSecondaryLineYouLeft = '';
z.string.el.conversationsSecondaryLineYouWereRemoved = ' ';

z.string.el.takeoverSub = '      Wire.';
z.string.el.takeoverLink = ' ';
z.string.el.takeoverButtonChoose = '   ';
z.string.el.takeoverButtonKeep = ' ';

z.string.el.inviteMetaKeyMac = 'Cmd';
z.string.el.inviteMetaKeyPc = 'Ctrl';
z.string.el.inviteHeadline = '   Wire';
z.string.el.inviteMessage = '  Wire,   {{username}}     get.wire.com.';
z.string.el.inviteMessageNoEmail = '  Wire.   get.wire.com     .';

z.string.el.extensionsBubbleButtonGif = ' Gif';

z.string.el.extensionsGiphyButtonOk = '';
z.string.el.extensionsGiphyButtonMore = ' ';
z.string.el.extensionsGiphyMessage = '{{tag}}   giphy.com';
z.string.el.extensionsGiphyNoGifs = '!   gifs';
z.string.el.extensionsGiphyRandom = '';

z.string.el.addParticipantsConfirmLabel = '';
z.string.el.addParticipantsHeader = ' ';
z.string.el.addParticipantsHeaderWithCounter = '  ({{number}})';
z.string.el.addParticipantsSearchPlaceholder = '  ';
z.string.el.addParticipantsTabsPeople = '';
z.string.el.addParticipantsTabsServices = '';

z.string.el.conversationDetailsActionArchive = '';
z.string.el.conversationDetailsActionAddParticipants = ' ';
z.string.el.conversationDetailsActionBlock = ' ';
z.string.el.conversationDetailsActionCancelRequest = ' ';
z.string.el.conversationDetailsActionClear = ' ';
z.string.el.conversationDetailsActionCreateGroup = ' ';
z.string.el.conversationDetailsActionDevices = '';
z.string.el.conversationDetailsActionNotifications = '';
z.string.el.conversationDetailsGuestsOff = '';
z.string.el.conversationDetailsOptions = '';
z.string.el.conversationDetailsParticipantsServicesOne = '';
z.string.el.conversationDetailsParticipantsServicesMany = '';
z.string.el.conversationDetailsParticipantsUsersOne = '';
z.string.el.conversationDetailsParticipantsUsersMany = '';
z.string.el.conversationDetailsPeople = '';
z.string.el.conversationDetailsServices = '';

z.string.el.conversationParticipantsTitle = '';
z.string.el.conversationParticipantsSearchPlaceholder = '  ';

z.string.el.groupParticipantActionCancelRequest = ' ';
z.string.el.groupParticipantActionDevices = '';
z.string.el.groupParticipantActionPending = '';
z.string.el.groupParticipantActionSendRequest = '';

z.string.el.guestOptionsCopyLink = ' ';
z.string.el.guestOptionsCreateLink = ' ';
z.string.el.guestOptionsRevokeLink = ' ';

z.string.el.notificationSettingsTitle = '';

z.string.el.participantDevicesDetailHeadline = '          {{html1}} {{user}} {{html2}}.';
z.string.el.participantDevicesDetailHowTo = '    ;';
z.string.el.participantDevicesDetailResetSession = '  ';
z.string.el.participantDevicesDetailShowMyDevice = '    ';
z.string.el.participantDevicesDetailVerify = '';

z.string.el.participantDevicesHeader = '';
z.string.el.participantDevicesHeadline = ' Wire       .    {{user}}     .';
z.string.el.participantDevicesLearnMore = ' ';
z.string.el.participantDevicesWhyVerify = '    ;';
z.string.el.participantDevicesOutdatedClientMessage = '{{user}}      Wire.    .';

z.string.el.participantDevicesSelfAllDevices = '    ';
z.string.el.participantDevicesSelfFingerprint = ' ';

z.string.el.userProfileButtonConnect = '';
z.string.el.userProfileButtonIgnore = '';
z.string.el.userProfileButtonUnblock = ' ';

z.string.el.preferencesAbout = '';
z.string.el.preferencesAccount = '';
z.string.el.preferencesAV = ' / ';
z.string.el.preferencesDeviceDetails = ' ';
z.string.el.preferencesDevices = '';
z.string.el.preferencesHeadline = '';
z.string.el.preferencesOptions = '';

z.string.el.preferencesAboutPrivacyPolicy = ' ';
z.string.el.preferencesAboutSupport = '';
z.string.el.preferencesAboutSupportWebsite = ' ';
z.string.el.preferencesAboutSupportContact = '    ';
z.string.el.preferencesAboutTermsOfUse = ' ';
z.string.el.preferencesAboutVersion = ' {{version}}';
z.string.el.preferencesAboutWebsite = '   Wire';

z.string.el.preferencesAccountCreateTeam = '  ';
z.string.el.preferencesAccountDelete = ' ';
z.string.el.preferencesAccountLogOut = '';
z.string.el.preferencesAccountManageTeam = ' ';
z.string.el.preferencesAccountResetPassword = '  ';
z.string.el.preferencesAccountTeam = ' {{name}}';
z.string.el.preferencesAccountUsernamePlaceholder = '';
z.string.el.preferencesAccountUsernameHint = ' 2 . az, 09  _ .';
z.string.el.preferencesAccountUsernameAvailable = '';
z.string.el.preferencesAccountUsernameErrorTaken = ' ';

z.string.el.preferencesAVCamera = '';
z.string.el.preferencesAVMicrophone = '';
z.string.el.preferencesAVPermissionDetail = '      ';
z.string.el.preferencesAVSpeakers = '';

z.string.el.preferencesDevicesActivatedOn = '  {{date}}';
z.string.el.preferencesDevicesActive = '';
z.string.el.preferencesDevicesActiveDetail = '       ,       .';
z.string.el.preferencesDevicesCurrent = '';
z.string.el.preferencesDevicesFingerprint = ' ';
z.string.el.preferencesDevicesFingerprintDetail = ' Wire       .           .';
z.string.el.preferencesDevicesId = 'ID: ';
z.string.el.preferencesDevicesRemoveCancel = '';
z.string.el.preferencesDevicesRemoveDetail = '         .         .';
z.string.el.preferencesDevicesSessionConfirmation = '    .';
z.string.el.preferencesDevicesSessionDetail = '    ,              .';
z.string.el.preferencesDevicesSessionReset = '  ';
z.string.el.preferencesDevicesSessionOngoing = '   ';
z.string.el.preferencesDevicesVerification = '';

z.string.el.preferencesOptionsAudio = ' ';
z.string.el.preferencesOptionsAudioAll = '';
z.string.el.preferencesOptionsAudioAllDetail = '  ';
z.string.el.preferencesOptionsAudioNone = '';
z.string.el.preferencesOptionsAudioNoneDetail = '!';
z.string.el.preferencesOptionsAudioSome = '';
z.string.el.preferencesOptionsAudioSomeDetail = '  ';
z.string.el.preferencesOptionsContacts = '';
z.string.el.preferencesOptionsContactsGmail = '   Gmail';
z.string.el.preferencesOptionsContactsMacos = '   ';
z.string.el.preferencesOptionsContactsDetail = '        .             .';
z.string.el.preferencesOptionsPopular = '  ';
z.string.el.preferencesOptionsEmojiReplaceCheckbox = '  emoticons  emojis';
z.string.el.preferencesOptionsPreviewsSendCheckbox = '     ';
z.string.el.preferencesOptionsPreviewsSendDetail = '           .';
z.string.el.preferencesOptionsNotifications = '';
z.string.el.preferencesOptionsNotificationsNone = '';
z.string.el.preferencesOptionsNotificationsObfuscate = ' ';
z.string.el.preferencesOptionsNotificationsObfuscateMessage = ' ';
z.string.el.preferencesOptionsNotificationsOn = '   ';

z.string.el.backupImportGenericErrorHeadline = '  ';
z.string.el.backupCancel = '';

z.string.el.searchConnect = '';
z.string.el.searchConnections = '';
z.string.el.searchContacts = '';
z.string.el.searchCreateGroup = ' ';
z.string.el.searchGroups = '';
z.string.el.searchPeople = '';
z.string.el.searchPlaceholder = '  ';
z.string.el.searchServicePlaceholder = '  ';
z.string.el.searchServices = '';
z.string.el.searchTeamGroups = ' ';
z.string.el.searchTeamMembers = ' ';
z.string.el.searchTopPeople = ' ';
z.string.el.searchTrySearch = '      ';
z.string.el.searchNoContactsOnWire = '    Wire.            .';
z.string.el.searchOthers = '';

z.string.el.searchInvite = '     Wire';
z.string.el.searchInviteDetail = '             .            .';
z.string.el.searchInviteButtonContacts = '  ';
z.string.el.searchInviteButtonGmail = '  Gmail';
z.string.el.searchInviteHeadline = '    ';
z.string.el.searchInviteShare = '  ';

z.string.el.searchListEveryoneParticipates = '       .';
z.string.el.searchListNoMatches = '   .\n     .';

z.string.el.temporaryGuestCta = ' ';

z.string.el.uploadGoogleHeadline = '   .';
z.string.el.uploadGoogleMessage = '        .             .';

z.string.el.warningCallUnsupportedIncoming = '{{user}} .       .';
z.string.el.warningCallUnsupportedOutgoing = '   ,        .';
z.string.el.warningCallIssues = '    Wire      .  ';
z.string.el.warningCallUpgradeBrowser = '  ,    Google Chrome.';
z.string.el.warningConnectivityConnectionLost = '  .  Wire         .';
z.string.el.warningConnectivityNoInternet = ' .         .';
z.string.el.warningLearnMore = ' ';
z.string.el.warningLifecycleUpdate = '     Wire.';
z.string.el.warningLifecycleUpdateNotes = '  ';
z.string.el.warningLifecycleUpdateLink = ' ';
z.string.el.warningNotFoundCamera = '           .';
z.string.el.warningNotFoundMicrophone = '   ,       .';
z.string.el.warningPermissionDeniedCamera = '   ,          .';
z.string.el.warningPermissionDeniedMicrophone = '   ,          .';
z.string.el.warningPermissionDeniedScreen = '           .';
z.string.el.warningPermissionRequestCamera = '{{icon}}      ';
z.string.el.warningPermissionRequestMicrophone = '{{icon}}      ';
z.string.el.warningPermissionRequestNotification = '{{icon}}    ';
z.string.el.warningPermissionRequestScreen = '{{icon}}      ';

z.string.el.userAvailabilityAvailable = '';
z.string.el.userAvailabilityNone = '';

z.string.el.notificationAssetAdd = ' ';
z.string.el.notificationConnectionAccepted = '     ';
z.string.el.notificationConnectionConnected = ' ';
z.string.el.notificationConnectionRequest = '  ';
z.string.el.notificationConversationCreate = '{{user}}   ';
z.string.el.notificationConversationRename = '{{user}}     {{name}}';
z.string.el.notificationMemberJoinMany = '{{user}}  {{number}}   ';
z.string.el.notificationMemberJoinOne = '{{user1}}  {{user2}}  ';
z.string.el.notificationMemberLeaveRemovedYou = '{{user}}     ';
z.string.el.notificationObfuscated = '   ';
z.string.el.notificationObfuscatedTitle = '';
z.string.el.notificationPing = '';
z.string.el.notificationReaction = '{{reaction}}   ';
z.string.el.notificationSharedAudio = '  ';
z.string.el.notificationSharedFile = ' ';
z.string.el.notificationSharedLocation = '    ';
z.string.el.notificationSharedVideo = ' ';
z.string.el.notificationVoiceChannelActivate = '';
z.string.el.notificationVoiceChannelDeactivate = '';

z.string.el.tooltipConversationAllVerified = '   ';
z.string.el.tooltipConversationCall = '';
z.string.el.tooltipConversationEphemeral = ' ';
z.string.el.tooltipConversationFile = ' ';
z.string.el.tooltipConversationInputPlaceholder = ' ';
z.string.el.tooltipConversationPeople = ' ({{shortcut}})';
z.string.el.tooltipConversationPicture = ' ';
z.string.el.tooltipConversationPing = ' ({{shortcut}})';
z.string.el.tooltipConversationSearch = '';
z.string.el.tooltipConversationVideoCall = '';

z.string.el.tooltipConversationsArchive = ' ({{shortcut}})';
z.string.el.tooltipConversationsArchived = '  ({{number}})';
z.string.el.tooltipConversationsMore = '';
z.string.el.tooltipConversationsNotify = '  ({{shortcut}})';
z.string.el.tooltipConversationsPreferences = '  ';
z.string.el.tooltipConversationsSilence = ' ({{shortcut}})';
z.string.el.tooltipConversationsStart = '  ({{shortcut}})';

z.string.el.tooltipConversationDetailsRename = '   ';

z.string.el.tooltipPreferencesContactsGmail = '   Gmail      ';
z.string.el.tooltipPreferencesContactsMacos = '      macOS   ';
z.string.el.tooltipPreferencesPassword = '         ';
z.string.el.tooltipPreferencesPicture = ' ...';
z.string.el.tooltipPreferencesRename = '   ';

z.string.el.tooltipSearchClose = ' (Esc)';

z.string.el.initReceivedSelfUser = ' , {{user}}.';
z.string.el.initReceivedUserData = '   ';
z.string.el.initEvents = ' ';

z.string.el.ephemeralUnitsNone = '';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.es.wireMacos = 'Wire para macOS';
z.string.es.wireWindows = 'Wire para Windows';
z.string.es.wireLinux = 'Wire para Linux';
z.string.es.nonexistentUser = 'Usuario Borrado';
z.string.es.and = 'y';
z.string.es.enumerationAnd = ' y ';

z.string.es.authAccountCountryCode = 'Cdigo de Pas';
z.string.es.authAccountPasswordForgot = 'Contrasea Olvidada';
z.string.es.authAccountPublicComputer = 'Es un ordenador pblico';
z.string.es.authAccountSignIn = 'Iniciar sesin';
z.string.es.authAccountSignInPhone = 'Acceso con nmero de telfono';

z.string.es.authBlockedCookies = 'Habilita las cookies para iniciar sesin.';
z.string.es.authBlockedDatabase = 'Wire necesita acceso al almacenamiento local para mostrar los mensajes. No est disponible en modo privado.';
z.string.es.authBlockedTabs = 'Wire ya est abierto en otra pestaa.';
z.string.es.authBlockedTabsAction = 'Utilice esta pestaa en su lugar';

z.string.es.authVerifyAccountAdd = 'Agregar';
z.string.es.authVerifyAccountDetail = 'Esto le permite usar Wire en mltiples dispositivos.';
z.string.es.authVerifyAccountHeadline = 'Agregar direccin de correo electrnico y contrasea.';
z.string.es.authVerifyAccountLogout = 'Cerrar sesin';
z.string.es.authVerifyCodeDescription = 'Ingresa el cdigo de verificacin\nque hemos enviado a {{number}}.';
z.string.es.authVerifyCodeResend = 'No ha recibido ningn cdigo?';
z.string.es.authVerifyCodeResendDetail = 'Reenviar';
z.string.es.authVerifyCodeResendTimer = 'Puede solicitar un nuevo cdigo en {{expiration}}.';
z.string.es.authVerifyCodeChangePhone = 'Cambiar nmero de telfono';
z.string.es.authVerifyPasswordHeadline = 'Introduzca su contrasea';

z.string.es.authLimitDevicesHeadline = 'Dispositivos';
z.string.es.authLimitDescription = 'Quite uno de los dispositivos para comenzar a usar Wire en este dispositivo.';
z.string.es.authLimitButtonManage = 'Administrar dispositivos';
z.string.es.authLimitButtonSignOut = 'Cerrar sesin';
z.string.es.authLimitDevicesCurrent = '(Actual)';

z.string.es.authHistoryHeadline = 'Es la primera vez que usas Wire en este dispositivo.';
z.string.es.authHistoryDescription = 'Por motivos de privacidad, tu historial de conversacin no aparecer aqu.';
z.string.es.authHistoryReuseHeadline = 'Ya has utilizado Wire en este dispositivo antes.';
z.string.es.authHistoryReuseDescription = 'Los mensajes enviados mientras tanto no aparecern aqu.';
z.string.es.authHistoryButton = 'OK';

z.string.es.authPostedResend = 'Reenviar a {{email}}';
z.string.es.authPostedResendAction = 'No aparece ningn correo electrnico?';
z.string.es.authPostedResendDetail = 'Revise su buzn de correo electrnico y siga las instrucciones.';
z.string.es.authPostedResendHeadline = 'Tiene un correo electrnico.';

z.string.es.authPlaceholderEmail = 'Correo';
z.string.es.authPlaceholderPasswordPut = 'Contrasea';
z.string.es.authPlaceholderPasswordSet = 'Contrasea (mnimo 8 caracteres)';
z.string.es.authPlaceholderPhone = 'Nmero de telfono';

z.string.es.authErrorCode = 'Cdigo no vlido';
z.string.es.authErrorCountryCodeInvalid = 'Cdigo de pas no vlido';
z.string.es.authErrorEmailExists = 'Este correo electrnico ya est registrado';
z.string.es.authErrorEmailForbidden = 'Lo sentimos. Esta direccin de correo electrnico est prohibida.';
z.string.es.authErrorEmailMalformed = 'Por favor, introduce una direccin de correo electrnico vlida.';
z.string.es.authErrorEmailMissing = 'Por favor, introduce una direccin de correo electrnico.';
z.string.es.authErrorMisc = 'Problemas con la conexin. Por favor, intntelo de nuevo.';
z.string.es.authErrorNameShort = 'Introduce un nombre con al menos 2 caracteres';
z.string.es.authErrorOffline = 'No hay conexin a Internet';
z.string.es.authErrorPasswordShort = 'Elige una contrasea con al menos 8 caracteres.';
z.string.es.authErrorPasswordWrong = 'Contrasea incorrecta. Por favor, intntelo de nuevo.';
z.string.es.authErrorPending = 'La cuenta an no esta verificada';
z.string.es.authErrorPhoneNumberBudget = 'Has entrado muchas veces. Prueba ms tarde.';
z.string.es.authErrorPhoneNumberForbidden = 'Lo sentimos. Este nmero de telfono est prohibido.';
z.string.es.authErrorPhoneNumberInvalid = 'Nmero de telfono no vlido';
z.string.es.authErrorPhoneNumberUnknown = 'Nmero de Telfono Desconocido';
z.string.es.authErrorSuspended = 'Esta cuenta ya no est autorizada a iniciar sesin.';
z.string.es.authErrorSignIn = 'Por favor, verifica tus datos y vuelve a intentarlo.';

z.string.es.callStateOutgoing = 'Sonando';
z.string.es.callStateConnecting = 'Conectando';
z.string.es.callStateIncoming = 'Llamando';
z.string.es.callStateIncomingGroup = '{{user}} est llamando';
z.string.es.callDecline = 'Rechazar';
z.string.es.callAccept = 'Aceptar';
z.string.es.callJoin = 'Entrar';
z.string.es.callChooseSharedScreen = 'Elige una pantalla para compartir';
z.string.es.callParticipants = '{{number}} en la llamada';
z.string.es.callNoCameraAccess = 'Sin acceso a la cmara';

z.string.es.videoCallOverlayFitVideoLabel = 'Haga doble clic para ajustar o rellenar el video';
z.string.es.videoCallOverlayConversations = 'Conversaciones';
z.string.es.videoCallOverlayMute = 'Silenciar';
z.string.es.videoCallOverlayVideo = 'Video';
z.string.es.videoCallOverlayShareScreen = 'Compartir pantalla';
z.string.es.videoCallOverlayHangUp = 'Colgar';
z.string.es.videoCallPaused = 'Video pausado';
z.string.es.videoCallScreenShareNotSupported = 'Este navegador no permite compartir pantallas';

z.string.es.modalAcknowledgeAction = 'OK';
z.string.es.modalAcknowledgeHeadline = 'Algo sali mal';
z.string.es.modalConfirmSecondary = 'Cancelar';
z.string.es.modalOptionSecondary = 'Cancelar';

z.string.es.modalAccountCreateAction = 'OK';
z.string.es.modalAccountCreateHeadline = 'Crear una cuenta?';
z.string.es.modalAccountCreateMessage = 'Al crear una cuenta perder el histrico de la conversacin de esta sala de invitados.';

z.string.es.modalAccountDeletionAction = 'Eliminar';
z.string.es.modalAccountDeletionHeadline = 'Eliminar cuenta';
z.string.es.modalAccountDeletionMessage = 'Enviaremos un mensaje por correo electrnico o SMS. Sigue el enlace para borrar permanentemente tu cuenta.';

z.string.es.modalAccountLeaveGuestRoomAction = 'Abandonar';
z.string.es.modalAccountLeaveGuestRoomHeadline = 'Abandonar la sala de invitados?';
z.string.es.modalAccountLeaveGuestRoomMessage = 'El historial de conversacion ser eliminado. Para guardarlo, cree una cuenta la prxima vez.';

z.string.es.modalAccountLogoutAction = 'Cerrar sesin';
z.string.es.modalAccountLogoutHeadline = 'Borrar los Datos?';
z.string.es.modalAccountLogoutOption = 'Borrar todos sus datos personales y las conversaciones en este dispositivo.';

z.string.es.modalAccountNewDevicesSecondary = 'Administrar dispositivos';
z.string.es.modalAccountNewDevicesHeadline = 'Tu cuenta fue usada en:';
z.string.es.modalAccountNewDevicesFrom = 'Desde:';
z.string.es.modalAccountNewDevicesMessage = 'Si usted no hizo esto, retire el dispositivo y restablecer la contrasea.';

z.string.es.modalAccountRemoveDeviceAction = 'Eliminar dispositivo';
z.string.es.modalAccountRemoveDeviceHeadline = 'Eliminar "{{device}}"';
z.string.es.modalAccountRemoveDeviceMessage = 'Se requiere tu contrasea para eliminar el dispositivo.';
z.string.es.modalAccountRemoveDevicePlaceholder = 'Contrasea';

z.string.es.modalAssetTooLargeHeadline = 'Archivo demasiado grande';
z.string.es.modalAssetTooLargeMessage = 'Puedes enviar archivos de hasta {{number}}';

z.string.es.modalAssetParallelUploadsHeadline = 'Demasiados archivos a la vez';
z.string.es.modalAssetParallelUploadsMessage = 'Puede enviar hasta {{number}} archivos a la vez.';

z.string.es.modalCallEmptyConversationHeadline = 'Nadie para llamar';
z.string.es.modalCallEmptyConversationMessage = 'No hay nadie aqui.';

z.string.es.modalCallEmptyLogHeadline = 'No hay llamadas';
z.string.es.modalCallEmptyLogMessage = 'No hay llamadas para crear el informe de depuracin.';

z.string.es.modalCallNoGroupVideoHeadline = 'No hay videollamadas en grupos';
z.string.es.modalCallNoGroupVideoMessage = 'Video llamadas no estn disponibles en conversaciones de grupo.';

z.string.es.modalCallNoMicrophoneAction = 'Explqueme cmo';
z.string.es.modalCallNoMicrophoneMessage = 'Para hablar, tu navegador necesita permiso de usar el micrfono.';
z.string.es.modalCallNoMicrophoneHeadline = 'No se puede llamar sin micrfono';

z.string.es.modalCallSecondIncomingAction = 'Contestar';
z.string.es.modalCallSecondIncomingHeadline = 'Contestar llamada?';
z.string.es.modalCallSecondIncomingMessage = 'Su llamada en curso terminara.';

z.string.es.modalCallSecondOngoingAction = 'Colgar';
z.string.es.modalCallSecondOngoingHeadline = 'Colgar llamada en otro dispositivo?';
z.string.es.modalCallSecondOngoingMessage = 'Solo puedes estar en una llamada a la vez.';

z.string.es.modalCallSecondOutgoingAction = 'Colgar';
z.string.es.modalCallSecondOutgoingHeadline = 'Colgar llamada actual?';
z.string.es.modalCallSecondOutgoingMessage = 'Solo puedes estar en una llamada a la vez.';

z.string.es.modalConnectCancelAction = 'Si';
z.string.es.modalConnectCancelHeadline = 'Cancelar solicitud?';
z.string.es.modalConnectCancelMessage = 'Eliminar la solicitud de conexin con {{user}}.';
z.string.es.modalConnectCancelSecondary = 'No';

z.string.es.modalConnectAcceptAction = 'Conectar';
z.string.es.modalConnectAcceptHeadline = 'Aceptar?';
z.string.es.modalConnectAcceptMessage = 'Esto los conectar y abrir la conversacin con {{user}}.';
z.string.es.modalConnectAcceptSecondary = 'Ignorar';

z.string.es.modalConversationClearAction = 'Eliminar';
z.string.es.modalConversationClearHeadline = 'Borrar contenido?';
z.string.es.modalConversationClearMessage = 'Esto borrar el historial de conversaciones en todos sus dispositivos.';
z.string.es.modalConversationClearOption = 'Tambin abandonar la conversacin';

z.string.es.modalConversationDeleteMessageAction = 'Eliminar';
z.string.es.modalConversationDeleteMessageHeadline = 'Eliminar slo para m?';
z.string.es.modalConversationDeleteMessageMessage = 'Esto no se puede deshacer.';

z.string.es.modalConversationDeleteMessageEveryoneAction = 'Eliminar';
z.string.es.modalConversationDeleteMessageEveryoneHeadline = 'Eliminar para todos?';
z.string.es.modalConversationDeleteMessageEveryoneMessage = 'Esto no se puede deshacer.';

z.string.es.modalConversationLeaveAction = 'Abandonar';
z.string.es.modalConversationLeaveHeadline = 'Dejar la conversacin {{name}}?';
z.string.es.modalConversationLeaveMessage = 'No podr enviar o recibir mensajes en esta conversacin.';

z.string.es.modalConversationMessageTooLongHeadline = 'El mensaje es demasiado largo';
z.string.es.modalConversationMessageTooLongMessage = 'Puede enviar mensajes de hasta {{number}} caracteres.';

z.string.es.modalConversationNewDeviceAction = 'Enviar de todos modos';
z.string.es.modalConversationNewDeviceHeadlineOne = '{{user}} comenz a utilizar un dispositivo nuevo';
z.string.es.modalConversationNewDeviceHeadlineMany = '{{user}}s comenzaron a utilizar dispositivos nuevos';
z.string.es.modalConversationNewDeviceHeadlineYou = '{{user}} comenz a utilizar un dispositivo nuevo';
z.string.es.modalConversationNewDeviceIncomingCallAction = 'Acepta la llamada?';
z.string.es.modalConversationNewDeviceIncomingCallMessage = 'Desea aceptar la llamada?';
z.string.es.modalConversationNewDeviceMessage = 'An quieres enviar su mensaje?';
z.string.es.modalConversationNewDeviceOutgoingCallAction = 'Llamar de todos modos';
z.string.es.modalConversationNewDeviceOutgoingCallMessage = 'Desea realizar la llamada?';

z.string.es.modalConversationNotConnectedHeadline = 'No hay nadie aadido a la conversacin';
z.string.es.modalConversationNotConnectedMessageOne = '{{name}} no quiere ser aadido a las conversaciones.';
z.string.es.modalConversationNotConnectedMessageMany = 'Una de las personas que has seleccionado no quiere ser aadida a conversaciones.';

z.string.es.modalConversationRemoveAction = 'Eliminar';
z.string.es.modalConversationRemoveHeadline = 'Quitar?';
z.string.es.modalConversationRemoveMessage = '{{user}} no podr enviar o recibir mensajes en esta conversacin.';

z.string.es.modalConversationRemoveGuestsAction = 'Eliminar';
z.string.es.modalConversationRemoveGuestsHeadline = 'Desactivar el acceso de invitados?';
z.string.es.modalConversationRemoveGuestsMessage = 'Los invitados y servicios actuales sern eliminados de la conversacin. No se permitirn nuevos invitados o servicios.';

z.string.es.modalConversationRevokeLinkAction = 'Revocar enlace';
z.string.es.modalConversationRevokeLinkHeadline = 'Revocar el enlace?';
z.string.es.modalConversationRevokeLinkMessage = 'Los nuevos invitados no podrn unirse a este enlace. Los invitados actuales seguirn teniendo acceso.';

z.string.es.modalConversationGuestOptionsAllowGuestMessage = 'No se admiten invitados o servicios. Por favor, intntalo de nuevo.';
z.string.es.modalConversationGuestOptionsDisableGuestMessage = 'No se pudieron eliminar los invitados y servicios. Por favor, intntalo de nuevo.';
z.string.es.modalConversationGuestOptionsGetCodeMessage = 'No se pudo obtener el enlace de acceso.';
z.string.es.modalConversationGuestOptionsRequestCodeMessage = 'No se ha podido solicitar el enlace de acceso. Por favor, intntalo de nuevo.';
z.string.es.modalConversationGuestOptionsRevokeCodeMessage = 'No se pudo revocar el enlace de acceso. Por favor, intntalo de nuevo.';
z.string.es.modalConversationGuestOptionsToggleGuestsMessage = 'No se pudo cambiar el estado de los invitados.';

z.string.es.modalConversationTooManyMembersHeadline = 'Grupo completo';
z.string.es.modalConversationTooManyMembersMessage = 'Hasta {{number1}} personas pueden unirse a una conversacin. Actualmente slo hay espacio para {{number2}} personas ms.';

z.string.es.modalGifTooLargeHeadline = 'La animacin seleccionada es demasiado grande';
z.string.es.modalGifTooLargeMessage = 'El tamao mximo es {{number}} MB.';

z.string.es.modalIntegrationUnavailableHeadline = 'Bots no disponibles por el momento';
z.string.es.modalIntegrationUnavailableMessage = 'Gracias por su inters en los bots. El servicio est suspendido mientras trabajamos en la prxima versin.';

z.string.es.modalPictureFileFormatHeadline = 'No es posible utilizar esta foto';
z.string.es.modalPictureFileFormatMessage = 'Por favor, elija un archivo PNG o JPEG.';

z.string.es.modalPictureTooLargeHeadline = 'La imagen seleccionada es demasiado grande';
z.string.es.modalPictureTooLargeMessage = 'Puede utilizar imgenes de hasta {{number}} MB.';

z.string.es.modalPictureTooSmallHeadline = 'Imagen demasiado pequea';
z.string.es.modalPictureTooSmallMessage = 'Por favor, elija una foto que sea de al menos 320 x 320 px.';

z.string.es.modalImproveWireAction = 'Aceptar';
z.string.es.modalImproveWireSecondary = 'No ahora';
z.string.es.modalImproveWireHeadline = 'Aydenos a mejorar Wire';
z.string.es.modalImproveWireMessage = 'El envo annimo de informes de uso y fallos nos ayuda a mejorar nuestros productos y servicios. No usamos esta informacin para nada ms.';

z.string.es.modalServiceUnavailableHeadline = 'No es posible aadir un servicio';
z.string.es.modalServiceUnavailableMessage = 'El servicio no est disponible en este momento.';

z.string.es.modalSessionResetHeadline = 'La sesin ha sido restablecida';
z.string.es.modalSessionResetMessage1 = 'Si no se resuelva el problema,';
z.string.es.modalSessionResetMessageLink = 'comunicarse con';
z.string.es.modalSessionResetMessage2 = 'nosotros.';

z.string.es.modalUploadContactsAction = 'Vuelve a intentarlo';
z.string.es.modalUploadContactsMessage = 'No recibimos tu informacin. Por favor, intenta importar tus contactos otra vez.';

z.string.es.modalUserBlockAction = 'Bloquear';
z.string.es.modalUserBlockHeadline = 'Bloquear a {{user}}?';
z.string.es.modalUserBlockMessage = '{{user}} no podr ponerse en contacto contigo o aadirte a chats de grupo.';

z.string.es.modalUserUnblockAction = 'Desbloquear';
z.string.es.modalUserUnblockHeadline = 'Desbloquear?';
z.string.es.modalUserUnblockMessage = '{{user}} ahora podr ponerse en contacto contigo o aadirte a chats de grupo.';

z.string.es.modalNoCameraTitle = 'Sin acceso a la cmara';
z.string.es.modalNoCameraMessage = 'Wire no tiene acceso a la cmara.[br][faqLink]Consulte este artculo de asistencia[/faqLink] para saber cmo solucionar el problema.';

z.string.es.connectionRequestConnect = 'Conectar';
z.string.es.connectionRequestIgnore = 'Ignorar';

z.string.es.conversationGuestIndicator = 'Invitado';
z.string.es.userRemainingTimeHours = '{{time}}horas restantes';
z.string.es.userRemainingTimeMinutes = 'Menos de {{time}}m restante';

z.string.es.conversationYouNominative = 't';
z.string.es.conversationYouDative = 't';
z.string.es.conversationYouAccusative = 't';

z.string.es.conversationConnectionAccepted = 'Conectado';
z.string.es.conversationConnectionBlocked = 'Bloqueado';
z.string.es.conversationConnectionCancelRequest = 'Cancelar solicitud de conexin';
z.string.es.conversationCreateTemporary = 'Te uniste a la conversacin';
z.string.es.conversationCreateWith = 'con {{users}}';
z.string.es.conversationDeviceStartedUsingOne = ' comenz a utilizar';
z.string.es.conversationDeviceStartedUsingMany = ' comenz a utilizar';
z.string.es.conversationDeviceUnverified = ' uno no verificado de';
z.string.es.conversationDeviceYourDevices = ' tus dispositivos';
z.string.es.conversationDeviceUserDevices = ' {{user}} dispositivos';
z.string.es.conversationDeviceNewDeviceOne = ' un nuevo dispositivo';
z.string.es.conversationDeviceNewDeviceMany = ' nuevos dispositivos';
z.string.es.conversationDeviceNewPeopleJoined = 'Nuevas personas se unieron.';
z.string.es.conversationDeviceNewPeopleJoinedVerify = 'Verificar dispositivos';
z.string.es.conversationJustNow = 'Justo ahora';
z.string.es.conversationLocationLink = 'Abrir Mapa';
z.string.es.conversationCreated = '[bold]{{name}}[/bold] inici una conversacin con {{users}}';
z.string.es.conversationCreatedMore = '[bold]{{name}}[/bold] inici una conversacin con {{users}} y [showmore]{{count}} ms[/showmore]';
z.string.es.conversationCreatedName = '[bold]{{name}}[/bold] inici la conversacin';
z.string.es.conversationCreatedNameYou = '[bold]Tu[/bold] iniciaste la conversacin';
z.string.es.conversationCreatedYou = '[[T]] iniciaste una conversacin con %2$s';
z.string.es.conversationCreatedYouMore = 'Iniciaste una conversacin con {{users}}, y [showmore]{{count}} ms[/showmore]';
z.string.es.conversationCreateWithMore = 'con {{users}} y [showmore]{{count}} ms[/showmore]';
z.string.es.conversationCreateTeam = 'con [showmore]todos los miembros del equipo[/showmore]';
z.string.es.conversationCreateTeamGuest = 'con [showmore]todos los miembros del equipo y un invitado[/showmore]';
z.string.es.conversationCreateTeamGuests = 'con [showmore]todos los miembros del equipo y {{count}} invitados[/showmore]';
z.string.es.conversationMemberJoined = '[bold]{{name}}[/bold] aadi a {{users}} a la conversacin';
z.string.es.conversationMemberJoinedYou = '[bold] T [/bold] aadiste a {{users}} a la conversacin';
z.string.es.conversationMemberJoinedMore = '[bold]{{name}}[/bold] agreg a {{users}} y [showmore]{{count}} ms[/showmore] a la conversacin';
z.string.es.conversationMemberJoinedYouMore = '[bold] T [/bold] aadiste a {{users}}y [showmore]{{count}}[/showmore] a la conversacin';
z.string.es.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] se uni';
z.string.es.conversationMemberJoinedSelfYou = '[bold]T[/bold] te uniste';
z.string.es.conversationMemberLeft = '[bold]{{name}}[/bold] se fue';
z.string.es.conversationMemberLeftYou = '[bold]T[/bold] te fuiste';
z.string.es.conversationMemberRemoved = '[bold]{{name}}[/bold] ha removido a {{users}}';
z.string.es.conversationMemberRemovedYou = '[bold]T[/bold] has removido a {{users}}';
z.string.es.conversationTeamLeft = '[bold]{{name}}[/bold] fue removido del equipo';
z.string.es.conversationMessageDelivered = 'Entregado';
z.string.es.conversationRename = ' renombr la conversacin';
z.string.es.conversationRenameYou = ' renombr la conversacin';
z.string.es.conversationUpdatedTimer = ' ajustar el temporizador de mensajes a {{time}}';
z.string.es.conversationUpdatedTimerYou = ' ajustar el temporizador de mensajes a {{time}}';
z.string.es.conversationResetTimer = ' apag el temporizador de mensajes';
z.string.es.conversationResetTimerYou = ' apag el temporizador de mensajes';
z.string.es.conversationResume = 'Iniciar una conversacin con {{users}}';
z.string.es.conversationPing = ' ping';
z.string.es.conversationPingYou = ' ping';
z.string.es.conversationToday = 'hoy';
z.string.es.conversationVoiceChannelDeactivate = ' llam';
z.string.es.conversationVoiceChannelDeactivateYou = ' llam';
z.string.es.conversationYesterday = 'Ayer';
z.string.es.conversationUnableToDecrypt1 = 'un mensaje de {{user}} no se ha recibido.';
z.string.es.conversationUnableToDecrypt2 = 'La identidad del dispositivo de {{user}} ha cambiado. Mensaje no entregado.';
z.string.es.conversationUnableToDecryptLink = 'Por qu?';
z.string.es.conversationUnableToDecryptErrorMessage = 'Error';
z.string.es.conversationUnableToDecryptResetSession = 'Restablecer sesin';
z.string.es.conversationMissedMessages = 'No has utilizado este dispositivo durante un tiempo. Algunos mensajes no aparecern aqu.';
z.string.es.conversationAssetUploading = 'Subiendo';
z.string.es.conversationAssetDownloading = 'Descargando';
z.string.es.conversationAssetUploadFailed = 'Error al subir la informacin';
z.string.es.conversationPlaybackError = 'Incapaz de reproducir';
z.string.es.conversationContextMenuCopy = 'Copiar';
z.string.es.conversationContextMenuEdit = 'Editar';
z.string.es.conversationContextMenuDelete = 'Eliminar para m';
z.string.es.conversationContextMenuDeleteEveryone = 'Eliminar para Todos';
z.string.es.conversationContextMenuDownload = 'Descargar';
z.string.es.conversationContextMenuLike = 'Me gusta';
z.string.es.conversationContextMenuUnlike = 'No me gusta';
z.string.es.conversationDeleteTimestamp = 'Eliminados el {{date}}';
z.string.es.conversationEditTimestamp = 'Editado {{date}}';
z.string.es.conversationLikesCaption = '{{number}}o de personas';
z.string.es.conversationSendPastedFile = 'Imagen aadida el {{date}}';
z.string.es.conversationSomeone = 'Alguien';
z.string.es.conversationTweetAuthor = ' en Twitter';
z.string.es.conversationServicesWarning = 'Hay servicios con acceso al contenido de esta conversacin';

z.string.es.groupCreationPreferencesAction = 'Siguiente';
z.string.es.groupCreationPreferencesErrorNameShort = 'Por lo menos 1 caracter';
z.string.es.groupCreationPreferencesErrorNameLong = 'Demasiados caracteres';
z.string.es.groupCreationPreferencesHeader = 'Crear grupo';
z.string.es.groupCreationPreferencesPlaceholder = 'Nombre del grupo';
z.string.es.groupCreationParticipantsActionCreate = 'Listo';
z.string.es.groupCreationParticipantsActionSkip = 'Omitir';
z.string.es.groupCreationParticipantsHeader = 'Agregar personas';
z.string.es.groupCreationParticipantsHeaderWithCounter = 'Aadir personas ({{number}})';
z.string.es.groupCreationParticipantsPlaceholder = 'Buscar por nombre';
z.string.es.groupSizeInfo = 'Hasta {{count}} personas pueden unirse a una conversacin de grupo. Las videollamadas funcionan con hasta 3 personas y contigo.';

z.string.es.guestRoomConversationName = 'Sala de invitados';
z.string.es.guestRoomToggleName = 'Permitir invitados y servicios';
z.string.es.guestRoomToggleInfo = 'Abrir esta conversacin a servicios y personas fuera de su equipo.';
z.string.es.guestRoomToggleInfoExtended = 'Abrir esta conversacin a servicios y personas fuera de su equipo. Siempre puedes cambiarlo ms tarde.';

z.string.es.guestRoomConversationBadge = 'Invitados presentes';
z.string.es.guestRoomConversationBadgeService = 'Servicios activos';
z.string.es.guestRoomConversationBadgeGuestAndService = 'Hay invitados y servicios activos';

z.string.es.guestRoomConversationHead = 'Personas ajenas a su equipo pueden unirse a esta conversacin.';
z.string.es.guestRoomConversationButton = 'Invitar personas';

z.string.es.collectionShowAll = 'Mostrar los {{number}}';
z.string.es.collectionSectionLinks = 'Enlaces';
z.string.es.collectionSectionImages = 'Fotos';
z.string.es.collectionSectionFiles = 'Ficheros';
z.string.es.collectionSectionAudio = 'Mensajes de audio';

z.string.es.fullsearchPlaceholder = 'Buscar mensajes';
z.string.es.fullsearchNoResults = 'Ningn resultado.';

z.string.es.archiveHeader = 'Archivar';

z.string.es.conversationsAllArchived = 'Todo archivado';
z.string.es.conversationsContacts = 'Contactos';
z.string.es.conversationsConnectionRequestMany = '{{number}} personas en espera';
z.string.es.conversationsConnectionRequestOne = '1 persona en espera';
z.string.es.conversationsEmptyConversation = 'Conversacin en grupo';
z.string.es.conversationsNoConversations = 'Iniciar una conversacin o crear un grupo.';
z.string.es.conversationsPopoverArchive = 'Archivar';
z.string.es.conversationsPopoverBlock = 'Bloquear';
z.string.es.conversationsPopoverCancel = 'Cancelar solicitud';
z.string.es.conversationsPopoverClear = 'Eliminar contenido';
z.string.es.conversationsPopoverLeave = 'Abandonar el grupo';
z.string.es.conversationsPopoverNotificationSettings = 'Notificaciones';
z.string.es.conversationsPopoverNotify = 'Sonido';
z.string.es.conversationsPopoverSilence = 'Silenciar';
z.string.es.conversationsPopoverUnarchive = 'Desarchivar';

z.string.es.conversationsSecondaryLineEphemeralMention = 'Te mencion';
z.string.es.conversationsSecondaryLineEphemeralMentionGroup = 'Alguien te mencion';
z.string.es.conversationsSecondaryLineEphemeralMessage = 'Te envi un mensaje';
z.string.es.conversationsSecondaryLineEphemeralMessageGroup = 'Alguien envi un mensaje';
z.string.es.conversationsSecondaryLineIncomingCall = '{{user}} est llamando';
z.string.es.conversationsSecondaryLinePeopleLeft = '{{number}} personas se fueron';
z.string.es.conversationsSecondaryLinePersonLeft = '{{user}} se fue';
z.string.es.conversationsSecondaryLinePersonRemoved = '{{user}} fue eliminado';
z.string.es.conversationsSecondaryLinePersonRemovedTeam = '{{user}} fue eliminado del equipo';
z.string.es.conversationsSecondaryLinePeopleAdded = '{{user}} personas se han aadido';
z.string.es.conversationsSecondaryLinePersonAdded = '{{user}} se ha aadido';
z.string.es.conversationsSecondaryLinePersonAddedSelf = '{{user}} se uni';
z.string.es.conversationsSecondaryLinePersonAddedYou = '{{user}} te ha aadido';
z.string.es.conversationsSecondaryLineRenamed = '{{user}} renombr la conversacin';
z.string.es.conversationsSecondaryLineSummaryMessage = '{{number}} mensaje';
z.string.es.conversationsSecondaryLineSummaryMessages = '{{number}} mensajes';
z.string.es.conversationsSecondaryLineSummaryMention = '{{number}} mencin';
z.string.es.conversationsSecondaryLineSummaryMentions = '{{number}} menciones';
z.string.es.conversationsSecondaryLineSummaryMissedCall = '{{number}} llamada perdida';
z.string.es.conversationsSecondaryLineSummaryMissedCalls = '{{number}} llamadas perdidas';
z.string.es.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.es.conversationsSecondaryLineSummaryPings = '{{number}} pings'
z.string.es.conversationsSecondaryLineYouLeft = 'Te fuiste';
z.string.es.conversationsSecondaryLineYouWereRemoved = 'Te han eliminado';

z.string.es.takeoverSub = 'Reclama tu nombre nico en Wire.';
z.string.es.takeoverLink = 'Aprender ms';
z.string.es.takeoverButtonChoose = 'Elegir tu propio nombre';
z.string.es.takeoverButtonKeep = 'Conservar este';

z.string.es.inviteMetaKeyMac = 'Cmd';
z.string.es.inviteMetaKeyPc = 'Ctrl';
z.string.es.inviteHintSelected = 'Presione {{metaKey}} + C para copiar';
z.string.es.inviteHintUnselected = 'Seleccione y presione {{metaKey}} + C';
z.string.es.inviteHeadline = 'Invitar amigos a Wire';
z.string.es.inviteMessage = 'Estoy en Wire, bscame como {{username}} o visita get.wire.com.';
z.string.es.inviteMessageNoEmail = 'Estoy en Wire. Visita get.wire.com para conectar conmigo.';

z.string.es.extensionsBubbleButtonGif = 'Gif';

z.string.es.extensionsGiphyButtonOk = 'Enviar';
z.string.es.extensionsGiphyButtonMore = 'Buscar otro';
z.string.es.extensionsGiphyMessage = '{{tag}}  va giphy.com';
z.string.es.extensionsGiphyNoGifs = 'Uups, no hay gifs';
z.string.es.extensionsGiphyRandom = 'Aleatorio';

z.string.es.addParticipantsConfirmLabel = 'Agregar';
z.string.es.addParticipantsHeader = 'Agregar participantes';
z.string.es.addParticipantsHeaderWithCounter = 'Aadir participantes ({{number}})';
z.string.es.addParticipantsManageServices = 'Gestionar servicios';
z.string.es.addParticipantsManageServicesNoResults = 'Gestionar servicios';
z.string.es.addParticipantsNoServicesManager = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo.';
z.string.es.addParticipantsNoServicesMember = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo. Para activarlos, pngase en contacto con el administrador.';
z.string.es.addParticipantsSearchPlaceholder = 'Buscar por nombre';
z.string.es.addParticipantsServiceConfirmButton = 'Aadir un servicio';
z.string.es.addParticipantsTabsPeople = 'Personas';
z.string.es.addParticipantsTabsServices = 'Servicios';

z.string.es.conversationDetailsActionArchive = 'Archivar';
z.string.es.conversationDetailsActionAddParticipants = 'Aadir participantes';
z.string.es.conversationDetailsActionBlock = 'Bloquear';
z.string.es.conversationDetailsActionCancelRequest = 'Cancelar solicitud';
z.string.es.conversationDetailsActionClear = 'Eliminar contenido';
z.string.es.conversationDetailsActionConversationParticipants = 'Mostrar todo ({{number}})';
z.string.es.conversationDetailsActionCreateGroup = 'Crear grupo';
z.string.es.conversationDetailsActionDevices = 'Dispositivos';
z.string.es.conversationDetailsActionGuestOptions = 'Invitados y servicios';
z.string.es.conversationDetailsActionTimedMessages = 'Mensajes temporizados';
z.string.es.conversationDetailsActionNotifications = 'Notificaciones';
z.string.es.conversationDetailsActionLeave = 'Abandonar el grupo';
z.string.es.conversationDetailsGuestsOff = 'Desactivar';
z.string.es.conversationDetailsGuestsOn = 'En';
z.string.es.conversationDetailsOptions = 'Opciones';
z.string.es.conversationDetailsParticipantsServicesOne = 'Servicio';
z.string.es.conversationDetailsParticipantsServicesMany = 'Servicios';
z.string.es.conversationDetailsParticipantsUsersOne = 'Persona';
z.string.es.conversationDetailsParticipantsUsersMany = 'Personas';
z.string.es.conversationDetailsPeople = 'Personas';
z.string.es.conversationDetailsServices = 'Servicios';

z.string.es.conversationParticipantsTitle = 'Personas';
z.string.es.conversationParticipantsSearchPlaceholder = 'Buscar por nombre';

z.string.es.groupParticipantActionBlock = 'Bloquear';
z.string.es.groupParticipantActionCancelRequest = 'Cancelar solicitud';
z.string.es.groupParticipantActionDevices = 'Dispositivos';
z.string.es.groupParticipantActionIgnoreRequest = 'Ignorar la solicitud';
z.string.es.groupParticipantActionIncomingRequest = 'Aceptar la solicitud';
z.string.es.groupParticipantActionLeave = 'Abandonar el grupo';
z.string.es.groupParticipantActionOpenConversation = 'Abrir la conversacin';
z.string.es.groupParticipantActionPending = 'Pendiente';
z.string.es.groupParticipantActionRemove = 'Remover del grupo';
z.string.es.groupParticipantActionSelfProfile = 'Abrir perfil';
z.string.es.groupParticipantActionSendRequest = 'Conectar';
z.string.es.groupParticipantActionUnblock = 'Desbloquear';

z.string.es.guestOptionsCopyLink = 'Copiar el enlace';
z.string.es.guestOptionsCopyLinkDone = 'Se copi el enlace.';
z.string.es.guestOptionsCreateLink = 'Crear un enlace';
z.string.es.guestOptionsInfoHeader = 'Invitar a otros con un enlace';
z.string.es.guestOptionsInfoText = 'Cualquiera que posea el enlace puede unirse a la conversacin, incluso si no usa Wire.';
z.string.es.guestOptionsRevokeLink = 'Revocar el enlace';
z.string.es.guestOptionsTitle = 'Invitados y servicios';

z.string.es.notificationSettingsTitle = 'Notificaciones';
z.string.es.notificationSettingsDisclaimer = 'Se te notificar acerca de todo (incluidas llamadas de audio y video) o slo cuando se te menciona.';
z.string.es.notificationSettingsEverything = 'Todo';
z.string.es.notificationSettingsNothing = 'Nada';

z.string.es.timedMessagesTitle = 'Mensaje temporizado';
z.string.es.timedMessageDisclaimer = 'Los mensajes cronometrados se activarn para todos los participantes en esta conversacin.';

z.string.es.participantDevicesDetailHeadline = 'Verifica que esta coincida con la huella digital que se muestra en el {{html1}}dispositivo de {{user}}s{{html2}}.';
z.string.es.participantDevicesDetailHowTo = 'Cmo lo hago?';
z.string.es.participantDevicesDetailResetSession = 'Restablecer sesin';
z.string.es.participantDevicesDetailShowMyDevice = 'Mostrar la huella digital de mi dispositivo';
z.string.es.participantDevicesDetailVerify = 'Verificado';

z.string.es.participantDevicesHeader = 'Dispositivos';
z.string.es.participantDevicesHeadline = 'Wire proporciona a cada dispositivo una huella digital nica. Comparala con {{user}} y verifica tu conversacin.';
z.string.es.participantDevicesLearnMore = 'Aprender ms';
z.string.es.participantDevicesWhyVerify = 'Por qu verificar las conversaciones?';
z.string.es.participantDevicesOutdatedClientMessage = '{{user}} est utilizando una versin antigua de Wire. No se muestran dispositivos aqu.';

z.string.es.participantDevicesSelfAllDevices = 'Mostrar todos mis dispositivos';
z.string.es.participantDevicesSelfFingerprint = 'Huella digital de tu dispositivo';

z.string.es.userProfileButtonConnect = 'Conectar';
z.string.es.userProfileButtonIgnore = 'Ignorar';
z.string.es.userProfileButtonUnblock = 'Desbloquear';

z.string.es.preferencesAbout = 'Acerca de';
z.string.es.preferencesAccount = 'Cuenta';
z.string.es.preferencesAV = 'Audio / Vdeo';
z.string.es.preferencesDeviceDetails = 'Detalles del dispositivo';
z.string.es.preferencesDevices = 'Dispositivos';
z.string.es.preferencesHeadline = 'Preferencias';
z.string.es.preferencesOptions = 'Opciones';

z.string.es.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.es.preferencesAboutPrivacyPolicy = 'Poltica de Privacidad';
z.string.es.preferencesAboutSupport = 'Soporte';
z.string.es.preferencesAboutSupportWebsite = 'Sitio web de Soporte';
z.string.es.preferencesAboutSupportContact = 'Contactar con Soporte';
z.string.es.preferencesAboutTermsOfUse = 'Trminos de uso';
z.string.es.preferencesAboutVersion = 'Versin {{version}}';
z.string.es.preferencesAboutWebsite = 'Pgina web de Wire';

z.string.es.preferencesAccountAvaibilityUnset = 'Establecer estado';
z.string.es.preferencesAccountCreateTeam = 'Crear un equipo';
z.string.es.preferencesAccountData = 'Permisos de uso de datos';
z.string.es.preferencesAccountDataCheckbox = 'Enviar datos annimos';
z.string.es.preferencesAccountDataDetail = 'Ayude a mejorar Wire enviando informes annimos sobre el uso y los fallos.';
z.string.es.preferencesAccountDelete = 'Eliminar cuenta';
z.string.es.preferencesAccountLeaveGuestRoom = 'Abandonar la sala de invitados';
z.string.es.preferencesAccountLeaveGuestRoomDescription = 'Ya no podr acceder a los mensajes de esta conversacin.';
z.string.es.preferencesAccountLogOut = 'Cerrar sesin';
z.string.es.preferencesAccountManageTeam = 'Administrar equipo';
z.string.es.preferencesAccountMarketingConsentCheckbox = 'Recibir boletn de noticias';
z.string.es.preferencesAccountMarketingConsentDetail = 'Reciba noticias y actualizaciones de productos de Wire por correo electrnico.';
z.string.es.preferencesAccountResetPassword = 'Restablecer contrasea';
z.string.es.preferencesAccountTeam = 'en {{name}}';
z.string.es.preferencesAccountUsernamePlaceholder = 'Tu nombre completo';
z.string.es.preferencesAccountUsernameHint = 'Al menos 2 caracteres. Slo az, 09 y _.';
z.string.es.preferencesAccountUsernameAvailable = 'Disponible';
z.string.es.preferencesAccountUsernameErrorTaken = 'No disponible';

z.string.es.preferencesAVCamera = 'Cmara';
z.string.es.preferencesAVMicrophone = 'Micrfono';
z.string.es.preferencesAVPermissionDetail = 'Habilitar desde las preferencias de tu navegador';
z.string.es.preferencesAVSpeakers = 'Altavoz';
z.string.es.preferencesAVTemporaryDisclaimer = 'Los invitados no pueden iniciar videoconferencias. Seleccione la cmara que desea utilizar si se une a una.';
z.string.es.preferencesAVNoCamera = 'Wire no tiene acceso a la cmara.[br][faqLink]Consulte este artculo de asistencia[/faqLink] para saber cmo solucionar el problema.';
z.string.es.preferencesAVTryAgain = 'Intentar de nuevo';

z.string.es.preferencesDevicesActivatedOn = 'Activado el {{date}}';
z.string.es.preferencesDevicesActive = 'Activo';
z.string.es.preferencesDevicesActiveDetail = 'Si no reconoces un dispositivo anterior, elimnalo y restablece tu contrasea.';
z.string.es.preferencesDevicesCurrent = 'Actual';
z.string.es.preferencesDevicesFingerprint = 'Huella digital';
z.string.es.preferencesDevicesFingerprintDetail = 'Wire proporciona a cada dispositivo una huella digital nica. Compare las huellas dactilares para verificar su dispositivos y conversaciones.';
z.string.es.preferencesDevicesId = 'ID: ';
z.string.es.preferencesDevicesRemove = 'Eliminar';
z.string.es.preferencesDevicesRemoveCancel = 'Cancelar';
z.string.es.preferencesDevicesRemoveDetail = 'Elimina este dispositivo si has dejado de usarlo. Se cerrar la sesin inmediatamente en este dispositivo.';
z.string.es.preferencesDevicesSessionConfirmation = 'La sesin ha sido restablecida.';
z.string.es.preferencesDevicesSessionDetail = 'Si no coinciden las huellas digitales, reiniciar la sesin para generar nuevas claves de cifrado en ambos lados.';
z.string.es.preferencesDevicesSessionReset = 'Restablecer sesin';
z.string.es.preferencesDevicesSessionOngoing = 'Restableciendo sesin';
z.string.es.preferencesDevicesVerification = 'Verificado';

z.string.es.preferencesOptionsAudio = 'Alertas de sonido';
z.string.es.preferencesOptionsAudioAll = 'Todos';
z.string.es.preferencesOptionsAudioAllDetail = 'Todos los sonidos';
z.string.es.preferencesOptionsAudioNone = 'Ninguno';
z.string.es.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.es.preferencesOptionsAudioSome = 'Algunos';
z.string.es.preferencesOptionsAudioSomeDetail = 'Pings y llamadas';
z.string.es.preferencesOptionsContacts = 'Contactos';
z.string.es.preferencesOptionsContactsGmail = 'Importar desde Gmail';
z.string.es.preferencesOptionsContactsMacos = 'Importar desde Contactos';
z.string.es.preferencesOptionsContactsDetail = 'Compartir tus contactos te ayuda a conectarte con otros. Toda la informacin es annima y no ser compartida con nadie ms.';
z.string.es.preferencesOptionsPopular = 'Por demanda popular';
z.string.es.preferencesOptionsEmojiReplaceCheckbox = 'Sustituir emoticonos por emojis';
z.string.es.preferencesOptionsPreviewsSendCheckbox = 'Crear vistas previas para los enlaces enviados';
z.string.es.preferencesOptionsPreviewsSendDetail = 'Las vistas previas todava pueden mostrarse para enlaces de otras personas.';
z.string.es.preferencesOptionsNotifications = 'Notificaciones';
z.string.es.preferencesOptionsNotificationsNone = 'Desactivar';
z.string.es.preferencesOptionsNotificationsObfuscate = 'Ocultar detalles';
z.string.es.preferencesOptionsNotificationsObfuscateMessage = 'Mostrar remitente';
z.string.es.preferencesOptionsNotificationsOn = 'Mostrar remitente y mensaje';
z.string.es.preferencesOptionsCallLogs = 'Solucin de problemas';
z.string.es.preferencesOptionsCallLogsGet = 'Guardar el informe de depuracin de llamadas';
z.string.es.preferencesOptionsCallLogsDetail = 'Esta informacin ayuda al Soporte de Wire a diagnosticar problemas de llamadas.';

z.string.es.preferencesOptionsBackupHeader = 'Historia';
z.string.es.preferencesOptionsBackupExportHeadline = 'Realizar copias de seguridad de las conversaciones';
z.string.es.preferencesOptionsBackupExportSecondary = 'Cree una copia de seguridad para conservar el historial de conversaciones. Puede utilizarla para restaurar el historial si pierde el equipo o cambia a uno nuevo. El archivo de copia de seguridad no est protegido por el cifrado de extremo a extremo de Wire, as que gurdelo en un lugar seguro.';
z.string.es.preferencesOptionsBackupImportHeadline = 'Restaurar desde la copia de seguridad';
z.string.es.preferencesOptionsBackupImportSecondary = 'Slo puede restaurar el historial desde una copia de seguridad de la misma plataforma. Su copia de seguridad sobrescribir las conversaciones que pueda tener en este dispositivo.';

z.string.es.backupExportGenericErrorHeadline = 'El archivo no se ha podido guardar';
z.string.es.backupExportGenericErrorSecondary = 'La copia de seguridad no se ha completado.';
z.string.es.backupExportProgressHeadline = 'Preparando';
z.string.es.backupExportProgressSecondary = 'Haciendo copias de seguridad. {{processed}} de {{total}} - {{progress}}%';
z.string.es.backupExportProgressCompressing = 'Preparando el archivo de respaldo';
z.string.es.backupExportSaveFileAction = 'Guardar archivo';
z.string.es.backupExportSuccessHeadline = 'Backup listo';
z.string.es.backupExportSuccessSecondary = 'Puedes utilizar esto para restaurar el historial de conversaciones si pierdes la computadora o cambias a una nueva.';
z.string.es.backupImportGenericErrorHeadline = 'Algo sali mal';
z.string.es.backupImportGenericErrorSecondary = 'Tu historial no pudo ser restaurado.';
z.string.es.backupImportAccountErrorHeadline = 'Copia de seguridad incorrecta';
z.string.es.backupImportAccountErrorSecondary = 'No se puede restaurar el historial desde una cuenta diferente.';
z.string.es.backupImportVersionErrorHeadline = 'Copia de seguridad incompatible';
z.string.es.backupImportVersionErrorSecondary = 'Esta copia de seguridad fue creada por una versin antigua o ms reciente de Wire y no se puede restaurar aqu.';
z.string.es.backupImportIncompatibleErrorHeadline = 'Copia de seguridad incorrecta';
z.string.es.backupImportIncompatibleErrorSecondary = 'No se puede restaurar el historial desde una cuenta diferente.';
z.string.es.backupImportOutdatedErrorHeadline = 'Copia de seguridad incompatible';
z.string.es.backupImportOutdatedErrorSecondary = 'Esta copia de seguridad fue creada por una versin antigua o ms reciente de Wire y no se puede restaurar aqu.';
z.string.es.backupImportProgressHeadline = 'Preparando';
z.string.es.backupImportProgressSecondary = 'Restaurando la copia de seguridad. {{processed}} de {{total}} - {{progress}}%';
z.string.es.backupImportSuccessHeadline = 'Historia restaurada.';
z.string.es.backupCancel = 'Cancelar';
z.string.es.backupTryAgain = 'Intentar de nuevo';

z.string.es.searchConnect = 'Conectar';
z.string.es.searchConnections = 'Conexiones';
z.string.es.searchContacts = 'Contactos';
z.string.es.searchCreateGroup = 'Crear grupo';
z.string.es.searchCreateGuestRoom = 'Crear una sala de invitados';
z.string.es.searchGroups = 'Grupos';
z.string.es.searchPeople = 'Personas';
z.string.es.searchPlaceholder = 'Buscar por nombre o usuario';
z.string.es.searchServicePlaceholder = 'Buscar por nombre';
z.string.es.searchServices = 'Servicios';
z.string.es.searchManageServices = 'Gestionar los servicios';
z.string.es.searchManageServicesNoResults = 'Gestionar servicios';
z.string.es.searchNoServicesManager = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo.';
z.string.es.searchNoServicesMember = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo. Para activarlos, pngase en contacto con el administrador.';
z.string.es.searchTeamGroups = 'Conversaciones de equipo';
z.string.es.searchTeamMembers = 'Miembros del equipo';
z.string.es.searchTopPeople = 'Personas ms importantes';
z.string.es.searchTrySearch = 'Encontrar personas por nombre o usuario';
z.string.es.searchNoContactsOnWire = 'No tienes contactos en Wire. Trata de encontrar personas por nombre o usuario.';
z.string.es.searchMemberInvite = 'Invitar personas a unirse al equipo';
z.string.es.searchOthers = 'Conectar';

z.string.es.searchInvite = 'Invitar amigos a Wire';
z.string.es.searchInviteDetail = 'Compartir tus contactos te ayuda a conectar con otros. Anonimizamos toda la informacin y no la compartimos con nadie.';
z.string.es.searchInviteButtonContacts = 'Desde los contactos';
z.string.es.searchInviteButtonGmail = 'Desde Gmail';
z.string.es.searchInviteHeadline = 'Trete a tus amigos';
z.string.es.searchInviteShare = 'Compartir contactos';

z.string.es.searchServiceConfirmButton = 'Abrir conversacin';

z.string.es.searchListEveryoneParticipates = 'Todas las personas con quien ests conectado ya se encuentran en esta conversacin.';
z.string.es.searchListNoMatches = 'No hay resultados coincidentes. Intente con un nombre diferente.';

z.string.es.temporaryGuestCta = 'Crear una cuenta';
z.string.es.temporaryGuestDescription = 'Asegur tu negocio con mensajes de grupos y llamadas cifradas de punta a punta.';
z.string.es.temporaryGuestTimeRemaining = ' no hay nadie en esta sala de invitados';

z.string.es.temporaryGuestJoinMessage = 'Esta conversacin estar disponible durante las prximas 24 horas.';
z.string.es.temporaryGuestJoinDescription = 'Si cierras o actualizas esta pgina, perders acceso.';

z.string.es.temporaryGuestLeaveMessage = ' ya no eres parte de esta conversacin.';
z.string.es.temporaryGuestLeaveDescription = 'Si cierras o actualizas esta pgina, perders acceso al historial de conversacin.';

z.string.es.uploadGoogleHeadline = 'Buscar con quien hablar.';
z.string.es.uploadGoogleMessage = 'Compartir tus contactos te ayuda a conectarte con otros. Toda la informacin es annima y no ser compartida con nadie ms.';

z.string.es.warningCallUnsupportedIncoming = '{{user}} est llamando. Tu navegador no est configurada para llamadas.';
z.string.es.warningCallUnsupportedOutgoing = 'No puedes llamar porque tu navegador no est configurada para llamadas.';
z.string.es.warningCallIssues = 'Esta versin de Wire no puede participar en la llamada. Por favor, usa';
z.string.es.warningCallUpgradeBrowser = 'Para llamar se necesita una versin reciente de Google Chrome.';
z.string.es.warningConnectivityConnectionLost = 'Intentando conectar. Es posible que Wire no podr entregar mensajes.';
z.string.es.warningConnectivityNoInternet = 'No hay Internet. No podrs enviar o recibir mensajes.';
z.string.es.warningLearnMore = 'Aprender ms';
z.string.es.warningLifecycleUpdate = 'Hay una nueva versin de Wire disponible.';
z.string.es.warningLifecycleUpdateNotes = 'Novedades';
z.string.es.warningLifecycleUpdateLink = 'Actualiza ahora';
z.string.es.warningNotFoundCamera = 'No puedes llamar porque tu mquina no tiene cmera.';
z.string.es.warningNotFoundMicrophone = 'No puedes llamar porque tu mquina no tiene micrfono.';
z.string.es.warningPermissionDeniedCamera = 'No puedes llamar porque tu mquina no tiene accesso a la cmera.';
z.string.es.warningPermissionDeniedMicrophone = 'No puedes llamar porque tu mquina no tiene acceso al micrfono.';
z.string.es.warningPermissionDeniedScreen = 'Tu navegador necesita permiso para compartir la pantalla.';
z.string.es.warningPermissionRequestCamera = '{{icon}} Permitir acceso a la cmara';
z.string.es.warningPermissionRequestMicrophone = '{{icon}} Permitir acceso al micrfono';
z.string.es.warningPermissionRequestNotification = '{{icon}} Permitir notificaciones';
z.string.es.warningPermissionRequestScreen = '{{icon}} Permitir acceso a la pantalla';

z.string.es.userAvailabilityAvailable = 'Disponible';
z.string.es.userAvailabilityAway = 'Ausente';
z.string.es.userAvailabilityBusy = 'Ocupado';
z.string.es.userAvailabilityNone = 'Ninguno';

z.string.es.notificationAssetAdd = 'Comparti una foto';
z.string.es.notificationConnectionAccepted = 'Acept tu solicitud de conexin';
z.string.es.notificationConnectionConnected = 'Ahora est conectado';
z.string.es.notificationConnectionRequest = 'Quiere conectar';
z.string.es.notificationConversationCreate = '{{user}} inici una conversacin';
z.string.es.notificationConversationMessageTimerUpdate = '{{user}} estableci el temporizador de mensajes a {{time}}';
z.string.es.notificationConversationMessageTimerReset = '{{user}} apag el temporizador de mensajes';
z.string.es.notificationConversationRename = '{{user}} renombr la conversacin a {{name}}';
z.string.es.notificationMemberJoinMany = '{{user}} agreg a {{number}} personas a la conversacin';
z.string.es.notificationMemberJoinSelf = '{user} se uni a la conversacin';
z.string.es.notificationMemberJoinOne = '{{user1}} agreg a {{user2}} a la conversacin';
z.string.es.notificationMemberLeaveRemovedYou = '{{user}} te elimin de la conversacin';
z.string.es.notificationMention = 'Mencin nueva:';
z.string.es.notificationObfuscated = 'Te envi un mensaje';
z.string.es.notificationObfuscatedMention = 'Te mencion';
z.string.es.notificationObfuscatedTitle = 'Alguien';
z.string.es.notificationPing = 'Hizo ping';
z.string.es.notificationReaction = '{{reaction}} su mensaje';
z.string.es.notificationSharedAudio = 'Comparti un mensaje de audio';
z.string.es.notificationSharedFile = 'Comparti un archivo';
z.string.es.notificationSharedLocation = 'Comparti una ubicacin';
z.string.es.notificationSharedVideo = 'Comparti un video';
z.string.es.notificationTitleGroup = '{{user}} en {{conversation}}';
z.string.es.notificationVoiceChannelActivate = 'Llamando';
z.string.es.notificationVoiceChannelDeactivate = 'Llam';

z.string.es.tooltipConversationAllVerified = 'Todas las huellas digitales estn verificadas';
z.string.es.tooltipConversationCall = 'Llamar';
z.string.es.tooltipConversationEphemeral = 'Mensaje temporizado';
z.string.es.tooltipConversationFile = 'Aadir archivo';
z.string.es.tooltipConversationInputPlaceholder = 'Escriba un mensaje';
z.string.es.tooltipConversationInputPlaceholderAvailable = '{{user}} est disponible';
z.string.es.tooltipConversationInputPlaceholderAway = '{{user}} est ausente';
z.string.es.tooltipConversationInputPlaceholderBusy = '{{user}} est ocupado';
z.string.es.tooltipConversationPeople = 'Personas ({{shortcut}})';
z.string.es.tooltipConversationPicture = 'Aadir imagen';
z.string.es.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.es.tooltipConversationSearch = 'Buscar';
z.string.es.tooltipConversationVideoCall = 'Videollamada';

z.string.es.tooltipConversationsArchive = 'Archivo ({{shortcut}})';
z.string.es.tooltipConversationsArchived = 'Mostrar archivo ({{number}})';
z.string.es.tooltipConversationsMore = 'Ms';
z.string.es.tooltipConversationsNotifications = 'Abrir configuracin de notificaciones ({{shortcut}})';
z.string.es.tooltipConversationsNotify = 'Activar snido ({{shortcut}})';
z.string.es.tooltipConversationsPreferences = 'Abrir preferencias';
z.string.es.tooltipConversationsSilence = 'Silenciar ({{shortcut}})';
z.string.es.tooltipConversationsStart = 'Empezar una conversacin ({{shortcut}})';

z.string.es.tooltipConversationDetailsAddPeople = 'Aadir participantes a la conversacin ({{shortcut}})';
z.string.es.tooltipConversationDetailsRename = 'Cambiar nombre de la conversacin';

z.string.es.tooltipPreferencesContactsGmail = 'Iniciar sesin en tu cuenta de Gmail para compartir los contactos';
z.string.es.tooltipPreferencesContactsMacos = 'Compartir todos tus contactos desde la aplicacin de Contactos de macOS';
z.string.es.tooltipPreferencesPassword = 'Abrir otra pgina web para restablecer su contrasea';
z.string.es.tooltipPreferencesPicture = 'Cambiar tu foto';
z.string.es.tooltipPreferencesRename = 'Cambiar tu nombre';

z.string.es.tooltipSearchClose = 'Cerrar (Esc)';

z.string.es.initReceivedSelfUser = 'Hola, {{user}}.';
z.string.es.initValidatedClient = 'Cargando conexiones y conversaciones';
z.string.es.initReceivedUserData = 'Buscando mensajes nuevos';
z.string.es.initDecryption = 'Descifrando mensajes';
z.string.es.initEvents = 'Cargando mensajes';
z.string.es.initUpdatedFromNotifications = 'Casi terminado - Disfruta  Wire';
z.string.es.initProgress = '  {{number1}} de {{number2}}';

z.string.es.ephemeralUnitsNone = 'Desactivar';
z.string.es.ephemeralUnitsSecond = 'segundo';
z.string.es.ephemeralUnitsSeconds = 'segundos';
z.string.es.ephemeralUnitsMinute = 'minuto';
z.string.es.ephemeralUnitsMinutes = 'minutos';
z.string.es.ephemeralUnitsHour = 'hora';
z.string.es.ephemeralUnitsHours = 'horas';
z.string.es.ephemeralUnitsDay = 'da';
z.string.es.ephemeralUnitsDays = 'das';
z.string.es.ephemeralUnitsWeek = 'semana';
z.string.es.ephemeralUnitsWeeks = 'semanas';
z.string.es.ephemeralUnitsYear = 'ao';
z.string.es.ephemeralUnitsYears = 'aos';
z.string.es.ephemeralRemaining = 'restantes';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.et.wire = 'Wire';
z.string.et.wireMacos = 'Wire macOS-ile';
z.string.et.wireWindows = 'Wire Windowsile';
z.string.et.wireLinux = 'Wire Linuxile';
z.string.et.nonexistentUser = 'Kustutatud kasutaja';
z.string.et.and = 'ja';
z.string.et.enumerationAnd = ' ja ';

//=Rakenduse laadimine
z.string.et.authAccountCountryCode = 'Riigi kood';
z.string.et.authAccountPasswordForgot = 'Unustasid parooli?';
z.string.et.authAccountPublicComputer = 'See on avalik arvuti';
z.string.et.authAccountSignIn = 'Logi sisse';
z.string.et.authAccountSignInPhone = 'Telefoniga sisse logimine';

z.string.et.authBlockedCookies = 'Wirei sisselogimiseks luba kpsised.';
z.string.et.authBlockedDatabase = 'Wire vajab snumite kuvamiseks ligipsu kohalikule hoidlale (local storage). Kohalik hoidla ei ole privaatreiimis saadaval.';
z.string.et.authBlockedTabs = 'Wire on juba teisel kaardil avatud.';
z.string.et.authBlockedTabsAction = 'Kasuta hoopis seda brauserisakki';

z.string.et.authVerifyAccountAdd = 'Lisa';
z.string.et.authVerifyAccountDetail = 'See vimaldab kasutada Wirei mitmes seadmes.';
z.string.et.authVerifyAccountHeadline = 'Lisa meiliaadress ja parool.';
z.string.et.authVerifyAccountLogout = 'Logi vlja';
z.string.et.authVerifyCodeDescription = 'Sisesta kinnituskood,\nmille saatsime numbrile {{number}}.';
z.string.et.authVerifyCodeResend = 'Kood ei saabu?';
z.string.et.authVerifyCodeResendDetail = 'Saada uuesti';
z.string.et.authVerifyCodeResendTimer = 'Sa vid uue koodi tellida {{expiration}} prast.';
z.string.et.authVerifyCodeChangePhone = 'Numbri muutmine';
z.string.et.authVerifyPasswordHeadline = 'Sisesta parool';

z.string.et.authLimitDevicesHeadline = 'Seadmed';
z.string.et.authLimitDescription = 'Eemalda ks oma teistest seadmetest, et sellel Wirei kasutada.';
z.string.et.authLimitButtonManage = 'Seadmete haldus';
z.string.et.authLimitButtonSignOut = 'Logi vlja';
z.string.et.authLimitDevicesCurrent = '(Praegune)';

z.string.et.authHistoryHeadline = 'Kasutad sellel seadmel Wireit esimest korda.';
z.string.et.authHistoryDescription = 'Privaatuse tagamiseks ei ilmu siia sinu varasemad vestlused.';
z.string.et.authHistoryReuseHeadline = 'Oled sellel seadmel juba varem Wirei kasutanud.';
z.string.et.authHistoryReuseDescription = 'Vahepeal saadetud snumid ei ilmu siia.';
z.string.et.authHistoryButton = 'OK';

z.string.et.authPostedResend = 'Saada uuesti aadressile {{email}}';
z.string.et.authPostedResendAction = 'E-kiri ei saabu?';
z.string.et.authPostedResendDetail = 'Kontrolli oma e-postkasti ja jrgi kirjas olevaid juhiseid.';
z.string.et.authPostedResendHeadline = 'Sulle tuli kiri.';

z.string.et.authPlaceholderEmail = 'E-post';
z.string.et.authPlaceholderPasswordPut = 'Parool';
z.string.et.authPlaceholderPasswordSet = 'Parool (vhemalt 8 mrki)';
z.string.et.authPlaceholderPhone = 'Telefoninumber';

z.string.et.authErrorCode = 'Vigane kood';
z.string.et.authErrorCountryCodeInvalid = 'Vale riigikood';
z.string.et.authErrorEmailExists = 'E-posti aadress on juba kasutusel';
z.string.et.authErrorEmailForbidden = 'Vabandust. See e-posti aadress on keelatud.';
z.string.et.authErrorEmailMalformed = 'Palun sisesta korrektne e-posti aadress.';
z.string.et.authErrorEmailMissing = 'Palun sisesta e-posti aadress.';
z.string.et.authErrorMisc = 'Probleemid hendusega. Palun proovi uuesti.';
z.string.et.authErrorNameShort = 'Sisesta vhemalt 2-theline nimi';
z.string.et.authErrorOffline = 'Internetihendus puudub';
z.string.et.authErrorPasswordShort = 'Vali vhemalt 8-theline parool.';
z.string.et.authErrorPasswordWrong = 'Vale parool. Palun proovi uuesti.';
z.string.et.authErrorPending = 'Konto pole veel kinnitatud';
z.string.et.authErrorPhoneNumberBudget = 'Sa logisid liiga tihti sisse. Proovi hiljem uuesti.';
z.string.et.authErrorPhoneNumberForbidden = 'Vabandust. See telefoninumber on keelatud.';
z.string.et.authErrorPhoneNumberInvalid = 'Sobimatu telefoninumber';
z.string.et.authErrorPhoneNumberUnknown = 'Tundmatu telefoninumber';
z.string.et.authErrorSuspended = 'See konto ei ole enam sisse logimiseks autoriseeritud.';
z.string.et.authErrorSignIn = 'Palun kinnita oma andmeid ja proovi uuesti.';

z.string.et.callStateOutgoing = 'Heliseb';
z.string.et.callStateConnecting = 'hendan';
z.string.et.callStateIncoming = 'Helistab';
z.string.et.callStateIncomingGroup = '{{user}} helistab';
z.string.et.callDecline = 'Keeldu';
z.string.et.callAccept = 'Nustu';
z.string.et.callJoin = 'Liitu';
z.string.et.callChooseSharedScreen = 'Vali ekraan, mida jagada';
z.string.et.callParticipants = '{{number}} knes';
z.string.et.callNoCameraAccess = 'Kaamera ligips puudub';

z.string.et.videoCallOverlayFitVideoLabel = 'Topeltklpsa, et mahutada video ekraanialasse';
z.string.et.videoCallOverlayConversations = 'Vestlused';
z.string.et.videoCallOverlayMute = 'Vaigista vestlus';
z.string.et.videoCallOverlayVideo = 'Video';
z.string.et.videoCallOverlayShareScreen = 'Jaga ekraani';
z.string.et.videoCallOverlayHangUp = 'Lpeta kne';
z.string.et.videoCallPaused = 'Video pausil';
z.string.et.videoCallScreenShareNotSupported = 'Sinu brauser ei toeta ekraanijagamist';

z.string.et.modalAcknowledgeAction = 'Ok';
z.string.et.modalAcknowledgeHeadline = 'Midagi lks valesti';
z.string.et.modalConfirmSecondary = 'Thista';
z.string.et.modalOptionSecondary = 'Thista';

z.string.et.modalAccountCreateAction = 'OK';
z.string.et.modalAccountCreateHeadline = 'Loo konto?';
z.string.et.modalAccountCreateMessage = 'Konto luues kaotad vestluste ajaloo siin klalistetoas.';

z.string.et.modalAccountDeletionAction = 'Kustuta';
z.string.et.modalAccountDeletionHeadline = 'Kustuta konto';
z.string.et.modalAccountDeletionMessage = 'Me saadame snumi e-posti vi SMSi kaudu. Jrgi linki, et psivalt oma konto kustutada.';

z.string.et.modalAccountLeaveGuestRoomAction = 'Lahku';
z.string.et.modalAccountLeaveGuestRoomHeadline = 'Lahkud klalistetoast?';
z.string.et.modalAccountLeaveGuestRoomMessage = 'Vestluse ajalugu kustutatakse. Edaspidi ajaloo silitamiseks registreeri endale konto.';

z.string.et.modalAccountLogoutAction = 'Logi vlja';
z.string.et.modalAccountLogoutHeadline = 'Thjendad andmed?';
z.string.et.modalAccountLogoutOption = 'Kustuta kik isikuandmed ja vestlused sellest seadmest.';

z.string.et.modalAccountNewDevicesSecondary = 'Seadmete haldus';
z.string.et.modalAccountNewDevicesHeadline = 'Sinu kontot kasutati:';
z.string.et.modalAccountNewDevicesFrom = 'Kohast:';
z.string.et.modalAccountNewDevicesMessage = 'Kui sina seda ei teinud, eemalda seade ja lhtesta oma parool.';

z.string.et.modalAccountRemoveDeviceAction = 'Eemalda seade';
z.string.et.modalAccountRemoveDeviceHeadline = 'Eemalda "{{device}}"';
z.string.et.modalAccountRemoveDeviceMessage = 'Seadme eemaldamiseks pead sisestama parooli.';
z.string.et.modalAccountRemoveDevicePlaceholder = 'Parool';

z.string.et.modalAssetTooLargeHeadline = 'Liiga suur fail';
z.string.et.modalAssetTooLargeMessage = 'Sa saad saata faile kuni {{number}}';

z.string.et.modalAssetParallelUploadsHeadline = 'Liiga palju faile korraga';
z.string.et.modalAssetParallelUploadsMessage = 'Sa saad hekorraga saata kuni {{number}} faili.';

z.string.et.modalCallEmptyConversationHeadline = 'Pole kellelegi helistada';
z.string.et.modalCallEmptyConversationMessage = 'Siia pole kedagi jnud.';

z.string.et.modalCallEmptyLogHeadline = 'Kned puuduvad';
z.string.et.modalCallEmptyLogMessage = 'Kned puuduvad, vearaporti saatmine pole vimalik.';

z.string.et.modalCallNoGroupVideoHeadline = 'Videoknesid ei saa teha gruppides';
z.string.et.modalCallNoGroupVideoMessage = 'Videokned pole saadaval grupivestlustes.';

z.string.et.modalCallNoMicrophoneAction = 'tle, kuidas';
z.string.et.modalCallNoMicrophoneMessage = 'Sinu brauser vajab mikrofonile juurdepsu knede tegemiseks.';
z.string.et.modalCallNoMicrophoneHeadline = 'Mikrofonita ei saa helistada';

z.string.et.modalCallSecondIncomingAction = 'Vasta';
z.string.et.modalCallSecondIncomingHeadline = 'Vasta?';
z.string.et.modalCallSecondIncomingMessage = 'Kimasolev kne lpeb.';

z.string.et.modalCallSecondOngoingAction = 'Lpeta kne';
z.string.et.modalCallSecondOngoingHeadline = 'Lpetad teises seadmes kne?';
z.string.et.modalCallSecondOngoingMessage = 'Sa saad olla korraga ainult hes knes.';

z.string.et.modalCallSecondOutgoingAction = 'Lpeta kne';
z.string.et.modalCallSecondOutgoingHeadline = 'Lpetad kimasoleva kne?';
z.string.et.modalCallSecondOutgoingMessage = 'Sa saad olla korraga ainult hes knes.';

z.string.et.modalConnectCancelAction = 'Jah';
z.string.et.modalConnectCancelHeadline = 'Thistad kontaktisoov?';
z.string.et.modalConnectCancelMessage = 'Eemalda henduse taotlus kasutajale {{user}}.';
z.string.et.modalConnectCancelSecondary = 'Ei';

z.string.et.modalConnectAcceptAction = 'hendu';
z.string.et.modalConnectAcceptHeadline = 'Nustud?';
z.string.et.modalConnectAcceptMessage = 'See hendab teid ja avab vestluse kasutajaga {{user}}.';
z.string.et.modalConnectAcceptSecondary = 'Ignoreeri';

z.string.et.modalConversationClearAction = 'Kustuta';
z.string.et.modalConversationClearHeadline = 'Kustuta sisu?';
z.string.et.modalConversationClearMessage = 'See kustutab vestluse ajaloo kigis seadmetes.';
z.string.et.modalConversationClearOption = 'Lahku samuti vestlusest';

z.string.et.modalConversationDeleteMessageAction = 'Kustuta';
z.string.et.modalConversationDeleteMessageHeadline = 'Kustuta ainult minu jaoks?';
z.string.et.modalConversationDeleteMessageMessage = 'Seda ei saa tagasi vtta.';

z.string.et.modalConversationDeleteMessageEveryoneAction = 'Kustuta';
z.string.et.modalConversationDeleteMessageEveryoneHeadline = 'Kustuta kigi jaoks?';
z.string.et.modalConversationDeleteMessageEveryoneMessage = 'Seda ei saa tagasi vtta.';

z.string.et.modalConversationLeaveAction = 'Lahku';
z.string.et.modalConversationLeaveHeadline = 'Lahkud vestlusest {{name}}?';
z.string.et.modalConversationLeaveMessage = 'Sa ei saa selles vestluses snumeid saata ega vastu vtta.';

z.string.et.modalConversationMessageTooLongHeadline = 'Snum on liiga pikk';
z.string.et.modalConversationMessageTooLongMessage = 'Sa saad saata snumeid, mis on kuni {{number}} themrki pikad.';

z.string.et.modalConversationNewDeviceAction = 'Saada siiski';
z.string.et.modalConversationNewDeviceHeadlineOne = '{{user}} hakkas uut seadet kasutama';
z.string.et.modalConversationNewDeviceHeadlineMany = '{{users}} hakkasid uusi seadmeid kasutama';
z.string.et.modalConversationNewDeviceHeadlineYou = '{{user}} hakkasid uut seadet kasutama';
z.string.et.modalConversationNewDeviceIncomingCallAction = 'Vta kne vastu';
z.string.et.modalConversationNewDeviceIncomingCallMessage = 'Kas sa soovid siiski kne vastu vtta?';
z.string.et.modalConversationNewDeviceMessage = 'Kas tahad ikka seda snumit saata?';
z.string.et.modalConversationNewDeviceOutgoingCallAction = 'Helista siiski';
z.string.et.modalConversationNewDeviceOutgoingCallMessage = 'Kas sa soovid siiski kne teha?';

z.string.et.modalConversationNotConnectedHeadline = 'Kedagi pole vestlusse veel lisatud';
z.string.et.modalConversationNotConnectedMessageOne = '{{name}} ei soovi vestlustega liituda.';
z.string.et.modalConversationNotConnectedMessageMany = 'ks valitud inimestest ei soovi vestlustega liituda.';

z.string.et.modalConversationRemoveAction = 'Eemalda';
z.string.et.modalConversationRemoveHeadline = 'Eemaldad?';
z.string.et.modalConversationRemoveMessage = '{{user}} ei saa siin vestluses snumeid saata ega vastu vtta.';

z.string.et.modalConversationRemoveGuestsAction = 'Eemalda klalised';
z.string.et.modalConversationRemoveGuestsHeadline = 'Llitad vlja klaliste juurdepsu?';
z.string.et.modalConversationRemoveGuestsMessage = 'Praegune klaline eemaldatakse vestlusest. Uusi klalisi ei lubata.';

z.string.et.modalConversationRevokeLinkAction = 'Thista link';
z.string.et.modalConversationRevokeLinkHeadline = 'Thistad lingi?';
z.string.et.modalConversationRevokeLinkMessage = 'Uued klalised ei saa selle lingi abil liituda. Praegustel klalistel on jtkuvalt ligips.';

z.string.et.modalConversationGuestOptionsAllowGuestMessage = 'Klaliste lubamine ebannestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsDisableGuestMessage = 'Klaliste eemaldamine ebannestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsGetCodeMessage = 'Ligipsulinki ei saadud.';
z.string.et.modalConversationGuestOptionsRequestCodeMessage = 'Ligipsulingi taotlemine ebannestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsRevokeCodeMessage = 'Ligipsulingi thistamine ebannestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsToggleGuestsMessage = 'Klaliste oleku muutumine ebannestus.';

z.string.et.modalConversationTooManyMembersHeadline = 'Tismaja';
z.string.et.modalConversationTooManyMembersMessage = 'Vestlusega saavad liituda kuni {{number1}} inimest. Hetkel on ruumi veel {{number2}} inimesele.';

z.string.et.modalGifTooLargeHeadline = 'Valitud animatsioon on liiga suur';
z.string.et.modalGifTooLargeMessage = 'Maksimaalne suurus on {{number}} MB.';

z.string.et.modalIntegrationUnavailableHeadline = 'Integratsioonide tugi puudub';
z.string.et.modalIntegrationUnavailableMessage = 'Aith, et integratsioonide vastu huvi tunned. Ajutiselt vestlused integratsioone ei toeta.';

z.string.et.modalPictureFileFormatHeadline = 'Seda pilti ei saa kasutada';
z.string.et.modalPictureFileFormatMessage = 'Palun vali PNG vi JPEG fail.';

z.string.et.modalPictureTooLargeHeadline = 'Valitud pilt on liiga suur';
z.string.et.modalPictureTooLargeMessage = 'Sa saad kasutada pilte suurusega kuni {{number}} MB.';

z.string.et.modalPictureTooSmallHeadline = 'Pilt on liiga vike';
z.string.et.modalPictureTooSmallMessage = 'Palun vali pilt, mis on vhemalt 320 x 320 px suur.';

z.string.et.modalImproveWireAction = 'Nustu';
z.string.et.modalImproveWireSecondary = 'Mitte praegu';
z.string.et.modalImproveWireHeadline = 'Aita meil muuta Wirei paremaks';
z.string.et.modalImproveWireMessage = 'Anonmsete kasutus- ja krahhiaruannete saatmine aitab meil oma tooteid ja teenuseid parandada. Me ei kasuta seda infot mitte millegi muu jaoks.';

z.string.et.modalServiceUnavailableHeadline = 'Teenuse lisamine pole vimalik';
z.string.et.modalServiceUnavailableMessage = 'Teenus pole hetkel saadaval.';

z.string.et.modalSessionResetHeadline = 'Sessioon on lhtestatud';
z.string.et.modalSessionResetMessage1 = 'Kui probleem ei lahene,';
z.string.et.modalSessionResetMessageLink = 'kontakteeru';
z.string.et.modalSessionResetMessage2 = 'meiega.';

z.string.et.modalUploadContactsAction = 'Proovi uuesti';
z.string.et.modalUploadContactsMessage = 'Me ei saanud sinu infot ktte. Palun proovi uuesti kontakte importida.';

z.string.et.modalUserBlockAction = 'Blokeeri';
z.string.et.modalUserBlockHeadline = 'Blokeerid kasutaja {{user}}?';
z.string.et.modalUserBlockMessage = '{{user}} ei saa sulle snumeid saata ega sind grupivestlustesse lisada.';

z.string.et.modalUserUnblockAction = 'Eemalda blokeering';
z.string.et.modalUserUnblockHeadline = 'Eemaldad blokeeringu?';
z.string.et.modalUserUnblockMessage = '{{user}} saab sinuga uuesti hendust vtta ja sind grupivestlustesse lisada.';

z.string.et.modalNoCameraTitle = 'Kaamera ligips puudub';
z.string.et.modalNoCameraMessage = 'Wire ei saa kaamerale ligi.[br][faqLink]Loe seda tugiartiklit[/faqLink] et parandada see probleem.';

z.string.et.connectionRequestConnect = 'hendu';
z.string.et.connectionRequestIgnore = 'Ignoreeri';

z.string.et.conversationGuestIndicator = 'Klaline';
z.string.et.userRemainingTimeHours = '{{time}}h jnud';
z.string.et.userRemainingTimeMinutes = 'Alla {{time}}m jnud';

z.string.et.conversationYouNominative = 'sina';
z.string.et.conversationYouDative = 'sina';
z.string.et.conversationYouAccusative = 'sina';

z.string.et.conversationConnectionAccepted = 'hendatud';
z.string.et.conversationConnectionBlocked = 'Blokeeritud';
z.string.et.conversationConnectionCancelRequest = 'Thista hendussoov';
z.string.et.conversationCreateTemporary = 'Sina liitusid vestlusega';
z.string.et.conversationCreateWith = ' koos {{users}}';
z.string.et.conversationDeviceStartedUsingOne = ' hakkas kasutama';
z.string.et.conversationDeviceStartedUsingMany = ' hakkas kasutama';
z.string.et.conversationDeviceUnverified = ' eemaldasid kinnituse hel';
z.string.et.conversationDeviceYourDevices = ' oma seadmetest';
z.string.et.conversationDeviceUserDevices = ' kasutaja {{user}} seadmed';
z.string.et.conversationDeviceNewDeviceOne = ' uus seade';
z.string.et.conversationDeviceNewDeviceMany = ' uut seadet';
z.string.et.conversationDeviceNewPeopleJoined = 'Uued inimesed liitusid.';
z.string.et.conversationDeviceNewPeopleJoinedVerify = ' kinnita seadmed';
z.string.et.conversationJustNow = 'Just nd';
z.string.et.conversationLocationLink = 'Ava kaart';
z.string.et.conversationCreated = '[bold]{{name}}[/bold] alustas vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreatedMore = '[bold]{{name}}[/bold] alustas vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreatedName = '[bold]{{name}}[/bold] alustas vestlust';
z.string.et.conversationCreatedNameYou = '[bold]Sina[/bold] alustasid vestlust';
z.string.et.conversationCreatedYou = 'Sina alustasid vestlust kasutajatega {{users}}';
z.string.et.conversationCreatedYouMore = 'Sina alustasid vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreateWithMore = 'kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreateTeam = '[showmore]kikide meeskonnaliikmetega[/showmore]';
z.string.et.conversationCreateTeamGuest = '[showmore]kikide meeskonnaliikmete ja he klalisega[/showmore]';
z.string.et.conversationCreateTeamGuests = '[showmore]kikide meeskonnaliikmete ja {{count}} klalisega[/showmore]';
z.string.et.conversationMemberJoined = '[bold]{{name}}[/bold] lisas vestlusesse {{users}}';
z.string.et.conversationMemberJoinedYou = '[bold]Sina[/bold] lisasid vestlusesse {{users}}';
z.string.et.conversationMemberJoinedMore = '[bold]{{name}}[/bold] lisas vestlusesse {{users}} ja [showmore]{{count}} teist[/showmore]';
z.string.et.conversationMemberJoinedYouMore = '[bold]Sina[/bold] lisasid vestlusesse {{users}} ja [showmore]{{count}} teist[/showmore]';
z.string.et.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] liitus';
z.string.et.conversationMemberJoinedSelfYou = '[bold]Sina[/bold] liitusid';
z.string.et.conversationMemberLeft = '[bold]{{name}}[/bold] lahkus';
z.string.et.conversationMemberLeftYou = '[bold]Sina[/bold] lahkusid';
z.string.et.conversationMemberRemoved = '[bold]{{name}}[/bold] eemaldas {{users}}';
z.string.et.conversationMemberRemovedYou = '[bold]Sina[/bold] eemaldasid {{users}}';
z.string.et.conversationTeamLeft = '[bold]{{name}}[/bold] eemaldati meeskonnast';
z.string.et.conversationMessageDelivered = 'Kohale toimetatud';
z.string.et.conversationRename = ' nimetas vestluse mber';
z.string.et.conversationRenameYou = ' nimetasid vestluse mber';
z.string.et.conversationUpdatedTimer = ' mras snumi taimeriks {{time}}';
z.string.et.conversationUpdatedTimerYou = ' mras snumi taimeriks {{time}}';
z.string.et.conversationResetTimer = ' llitas snumi taimeri vlja';
z.string.et.conversationResetTimerYou = ' llitas snumi taimeri vlja';
z.string.et.conversationResume = 'Alusta vestlust kasutajatega {{users}}';
z.string.et.conversationPing = ' pingis';
z.string.et.conversationPingYou = ' pingisid';
z.string.et.conversationToday = 'tna';
z.string.et.conversationVoiceChannelDeactivate = ' helistas';
z.string.et.conversationVoiceChannelDeactivateYou = ' helistasid';
z.string.et.conversationYesterday = 'Eile';
z.string.et.conversationUnableToDecrypt1 = 'snumit kasutajalt {{user}} ei vetud vastu.';
z.string.et.conversationUnableToDecrypt2 = 'Kasutaja {{user}} seadme identiteet muutus. Snumit ei saadetud.';
z.string.et.conversationUnableToDecryptLink = 'Miks?';
z.string.et.conversationUnableToDecryptErrorMessage = 'Viga';
z.string.et.conversationUnableToDecryptResetSession = 'Lhtesta seanss';
z.string.et.conversationMissedMessages = 'Sa ei ole seda seadet mnda aega kasutanud. Osad snumid ei pruugi siia ilmuda.';
z.string.et.conversationAssetUploading = 'leslaadimine';
z.string.et.conversationAssetDownloading = 'Allalaadimine';
z.string.et.conversationAssetUploadFailed = 'leslaadimine ebannestus';
z.string.et.conversationPlaybackError = 'Ei saa esitada';
z.string.et.conversationContextMenuCopy = 'Kopeeri';
z.string.et.conversationContextMenuEdit = 'Muuda';
z.string.et.conversationContextMenuDelete = 'Kustuta minu jaoks';
z.string.et.conversationContextMenuDeleteEveryone = 'Kustuta kigi jaoks';
z.string.et.conversationContextMenuDownload = 'Laadi alla';
z.string.et.conversationContextMenuLike = 'Meeldib';
z.string.et.conversationContextMenuReply = 'Vasta';
z.string.et.conversationContextMenuUnlike = 'Eemalda meeldimine';
z.string.et.conversationDeleteTimestamp = 'Kustutati kuupeval {{date}}';
z.string.et.conversationEditTimestamp = 'Muudeti kuupeval {{date}}';
z.string.et.conversationLikesCaption = '{{number}} inimest';
z.string.et.conversationSendPastedFile = 'Kleepis pildi kuupeval {{date}}';
z.string.et.conversationSomeone = 'Keegi';
z.string.et.conversationTweetAuthor = ' Twitteris';
z.string.et.conversationServicesWarning = 'Teenustel on ligips selle vestluse sisule';

z.string.et.groupCreationPreferencesAction = 'Jrgmine';
z.string.et.groupCreationPreferencesErrorNameShort = 'Vhemalt 1 themrk';
z.string.et.groupCreationPreferencesErrorNameLong = 'Liiga palju themrke';
z.string.et.groupCreationPreferencesHeader = 'Uus grupp';
z.string.et.groupCreationPreferencesPlaceholder = 'Grupi nimi';
z.string.et.groupCreationParticipantsActionCreate = 'Valmis';
z.string.et.groupCreationParticipantsActionSkip = 'Jta vahele';
z.string.et.groupCreationParticipantsHeader = 'Lisa inimesi';
z.string.et.groupCreationParticipantsHeaderWithCounter = 'Lisa inimesi ({{number}})';
z.string.et.groupCreationParticipantsPlaceholder = 'Otsi nime jrgi';
z.string.et.groupSizeInfo = 'Grupivestlusega saab liituda kuni {{count}} inimest. Videokned ttavad kuni 4 osalejaga grupis.';

z.string.et.guestRoomConversationName = 'Klalistetuba';
z.string.et.guestRoomToggleName = 'Luba klalisi';
z.string.et.guestRoomToggleInfo = 'Ava see vestlus meeskonnast vljas olevatele inimestele.';
z.string.et.guestRoomToggleInfoExtended = 'Ava see vestlus meeskonnast vljas olevatele inimestele. Sa saad seda alati hiljem muuta.';

z.string.et.guestRoomConversationBadge = 'Kohal on klalisi';
z.string.et.guestRoomConversationBadgeService = 'Kohal on teenuseid';
z.string.et.guestRoomConversationBadgeGuestAndService = 'Kohal on klalisi ja teenuseid';

z.string.et.guestRoomConversationHead = 'Inimesed vljaspool sinu meeskonda saavad liituda selle vestlusega.';
z.string.et.guestRoomConversationButton = 'Kutsu inimesi';

z.string.et.collectionShowAll = 'Kuva kik {{number}}';
z.string.et.collectionSectionLinks = 'Lingid';
z.string.et.collectionSectionImages = 'Pildid';
z.string.et.collectionSectionFiles = 'Failid';
z.string.et.collectionSectionAudio = 'Helisnumid';

z.string.et.fullsearchPlaceholder = 'Otsi tekstsnumeid';
z.string.et.fullsearchNoResults = 'Tulemusi ei leitud.';

z.string.et.archiveHeader = 'Arhiveeri';

z.string.et.conversationsAllArchived = 'Kik on arhiveeritud';
z.string.et.conversationsContacts = 'Kontaktid';
z.string.et.conversationsConnectionRequestMany = '{{number}} inimest ootel';
z.string.et.conversationsConnectionRequestOne = '1 inimene on ootel';
z.string.et.conversationsEmptyConversation = 'Grupivestlus';
z.string.et.conversationsNoConversations = 'Alusta vestlust vi loo grupp.';
z.string.et.conversationsPopoverArchive = 'Arhiveeri vestlus';
z.string.et.conversationsPopoverBlock = 'Blokeeri kontakt';
z.string.et.conversationsPopoverCancel = 'Thista taotlus';
z.string.et.conversationsPopoverClear = 'Kustuta sisu';
z.string.et.conversationsPopoverLeave = 'Lahku grupist';
z.string.et.conversationsPopoverNotificationSettings = 'Teated';
z.string.et.conversationsPopoverNotify = 'Eemalda vestluse vaigistus';
z.string.et.conversationsPopoverSilence = 'Vaigista vestlus';
z.string.et.conversationsPopoverUnarchive = 'Taasta vestlus arhiivist';

z.string.et.conversationsSecondaryLineEphemeralMention = 'Mainis sind';
z.string.et.conversationsSecondaryLineEphemeralMentionGroup = 'Keegi mainis sind';
z.string.et.conversationsSecondaryLineEphemeralMessage = 'Saatis sulle snumi';
z.string.et.conversationsSecondaryLineEphemeralMessageGroup = 'Keegi saatis snumi';
z.string.et.conversationsSecondaryLineEphemeralReply = 'Vastas sulle';
z.string.et.conversationsSecondaryLineEphemeralReplyGroup = 'Keegi vastas sulle';
z.string.et.conversationsSecondaryLineIncomingCall = '{{user}} helistab';
z.string.et.conversationsSecondaryLinePeopleLeft = '{{number}} inimest lahkusid';
z.string.et.conversationsSecondaryLinePersonLeft = '{{user}} lahkus';
z.string.et.conversationsSecondaryLinePersonRemoved = '{{user}} eemaldati';
z.string.et.conversationsSecondaryLinePersonRemovedTeam = '{{user}} eemaldati meeskonnast';
z.string.et.conversationsSecondaryLinePeopleAdded = '{{user}} inimest lisati';
z.string.et.conversationsSecondaryLinePersonAdded = '{{user}} lisati';
z.string.et.conversationsSecondaryLinePersonAddedSelf = '{{user}} liitus';
z.string.et.conversationsSecondaryLinePersonAddedYou = '{{user}} lisas sind';
z.string.et.conversationsSecondaryLineRenamed = '{{user}} nimetas vestluse mber';
z.string.et.conversationsSecondaryLineSummaryMessage = '{{number}} snum';
z.string.et.conversationsSecondaryLineSummaryMessages = '{{number}} snumit';
z.string.et.conversationsSecondaryLineSummaryMention = '{{number}} mainimine';
z.string.et.conversationsSecondaryLineSummaryMentions = '{{number}} mainimist';
z.string.et.conversationsSecondaryLineSummaryMissedCall = '{{number}} vastamata kne';
z.string.et.conversationsSecondaryLineSummaryMissedCalls = '{{number}} vastamata knet';
z.string.et.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.et.conversationsSecondaryLineSummaryPings = '{{number}} pingi'
z.string.et.conversationsSecondaryLineSummaryReply = '{{number}} vastus';
z.string.et.conversationsSecondaryLineSummaryReplies = '{{number}} vastust';
z.string.et.conversationsSecondaryLineYouLeft = 'Sina lahkusid';
z.string.et.conversationsSecondaryLineYouWereRemoved = 'Sind eemaldati vestlusest';

z.string.et.takeoverSub = 'Haara oma unikaalne nimi Wireis.';
z.string.et.takeoverLink = 'Loe lhemalt';
z.string.et.takeoverButtonChoose = 'Vali enda oma';
z.string.et.takeoverButtonKeep = 'Vali see sama';

z.string.et.inviteMetaKeyMac = 'Cmd';
z.string.et.inviteMetaKeyPc = 'Ctrl';
z.string.et.inviteHintSelected = 'Kopeerimiseks vajuta {{metaKey}} + C';
z.string.et.inviteHintUnselected = 'Vali ja vajuta {{metaKey}} + C';
z.string.et.inviteHeadline = 'Kutsu inimesi Wireiga liituma';
z.string.et.inviteMessage = 'Kasutan suhtlemiseks Wire ppi. Mu kasutajanimi on {{username}}. Tmba pp siit get.wire.com';
z.string.et.inviteMessageNoEmail = 'Kasutan suhtluseks Wire ppi. Klasta get.wire.com et minuga suhelda.';

z.string.et.extensionsBubbleButtonGif = 'Gif';

z.string.et.extensionsGiphyButtonOk = 'Saada';
z.string.et.extensionsGiphyButtonMore = 'Proovi jrgmist';
z.string.et.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.et.extensionsGiphyNoGifs = 'Ups, gif-e pole';
z.string.et.extensionsGiphyRandom = 'Juhuslik';

z.string.et.addParticipantsConfirmLabel = 'Lisa';
z.string.et.addParticipantsHeader = 'Lisa inimesi';
z.string.et.addParticipantsHeaderWithCounter = 'Lisa inimesi ({{number}})';
z.string.et.addParticipantsManageServices = 'Halda teenuseid';
z.string.et.addParticipantsManageServicesNoResults = 'Halda teenuseid';
z.string.et.addParticipantsNoServicesManager = 'Teenused on abistajad, mis vivad aidata sul tid teha.';
z.string.et.addParticipantsNoServicesMember = 'Teenused on abistajad, mis vivad aidata sul tid teha. Nende lubamiseks ksi oma administraatorilt.';
z.string.et.addParticipantsSearchPlaceholder = 'Otsi nime jrgi';
z.string.et.addParticipantsServiceConfirmButton = 'Lisa teenus';
z.string.et.addParticipantsTabsPeople = 'Inimesed';
z.string.et.addParticipantsTabsServices = 'Teenused';

z.string.et.conversationDetailsActionArchive = 'Arhiveeri vestlus';
z.string.et.conversationDetailsActionAddParticipants = 'Lisa osalejaid';
z.string.et.conversationDetailsActionBlock = 'Blokeeri kontakt';
z.string.et.conversationDetailsActionCancelRequest = 'Thista taotlus';
z.string.et.conversationDetailsActionClear = 'Kustuta sisu';
z.string.et.conversationDetailsActionConversationParticipants = 'Kuva kik ({{number}})';
z.string.et.conversationDetailsActionCreateGroup = 'Uus grupp';
z.string.et.conversationDetailsActionDevices = 'Seadmed';
z.string.et.conversationDetailsActionGuestOptions = 'Klaliste valikud';
z.string.et.conversationDetailsActionTimedMessages = 'Kustuvad snumid';
z.string.et.conversationDetailsActionNotifications = 'Teated';
z.string.et.conversationDetailsActionLeave = 'Lahku grupist';
z.string.et.conversationDetailsGuestsOff = 'Vljas';
z.string.et.conversationDetailsGuestsOn = 'Sees';
z.string.et.conversationDetailsOptions = 'Valikud';
z.string.et.conversationDetailsParticipantsServicesOne = 'Teenus';
z.string.et.conversationDetailsParticipantsServicesMany = 'Teenused';
z.string.et.conversationDetailsParticipantsUsersOne = 'Inimene';
z.string.et.conversationDetailsParticipantsUsersMany = 'Inimesed';
z.string.et.conversationDetailsPeople = 'Inimesed';
z.string.et.conversationDetailsServices = 'Teenused';

z.string.et.conversationParticipantsTitle = 'Inimesed';
z.string.et.conversationParticipantsSearchPlaceholder = 'Otsi nime jrgi';

z.string.et.groupParticipantActionBlock = 'Blokeeri kontakt';
z.string.et.groupParticipantActionCancelRequest = 'Thista taotlus';
z.string.et.groupParticipantActionDevices = 'Seadmed';
z.string.et.groupParticipantActionIgnoreRequest = 'Ignoreeri taotlust';
z.string.et.groupParticipantActionIncomingRequest = 'Nustu taotlusega';
z.string.et.groupParticipantActionLeave = 'Lahku grupist';
z.string.et.groupParticipantActionOpenConversation = 'Ava vestlus';
z.string.et.groupParticipantActionPending = 'Ootel';
z.string.et.groupParticipantActionRemove = 'Eemalda grupist';
z.string.et.groupParticipantActionSelfProfile = 'Ava profiil';
z.string.et.groupParticipantActionSendRequest = 'hendu';
z.string.et.groupParticipantActionUnblock = 'Thista kontakti blokeering';

z.string.et.guestOptionsCopyLink = 'Kopeeri link';
z.string.et.guestOptionsCopyLinkDone = 'Link kopeeritud!';
z.string.et.guestOptionsCreateLink = 'Loo link';
z.string.et.guestOptionsInfoHeader = 'Kutsu teisi lingi abil';
z.string.et.guestOptionsInfoText = 'Igaks saab liituda selle lingiga vestlusesse 24 tunniks, isegi kui neil pole Wirei.';
z.string.et.guestOptionsRevokeLink = 'Thista link';
z.string.et.guestOptionsTitle = 'Klaliste valikud';

z.string.et.notificationSettingsTitle = 'Teated';
z.string.et.notificationSettingsDisclaimer = 'Sind teavitatakse kigest (s.h. hl- ja videokned) vi ainult siis, kui sind mainitakse.';
z.string.et.notificationSettingsEverything = 'Kik';
z.string.et.notificationSettingsMentionsAndReplies = 'Mainimised ja vastused';
z.string.et.notificationSettingsNothing = 'Puuduvad';

z.string.et.timedMessagesTitle = 'Kustuvad snumid';
z.string.et.timedMessageDisclaimer = 'Kustuvad snumid llitatatakse kikide osalejate jaoks sisse selles vestluses.';

z.string.et.participantDevicesDetailHeadline = 'Veendu, et see vastab {{html1}}kasutaja {{user}} seadmel{{html2}} kuvatud srmejljele.';
z.string.et.participantDevicesDetailHowTo = 'Kuidas ma seda teen?';
z.string.et.participantDevicesDetailResetSession = 'Lhtesta seanss';
z.string.et.participantDevicesDetailShowMyDevice = 'Nita mu seadme srmejlge';
z.string.et.participantDevicesDetailVerify = 'Kinnitatud';

z.string.et.participantDevicesHeader = 'Seadmed';
z.string.et.participantDevicesHeadline = 'Wire annab igale seadmele unikaalse srmejlje. Vrdle neid kasutajaga {{user}} ja kinnita oma vestlus.';
z.string.et.participantDevicesLearnMore = 'Loe lhemalt';
z.string.et.participantDevicesWhyVerify = 'Miks vestluste turvalisust kontrollida?';
z.string.et.participantDevicesOutdatedClientMessage = '{{user}} kasutab vana Wirei versiooni. Seadmete kohta puudub info.';

z.string.et.participantDevicesSelfAllDevices = 'Nita kiki mu seadmeid';
z.string.et.participantDevicesSelfFingerprint = 'Seadme srmejlg';

z.string.et.userProfileButtonConnect = 'hendu';
z.string.et.userProfileButtonIgnore = 'Ignoreeri';
z.string.et.userProfileButtonUnblock = 'Eemalda blokeering';

z.string.et.preferencesAbout = 'Teave';
z.string.et.preferencesAccount = 'Konto';
z.string.et.preferencesAV = 'Audio/video';
z.string.et.preferencesDeviceDetails = 'Seadme ksikasjad';
z.string.et.preferencesDevices = 'Seadmed';
z.string.et.preferencesHeadline = 'Eelistused';
z.string.et.preferencesOptions = 'Valikud';

z.string.et.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.et.preferencesAboutPrivacyPolicy = 'Privaatsuspoliitika';
z.string.et.preferencesAboutSupport = 'Klienditugi';
z.string.et.preferencesAboutSupportWebsite = 'Kasutajatoe veebisait';
z.string.et.preferencesAboutSupportContact = 'Vta kasutajatoega hendust';
z.string.et.preferencesAboutTermsOfUse = 'Kasutustingimused';
z.string.et.preferencesAboutVersion = 'Versioon {{version}}';
z.string.et.preferencesAboutWebsite = 'Wirei koduleht';

z.string.et.preferencesAccountAvaibilityUnset = 'Sea olek';
z.string.et.preferencesAccountCreateTeam = 'Loo meeskond';
z.string.et.preferencesAccountData = 'Andmekasutuse igused';
z.string.et.preferencesAccountDataCheckbox = 'Saada anonmseid andmeid';
z.string.et.preferencesAccountDataDetail = 'Aita Wirei paremaks muuta, saates anonmseid kasutus- ja krahhiaruandeid.';
z.string.et.preferencesAccountDelete = 'Kustuta konto';
z.string.et.preferencesAccountLeaveGuestRoom = 'Lahku klalistetoast';
z.string.et.preferencesAccountLeaveGuestRoomDescription = 'Sa ei saa enam selle vestluse snumitele ligi.';
z.string.et.preferencesAccountLogOut = 'Logi vlja';
z.string.et.preferencesAccountManageTeam = 'Meeskonna haldamine';
z.string.et.preferencesAccountMarketingConsentCheckbox = 'Saa uudiskirja';
z.string.et.preferencesAccountMarketingConsentDetail = 'Saa Wireilt uudiseid ja tooteuuendusi e-posti teel.';
z.string.et.preferencesAccountResetPassword = 'Lhesta parool';
z.string.et.preferencesAccountTeam = 'vestluses {{name}}';
z.string.et.preferencesAccountUsernamePlaceholder = 'Sinu tisnimi';
z.string.et.preferencesAccountUsernameHint = 'Vhemalt 2 themrki. Ainult a-z, 0-9 ja _.';
z.string.et.preferencesAccountUsernameAvailable = 'Saadaval';
z.string.et.preferencesAccountUsernameErrorTaken = 'Juba kasutusel';

z.string.et.preferencesAVCamera = 'Kaamera';
z.string.et.preferencesAVMicrophone = 'Mikrofon';
z.string.et.preferencesAVPermissionDetail = 'Luba oma brauseri Eelistustest';
z.string.et.preferencesAVSpeakers = 'Klarid';
z.string.et.preferencesAVTemporaryDisclaimer = 'Klalised ei saa alustada videokonverentse. Vali kasutatav kaamera, kui liitud mnega.';
z.string.et.preferencesAVNoCamera = 'Wire ei saa kaamerale ligi.[br][faqLink]Loe seda tugiartiklit[/faqLink] et parandada see probleem.';
z.string.et.preferencesAVTryAgain = 'Proovi uuesti';

z.string.et.preferencesDevicesActivatedOn = 'Aktiveeritud kuupeval {{date}}';
z.string.et.preferencesDevicesActive = 'Aktiivne';
z.string.et.preferencesDevicesActiveDetail = 'Kui sa ei tunne mnda lalolevat seadet ra, eemalda see ja lhtesta oma parool.';
z.string.et.preferencesDevicesCurrent = 'Praegune';
z.string.et.preferencesDevicesFingerprint = 'Vtme srmejlg';
z.string.et.preferencesDevicesFingerprintDetail = 'Wire annab igale seadmele unikaalse srmejlje. Vrdle neid ja kinnita oma seadmed ning vestlused.';
z.string.et.preferencesDevicesId = 'ID: ';
z.string.et.preferencesDevicesRemove = 'Eemalda';
z.string.et.preferencesDevicesRemoveCancel = 'Thista';
z.string.et.preferencesDevicesRemoveDetail = 'Eemalda see seade kui oled lpetanud selle kasutamise. Sind logitakse koheselt seadmest vlja.';
z.string.et.preferencesDevicesSessionConfirmation = 'Sessioon on lhtestatud.';
z.string.et.preferencesDevicesSessionDetail = 'Kui srmejljed ei kattu, lhtesta sessioon, et luua mlemal poolel uued krpteerimisvtmed.';
z.string.et.preferencesDevicesSessionReset = 'Lhtesta seanss';
z.string.et.preferencesDevicesSessionOngoing = 'Seansi lhtestamine';
z.string.et.preferencesDevicesVerification = 'Kinnitatud';

z.string.et.preferencesOptionsAudio = 'Heliteated';
z.string.et.preferencesOptionsAudioAll = 'Kik';
z.string.et.preferencesOptionsAudioAllDetail = 'Kik helid';
z.string.et.preferencesOptionsAudioNone = 'Puudub';
z.string.et.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.et.preferencesOptionsAudioSome = 'Mned';
z.string.et.preferencesOptionsAudioSomeDetail = 'Pingid ja kned';
z.string.et.preferencesOptionsContacts = 'Kontaktid';
z.string.et.preferencesOptionsContactsGmail = 'Impordi Gmailist';
z.string.et.preferencesOptionsContactsMacos = 'Impordi kontaktidest';
z.string.et.preferencesOptionsContactsDetail = 'Me kasutame su kontakte, et hendada sind teistega. Me muudame kogu info anonmseks ja ei jaga seda kellegi teisega.';
z.string.et.preferencesOptionsPopular = 'Publiku nudmisel';
z.string.et.preferencesOptionsEmojiReplaceCheckbox = 'Asenda kirjutatud emotikonid emojidega';
z.string.et.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.et.preferencesOptionsPreviewsSendCheckbox = 'Loo eelvaateid saadetavatele linkidele';
z.string.et.preferencesOptionsPreviewsSendDetail = 'Eelvaateid vidakse siiski nidata teiste inimeste linkide puhul.';
z.string.et.preferencesOptionsNotifications = 'Teated';
z.string.et.preferencesOptionsNotificationsNone = 'Vljas';
z.string.et.preferencesOptionsNotificationsObfuscate = 'Peida ksikasjad';
z.string.et.preferencesOptionsNotificationsObfuscateMessage = 'Kuva saatjat';
z.string.et.preferencesOptionsNotificationsOn = 'Kuva saatjat ja snumit';
z.string.et.preferencesOptionsCallLogs = 'Veaotsing';
z.string.et.preferencesOptionsCallLogsGet = 'Salvesta kne silumisraport';
z.string.et.preferencesOptionsCallLogsDetail = 'See teave aitab Wire kasutajatoel leida helistamise probleeme.';

z.string.et.preferencesOptionsBackupHeader = 'Ajalugu';
z.string.et.preferencesOptionsBackupExportHeadline = 'Varunda vestlused';
z.string.et.preferencesOptionsBackupExportSecondary = 'Loo varundus, et silitada oma vestlusajalugu. Sa saad seda kasutada, et taastada ajalugu, kui kaotad oma arvuti vi hakkad kasutama uut.\nVarundusfail ei ole kaitstud Wirei otsast-otsani krpteeringuga, seega hoia seda turvalises kohas.';
z.string.et.preferencesOptionsBackupImportHeadline = 'Taasta varundusest';
z.string.et.preferencesOptionsBackupImportSecondary = 'Sa saad taastada ajalugu ainult sama platvormi varundusest. Sinu varundus kirjutab le vestlused, mis sul vivad selles seadmes olla.';

z.string.et.backupExportGenericErrorHeadline = 'Faili ei saanud salvestada';
z.string.et.backupExportGenericErrorSecondary = 'Varundust ei viidud lpule.';
z.string.et.backupExportProgressHeadline = 'Ettevalmistamine';
z.string.et.backupExportProgressSecondary = 'Varundamine  {{processed}} / {{total}}  {{progress}}%';
z.string.et.backupExportProgressCompressing = 'Valmistan varundusfaili ette';
z.string.et.backupExportSaveFileAction = 'Salvesta fail';
z.string.et.backupExportSuccessHeadline = 'Varundus valmis';
z.string.et.backupExportSuccessSecondary = 'Sa saad seda kasutada, et taastada ajalugu, kui kaotad oma arvuti vi hakkad kasutama uut.';
z.string.et.backupImportGenericErrorHeadline = 'Midagi lks valesti';
z.string.et.backupImportGenericErrorSecondary = 'Sinu ajalugu ei saanud taastada.';
z.string.et.backupImportAccountErrorHeadline = 'Vale varundus';
z.string.et.backupImportAccountErrorSecondary = 'Sa ei saa taastada teise konto ajalugu.';
z.string.et.backupImportVersionErrorHeadline = 'hildumatu varundus';
z.string.et.backupImportVersionErrorSecondary = 'See varundus loodi uuema vi aegunud Wirei versiooni kaudu ja seda ei saa siin taastada.';
z.string.et.backupImportIncompatibleErrorHeadline = 'Vale varundus';
z.string.et.backupImportIncompatibleErrorSecondary = 'Sa ei saa taastada teise konto ajalugu.';
z.string.et.backupImportOutdatedErrorHeadline = 'hildumatu varundus';
z.string.et.backupImportOutdatedErrorSecondary = 'See varundus loodi uuema vi aegunud Wirei versiooni kaudu ja seda ei saa siin taastada.';
z.string.et.backupImportProgressHeadline = 'Ettevalmistamine';
z.string.et.backupImportProgressSecondary = 'Taastan ajalugu  {{processed}} / {{total}}  {{progress}}%';
z.string.et.backupImportSuccessHeadline = 'Ajalugu taastatud.';
z.string.et.backupCancel = 'Thista';
z.string.et.backupTryAgain = 'Proovi uuesti';

z.string.et.searchConnect = 'hendu';
z.string.et.searchConnections = 'hendused';
z.string.et.searchContacts = 'Kontaktid';
z.string.et.searchCreateGroup = 'Loo grupp';
z.string.et.searchCreateGuestRoom = 'Loo klalistetuba';
z.string.et.searchGroups = 'Grupid';
z.string.et.searchPeople = 'Inimesed';
z.string.et.searchPlaceholder = 'Otsi nime vi kasutajanime jrgi';
z.string.et.searchServicePlaceholder = 'Otsi nime jrgi';
z.string.et.searchServices = 'Teenused';
z.string.et.searchManageServices = 'Halda teenuseid';
z.string.et.searchManageServicesNoResults = 'Halda teenuseid';
z.string.et.searchNoServicesManager = 'Teenused on abistajad, mis vivad aidata sul tid teha.';
z.string.et.searchNoServicesMember = 'Teenused on abistajad, mis vivad aidata sul tid teha. Nende lubamiseks ksi oma administraatorilt.';
z.string.et.searchTeamGroups = 'Meeskonnavestlused';
z.string.et.searchTeamMembers = 'Meeskonnaliikmed';
z.string.et.searchTopPeople = 'Lemmikinimesed';
z.string.et.searchTrySearch = 'Leia inimesi\nnime vi kasutajanime jrgi';
z.string.et.searchNoContactsOnWire = 'Sul pole Wireis htegi kontakti.\nProovi inimesi leida\nnime vi kasutajanime jrgi.';
z.string.et.searchMemberInvite = 'Kutsu inimesi meeskonnaga liituma';
z.string.et.searchOthers = 'hendu';

z.string.et.searchInvite = 'Kutsu inimesi Wireiga liituma';
z.string.et.searchInviteDetail = 'Kontaktide jagamine aitab sul teistega henduda. Me muudame kogu info anonmseks ja ei jaga seda kellegi teisega.';
z.string.et.searchInviteButtonContacts = 'Kontaktidest';
z.string.et.searchInviteButtonGmail = 'Gmailist';
z.string.et.searchInviteHeadline = 'Too oma sbrad';
z.string.et.searchInviteShare = 'Jaga kontakte';

z.string.et.searchServiceConfirmButton = 'Lisa teenus';

z.string.et.searchListEveryoneParticipates = 'Kik sinu\nkontaktid on juba\nselles vestluses.';
z.string.et.searchListNoMatches = 'Sobivaid tulemusi ei leitud.\nProovi sisestada mni muu nimi.';

z.string.et.temporaryGuestCta = 'Loo konto';
z.string.et.temporaryGuestDescription = 'Turva oma ri krptitud grupi snumside ja knedega.';
z.string.et.temporaryGuestTimeRemaining = ' jnud siin klalistetoas';

z.string.et.temporaryGuestJoinMessage = 'See vestlus muutub sulle saadavaks 24 tunniks.';
z.string.et.temporaryGuestJoinDescription = 'Kui sa lehe sulged vi laadid uuesti, kaotad ligipsu.';

z.string.et.temporaryGuestLeaveMessage = ' pole enam selles vestluses.';
z.string.et.temporaryGuestLeaveDescription = 'Kui sa lehe sulged vi laadid uuesti, kaotad ligipsu vestlusajaloole.';

z.string.et.uploadGoogleHeadline = 'Otsi inimesi\nkellega rkida.';
z.string.et.uploadGoogleMessage = 'Me kasutame su kontakte, et hendada sind teistega. Me muudame kogu info anonmseks ja ei jaga seda kellegi teisega.';

z.string.et.urlSupportRoot = '/';
z.string.et.urlSupportArticles = '/hc/en-us/articles/';
z.string.et.urlSupportRequests = '/hc/en-us/requests/';
z.string.et.urlWebappRoot = '/';
z.string.et.urlWebsiteRoot = '/';
z.string.et.urlWebsiteCreateTeam = '/create-team/';
z.string.et.urlWebsitePrivacy = '/privacy';
z.string.et.warningCallUnsupportedIncoming = '{{user}} helistab. Sinu brauser ei toeta knesid.';
z.string.et.warningCallUnsupportedOutgoing = 'Sa ei saa helistada, kuna sinu brauser ei toeta knesid.';
z.string.et.warningCallIssues = 'See Wirei versioon ei saa knes osaleda. Palun kasuta';
z.string.et.warningCallUpgradeBrowser = 'Helistamiseks palun uuenda Google Chromei.';
z.string.et.warningConnectivityConnectionLost = 'Proovin henduda. Wire ei pruugi snumeid edastada.';
z.string.et.warningConnectivityNoInternet = 'Internet puudub. Sa ei saa snumeid saata ega vastu vtta.';
z.string.et.warningLearnMore = 'Loe lhemalt';
z.string.et.warningLifecycleUpdate = 'Uus Wirei versioon on saadaval.';
z.string.et.warningLifecycleUpdateNotes = 'Mis on uut';
z.string.et.warningLifecycleUpdateLink = 'Uuenda nd';
z.string.et.warningNotFoundCamera = 'Sa ei saa knet teha, kuna su arvutil pole kaamerat.';
z.string.et.warningNotFoundMicrophone = 'Sa ei saa helistada, kuna su arvutil pole mikrofoni.';
z.string.et.warningPermissionDeniedCamera = 'Sa ei saa knet teha, kuna su brauseril pole kaamerale ligipsu.';
z.string.et.warningPermissionDeniedMicrophone = 'Sa ei saa helistada, kuna su brauseril pole mikrofonile ligipsu.';
z.string.et.warningPermissionDeniedScreen = 'Su brauser vajab ligipsu ekraani jagamiseks.';
z.string.et.warningPermissionRequestCamera = '{{icon}} Luba kaamerale juurdeps';
z.string.et.warningPermissionRequestMicrophone = '{{icon}} Luba mikrofonile juurdeps';
z.string.et.warningPermissionRequestNotification = '{{icon}} Luba teated';
z.string.et.warningPermissionRequestScreen = '{{icon}} Luba ekraanile juurdeps';

z.string.et.userAvailabilityAvailable = 'Saadaval';
z.string.et.userAvailabilityAway = 'Eemal';
z.string.et.userAvailabilityBusy = 'Hivatud';
z.string.et.userAvailabilityNone = 'Puudub';

z.string.et.notificationAssetAdd = 'Jagas pilti';
z.string.et.notificationConnectionAccepted = 'Nustus sinu hendamistaotlusega';
z.string.et.notificationConnectionConnected = 'Sa oled nd hendatud';
z.string.et.notificationConnectionRequest = 'Soovib henduda';
z.string.et.notificationConversationCreate = '{{user}} alustas vestlust';
z.string.et.notificationConversationMessageTimerUpdate = '{{user}} mras snumi taimeriks {{time}}';
z.string.et.notificationConversationMessageTimerReset = '{{user}} llitas snumi taimeri vlja';
z.string.et.notificationConversationRename = '{{user}} nimetas vestluse mber: {{name}}';
z.string.et.notificationMemberJoinMany = '{{user}} lisas vestlusesse {{number}} inimest';
z.string.et.notificationMemberJoinSelf = '{{user}} liitus vestlusega';
z.string.et.notificationMemberJoinOne = '{{user1}} lisas vestlusesse {{user2}}';
z.string.et.notificationMemberLeaveRemovedYou = '{{user}} eemaldas sind vestlusest';
z.string.et.notificationMention = 'Uus mainimine:';
z.string.et.notificationObfuscated = 'Saatis sulle snumi';
z.string.et.notificationObfuscatedMention = 'Mainis sind';
z.string.et.notificationObfuscatedReply = 'Vastas sulle';
z.string.et.notificationObfuscatedTitle = 'Keegi';
z.string.et.notificationPing = 'Pingis';
z.string.et.notificationReaction = '{{reaction}} su snum';
z.string.et.notificationReply = 'Vastus: {{text}}';
z.string.et.notificationSharedAudio = 'Jagas hlsnumit';
z.string.et.notificationSharedFile = 'Jagas faili';
z.string.et.notificationSharedLocation = 'Jagas asukohta';
z.string.et.notificationSharedVideo = 'Jagas videot';
z.string.et.notificationTitleGroup = '{{user}} vestluses {{conversation}}';
z.string.et.notificationVoiceChannelActivate = 'Helistamine';
z.string.et.notificationVoiceChannelDeactivate = 'helistas';

z.string.et.tooltipConversationAllVerified = 'Kik srmejljed on kinnitatud';
z.string.et.tooltipConversationCall = 'Kne';
z.string.et.tooltipConversationEphemeral = 'Kustuv snum';
z.string.et.tooltipConversationFile = 'Lisa fail';
z.string.et.tooltipConversationInputPlaceholder = 'Kirjuta snum';
z.string.et.tooltipConversationInputPlaceholderAvailable = '{{user}} on saadaval';
z.string.et.tooltipConversationInputPlaceholderAway = '{{user}} on eemal';
z.string.et.tooltipConversationInputPlaceholderBusy = '{{user}} on hivatud';
z.string.et.tooltipConversationPeople = 'Inimesed ({{shortcut}})';
z.string.et.tooltipConversationPicture = 'Lisa pilt';
z.string.et.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.et.tooltipConversationSearch = 'Otsing';
z.string.et.tooltipConversationVideoCall = 'Videokne';

z.string.et.tooltipConversationsArchive = 'Arhiveeri ({{shortcut}})';
z.string.et.tooltipConversationsArchived = 'Kuva arhiiv ({{number}})';
z.string.et.tooltipConversationsMore = 'Veel';
z.string.et.tooltipConversationsNotifications = 'Ava teadete seaded ({{shortcut}})';
z.string.et.tooltipConversationsNotify = 'Eemalda vaigistus ({{shortcut}})';
z.string.et.tooltipConversationsPreferences = 'Ava eelistused';
z.string.et.tooltipConversationsSilence = 'Vaigista ({{shortcut}})';
z.string.et.tooltipConversationsStart = 'Alusta vestlust ({{shortcut}})';

z.string.et.tooltipConversationDetailsAddPeople = 'Lisa vestlusesse osalejaid ({{shortcut}})';
z.string.et.tooltipConversationDetailsRename = 'Muuda vestluse nime';

z.string.et.tooltipPreferencesContactsGmail = 'Logi oma Gmaili kontosse sisse, et jagada kontakte';
z.string.et.tooltipPreferencesContactsMacos = 'Jaga kiki oma kontakte macOS Kontaktide rakendusest';
z.string.et.tooltipPreferencesPassword = 'Ava teine veebileht oma parooli lhtestamiseks';
z.string.et.tooltipPreferencesPicture = 'Muuda oma pilti';
z.string.et.tooltipPreferencesRename = 'Muuda oma nime';

z.string.et.tooltipSearchClose = 'Sulge (Esc)';

z.string.et.initReceivedSelfUser = 'Tere, {{user}}.';
z.string.et.initValidatedClient = 'Toon hendusi ja vestlusi';
z.string.et.initReceivedUserData = 'Kontrollin uusi snumeid';
z.string.et.initDecryption = 'Dekrptin snumeid';
z.string.et.initEvents = 'Laadin snumeid';
z.string.et.initUpdatedFromNotifications = 'Peaaegu valmis - naudi Wirei';
z.string.et.initProgress = '  {{number1}}/{{number2}}';

z.string.et.ephemeralUnitsNone = 'Vljas';
z.string.et.ephemeralUnitsSecond = 'sekund';
z.string.et.ephemeralUnitsSeconds = 'sekundit';
z.string.et.ephemeralUnitsMinute = 'minut';
z.string.et.ephemeralUnitsMinutes = 'minutit';
z.string.et.ephemeralUnitsHour = 'tund';
z.string.et.ephemeralUnitsHours = 'tundi';
z.string.et.ephemeralUnitsDay = 'pev';
z.string.et.ephemeralUnitsDays = 'peva';
z.string.et.ephemeralUnitsWeek = 'ndal';
z.string.et.ephemeralUnitsWeeks = 'ndalat';
z.string.et.ephemeralUnitsYear = 'aasta';
z.string.et.ephemeralUnitsYears = 'aastat';
z.string.et.ephemeralRemaining = 'on jnud';

z.string.et.replyAudioMessage = 'Helisnum';
z.string.et.replyQuoteError = 'Sa ei saa seda snumit nha.';
z.string.et.replyQuoteShowMore = 'Kuva rohkem';
z.string.et.replyQuoteShowLess = 'Kuva vhem';
z.string.et.replyQuoteTimeStampDate = 'Originaalsnum ajast {{date}}';
z.string.et.replyQuoteTimeStampTime = 'Originaalsnum kellast {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.fi.wireMacos = 'Wire macOS: lle';
z.string.fi.wireWindows = 'Wire Windowsille';
z.string.fi.wireLinux = 'Wire Linuxille';
z.string.fi.nonexistentUser = 'Poistettu kyttj';
z.string.fi.and = 'ja';

z.string.fi.authAccountCountryCode = 'Maakoodi';
z.string.fi.authAccountPasswordForgot = 'Unohdin salasanani';
z.string.fi.authAccountPublicComputer = 'Tm on julkinen tietokone';
z.string.fi.authAccountSignIn = 'Kirjaudu sisn';
z.string.fi.authAccountSignInPhone = 'Puhelinnumero';

z.string.fi.authBlockedCookies = 'Salli evsteet kirjautuaksesi Wireen.';
z.string.fi.authBlockedDatabase = 'Wire tarvitsee psyn paikalliseen silsi silkseen viestej. Paikallinen sil ei ole saatavilla yksityisess tilassa.';
z.string.fi.authBlockedTabs = 'Wire on jo avoinna toisessa vlilehdess.';

z.string.fi.authVerifyAccountAdd = 'Lis';
z.string.fi.authVerifyAccountDetail = 'Tm mahdollistaa Wiren kytn useilla laitteilla.';
z.string.fi.authVerifyAccountHeadline = 'Lis shkpostiosoitteesi ja salasanasi.';
z.string.fi.authVerifyAccountLogout = 'Kirjaudu ulos';
z.string.fi.authVerifyCodeDescription = 'Syt vahvistuskoodi jonka lhetimme {{number}}.';
z.string.fi.authVerifyCodeResend = 'Eik koodi ole tullut perille?';
z.string.fi.authVerifyCodeResendDetail = 'Lhet uudelleen';
z.string.fi.authVerifyCodeResendTimer = 'Voit pyyt uuden koodin {{expiration}} kuluttua.';
z.string.fi.authVerifyCodeChangePhone = 'Vaihda puhelinnumero';
z.string.fi.authVerifyPasswordHeadline = 'Kirjoita salasanasi';

z.string.fi.authLimitDevicesHeadline = 'Laitteet';
z.string.fi.authLimitDescription = 'Poista yksi laitteistasi aloittaaksesi Wiren kytn tss laiteessa.';
z.string.fi.authLimitButtonManage = 'Hallitse laitteita';
z.string.fi.authLimitButtonSignOut = 'Kirjaudu ulos';
z.string.fi.authLimitDevicesCurrent = '(Nykyinen)';

z.string.fi.authHistoryHeadline = 'Kytt Wire ensimmist kertaa tll laitteella.';
z.string.fi.authHistoryDescription = 'Tietosuojasyist keskusteluhistoriasi ei ny tll.';
z.string.fi.authHistoryReuseHeadline = 'Olet kyttnyt Wire tll laitteella aiemmin.';
z.string.fi.authHistoryReuseDescription = 'Sill vlin lhetetyt viestit eivt ny tss.';
z.string.fi.authHistoryButton = 'OK';

z.string.fi.authPostedResend = 'Lhet uudelleen shkpostiosoitteeseen: {{email}}';
z.string.fi.authPostedResendAction = 'Eik shkposti saavu perille?';
z.string.fi.authPostedResendDetail = 'Tarkista shkpostisi saapuneet-kansio ja seuraa ohjeita.';
z.string.fi.authPostedResendHeadline = 'Sinulle on shkpostia.';

z.string.fi.authPlaceholderEmail = 'Shkposti';
z.string.fi.authPlaceholderPasswordPut = 'Salasana';
z.string.fi.authPlaceholderPasswordSet = 'Salasana (vhintn 8 merkki pitk)';
z.string.fi.authPlaceholderPhone = 'Puhelinnumero';

z.string.fi.authErrorCode = 'Virheellinen koodi';
z.string.fi.authErrorCountryCodeInvalid = 'Maakoodi ei kelpaa';
z.string.fi.authErrorEmailExists = 'Tlle shkpostille on jo luotu tunnus';
z.string.fi.authErrorEmailForbidden = 'Valitettavasti tm shkpostiosoite on kielletty.';
z.string.fi.authErrorEmailMalformed = 'Kirjoita voimassa oleva shkpostiosoite.';
z.string.fi.authErrorEmailMissing = 'Kirjoita shkpostiosoite.';
z.string.fi.authErrorMisc = 'Ongelmia yhteyden kanssa. Yrit uudelleen.';
z.string.fi.authErrorNameShort = 'Kirjoita nimi, jossa on vhintn 2 merkki';
z.string.fi.authErrorOffline = 'Ei internet-yhteytt';
z.string.fi.authErrorPasswordShort = 'Valitse salasana, jossa on vhintn 8 merkki.';
z.string.fi.authErrorPasswordWrong = 'Vr salasana. Yrit uudelleen.';
z.string.fi.authErrorPhoneNumberBudget = 'Kirjauduit sisn liian usein. Yrit myhemmin uudelleen.';
z.string.fi.authErrorPhoneNumberForbidden = 'Valitettavasti tm puhelinnumero on kielletty.';
z.string.fi.authErrorPhoneNumberInvalid = 'Virheellinen puhelinnumero';
z.string.fi.authErrorPhoneNumberUnknown = 'Tuntematon puhelinnumero';
z.string.fi.authErrorSuspended = 'Tm tili ei ole en oikeutettu kirjautumaan sisn.';
z.string.fi.authErrorSignIn = 'Vahvista tietosi ja yrit uudelleen.';

z.string.fi.callStateOutgoing = 'Soi';
z.string.fi.callStateConnecting = 'Yhdistetn';
z.string.fi.callStateIncoming = 'Soitetaan';
z.string.fi.callDecline = 'Kieltydy';
z.string.fi.callAccept = 'Hyvksy';
z.string.fi.callJoin = 'Liity';
z.string.fi.callChooseSharedScreen = 'Valitse nytt jonka haluat jakaa';
z.string.fi.callParticipants = '{{number}} puhelussa';

z.string.fi.videoCallOverlayMute = 'Mykist';
z.string.fi.videoCallOverlayHangUp = 'Katkaise puhelu';

z.string.fi.modalAcknowledgeAction = 'Ok';
z.string.fi.modalConfirmSecondary = 'Peruuta';
z.string.fi.modalOptionSecondary = 'Peruuta';

z.string.fi.modalAccountCreateAction = 'OK';

z.string.fi.modalAccountDeletionAction = 'Poista';
z.string.fi.modalAccountDeletionHeadline = 'Poista tili';
z.string.fi.modalAccountDeletionMessage = 'Lhetmme viestin shkpostina tai tekstiviestin. Paina viestiss olevaa linkki poistaaksesi tilisi lopullisesti.';

z.string.fi.modalAccountLeaveGuestRoomAction = 'Poistu';

z.string.fi.modalAccountLogoutAction = 'Kirjaudu ulos';
z.string.fi.modalAccountLogoutHeadline = 'Tyhjenn tiedot?';
z.string.fi.modalAccountLogoutOption = 'Poista kaikki henkilkohtaiset tiedot ja keskustelut tst laitteesta.';

z.string.fi.modalAccountNewDevicesSecondary = 'Hallitse laitteita';
z.string.fi.modalAccountNewDevicesHeadline = 'Tilisi kytettiin:';
z.string.fi.modalAccountNewDevicesFrom = 'Laite:';
z.string.fi.modalAccountNewDevicesMessage = 'Jos et tehnyt tt, poista laite ja vaihda salasanasi.';

z.string.fi.modalAccountRemoveDeviceAction = 'Poista laite';
z.string.fi.modalAccountRemoveDeviceHeadline = 'Poista "{{device}}"';
z.string.fi.modalAccountRemoveDeviceMessage = 'Sinun tytyy kirjoittaa salasanasi poistaaksesi laitteen.';
z.string.fi.modalAccountRemoveDevicePlaceholder = 'Salasana';

z.string.fi.modalAssetTooLargeMessage = 'Voit lhett maksimissaan {{number}} kokoisia tiedostoja';

z.string.fi.modalAssetParallelUploadsMessage = 'Voit lhett jopa {{number}} tiedostoa samaan aikaan.';

z.string.fi.modalCallEmptyConversationHeadline = 'Ei ketn kelle soittaa';
z.string.fi.modalCallEmptyConversationMessage = 'Tll ei ole ketn jljell.';

z.string.fi.modalCallNoGroupVideoHeadline = 'Ei videopuheluja ryhmiss';
z.string.fi.modalCallNoGroupVideoMessage = 'Videopuhelut eivt ole saatavilla ryhmkeskusteluissa.';

z.string.fi.modalCallNoMicrophoneAction = 'Kerro miten';
z.string.fi.modalCallNoMicrophoneMessage = 'Selaimellasi tytyy olla kyttoikeus mikrofoniisi voidaksesi kyd puhelinkeskusteluja.';
z.string.fi.modalCallNoMicrophoneHeadline = 'Et voi kyd puhelinkeskusteluja ilman mikrofonia';

z.string.fi.modalCallSecondIncomingAction = 'Vastaa';
z.string.fi.modalCallSecondIncomingHeadline = 'Vastaatko puheluun?';
z.string.fi.modalCallSecondIncomingMessage = 'Sinun tmnhetkinen puhelu pttyy.';

z.string.fi.modalCallSecondOngoingAction = 'Katkaise puhelu';
z.string.fi.modalCallSecondOngoingHeadline = 'Katkaise puhelu toisessa laitteessa?';
z.string.fi.modalCallSecondOngoingMessage = 'Voit olla vain yhdess puhelussa kerrallaan.';

z.string.fi.modalCallSecondOutgoingAction = 'Katkaise puhelu';
z.string.fi.modalCallSecondOutgoingHeadline = 'Katkaise nykyinen puhelu?';
z.string.fi.modalCallSecondOutgoingMessage = 'Voit olla vain yhdess puhelussa kerrallaan.';

z.string.fi.modalConnectCancelAction = 'Kyll';
z.string.fi.modalConnectCancelHeadline = 'Peruuta pyynt?';
z.string.fi.modalConnectCancelMessage = 'Poista yhteyspyynt {{user}}:lle.';
z.string.fi.modalConnectCancelSecondary = 'Ei';

z.string.fi.modalConnectAcceptAction = 'Yhdist';
z.string.fi.modalConnectAcceptHeadline = 'Hyvksy?';
z.string.fi.modalConnectAcceptMessage = 'Tm yhdist teidt ja avaa keskustelun {{user}} kanssa.';
z.string.fi.modalConnectAcceptSecondary = 'Hylk';

z.string.fi.modalConversationClearAction = 'Poista';
z.string.fi.modalConversationClearHeadline = 'Poista sislt?';
z.string.fi.modalConversationClearOption = 'Poistu mys keskustelusta';

z.string.fi.modalConversationDeleteMessageAction = 'Poista';
z.string.fi.modalConversationDeleteMessageHeadline = 'Poista ainoastaan minulta?';
z.string.fi.modalConversationDeleteMessageMessage = 'Tt ei voi perua.';

z.string.fi.modalConversationDeleteMessageEveryoneAction = 'Poista';
z.string.fi.modalConversationDeleteMessageEveryoneHeadline = 'Poista kaikilta?';
z.string.fi.modalConversationDeleteMessageEveryoneMessage = 'Tt ei voi perua.';

z.string.fi.modalConversationLeaveAction = 'Poistu';
z.string.fi.modalConversationLeaveMessage = 'Et pysty lhettmn tai vastaanottamaan viestej tss keskustelussa.';

z.string.fi.modalConversationMessageTooLongHeadline = 'Viesti on liian pitk';
z.string.fi.modalConversationMessageTooLongMessage = 'Voit lhett viestej joissa on maksimissaan {{number}} merkki.';

z.string.fi.modalConversationNewDeviceHeadlineOne = '{{user}} aloitti kyttmn uutta laitetta';
z.string.fi.modalConversationNewDeviceHeadlineMany = '{{users}} aloittivat kyttmn uusia laitteita';
z.string.fi.modalConversationNewDeviceHeadlineYou = '{{user}} aloitti kyttmn uutta laitetta';
z.string.fi.modalConversationNewDeviceIncomingCallAction = 'Vastaa puheluun';
z.string.fi.modalConversationNewDeviceIncomingCallMessage = 'Haluatko silti vastata puheluun?';
z.string.fi.modalConversationNewDeviceMessage = 'Haluatko viel silti lhett viestisi?';
z.string.fi.modalConversationNewDeviceOutgoingCallAction = 'Soita kuitenkin';
z.string.fi.modalConversationNewDeviceOutgoingCallMessage = 'Haluatko silti soittaa puhelun?';

z.string.fi.modalConversationNotConnectedHeadline = 'Ketn ei ole listty keskusteluun';
z.string.fi.modalConversationNotConnectedMessageOne = '{{name}} ei halua tulla listyksi keskusteluihin.';
z.string.fi.modalConversationNotConnectedMessageMany = 'Yksi valitsimistasi kyttjist ei halua tulla listyksi keskusteluihin.';

z.string.fi.modalConversationRemoveAction = 'Poista';
z.string.fi.modalConversationRemoveHeadline = 'Poista?';
z.string.fi.modalConversationRemoveMessage = '{{user}} ei pysty lhettmn tai vastaanottamaan viestej tss keskustelussa.';

z.string.fi.modalConversationRemoveGuestsAction = 'Poista';

z.string.fi.modalConversationTooManyMembersHeadline = 'Kaikki puhelukanavat varattuja';

z.string.fi.modalIntegrationUnavailableHeadline = 'Botit eivt kytettviss';
z.string.fi.modalIntegrationUnavailableMessage = 'Kiitos mielenkiinnostasi botteihin. Tm palvelu on vliaikaisesti pois kytst, koska tystmme seuraavaa versiota.';


z.string.fi.modalImproveWireAction = 'Hyvksy';
z.string.fi.modalImproveWireSecondary = 'Ei';

z.string.fi.modalSessionResetHeadline = 'Istunto on nollattu';
z.string.fi.modalSessionResetMessage1 = 'Jos ongelma ei ole ratkennut';
z.string.fi.modalSessionResetMessageLink = 'ota yhteys';
z.string.fi.modalSessionResetMessage2 = 'meihin.';

z.string.fi.modalUploadContactsAction = 'Yrit uudelleen';
z.string.fi.modalUploadContactsMessage = 'Emme vastaanottaneet tietojasi. Ole hyv ja yrit tuoda kontaktisi uudelleen.';

z.string.fi.modalUserBlockAction = 'Est';
z.string.fi.modalUserBlockHeadline = 'Est {{user}}?';
z.string.fi.modalUserBlockMessage = '{{user}} ei pysty ottamaan sinuun yhteytt tai lismn sinua ryhmkeskusteluihin.';

z.string.fi.modalUserUnblockAction = 'Poista esto';
z.string.fi.modalUserUnblockHeadline = 'Poista esto?';
z.string.fi.modalUserUnblockMessage = '{{user}} pystyy jlleen ottamaan sinuun yhteytt ja lismn sinut ryhmkeskusteluihin.';

z.string.fi.connectionRequestConnect = 'Yhdist';
z.string.fi.connectionRequestIgnore = 'Hylk';

z.string.fi.conversationGuestIndicator = 'Vieras';

z.string.fi.conversationYouNominative = 'sin';
z.string.fi.conversationYouDative = 'sin';
z.string.fi.conversationYouAccusative = 'sin';

z.string.fi.conversationConnectionAccepted = 'Yhdistetty';
z.string.fi.conversationConnectionBlocked = 'Estetty';
z.string.fi.conversationConnectionCancelRequest = 'Peruuta yhteyspyynt';
z.string.fi.conversationDeviceStartedUsingOne = ' aloitti kyttmn';
z.string.fi.conversationDeviceStartedUsingMany = ' aloitti kyttmn';
z.string.fi.conversationDeviceUnverified = ' vahvistamattomia yksi';
z.string.fi.conversationDeviceYourDevices = ' sinun laitteet';
z.string.fi.conversationDeviceUserDevices = ' {{user}} n laitteet';
z.string.fi.conversationDeviceNewDeviceOne = ' uutta laitetta';
z.string.fi.conversationDeviceNewDeviceMany = ' uusia laitteita';
z.string.fi.conversationDeviceNewPeopleJoinedVerify = ' vahvista laitteet';
z.string.fi.conversationJustNow = 'Juuri nyt';
z.string.fi.conversationLocationLink = 'Avaa kartta';
z.string.fi.conversationMessageDelivered = 'Toimitettu';
z.string.fi.conversationRename = ' keskustelun nimi vaihdettu';
z.string.fi.conversationRenameYou = ' keskustelun nimi vaihdettu';
z.string.fi.conversationResume = 'Aloita keskustelu {{users}} n kanssa';
z.string.fi.conversationPing = ' pinggasi';
z.string.fi.conversationPingYou = ' pinggasi';
z.string.fi.conversationToday = 'tnn';
z.string.fi.conversationVoiceChannelDeactivate = ' soitti';
z.string.fi.conversationVoiceChannelDeactivateYou = ' soitti';
z.string.fi.conversationYesterday = 'Eilen';
z.string.fi.conversationUnableToDecrypt1 = 'Kyttjn {{user}} viesti ei tullut perille.';
z.string.fi.conversationUnableToDecrypt2 = 'Kyttjn {{user}} laitteen identiteetti muuttui. Viesti ei toimitettu.';
z.string.fi.conversationUnableToDecryptLink = 'Miksi?';
z.string.fi.conversationUnableToDecryptErrorMessage = 'Virhe';
z.string.fi.conversationUnableToDecryptResetSession = 'Nollaa istunto';
z.string.fi.conversationMissedMessages = 'Et ole kyttnyt tt laitetta pitkn aikaan. Jotkut viestit eivt saata nky tll.';
z.string.fi.conversationAssetDownloading = 'Ladataan';
z.string.fi.conversationAssetUploadFailed = 'Lhetys eponnistui';
z.string.fi.conversationPlaybackError = 'Toisto eponnistui';
z.string.fi.conversationContextMenuCopy = 'Kopioi';
z.string.fi.conversationContextMenuEdit = 'Muokkaa';
z.string.fi.conversationContextMenuDelete = 'Poista minulta';
z.string.fi.conversationContextMenuDeleteEveryone = 'Poista kaikilta';
z.string.fi.conversationContextMenuDownload = 'Lataa';
z.string.fi.conversationContextMenuLike = 'Tykk';
z.string.fi.conversationContextMenuUnlike = 'Poista tykkys';
z.string.fi.conversationDeleteTimestamp = 'Poistettu {{date}}';
z.string.fi.conversationEditTimestamp = 'Muokattu {{date}}';
z.string.fi.conversationLikesCaption = '{{number}} henke';
z.string.fi.conversationSendPastedFile = 'Liitetty kuva, {{date}}';
z.string.fi.conversationSomeone = 'Joku';
z.string.fi.conversationTweetAuthor = ' Twitteriss';

z.string.fi.groupCreationPreferencesAction = 'Seuraava';
z.string.fi.groupCreationParticipantsActionCreate = 'Valmis';
z.string.fi.groupCreationParticipantsPlaceholder = 'Hae nimell';


z.string.fi.collectionShowAll = 'Nyt kaikki {{number}}';
z.string.fi.collectionSectionLinks = 'Linkit';
z.string.fi.collectionSectionImages = 'Kuvat';
z.string.fi.collectionSectionFiles = 'Tiedostot';
z.string.fi.collectionSectionAudio = 'niviestit';

z.string.fi.fullsearchPlaceholder = 'Etsi viestej';
z.string.fi.fullsearchNoResults = 'Ei tuloksia.';

z.string.fi.archiveHeader = 'Arkistoi';

z.string.fi.conversationsAllArchived = 'Kaikki arkistoitu';
z.string.fi.conversationsContacts = 'Yhteystiedot';
z.string.fi.conversationsConnectionRequestMany = '{{number}} ihmisi odottaa';
z.string.fi.conversationsConnectionRequestOne = '1 ihminen odottaa';
z.string.fi.conversationsEmptyConversation = 'Ryhmkeskustelu';
z.string.fi.conversationsNoConversations = 'Ei viel keskusteluita';
z.string.fi.conversationsPopoverArchive = 'Arkistoi';
z.string.fi.conversationsPopoverCancel = 'Peru pyynt';
z.string.fi.conversationsPopoverNotify = 'Poista mykistys';
z.string.fi.conversationsPopoverSilence = 'Mykist';
z.string.fi.conversationsPopoverUnarchive = 'Palauta arkistosta';

z.string.fi.conversationsSecondaryLineEphemeralMessage = 'Lhetti sinulle viestin';
z.string.fi.conversationsSecondaryLinePeopleLeft = '{{number}} henkil poistui';
z.string.fi.conversationsSecondaryLinePersonLeft = '{{user}} poistui';
z.string.fi.conversationsSecondaryLinePersonRemoved = '{{user}} poistettiin';
z.string.fi.conversationsSecondaryLinePeopleAdded = '{{user}} henkil listtiin';
z.string.fi.conversationsSecondaryLinePersonAdded = '{{user}} listtiin';
z.string.fi.conversationsSecondaryLinePersonAddedYou = '{{user}} lissi sinut';
z.string.fi.conversationsSecondaryLineRenamed = '{{user}} vaihtoi keskustelun nime';
z.string.fi.conversationsSecondaryLineYouLeft = 'Poistuit';
z.string.fi.conversationsSecondaryLineYouWereRemoved = 'Sinut poistettiin';

z.string.fi.takeoverSub = 'Valtaa yksilllinen nimesi Wiress.';
z.string.fi.takeoverLink = 'Lue lis';
z.string.fi.takeoverButtonChoose = 'Valitse omasi';
z.string.fi.takeoverButtonKeep = 'Pid tm';

z.string.fi.inviteMetaKeyMac = 'Cmd';
z.string.fi.inviteMetaKeyPc = 'Ctrl';
z.string.fi.inviteHeadline = 'Kutsu ihmisi Wireen';
z.string.fi.inviteMessage = 'Olen Wiress, etsi {{username}} tai mene osoitteeseen get.wire.com.';
z.string.fi.inviteMessageNoEmail = 'Olen Wiress. Mene osoitteeseen get.wire.com ottaaksesi minuun yhteytt.';

z.string.fi.extensionsBubbleButtonGif = 'Gif';

z.string.fi.extensionsGiphyButtonOk = 'Lhet';
z.string.fi.extensionsGiphyButtonMore = 'Kokeile toista';
z.string.fi.extensionsGiphyMessage = '{{tag}}  giphy.com:in kautta';
z.string.fi.extensionsGiphyNoGifs = 'Upsista, ei giffej';
z.string.fi.extensionsGiphyRandom = 'Satunnainen';

z.string.fi.addParticipantsConfirmLabel = 'Lis';
z.string.fi.addParticipantsSearchPlaceholder = 'Hae nimell';
z.string.fi.addParticipantsTabsPeople = 'Ihmiset';
z.string.fi.addParticipantsTabsServices = 'Palvelut';

z.string.fi.conversationDetailsActionArchive = 'Arkistoi';
z.string.fi.conversationDetailsActionCancelRequest = 'Peru pyynt';
z.string.fi.conversationDetailsActionDevices = 'Laitteet';
z.string.fi.conversationDetailsActionNotifications = 'Ilmoitukset';
z.string.fi.conversationDetailsGuestsOff = 'Pois plt';
z.string.fi.conversationDetailsOptions = 'Valinnat';
z.string.fi.conversationDetailsParticipantsServicesMany = 'Palvelut';
z.string.fi.conversationDetailsParticipantsUsersMany = 'Ihmiset';
z.string.fi.conversationDetailsPeople = 'Ihmiset';
z.string.fi.conversationDetailsServices = 'Palvelut';

z.string.fi.conversationParticipantsTitle = 'Ihmiset';
z.string.fi.conversationParticipantsSearchPlaceholder = 'Hae nimell';

z.string.fi.groupParticipantActionCancelRequest = 'Peru pyynt';
z.string.fi.groupParticipantActionDevices = 'Laitteet';
z.string.fi.groupParticipantActionPending = 'Odottaa';
z.string.fi.groupParticipantActionSendRequest = 'Yhdist';

z.string.fi.notificationSettingsTitle = 'Ilmoitukset';

z.string.fi.participantDevicesDetailHeadline = 'Vahvista ett tm vastaa sormenjlke joka nkyy {{html1}}{{user}}s n laitteella{{html2}}.';
z.string.fi.participantDevicesDetailHowTo = 'Miten teen sen?';
z.string.fi.participantDevicesDetailResetSession = 'Nollaa istunto';
z.string.fi.participantDevicesDetailShowMyDevice = 'Nyt laitteeni sormenjlki';
z.string.fi.participantDevicesDetailVerify = 'Vahvistettu';

z.string.fi.participantDevicesHeader = 'Laitteet';
z.string.fi.participantDevicesHeadline = 'Wire antaa jokaiselle laitteelle yksilllisen sormenjljen. Vertaa niit {{user}} kanssa ja vahvista keskustelusi.';
z.string.fi.participantDevicesLearnMore = 'Lue lis';
z.string.fi.participantDevicesWhyVerify = 'Miksi vahvistaa keskusteluja?';
z.string.fi.participantDevicesOutdatedClientMessage = '{{user}} kytt vanhaa Wire-versiota. Laitteita ei nytet tll.';

z.string.fi.participantDevicesSelfAllDevices = 'Nyt kaikki laitteeni';
z.string.fi.participantDevicesSelfFingerprint = 'Laitteen sormenjlki';

z.string.fi.userProfileButtonConnect = 'Yhdist';
z.string.fi.userProfileButtonIgnore = 'Hylk';
z.string.fi.userProfileButtonUnblock = 'Poista esto';

z.string.fi.preferencesAbout = 'Tietoja meist';
z.string.fi.preferencesAccount = 'Tili';
z.string.fi.preferencesAV = 'Audio / Video';
z.string.fi.preferencesDeviceDetails = 'Laitteen yksityiskohdat';
z.string.fi.preferencesDevices = 'Laitteet';
z.string.fi.preferencesHeadline = 'Asetukset';
z.string.fi.preferencesOptions = 'Valinnat';

z.string.fi.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.fi.preferencesAboutPrivacyPolicy = 'Yksityisyyskytnnt';
z.string.fi.preferencesAboutSupport = 'Tuki';
z.string.fi.preferencesAboutSupportWebsite = 'Tuki sivusto';
z.string.fi.preferencesAboutSupportContact = 'Ota yhteytt tukeen';
z.string.fi.preferencesAboutTermsOfUse = 'Kyttehdot';
z.string.fi.preferencesAboutVersion = 'Versio {{version}}';
z.string.fi.preferencesAboutWebsite = 'Wiren verkkosivu';

z.string.fi.preferencesAccountCreateTeam = 'Luo tiimi';
z.string.fi.preferencesAccountDelete = 'Poista tili';
z.string.fi.preferencesAccountLogOut = 'Kirjaudu ulos';
z.string.fi.preferencesAccountManageTeam = 'Hallinnoi tiimi';
z.string.fi.preferencesAccountResetPassword = 'Vaihda salasana';
z.string.fi.preferencesAccountTeam = 'tiimiss {{name}}';
z.string.fi.preferencesAccountUsernamePlaceholder = 'Koko nimesi';
z.string.fi.preferencesAccountUsernameHint = 'Vhintn 2 merkki, vain a - z, 0 - 9 ja _.';
z.string.fi.preferencesAccountUsernameAvailable = 'Saatavilla';
z.string.fi.preferencesAccountUsernameErrorTaken = 'On jo kytss';

z.string.fi.preferencesAVCamera = 'Kamera';
z.string.fi.preferencesAVMicrophone = 'Mikrofoni';
z.string.fi.preferencesAVPermissionDetail = 'Salli selaimesi asetuksista';
z.string.fi.preferencesAVSpeakers = 'Kaiuttimet';

z.string.fi.preferencesDevicesActivatedOn = 'Aktivoitu {{date}}';
z.string.fi.preferencesDevicesActive = 'Aktiivinen';
z.string.fi.preferencesDevicesActiveDetail = 'Jos et tunnista yll olevaa laitetta, poista se ja vaihda salasanasi.';
z.string.fi.preferencesDevicesCurrent = 'Nykyinen';
z.string.fi.preferencesDevicesFingerprint = 'Sormenjlki avain';
z.string.fi.preferencesDevicesFingerprintDetail = 'Wire antaa jokaiselle laitteelle yksilllisen sormenjljen. Vertaa niit ja varmenna laitteesi ja keskustelusi.';
z.string.fi.preferencesDevicesId = 'ID: ';
z.string.fi.preferencesDevicesRemoveCancel = 'Peruuta';
z.string.fi.preferencesDevicesRemoveDetail = 'Poista tm laite jos olet lakannut kyttmst sit. Sinut kirjataan ulos tst laitteesta vlittmsti.';
z.string.fi.preferencesDevicesSessionConfirmation = 'Istunto on nollattu.';
z.string.fi.preferencesDevicesSessionDetail = 'Jos sormenjljet eivt tsm, nollaa istunto luodaksesi uudet salausavaimet molemmille osapuolille.';
z.string.fi.preferencesDevicesSessionReset = 'Nollaa istunto';
z.string.fi.preferencesDevicesSessionOngoing = 'Nollataan istuntoa';
z.string.fi.preferencesDevicesVerification = 'Vahvistettu';

z.string.fi.preferencesOptionsAudio = 'nimerkit';
z.string.fi.preferencesOptionsAudioAll = 'Kaikki';
z.string.fi.preferencesOptionsAudioAllDetail = 'Kaikki net';
z.string.fi.preferencesOptionsAudioNone = 'Ei mitn';
z.string.fi.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.fi.preferencesOptionsAudioSome = 'Jotain';
z.string.fi.preferencesOptionsAudioSomeDetail = 'Pingit ja puhelut';
z.string.fi.preferencesOptionsContacts = 'Yhteystiedot';
z.string.fi.preferencesOptionsContactsGmail = 'Tuo Gmailista';
z.string.fi.preferencesOptionsContactsMacos = 'Tuo Yhteystiedoista';
z.string.fi.preferencesOptionsContactsDetail = 'Kytmme sinun kontaktitietoja yhdistksemme sinut muiden kanssa. Anonymisoimme kaiken tiedon ja emme jaa sit ulkopuolisille.';
z.string.fi.preferencesOptionsPopular = 'Yleisn pyynnst';
z.string.fi.preferencesOptionsEmojiReplaceCheckbox = 'Korvaa tekstihymit emojeilla';
z.string.fi.preferencesOptionsPreviewsSendCheckbox = 'Luo esikatselut lhettmillesi linkeille';
z.string.fi.preferencesOptionsPreviewsSendDetail = 'Esikatselut saattavat silti nky muiden lhettmiss linkeiss.';
z.string.fi.preferencesOptionsNotifications = 'Ilmoitukset';
z.string.fi.preferencesOptionsNotificationsNone = 'Pois plt';
z.string.fi.preferencesOptionsNotificationsObfuscate = 'Piilota yksityiskohdat';
z.string.fi.preferencesOptionsNotificationsObfuscateMessage = 'Nyt lhettj';
z.string.fi.preferencesOptionsNotificationsOn = 'Nyt lhettj ja viesti';

z.string.fi.backupCancel = 'Peruuta';

z.string.fi.searchConnect = 'Yhdist';
z.string.fi.searchConnections = 'Yhteydet';
z.string.fi.searchContacts = 'Yhteystiedot';
z.string.fi.searchCreateGroup = 'Luo ryhm';
z.string.fi.searchGroups = 'Ryhmt';
z.string.fi.searchPeople = 'Ihmiset';
z.string.fi.searchPlaceholder = 'Etsi nimell tai kyttjnimell';
z.string.fi.searchServicePlaceholder = 'Hae nimell';
z.string.fi.searchServices = 'Palvelut';
z.string.fi.searchTeamGroups = 'Tiimikeskustelut';
z.string.fi.searchTeamMembers = 'Tiimin jsenet';
z.string.fi.searchTopPeople = 'Eniten kytetyt kontaktit';
z.string.fi.searchTrySearch = 'Etsi kyttji nimell tai kyttjnimell';
z.string.fi.searchNoContactsOnWire = 'Sinulla ei ole kontakteja Wiress. Yrit etsi muita kyttji nimell tai kyttjnimell.';
z.string.fi.searchOthers = 'Yhdist';

z.string.fi.searchInvite = 'Kutsu henkilit Wireen';
z.string.fi.searchInviteDetail = 'Yhteystietojesi jakaminen auttaa sinua lytmn uusia kontakteja. Anonymisoimme kaiken tiedon ja emme jaa sit ulkopuolisille.';
z.string.fi.searchInviteButtonContacts = 'Kontakteista';
z.string.fi.searchInviteButtonGmail = 'Gmailista';
z.string.fi.searchInviteHeadline = 'Kutsu kavereitasi';
z.string.fi.searchInviteShare = 'Jaa yhteystietoja';

z.string.fi.searchListEveryoneParticipates = 'Jokainen jonka kanssa olet yhdistetty on jo tss keskustelussa.';
z.string.fi.searchListNoMatches = 'Ei vastaavia tuloksia. Yrit toisella nimell.';


z.string.fi.uploadGoogleHeadline = 'Etsi ihmisi joiden kanssa jutella.';
z.string.fi.uploadGoogleMessage = 'Kytmme sinun kontaktitietoja yhdistksemme sinut muiden kanssa. Anonymisoimme kaiken tiedon ja emme jaa sit ulkopuolisille.';

z.string.fi.warningCallUnsupportedIncoming = '{{user}} soittaa. Selaimesi ei tue puheluja.';
z.string.fi.warningCallUnsupportedOutgoing = 'Et voi soittaa puhelua koska selaimesi ei tue puheluja.';
z.string.fi.warningCallIssues = 'Tm versio Wirest ei pysty osallistumaan puheluun. Kyt';
z.string.fi.warningCallUpgradeBrowser = 'Soittaaksesi puhelun, pivit Google Chrome.';
z.string.fi.warningConnectivityConnectionLost = 'Yritetn yhdist. Wire ei mahdollisesti pysty toimitttamaan viestej perille.';
z.string.fi.warningConnectivityNoInternet = 'Ei Interneti. Et pysty lhettmn tai vastaanottamaan viestej.';
z.string.fi.warningLearnMore = 'Lue lis';
z.string.fi.warningLifecycleUpdate = 'Wiren uusi versio on saatavilla.';
z.string.fi.warningLifecycleUpdateNotes = 'Uutuudet';
z.string.fi.warningLifecycleUpdateLink = 'Pivit nyt';
z.string.fi.warningNotFoundCamera = 'Et voi soittaa puhelua koska tietokoneessasi ei ole kameraa.';
z.string.fi.warningNotFoundMicrophone = 'Et voi soittaa puhelua koska tietokoneessasi ei ole mikrofonia.';
z.string.fi.warningPermissionDeniedCamera = 'Et voi soittaa puhelua koska selaimellasi ei ole oikeutta kytt kameraa.';
z.string.fi.warningPermissionDeniedMicrophone = 'Et voi soittaa puhelua koska selaimellasi ei ole oikeuta kytt mikrofonia.';
z.string.fi.warningPermissionDeniedScreen = 'Selaimesi tarvitsee luvan jakaa nyttsi.';
z.string.fi.warningPermissionRequestCamera = '{{icon}} Anna kyttoikeus kameraan';
z.string.fi.warningPermissionRequestMicrophone = '{{icon}} Anna kyttoikeus mikrofoniin';
z.string.fi.warningPermissionRequestNotification = '{{icon}} Salli ilmoitukset';
z.string.fi.warningPermissionRequestScreen = '{{icon}} Salli nytn kytt';

z.string.fi.userAvailabilityAvailable = 'Saatavilla';
z.string.fi.userAvailabilityNone = 'Ei mitn';

z.string.fi.notificationAssetAdd = 'Jakoi kuvan';
z.string.fi.notificationConnectionAccepted = 'Hyvksyi yhteyspyyntsi';
z.string.fi.notificationConnectionConnected = 'Olet nyt yhteydess';
z.string.fi.notificationConnectionRequest = 'Haluaa luoda kontaktin';
z.string.fi.notificationConversationCreate = '{{user}} aloitti keskustelun';
z.string.fi.notificationConversationRename = '{{user}} nimesi keskustelun uudelleen {{name}}ksi';
z.string.fi.notificationMemberJoinMany = '{{user}} lissi {{number}} ihmist keskusteluun';
z.string.fi.notificationMemberJoinOne = '{{user1}} lissi {{user2}}n keskusteluun';
z.string.fi.notificationMemberLeaveRemovedYou = '{{user}} poisti sinut keskustelusta';
z.string.fi.notificationObfuscated = 'Lhetti sinulle viestin';
z.string.fi.notificationObfuscatedTitle = 'Joku';
z.string.fi.notificationPing = 'Pinggasi';
z.string.fi.notificationReaction = '{{reaction}} sinun viesti';
z.string.fi.notificationSharedAudio = 'Jakoi niviestin';
z.string.fi.notificationSharedFile = 'Jakoi tiedoston';
z.string.fi.notificationSharedLocation = 'Jakoi sijainnin';
z.string.fi.notificationSharedVideo = 'Jakoi videon';
z.string.fi.notificationVoiceChannelActivate = 'Soittaa';
z.string.fi.notificationVoiceChannelDeactivate = 'Soitti';

z.string.fi.tooltipConversationAllVerified = 'Kaikki sormenjljet on vahvistettu';
z.string.fi.tooltipConversationCall = 'Puhelu';
z.string.fi.tooltipConversationEphemeral = 'Ajoitettu viesti';
z.string.fi.tooltipConversationFile = 'Lis tiedosto';
z.string.fi.tooltipConversationInputPlaceholder = 'Kirjoita viesti';
z.string.fi.tooltipConversationPeople = 'Ihmiset ({{shortcut}})';
z.string.fi.tooltipConversationPicture = 'Lis kuva';
z.string.fi.tooltipConversationPing = 'Pingaa ({{shortcut}})';
z.string.fi.tooltipConversationSearch = 'Etsi';
z.string.fi.tooltipConversationVideoCall = 'Videopuhelu';

z.string.fi.tooltipConversationsArchive = 'Arkisto ({{shortcut}})';
z.string.fi.tooltipConversationsArchived = 'Nyt arkisto ({{number}})';
z.string.fi.tooltipConversationsMore = 'Lis';
z.string.fi.tooltipConversationsNotify = 'Poist mykistys ({{shortcut}})';
z.string.fi.tooltipConversationsPreferences = 'Avaa asetukset';
z.string.fi.tooltipConversationsSilence = 'Mykist ({{shortcut}})';
z.string.fi.tooltipConversationsStart = 'Aloita keskustelu ({{shortcut}})';

z.string.fi.tooltipConversationDetailsRename = 'Muuta keskustelun nime';

z.string.fi.tooltipPreferencesContactsGmail = 'Kirjaudu gmail-tilillesi jakaaksesi kontakteja';
z.string.fi.tooltipPreferencesContactsMacos = 'Jaa kaikki yhteystietosi macOs Yhteystieto sovelluksesta';
z.string.fi.tooltipPreferencesPassword = 'Avaa toinen nettisivu vaihtaaksesi salasanasi';
z.string.fi.tooltipPreferencesPicture = 'Vaihda kuvasi';
z.string.fi.tooltipPreferencesRename = 'Vaihda nimesi';

z.string.fi.tooltipSearchClose = 'Sulje (Esc)';

z.string.fi.initReceivedSelfUser = 'He, {{user}}.';
z.string.fi.initValidatedClient = 'Haetaan yhteyksisi ja keskustelujasi';
z.string.fi.initReceivedUserData = 'Tarkistetaan uusia viestej';
z.string.fi.initDecryption = 'Puretaan viestej';
z.string.fi.initEvents = 'Ladataan viestej';
z.string.fi.initUpdatedFromNotifications = 'Melkein valmista - nauti Wirest';
z.string.fi.initProgress = '  {{number1}} / {{number2}}';

z.string.fi.ephemeralUnitsNone = 'Pois plt';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.fr.wire = 'Wire';
z.string.fr.wireMacos = 'Wire pour macOS';
z.string.fr.wireWindows = 'Wire pour Windows';
z.string.fr.wireLinux = 'Wire pour Linux';
z.string.fr.nonexistentUser = 'Utilisateur supprim';
z.string.fr.and = 'et';
z.string.fr.enumerationAnd = ', et ';

//=L'application se charge
z.string.fr.authAccountCountryCode = 'Indicatif du pays';
z.string.fr.authAccountPasswordForgot = 'Mot de passe oubli';
z.string.fr.authAccountPublicComputer = 'Cet ordinateur est public';
z.string.fr.authAccountSignIn = 'Se connecter';
z.string.fr.authAccountSignInPhone = 'Tlphone';

z.string.fr.authBlockedCookies = 'Autorisez les cookies pour vous connecter  Wire.';
z.string.fr.authBlockedDatabase = 'Wire a besoin daccder  votre espace de stockage pour afficher les messages. Il nest pas disponible en navigation prive.';
z.string.fr.authBlockedTabs = 'Wire est dj ouvert dans un autre onglet.';
z.string.fr.authBlockedTabsAction = 'Utiliser cet onglet  la place';

z.string.fr.authVerifyAccountAdd = 'Ajouter';
z.string.fr.authVerifyAccountDetail = 'Cela vous permet dutiliser Wire sur plusieurs appareils.';
z.string.fr.authVerifyAccountHeadline = 'Ajouter une adresse e-mail et un mot de passe.';
z.string.fr.authVerifyAccountLogout = 'Se dconnecter';
z.string.fr.authVerifyCodeDescription = 'Saisissez le code de vrification que nous avons envoy au {{number}}.';
z.string.fr.authVerifyCodeResend = 'Pas de code  lhorizon ?';
z.string.fr.authVerifyCodeResendDetail = 'Renvoyer';
z.string.fr.authVerifyCodeResendTimer = 'Vous pourrez demander un nouveau code {{expiration}}.';
z.string.fr.authVerifyCodeChangePhone = 'Changer le numro de tlphone';
z.string.fr.authVerifyPasswordHeadline = 'Saisissez votre mot de passe';

z.string.fr.authLimitDevicesHeadline = 'Appareils';
z.string.fr.authLimitDescription = 'Supprimez un de vos autres appareils pour commencer  utiliser Wire sur celui-ci.';
z.string.fr.authLimitButtonManage = 'Grer les appareils';
z.string.fr.authLimitButtonSignOut = 'Se dconnecter';
z.string.fr.authLimitDevicesCurrent = '(actuel)';

z.string.fr.authHistoryHeadline = 'Cest la premire fois que vous utilisez Wire sur cet appareil.';
z.string.fr.authHistoryDescription = 'Pour des raisons de confidentialit, votre historique de conversation napparatra pas ici.';
z.string.fr.authHistoryReuseHeadline = 'Vous avez dj utilis Wire sur cet appareil.';
z.string.fr.authHistoryReuseDescription = 'Les messages envoys entre-temps napparatront pas ici.';
z.string.fr.authHistoryButton = 'OK';

z.string.fr.authPostedResend = 'Renvoyer  {{email}}';
z.string.fr.authPostedResendAction = 'Aucun e-mail  lhorizon ?';
z.string.fr.authPostedResendDetail = 'Vrifiez votre bote de rception et suivez les instructions.';
z.string.fr.authPostedResendHeadline = 'Vous avez du courrier.';

z.string.fr.authPlaceholderEmail = 'E-mail';
z.string.fr.authPlaceholderPasswordPut = 'Mot de passe';
z.string.fr.authPlaceholderPasswordSet = 'Mot de passe (8 caractres minimum)';
z.string.fr.authPlaceholderPhone = 'Numro de tlphone';

z.string.fr.authErrorCode = 'Code invalide';
z.string.fr.authErrorCountryCodeInvalid = 'Indicatif du pays invalide';
z.string.fr.authErrorEmailExists = 'Adresse e-mail dj utilise';
z.string.fr.authErrorEmailForbidden = 'Dsol. Cette adresse e-mail est bannie.';
z.string.fr.authErrorEmailMalformed = 'Veuillez saisir une adresse e-mail valide.';
z.string.fr.authErrorEmailMissing = 'Veuillez saisir une adresse e-mail.';
z.string.fr.authErrorMisc = 'Problmes de connexion. Veuillez ressayer.';
z.string.fr.authErrorNameShort = 'Saisissez un nom compos dau moins 2 caractres';
z.string.fr.authErrorOffline = 'Pas de connexion Internet';
z.string.fr.authErrorPasswordShort = 'Choisissez un mot de passe dau moins 8 caractres.';
z.string.fr.authErrorPasswordWrong = 'Mot de passe incorrect. Veuillez ressayer.';
z.string.fr.authErrorPending = 'Le compte nest pas encore vrifi';
z.string.fr.authErrorPhoneNumberBudget = 'Vous vous tes connect trop souvent. Ressayez plus tard.';
z.string.fr.authErrorPhoneNumberForbidden = 'Dsol. Ce numro de tlphone est banni.';
z.string.fr.authErrorPhoneNumberInvalid = 'Numro de tlphone non valide';
z.string.fr.authErrorPhoneNumberUnknown = 'Numro de tlphone inconnu';
z.string.fr.authErrorSuspended = 'Ce compte nest plus autoris  se connecter.';
z.string.fr.authErrorSignIn = 'Veuillez vrifier vos informations et ressayez.';

z.string.fr.callStateOutgoing = 'Sonnerie';
z.string.fr.callStateConnecting = 'Connexion';
z.string.fr.callStateIncoming = 'Appel';
z.string.fr.callStateIncomingGroup = '{{user}} appelle';
z.string.fr.callDecline = 'Dcliner';
z.string.fr.callAccept = 'Accepter';
z.string.fr.callJoin = 'Rejoindre';
z.string.fr.callChooseSharedScreen = 'Choisissez un cran  partager';
z.string.fr.callParticipants = '{{number}} sur lappel';
z.string.fr.callNoCameraAccess = 'Appareil photo indisponible';

z.string.fr.videoCallOverlayFitVideoLabel = 'Double-cliquez pour adapter la taille de la vido';
z.string.fr.videoCallOverlayConversations = 'Conversations';
z.string.fr.videoCallOverlayMute = 'Mettre en sourdine';
z.string.fr.videoCallOverlayVideo = 'Vido';
z.string.fr.videoCallOverlayShareScreen = 'Partager lcran';
z.string.fr.videoCallOverlayHangUp = 'Raccrocher';
z.string.fr.videoCallPaused = 'Vido en pause';
z.string.fr.videoCallScreenShareNotSupported = 'Le partage dcran nest pas compatible avec ce navigateur';

z.string.fr.modalAcknowledgeAction = 'OK';
z.string.fr.modalAcknowledgeHeadline = 'Une erreur est survenue';
z.string.fr.modalConfirmSecondary = 'Annuler';
z.string.fr.modalOptionSecondary = 'Annuler';

z.string.fr.modalAccountCreateAction = 'OK';
z.string.fr.modalAccountCreateHeadline = 'Crer un compte ?';
z.string.fr.modalAccountCreateMessage = 'En crant un compte, vous perdrez lhistorique de conversation dans cette chambre dinvits.';

z.string.fr.modalAccountDeletionAction = 'Supprimer';
z.string.fr.modalAccountDeletionHeadline = 'Supprimer le compte';
z.string.fr.modalAccountDeletionMessage = 'Nous allons envoyer un e-mail ou un SMS. Cliquez sur le lien pour supprimer dfinitivement votre compte.';

z.string.fr.modalAccountLeaveGuestRoomAction = 'Quitter';
z.string.fr.modalAccountLeaveGuestRoomHeadline = 'Quitter la conversation ?';
z.string.fr.modalAccountLeaveGuestRoomMessage = 'Lhistorique de la conversation sera supprim. Pour le conserver, crez un compte la prochaine fois.';

z.string.fr.modalAccountLogoutAction = 'Se dconnecter';
z.string.fr.modalAccountLogoutHeadline = 'Supprimer les donnes ?';
z.string.fr.modalAccountLogoutOption = 'Supprime toutes vos informations personnelles et conversations de cet appareil.';

z.string.fr.modalAccountNewDevicesSecondary = 'Grer les appareils';
z.string.fr.modalAccountNewDevicesHeadline = 'Votre compte a t utilis le :';
z.string.fr.modalAccountNewDevicesFrom = 'Depuis :';
z.string.fr.modalAccountNewDevicesMessage = 'Si ce ntait pas vous, supprimez lappareil et changez votre mot de passe.';

z.string.fr.modalAccountRemoveDeviceAction = 'Supprimer lappareil';
z.string.fr.modalAccountRemoveDeviceHeadline = 'Supprimer "{{device}}"';
z.string.fr.modalAccountRemoveDeviceMessage = 'Votre mot de passe est ncessaire pour supprimer lappareil.';
z.string.fr.modalAccountRemoveDevicePlaceholder = 'Mot de passe';

z.string.fr.modalAssetTooLargeHeadline = 'Fichier trop volumineux';
z.string.fr.modalAssetTooLargeMessage = 'Vous pouvez envoyer des fichiers jusqu {{number}}';

z.string.fr.modalAssetParallelUploadsHeadline = 'Trop de fichiers  la fois';
z.string.fr.modalAssetParallelUploadsMessage = 'Vous pouvez envoyer jusqu {{number}} fichiers  la fois.';

z.string.fr.modalCallEmptyConversationHeadline = 'Personne  appeler';
z.string.fr.modalCallEmptyConversationMessage = 'Il ny a plus personne ici.';

z.string.fr.modalCallEmptyLogHeadline = 'Aucun appel';
z.string.fr.modalCallEmptyLogMessage = 'Il ny a aucun appel sur lequel se baser pour le rapport de dbogage.';

z.string.fr.modalCallNoGroupVideoHeadline = 'Pas dappel vido en groupe';
z.string.fr.modalCallNoGroupVideoMessage = 'Les appels vido ne sont pas disponibles dans les conversations de groupe.';

z.string.fr.modalCallNoMicrophoneAction = 'Dites-moi comment faire';
z.string.fr.modalCallNoMicrophoneMessage = 'Votre navigateur doit avoir accs au micro pour passer des appels.';
z.string.fr.modalCallNoMicrophoneHeadline = 'Impossible dappeler sans micro';

z.string.fr.modalCallSecondIncomingAction = 'Rpondre';
z.string.fr.modalCallSecondIncomingHeadline = 'Rpondre  lappel ?';
z.string.fr.modalCallSecondIncomingMessage = 'Votre appel en cours sera termin.';

z.string.fr.modalCallSecondOngoingAction = 'Raccrocher';
z.string.fr.modalCallSecondOngoingHeadline = 'Raccrocher lappel dun autre appareil ?';
z.string.fr.modalCallSecondOngoingMessage = 'Vous ne pouvez tre que dans un appel  la fois.';

z.string.fr.modalCallSecondOutgoingAction = 'Raccrocher';
z.string.fr.modalCallSecondOutgoingHeadline = 'Raccrocher lappel en cours ?';
z.string.fr.modalCallSecondOutgoingMessage = 'Vous ne pouvez tre que dans un appel  la fois.';

z.string.fr.modalConnectCancelAction = 'Oui';
z.string.fr.modalConnectCancelHeadline = 'Annuler la demande ?';
z.string.fr.modalConnectCancelMessage = 'Annuler la demande de connexion  {{user}}.';
z.string.fr.modalConnectCancelSecondary = 'Non';

z.string.fr.modalConnectAcceptAction = 'Se connecter';
z.string.fr.modalConnectAcceptHeadline = 'Accepter ?';
z.string.fr.modalConnectAcceptMessage = 'Cela vous connectera et ouvrira la conversation avec {{user}}.';
z.string.fr.modalConnectAcceptSecondary = 'Ignorer';

z.string.fr.modalConversationClearAction = 'Supprimer';
z.string.fr.modalConversationClearHeadline = 'Effacer le contenu?';
z.string.fr.modalConversationClearMessage = 'Ceci effacera la conversation sur tous vos appareils.';
z.string.fr.modalConversationClearOption = 'Quitter aussi la conversation';

z.string.fr.modalConversationDeleteMessageAction = 'Supprimer';
z.string.fr.modalConversationDeleteMessageHeadline = 'Supprimer seulement pour moi ?';
z.string.fr.modalConversationDeleteMessageMessage = 'Cela est irrversible.';

z.string.fr.modalConversationDeleteMessageEveryoneAction = 'Supprimer';
z.string.fr.modalConversationDeleteMessageEveryoneHeadline = 'Supprimer pour tout le monde ?';
z.string.fr.modalConversationDeleteMessageEveryoneMessage = 'Cela est irrversible.';

z.string.fr.modalConversationLeaveAction = 'Quitter';
z.string.fr.modalConversationLeaveHeadline = 'Quitter la conversation "{{name}}" ?';
z.string.fr.modalConversationLeaveMessage = 'Vous ne pourrez plus envoyer ou recevoir de messages dans cette conversation.';

z.string.fr.modalConversationMessageTooLongHeadline = 'Message trop long';
z.string.fr.modalConversationMessageTooLongMessage = 'Vous pouvez envoyer des messages de {{number}} caractres maximum.';

z.string.fr.modalConversationNewDeviceAction = 'Envoyer quand mme';
z.string.fr.modalConversationNewDeviceHeadlineOne = '{{user}} utilise un nouvel appareil';
z.string.fr.modalConversationNewDeviceHeadlineMany = '{{users}} utilisent de nouveaux appareils';
z.string.fr.modalConversationNewDeviceHeadlineYou = '{{user}} utilise un nouvel appareil';
z.string.fr.modalConversationNewDeviceIncomingCallAction = 'Dcrocher';
z.string.fr.modalConversationNewDeviceIncomingCallMessage = 'Voulez-vous quand mme dcrocher ?';
z.string.fr.modalConversationNewDeviceMessage = 'Voulez-vous toujours envoyer vos messages ?';
z.string.fr.modalConversationNewDeviceOutgoingCallAction = 'Appeler quand mme';
z.string.fr.modalConversationNewDeviceOutgoingCallMessage = 'Voulez-vous quand mme appeler ?';

z.string.fr.modalConversationNotConnectedHeadline = 'Personne na t ajout  la conversation';
z.string.fr.modalConversationNotConnectedMessageOne = '{{name}} ne veut pas tre ajout aux conversations.';
z.string.fr.modalConversationNotConnectedMessageMany = 'Une des personnes slectionnes ne veut pas tre ajoute aux conversations.';

z.string.fr.modalConversationRemoveAction = 'Exclure';
z.string.fr.modalConversationRemoveHeadline = 'Exclure ?';
z.string.fr.modalConversationRemoveMessage = '{{user}} ne pourra plus envoyer ou recevoir de messages dans cette conversation.';

z.string.fr.modalConversationRemoveGuestsAction = 'Exclure';
z.string.fr.modalConversationRemoveGuestsHeadline = 'Dsactiver laccs?';
z.string.fr.modalConversationRemoveGuestsMessage = 'Tous les invits et services seront retirs de la conversation. Il ne sera plus possible dajouter de nouveaux invits ou services.';

z.string.fr.modalConversationRevokeLinkAction = 'Rvoquer le lien';
z.string.fr.modalConversationRevokeLinkHeadline = 'Rvoquer le lien ?';
z.string.fr.modalConversationRevokeLinkMessage = 'Les invits ne pourront plus rejoindre la conversation avec ce lien. Les invits ayant dj rejoint la conversation conserveront leurs accs.';

z.string.fr.modalConversationGuestOptionsAllowGuestMessage = 'Impossible daccepter des invits ou des services. Veuillez ressayer.';
z.string.fr.modalConversationGuestOptionsDisableGuestMessage = 'Impossible de retirer des invits ou des services. Veuillez ressayer.';
z.string.fr.modalConversationGuestOptionsGetCodeMessage = 'Impossible de rcuprer le lien daccs.';
z.string.fr.modalConversationGuestOptionsRequestCodeMessage = 'La demande de lien daccs a chou. Merci de ressayer.';
z.string.fr.modalConversationGuestOptionsRevokeCodeMessage = 'Impossible de rvoquer le lien daccs. Merci de ressayer.';
z.string.fr.modalConversationGuestOptionsToggleGuestsMessage = 'Impossible de changer les rglages pour les invits.';

z.string.fr.modalConversationTooManyMembersHeadline = 'Le groupe est complet';
z.string.fr.modalConversationTooManyMembersMessage = 'Jusqu {{number1}} personnes peuvent participer  une conversation. Actuellement, il ny a de la place que pour {{number2}} de plus.';

z.string.fr.modalGifTooLargeHeadline = 'Limage slectionne est trop volumineuse';
z.string.fr.modalGifTooLargeMessage = 'La taille maximale autorise est {{number}} MB.';

z.string.fr.modalIntegrationUnavailableHeadline = 'Les bots sont indisponibles pour le moment';
z.string.fr.modalIntegrationUnavailableMessage = 'Merci de votre intrt pour les bots. Ce service est actuellement dsactiv pendant que nous travaillons sur la prochaine version. Restez  lcoute.';

z.string.fr.modalPictureFileFormatHeadline = 'Impossible dutiliser cette image';
z.string.fr.modalPictureFileFormatMessage = 'Veuillez choisir un fichier PNG ou JPEG.';

z.string.fr.modalPictureTooLargeHeadline = 'La photo slectionne est trop volumineuse';
z.string.fr.modalPictureTooLargeMessage = 'Vous pouvez envoyer des images allant jusqu {{number}} MB.';

z.string.fr.modalPictureTooSmallHeadline = 'Limage slectionne est trop petite';
z.string.fr.modalPictureTooSmallMessage = 'Merci de choisir une image mesurant au moins 320  320 px.';

z.string.fr.modalImproveWireAction = 'Accepter';
z.string.fr.modalImproveWireSecondary = 'Non';
z.string.fr.modalImproveWireHeadline = 'Aidez-nous  amliorer Wire';
z.string.fr.modalImproveWireMessage = 'Wire peut crer et utiliser des rapports dutilisation et derreurs anonymes afin damliorer lapplication. Vous pouvez rvoquer votre autorisation  tout moment.';

z.string.fr.modalServiceUnavailableHeadline = 'Lajout du service est impossible';
z.string.fr.modalServiceUnavailableMessage = 'Le service est temporairement indisponible.';

z.string.fr.modalSessionResetHeadline = 'La session a t rinitialise';
z.string.fr.modalSessionResetMessage1 = 'Si le problme nest pas rsolu,';
z.string.fr.modalSessionResetMessageLink = 'contactez';
z.string.fr.modalSessionResetMessage2 = '-nous.';

z.string.fr.modalUploadContactsAction = 'Ressayer';
z.string.fr.modalUploadContactsMessage = 'Nous navons pas reu votre information. Veuillez ressayer dimporter vos contacts.';

z.string.fr.modalUserBlockAction = 'Bloquer';
z.string.fr.modalUserBlockHeadline = 'Bloquer {{user}} ?';
z.string.fr.modalUserBlockMessage = '{{user}} ne pourra plus vous contacter ou vous ajouter  des conversations de groupe.';

z.string.fr.modalUserUnblockAction = 'Dbloquer';
z.string.fr.modalUserUnblockHeadline = 'Dbloquer ?';
z.string.fr.modalUserUnblockMessage = '{{user}} pourra de nouveau vous parler ou vous ajouter  des conversations de groupe.';

z.string.fr.modalNoCameraTitle = 'Appareil photo indisponible';
z.string.fr.modalNoCameraMessage = 'Wire na pas accs  la camra.[br][faqLink]Lisez cet article de support[/faqLink] pour savoir comment rsoudre ce problme.';

z.string.fr.connectionRequestConnect = 'Se connecter';
z.string.fr.connectionRequestIgnore = 'Ignorer';

z.string.fr.conversationGuestIndicator = 'Invit';
z.string.fr.userRemainingTimeHours = '{{time}} heures restantes';
z.string.fr.userRemainingTimeMinutes = 'Moins de {{time}} minutes restantes';

z.string.fr.conversationYouNominative = 'vous';
z.string.fr.conversationYouDative = 'vous';
z.string.fr.conversationYouAccusative = 'vous';

z.string.fr.conversationConnectionAccepted = 'Connect';
z.string.fr.conversationConnectionBlocked = 'Bloqu';
z.string.fr.conversationConnectionCancelRequest = 'Annuler la demande de connexion';
z.string.fr.conversationCreateTemporary = 'Vous avez rejoint la conversation';
z.string.fr.conversationCreateWith = 'avec {{users}}';
z.string.fr.conversationDeviceStartedUsingOne = ' utilise';
z.string.fr.conversationDeviceStartedUsingMany = ' utilise';
z.string.fr.conversationDeviceUnverified = ' a annul la vrification dun';
z.string.fr.conversationDeviceYourDevices = ' de vos appareils';
z.string.fr.conversationDeviceUserDevices = ' des appareils de {{user}}';
z.string.fr.conversationDeviceNewDeviceOne = ' un nouvel appareil';
z.string.fr.conversationDeviceNewDeviceMany = ' de nouveaux appareils';
z.string.fr.conversationDeviceNewPeopleJoined = 'De nouvelles personnes ont rejoint la conversation.';
z.string.fr.conversationDeviceNewPeopleJoinedVerify = 'Vrifier les appareils';
z.string.fr.conversationJustNow = ' linstant';
z.string.fr.conversationLocationLink = 'Ouvrir la carte';
z.string.fr.conversationCreated = '[bold]{{name}}[/bold] a dmarr une conversation avec {{users}}';
z.string.fr.conversationCreatedMore = '[bold]{{name}}[/bold] a dmarr une conversation avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreatedName = '[bold]{{name}}[/bold] a dmarr la conversation';
z.string.fr.conversationCreatedNameYou = '[bold]Vous[/bold] avez dmarr la conversation';
z.string.fr.conversationCreatedYou = 'Vous avez commenc une conversation avec {{users}}';
z.string.fr.conversationCreatedYouMore = 'Vous avez dmarr la conversation avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreateWithMore = 'avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreateTeam = 'avec [showmore]tous les membres de lquipe[/showmore]';
z.string.fr.conversationCreateTeamGuest = 'avec [showmore]tous les membres de lquipe et un invit[/showmore]';
z.string.fr.conversationCreateTeamGuests = 'avec [showmore]tous les membres de lquipe et {{count}} invits[/showmore]';
z.string.fr.conversationMemberJoined = '[bold]{{name}}[/bold] a ajout {{users}}  la conversation';
z.string.fr.conversationMemberJoinedYou = '[bold]Vous[/bold] avez ajout {{users}}  la conversation';
z.string.fr.conversationMemberJoinedMore = '[bold]{{name}}[/bold] a ajout {{users}}, et [showmore]{{count}} autres[/showmore]  la conversation';
z.string.fr.conversationMemberJoinedYouMore = '[bold]Vous[/bold] avez ajout {{users}}, et [showmore]{{count}} plus[/showmore]  la conversation';
z.string.fr.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] a rejoint la conversation';
z.string.fr.conversationMemberJoinedSelfYou = '[bold]Vous[/bold] avez rejoint la conversation';
z.string.fr.conversationMemberLeft = '[bold]{{name}}[/bold] a quitt la conversation';
z.string.fr.conversationMemberLeftYou = '[bold]Vous[/bold] avez quitt la conversation';
z.string.fr.conversationMemberRemoved = '[bold]{{name}}[/bold] a exclu {{users}}';
z.string.fr.conversationMemberRemovedYou = '[bold]Vous[/bold] avez exclu {{users}}';
z.string.fr.conversationTeamLeft = '[bold]{{name}}[/bold] a t retir de lquipe';
z.string.fr.conversationMessageDelivered = 'Distribu';
z.string.fr.conversationRename = ' a renomm la conversation';
z.string.fr.conversationRenameYou = ' a renomm la conversation';
z.string.fr.conversationUpdatedTimer = ' a dfini les messages phmre  {{time}}';
z.string.fr.conversationUpdatedTimerYou = ' avez dfini les message phmres  {{time}}';
z.string.fr.conversationResetTimer = ' a dsactiv les messages phmres';
z.string.fr.conversationResetTimerYou = ' avez dsactiv les messages phmres';
z.string.fr.conversationResume = 'Commencez une conversation avec {{users}}';
z.string.fr.conversationPing = ' a fait un signe';
z.string.fr.conversationPingYou = ' a fait un signe';
z.string.fr.conversationToday = 'aujourdhui';
z.string.fr.conversationVoiceChannelDeactivate = ' a essay dappeler';
z.string.fr.conversationVoiceChannelDeactivateYou = ' a essay dappeler';
z.string.fr.conversationYesterday = 'Hier';
z.string.fr.conversationUnableToDecrypt1 = 'Un message de [highlight]{{user}}[/highlight] na pas t reu.';
z.string.fr.conversationUnableToDecrypt2 = 'Lidentit de lappareil de {{user}} a chang. Message non dlivr.';
z.string.fr.conversationUnableToDecryptLink = 'Pourquoi ?';
z.string.fr.conversationUnableToDecryptErrorMessage = 'Erreur';
z.string.fr.conversationUnableToDecryptResetSession = 'Rinitialiser la session';
z.string.fr.conversationMissedMessages = 'Vous navez pas utilis cet appareil depuis un moment. Il est possible que certains messages napparaissent pas ici.';
z.string.fr.conversationAssetUploading = 'Envoi en cours';
z.string.fr.conversationAssetDownloading = 'Tlchargement en cours';
z.string.fr.conversationAssetUploadFailed = 'chec de lenvoi';
z.string.fr.conversationPlaybackError = 'Lecture impossible';
z.string.fr.conversationContextMenuCopy = 'Copier';
z.string.fr.conversationContextMenuEdit = 'dition';
z.string.fr.conversationContextMenuDelete = 'Supprimer pour moi';
z.string.fr.conversationContextMenuDeleteEveryone = 'Supprimer pour tout le monde';
z.string.fr.conversationContextMenuDownload = 'Tlcharger';
z.string.fr.conversationContextMenuLike = 'Jaime';
z.string.fr.conversationContextMenuReply = 'Rpondre';
z.string.fr.conversationContextMenuUnlike = 'Je naime plus';
z.string.fr.conversationDeleteTimestamp = 'Supprim: {{date}}';
z.string.fr.conversationEditTimestamp = 'Modifi : {{date}}';
z.string.fr.conversationLikesCaption = '{{number}} personnes';
z.string.fr.conversationSendPastedFile = 'Image colle le {{date}}';
z.string.fr.conversationSomeone = 'Quelquun';
z.string.fr.conversationTweetAuthor = ' via Twitter';
z.string.fr.conversationServicesWarning = 'Les services ont accs au contenu de la conversation';

z.string.fr.groupCreationPreferencesAction = 'Suivant';
z.string.fr.groupCreationPreferencesErrorNameShort = 'Au moins un caractre';
z.string.fr.groupCreationPreferencesErrorNameLong = 'Trop de caractres';
z.string.fr.groupCreationPreferencesHeader = 'Nouveau groupe';
z.string.fr.groupCreationPreferencesPlaceholder = 'Nom du groupe';
z.string.fr.groupCreationParticipantsActionCreate = 'Termin';
z.string.fr.groupCreationParticipantsActionSkip = 'Passer';
z.string.fr.groupCreationParticipantsHeader = 'Ajouter un contact';
z.string.fr.groupCreationParticipantsHeaderWithCounter = 'Ajouter des participants ({{number}})';
z.string.fr.groupCreationParticipantsPlaceholder = 'Rechercher par nom';
z.string.fr.groupSizeInfo = 'Les conversations de groupe peuvent accueillir jusqu {{count}} personnes. Les appels vido peuvent accueillir jusqu 3 personnes en plus de vous.';

z.string.fr.guestRoomConversationName = 'Espace invit';
z.string.fr.guestRoomToggleName = 'Autoriser les invits et les services';
z.string.fr.guestRoomToggleInfo = 'Rendre cette conversation accessible  des personnes et services trangers  votre quipe.';
z.string.fr.guestRoomToggleInfoExtended = 'Rendre cette conversation accessible  des personnes et services trangers  votre quipe. Vous pouvez toujours changer cette option plus tard.';

z.string.fr.guestRoomConversationBadge = 'Des invits sont prsents';
z.string.fr.guestRoomConversationBadgeService = 'Des services sont actifs';
z.string.fr.guestRoomConversationBadgeGuestAndService = 'Des invits et des services sont prsents';

z.string.fr.guestRoomConversationHead = 'Des personnes trangres  votre quipe peuvent rejoindre la conversation.';
z.string.fr.guestRoomConversationButton = 'Inviter des personnes';

z.string.fr.collectionShowAll = 'Tout afficher ({{number}})';
z.string.fr.collectionSectionLinks = 'Liens';
z.string.fr.collectionSectionImages = 'Images';
z.string.fr.collectionSectionFiles = 'Fichiers';
z.string.fr.collectionSectionAudio = 'Messages vocaux';

z.string.fr.fullsearchPlaceholder = 'Chercher dans les messages';
z.string.fr.fullsearchNoResults = 'Aucun rsultat.';

z.string.fr.archiveHeader = 'Archiver';

z.string.fr.conversationsAllArchived = 'Tout a t archiv';
z.string.fr.conversationsContacts = 'Contacts';
z.string.fr.conversationsConnectionRequestMany = '{{number}} personnes en attente';
z.string.fr.conversationsConnectionRequestOne = '1 personne en attente';
z.string.fr.conversationsEmptyConversation = 'Conversation de groupe';
z.string.fr.conversationsNoConversations = 'Commencez une conversation ou crez un groupe.';
z.string.fr.conversationsPopoverArchive = 'Archiver';
z.string.fr.conversationsPopoverBlock = 'Bloquer';
z.string.fr.conversationsPopoverCancel = 'Annuler la demande';
z.string.fr.conversationsPopoverClear = 'Supprimer le contenu';
z.string.fr.conversationsPopoverLeave = 'Quitter le groupe';
z.string.fr.conversationsPopoverNotificationSettings = 'Notifications';
z.string.fr.conversationsPopoverNotify = 'Activer le micro';
z.string.fr.conversationsPopoverSilence = 'Mettre en sourdine';
z.string.fr.conversationsPopoverUnarchive = 'Restaurer';

z.string.fr.conversationsSecondaryLineEphemeralMention = 'Vous a mentionn';
z.string.fr.conversationsSecondaryLineEphemeralMentionGroup = 'Quelquun vous a mentionn';
z.string.fr.conversationsSecondaryLineEphemeralMessage = 'vous a envoy un message';
z.string.fr.conversationsSecondaryLineEphemeralMessageGroup = 'Quelquun a envoy un message';
z.string.fr.conversationsSecondaryLineEphemeralReply = 'Vous a rpondu';
z.string.fr.conversationsSecondaryLineEphemeralReplyGroup = 'Quelquun vous a rpondu';
z.string.fr.conversationsSecondaryLineIncomingCall = '{{user}} appelle';
z.string.fr.conversationsSecondaryLinePeopleLeft = '{{number}} personnes sont parties';
z.string.fr.conversationsSecondaryLinePersonLeft = '{{user}} est parti';
z.string.fr.conversationsSecondaryLinePersonRemoved = '{{user}} a t exclu';
z.string.fr.conversationsSecondaryLinePersonRemovedTeam = '{{user}} a t exclu de lquipe';
z.string.fr.conversationsSecondaryLinePeopleAdded = '{{user}} personnes ont t ajoutes';
z.string.fr.conversationsSecondaryLinePersonAdded = '{{user}} a t ajout';
z.string.fr.conversationsSecondaryLinePersonAddedSelf = '{{user}} a rejoint la conversation';
z.string.fr.conversationsSecondaryLinePersonAddedYou = '{{user}} vous a ajout';
z.string.fr.conversationsSecondaryLineRenamed = '{{user}} a renomm la conversation';
z.string.fr.conversationsSecondaryLineSummaryMessage = '{{number}} message';
z.string.fr.conversationsSecondaryLineSummaryMessages = '{{number}} messages';
z.string.fr.conversationsSecondaryLineSummaryMention = '{{number}} mention';
z.string.fr.conversationsSecondaryLineSummaryMentions = '{{number}} mentions';
z.string.fr.conversationsSecondaryLineSummaryMissedCall = '{{number}} appel manqu';
z.string.fr.conversationsSecondaryLineSummaryMissedCalls = '{{number}} appels manqus';
z.string.fr.conversationsSecondaryLineSummaryPing = '{{number}} signe';
z.string.fr.conversationsSecondaryLineSummaryPings = '{{number}} signes'
z.string.fr.conversationsSecondaryLineSummaryReply = '{{number}} rponse';
z.string.fr.conversationsSecondaryLineSummaryReplies = '{{number}} rponses';
z.string.fr.conversationsSecondaryLineYouLeft = 'Vous tes parti';
z.string.fr.conversationsSecondaryLineYouWereRemoved = 'Vous avez t exclu';

z.string.fr.takeoverSub = 'Choisissez votre nom dutilisateur unique sur Wire.';
z.string.fr.takeoverLink = 'En savoir plus';
z.string.fr.takeoverButtonChoose = 'Choisissez le vtre';
z.string.fr.takeoverButtonKeep = 'Garder celui-l';

z.string.fr.inviteMetaKeyMac = 'Cmd';
z.string.fr.inviteMetaKeyPc = 'Ctrl';
z.string.fr.inviteHintSelected = 'Appuyez sur {{metaKey}} + C pour copier';
z.string.fr.inviteHintUnselected = 'Slectionnez et appuyez sur {{metaKey}} + C';
z.string.fr.inviteHeadline = 'Invitez des personnes sur Wire';
z.string.fr.inviteMessage = 'Je suis sur Wire, cherche {{username}} ou va sur get.wire.com .';
z.string.fr.inviteMessageNoEmail = 'Je suis sur Wire. Va sur get.wire.com pour me rejoindre.';

z.string.fr.extensionsBubbleButtonGif = 'Gif';

z.string.fr.extensionsGiphyButtonOk = 'Envoyer';
z.string.fr.extensionsGiphyButtonMore = 'Autre gif';
z.string.fr.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.fr.extensionsGiphyNoGifs = 'Oups, pas de gif';
z.string.fr.extensionsGiphyRandom = 'Au hasard';

z.string.fr.addParticipantsConfirmLabel = 'Ajouter';
z.string.fr.addParticipantsHeader = 'Ajouter des participants';
z.string.fr.addParticipantsHeaderWithCounter = 'Ajouter des participants ({{number}})';
z.string.fr.addParticipantsManageServices = 'Grer les services';
z.string.fr.addParticipantsManageServicesNoResults = 'Grer les services';
z.string.fr.addParticipantsNoServicesManager = 'Les services sont des programmes qui peuvent amliorer votre flux de travail.';
z.string.fr.addParticipantsNoServicesMember = 'Les services sont des programmes qui peuvent amliorer votre flux de travail. Pour les activer, contactez votre administrateur.';
z.string.fr.addParticipantsSearchPlaceholder = 'Rechercher par nom';
z.string.fr.addParticipantsServiceConfirmButton = 'Ajouter un service';
z.string.fr.addParticipantsTabsPeople = 'Personnes';
z.string.fr.addParticipantsTabsServices = 'Services';

z.string.fr.conversationDetailsActionArchive = 'Archiver';
z.string.fr.conversationDetailsActionAddParticipants = 'Ajouter des participants';
z.string.fr.conversationDetailsActionBlock = 'Bloquer';
z.string.fr.conversationDetailsActionCancelRequest = 'Annuler la demande';
z.string.fr.conversationDetailsActionClear = 'Supprimer le contenu';
z.string.fr.conversationDetailsActionConversationParticipants = 'Tout afficher ({{number}})';
z.string.fr.conversationDetailsActionCreateGroup = 'Nouveau groupe';
z.string.fr.conversationDetailsActionDevices = 'Appareils';
z.string.fr.conversationDetailsActionGuestOptions = 'Invits et services';
z.string.fr.conversationDetailsActionTimedMessages = 'Messages phmres';
z.string.fr.conversationDetailsActionNotifications = 'Notifications';
z.string.fr.conversationDetailsActionLeave = 'Quitter le groupe';
z.string.fr.conversationDetailsGuestsOff = 'Dsactiver';
z.string.fr.conversationDetailsGuestsOn = 'Activ';
z.string.fr.conversationDetailsOptions = 'Options';
z.string.fr.conversationDetailsParticipantsServicesOne = 'Service';
z.string.fr.conversationDetailsParticipantsServicesMany = 'Services';
z.string.fr.conversationDetailsParticipantsUsersOne = 'Personne';
z.string.fr.conversationDetailsParticipantsUsersMany = 'Personnes';
z.string.fr.conversationDetailsPeople = 'Personnes';
z.string.fr.conversationDetailsServices = 'Services';

z.string.fr.conversationParticipantsTitle = 'Personnes';
z.string.fr.conversationParticipantsSearchPlaceholder = 'Rechercher par nom';

z.string.fr.groupParticipantActionBlock = 'Bloquer';
z.string.fr.groupParticipantActionCancelRequest = 'Annuler la demande';
z.string.fr.groupParticipantActionDevices = 'Appareils';
z.string.fr.groupParticipantActionIgnoreRequest = 'Ignorer la demande';
z.string.fr.groupParticipantActionIncomingRequest = 'Accepter la demande';
z.string.fr.groupParticipantActionLeave = 'Quitter le groupe';
z.string.fr.groupParticipantActionOpenConversation = 'Ouvrir la conversation';
z.string.fr.groupParticipantActionPending = 'En attente';
z.string.fr.groupParticipantActionRemove = 'Retirer du groupe';
z.string.fr.groupParticipantActionSelfProfile = 'Ouvrir le profil';
z.string.fr.groupParticipantActionSendRequest = 'Se connecter';
z.string.fr.groupParticipantActionUnblock = 'Dbloquer';

z.string.fr.guestOptionsCopyLink = 'Copier le lien';
z.string.fr.guestOptionsCopyLinkDone = 'Lien copi !';
z.string.fr.guestOptionsCreateLink = 'Crer le lien';
z.string.fr.guestOptionsInfoHeader = 'Inviter des personnes via un lien';
z.string.fr.guestOptionsInfoText = 'Nimporte qui avec le lien peut rejoindre la conversation, mme sils nutilisent pas Wire.';
z.string.fr.guestOptionsRevokeLink = 'Rvoquer le lien';
z.string.fr.guestOptionsTitle = 'Invits et services';

z.string.fr.notificationSettingsTitle = 'Notifications';
z.string.fr.notificationSettingsDisclaimer = 'Vous pouvez choisir dtre notifi pour tous les vnements (y compris les appels audios et vidos) ou juste lorsque vous tes mentionn.';
z.string.fr.notificationSettingsEverything = 'Toutes';
z.string.fr.notificationSettingsMentionsAndReplies = 'Mentions et rponses';
z.string.fr.notificationSettingsNothing = 'Aucune';

z.string.fr.timedMessagesTitle = 'Messages phmres';
z.string.fr.timedMessageDisclaimer = 'Les messages phmres seront activs pour tous les participants de cette conversation.';

z.string.fr.participantDevicesDetailHeadline = 'Vrifiez que cela correspond  lempreinte affiche sur {{html1}}lappareil de {{user}}{{html2}}.';
z.string.fr.participantDevicesDetailHowTo = 'Comment faire ?';
z.string.fr.participantDevicesDetailResetSession = 'Rinitialiser la session';
z.string.fr.participantDevicesDetailShowMyDevice = 'Afficher lempreinte de mon appareil';
z.string.fr.participantDevicesDetailVerify = 'Vrifi';

z.string.fr.participantDevicesHeader = 'Appareils';
z.string.fr.participantDevicesHeadline = 'Wire donne  chaque appareil une empreinte unique. Comparez-les avec {{user}} et vrifiez votre conversation.';
z.string.fr.participantDevicesLearnMore = 'En savoir plus';
z.string.fr.participantDevicesWhyVerify = 'Pourquoi vrifier les conversations ?';
z.string.fr.participantDevicesOutdatedClientMessage = '{{user}} utilise une ancienne version de Wire. Aucun appareil nest affich ici.';

z.string.fr.participantDevicesSelfAllDevices = 'Afficher tous mes appareils';
z.string.fr.participantDevicesSelfFingerprint = 'Empreinte de lappareil';

z.string.fr.userProfileButtonConnect = 'Se connecter';
z.string.fr.userProfileButtonIgnore = 'Ignorer';
z.string.fr.userProfileButtonUnblock = 'Dbloquer';

z.string.fr.preferencesAbout = ' propos';
z.string.fr.preferencesAccount = 'Compte';
z.string.fr.preferencesAV = 'Audio / Vido';
z.string.fr.preferencesDeviceDetails = 'Informations de lappareil';
z.string.fr.preferencesDevices = 'Appareils';
z.string.fr.preferencesHeadline = 'Prfrences';
z.string.fr.preferencesOptions = 'Options';

z.string.fr.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.fr.preferencesAboutPrivacyPolicy = 'Politique de confidentialit';
z.string.fr.preferencesAboutSupport = 'Assistance';
z.string.fr.preferencesAboutSupportWebsite = 'Site dassistance de Wire';
z.string.fr.preferencesAboutSupportContact = 'Contacter lassistance technique';
z.string.fr.preferencesAboutTermsOfUse = 'Conditions dutilisation';
z.string.fr.preferencesAboutVersion = 'Version {{version}}';
z.string.fr.preferencesAboutWebsite = 'Site de Wire';

z.string.fr.preferencesAccountAvaibilityUnset = 'Dfinir un statut';
z.string.fr.preferencesAccountCreateTeam = 'Crer une quipe';
z.string.fr.preferencesAccountData = 'Utilisation des Donnes Personnelles';
z.string.fr.preferencesAccountDataCheckbox = 'Envoyer des donnes anonymes';
z.string.fr.preferencesAccountDataDetail = 'Vous pouvez aider  amliorer Wire en envoyant des donnes anonymes sur votre utilisation et des rapports derreur.';
z.string.fr.preferencesAccountDelete = 'Supprimer le compte';
z.string.fr.preferencesAccountLeaveGuestRoom = 'Quitter lespace invit';
z.string.fr.preferencesAccountLeaveGuestRoomDescription = 'Vous ne pourrez plus accder aux messages de cette conversation.';
z.string.fr.preferencesAccountLogOut = 'Se dconnecter';
z.string.fr.preferencesAccountManageTeam = 'Grer lquipe';
z.string.fr.preferencesAccountMarketingConsentCheckbox = 'Recevoir notre newsletter';
z.string.fr.preferencesAccountMarketingConsentDetail = 'Recevoir des e-mails sur les nouveauts de Wire.';
z.string.fr.preferencesAccountResetPassword = 'Rinitialiser le mot de passe';
z.string.fr.preferencesAccountTeam = 'dans {{name}}';
z.string.fr.preferencesAccountUsernamePlaceholder = 'Votre nom complet';
z.string.fr.preferencesAccountUsernameHint = 'Au moins 2 caractres. Uniquement az, 09 et _.';
z.string.fr.preferencesAccountUsernameAvailable = 'Disponible';
z.string.fr.preferencesAccountUsernameErrorTaken = 'Dj pris';

z.string.fr.preferencesAVCamera = 'Webcam';
z.string.fr.preferencesAVMicrophone = 'Microphone';
z.string.fr.preferencesAVPermissionDetail = 'Activer  partir des prfrences de votre navigateur';
z.string.fr.preferencesAVSpeakers = 'Haut-parleurs';
z.string.fr.preferencesAVTemporaryDisclaimer = 'Les invits ne peuvent pas dmarrer de vidoconfrences. Slectionnez la camra  utiliser si vous en rejoignez une.';
z.string.fr.preferencesAVNoCamera = 'Wire na pas accs  la camra.[br][faqLink]Lisez cet article[/faqLink] pour savoir comment rsoudre ce problme.';
z.string.fr.preferencesAVTryAgain = 'Ressayez';

z.string.fr.preferencesDevicesActivatedOn = 'Activ le {{date}}';
z.string.fr.preferencesDevicesActive = 'Actifs';
z.string.fr.preferencesDevicesActiveDetail = 'Si vous ne reconnaissez pas lun des appareils ci-dessus, supprimez-le et changez votre mot de passe.';
z.string.fr.preferencesDevicesCurrent = 'Actuel';
z.string.fr.preferencesDevicesFingerprint = 'Empreinte';
z.string.fr.preferencesDevicesFingerprintDetail = 'Wire donne  chaque appareil une empreinte unique. Comparez-les et vrifiez vos appareils et conversations.';
z.string.fr.preferencesDevicesId = 'ID : ';
z.string.fr.preferencesDevicesRemove = 'Supprimer';
z.string.fr.preferencesDevicesRemoveCancel = 'Annuler';
z.string.fr.preferencesDevicesRemoveDetail = 'Supprimez ce priphrique si vous avez cess de lutiliser. Vous serez dconnect de cet appareil immdiatement.';
z.string.fr.preferencesDevicesSessionConfirmation = 'La session a t rinitialise.';
z.string.fr.preferencesDevicesSessionDetail = 'Si les empreintes ne correspondent pas, rinitialisez la session afin de gnrer de nouvelles cls de chiffrement des deux cts.';
z.string.fr.preferencesDevicesSessionReset = 'Rinitialiser la session';
z.string.fr.preferencesDevicesSessionOngoing = 'Rinitialisation de la session';
z.string.fr.preferencesDevicesVerification = 'Vrifi';

z.string.fr.preferencesOptionsAudio = 'Alertes sonores';
z.string.fr.preferencesOptionsAudioAll = 'Toutes';
z.string.fr.preferencesOptionsAudioAllDetail = 'Tous les sons';
z.string.fr.preferencesOptionsAudioNone = 'Aucune';
z.string.fr.preferencesOptionsAudioNoneDetail = 'Chuuut !';
z.string.fr.preferencesOptionsAudioSome = 'Certaines';
z.string.fr.preferencesOptionsAudioSomeDetail = 'Signes et appels';
z.string.fr.preferencesOptionsContacts = 'Contacts';
z.string.fr.preferencesOptionsContactsGmail = 'Importer depuis Gmail';
z.string.fr.preferencesOptionsContactsMacos = 'Importer depuis Contacts';
z.string.fr.preferencesOptionsContactsDetail = 'Nous utilisons les donnes de vos contacts afin de vous connecter  dautres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne dautre.';
z.string.fr.preferencesOptionsPopular = ' la demande gnrale';
z.string.fr.preferencesOptionsEmojiReplaceCheckbox = 'Remplace les moticnes typographiques par des emojis';
z.string.fr.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.fr.preferencesOptionsPreviewsSendCheckbox = 'Cre des aperus pour les liens que vous envoyez';
z.string.fr.preferencesOptionsPreviewsSendDetail = 'Les aperus pourront toujours safficher pour les liens dautres personnes.';
z.string.fr.preferencesOptionsNotifications = 'Notifications';
z.string.fr.preferencesOptionsNotificationsNone = 'Dsactiver';
z.string.fr.preferencesOptionsNotificationsObfuscate = 'Masquer les dtails';
z.string.fr.preferencesOptionsNotificationsObfuscateMessage = 'Afficher lexpditeur';
z.string.fr.preferencesOptionsNotificationsOn = 'Afficher lexpditeur et le message';
z.string.fr.preferencesOptionsCallLogs = 'Rsolution de problmes';
z.string.fr.preferencesOptionsCallLogsGet = 'Sauvegarder le rapport de dbogage des appels';
z.string.fr.preferencesOptionsCallLogsDetail = 'Cette information aide lassistance de Wire  diagnostiquer les problmes dappel.';

z.string.fr.preferencesOptionsBackupHeader = 'Historique';
z.string.fr.preferencesOptionsBackupExportHeadline = 'Sauvegarder les conversations';
z.string.fr.preferencesOptionsBackupExportSecondary = 'Crez une sauvegarde afin de conserver lhistorique de vos conversations. Vous pourrez utiliser celle-ci si vous perdez votre priphrique ou si vous basculez vers un nouveau.\nLe fichier de sauvegarde nest pas protg par le chiffrement de bout-en-bout de Wire, enregistrez-le dans un endroit sr.';
z.string.fr.preferencesOptionsBackupImportHeadline = 'Restaurer depuis une sauvegarde';
z.string.fr.preferencesOptionsBackupImportSecondary = 'Vous pouvez uniquement restaurer lhistorique depuis une sauvegarde provenant dune plateforme identique. Ceci effacera les conversations que vous avez dj sur cet appareil.';

z.string.fr.backupExportGenericErrorHeadline = 'Le fichier na pas pu tre sauvegard';
z.string.fr.backupExportGenericErrorSecondary = 'La sauvegarde a chou.';
z.string.fr.backupExportProgressHeadline = 'Prparation en cours';
z.string.fr.backupExportProgressSecondary = 'Sauvegarde en cours  {{processed}} sur {{total}}  {{progress}}%';
z.string.fr.backupExportProgressCompressing = 'Fichier de sauvegarde en prparation';
z.string.fr.backupExportSaveFileAction = 'Enregistrer le fichier';
z.string.fr.backupExportSuccessHeadline = 'Sauvegarde prte';
z.string.fr.backupExportSuccessSecondary = 'Vous pourrez utiliser cette sauvegarde si vous perdez votre priphrique ou si vous basculez vers un nouveau.';
z.string.fr.backupImportGenericErrorHeadline = 'Une erreur est survenue';
z.string.fr.backupImportGenericErrorSecondary = 'Votre historique na pas pu tre restaur.';
z.string.fr.backupImportAccountErrorHeadline = 'Fichier de sauvegarde invalide';
z.string.fr.backupImportAccountErrorSecondary = 'Vous ne pouvez pas restaurer lhistoire dun autre compte.';
z.string.fr.backupImportVersionErrorHeadline = 'Sauvegarde incompatible';
z.string.fr.backupImportVersionErrorSecondary = 'Cette sauvegarde a t cre par une version plus rcente ou expire de Wire et ne peut pas tre restaure ici.';
z.string.fr.backupImportIncompatibleErrorHeadline = 'Fichier de sauvegarde invalide';
z.string.fr.backupImportIncompatibleErrorSecondary = 'Vous ne pouvez pas restaurer lhistoire dun autre compte.';
z.string.fr.backupImportOutdatedErrorHeadline = 'Sauvegarde incompatible';
z.string.fr.backupImportOutdatedErrorSecondary = 'Cette sauvegarde a t cre par une version plus rcente ou expire de Wire et ne peut pas tre restaure ici.';
z.string.fr.backupImportProgressHeadline = 'Prparation en cours';
z.string.fr.backupImportProgressSecondary = 'Restauration en cours  {{processed}} sur {{total}}  {{progress}}%';
z.string.fr.backupImportSuccessHeadline = 'Lhistorique a t restaur.';
z.string.fr.backupCancel = 'Annuler';
z.string.fr.backupTryAgain = 'Ressayez';

z.string.fr.searchConnect = 'Se connecter';
z.string.fr.searchConnections = 'Contacts';
z.string.fr.searchContacts = 'Contacts';
z.string.fr.searchCreateGroup = 'Crer un groupe';
z.string.fr.searchCreateGuestRoom = 'Crer un espace pour invits';
z.string.fr.searchGroups = 'Groupes';
z.string.fr.searchPeople = 'Personnes';
z.string.fr.searchPlaceholder = 'Chercher par nom ou par identifiant';
z.string.fr.searchServicePlaceholder = 'Rechercher par nom';
z.string.fr.searchServices = 'Services';
z.string.fr.searchManageServices = 'Grer les Services';
z.string.fr.searchManageServicesNoResults = 'Grer les services';
z.string.fr.searchNoServicesManager = 'Les services sont des programmes qui peuvent amliorer votre flux de travail.';
z.string.fr.searchNoServicesMember = 'Les services sont des programmes qui peuvent amliorer votre flux de travail. Pour les activer, contactez votre administrateur.';
z.string.fr.searchTeamGroups = 'Conversations dquipe';
z.string.fr.searchTeamMembers = 'Membres de lquipe';
z.string.fr.searchTopPeople = 'Contacts favoris';
z.string.fr.searchTrySearch = 'Trouver des contacts par\nnom ou identifiant';
z.string.fr.searchNoContactsOnWire = 'Vous navez pas de contacts sur Wire.\nEssayez de trouver des gens par\nleur nom ou leur nom dutilisateur.';
z.string.fr.searchMemberInvite = 'Inviter des personnes  rejoindre lquipe';
z.string.fr.searchOthers = 'Se connecter';

z.string.fr.searchInvite = 'Invitez des personnes  rejoindre Wire';
z.string.fr.searchInviteDetail = 'Partager vos contacts vous permet de vous connecter  dautres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne dautre.';
z.string.fr.searchInviteButtonContacts = 'Depuis vos contacts';
z.string.fr.searchInviteButtonGmail = 'Depuis Gmail';
z.string.fr.searchInviteHeadline = 'Invitez vos amis';
z.string.fr.searchInviteShare = 'Partagez vos contacts';

z.string.fr.searchServiceConfirmButton = 'Ajouter un service';

z.string.fr.searchListEveryoneParticipates = 'Toutes les personnes\navec qui vous tes connect(e)\nsont dj dans cette conversation.';
z.string.fr.searchListNoMatches = 'Aucun rsultat.\nEssayez avec un nom diffrent.';

z.string.fr.temporaryGuestCta = 'Crer un compte';
z.string.fr.temporaryGuestDescription = 'Protgez votre activit avec des messages de groupe et des appels chiffrs.';
z.string.fr.temporaryGuestTimeRemaining = ' restants dans cet espace pour invits';

z.string.fr.temporaryGuestJoinMessage = 'Cette conversation vous sera accessible pendant 24 heures.';
z.string.fr.temporaryGuestJoinDescription = 'Si vous fermez ou rafrachissez cette page, votre accs sera perdu.';

z.string.fr.temporaryGuestLeaveMessage = ' ne font plus partie de cette conversation.';
z.string.fr.temporaryGuestLeaveDescription = 'Si vous fermez ou rafrachissez cette page, votre naurez plus accs  lhistorique de cette conversation.';

z.string.fr.uploadGoogleHeadline = 'Trouvez des personnes\n qui parler.';
z.string.fr.uploadGoogleMessage = 'Nous utilisons les donnes de vos contacts afin de vous connecter  dautres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne dautre.';

z.string.fr.urlSupportRoot = '/';
z.string.fr.urlWebappRoot = '/';
z.string.fr.urlWebsiteRoot = '/';
z.string.fr.urlWebsiteCreateTeam = '/create-team/';
z.string.fr.warningCallUnsupportedIncoming = '{{user}} vous appelle. Votre navigateur ne prend pas en charge les appels.';
z.string.fr.warningCallUnsupportedOutgoing = 'Vous ne pouvez pas appeler parce que votre navigateur ne prend pas en charge les appels.';
z.string.fr.warningCallIssues = 'Cette version de Wire ne peut pas participer  cet appel. Utilisez plutt';
z.string.fr.warningCallUpgradeBrowser = 'Pour pouvoir appeler, mettez  jour Google Chrome.';
z.string.fr.warningConnectivityConnectionLost = 'Tentative de connexion. Wire nest peut-tre pas en mesure denvoyer des messages.';
z.string.fr.warningConnectivityNoInternet = 'Pas de connexion Internet. Vous ne pourrez pas envoyer ou recevoir de messages.';
z.string.fr.warningLearnMore = 'En savoir plus';
z.string.fr.warningLifecycleUpdate = 'Une nouvelle version de Wire est disponible.';
z.string.fr.warningLifecycleUpdateNotes = 'Nouveauts';
z.string.fr.warningLifecycleUpdateLink = 'Mettre  jour maintenant';
z.string.fr.warningNotFoundCamera = 'Vous ne pouvez pas appeler car votre ordinateur ne dispose pas dune webcam.';
z.string.fr.warningNotFoundMicrophone = 'Vous ne pouvez pas appeler car votre ordinateur ne dispose pas dun micro.';
z.string.fr.warningPermissionDeniedCamera = 'Vous ne pouvez pas appeler car votre navigateur na pas accs  votre webcam.';
z.string.fr.warningPermissionDeniedMicrophone = 'Vous ne pouvez pas appeler car votre navigateur na pas accs  votre micro.';
z.string.fr.warningPermissionDeniedScreen = 'Votre navigateur a besoin de votre permission pour partager votre cran.';
z.string.fr.warningPermissionRequestCamera = '{{icon}} Autoriser laccs  la webcam';
z.string.fr.warningPermissionRequestMicrophone = '{{icon}} Autoriser laccs au micro';
z.string.fr.warningPermissionRequestNotification = '{{icon}} Autoriser les notifications';
z.string.fr.warningPermissionRequestScreen = '{{icon}} Autoriser laccs  lcran';

z.string.fr.userAvailabilityAvailable = 'Disponible';
z.string.fr.userAvailabilityAway = 'Absent(e)';
z.string.fr.userAvailabilityBusy = 'Occup(e)';
z.string.fr.userAvailabilityNone = 'Aucune';

z.string.fr.notificationAssetAdd = 'A partag une image';
z.string.fr.notificationConnectionAccepted = 'A accept votre demande de connexion';
z.string.fr.notificationConnectionConnected = 'Vous tes connect';
z.string.fr.notificationConnectionRequest = 'Souhaite se connecter';
z.string.fr.notificationConversationCreate = '{{user}} a commenc une conversation';
z.string.fr.notificationConversationMessageTimerUpdate = '{{user}} a dfini les messages phmres  {{time}}';
z.string.fr.notificationConversationMessageTimerReset = '{{user}} a dsactiv les messages phmres';
z.string.fr.notificationConversationRename = '{{user}} a renomm la conversation en {{name}}';
z.string.fr.notificationMemberJoinMany = '{{user}} a ajout {{number}} personnes  la conversation';
z.string.fr.notificationMemberJoinSelf = '{{user}} a rejoint la conversation';
z.string.fr.notificationMemberJoinOne = '{{user1}} a ajout {{user2}}  la conversation';
z.string.fr.notificationMemberLeaveRemovedYou = '{{user}} vous a exclu de la conversation';
z.string.fr.notificationMention = 'Nouvelle mention :';
z.string.fr.notificationObfuscated = 'vous a envoy un message';
z.string.fr.notificationObfuscatedMention = 'Vous a mentionn';
z.string.fr.notificationObfuscatedReply = 'Vous a rpondu';
z.string.fr.notificationObfuscatedTitle = 'Quelquun';
z.string.fr.notificationPing = 'a fait un signe';
z.string.fr.notificationReaction = '{{reaction}} votre message';
z.string.fr.notificationReply = 'Rponse: {{text}}';
z.string.fr.notificationSharedAudio = 'A partag un message vocal';
z.string.fr.notificationSharedFile = 'A partag un fichier';
z.string.fr.notificationSharedLocation = 'A partag une position';
z.string.fr.notificationSharedVideo = 'A partag une vido';
z.string.fr.notificationTitleGroup = '{{user}} dans {{conversation}}';
z.string.fr.notificationVoiceChannelActivate = 'Appel en cours';
z.string.fr.notificationVoiceChannelDeactivate = 'vous a appel';

z.string.fr.tooltipConversationAllVerified = 'Toutes les empreintes sont vrifies';
z.string.fr.tooltipConversationCall = 'Appeler';
z.string.fr.tooltipConversationEphemeral = 'Message phmre';
z.string.fr.tooltipConversationFile = 'Ajouter un fichier';
z.string.fr.tooltipConversationInputPlaceholder = 'crivez un message';
z.string.fr.tooltipConversationInputPlaceholderAvailable = '{{user}} est disponible';
z.string.fr.tooltipConversationInputPlaceholderAway = '{{user}} est absent(e)';
z.string.fr.tooltipConversationInputPlaceholderBusy = '{{user}} est occup(e)';
z.string.fr.tooltipConversationPeople = 'Personnes ({{shortcut}})';
z.string.fr.tooltipConversationPicture = 'Ajouter une image';
z.string.fr.tooltipConversationPing = 'Faire un signe ({{shortcut}})';
z.string.fr.tooltipConversationSearch = 'Recherche';
z.string.fr.tooltipConversationVideoCall = 'Appel vido';

z.string.fr.tooltipConversationsArchive = 'Archiver ({{shortcut}})';
z.string.fr.tooltipConversationsArchived = 'Voir les archives ({{number}})';
z.string.fr.tooltipConversationsMore = 'Plus';
z.string.fr.tooltipConversationsNotifications = 'Ouvrir les paramtres de notifications ({{shortcut}})';
z.string.fr.tooltipConversationsNotify = 'Activer les notifications ({{shortcut}})';
z.string.fr.tooltipConversationsPreferences = 'Ouvrir les prfrences';
z.string.fr.tooltipConversationsSilence = 'Dsactiver les notifications ({{shortcut}})';
z.string.fr.tooltipConversationsStart = 'Commencer une conversation ({{shortcut}})';

z.string.fr.tooltipConversationDetailsAddPeople = 'Ajouter des participants  la conversation ({{shortcut}})';
z.string.fr.tooltipConversationDetailsRename = 'Changer le nom de la conversation';

z.string.fr.tooltipPreferencesContactsGmail = 'Connectez-vous  votre compte Gmail pour importer des contacts';
z.string.fr.tooltipPreferencesContactsMacos = 'Partagez tous vos contacts depuis lapplication Contacts de macOS';
z.string.fr.tooltipPreferencesPassword = 'Ouvre une page web pour rinitialiser votre mot de passe';
z.string.fr.tooltipPreferencesPicture = 'Changez votre image de profil';
z.string.fr.tooltipPreferencesRename = 'Changez votre nom';

z.string.fr.tooltipSearchClose = 'Fermer (chap)';

z.string.fr.initReceivedSelfUser = 'Bonjour, {{user}}.';
z.string.fr.initValidatedClient = 'Tlchargement de vos contacts et de vos conversations';
z.string.fr.initReceivedUserData = 'Recherche de nouveaux messages';
z.string.fr.initDecryption = 'Dchiffrement des messages';
z.string.fr.initEvents = 'Chargement des messages';
z.string.fr.initUpdatedFromNotifications = 'Presque termin - Profitez de Wire';
z.string.fr.initProgress = '  {{number1}} sur {{number2}}';

z.string.fr.ephemeralUnitsNone = 'Dsactiver';
z.string.fr.ephemeralUnitsSecond = 'seconde';
z.string.fr.ephemeralUnitsSeconds = 'secondes';
z.string.fr.ephemeralUnitsMinute = 'minute';
z.string.fr.ephemeralUnitsMinutes = 'minutes';
z.string.fr.ephemeralUnitsHour = 'heure';
z.string.fr.ephemeralUnitsHours = 'heures';
z.string.fr.ephemeralUnitsDay = 'jour';
z.string.fr.ephemeralUnitsDays = 'jours';
z.string.fr.ephemeralUnitsWeek = 'semaine';
z.string.fr.ephemeralUnitsWeeks = 'semaines';
z.string.fr.ephemeralUnitsYear = 'anne';
z.string.fr.ephemeralUnitsYears = 'annes';
z.string.fr.ephemeralRemaining = 'restant';

z.string.fr.replyAudioMessage = 'Message vocal';
z.string.fr.replyQuoteError = 'Vous ne pouvez pas voir ce message.';
z.string.fr.replyQuoteShowMore = 'Plus';
z.string.fr.replyQuoteShowLess = 'Rduire';
z.string.fr.replyQuoteTimeStampDate = 'Message original du {{date}}';
z.string.fr.replyQuoteTimeStampTime = 'Message original de {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.hr.wireMacos = 'Wire za macOS';
z.string.hr.wireWindows = 'Wire za Windows';
z.string.hr.wireLinux = 'Wire za Linux';
z.string.hr.nonexistentUser = 'Izbrisani korisnik';
z.string.hr.and = 'i';

z.string.hr.authAccountCountryCode = 'Pozivni broj';
z.string.hr.authAccountPasswordForgot = 'Zaboravljena lozinka';
z.string.hr.authAccountSignIn = 'Prijava';
z.string.hr.authAccountSignInPhone = 'Telefon';

z.string.hr.authVerifyAccountAdd = 'Dodaj';
z.string.hr.authVerifyAccountDetail = 'Ovo Vam omoguuje da koristite Wire na vie ureaja.';
z.string.hr.authVerifyAccountHeadline = 'Dodajte email adresu i lozinku.';
z.string.hr.authVerifyAccountLogout = 'Odjava';
z.string.hr.authVerifyCodeDescription = 'Unesite kontrolni kod koji smo poslali na {{number}}.';
z.string.hr.authVerifyCodeResend = 'Kod se ne pojavljuje?';
z.string.hr.authVerifyCodeResendDetail = 'Ponovno poalji';
z.string.hr.authVerifyCodeResendTimer = 'Moete zatraiti novi kod {{expiration}}.';
z.string.hr.authVerifyCodeChangePhone = 'Promjeni broj telefona';
z.string.hr.authVerifyPasswordHeadline = 'Upiite Vau ifru';

z.string.hr.authLimitDevicesHeadline = 'Ureaji';
z.string.hr.authLimitDescription = 'Uklonite jedan od Vaih ostalih ureaja kako bi ste poeli koristiti Wire na ovom.';
z.string.hr.authLimitButtonManage = 'Upravljanje ureajima';
z.string.hr.authLimitButtonSignOut = 'Odjava';
z.string.hr.authLimitDevicesCurrent = '(Trenutno)';

z.string.hr.authHistoryHeadline = 'Ovo je prvi put da koristite Wire na ovom ureaju.';
z.string.hr.authHistoryDescription = 'Iz sigurnosnih razloga, povijest razgovora se nee pojaviti ovdje.';
z.string.hr.authHistoryReuseHeadline = 'Ve ste upotrebljavali Wire na ovom ureaju.';
z.string.hr.authHistoryReuseDescription = 'Poruke poslane u meuvremenu nee se pojaviti.';
z.string.hr.authHistoryButton = 'U redu';

z.string.hr.authPostedResend = 'Ponovno poalji na {{email}}';
z.string.hr.authPostedResendAction = 'Email se ne pojavljuje?';
z.string.hr.authPostedResendDetail = 'Provjerite svoj email sandui i slijedite upute.';
z.string.hr.authPostedResendHeadline = 'Imate potu.';

z.string.hr.authPlaceholderEmail = 'Email';
z.string.hr.authPlaceholderPasswordPut = 'Lozinka';
z.string.hr.authPlaceholderPasswordSet = 'Lozinka (najmanje 8 znakova)';
z.string.hr.authPlaceholderPhone = 'Telefonski broj';

z.string.hr.authErrorCode = 'Neispravan kod';
z.string.hr.authErrorCountryCodeInvalid = 'Nevaei kod drave';
z.string.hr.authErrorEmailExists = 'Email adresa je ve u upotrebi';
z.string.hr.authErrorEmailForbidden = 'Ova email adresa je zabranjena.';
z.string.hr.authErrorEmailMalformed = 'Molimo unesite ispravnu e-mail adresu.';
z.string.hr.authErrorEmailMissing = 'Molimo unesite email adresu.';
z.string.hr.authErrorMisc = 'Problemi s vezom. Molimo pokuajte ponovo.';
z.string.hr.authErrorNameShort = 'Unesite naziv s najmanje 2 znaka';
z.string.hr.authErrorOffline = 'Nema internetske veze';
z.string.hr.authErrorPasswordShort = 'Odaberite lozinku s najmanje 8 znakova.';
z.string.hr.authErrorPasswordWrong = 'Pogrena lozinka, molimo pokuajte ponovno.';
z.string.hr.authErrorPhoneNumberForbidden = 'Ova email adresa je zabranjena.';
z.string.hr.authErrorPhoneNumberInvalid = 'Nevaei broj';
z.string.hr.authErrorPhoneNumberUnknown = 'Nepoznat broj';
z.string.hr.authErrorSignIn = 'Molimo provjerite vae podatke i pokuajte ponovno.';

z.string.hr.callStateOutgoing = 'Zvoni...';
z.string.hr.callStateConnecting = 'Povezivanje';
z.string.hr.callStateIncoming = 'Pozivanje';
z.string.hr.callDecline = 'Odbij';
z.string.hr.callAccept = 'Prihvati';
z.string.hr.callJoin = 'Pridrui se';
z.string.hr.callChooseSharedScreen = 'Odaberite zaslon za zajedniko koritenje';

z.string.hr.videoCallOverlayMute = 'Iskljui zvuk';
z.string.hr.videoCallOverlayHangUp = 'Poklopi';

z.string.hr.modalAcknowledgeAction = 'Ok';
z.string.hr.modalConfirmSecondary = 'Odustani';
z.string.hr.modalOptionSecondary = 'Odustani';

z.string.hr.modalAccountCreateAction = 'U redu';

z.string.hr.modalAccountDeletionAction = 'Obrii';
z.string.hr.modalAccountDeletionHeadline = 'Brisanje rauna';
z.string.hr.modalAccountDeletionMessage = 'Poslati emo Vam poslati poruku putem e-maila ili SMS-a. Slijedite link za trajno brisanje rauna.';

z.string.hr.modalAccountLeaveGuestRoomAction = 'Izai';

z.string.hr.modalAccountLogoutAction = 'Odjava';
z.string.hr.modalAccountLogoutHeadline = 'Obrii podatke?';
z.string.hr.modalAccountLogoutOption = 'Izbrii sve osobne informacije i razgovore na ovom ureaju.';

z.string.hr.modalAccountNewDevicesSecondary = 'Upravljanje ureajima';
z.string.hr.modalAccountNewDevicesHeadline = 'Va raun je koriten na:';
z.string.hr.modalAccountNewDevicesFrom = 'alje:';
z.string.hr.modalAccountNewDevicesMessage = 'Ako niste to uinili, uklonite ureaj i ponovno postavite lozinku.';

z.string.hr.modalAccountRemoveDeviceAction = 'Uklanjanje ureaja';
z.string.hr.modalAccountRemoveDeviceHeadline = 'Uklanjanje "{{device}}"';
z.string.hr.modalAccountRemoveDeviceMessage = 'Lozinka potrebna za uklanjanje ureaja.';
z.string.hr.modalAccountRemoveDevicePlaceholder = 'Lozinka';

z.string.hr.modalAssetTooLargeMessage = 'Moete poslati datoteke do {{number}}';

z.string.hr.modalAssetParallelUploadsMessage = 'Moete poslati {{number}} datoteke odjednom.';

z.string.hr.modalCallEmptyConversationHeadline = 'Nemam koga zvati';
z.string.hr.modalCallEmptyConversationMessage = 'Nema osoba u konverzaciji.';

z.string.hr.modalCallNoGroupVideoHeadline = 'Nema video poziva u grupama';
z.string.hr.modalCallNoGroupVideoMessage = 'Video pozivi nisu dostupni u grupnim razgovorima.';

z.string.hr.modalCallNoMicrophoneAction = 'Recite mi kako';
z.string.hr.modalCallNoMicrophoneMessage = 'Your browser needs access to the microphone to make calls.';
z.string.hr.modalCallNoMicrophoneHeadline = 'Poziv nije mogu bez mikrofona';

z.string.hr.modalCallSecondIncomingAction = 'Odgovori';
z.string.hr.modalCallSecondIncomingHeadline = 'Odgovoriti na poziv?';
z.string.hr.modalCallSecondIncomingMessage = 'Va trenutni poziv e zavriti.';

z.string.hr.modalCallSecondOngoingAction = 'Poklopi';
z.string.hr.modalCallSecondOngoingHeadline = 'Prekini poziv na drugom ureaju?';
z.string.hr.modalCallSecondOngoingMessage = 'Moete biti u samo jednom pozivu u isto vrijeme.';

z.string.hr.modalCallSecondOutgoingAction = 'Poklopi';
z.string.hr.modalCallSecondOutgoingHeadline = 'Prekinuti trenutni poziv?';
z.string.hr.modalCallSecondOutgoingMessage = 'Moete biti u samo jednom pozivu u isto vrijeme.';

z.string.hr.modalConnectCancelAction = 'Da';
z.string.hr.modalConnectCancelHeadline = 'Ponititi zahtjev?';
z.string.hr.modalConnectCancelMessage = 'Uklanjanje zahtjeva za povezivanje s {{user}}.';
z.string.hr.modalConnectCancelSecondary = 'Ne';

z.string.hr.modalConnectAcceptAction = 'Povei se';
z.string.hr.modalConnectAcceptHeadline = 'Prihvatiti?';
z.string.hr.modalConnectAcceptMessage = 'Ovo e vas spojiti i otvoriti razgovor s {{user}}.';
z.string.hr.modalConnectAcceptSecondary = 'Ignoriraj';

z.string.hr.modalConversationClearAction = 'Obrii';
z.string.hr.modalConversationClearHeadline = 'Izbrisati sadraj?';
z.string.hr.modalConversationClearOption = 'Takoer napusti razgovor';

z.string.hr.modalConversationDeleteMessageAction = 'Obrii';
z.string.hr.modalConversationDeleteMessageHeadline = 'Izbrii samo za mene?';
z.string.hr.modalConversationDeleteMessageMessage = 'Ovo se ne moe ponititi.';

z.string.hr.modalConversationDeleteMessageEveryoneAction = 'Obrii';
z.string.hr.modalConversationDeleteMessageEveryoneHeadline = 'Izbrii za sve?';
z.string.hr.modalConversationDeleteMessageEveryoneMessage = 'Ovo se ne moe ponititi.';

z.string.hr.modalConversationLeaveAction = 'Izai';
z.string.hr.modalConversationLeaveMessage = 'Neete moi slati ili primati poruke u ovom razgovoru.';

z.string.hr.modalConversationMessageTooLongHeadline = 'Poruka preduga';
z.string.hr.modalConversationMessageTooLongMessage = 'Moete slati poruke do {{number}} znakova.';

z.string.hr.modalConversationNewDeviceHeadlineOne = '{{user}} poeo koristiti novi ureaj';
z.string.hr.modalConversationNewDeviceHeadlineMany = '{{users}} je poeo/ poela koristiti nove ureaje';
z.string.hr.modalConversationNewDeviceHeadlineYou = '{{user}} poeo koristiti novi ureaj';
z.string.hr.modalConversationNewDeviceMessage = 'Jo uvijek elite poslati poruku?';
z.string.hr.modalConversationNewDeviceOutgoingCallAction = 'Svejedno iniciraj poziv';

z.string.hr.modalConversationNotConnectedMessageOne = '{{name}} ne eli biti dodan/a razgovorima.';
z.string.hr.modalConversationNotConnectedMessageMany = 'Jedna od osoba koje ste odabrali ne eli biti dodana u razgovore.';

z.string.hr.modalConversationRemoveAction = 'Ukloni';
z.string.hr.modalConversationRemoveHeadline = 'Ukloniti?';
z.string.hr.modalConversationRemoveMessage = '{{user}} nee moi slati ili primati poruke u ovom razgovoru.';

z.string.hr.modalConversationRemoveGuestsAction = 'Ukloni';

z.string.hr.modalConversationTooManyMembersHeadline = 'Puna kua';



z.string.hr.modalImproveWireAction = 'Prihvati';
z.string.hr.modalImproveWireSecondary = 'Ne';

z.string.hr.modalSessionResetHeadline = 'Sesija je resetirana';
z.string.hr.modalSessionResetMessage1 = 'Ako problem nije razrijeen,';
z.string.hr.modalSessionResetMessageLink = 'kontaktirajte';
z.string.hr.modalSessionResetMessage2 = 'nas.';

z.string.hr.modalUploadContactsAction = 'Pokuaj ponovno';
z.string.hr.modalUploadContactsMessage = 'Nismo dobili podatke. Pokuajte ponovno uvesti svoje kontakte.';

z.string.hr.modalUserBlockAction = 'Blokiraj';
z.string.hr.modalUserBlockHeadline = 'Blokiraj {{user}}?';
z.string.hr.modalUserBlockMessage = '{{user}} nee biti u mogunosti kontaktirati vas ili vas pozvati u grupnu konverzaciju.';

z.string.hr.modalUserUnblockAction = 'Odblokiraj';
z.string.hr.modalUserUnblockHeadline = 'Odblokirati?';

z.string.hr.connectionRequestConnect = 'Povei se';
z.string.hr.connectionRequestIgnore = 'Ignoriraj';

z.string.hr.conversationYouNominative = 'ti';
z.string.hr.conversationYouDative = 'ti';
z.string.hr.conversationYouAccusative = 'ti';

z.string.hr.conversationConnectionAccepted = 'Povezani';
z.string.hr.conversationConnectionBlocked = 'Blokiran';
z.string.hr.conversationConnectionCancelRequest = 'Odjavi zahtjev za vezu';
z.string.hr.conversationDeviceStartedUsingOne = ' poela/o koristiti';
z.string.hr.conversationDeviceStartedUsingMany = ' poela/o koristiti';
z.string.hr.conversationDeviceUnverified = ' neverificirala/o je jedan od';
z.string.hr.conversationDeviceYourDevices = ' tvojih ureaja';
z.string.hr.conversationDeviceUserDevices = ' {{user}} ureaji';
z.string.hr.conversationDeviceNewDeviceOne = ' novi ureaj';
z.string.hr.conversationDeviceNewDeviceMany = ' novi ureaji';
z.string.hr.conversationJustNow = 'Upravo';
z.string.hr.conversationLocationLink = 'Otvori kartu';
z.string.hr.conversationMessageDelivered = 'Dostavljeno';
z.string.hr.conversationRename = ' preimenovala/o razgovor';
z.string.hr.conversationRenameYou = ' preimenovala/o razgovor';
z.string.hr.conversationResume = 'Zaponi razgovor s {{users}}';
z.string.hr.conversationPing = ' pingala/o';
z.string.hr.conversationPingYou = ' pingala/o';
z.string.hr.conversationToday = 'danas';
z.string.hr.conversationVoiceChannelDeactivate = ' zvao';
z.string.hr.conversationVoiceChannelDeactivateYou = ' zvao';
z.string.hr.conversationYesterday = 'Juer';
z.string.hr.conversationUnableToDecrypt1 = 'poruka od {{user}} nije primljena.';
z.string.hr.conversationUnableToDecrypt2 = '{{user}} identitet ureaja promijenjen. Neisporuena poruka.';
z.string.hr.conversationUnableToDecryptLink = 'Zato?';
z.string.hr.conversationUnableToDecryptErrorMessage = 'Pogreka';
z.string.hr.conversationUnableToDecryptResetSession = 'Resetiraj sesiju';
z.string.hr.conversationMissedMessages = 'Niste upotrebljavali ovaj ureaj neko vrijeme. Neke poruke moda nee biti vidljive na njemu.';
z.string.hr.conversationAssetDownloading = 'Preuzimanje';
z.string.hr.conversationAssetUploadFailed = 'Prijenos neuspjean';
z.string.hr.conversationPlaybackError = 'Reprodukcija neuspjena';
z.string.hr.conversationContextMenuCopy = 'Kopiraj';
z.string.hr.conversationContextMenuEdit = 'Promjeni';
z.string.hr.conversationContextMenuDelete = 'Brisanje poruke za mene';
z.string.hr.conversationContextMenuDeleteEveryone = 'Brisanje poruke za sve sudionike';
z.string.hr.conversationContextMenuDownload = 'Preuzimanje';
z.string.hr.conversationContextMenuLike = 'Svia mi se';
z.string.hr.conversationContextMenuUnlike = 'Ne svia mi se';
z.string.hr.conversationDeleteTimestamp = 'Izbrisano na {{date}}';
z.string.hr.conversationEditTimestamp = 'Promijenjeno na {{date}}';
z.string.hr.conversationLikesCaption = '{{number}} ljudi';
z.string.hr.conversationSendPastedFile = 'Slika zaljepljena na {{date}}';
z.string.hr.conversationSomeone = 'Netko';
z.string.hr.conversationTweetAuthor = ' na Twitteru';

z.string.hr.groupCreationParticipantsPlaceholder = 'Trai po imenu';


z.string.hr.collectionSectionLinks = 'Linkovi';
z.string.hr.collectionSectionImages = 'Slike';
z.string.hr.collectionSectionFiles = 'Dokumenti';

z.string.hr.fullsearchPlaceholder = 'Pretrai poruke';
z.string.hr.fullsearchNoResults = 'Nema rezultata.';

z.string.hr.archiveHeader = 'Arhiviraj';

z.string.hr.conversationsAllArchived = 'Sve arhivirano';
z.string.hr.conversationsContacts = 'Kontakti';
z.string.hr.conversationsConnectionRequestMany = '{{number}} ljudi ekaju';
z.string.hr.conversationsConnectionRequestOne = '1 osoba eka';
z.string.hr.conversationsEmptyConversation = 'Grupni razgovor';
z.string.hr.conversationsNoConversations = 'Nema razgovora';
z.string.hr.conversationsPopoverArchive = 'Arhiviraj';
z.string.hr.conversationsPopoverCancel = 'Poniti zahtjev';
z.string.hr.conversationsPopoverNotify = 'Ukljui zvuk';
z.string.hr.conversationsPopoverSilence = 'Iskljui zvuk';
z.string.hr.conversationsPopoverUnarchive = 'Dearhiviraj';

z.string.hr.conversationsSecondaryLineEphemeralMessage = 'Poslao ti je poruku';

z.string.hr.takeoverSub = 'Zatraite svoje jedinstveno ime na Wire.';
z.string.hr.takeoverLink = 'Saznaj vie';
z.string.hr.takeoverButtonChoose = 'Odaberite vlastitu';
z.string.hr.takeoverButtonKeep = 'Zadri ovu';

z.string.hr.inviteMetaKeyMac = 'Cmd';
z.string.hr.inviteMetaKeyPc = 'Ctrl';
z.string.hr.inviteHeadline = 'Pozvati ljude na Wire';

z.string.hr.extensionsBubbleButtonGif = 'Gif';

z.string.hr.extensionsGiphyButtonOk = 'Poalji';
z.string.hr.extensionsGiphyButtonMore = 'Probaj neto drugo';
z.string.hr.extensionsGiphyMessage = ' {{tag}} s giphy.com';
z.string.hr.extensionsGiphyNoGifs = 'Ups, nema Gif-ova';
z.string.hr.extensionsGiphyRandom = 'Nasumino';

z.string.hr.addParticipantsConfirmLabel = 'Dodaj';
z.string.hr.addParticipantsSearchPlaceholder = 'Trai po imenu';
z.string.hr.addParticipantsTabsPeople = 'Kontakti';
z.string.hr.addParticipantsTabsServices = 'Usluge';

z.string.hr.conversationDetailsActionArchive = 'Arhiviraj';
z.string.hr.conversationDetailsActionCancelRequest = 'Poniti zahtjev';
z.string.hr.conversationDetailsActionDevices = 'Ureaji';
z.string.hr.conversationDetailsActionNotifications = 'Obavijesti';
z.string.hr.conversationDetailsGuestsOff = 'Iskljui';
z.string.hr.conversationDetailsOptions = 'Opcije';
z.string.hr.conversationDetailsParticipantsServicesMany = 'Usluge';
z.string.hr.conversationDetailsParticipantsUsersMany = 'Kontakti';
z.string.hr.conversationDetailsPeople = 'Kontakti';
z.string.hr.conversationDetailsServices = 'Usluge';

z.string.hr.conversationParticipantsTitle = 'Kontakti';
z.string.hr.conversationParticipantsSearchPlaceholder = 'Trai po imenu';

z.string.hr.groupParticipantActionCancelRequest = 'Poniti zahtjev';
z.string.hr.groupParticipantActionDevices = 'Ureaji';
z.string.hr.groupParticipantActionPending = 'Na ekanju';
z.string.hr.groupParticipantActionSendRequest = 'Povei se';

z.string.hr.notificationSettingsTitle = 'Obavijesti';

z.string.hr.participantDevicesDetailHeadline = 'Provjerite da je otisak prikazan na {{html1}}{{user}}s device{{html2}}.';
z.string.hr.participantDevicesDetailHowTo = 'Kako to da uinim?';
z.string.hr.participantDevicesDetailResetSession = 'Resetiraj sesiju';
z.string.hr.participantDevicesDetailShowMyDevice = 'Pokai otisak mog ureaja';
z.string.hr.participantDevicesDetailVerify = 'Verificirano';

z.string.hr.participantDevicesHeader = 'Ureaji';
z.string.hr.participantDevicesHeadline = 'Wire daje svakom ureaju jedinstveni otisak. Usporedite otiske s {{user}} da bi verificirali razgovor.';
z.string.hr.participantDevicesLearnMore = 'Saznaj vie';
z.string.hr.participantDevicesWhyVerify = 'Zato ovjeravati razgovore?';
z.string.hr.participantDevicesOutdatedClientMessage = '{{user}} koristi staru verziju Wire. Nema novih ureaja.';

z.string.hr.participantDevicesSelfAllDevices = 'Pokai sve ureaje';
z.string.hr.participantDevicesSelfFingerprint = 'Otisak ureaja';

z.string.hr.userProfileButtonConnect = 'Povei se';
z.string.hr.userProfileButtonIgnore = 'Ignoriraj';
z.string.hr.userProfileButtonUnblock = 'Odblokiraj';

z.string.hr.preferencesAbout = 'O programu';
z.string.hr.preferencesAccount = 'Raun';
z.string.hr.preferencesAV = 'Audio / Video';
z.string.hr.preferencesDeviceDetails = 'Detalji o ureaju';
z.string.hr.preferencesDevices = 'Ureaji';
z.string.hr.preferencesHeadline = 'Osobne postavke';
z.string.hr.preferencesOptions = 'Opcije';

z.string.hr.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.hr.preferencesAboutPrivacyPolicy = 'Pravilnik o zatiti privatnosti';
z.string.hr.preferencesAboutSupport = 'Podrka';
z.string.hr.preferencesAboutSupportWebsite = 'Wire Podrka';
z.string.hr.preferencesAboutSupportContact = 'Kontaktirajte podrku';
z.string.hr.preferencesAboutTermsOfUse = 'Uvjeti uporabe';
z.string.hr.preferencesAboutVersion = 'Verzija {{version}}';
z.string.hr.preferencesAboutWebsite = 'Wire website';

z.string.hr.preferencesAccountDelete = 'Brisanje rauna';
z.string.hr.preferencesAccountLogOut = 'Odjava';
z.string.hr.preferencesAccountResetPassword = 'Resetiraj lozinku';
z.string.hr.preferencesAccountUsernamePlaceholder = 'Vae puno ime';
z.string.hr.preferencesAccountUsernameHint = 'Najmanje 2 znaka. Samo a-z, 0-9, i _.';
z.string.hr.preferencesAccountUsernameAvailable = 'Dostupno';
z.string.hr.preferencesAccountUsernameErrorTaken = 'Ve uzeto';

z.string.hr.preferencesAVCamera = 'Kamera';
z.string.hr.preferencesAVMicrophone = 'Mikrofon';
z.string.hr.preferencesAVPermissionDetail = 'Omoguite iz opcija preglednika';
z.string.hr.preferencesAVSpeakers = 'Zvunici';

z.string.hr.preferencesDevicesActivatedOn = 'Aktiviran u {{date}}';
z.string.hr.preferencesDevicesActive = 'Aktivno';
z.string.hr.preferencesDevicesActiveDetail = 'Ako ne prepoznajete neki od navedenih ureaja, uklonite ga i resetirajte Vau lozinku.';
z.string.hr.preferencesDevicesCurrent = 'Trenutno';
z.string.hr.preferencesDevicesFingerprint = 'Otisak prsta';
z.string.hr.preferencesDevicesFingerprintDetail = 'Wire daje svakom ureaju jedinstveni otisak. Usporedite otiske da bi verificirali ureaje i razgovore.';
z.string.hr.preferencesDevicesId = 'ID: ';
z.string.hr.preferencesDevicesRemoveCancel = 'Odustani';
z.string.hr.preferencesDevicesRemoveDetail = 'Uklonite ovaj ureaj ako ste ga prestali koristiti. Odmah ete biti automatski odjavljeni.';
z.string.hr.preferencesDevicesSessionConfirmation = 'Sesija je resetirana.';
z.string.hr.preferencesDevicesSessionDetail = 'Ako otisci prstiju ne odgovaraju, resetirajte sesiju da bi generirali nove kljueve za ifriranje na obje strane.';
z.string.hr.preferencesDevicesSessionReset = 'Resetiraj sesiju';
z.string.hr.preferencesDevicesSessionOngoing = 'Resetiranje sesije';
z.string.hr.preferencesDevicesVerification = 'Verificirano';

z.string.hr.preferencesOptionsAudio = 'Zvukovi upozorenja';
z.string.hr.preferencesOptionsAudioAll = 'Svi';
z.string.hr.preferencesOptionsAudioAllDetail = 'Svi zvukovi';
z.string.hr.preferencesOptionsAudioNone = 'Nita';
z.string.hr.preferencesOptionsAudioNoneDetail = '!';
z.string.hr.preferencesOptionsAudioSome = 'Neki';
z.string.hr.preferencesOptionsAudioSomeDetail = 'Pingovi i pozivi';
z.string.hr.preferencesOptionsContacts = 'Kontakti';
z.string.hr.preferencesOptionsContactsGmail = 'Uvezi iz Gmaila';
z.string.hr.preferencesOptionsContactsMacos = 'Uvezi iz kontakata';
z.string.hr.preferencesOptionsContactsDetail = 'Mi koristimo vae kontakt podatke za povezivanje s drugima. Sve informacije su anonimiziane i nisu dijeljene s drugima.';
z.string.hr.preferencesOptionsNotifications = 'Obavijesti';
z.string.hr.preferencesOptionsNotificationsNone = 'Iskljui';
z.string.hr.preferencesOptionsNotificationsObfuscate = 'Sakrij detalje';
z.string.hr.preferencesOptionsNotificationsOn = 'Prikai poiljatelja i poruku';

z.string.hr.backupCancel = 'Odustani';

z.string.hr.searchConnect = 'Povei se';
z.string.hr.searchConnections = 'Veze';
z.string.hr.searchContacts = 'Kontakti';
z.string.hr.searchCreateGroup = 'Napravi grupu';
z.string.hr.searchGroups = 'Grupe';
z.string.hr.searchPeople = 'Kontakti';
z.string.hr.searchPlaceholder = 'Pretrai po imenu ili korisnikom imenu';
z.string.hr.searchServicePlaceholder = 'Trai po imenu';
z.string.hr.searchServices = 'Usluge';
z.string.hr.searchTopPeople = 'Top veze';
z.string.hr.searchTrySearch = 'Traenje ljudi po imenu ili korisnikom imenu';
z.string.hr.searchNoContactsOnWire = 'Nemate veza na Wire. Pokuajte pronai ljude po imenu ili korisnikom imenu.';
z.string.hr.searchOthers = 'Povei se';

z.string.hr.searchInviteButtonContacts = 'Iz kontakata';
z.string.hr.searchInviteButtonGmail = 'Iz Gmaila';
z.string.hr.searchInviteHeadline = 'Pozovi prijatelje';
z.string.hr.searchInviteShare = 'Podijeli kontakte';

z.string.hr.searchListEveryoneParticipates = 'Svi ljudi s kojima ste povezani su ve u ovom razgovoru.';
z.string.hr.searchListNoMatches = 'Nema odgovarajuih rezultata. Pokuajte unijeti drugaije ime.';


z.string.hr.uploadGoogleHeadline = 'Pronai ljude za razgovor.';
z.string.hr.uploadGoogleMessage = 'Mi koristimo vae kontakt podatke za povezivanje s drugima. Sve informacije su anonimiziane i nisu dijeljene s drugima.';

z.string.hr.warningCallUnsupportedIncoming = '{{user}} zove. Va preglednik ne podrava pozive.';
z.string.hr.warningCallUnsupportedOutgoing = 'Poziv nije mogu jer va preglednik ne podrava pozive.';
z.string.hr.warningCallIssues = 'Ova verzija Wire nema pozive. Molimo vas da koristite';
z.string.hr.warningCallUpgradeBrowser = 'Da bi imali pozive, molimo aurirajte Google Chrome.';
z.string.hr.warningConnectivityConnectionLost = 'Povezivanje u tijeku. Postoji mogunost da Wire nee moi isporuiti poruke.';
z.string.hr.warningConnectivityNoInternet = 'Nema Interneta. Neete moi slati ili primati poruke.';
z.string.hr.warningLearnMore = 'Saznaj vie';
z.string.hr.warningLifecycleUpdate = 'Nova verzija Wire je dostupna.';
z.string.hr.warningLifecycleUpdateNotes = 'to je novo';
z.string.hr.warningLifecycleUpdateLink = 'Auriraj sada';
z.string.hr.warningNotFoundCamera = 'Poziv nije mogu jer raunalo nema kameru.';
z.string.hr.warningNotFoundMicrophone = 'Poziv nije mogu jer raunalo nema mikrofon.';
z.string.hr.warningPermissionDeniedCamera = 'Poziv nije mogu jer raunalo nema pristup kameri.';
z.string.hr.warningPermissionDeniedMicrophone = 'Poziv nije mogu jer raunalo nema pristup mikrofonu.';
z.string.hr.warningPermissionDeniedScreen = 'Va preglednik treba dozvolu za zajedniko koritenje vaeg zaslona.';
z.string.hr.warningPermissionRequestCamera = '{{icon}} dopusti pristup kameri';
z.string.hr.warningPermissionRequestMicrophone = '{{icon}} dopusti pristup mikrofonu';
z.string.hr.warningPermissionRequestNotification = '{{icon}} Dopusti notifikacije';
z.string.hr.warningPermissionRequestScreen = '{{icon}} dopusti pristup zaslonu';

z.string.hr.userAvailabilityAvailable = 'Dostupno';
z.string.hr.userAvailabilityNone = 'Nita';

z.string.hr.notificationAssetAdd = 'Podijelila/o sliku';
z.string.hr.notificationConnectionAccepted = 'Prihvatila/o zahtjev za vezu';
z.string.hr.notificationConnectionRequest = 'eli se povezati';
z.string.hr.notificationConversationCreate = '{{user}} je zapoela/o razgovor';
z.string.hr.notificationConversationRename = '{{user}} je preimenovala/o razgovor u {{name}}';
z.string.hr.notificationMemberJoinMany = '{{user}} dodala/o {{number}} ljudi u razgovor';
z.string.hr.notificationMemberJoinOne = '{{user1}} dodala/o {{user2}} u razgovor';
z.string.hr.notificationMemberLeaveRemovedYou = '{{user}} vas je izbrisao / izbrisala iz razgovora';
z.string.hr.notificationObfuscated = 'Poslao ti je poruku';
z.string.hr.notificationObfuscatedTitle = 'Netko';
z.string.hr.notificationPing = 'Pingala/o';
z.string.hr.notificationReaction = '{{reaction}} tvoju poruku';
z.string.hr.notificationSharedAudio = 'Podijelila/o audio poruku';
z.string.hr.notificationSharedFile = 'Podijelila/o datoteku';
z.string.hr.notificationSharedLocation = 'Podijelila/o lokaciju';
z.string.hr.notificationSharedVideo = 'Podijelila/o video';
z.string.hr.notificationVoiceChannelActivate = 'Pozivanje';
z.string.hr.notificationVoiceChannelDeactivate = 'Zvala/o';

z.string.hr.tooltipConversationAllVerified = 'Svi otisci su verificirani';
z.string.hr.tooltipConversationCall = 'Poziv';
z.string.hr.tooltipConversationEphemeral = 'Odgoeno slanje';
z.string.hr.tooltipConversationFile = 'Dodaj datoteku';
z.string.hr.tooltipConversationInputPlaceholder = 'Upii poruku';
z.string.hr.tooltipConversationPeople = 'Ljudi ({{shortcut}})';
z.string.hr.tooltipConversationPicture = 'Dodaj sliku';
z.string.hr.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.hr.tooltipConversationSearch = 'Trai';
z.string.hr.tooltipConversationVideoCall = 'Video poziv';

z.string.hr.tooltipConversationsArchive = 'Arhiva ({{shortcut}})';
z.string.hr.tooltipConversationsArchived = 'Pokai arhivu ({{number}})';
z.string.hr.tooltipConversationsMore = 'Vie';
z.string.hr.tooltipConversationsNotify = 'Ukljui zvukove ({{shortcut}})';
z.string.hr.tooltipConversationsSilence = 'Iskljui zvukove ({{shortcut}})';
z.string.hr.tooltipConversationsStart = 'Poetak razgovora ({{shortcut}})';

z.string.hr.tooltipConversationDetailsRename = 'Promijeni naziv razgovora';

z.string.hr.tooltipPreferencesContactsGmail = 'Prijavite se na svoj Gmail raun za dijeljenje kontakata';
z.string.hr.tooltipPreferencesContactsMacos = 'Podijelite sve svoje kontakte s macOS Contacts aplikacijom';
z.string.hr.tooltipPreferencesPassword = 'Otvori web stranicu za ponovno postavljanje lozinke';
z.string.hr.tooltipPreferencesPicture = 'Promjena slike';
z.string.hr.tooltipPreferencesRename = 'Promijeni ime';

z.string.hr.tooltipSearchClose = 'Zatvori (Esc)';

z.string.hr.initReceivedSelfUser = 'Pozdrav, {{user}}.';
z.string.hr.initValidatedClient = 'Uitavanje veze i razgovora';
z.string.hr.initReceivedUserData = 'Provjeravanje novih poruka';
z.string.hr.initEvents = 'Uitavanje poruka';

z.string.hr.ephemeralUnitsNone = 'Iskljui';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use=szigor';

z.string.hu.wire = 'Wire';
z.string.hu.wireMacos = 'Wire MacOS-hez';
z.string.hu.wireWindows = 'Wire Windowshoz';
z.string.hu.wireLinux = 'Wire Linuxhoz';
z.string.hu.nonexistentUser = 'Trlt felhasznl';
z.string.hu.and = 's';
z.string.hu.enumerationAnd = 's ';

//=Alkalmazs betltse
z.string.hu.authAccountCountryCode = 'Orszghv-kd';
z.string.hu.authAccountPasswordForgot = 'Elfelejtett jelsz';
z.string.hu.authAccountPublicComputer = 'Ez egy nyilvnos szmtgp';
z.string.hu.authAccountSignIn = 'Bejelentkezs';
z.string.hu.authAccountSignInPhone = 'Telefonos bejelentkezs';

z.string.hu.authBlockedCookies = 'A bejelentkezshez engedlyezni kell a bngsz-stiket.';
z.string.hu.authBlockedDatabase = 'Az zenetek megjelentshez a Wire-nek el kell rnie a helyi trhelyet. A bngsz privt md hasznlatakor a helyi trhely nem ll rendelkezsre.';
z.string.hu.authBlockedTabs = 'A Wire mr nyitva van egy msik bngszlapon.';
z.string.hu.authBlockedTabsAction = 'Inkbb hasznljuk ezt a flet';

z.string.hu.authVerifyAccountAdd = 'Hozzads';
z.string.hu.authVerifyAccountDetail = 'Ezltal akr tbb eszkzn is hasznlhatod a Wire-t.';
z.string.hu.authVerifyAccountHeadline = 'E-mail cm s jelsz megadsa.';
z.string.hu.authVerifyAccountLogout = 'Kijelentkezs';
z.string.hu.authVerifyCodeDescription = 'rd be az ellenrz kdot,\namit a {{number}} telefonszmra kldtnk.';
z.string.hu.authVerifyCodeResend = 'Nem kaptl kdot?';
z.string.hu.authVerifyCodeResendDetail = 'jraklds';
z.string.hu.authVerifyCodeResendTimer = 'j kdot krhetsz {{expiration}} mlva.';
z.string.hu.authVerifyCodeChangePhone = 'Telefonszm mdostsa';
z.string.hu.authVerifyPasswordHeadline = 'Add meg a jelszavad';

z.string.hu.authLimitDevicesHeadline = 'Eszkzk';
z.string.hu.authLimitDescription = 'Ahhoz, hogy hasznlni tudd a Wire-t ezen az eszkzn, elszr tvoltsd el azt valamelyik msikrl.';
z.string.hu.authLimitButtonManage = 'Eszkzk kezelse';
z.string.hu.authLimitButtonSignOut = 'Kijelentkezs';
z.string.hu.authLimitDevicesCurrent = '(Ez az eszkz)';

z.string.hu.authHistoryHeadline = 'Els alkalommal hasznlod a Wire-t ezen az eszkzn.';
z.string.hu.authHistoryDescription = 'Adatvdelmi okokbl a beszlgets elzmnyei nem jelennek meg.';
z.string.hu.authHistoryReuseHeadline = 'Mr hasznltad a Wire-t ezen az eszkzn.';
z.string.hu.authHistoryReuseDescription = 'Az elz hasznlat ta elkldtt zenetek ezen az eszkzn nem fognak megjelenni.';
z.string.hu.authHistoryButton = 'OK';

z.string.hu.authPostedResend = 'jraklds ide: {{email}}';
z.string.hu.authPostedResendAction = 'Nem kaptl e-mailt?';
z.string.hu.authPostedResendDetail = 'Ellenrizd bejv e-mailjeidet s kvesd az utastsokat.';
z.string.hu.authPostedResendHeadline = 'Leveled rkezett.';

z.string.hu.authPlaceholderEmail = 'E-mail';
z.string.hu.authPlaceholderPasswordPut = 'Jelsz';
z.string.hu.authPlaceholderPasswordSet = 'Jelsz (legalbb 8 karakter)';
z.string.hu.authPlaceholderPhone = 'Telefonszm';

z.string.hu.authErrorCode = 'rvnytelen kd';
z.string.hu.authErrorCountryCodeInvalid = 'rvnytelen az Orszghv-kd';
z.string.hu.authErrorEmailExists = 'Ez az e-mail cm mr foglalt';
z.string.hu.authErrorEmailForbidden = 'Sajnljuk. Ez az e-mail cm nem megengedett.';
z.string.hu.authErrorEmailMalformed = 'Krjk, vals e-mail cmet adj meg.';
z.string.hu.authErrorEmailMissing = 'Krjk, add meg az e-mail cmed.';
z.string.hu.authErrorMisc = 'Csatlakozsi problma. Krjk, prbld meg jra.';
z.string.hu.authErrorNameShort = 'Legalbb 2 karakterbl ll nevet adj meg';
z.string.hu.authErrorOffline = 'Nincs internetkapcsolat';
z.string.hu.authErrorPasswordShort = 'Vlassz egy legalbb 8 karakter hossz jelszt.';
z.string.hu.authErrorPasswordWrong = 'Hibs jelsz. Krjk, prbld meg jra.';
z.string.hu.authErrorPending = 'A fik mg nincs ellenrizve';
z.string.hu.authErrorPhoneNumberBudget = 'Tl gyakran jelentkeztl be. Prbld meg ksbb.';
z.string.hu.authErrorPhoneNumberForbidden = 'Sajnljuk. Ez a telefonszm nem megengedett.';
z.string.hu.authErrorPhoneNumberInvalid = 'rvnytelen telefonszm';
z.string.hu.authErrorPhoneNumberUnknown = 'Ismeretlen telefonszm';
z.string.hu.authErrorSuspended = 'Ezzel az azonostval mr nem lehet bejelentkezni.';
z.string.hu.authErrorSignIn = 'Krjk, ellenrizd az adataid, majd prbld meg jra.';

z.string.hu.callStateOutgoing = 'Kicsengs';
z.string.hu.callStateConnecting = 'Csatlakozs';
z.string.hu.callStateIncoming = 'Hvs';
z.string.hu.callStateIncomingGroup = '{{user}} hv';
z.string.hu.callDecline = 'Elutasts';
z.string.hu.callAccept = 'Elfogads';
z.string.hu.callJoin = 'Csatlakozs';
z.string.hu.callChooseSharedScreen = 'Vlaszd ki a megosztand kpernyt';
z.string.hu.callParticipants = '{{number}} partner a vonalban';

z.string.hu.videoCallOverlayConversations = 'Beszlgetsek';
z.string.hu.videoCallOverlayMute = 'Nmts';
z.string.hu.videoCallOverlayVideo = 'Vide';
z.string.hu.videoCallOverlayShareScreen = 'Kperny megosztsa';
z.string.hu.videoCallOverlayHangUp = 'Hvs befejezse';
z.string.hu.videoCallPaused = 'Vide szneteltetve';

z.string.hu.modalAcknowledgeAction = 'Ok';
z.string.hu.modalAcknowledgeHeadline = 'Valami nem stimmel';
z.string.hu.modalConfirmSecondary = 'Mgsem';
z.string.hu.modalOptionSecondary = 'Mgsem';

z.string.hu.modalAccountCreateAction = 'OK';
z.string.hu.modalAccountCreateHeadline = 'Fik ltrehozsa?';
z.string.hu.modalAccountCreateMessage = 'Ha ltrehozol egy fikot, akkor elveszted a beszlgets elzmnyit ebben a vendgszobban.';

z.string.hu.modalAccountDeletionAction = 'Trls';
z.string.hu.modalAccountDeletionHeadline = 'Fik trlse';
z.string.hu.modalAccountDeletionMessage = 'Kldnk egy e-mailt vagy SMS-t. Fikod vgleges trlshez nyisd meg a kapott linket.';

z.string.hu.modalAccountLeaveGuestRoomAction = 'Kilps';
z.string.hu.modalAccountLeaveGuestRoomHeadline = 'Elhagyod a vendgszobt?';
z.string.hu.modalAccountLeaveGuestRoomMessage = 'A beszlgets elzmnyei trldnek. Ha meg szeretnd tartani, inkbb legkzelebb hozz ltre egy fikot.';

z.string.hu.modalAccountLogoutAction = 'Kijelentkezs';
z.string.hu.modalAccountLogoutHeadline = 'Adatok trlse?';
z.string.hu.modalAccountLogoutOption = 'Ez trli az sszes szemlyes adatodat s beszlgetseidet errl az eszkzrl.';

z.string.hu.modalAccountNewDevicesSecondary = 'Eszkzk kezelse';
z.string.hu.modalAccountNewDevicesHeadline = 'Fikod legutbbi hasznlata:';
z.string.hu.modalAccountNewDevicesFrom = 'Eszkz:';
z.string.hu.modalAccountNewDevicesMessage = 'Ha ezt nem te voltl, akkor trld az eszkzt, s lltsd alaphelyzetbe jelszavad.';

z.string.hu.modalAccountRemoveDeviceAction = 'Eszkz eltvoltsa';
z.string.hu.modalAccountRemoveDeviceHeadline = '"{{device}}" eltvoltsa';
z.string.hu.modalAccountRemoveDeviceMessage = 'Az eszkz eltvoltshoz add meg a jelszavad.';
z.string.hu.modalAccountRemoveDevicePlaceholder = 'Jelsz';

z.string.hu.modalAssetTooLargeHeadline = 'A fjl tl nagy';
z.string.hu.modalAssetTooLargeMessage = 'Maximum {{number}} mret fjlokat kldhetsz';

z.string.hu.modalAssetParallelUploadsHeadline = 'Egyszerre ez tl sok fjl';
z.string.hu.modalAssetParallelUploadsMessage = 'Egyszerre {{number}} fjt kldhetsz.';

z.string.hu.modalCallEmptyConversationHeadline = 'Senki sem hvhat';
z.string.hu.modalCallEmptyConversationMessage = 'Senki sem maradt itt.';

z.string.hu.modalCallEmptyLogHeadline = 'Nincsenek hvsok';
z.string.hu.modalCallEmptyLogMessage = 'Nincsenek hvsok, amikrl hibanapl kszthet lenne.';

z.string.hu.modalCallNoGroupVideoHeadline = 'A csoportokban a videhvs nem elrhet';
z.string.hu.modalCallNoGroupVideoMessage = 'Videohvsok nem rhetk el a csoportos beszlgetsben.';

z.string.hu.modalCallNoMicrophoneAction = 'Mit kell tennem';
z.string.hu.modalCallNoMicrophoneMessage = 'A hvsokhoz a bngszdnek hozz kell frnie a mikrofonodhoz.';
z.string.hu.modalCallNoMicrophoneHeadline = 'Nem kezdemnyezhetsz hvst mikrofon nlkl';

z.string.hu.modalCallSecondIncomingAction = 'Fogads';
z.string.hu.modalCallSecondIncomingHeadline = 'Fogadod a hvst?';
z.string.hu.modalCallSecondIncomingMessage = 'A folyamatban lv hvs vget rt.';

z.string.hu.modalCallSecondOngoingAction = 'Hvs befejezse';
z.string.hu.modalCallSecondOngoingHeadline = 'Bontsuk a hvst a msik eszkzn?';
z.string.hu.modalCallSecondOngoingMessage = 'Egyszerre csak egy hvsban vehetsz rszt.';

z.string.hu.modalCallSecondOutgoingAction = 'Hvs befejezse';
z.string.hu.modalCallSecondOutgoingHeadline = 'Leteszed a folyamatban lv hvst?';
z.string.hu.modalCallSecondOutgoingMessage = 'Egyszerre csak egy hvsban vehetsz rszt.';

z.string.hu.modalConnectCancelAction = 'Igen';
z.string.hu.modalConnectCancelHeadline = 'Krelem visszavonsa?';
z.string.hu.modalConnectCancelMessage = 'Visszavonod a csatlakozsi krelmet {{user}} partnerhez.';
z.string.hu.modalConnectCancelSecondary = 'Nem';

z.string.hu.modalConnectAcceptAction = 'Csatlakozs';
z.string.hu.modalConnectAcceptHeadline = 'Elfogadod?';
z.string.hu.modalConnectAcceptMessage = 'Ezzel csatlakozol s beszlgetst indtasz {{user}} partnerrel.';
z.string.hu.modalConnectAcceptSecondary = 'Figyelmen kvl hagys';

z.string.hu.modalConversationClearAction = 'Trls';
z.string.hu.modalConversationClearHeadline = 'Trld a tartalmat?';
z.string.hu.modalConversationClearMessage = 'Ezzel trld a beszlgets elzmnyt az sszes eszkzdrl.';
z.string.hu.modalConversationClearOption = 'Kilps a beszlgetsbl is';

z.string.hu.modalConversationDeleteMessageAction = 'Trls';
z.string.hu.modalConversationDeleteMessageHeadline = 'Trls csak nlam?';
z.string.hu.modalConversationDeleteMessageMessage = 'Ezt a mveletet nem lehet visszavonni.';

z.string.hu.modalConversationDeleteMessageEveryoneAction = 'Trls';
z.string.hu.modalConversationDeleteMessageEveryoneHeadline = 'Trls minden rsztvevnl?';
z.string.hu.modalConversationDeleteMessageEveryoneMessage = 'Ezt a mveletet nem lehet visszavonni.';

z.string.hu.modalConversationLeaveAction = 'Kilps';
z.string.hu.modalConversationLeaveHeadline = 'Kilpsz ebbl a beszlgetsbl: "{{name}}"?';
z.string.hu.modalConversationLeaveMessage = 'Ezutn nem fogsz tudni zeneteket kldeni s fogadni ebben a beszlgetsben.';

z.string.hu.modalConversationMessageTooLongHeadline = 'Az zenet tl hossz';
z.string.hu.modalConversationMessageTooLongMessage = 'Maximum {{number}} karakter hossz zenetet kldhetsz.';

z.string.hu.modalConversationNewDeviceAction = 'Klds mindenkppen';
z.string.hu.modalConversationNewDeviceHeadlineOne = '{{user}} elkezdett hasznlni egy j eszkzt';
z.string.hu.modalConversationNewDeviceHeadlineMany = '{{users}} elkezdtek j eszkzket hasznlni';
z.string.hu.modalConversationNewDeviceHeadlineYou = '{{user}} elkezdett hasznlni egy j eszkzt';
z.string.hu.modalConversationNewDeviceIncomingCallAction = 'Hvs fogadsa';
z.string.hu.modalConversationNewDeviceIncomingCallMessage = 'Biztos, hogy mg mindig fogadni szeretnd a hvst?';
z.string.hu.modalConversationNewDeviceMessage = 'Biztos, hogy mg mindig el szeretnd kldeni az zeneteidet?';
z.string.hu.modalConversationNewDeviceOutgoingCallAction = 'Hvs mindenkppen';
z.string.hu.modalConversationNewDeviceOutgoingCallMessage = 'Biztos, hogy mg mindig kezdemnyezni szeretnd a hvst?';

z.string.hu.modalConversationNotConnectedHeadline = 'Senki nem lett hozzadva a beszlgetshez';
z.string.hu.modalConversationNotConnectedMessageOne = '{{name}} nem szeretne csatlakozni a beszlgetshez.';
z.string.hu.modalConversationNotConnectedMessageMany = 'Az egyik kivlasztott partner nem szeretne csatlakozni a beszlgetshez.';

z.string.hu.modalConversationRemoveAction = 'Eltvolts';
z.string.hu.modalConversationRemoveHeadline = 'Trld?';
z.string.hu.modalConversationRemoveMessage = '{{user}} nem fog tudni zenetet kldeni s fogadni ebben a beszlgetsben.';

z.string.hu.modalConversationRemoveGuestsAction = 'Vendgek eltvoltsa';
z.string.hu.modalConversationRemoveGuestsHeadline = 'Kikapcsolod a vendg hozzfrst?';
z.string.hu.modalConversationRemoveGuestsMessage = 'A jelenlegi vendg el lesz tvoltva a beszlgetsbl. j vendgek sem csatlakozhatnak.';

z.string.hu.modalConversationRevokeLinkAction = 'Link visszavonsa';
z.string.hu.modalConversationRevokeLinkHeadline = 'Visszavonod a hivatkozst?';
z.string.hu.modalConversationRevokeLinkMessage = 'j vendgek nem tudnak ezzel a hivatkozssal csatlakozni. A mr meglv vendgeknek tovbbra is megmarad a hozzfrse.';

z.string.hu.modalConversationGuestOptionsAllowGuestMessage = 'Nem sikerlt engedlyezni a vendgeket. Krjk, prbld jra.';
z.string.hu.modalConversationGuestOptionsDisableGuestMessage = 'Nem sikerlt eltvoltani a vendgeket. Krjk, prbld jra.';
z.string.hu.modalConversationGuestOptionsGetCodeMessage = 'Nem sikerlt hozzfrsi hivatkozst beszerezni.';
z.string.hu.modalConversationGuestOptionsRequestCodeMessage = 'Nem sikerlt hozzfrsi hivatkozst ignyelni. Krjk, prbld jra.';
z.string.hu.modalConversationGuestOptionsRevokeCodeMessage = 'Nem sikerlt visszavonni a hozzfrsi hivatkozst. Krjk, prbld jra.';
z.string.hu.modalConversationGuestOptionsToggleGuestsMessage = 'Nem sikerlt megvltoztatni a vendg llapott.';

z.string.hu.modalConversationTooManyMembersHeadline = 'Telt hz';
z.string.hu.modalConversationTooManyMembersMessage = 'Legfeljebb {{number1}} partner tud csatlakozni a beszlgetshez. Mg {{number2}} partner szmra van hely.';

z.string.hu.modalGifTooLargeHeadline = 'A kivlsztott animci tl nagy';
z.string.hu.modalGifTooLargeMessage = 'A maximlis mret {{number}} MB lehet.';

z.string.hu.modalIntegrationUnavailableHeadline = 'A botok jelenleg nem elrhetek';
z.string.hu.modalIntegrationUnavailableMessage = 'Ksznjk, hogy rdekldsz a botokkal kapcsolatban. A szolgltatst jelenleg felfggesztettk, amg a kvetkez verzin dolgozunk. Hamarosan jelentkeznk.';

z.string.hu.modalPictureFileFormatHeadline = 'Nem lehet ezt a kpet hasznlni';
z.string.hu.modalPictureFileFormatMessage = 'Krjk, PNG vagy JPEG kpet hasznlj.';

z.string.hu.modalPictureTooLargeHeadline = 'A kivlasztott kp tl nagy';
z.string.hu.modalPictureTooLargeMessage = 'Maximum {{number}} MB mret kpeket hasznlhatsz.';

z.string.hu.modalPictureTooSmallHeadline = 'A kp tl kicsi';
z.string.hu.modalPictureTooSmallMessage = 'Krjk, legalbb 320 x 320 kppont mret kpet vlassz.';

z.string.hu.modalImproveWireAction = 'Elfogads';
z.string.hu.modalImproveWireSecondary = 'Most nem';
z.string.hu.modalImproveWireHeadline = 'Segts neknk jobb tenni a Wire-t';
z.string.hu.modalImproveWireMessage = 'Segts jobb tenni termkeinket s szolgltatsainkat azzal, hogy nvtelen hasznlati s hibajelentseket kldesz. Ezeket az informcikat semmi msra nem hasznljuk.';

z.string.hu.modalServiceUnavailableHeadline = 'j szolgltats hozzadsa nem lehetsges';
z.string.hu.modalServiceUnavailableMessage = 'A szolgltats jelenleg nem elrhet.';

z.string.hu.modalSessionResetHeadline = 'A munkamenet alaphelyzetbe lltva';
z.string.hu.modalSessionResetMessage1 = 'Ha a problma tovbbra is fennll,';
z.string.hu.modalSessionResetMessageLink = 'lpj kapcsolatba';
z.string.hu.modalSessionResetMessage2 = 'velnk.';

z.string.hu.modalUploadContactsAction = 'jra prbls';
z.string.hu.modalUploadContactsMessage = 'Nem kaptuk meg az adataidat. Krjk, prbld meg jra a nvjegyek importlst.';

z.string.hu.modalUserBlockAction = 'Tilts';
z.string.hu.modalUserBlockHeadline = '{{user}} tiltsa?';
z.string.hu.modalUserBlockMessage = '{{user}} nem tud majd kapcsolatba lpni veled, sem meghvni tged csoportos beszlgetsekbe.';

z.string.hu.modalUserUnblockAction = 'Tilts feloldsa';
z.string.hu.modalUserUnblockHeadline = 'Feloldod a letiltst?';
z.string.hu.modalUserUnblockMessage = '{{user}} jra kapcsolatba tud lpni veled s meg tud hvni tged csoportos beszlgetsekbe.';

z.string.hu.connectionRequestConnect = 'Csatlakozs';
z.string.hu.connectionRequestIgnore = 'Figyelmen kvl hagys';

z.string.hu.conversationGuestIndicator = 'Vendg';
z.string.hu.userRemainingTimeHours = '{{time}} ra van htra';
z.string.hu.userRemainingTimeMinutes = 'Kevesebb mint {{time}} perc van htra';

z.string.hu.conversationYouNominative = 'te';
z.string.hu.conversationYouDative = 'te';
z.string.hu.conversationYouAccusative = 'te';

z.string.hu.conversationConnectionAccepted = 'Csatlakozva';
z.string.hu.conversationConnectionBlocked = 'Letiltva';
z.string.hu.conversationConnectionCancelRequest = 'Csatlakozsi krs visszavonsa';
z.string.hu.conversationCreateTemporary = 'Csatlakoztl a beszlgetshez';
z.string.hu.conversationCreateWith = ' velk: {{users}}';
z.string.hu.conversationDeviceStartedUsingOne = ' elkezdett hasznlni';
z.string.hu.conversationDeviceStartedUsingMany = ' elkezdett hasznlni';
z.string.hu.conversationDeviceUnverified = ' visszavontad az ellenrztt sttuszt';
z.string.hu.conversationDeviceYourDevices = ' az egyik eszkzdrl';
z.string.hu.conversationDeviceUserDevices = ' {{user}} egyik eszkze';
z.string.hu.conversationDeviceNewDeviceOne = ' egy j eszkzt';
z.string.hu.conversationDeviceNewDeviceMany = ' j eszkzket';
z.string.hu.conversationDeviceNewPeopleJoined = 'j partnerek csatlakoztak.';
z.string.hu.conversationDeviceNewPeopleJoinedVerify = ' eszkzk ellenrzse';
z.string.hu.conversationJustNow = 'pp most';
z.string.hu.conversationLocationLink = 'Trkp megnyitsa';
z.string.hu.conversationMessageDelivered = 'Kzbestve';
z.string.hu.conversationRename = ' tnevezte a beszlgetst';
z.string.hu.conversationRenameYou = ' tnevezte a beszlgetst';
z.string.hu.conversationResume = 'Beszlgets indtsa a kvetkezkkel: {{users}}';
z.string.hu.conversationPing = ' kopogott';
z.string.hu.conversationPingYou = ' kopogott';
z.string.hu.conversationToday = 'ma';
z.string.hu.conversationVoiceChannelDeactivate = ' hvst kezdemnyezett';
z.string.hu.conversationVoiceChannelDeactivateYou = ' hvst kezdemnyezett';
z.string.hu.conversationYesterday = 'Tegnap';
z.string.hu.conversationUnableToDecrypt1 = 'Nem kaptl meg egy zenetet tle: {{user}}.';
z.string.hu.conversationUnableToDecrypt2 = '{{user}} eszkznek azonostja megvltozott. Kzbestetlen zenet.';
z.string.hu.conversationUnableToDecryptLink = 'Mirt?';
z.string.hu.conversationUnableToDecryptErrorMessage = 'Hiba';
z.string.hu.conversationUnableToDecryptResetSession = 'Munkamenet visszalltsa';
z.string.hu.conversationMissedMessages = 'Ezt a kszlket mr nem hasznltad egy ideje, ezrt nem biztos, hogy minden zenet megjelenik itt.';
z.string.hu.conversationAssetUploading = 'Feltlts';
z.string.hu.conversationAssetDownloading = 'Letlts';
z.string.hu.conversationAssetUploadFailed = 'A feltlts sikertelen';
z.string.hu.conversationPlaybackError = 'Nem lehet lejtszani';
z.string.hu.conversationContextMenuCopy = 'Msols';
z.string.hu.conversationContextMenuEdit = 'Szerkeszts';
z.string.hu.conversationContextMenuDelete = 'Trls nlam';
z.string.hu.conversationContextMenuDeleteEveryone = 'Trls mindenkinl';
z.string.hu.conversationContextMenuDownload = 'Letlts';
z.string.hu.conversationContextMenuLike = 'Tetszik';
z.string.hu.conversationContextMenuUnlike = 'Nem tetszik';
z.string.hu.conversationDeleteTimestamp = 'Trlve: {{date}}';
z.string.hu.conversationEditTimestamp = 'Mdostva: {{date}}';
z.string.hu.conversationLikesCaption = '{{number}} partner';
z.string.hu.conversationSendPastedFile = 'Kp beillesztve ({{date}})';
z.string.hu.conversationSomeone = 'Valaki';
z.string.hu.conversationTweetAuthor = ' Twitteren';

z.string.hu.groupCreationPreferencesAction = 'Tovbb';
z.string.hu.groupCreationPreferencesErrorNameShort = 'Legalbb 1 karakter';
z.string.hu.groupCreationPreferencesErrorNameLong = 'Tl sok karakter';
z.string.hu.groupCreationPreferencesHeader = 'j csoport';
z.string.hu.groupCreationPreferencesPlaceholder = 'Csoportnv';
z.string.hu.groupCreationParticipantsActionCreate = 'Ksz';
z.string.hu.groupCreationParticipantsActionSkip = 'Kihagys';
z.string.hu.groupCreationParticipantsHeader = 'Partnerek hozzadsa';
z.string.hu.groupCreationParticipantsHeaderWithCounter = 'Partnerek hozzadsa ({{number}})';
z.string.hu.groupCreationParticipantsPlaceholder = 'Keress nv szerint';
z.string.hu.groupSizeInfo = 'Maximum {{count}} partner csatlakozhat a csoportos beszlgetshez. Videhvsok 4 vagy kevesebb emberrel lehetsgesek.';

z.string.hu.guestRoomConversationName = 'Vendgszoba';
z.string.hu.guestRoomToggleName = 'Vendgek engedlyezse';
z.string.hu.guestRoomToggleInfo = 'Megnyitja a beszlgetst a csapatodon kvli partnerek szmra is.';
z.string.hu.guestRoomToggleInfoExtended = 'A beszlgets elrhet a csapaton kvli embereknek is. Ezt ksbb brmikor megvltoztathatod.';

z.string.hu.guestRoomConversationBadge = 'Vendgek is vannak itt';

z.string.hu.guestRoomConversationHead = 'Csapatodon kvli emberek is csatlakozhatnak ehhez a beszlgetshez.';
z.string.hu.guestRoomConversationButton = 'Partner meghvsa';

z.string.hu.collectionShowAll = 'Mind a(z) {{number}} mutatsa';
z.string.hu.collectionSectionLinks = 'Hivatkozsok';
z.string.hu.collectionSectionImages = 'Kpek';
z.string.hu.collectionSectionFiles = 'Fjlok';
z.string.hu.collectionSectionAudio = 'Hangzenetek';

z.string.hu.fullsearchPlaceholder = 'Szveges zenetek keresse';
z.string.hu.fullsearchNoResults = 'Nincs tallat.';

z.string.hu.archiveHeader = 'Archivls';

z.string.hu.conversationsAllArchived = 'Minden archivlva';
z.string.hu.conversationsContacts = 'Nvjegyek';
z.string.hu.conversationsConnectionRequestMany = '{{number}} partner vrakozik';
z.string.hu.conversationsConnectionRequestOne = '1 partner vrakozik';
z.string.hu.conversationsEmptyConversation = 'Csoportos beszlgets';
z.string.hu.conversationsNoConversations = 'Indts egy beszlgetst vagy hozz ltre egy csoportot.';
z.string.hu.conversationsPopoverArchive = 'Archivls';
z.string.hu.conversationsPopoverBlock = 'Letilt';
z.string.hu.conversationsPopoverCancel = 'Krelem visszavonsa';
z.string.hu.conversationsPopoverClear = 'Tartalom trlse';
z.string.hu.conversationsPopoverLeave = 'Kilps a csoportbl';
z.string.hu.conversationsPopoverNotify = 'Nmts feloldsa';
z.string.hu.conversationsPopoverSilence = 'Nmts';
z.string.hu.conversationsPopoverUnarchive = 'Archivls visszavonsa';

z.string.hu.conversationsSecondaryLineEphemeralMessage = 'zenetet kldtt';
z.string.hu.conversationsSecondaryLineIncomingCall = '{{user}} hv';
z.string.hu.conversationsSecondaryLinePeopleLeft = '{{number}} partner kilpett a beszlgetsbl';
z.string.hu.conversationsSecondaryLinePersonLeft = '{{user}} kilpett';
z.string.hu.conversationsSecondaryLinePersonRemoved = '{{user}} eltvoltva';
z.string.hu.conversationsSecondaryLinePersonRemovedTeam = '{{user}} el lett tvoltva a csapatbl';
z.string.hu.conversationsSecondaryLinePeopleAdded = '{{user}} hozzadva';
z.string.hu.conversationsSecondaryLinePersonAdded = '{{user}} hozzadva';
z.string.hu.conversationsSecondaryLinePersonAddedSelf = '{{user}} csatlakozott';
z.string.hu.conversationsSecondaryLinePersonAddedYou = '{{user}} hozzadott tged';
z.string.hu.conversationsSecondaryLineRenamed = '{{user}} tnevezte a beszlgetst';
z.string.hu.conversationsSecondaryLineYouLeft = 'Kilptl';
z.string.hu.conversationsSecondaryLineYouWereRemoved = 'El lettl tvoltva';

z.string.hu.takeoverSub = 'Foglald le egyedi Wire felhasznlneved.';
z.string.hu.takeoverLink = 'Tovbbi informci';
z.string.hu.takeoverButtonChoose = 'Vlaszd ki a sajtod';
z.string.hu.takeoverButtonKeep = 'Tartsd meg ezt';

z.string.hu.inviteMetaKeyMac = 'Cmd';
z.string.hu.inviteMetaKeyPc = 'Ctrl';
z.string.hu.inviteHintSelected = 'Nyomd meg a {{metaKey}} + C billentykombincit a msolshoz';
z.string.hu.inviteHintUnselected = 'Jelld ki a szveget, majd nyomd meg a {{metaKey}} + C billentykombincit';
z.string.hu.inviteHeadline = 'Hvj meg msokat is a Wire-re';
z.string.hu.inviteMessage = 'Fent vagyok a Wire-n. Keress r a felhasznlnevemre: {{username}} vagy nyisd meg a get.wire.com weboldalt.';
z.string.hu.inviteMessageNoEmail = 'Fent vagyok a Wire-n. Ltogass el a get.wire.com weboldalra s lpj kapcsolatba velem.';

z.string.hu.extensionsBubbleButtonGif = 'Gif';

z.string.hu.extensionsGiphyButtonOk = 'Klds';
z.string.hu.extensionsGiphyButtonMore = 'Msik keresse';
z.string.hu.extensionsGiphyMessage = '{{tag}}  Forrs: giphy.com';
z.string.hu.extensionsGiphyNoGifs = 'Hopp, nincs gif';
z.string.hu.extensionsGiphyRandom = 'Vletlenszer';

z.string.hu.addParticipantsConfirmLabel = 'Hozzads';
z.string.hu.addParticipantsHeader = 'Partnerek hozzadsa';
z.string.hu.addParticipantsHeaderWithCounter = 'Partnerek hozzadsa ({{number}})';
z.string.hu.addParticipantsSearchPlaceholder = 'Keress nv szerint';
z.string.hu.addParticipantsServiceConfirmButton = 'j szolgltats';
z.string.hu.addParticipantsTabsPeople = 'Partner';
z.string.hu.addParticipantsTabsServices = 'Szolgltatsok';

z.string.hu.conversationDetailsActionArchive = 'Beszlgets archivlsa';
z.string.hu.conversationDetailsActionAddParticipants = 'Rsztvevk hozzadsa';
z.string.hu.conversationDetailsActionBlock = 'Partner tiltsa';
z.string.hu.conversationDetailsActionCancelRequest = 'Krelem visszavonsa';
z.string.hu.conversationDetailsActionClear = 'Tartalom trlse';
z.string.hu.conversationDetailsActionCreateGroup = 'j csoport';
z.string.hu.conversationDetailsActionDevices = 'Eszkzk';
z.string.hu.conversationDetailsActionGuestOptions = 'Vendg opcik';
z.string.hu.conversationDetailsActionNotifications = 'rtestsek';
z.string.hu.conversationDetailsActionLeave = 'Kilps a csoportbl';
z.string.hu.conversationDetailsGuestsOff = 'Kikapcsolva';
z.string.hu.conversationDetailsGuestsOn = 'Be';
z.string.hu.conversationDetailsOptions = 'Belltsok';
z.string.hu.conversationDetailsParticipantsServicesOne = 'Szolgltats';
z.string.hu.conversationDetailsParticipantsServicesMany = 'Szolgltatsok';
z.string.hu.conversationDetailsParticipantsUsersOne = 'Szemly';
z.string.hu.conversationDetailsParticipantsUsersMany = 'Partner';
z.string.hu.conversationDetailsPeople = 'Partner';
z.string.hu.conversationDetailsServices = 'Szolgltatsok';

z.string.hu.conversationParticipantsTitle = 'Partner';
z.string.hu.conversationParticipantsSearchPlaceholder = 'Keress nv szerint';

z.string.hu.groupParticipantActionBlock = 'Letilt';
z.string.hu.groupParticipantActionCancelRequest = 'Krelem visszavonsa';
z.string.hu.groupParticipantActionDevices = 'Eszkzk';
z.string.hu.groupParticipantActionIgnoreRequest = 'Krs figyelmen kvl hatsa';
z.string.hu.groupParticipantActionIncomingRequest = 'Krs elfogadsa';
z.string.hu.groupParticipantActionLeave = 'Kilps a csoportbl';
z.string.hu.groupParticipantActionOpenConversation = 'Beszlgets megnyitsa';
z.string.hu.groupParticipantActionPending = 'Fggben lv';
z.string.hu.groupParticipantActionRemove = 'Eltvolts a csoportbl';
z.string.hu.groupParticipantActionSelfProfile = 'Profil megnyitsa';
z.string.hu.groupParticipantActionSendRequest = 'Csatlakozs';
z.string.hu.groupParticipantActionUnblock = 'Tilts feloldsa';

z.string.hu.guestOptionsCopyLink = 'Hivatkozs msolsa';
z.string.hu.guestOptionsCopyLinkDone = 'Hivatkozs msolva!';
z.string.hu.guestOptionsCreateLink = 'Hivatkozs ltrehozsa';
z.string.hu.guestOptionsInfoHeader = 'Hvj meg msokat egy hivatkozssal';
z.string.hu.guestOptionsInfoText = 'Brki, akinek megvan ez a hivatkozs, csatlakozhat a beszlgetshez 24 rn bell, akkor is, ha egybknt nincsenek a Wire-n.';
z.string.hu.guestOptionsRevokeLink = 'Link visszavonsa';
z.string.hu.guestOptionsTitle = 'Vendg opcik';

z.string.hu.notificationSettingsTitle = 'rtestsek';

z.string.hu.participantDevicesDetailHeadline = 'Ellenrizd, hogy ez egyezik-e {{html1}}{{user}} eszkzn lthat{{html2}} ujjlenyomattal.';
z.string.hu.participantDevicesDetailHowTo = 'Hogyan csinljam?';
z.string.hu.participantDevicesDetailResetSession = 'Munkamenet visszalltsa';
z.string.hu.participantDevicesDetailShowMyDevice = 'Eszkz ujjlenyomatnak megjelentse';
z.string.hu.participantDevicesDetailVerify = 'Ellenrizve';

z.string.hu.participantDevicesHeader = 'Eszkzk';
z.string.hu.participantDevicesHeadline = 'A Wire-ben minden eszkz egyedi ujjlenyomattal rendelkezik. Hasonltsd ssze ezt az ujjlenyomatot {{user}} partnerrel s ellenrizd a beszlgetst.';
z.string.hu.participantDevicesLearnMore = 'Tovbbi informci';
z.string.hu.participantDevicesWhyVerify = 'Mirt ellenrizd a beszlgetseket?';
z.string.hu.participantDevicesOutdatedClientMessage = '{{user}} a Wire rgi verzijt hasznlja. Eszkzei itt nem jelenthetek meg.';

z.string.hu.participantDevicesSelfAllDevices = 'sszes sajt eszkz mutatsa';
z.string.hu.participantDevicesSelfFingerprint = 'Eszkz ujjlenyomata';

z.string.hu.userProfileButtonConnect = 'Csatlakozs';
z.string.hu.userProfileButtonIgnore = 'Figyelmen kvl hagys';
z.string.hu.userProfileButtonUnblock = 'Tilts feloldsa';

z.string.hu.preferencesAbout = 'Nvjegy';
z.string.hu.preferencesAccount = 'Fik';
z.string.hu.preferencesAV = 'Hang / Vide';
z.string.hu.preferencesDeviceDetails = 'Eszkz rszletei';
z.string.hu.preferencesDevices = 'Eszkzk';
z.string.hu.preferencesHeadline = 'Belltsok';
z.string.hu.preferencesOptions = 'Belltsok';

z.string.hu.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.hu.preferencesAboutPrivacyPolicy = 'Adatvdelmi Nyilatkozat';
z.string.hu.preferencesAboutSupport = 'gyflszolglat';
z.string.hu.preferencesAboutSupportWebsite = 'Wire gyflszolglat';
z.string.hu.preferencesAboutSupportContact = 'Kapcsolatfelvtel az gyflszolglattal';
z.string.hu.preferencesAboutTermsOfUse = 'Felhasznlsi felttelek';
z.string.hu.preferencesAboutVersion = 'Verzi {{version}}';
z.string.hu.preferencesAboutWebsite = 'Wire weboldala';

z.string.hu.preferencesAccountAvaibilityUnset = 'llapot belltsa';
z.string.hu.preferencesAccountCreateTeam = 'Csapat ltrehozsa';
z.string.hu.preferencesAccountData = 'Adatokhasznlati engedlyek';
z.string.hu.preferencesAccountDataCheckbox = 'Adatok kldse nvtelenl';
z.string.hu.preferencesAccountDataDetail = 'Nvtelen hasznlati s hibajelentsek kldsvel segthetsz, hogy a Wire mg jobb legyen.';
z.string.hu.preferencesAccountDelete = 'Fik trlse';
z.string.hu.preferencesAccountLeaveGuestRoom = 'Vendgszoba elhagysa';
z.string.hu.preferencesAccountLeaveGuestRoomDescription = 'Ezutn nem tudod elrni az ebben a beszlgetsben lv zeneteket.';
z.string.hu.preferencesAccountLogOut = 'Kijelentkezs';
z.string.hu.preferencesAccountManageTeam = 'Csapat kezelse';
z.string.hu.preferencesAccountMarketingConsentCheckbox = 'Feliratkozs hrlevlre';
z.string.hu.preferencesAccountMarketingConsentDetail = 'Hrek s termkinformcik fogadsa e-mailben a Wire-tl.';
z.string.hu.preferencesAccountResetPassword = 'Jelsz visszalltsa';
z.string.hu.preferencesAccountTeam = 'innen: {{name}}';
z.string.hu.preferencesAccountUsernamePlaceholder = 'Teljes neved';
z.string.hu.preferencesAccountUsernameHint = 'Legalbb 2 karakter, s kizrlag az, 09 s _ karakterek.';
z.string.hu.preferencesAccountUsernameAvailable = 'Elrhet';
z.string.hu.preferencesAccountUsernameErrorTaken = 'Mr foglalt';

z.string.hu.preferencesAVCamera = 'Kamera';
z.string.hu.preferencesAVMicrophone = 'Mikrofon';
z.string.hu.preferencesAVPermissionDetail = 'Engedlyezze a bngsz Belltsainl';
z.string.hu.preferencesAVSpeakers = 'Hangszrk';
z.string.hu.preferencesAVTryAgain = 'Prbld jra';

z.string.hu.preferencesDevicesActivatedOn = 'Legutbb aktivlva: {{date}}';
z.string.hu.preferencesDevicesActive = 'Aktv';
z.string.hu.preferencesDevicesActiveDetail = 'Ha a fenti eszkzk kzl valamelyik nem ismers, akkor trld azt s vltoztass jelszt.';
z.string.hu.preferencesDevicesCurrent = 'Ez az eszkz';
z.string.hu.preferencesDevicesFingerprint = 'Eszkzazonost ujjlenyomat';
z.string.hu.preferencesDevicesFingerprintDetail = 'A Wire-ben minden eszkz egyedi ujjlenyomattal rendelkezik. sszehasonltssal ellenrizd az eszkzket s a beszlgetseket.';
z.string.hu.preferencesDevicesId = 'Eszkzazonost (ID): ';
z.string.hu.preferencesDevicesRemove = 'Eltvolts';
z.string.hu.preferencesDevicesRemoveCancel = 'Mgsem';
z.string.hu.preferencesDevicesRemoveDetail = 'Tvoltsd el ezt az eszkzt, ha mr nem hasznlod. Ezzel egytt azonnal ki is jelentkezel errl az eszkzrl.';
z.string.hu.preferencesDevicesSessionConfirmation = 'A munkamenet alaphelyzetbe lett lltva.';
z.string.hu.preferencesDevicesSessionDetail = 'Ha az ujjlenyomatok nem egyeznek, lltsd vissza a munkamenet, gy mindkt oldalon j titkostsi kulcsok jnnek ltre.';
z.string.hu.preferencesDevicesSessionReset = 'Munkamenet visszalltsa';
z.string.hu.preferencesDevicesSessionOngoing = 'Munkamenet visszalltsa';
z.string.hu.preferencesDevicesVerification = 'Ellenrizve';

z.string.hu.preferencesOptionsAudio = 'Hangjelzsek';
z.string.hu.preferencesOptionsAudioAll = 'Minden';
z.string.hu.preferencesOptionsAudioAllDetail = 'Minden hang';
z.string.hu.preferencesOptionsAudioNone = 'Semmi';
z.string.hu.preferencesOptionsAudioNoneDetail = 'Pssszt!';
z.string.hu.preferencesOptionsAudioSome = 'Nhny';
z.string.hu.preferencesOptionsAudioSomeDetail = 'Kopogsok s hvsok';
z.string.hu.preferencesOptionsContacts = 'Nvjegyek';
z.string.hu.preferencesOptionsContactsGmail = 'Importls Gmail-bl';
z.string.hu.preferencesOptionsContactsMacos = 'Importls Nvjegyek-bl';
z.string.hu.preferencesOptionsContactsDetail = 'A nvjegyeid importlsval knnyebben kapcsolatba lphetsz msokkal. Minden informcit anonimizlunk, s semmit nem osszuk meg senki mssal.';
z.string.hu.preferencesOptionsPopular = 'Kzkvnatra';
z.string.hu.preferencesOptionsEmojiReplaceCheckbox = 'Cserlje ki a begpelt hangulatjeleket emojikra';
z.string.hu.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.hu.preferencesOptionsPreviewsSendCheckbox = 'Elnzet ksztse az elkldtt hivatkozsokrl';
z.string.hu.preferencesOptionsPreviewsSendDetail = 'A ms partnerektl kapott hivatkozsok elnzete tovbbra is lthat lesz.';
z.string.hu.preferencesOptionsNotifications = 'rtestsek';
z.string.hu.preferencesOptionsNotificationsNone = 'Kikapcsolva';
z.string.hu.preferencesOptionsNotificationsObfuscate = 'Rszletek elrejtse';
z.string.hu.preferencesOptionsNotificationsObfuscateMessage = 'Kld mutatsa';
z.string.hu.preferencesOptionsNotificationsOn = 'Kld s zenet mutatsa';
z.string.hu.preferencesOptionsCallLogs = 'Hibaelhrts';
z.string.hu.preferencesOptionsCallLogsGet = 'Hvsok hibanapljnak mentse';
z.string.hu.preferencesOptionsCallLogsDetail = 'Ez az informci segt a Wire gyflszolglatnak a hvssal kapcsolatos problmk diagnosztizlsban.';

z.string.hu.preferencesOptionsBackupHeader = 'Elzmnyek';
z.string.hu.preferencesOptionsBackupExportHeadline = 'Beszlgetsek mentse';
z.string.hu.preferencesOptionsBackupExportSecondary = 'Biztonsgi ments ksztsvel megrizheted a beszlgetsek elzmnyeit. Ksbb ezzel vissza tudod lltani az elzmnyeket, ha elhagyod a szmtgped vagy jat kezdesz hasznlni.\nA ments nincs titkostva, ezrt biztonsgos helyen trold.';
z.string.hu.preferencesOptionsBackupImportHeadline = 'Visszallts biztonsgi msolatbl';
z.string.hu.preferencesOptionsBackupImportSecondary = 'Csak ugyanazon platformon kszlt mentst tudsz visszalltani. A visszallts fellrja az eszkzn jelenleg lv beszlgetseket.';

z.string.hu.backupExportGenericErrorHeadline = 'Nem sikerlt a fjl mentse';
z.string.hu.backupExportGenericErrorSecondary = 'A ments nem kszlt el.';
z.string.hu.backupExportProgressHeadline = 'Elkszts';
z.string.hu.backupExportProgressSecondary = 'Ments folyamatban  {{processed}} / {{total}}  {{progress}}%';
z.string.hu.backupExportProgressCompressing = 'Biztonsgi msolat ksztse';
z.string.hu.backupExportSaveFileAction = 'Fjl mentse';
z.string.hu.backupExportSuccessHeadline = 'Biztonsgi ments ksz';
z.string.hu.backupExportSuccessSecondary = 'Ennek segtsgvel vissza tudod lltani az elzmnyeket, ha elhagyod a szmtgped vagy elkezdesz egy jat hasznlni.';
z.string.hu.backupImportGenericErrorHeadline = 'Valami nem stimmel';
z.string.hu.backupImportGenericErrorSecondary = 'Az elzmnyek visszalltsa nem sikerlt.';
z.string.hu.backupImportAccountErrorHeadline = 'Rossz ments';
z.string.hu.backupImportAccountErrorSecondary = 'Az elzmnyeket nem lehet msik felhasznli fikbl visszalltani.';
z.string.hu.backupImportVersionErrorHeadline = 'A ments nem kompatibilis';
z.string.hu.backupImportVersionErrorSecondary = 'Ez a ments egy jabb vagy elavultabb Wire verzival kszlt s nem lehet itt visszalltani.';
z.string.hu.backupImportIncompatibleErrorHeadline = 'Rossz ments';
z.string.hu.backupImportIncompatibleErrorSecondary = 'Az elzmnyeket nem lehet msik felhasznli fikbl visszalltani.';
z.string.hu.backupImportOutdatedErrorHeadline = 'A ments nem kompatibilis';
z.string.hu.backupImportOutdatedErrorSecondary = 'Ez a ments egy jabb vagy elavultabb Wire verzival kszlt s nem lehet itt visszalltani.';
z.string.hu.backupImportProgressHeadline = 'Elkszts';
z.string.hu.backupImportProgressSecondary = 'Visszallts folyamatban  {{processed}} / {{total}}  {{progress}}%';
z.string.hu.backupImportSuccessHeadline = 'Az elzmnyek visszalltva.';
z.string.hu.backupCancel = 'Mgsem';
z.string.hu.backupTryAgain = 'Prbld jra';

z.string.hu.searchConnect = 'Csatlakozs';
z.string.hu.searchConnections = 'Kapcsolatok';
z.string.hu.searchContacts = 'Nvjegyek';
z.string.hu.searchCreateGroup = 'Csoport ltrehozsa';
z.string.hu.searchCreateGuestRoom = 'Vendgszoba ltrehozsa';
z.string.hu.searchGroups = 'Csoportok';
z.string.hu.searchPeople = 'Partner';
z.string.hu.searchPlaceholder = 'Keress nv vagy felhasznlnv alapjn';
z.string.hu.searchServicePlaceholder = 'Keress nv szerint';
z.string.hu.searchServices = 'Szolgltatsok';
z.string.hu.searchTeamGroups = 'Csapat beszlgets';
z.string.hu.searchTeamMembers = 'Csapattagok';
z.string.hu.searchTopPeople = 'Top Partnerek';
z.string.hu.searchTrySearch = 'Partnerek keresse\nnv vagy felhasznlnv alapjn';
z.string.hu.searchNoContactsOnWire = 'Nincsenek nvjegyeid a Wire-n.\nPrblj j partnereket keresni, \nnv vagy @felhasznlnv alapjn.';
z.string.hu.searchMemberInvite = 'Hvj meg msokat a csapatba';
z.string.hu.searchOthers = 'Csatlakozs';

z.string.hu.searchInvite = 'Hvj meg msokat is a Wire-re';
z.string.hu.searchInviteDetail = 'Nvjegyeid megosztsa megknnyti, hogy kapcsolatba lpj msokkal. Az sszes informcit anonimizljuk s nem osztjuk meg senki mssal.';
z.string.hu.searchInviteButtonContacts = 'Nvjegyekbl';
z.string.hu.searchInviteButtonGmail = 'Gmail-bl';
z.string.hu.searchInviteHeadline = 'Hozd a bartaidat is';
z.string.hu.searchInviteShare = 'Nvjegyek megosztsa';

z.string.hu.searchServiceConfirmButton = 'j szolgltats';

z.string.hu.searchListEveryoneParticipates = 'Az sszes partnered, \nakivel felvetted a kapcsolatot,\nmr ebben a beszlgetsben van.';
z.string.hu.searchListNoMatches = 'Nincs tallat. \nPrblj megy egy msik nevet.';

z.string.hu.temporaryGuestCta = 'Fik ltrehozsa';
z.string.hu.temporaryGuestDescription = 'Tedd biztonsgosabb vllalkozsodat a csoportos zenetek s beszlgetsek titkostsval.';
z.string.hu.temporaryGuestTimeRemaining = ' maradt ebben a vendgszobban';

z.string.hu.temporaryGuestJoinMessage = 'Ez a beszlgets 24 rn keresztl lesz elrhet.';
z.string.hu.temporaryGuestJoinDescription = 'Ha bezrod vagy jratltd ezt az oldalt, akkor elveszted a hozzfrsed.';

z.string.hu.temporaryGuestLeaveMessage = ' mr nem rszesei ennek a beszlgetsnek.';
z.string.hu.temporaryGuestLeaveDescription = 'Ha bezrod vagy jratltd ezt az oldalt, akkor elveszted a hozzfrst a beszlgets elzmnyeihez.';

z.string.hu.uploadGoogleHeadline = 'Keress partnereket\na Wire-n.';
z.string.hu.uploadGoogleMessage = 'A nvjegyeid importlsval knnyebben kapcsolatba lphetsz msokkal. Minden informcit anonimizlunk, s semmit nem osszuk meg senki mssal.';

z.string.hu.urlSupportRoot = '/';
z.string.hu.urlSupportArticles = '/hc/en-us/articles/';
z.string.hu.urlSupportRequests = '/hc/en-us/requests/';
z.string.hu.urlWebappRoot = '/';
z.string.hu.urlWebsiteRoot = '/';
z.string.hu.urlWebsiteCreateTeam = '/csapat-ltrehozsa/';
z.string.hu.urlWebsitePrivacy = '/adatvdelem';
z.string.hu.warningCallUnsupportedIncoming = '{{user}} hv. Bngszd nem tmogatja a hanghvsokat.';
z.string.hu.warningCallUnsupportedOutgoing = 'Nem kezdemnyezhetsz hvst, mert bngszd nem tmogatja a hanghvsokat.';
z.string.hu.warningCallIssues = 'Ezzel a Wire verzival nem tudsz rszt venni a hvsban. Krjk, hasznld ezt:';
z.string.hu.warningCallUpgradeBrowser = 'Krjk, hogy hanghvsokhoz frisstsd a Google Chrome-ot.';
z.string.hu.warningConnectivityConnectionLost = 'Kapcsoldsi ksrlet folyamatban. A Wire most nem tud zeneteket kzbesteni.';
z.string.hu.warningConnectivityNoInternet = 'Nincs internet. zenetek kldse s fogadsa most nem lehetsges.';
z.string.hu.warningLearnMore = 'Tovbbi informci';
z.string.hu.warningLifecycleUpdate = 'Elrhet a Wire j verzija.';
z.string.hu.warningLifecycleUpdateNotes = 'jdonsgok';
z.string.hu.warningLifecycleUpdateLink = 'Frissts most';
z.string.hu.warningNotFoundCamera = 'Nem kezdemnyezhetsz hvst, mert nincs kamerd.';
z.string.hu.warningNotFoundMicrophone = 'Nem kezdemnyezhetsz hvst, mert nincs mikrofonod.';
z.string.hu.warningPermissionDeniedCamera = 'Nem kezdemnyezhetsz hvst, mert bngszd nem frhet hozz a kamerdhoz.';
z.string.hu.warningPermissionDeniedMicrophone = 'Nem kezdemnyezhetsz hvst, mert bngszd nem frhet hozz a mikrofonodhoz.';
z.string.hu.warningPermissionDeniedScreen = 'A kpernymegosztst engedlyezned kell a bngszben.';
z.string.hu.warningPermissionRequestCamera = '{{icon}} Kamera hozzfrs engedlyezse';
z.string.hu.warningPermissionRequestMicrophone = '{{icon}} Mikrofon hozzfrs engedlyezse';
z.string.hu.warningPermissionRequestNotification = '{{icon}} rtestsek engedlyezse';
z.string.hu.warningPermissionRequestScreen = '{{icon}} Kpernymegoszts engedlyezse';

z.string.hu.userAvailabilityAvailable = 'Elrhet';
z.string.hu.userAvailabilityAway = 'Nincs a gpnl';
z.string.hu.userAvailabilityBusy = 'Elfoglalt';
z.string.hu.userAvailabilityNone = 'Semmi';

z.string.hu.notificationAssetAdd = 'Megosztott egy kpet';
z.string.hu.notificationConnectionAccepted = 'Elfogadta a csatlakozsi krelmedet';
z.string.hu.notificationConnectionConnected = 'Most mr csatlakozva vagytok';
z.string.hu.notificationConnectionRequest = 'Szeretne csatlakozni';
z.string.hu.notificationConversationCreate = '{{user}} beszlgetst indtott';
z.string.hu.notificationConversationRename = '{{user}} tnevezte a beszlgetst erre: {{name}}';
z.string.hu.notificationMemberJoinMany = '{{user}} hozzadott {{number}} partnert a beszlgetshez';
z.string.hu.notificationMemberJoinSelf = '{{user}} csatlakozott a beszlgetshez';
z.string.hu.notificationMemberJoinOne = '{{user1}} hozzadta {{user2}} partnert a beszlgetshez';
z.string.hu.notificationMemberLeaveRemovedYou = '{{user}} eltvoltott a beszlgetsbl';
z.string.hu.notificationObfuscated = 'zenetet kldtt';
z.string.hu.notificationObfuscatedTitle = 'Valaki';
z.string.hu.notificationPing = 'Kopogott';
z.string.hu.notificationReaction = 'Reaglt egy zenetre: {{reaction}}';
z.string.hu.notificationSharedAudio = 'Megosztott egy hangzenetet';
z.string.hu.notificationSharedFile = 'Megosztott egy fjlt';
z.string.hu.notificationSharedLocation = 'Megosztott egy helyet';
z.string.hu.notificationSharedVideo = 'Megosztott egy videt';
z.string.hu.notificationVoiceChannelActivate = 'Hv';
z.string.hu.notificationVoiceChannelDeactivate = 'Hvta';

z.string.hu.tooltipConversationAllVerified = 'Minden ujjlenyomat ellenrizve';
z.string.hu.tooltipConversationCall = 'Hvs';
z.string.hu.tooltipConversationEphemeral = 'Idztett zenet';
z.string.hu.tooltipConversationFile = 'Fjl hozzadsa';
z.string.hu.tooltipConversationInputPlaceholder = 'zenet rsa';
z.string.hu.tooltipConversationInputPlaceholderAvailable = '{{user}} elrhet';
z.string.hu.tooltipConversationInputPlaceholderAway = '{{user}} nincs a gpnl';
z.string.hu.tooltipConversationInputPlaceholderBusy = '{{user}} elfoglalt';
z.string.hu.tooltipConversationPeople = 'Partnerek ({{shortcut}})';
z.string.hu.tooltipConversationPicture = 'Kp hozzadsa';
z.string.hu.tooltipConversationPing = 'Kopogs ({{shortcut}})';
z.string.hu.tooltipConversationSearch = 'Keress';
z.string.hu.tooltipConversationVideoCall = 'Videhvs';

z.string.hu.tooltipConversationsArchive = 'Archivls ({{shortcut}})';
z.string.hu.tooltipConversationsArchived = 'Archvum megtekintse ({{number}})';
z.string.hu.tooltipConversationsMore = 'Tovbbiak';
z.string.hu.tooltipConversationsNotify = 'Nmts feloldsa ({{shortcut}})';
z.string.hu.tooltipConversationsPreferences = 'Belltsok megnyitsa';
z.string.hu.tooltipConversationsSilence = 'Nmts ({{shortcut}})';
z.string.hu.tooltipConversationsStart = 'Beszlgets megkezdse ({{shortcut}})';

z.string.hu.tooltipConversationDetailsAddPeople = 'Rsztvevk hozzadsa a beszlgetshez ({{shortcut}})';
z.string.hu.tooltipConversationDetailsRename = 'Beszlgets nevnek megvltoztatsa';

z.string.hu.tooltipPreferencesContactsGmail = 'Kapcsolataid megosztshoz jelentkezz be Gmail fikodba';
z.string.hu.tooltipPreferencesContactsMacos = 'Oszd meg nvjegyeidet a macOS Nvjegyek alkalmazsbl';
z.string.hu.tooltipPreferencesPassword = 'Nyiss meg egy msik weboldalt jelszavad visszalltshoz';
z.string.hu.tooltipPreferencesPicture = 'Profilkp mdostsa';
z.string.hu.tooltipPreferencesRename = 'Nv mdostsa';

z.string.hu.tooltipSearchClose = 'Bezrs (Esc)';

z.string.hu.initReceivedSelfUser = 'Szia {{user}}!';
z.string.hu.initValidatedClient = 'Kapcsolatok s a beszlgetsek lekrse';
z.string.hu.initReceivedUserData = 'j zenetek megtekintse';
z.string.hu.initDecryption = 'zenetek visszafejtse';
z.string.hu.initEvents = 'zenetek betltse';
z.string.hu.initUpdatedFromNotifications = 'Majdnem ksz - lvezd a Wire-t';
z.string.hu.initProgress = '  {{number1}} / {{number2}}';

z.string.hu.ephemeralUnitsNone = 'Kikapcsolva';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.it.wireMacos = 'Wire per macOS';
z.string.it.wireWindows = 'Wire per Windows';
z.string.it.wireLinux = 'Wire per Linux';
z.string.it.nonexistentUser = 'Elimina utente';
z.string.it.and = 'e';

z.string.it.authAccountCountryCode = 'Codice del paese';
z.string.it.authAccountPasswordForgot = 'Ho dimenticato la password';
z.string.it.authAccountPublicComputer = 'Questo computer  pubblico';
z.string.it.authAccountSignIn = 'Accedi';
z.string.it.authAccountSignInPhone = 'Telefono';

z.string.it.authBlockedDatabase = 'Wire ha bisogno di accedere la memoria locale per visualizzare i messaggi. Archiviazione locale non  disponibile in modalit privata.';
z.string.it.authBlockedTabs = 'Wire  gi aperto in unaltra scheda.';

z.string.it.authVerifyAccountAdd = 'Aggiungi';
z.string.it.authVerifyAccountDetail = 'Questo ti consente di usare Wire su pi dispositivi.';
z.string.it.authVerifyAccountHeadline = 'Aggiungi indirizzo email e password.';
z.string.it.authVerifyAccountLogout = 'Logout';
z.string.it.authVerifyCodeDescription = 'Inserisci il codice di verifica che abbiamo inviato a {{number}}.';
z.string.it.authVerifyCodeResend = 'Non hai ricevuto nessun codice?';
z.string.it.authVerifyCodeResendDetail = 'Inviare di nuovo';
z.string.it.authVerifyCodeResendTimer = ' possibile richiedere un nuovo codice {{expiration}}.';
z.string.it.authVerifyCodeChangePhone = 'Cambia numero di telefono';
z.string.it.authVerifyPasswordHeadline = 'Inserisci la tua password';

z.string.it.authLimitDevicesHeadline = 'Dispositivi';
z.string.it.authLimitDescription = 'Rimuovi uno dei tuoi dispositivi per iniziare a utilizzare Wire su questo.';
z.string.it.authLimitButtonManage = 'Gestione dei dispositivi';
z.string.it.authLimitButtonSignOut = 'Logout';
z.string.it.authLimitDevicesCurrent = '(Corrente)';

z.string.it.authHistoryHeadline = ' la prima volta che utilizzi Wire questo dispositivo.';
z.string.it.authHistoryDescription = 'Per motivi di privacy, la cronologia delle tue conversazioni non apparir qui.';
z.string.it.authHistoryReuseHeadline = 'Hai utilizzato Wire su questo dispositivo prima.';
z.string.it.authHistoryReuseDescription = 'I messaggi inviati nel frattempo non verranno visualizzati qui.';
z.string.it.authHistoryButton = 'OK';

z.string.it.authPostedResend = 'Invia di nuovo a {{email}}';
z.string.it.authPostedResendAction = 'Non hai ricevuto nessuna email?';
z.string.it.authPostedResendDetail = 'Verifica la tua casella di posta e segui le istruzioni.';
z.string.it.authPostedResendHeadline = 'C posta per te.';

z.string.it.authPlaceholderEmail = 'Email';
z.string.it.authPlaceholderPasswordPut = 'Password';
z.string.it.authPlaceholderPasswordSet = 'Password (almeno 8 caratteri)';
z.string.it.authPlaceholderPhone = 'Numero di telefono';

z.string.it.authErrorCode = 'Codice non valido';
z.string.it.authErrorCountryCodeInvalid = 'Prefisso paese non valido';
z.string.it.authErrorEmailExists = 'Indirizzo email gi registrato';
z.string.it.authErrorEmailForbidden = 'Siamo spiacenti. Questo indirizzo email  vietato.';
z.string.it.authErrorEmailMalformed = 'Inserisci un indirizzo email valido.';
z.string.it.authErrorEmailMissing = 'Inserisci un indirizzo email.';
z.string.it.authErrorMisc = 'Problemi di connessione. Riprova.';
z.string.it.authErrorNameShort = 'Inserisci un nome con almeno 2 caratteri';
z.string.it.authErrorOffline = 'Nessuna connessione internet';
z.string.it.authErrorPasswordShort = 'Scegli una password con almeno 8 caratteri.';
z.string.it.authErrorPasswordWrong = 'Password errata. Riprova.';
z.string.it.authErrorPhoneNumberBudget = 'Hai eseguito laccesso troppo spesso. Riprova pi tardi.';
z.string.it.authErrorPhoneNumberForbidden = 'Spiacenti. Questo numero di telefono  vietato.';
z.string.it.authErrorPhoneNumberInvalid = 'Numero di telefono non valido';
z.string.it.authErrorPhoneNumberUnknown = 'Numero di telefono sconosciuto';
z.string.it.authErrorSuspended = 'Questo account non  pi autorizzato ad accedere.';
z.string.it.authErrorSignIn = 'Verifica i tuoi dati e riprova.';

z.string.it.callStateOutgoing = 'Sta squillando';
z.string.it.callStateConnecting = 'Connessione in corso';
z.string.it.callStateIncoming = 'Chiamata in corso';
z.string.it.callDecline = 'Rifiuta';
z.string.it.callAccept = 'Accetta';
z.string.it.callJoin = 'Entra';
z.string.it.callChooseSharedScreen = 'Scegli quale schermata condividere';
z.string.it.callParticipants = '{{number}} nella chiamata';

z.string.it.videoCallOverlayMute = 'Silenzia';
z.string.it.videoCallOverlayHangUp = 'Riattacca';

z.string.it.modalAcknowledgeAction = 'Ok';
z.string.it.modalConfirmSecondary = 'Annulla';
z.string.it.modalOptionSecondary = 'Annulla';

z.string.it.modalAccountCreateAction = 'OK';

z.string.it.modalAccountDeletionAction = 'Elimina';
z.string.it.modalAccountDeletionHeadline = 'Elimina account';
z.string.it.modalAccountDeletionMessage = 'Ti invieremo un SMS o una email. Segui il link per eliminare definitivamente il tuo account.';

z.string.it.modalAccountLeaveGuestRoomAction = 'Abbandona';

z.string.it.modalAccountLogoutAction = 'Logout';
z.string.it.modalAccountLogoutHeadline = 'Cancella dati?';
z.string.it.modalAccountLogoutOption = 'Elimina tutti i tuoi dati personali e le conversazioni su questo dispositivo.';

z.string.it.modalAccountNewDevicesSecondary = 'Gestione dei dispositivi';
z.string.it.modalAccountNewDevicesHeadline = 'Il tuo account  stato utilizzato su:';
z.string.it.modalAccountNewDevicesFrom = 'Da:';
z.string.it.modalAccountNewDevicesMessage = 'Se non sei stato tu, riuovi il dispositivo e reimposta la password.';

z.string.it.modalAccountRemoveDeviceAction = 'Rimuovi dispositivo';
z.string.it.modalAccountRemoveDeviceHeadline = 'Rimuovi "{{device}}"';
z.string.it.modalAccountRemoveDeviceMessage = 'La tua password  necessaria per rimuovere il dispositivo.';
z.string.it.modalAccountRemoveDevicePlaceholder = 'Password';

z.string.it.modalAssetTooLargeMessage = 'Puoi inviare file fino a {{number}}';

z.string.it.modalAssetParallelUploadsMessage = ' possibile inviare fino a {{number}} file in una sola volta.';

z.string.it.modalCallEmptyConversationHeadline = 'Nessuno da chiamare';
z.string.it.modalCallEmptyConversationMessage = 'Non c pi nessuno qui.';

z.string.it.modalCallNoGroupVideoHeadline = 'Nessuna video chiamata nei gruppi';
z.string.it.modalCallNoGroupVideoMessage = 'Le videochiamate non sono disponibili nelle chat di gruppo.';

z.string.it.modalCallNoMicrophoneAction = 'Dimmi come';
z.string.it.modalCallNoMicrophoneMessage = 'Il browser ha bisogno di accedere al microfono per effettuare le chiamate.';
z.string.it.modalCallNoMicrophoneHeadline = 'Impossibile chiamare senza microfono';

z.string.it.modalCallSecondIncomingAction = 'Rispondi';
z.string.it.modalCallSecondIncomingHeadline = 'Rispondere alla chiamata?';
z.string.it.modalCallSecondIncomingMessage = 'La chiamata attuale terminer.';

z.string.it.modalCallSecondOngoingAction = 'Riattacca';
z.string.it.modalCallSecondOngoingHeadline = 'Riagganciare la chiamata su un altro dispositivo?';
z.string.it.modalCallSecondOngoingMessage = ' possibile partecipare a una sola chiamata alla volta.';

z.string.it.modalCallSecondOutgoingAction = 'Riattacca';
z.string.it.modalCallSecondOutgoingHeadline = 'Riagganciare la chiamata corrente?';
z.string.it.modalCallSecondOutgoingMessage = ' possibile partecipare a una sola chiamata alla volta.';

z.string.it.modalConnectCancelAction = 'S';
z.string.it.modalConnectCancelHeadline = 'Annullare la richiesta?';
z.string.it.modalConnectCancelMessage = 'Rimuovere la richiesta di connessione a {{user}}.';
z.string.it.modalConnectCancelSecondary = 'No';

z.string.it.modalConnectAcceptAction = 'Connetti';
z.string.it.modalConnectAcceptHeadline = 'Accettare?';
z.string.it.modalConnectAcceptMessage = 'Questo ti collegher e aprir la conversazione con {{user}}.';
z.string.it.modalConnectAcceptSecondary = 'Ignora';

z.string.it.modalConversationClearAction = 'Elimina';
z.string.it.modalConversationClearHeadline = 'Eliminare il contenuto?';
z.string.it.modalConversationClearOption = 'In aggiunta, abbandona la conversazione';

z.string.it.modalConversationDeleteMessageAction = 'Elimina';
z.string.it.modalConversationDeleteMessageHeadline = 'Eliminare solo per me?';
z.string.it.modalConversationDeleteMessageMessage = 'Questa azione non pu essere annullata.';

z.string.it.modalConversationDeleteMessageEveryoneAction = 'Elimina';
z.string.it.modalConversationDeleteMessageEveryoneHeadline = 'Eliminare per tutti?';
z.string.it.modalConversationDeleteMessageEveryoneMessage = 'Questa azione non pu essere annullata.';

z.string.it.modalConversationLeaveAction = 'Abbandona';
z.string.it.modalConversationLeaveMessage = 'Non sarai pi in grado di inviare o ricevere messaggi in questa conversazione.';

z.string.it.modalConversationMessageTooLongHeadline = 'Messaggio troppo lungo';
z.string.it.modalConversationMessageTooLongMessage = ' possibile inviare messaggi fino a {{number}} caratteri.';

z.string.it.modalConversationNewDeviceHeadlineOne = '{{user}} ha iniziato a utilizzare un nuovo dispositivo';
z.string.it.modalConversationNewDeviceHeadlineMany = '{{user}}s ha iniziato a utilizzare nuovi dispositivi';
z.string.it.modalConversationNewDeviceHeadlineYou = '{{user}} ha iniziato a utilizzare un nuovo dispositivo';
z.string.it.modalConversationNewDeviceIncomingCallAction = 'Accetta la chiamata';
z.string.it.modalConversationNewDeviceIncomingCallMessage = 'Vuoi accettare la chiamata?';
z.string.it.modalConversationNewDeviceMessage = 'Vuoi comunque mandare il messaggio?';
z.string.it.modalConversationNewDeviceOutgoingCallAction = 'Chiama comunque';
z.string.it.modalConversationNewDeviceOutgoingCallMessage = 'Vuoi effettuare la chiamata?';

z.string.it.modalConversationNotConnectedMessageOne = '{{name}} non vuole partecipare alle conversazioni.';
z.string.it.modalConversationNotConnectedMessageMany = 'Una delle persone che hai selezionato non vuole essere aggiunta alle conversazioni.';

z.string.it.modalConversationRemoveAction = 'Rimuovi';
z.string.it.modalConversationRemoveHeadline = 'Rimuovere?';
z.string.it.modalConversationRemoveMessage = '{{user}} non sar in grado di inviare o ricevere messaggi in questa conversazione.';

z.string.it.modalConversationRemoveGuestsAction = 'Rimuovi';

z.string.it.modalConversationTooManyMembersHeadline = 'Chiamata piena';



z.string.it.modalImproveWireAction = 'Accetta';
z.string.it.modalImproveWireSecondary = 'No';

z.string.it.modalSessionResetHeadline = 'La sessione  stata reimpostata';
z.string.it.modalSessionResetMessage1 = 'Se il problema non viene risolto,';
z.string.it.modalSessionResetMessageLink = 'contatta';
z.string.it.modalSessionResetMessage2 = 'Wire.';

z.string.it.modalUploadContactsAction = 'Riprova';
z.string.it.modalUploadContactsMessage = 'Non abbiamo ricevuto i tuoi dati. Per favore riprova ad importare i tuoi contatti.';

z.string.it.modalUserBlockAction = 'Blocca';
z.string.it.modalUserBlockHeadline = 'Bloccare {{user}}?';
z.string.it.modalUserBlockMessage = '{{user}} non sar in grado di contattarti o aggiungerti alle conversazioni di gruppo.';

z.string.it.modalUserUnblockAction = 'Sblocca';
z.string.it.modalUserUnblockHeadline = 'Sblocca?';
z.string.it.modalUserUnblockMessage = '{{user}} sar in grado di contattarti e aggiungerti alle conversazioni di gruppo di nuovo.';

z.string.it.connectionRequestConnect = 'Connetti';
z.string.it.connectionRequestIgnore = 'Ignora';

z.string.it.conversationGuestIndicator = 'Ospite';

z.string.it.conversationYouNominative = 'tu';
z.string.it.conversationYouDative = 'tu';
z.string.it.conversationYouAccusative = 'tu';

z.string.it.conversationConnectionAccepted = 'Connesso';
z.string.it.conversationConnectionBlocked = 'Bloccato';
z.string.it.conversationConnectionCancelRequest = 'Annulla la richiesta di connessione';
z.string.it.conversationDeviceStartedUsingOne = ' ha iniziato ad usare';
z.string.it.conversationDeviceStartedUsingMany = ' ha iniziato ad usare';
z.string.it.conversationDeviceUnverified = ' hai tolto la verifica di';
z.string.it.conversationDeviceYourDevices = ' i tuoi dispositivi';
z.string.it.conversationDeviceUserDevices = ' Dispositivi di {{user}}s';
z.string.it.conversationDeviceNewDeviceOne = ' un nuovo dispositivo';
z.string.it.conversationDeviceNewDeviceMany = ' nuovi dispositivi';
z.string.it.conversationDeviceNewPeopleJoinedVerify = ' verifica i dispositivi';
z.string.it.conversationJustNow = 'Adesso';
z.string.it.conversationLocationLink = 'Apri mappa';
z.string.it.conversationMessageDelivered = 'Consegnato';
z.string.it.conversationRename = ' ha rinominato la conversazione';
z.string.it.conversationRenameYou = ' ha rinominato la conversazione';
z.string.it.conversationResume = 'Inizia una conversazione con {{users}}';
z.string.it.conversationPing = ' ha fatto un trillo';
z.string.it.conversationPingYou = ' ha fatto un trillo';
z.string.it.conversationToday = 'oggi';
z.string.it.conversationVoiceChannelDeactivate = ' ha chiamato';
z.string.it.conversationVoiceChannelDeactivateYou = ' ha chiamato';
z.string.it.conversationYesterday = 'Ieri';
z.string.it.conversationUnableToDecrypt1 = 'un messaggio da {{user}} non  stato ricevuto.';
z.string.it.conversationUnableToDecrypt2 = 'Lidentit dei dispositivi {{user}}s  cambiata. Messaggi non consegnati.';
z.string.it.conversationUnableToDecryptLink = 'Perch?';
z.string.it.conversationUnableToDecryptErrorMessage = 'Errore';
z.string.it.conversationUnableToDecryptResetSession = 'Resetta la sessione';
z.string.it.conversationMissedMessages = ' da un po di tempo che non utilizzi questo dispositivo. Alcuni messaggi potrebbero non apparire qui.';
z.string.it.conversationAssetDownloading = 'Download in corso';
z.string.it.conversationAssetUploadFailed = 'Caricamento fallito';
z.string.it.conversationPlaybackError = 'Impossibile riprodurre';
z.string.it.conversationContextMenuCopy = 'Copia';
z.string.it.conversationContextMenuEdit = 'Modifica';
z.string.it.conversationContextMenuDelete = 'Elimina per me';
z.string.it.conversationContextMenuDeleteEveryone = 'Elimina per tutti';
z.string.it.conversationContextMenuDownload = 'Scarica';
z.string.it.conversationContextMenuLike = 'Mi piace';
z.string.it.conversationContextMenuUnlike = 'Non mi piace pi';
z.string.it.conversationDeleteTimestamp = 'Cancellato il {{date}}';
z.string.it.conversationEditTimestamp = 'Modificato il {{date}}';
z.string.it.conversationLikesCaption = '{{number}} persone';
z.string.it.conversationSendPastedFile = 'Immagine incollata alle {{date}}';
z.string.it.conversationSomeone = 'Qualcuno';
z.string.it.conversationTweetAuthor = ' su Twitter';

z.string.it.groupCreationParticipantsPlaceholder = 'Cerca per nome';


z.string.it.collectionShowAll = 'Mostra tutti i {{number}}';
z.string.it.collectionSectionLinks = 'Link';
z.string.it.collectionSectionImages = 'Immagini';
z.string.it.collectionSectionFiles = 'Files';
z.string.it.collectionSectionAudio = 'Messaggi audio';

z.string.it.fullsearchPlaceholder = 'Cerca messaggi di testo';
z.string.it.fullsearchNoResults = 'Nessun risultato.';

z.string.it.archiveHeader = 'Archivia';

z.string.it.conversationsAllArchived = 'Tutto archiviato';
z.string.it.conversationsContacts = 'Contatti';
z.string.it.conversationsConnectionRequestMany = '{{number}} persone in attesa';
z.string.it.conversationsConnectionRequestOne = '1 persona in attesa';
z.string.it.conversationsEmptyConversation = 'Conversazione di gruppo';
z.string.it.conversationsNoConversations = 'Nessuna conversazione';
z.string.it.conversationsPopoverArchive = 'Archivia';
z.string.it.conversationsPopoverCancel = 'Annulla richiesta';
z.string.it.conversationsPopoverNotify = 'Riattiva audio';
z.string.it.conversationsPopoverSilence = 'Silenzia';
z.string.it.conversationsPopoverUnarchive = 'Disarchivia';

z.string.it.conversationsSecondaryLineEphemeralMessage = 'Ti ha inviato un messaggio';
z.string.it.conversationsSecondaryLinePeopleLeft = '{{number}} utenti hanno abbandonato';
z.string.it.conversationsSecondaryLinePersonLeft = '{{user}} ha abbandonato';
z.string.it.conversationsSecondaryLinePersonRemoved = '{{user}}  stato rimosso';
z.string.it.conversationsSecondaryLinePeopleAdded = '{{user}} persone sono state aggiunte';
z.string.it.conversationsSecondaryLinePersonAdded = '{{user}}  stato aggiunto';
z.string.it.conversationsSecondaryLinePersonAddedYou = '{{user}} ti ha aggiunto';
z.string.it.conversationsSecondaryLineRenamed = '{{user}} ha cambiato nome di conversazione';
z.string.it.conversationsSecondaryLineYouLeft = 'Hai abbandonato';
z.string.it.conversationsSecondaryLineYouWereRemoved = 'Sei stato rimosso';

z.string.it.takeoverSub = 'Rivendica il tuo username su Wire.';
z.string.it.takeoverLink = 'Ulteriori informazioni';
z.string.it.takeoverButtonChoose = 'Scegli il tuo';
z.string.it.takeoverButtonKeep = 'Tieni questo';

z.string.it.inviteMetaKeyMac = 'Cmd';
z.string.it.inviteMetaKeyPc = 'Ctrl';
z.string.it.inviteHeadline = 'Invita amici ad usare Wire';
z.string.it.inviteMessage = 'Sono su Wire, cerca {{username}} o visita get.wire.com.';
z.string.it.inviteMessageNoEmail = 'Sono su Wire. Visita get.wire.com per connetterti con me.';

z.string.it.extensionsBubbleButtonGif = 'Gif';

z.string.it.extensionsGiphyButtonOk = 'Invia';
z.string.it.extensionsGiphyButtonMore = 'Prova un altro';
z.string.it.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.it.extensionsGiphyNoGifs = 'Oops, nessuna gif';
z.string.it.extensionsGiphyRandom = 'Scelta casuale';

z.string.it.addParticipantsConfirmLabel = 'Aggiungi';
z.string.it.addParticipantsSearchPlaceholder = 'Cerca per nome';
z.string.it.addParticipantsTabsPeople = 'Persone';
z.string.it.addParticipantsTabsServices = 'Servizi';

z.string.it.conversationDetailsActionArchive = 'Archivia';
z.string.it.conversationDetailsActionCancelRequest = 'Annulla richiesta';
z.string.it.conversationDetailsActionDevices = 'Dispositivi';
z.string.it.conversationDetailsActionNotifications = 'Notifiche';
z.string.it.conversationDetailsGuestsOff = 'Off';
z.string.it.conversationDetailsOptions = 'Opzioni';
z.string.it.conversationDetailsParticipantsServicesMany = 'Servizi';
z.string.it.conversationDetailsParticipantsUsersMany = 'Persone';
z.string.it.conversationDetailsPeople = 'Persone';
z.string.it.conversationDetailsServices = 'Servizi';

z.string.it.conversationParticipantsTitle = 'Persone';
z.string.it.conversationParticipantsSearchPlaceholder = 'Cerca per nome';

z.string.it.groupParticipantActionCancelRequest = 'Annulla richiesta';
z.string.it.groupParticipantActionDevices = 'Dispositivi';
z.string.it.groupParticipantActionPending = 'In sospeso';
z.string.it.groupParticipantActionSendRequest = 'Connetti';

z.string.it.notificationSettingsTitle = 'Notifiche';

z.string.it.participantDevicesDetailHeadline = 'Verifica che questo corrisponda allimpronta digitale sul {{html1}}dispositivo di {{user}}{{html2}}.';
z.string.it.participantDevicesDetailHowTo = 'Come si fa?';
z.string.it.participantDevicesDetailResetSession = 'Resetta la sessione';
z.string.it.participantDevicesDetailShowMyDevice = 'Visualizza impronta digitale del dispositivo';
z.string.it.participantDevicesDetailVerify = 'Verificato';

z.string.it.participantDevicesHeader = 'Dispositivi';
z.string.it.participantDevicesHeadline = 'Wire d unimpronta unica a ogni dispositivo. Confrontale con {{user}} e verifica la tua conversazione.';
z.string.it.participantDevicesLearnMore = 'Ulteriori informazioni';
z.string.it.participantDevicesWhyVerify = 'Perch verificare le conversazioni?';
z.string.it.participantDevicesOutdatedClientMessage = '{{user}} sta utilizzando una vecchia versione di Wire. Nessun dispositivo da visualizzare qui.';

z.string.it.participantDevicesSelfAllDevices = 'Mostra tutti i miei dispositivi';
z.string.it.participantDevicesSelfFingerprint = 'Impronta digitale dispositivo';

z.string.it.userProfileButtonConnect = 'Connetti';
z.string.it.userProfileButtonIgnore = 'Ignora';
z.string.it.userProfileButtonUnblock = 'Sblocca';

z.string.it.preferencesAbout = 'Info';
z.string.it.preferencesAccount = 'Account';
z.string.it.preferencesAV = 'Audio / Video';
z.string.it.preferencesDeviceDetails = 'Dettagli sul dispositivo';
z.string.it.preferencesDevices = 'Dispositivi';
z.string.it.preferencesHeadline = 'Preferenze';
z.string.it.preferencesOptions = 'Opzioni';

z.string.it.preferencesAboutPrivacyPolicy = 'Normativa sulla privacy';
z.string.it.preferencesAboutSupport = 'Supporto';
z.string.it.preferencesAboutSupportWebsite = 'Sito di assistenza';
z.string.it.preferencesAboutSupportContact = 'Contatta il supporto';
z.string.it.preferencesAboutTermsOfUse = 'Termini duso';
z.string.it.preferencesAboutVersion = 'Versione {{version}}';
z.string.it.preferencesAboutWebsite = 'Sito di Wire';

z.string.it.preferencesAccountCreateTeam = 'Crea un team';
z.string.it.preferencesAccountDelete = 'Elimina account';
z.string.it.preferencesAccountLogOut = 'Logout';
z.string.it.preferencesAccountManageTeam = 'Gestione Team';
z.string.it.preferencesAccountResetPassword = 'Reimposta la password';
z.string.it.preferencesAccountTeam = 'in {{name}}';
z.string.it.preferencesAccountUsernamePlaceholder = 'Il tuo nome e cognome';
z.string.it.preferencesAccountUsernameHint = 'Almeno 2 caratteri. a-z, 0-9 e solo _.';
z.string.it.preferencesAccountUsernameAvailable = 'Disponibile';
z.string.it.preferencesAccountUsernameErrorTaken = 'E gi stato scelto';

z.string.it.preferencesAVCamera = 'Fotocamera';
z.string.it.preferencesAVMicrophone = 'Microfono';
z.string.it.preferencesAVPermissionDetail = 'Attiva dalle tue preferenze di browser';
z.string.it.preferencesAVSpeakers = 'Altoparlanti';

z.string.it.preferencesDevicesActivatedOn = 'Attivato il {{date}}';
z.string.it.preferencesDevicesActive = 'Attivi';
z.string.it.preferencesDevicesActiveDetail = 'Se non riconosci un dispositivo qui sopra, rimuovilo e reimposta la password.';
z.string.it.preferencesDevicesCurrent = 'Attuale';
z.string.it.preferencesDevicesFingerprint = 'Impronta digitale della chiave';
z.string.it.preferencesDevicesFingerprintDetail = 'Wire d un impronta digitale unica a ogni dispositivo. Confrontale per verificare i tuoi dispositivi e le conversazioni.';
z.string.it.preferencesDevicesId = 'ID: ';
z.string.it.preferencesDevicesRemoveCancel = 'Annulla';
z.string.it.preferencesDevicesRemoveDetail = 'RimuovI questo dispositivo se hai smesso di usarlo. Verrai disconnesso immediatamente.';
z.string.it.preferencesDevicesSessionConfirmation = 'La sessione  stata resettata.';
z.string.it.preferencesDevicesSessionDetail = 'Se le impronte digitali non corrispondono,  necessario resettare la sessione per generare nuove chiavi di crittografia da entrambe le parti.';
z.string.it.preferencesDevicesSessionReset = 'Resetta la sessione';
z.string.it.preferencesDevicesSessionOngoing = 'Resettando la sessione';
z.string.it.preferencesDevicesVerification = 'Verificato';

z.string.it.preferencesOptionsAudio = 'Suoni notifiche';
z.string.it.preferencesOptionsAudioAll = 'Tutti';
z.string.it.preferencesOptionsAudioAllDetail = 'Tutti i suoni';
z.string.it.preferencesOptionsAudioNone = 'Nessuno';
z.string.it.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.it.preferencesOptionsAudioSome = 'Alcuni';
z.string.it.preferencesOptionsAudioSomeDetail = 'Trilli e chiamate';
z.string.it.preferencesOptionsContacts = 'Contatti';
z.string.it.preferencesOptionsContactsGmail = 'Importa da Gmail';
z.string.it.preferencesOptionsContactsMacos = 'Importa dalla rubrica';
z.string.it.preferencesOptionsContactsDetail = 'Utilizziamo i dati del tuo contatto per connetterti con gli altri. Rendiamo anonime tutte le informazioni e non le condividiamo con nessuno.';
z.string.it.preferencesOptionsPopular = 'A grande richiesta';
z.string.it.preferencesOptionsEmojiReplaceCheckbox = 'Sostituire il tipo emoticon con Emoji';
z.string.it.preferencesOptionsPreviewsSendCheckbox = 'Genera anteprime per i link inviati da te';
z.string.it.preferencesOptionsPreviewsSendDetail = ' possibile che vengano comunque mostrate delle anteprime per i link inviati dagli altri utenti.';
z.string.it.preferencesOptionsNotifications = 'Notifiche';
z.string.it.preferencesOptionsNotificationsNone = 'Off';
z.string.it.preferencesOptionsNotificationsObfuscate = 'Nascondi dettagli';
z.string.it.preferencesOptionsNotificationsObfuscateMessage = 'Mostra mittente';
z.string.it.preferencesOptionsNotificationsOn = 'Mostra mittente e messaggio';

z.string.it.backupCancel = 'Annulla';

z.string.it.searchConnect = 'Connetti';
z.string.it.searchConnections = 'Connessioni';
z.string.it.searchContacts = 'Contatti';
z.string.it.searchCreateGroup = 'Crea gruppo';
z.string.it.searchGroups = 'Gruppi';
z.string.it.searchPeople = 'Persone';
z.string.it.searchPlaceholder = 'Ricerca per nome o username';
z.string.it.searchServicePlaceholder = 'Cerca per nome';
z.string.it.searchServices = 'Servizi';
z.string.it.searchTeamGroups = 'Conversazioni di Team';
z.string.it.searchTeamMembers = 'Membri del team';
z.string.it.searchTopPeople = 'Contattati frequenti';
z.string.it.searchTrySearch = 'Trova le persone per nome o username';
z.string.it.searchNoContactsOnWire = 'Non hai nessun contatto su Wire. Prova a trovare persone per nome o username.';
z.string.it.searchOthers = 'Connetti';

z.string.it.searchInvite = 'Invita amici ad usare Wire';
z.string.it.searchInviteDetail = 'Condividere i contatti dalla rubrica ti aiuta a connetterti con gli altri. Rendiamo tutte le informazioni dei contatti anonime e non sono cedute a nessun altro.';
z.string.it.searchInviteButtonContacts = 'Dalla rubrica';
z.string.it.searchInviteButtonGmail = 'Da Gmail';
z.string.it.searchInviteHeadline = 'Invita i tuoi amici';
z.string.it.searchInviteShare = 'Condividi contatti';

z.string.it.searchListEveryoneParticipates = 'Tutte le persone a cui sei connesso sono gi in questa conversazione.';
z.string.it.searchListNoMatches = 'Nessun risultato corrispondente. Provare ad inserire un nome diverso.';


z.string.it.uploadGoogleHeadline = 'Trova persone con cui parlare.';
z.string.it.uploadGoogleMessage = 'Utilizziamo i dati del tuo contatto per connetterti con gli altri. Rendiamo anonime tutte le informazioni e non le condividiamo con nessuno.';

z.string.it.warningCallUnsupportedIncoming = '{{user}} sta chiamando. Il tuo browser non supporta le chiamate.';
z.string.it.warningCallUnsupportedOutgoing = 'Non puoi chiamare perch il tuo browser non supporta le chiamate.';
z.string.it.warningCallIssues = 'Questa versione di Wire non pu partecipare alla chiamata. Per favore usa';
z.string.it.warningCallUpgradeBrowser = 'Per chiamare, per favore aggiorna Google Chrome.';
z.string.it.warningConnectivityConnectionLost = 'Tentativo di connessione. Wire non  in grado di consegnare i messaggi.';
z.string.it.warningConnectivityNoInternet = 'Nessuna connessione. Non sarai in grado di inviare o ricevere messaggi.';
z.string.it.warningLearnMore = 'Ulteriori informazioni';
z.string.it.warningLifecycleUpdate = 'Una nuova versione di Wire  disponibile.';
z.string.it.warningLifecycleUpdateNotes = 'Novit';
z.string.it.warningLifecycleUpdateLink = 'Aggiorna Ora';
z.string.it.warningNotFoundCamera = 'Non puoi chiamare perch il tuo computer non ha una webcam.';
z.string.it.warningNotFoundMicrophone = 'Non puoi chiamare perch il tuo computer non ha un microfono.';
z.string.it.warningPermissionDeniedCamera = 'Non puoi chiamare perch il tuo browser non ha accesso alla webcam.';
z.string.it.warningPermissionDeniedMicrophone = 'Non puoi chiamare perch il tuo browser non ha accesso al microfono.';
z.string.it.warningPermissionDeniedScreen = 'Il browser richiede lautorizzazione per condividere il tuo schermo.';
z.string.it.warningPermissionRequestCamera = '{{icon}} Consenti accesso alla webcam';
z.string.it.warningPermissionRequestMicrophone = '{{icon}} Consenti accesso al microfono';
z.string.it.warningPermissionRequestNotification = '{{icon}} Consenti notifiche';
z.string.it.warningPermissionRequestScreen = '{{icon}} Consenti accesso allo schermo';

z.string.it.userAvailabilityAvailable = 'Disponibile';
z.string.it.userAvailabilityNone = 'Nessuno';

z.string.it.notificationAssetAdd = 'Ha condiviso unimmagine';
z.string.it.notificationConnectionAccepted = 'Ha accettato la tua richiesta di connessione';
z.string.it.notificationConnectionConnected = 'Siete connessi ora';
z.string.it.notificationConnectionRequest = 'Vuole connettersi';
z.string.it.notificationConversationCreate = '{{user}} ha iniziato una conversazione';
z.string.it.notificationConversationRename = '{{user}} ha rinominato la conversazione in {{name}}';
z.string.it.notificationMemberJoinMany = '{{user}} ha aggiunto {{number}} persone alla conversazione';
z.string.it.notificationMemberJoinOne = '{{user1}} ha aggiunto {{user2}} alla conversazione';
z.string.it.notificationMemberLeaveRemovedYou = '{{user}} ti ha rimosso da una conversazione';
z.string.it.notificationObfuscated = 'Ti ha inviato un messaggio';
z.string.it.notificationObfuscatedTitle = 'Qualcuno';
z.string.it.notificationPing = 'Ha fatto un trillo';
z.string.it.notificationReaction = '{{reaction}} il tuo messaggio';
z.string.it.notificationSharedAudio = 'Ha condiviso un messaggio vocale';
z.string.it.notificationSharedFile = 'Ha condiviso un file';
z.string.it.notificationSharedLocation = 'Ha condiviso una posizione';
z.string.it.notificationSharedVideo = 'Ha condiviso un video';
z.string.it.notificationVoiceChannelActivate = 'Chiamata in corso';
z.string.it.notificationVoiceChannelDeactivate = 'Ha chamato';

z.string.it.tooltipConversationAllVerified = 'Tutte le impronte digitali sono state verificate';
z.string.it.tooltipConversationCall = 'Chiama';
z.string.it.tooltipConversationEphemeral = 'Messaggio a tempo';
z.string.it.tooltipConversationFile = 'Aggiungi file';
z.string.it.tooltipConversationInputPlaceholder = 'Digita un messaggio';
z.string.it.tooltipConversationPeople = 'Persone ({{shortcut}})';
z.string.it.tooltipConversationPicture = 'Aggiungi immagine';
z.string.it.tooltipConversationPing = 'Trillo ({{shortcut}})';
z.string.it.tooltipConversationSearch = 'Cerca';
z.string.it.tooltipConversationVideoCall = 'Videochiama';

z.string.it.tooltipConversationsArchive = 'Archivio ({{shortcut}})';
z.string.it.tooltipConversationsArchived = 'Mostra archivio ({{number}})';
z.string.it.tooltipConversationsMore = 'Altro';
z.string.it.tooltipConversationsNotify = 'Riattiva audio ({{shortcut}})';
z.string.it.tooltipConversationsPreferences = 'Apri le preferenze';
z.string.it.tooltipConversationsSilence = 'Silenzia ({{shortcut}})';
z.string.it.tooltipConversationsStart = 'Avviare conversazione ({{shortcut}})';

z.string.it.tooltipConversationDetailsRename = 'Cambia il nome della conversazione';

z.string.it.tooltipPreferencesContactsGmail = 'Accedi al tuo account Gmail per condividere i contatti';
z.string.it.tooltipPreferencesContactsMacos = 'Condividi tutti i tuoi contatti dallapp Contatti di macOS';
z.string.it.tooltipPreferencesPassword = 'Apri un altro sito per reimpostare la password';
z.string.it.tooltipPreferencesPicture = 'Cambia la tua foto';
z.string.it.tooltipPreferencesRename = 'Cambia il tuo nome';

z.string.it.tooltipSearchClose = 'Chiudi (Esc)';

z.string.it.initReceivedSelfUser = 'Ciao, {{user}}.';
z.string.it.initValidatedClient = 'Caricamento delle tue connessioni e conversazioni';
z.string.it.initReceivedUserData = 'Controllo nuovi messaggi';
z.string.it.initDecryption = 'Decriptare i messaggi';
z.string.it.initEvents = 'Caricamento messaggi';

z.string.it.ephemeralUnitsNone = 'Off';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.lt.wire = 'Wire';
z.string.lt.wireMacos = 'Wire, skirta macOS';
z.string.lt.wireWindows = 'Wire, skirta Windows';
z.string.lt.wireLinux = 'Wire, skirta Linux';
z.string.lt.nonexistentUser = 'Itrintas naudotojas';
z.string.lt.and = 'ir';
z.string.lt.enumerationAnd = ', ir ';

//=keliama
z.string.lt.authAccountCountryCode = 'alies kodas';
z.string.lt.authAccountPasswordForgot = 'Pamirau slaptaod';
z.string.lt.authAccountPublicComputer = 'Tai yra vieas kompiuteris';
z.string.lt.authAccountSignIn = 'Prisijungti';
z.string.lt.authAccountSignInPhone = 'Telefonas';

z.string.lt.authBlockedCookies = 'Aktyvuokite slapukus, kad galtumte prisijungti prie Wire.';
z.string.lt.authBlockedDatabase = 'Norint rodyti inutes, Wire reikia prieigos prie js vietins saugyklos. Vietin saugykla nra prieinama privaioje veiksenoje.';
z.string.lt.authBlockedTabs = 'Wire jau yra atverta kitoje kortelje.';
z.string.lt.authBlockedTabsAction = 'Naudoti i kortel';

z.string.lt.authVerifyAccountAdd = 'Pridti';
z.string.lt.authVerifyAccountDetail = 'Tai leidia jums naudoti Wire keliuose renginiuose.';
z.string.lt.authVerifyAccountHeadline = 'Pridkite el. pato adres ir slaptaod.';
z.string.lt.authVerifyAccountLogout = 'Atsijungti';
z.string.lt.authVerifyCodeDescription = 'veskite patvirtinimo kod,\nkur mes isiuntme  {{number}}.';
z.string.lt.authVerifyCodeResend = 'Negaunate kodo?';
z.string.lt.authVerifyCodeResendDetail = 'Sisti i naujo';
z.string.lt.authVerifyCodeResendTimer = 'Js galite uklausti nauj kod {{expiration}}.';
z.string.lt.authVerifyCodeChangePhone = 'Pakeisti telefono numer';
z.string.lt.authVerifyPasswordHeadline = 'veskite savo slaptaod';

z.string.lt.authLimitDevicesHeadline = 'renginiai';
z.string.lt.authLimitDescription = 'Nordami pradti naudoti Wire iame renginyje, paalinkite vien i savo kit rengini.';
z.string.lt.authLimitButtonManage = 'Tvarkyti renginius';
z.string.lt.authLimitButtonSignOut = 'Atsijungti';
z.string.lt.authLimitDevicesCurrent = '(Esamas)';

z.string.lt.authHistoryHeadline = 'Pirm kart naudojate Wire iame renginyje.';
z.string.lt.authHistoryDescription = 'Privatumo sumetimais, js pokalbio istorija ia nebus rodoma.';
z.string.lt.authHistoryReuseHeadline = 'Naudojote Wire iame renginyje.';
z.string.lt.authHistoryReuseDescription = 'Per t laikotarp isistos inuts, ia nebus rodomos.';
z.string.lt.authHistoryButton = 'GERAI';

z.string.lt.authPostedResend = 'Sisti i naujo  {{email}}';
z.string.lt.authPostedResendAction = 'Negaunate el. laiko?';
z.string.lt.authPostedResendDetail = 'Patikrinkite savo el. pat ir sekite nurodymus.';
z.string.lt.authPostedResendHeadline = 'Js gavote laik.';

z.string.lt.authPlaceholderEmail = 'El. patas';
z.string.lt.authPlaceholderPasswordPut = 'Slaptaodis';
z.string.lt.authPlaceholderPasswordSet = 'Slaptaodis (bent 8 simboliai)';
z.string.lt.authPlaceholderPhone = 'Telefono numeris';

z.string.lt.authErrorCode = 'Neteisingas kodas';
z.string.lt.authErrorCountryCodeInvalid = 'Neteisingas alies kodas';
z.string.lt.authErrorEmailExists = 'El. pato adresas jau uimtas';
z.string.lt.authErrorEmailForbidden = 'Atleiskite. is el. pato adresas yra udraustas.';
z.string.lt.authErrorEmailMalformed = 'veskite taisykling el. pato adres.';
z.string.lt.authErrorEmailMissing = 'raykite el. pato adres.';
z.string.lt.authErrorMisc = 'Problemos su ryiu. Banbykite dar kart.';
z.string.lt.authErrorNameShort = 'veskite bent 2 simboli vard';
z.string.lt.authErrorOffline = 'Nra interneto ryio';
z.string.lt.authErrorPasswordShort = 'Pasirinkite bent 8 simboli slaptaod.';
z.string.lt.authErrorPasswordWrong = 'Neteisingas slaptaodis. Bandykite dar kart.';
z.string.lt.authErrorPending = 'Paskyra dar nepatvirtinta';
z.string.lt.authErrorPhoneNumberBudget = 'Js prisijungte pernelyg danai. Pabandykite vliau dar kart.';
z.string.lt.authErrorPhoneNumberForbidden = 'Atleiskite. is telefono numeris yra udraustas.';
z.string.lt.authErrorPhoneNumberInvalid = 'Neteisingas telefono numeris';
z.string.lt.authErrorPhoneNumberUnknown = 'Neinomas telefono numeris';
z.string.lt.authErrorSuspended = 'i paskyra daugiau nebeturi galiojim prisijungti.';
z.string.lt.authErrorSignIn = 'Patvirtinkite savo duomenis ir bandykite dar kart.';

z.string.lt.callStateOutgoing = 'Kvieiama';
z.string.lt.callStateConnecting = 'Sujungiama';
z.string.lt.callStateIncoming = 'Skambinama';
z.string.lt.callStateIncomingGroup = '{{user}} jums skambina';
z.string.lt.callDecline = 'Atmesti';
z.string.lt.callAccept = 'Priimti';
z.string.lt.callJoin = 'Prisijungti';
z.string.lt.callChooseSharedScreen = 'Pasirinkite ekran, kur bendrinti';
z.string.lt.callParticipants = '{{number}} kalba';
z.string.lt.callNoCameraAccess = 'Nra galimybs naudotis kamera';

z.string.lt.videoCallOverlayFitVideoLabel = 'Spustelkite dukart ir vaizdas bus talpintas arba upildytas';
z.string.lt.videoCallOverlayConversations = 'Susirainjimai';
z.string.lt.videoCallOverlayMute = 'Ijungti susirainjimo praneimus';
z.string.lt.videoCallOverlayVideo = 'Vaizdas';
z.string.lt.videoCallOverlayShareScreen = 'Sisti ekrano vaizd';
z.string.lt.videoCallOverlayHangUp = 'Ubaigti';
z.string.lt.videoCallPaused = 'Vaizdas pristabdytas';
z.string.lt.videoCallScreenShareNotSupported = 'i narykle nepalaiko ekrano rodymo';

z.string.lt.modalAcknowledgeAction = 'Gerai';
z.string.lt.modalAcknowledgeHeadline = 'Kakas nutiko';
z.string.lt.modalConfirmSecondary = 'Atsisakyti';
z.string.lt.modalOptionSecondary = 'Atsisakyti';

z.string.lt.modalAccountCreateAction = 'GERAI';
z.string.lt.modalAccountCreateHeadline = 'Kurti abonement?';
z.string.lt.modalAccountCreateMessage = 'Sukr paskyr prarasite bendravimo praeit iame svei kambaryje.';

z.string.lt.modalAccountDeletionAction = 'Itrinti';
z.string.lt.modalAccountDeletionHeadline = 'Itrinti paskyr';
z.string.lt.modalAccountDeletionMessage = 'Mes isisime jums praneim el. patu arba SMS inute. Pereikite nuorodos adresu, kad visiems laikams itrintumte savo paskyr.';

z.string.lt.modalAccountLeaveGuestRoomAction = 'Ieiti';
z.string.lt.modalAccountLeaveGuestRoomHeadline = 'Ieiti i svei kambario?';
z.string.lt.modalAccountLeaveGuestRoomMessage = 'Bendravimo praeitis bus itrinta. Nordami isaugoti, kit kart susikurkite paskyr.';

z.string.lt.modalAccountLogoutAction = 'Atsijungti';
z.string.lt.modalAccountLogoutHeadline = 'Ivalyti duomenis?';
z.string.lt.modalAccountLogoutOption = 'Itrinti vis js asmenin informacij ir pokalbius iame renginyje.';

z.string.lt.modalAccountNewDevicesSecondary = 'Tvarkyti renginius';
z.string.lt.modalAccountNewDevicesHeadline = 'Js paskyra buvo naudota:';
z.string.lt.modalAccountNewDevicesFrom = 'I:';
z.string.lt.modalAccountNewDevicesMessage = 'Jeigu js to nedarte, paalinkite rengin ir atstatykite savo slaptaod.';

z.string.lt.modalAccountRemoveDeviceAction = 'alinti rengin';
z.string.lt.modalAccountRemoveDeviceHeadline = 'alinti "{{device}}"';
z.string.lt.modalAccountRemoveDeviceMessage = 'Norint paalinti rengin, reikalingas js slaptaodis.';
z.string.lt.modalAccountRemoveDevicePlaceholder = 'Slaptaodis';

z.string.lt.modalAssetTooLargeHeadline = 'Failas per didelis';
z.string.lt.modalAssetTooLargeMessage = 'Js galite sisti failus iki {{number}}';

z.string.lt.modalAssetParallelUploadsHeadline = 'Per daug fail vienu metu';
z.string.lt.modalAssetParallelUploadsMessage = 'Js vienu metu galite sisti iki {{number}} fail.';

z.string.lt.modalCallEmptyConversationHeadline = 'Nra kam skambinti';
z.string.lt.modalCallEmptyConversationMessage = 'ia daugiau nieko nra.';

z.string.lt.modalCallEmptyLogHeadline = 'Skambui nebuvo';
z.string.lt.modalCallEmptyLogMessage = 'Nebuvo skambui, pagal kuriuos galtume sugeneruoti ataskait.';

z.string.lt.modalCallNoGroupVideoHeadline = 'Vaizdo skambuiai grupse nepalaikomi';
z.string.lt.modalCallNoGroupVideoMessage = 'Vaizdo skambuiai grups pokalbiuose yra neprieinami.';

z.string.lt.modalCallNoMicrophoneAction = 'Paaikinkite kaip';
z.string.lt.modalCallNoMicrophoneMessage = 'Norint skambinti, js naryklei reikia prieigos prie js mikrofono.';
z.string.lt.modalCallNoMicrophoneHeadline = 'Nepavyksta skambinti be mikrofono';

z.string.lt.modalCallSecondIncomingAction = 'Atsiliepti';
z.string.lt.modalCallSecondIncomingHeadline = 'Atsiliepti  skambut?';
z.string.lt.modalCallSecondIncomingMessage = 'Js dabartinis skambutis bus ubaigtas.';

z.string.lt.modalCallSecondOngoingAction = 'Ubaigti';
z.string.lt.modalCallSecondOngoingHeadline = 'Ubaigti skambut kitame renginyje?';
z.string.lt.modalCallSecondOngoingMessage = 'Js vienu metu galite dalyvauti tik viename skambutyje.';

z.string.lt.modalCallSecondOutgoingAction = 'Ubaigti';
z.string.lt.modalCallSecondOutgoingHeadline = 'Ubaigti esam skambut?';
z.string.lt.modalCallSecondOutgoingMessage = 'Js vienu metu galite dalyvauti tik viename skambutyje.';

z.string.lt.modalConnectCancelAction = 'Taip';
z.string.lt.modalConnectCancelHeadline = 'Atsisakyti uklausos?';
z.string.lt.modalConnectCancelMessage = 'alinti kontakto umezgimo su {{user}} uklaus.';
z.string.lt.modalConnectCancelSecondary = 'Ne';

z.string.lt.modalConnectAcceptAction = 'Umegzti kontakt';
z.string.lt.modalConnectAcceptHeadline = 'Priimti?';
z.string.lt.modalConnectAcceptMessage = 'Tai umegs kontakt ir atvers pokalb su {{user}}.';
z.string.lt.modalConnectAcceptSecondary = 'Nepaisyti';

z.string.lt.modalConversationClearAction = 'Itrinti';
z.string.lt.modalConversationClearHeadline = 'Itrinti turin?';
z.string.lt.modalConversationClearMessage = 'Tai ivalys bendravimo praeit visuose js renginiuose.';
z.string.lt.modalConversationClearOption = 'Taip pat ieiti i pokalbio';

z.string.lt.modalConversationDeleteMessageAction = 'Itrinti';
z.string.lt.modalConversationDeleteMessageHeadline = 'Itrinti tik man?';
z.string.lt.modalConversationDeleteMessageMessage = 'To negalima bus ataukti.';

z.string.lt.modalConversationDeleteMessageEveryoneAction = 'Itrinti';
z.string.lt.modalConversationDeleteMessageEveryoneHeadline = 'Itrinti visiems?';
z.string.lt.modalConversationDeleteMessageEveryoneMessage = 'To negalima bus ataukti.';

z.string.lt.modalConversationLeaveAction = 'Ieiti';
z.string.lt.modalConversationLeaveHeadline = 'Ieiti i susirainjimo {{name}}?';
z.string.lt.modalConversationLeaveMessage = 'Js daugiau nebegalsite gauti ar sisti inutes iame pokalbyje.';

z.string.lt.modalConversationMessageTooLongHeadline = 'inut pernelyg ilga';
z.string.lt.modalConversationMessageTooLongMessage = 'Js galite sisti inutes iki {{number}} simboli ilgio.';

z.string.lt.modalConversationNewDeviceAction = 'Vis tiek sisti';
z.string.lt.modalConversationNewDeviceHeadlineOne = '{{user}} pradjo naudoti nauj rengin';
z.string.lt.modalConversationNewDeviceHeadlineMany = '{{user}}s pradjo naudoti naujus renginius';
z.string.lt.modalConversationNewDeviceHeadlineYou = '{{user}} pradjo naudoti nauj rengin';
z.string.lt.modalConversationNewDeviceIncomingCallAction = 'Priimti skambut';
z.string.lt.modalConversationNewDeviceIncomingCallMessage = 'Ar vis dar norite priimti skambut?';
z.string.lt.modalConversationNewDeviceMessage = 'Ar vis dar norite isisti savo inutes?';
z.string.lt.modalConversationNewDeviceOutgoingCallAction = 'Vis tiek skambinti';
z.string.lt.modalConversationNewDeviceOutgoingCallMessage = 'Ar vis dar norite atlikti skambut?';

z.string.lt.modalConversationNotConnectedHeadline = 'Susirainjime nieko nra';
z.string.lt.modalConversationNotConnectedMessageOne = '{{name}} nenori bti susirainjimuose.';
z.string.lt.modalConversationNotConnectedMessageMany = 'Vienas i pasirinkt moni nenori bti susirainjimuose.';

z.string.lt.modalConversationRemoveAction = 'alinti';
z.string.lt.modalConversationRemoveHeadline = 'alinti?';
z.string.lt.modalConversationRemoveMessage = '{{user}} negals sisti ir gauti inutes iame pokalbyje.';

z.string.lt.modalConversationRemoveGuestsAction = 'Paalinti sveius';
z.string.lt.modalConversationRemoveGuestsHeadline = 'Ijungiate prisijungim sveiams?';
z.string.lt.modalConversationRemoveGuestsMessage = 'Dabartiniai sveiai bus paalinti i susirainjimo. Nauji sveiai prisijungi negals.';

z.string.lt.modalConversationRevokeLinkAction = 'Naikinti nuorod';
z.string.lt.modalConversationRevokeLinkHeadline = 'Panaikinti nuorod?';
z.string.lt.modalConversationRevokeLinkMessage = 'Nauji sveiai negals prisijungti spustelj nuorod. Dabartiniai sveiai liks prisijung.';

z.string.lt.modalConversationGuestOptionsAllowGuestMessage = 'Nepavyko leisti svei. Pabandykite dar kart.';
z.string.lt.modalConversationGuestOptionsDisableGuestMessage = 'Nepavyko paalinti svei. Pabandykite dar kart.';
z.string.lt.modalConversationGuestOptionsGetCodeMessage = 'Nepavyko gauti prisijungimo nuorodos.';
z.string.lt.modalConversationGuestOptionsRequestCodeMessage = 'Nepavyko gauti prisijungimo nuorodos. Pabandykite dar kart.';
z.string.lt.modalConversationGuestOptionsRevokeCodeMessage = 'Nepavyko panaikinti nuorodos. Bandykite dar kart.';
z.string.lt.modalConversationGuestOptionsToggleGuestsMessage = 'Nepavyko pakeisti sveio bsenos.';

z.string.lt.modalConversationTooManyMembersHeadline = 'Balso kanalas perpildytas';
z.string.lt.modalConversationTooManyMembersMessage = 'Prie pokalbio gali prisijungti iki {{number1}} moni. iuo metu yra vietos tik dar {{number2}} monms.';

z.string.lt.modalGifTooLargeHeadline = 'Pasirinkta animacija per didel';
z.string.lt.modalGifTooLargeMessage = 'Didiausias dydis yra {{number}} MB.';

z.string.lt.modalIntegrationUnavailableHeadline = 'iuo metu robotai negalimi';
z.string.lt.modalIntegrationUnavailableMessage = 'Dkojame, kad domits robotais. Paslauga iuo metu yra pristabdyta tol, kol mes ruoiame kit versij. Sekite naujienas.';

z.string.lt.modalPictureFileFormatHeadline = 'Negalite naudoti io paveiksllio';
z.string.lt.modalPictureFileFormatMessage = 'Pasirinkite PNG arba JPEG fail.';

z.string.lt.modalPictureTooLargeHeadline = 'Pasirinktas paveiksllis per didelis';
z.string.lt.modalPictureTooLargeMessage = 'Galite naudoti iki {{number}} MB dydio paveiksll.';

z.string.lt.modalPictureTooSmallHeadline = 'Paveiksllis per maas';
z.string.lt.modalPictureTooSmallMessage = 'Pasirinkite bent 320 x 320 px dydio paveiksll.';

z.string.lt.modalImproveWireAction = 'Priimti';
z.string.lt.modalImproveWireSecondary = 'Ne dabar';
z.string.lt.modalImproveWireHeadline = 'Pagerinkite Wire';
z.string.lt.modalImproveWireMessage = 'Sisdami anonimin naudojimosi ir triki ataskait padedate mums pagerinti produktus ir paslaugas. ios informacijos daugiau niekur nenaudojame.';

z.string.lt.modalServiceUnavailableHeadline = 'Paslaugos pridjimas negalimas';
z.string.lt.modalServiceUnavailableMessage = 'Paslauga iuo metu negalima.';

z.string.lt.modalSessionResetHeadline = 'Seansas buvo atstatytas';
z.string.lt.modalSessionResetMessage1 = 'Jeigu problema neisprsta,';
z.string.lt.modalSessionResetMessageLink = 'susisiekite';
z.string.lt.modalSessionResetMessage2 = 'su mumis.';

z.string.lt.modalUploadContactsAction = 'Bandyti dar kart';
z.string.lt.modalUploadContactsMessage = 'Mes negavome js informacijos. Bandykite importuoti savo kontaktus dar kart.';

z.string.lt.modalUserBlockAction = 'Ublokuoti';
z.string.lt.modalUserBlockHeadline = 'Ublokuoti {{user}}?';
z.string.lt.modalUserBlockMessage = '{{user}} negals su jumis susisiekti ar pridti jus  grups pokalbius.';

z.string.lt.modalUserUnblockAction = 'Atblokuoti';
z.string.lt.modalUserUnblockHeadline = 'Atblokuoti?';
z.string.lt.modalUserUnblockMessage = '{{user}} gals ir vl su jumis susisiekti ar pridti jus  grups pokalbius.';

z.string.lt.modalNoCameraTitle = 'Nra galimybs naudotis kamera';
z.string.lt.modalNoCameraMessage = 'Wire neturi galimybs prisijungti prie kameros.[br][faqLink]Perskaitykite  pagalbos straipsn[/faqLink] ir suinosite, kaip tai sutvarkyti.';

z.string.lt.connectionRequestConnect = 'Umegzti kontakt';
z.string.lt.connectionRequestIgnore = 'Nepaisyti';

z.string.lt.conversationGuestIndicator = 'Sveias';
z.string.lt.userRemainingTimeHours = 'Liko {{time}} val.';
z.string.lt.userRemainingTimeMinutes = 'Liko maiau nei {{time}} min.';

z.string.lt.conversationYouNominative = 'js';
z.string.lt.conversationYouDative = 'js';
z.string.lt.conversationYouAccusative = 'js';

z.string.lt.conversationConnectionAccepted = 'Kontaktas umegztas';
z.string.lt.conversationConnectionBlocked = 'Ublokuotas(-a)';
z.string.lt.conversationConnectionCancelRequest = 'Atsisakyti kontakto umezgimo uklausos';
z.string.lt.conversationCreateTemporary = 'Prisijungte prie susirainjimo';
z.string.lt.conversationCreateWith = 'su {{users}}';
z.string.lt.conversationDeviceStartedUsingOne = ' pradjo naudoti';
z.string.lt.conversationDeviceStartedUsingMany = ' pradjo naudoti';
z.string.lt.conversationDeviceUnverified = ' panaikinote patvirtinim vieno i';
z.string.lt.conversationDeviceYourDevices = ' savo rengini';
z.string.lt.conversationDeviceUserDevices = ' {{user}} rengini';
z.string.lt.conversationDeviceNewDeviceOne = ' nauj rengin';
z.string.lt.conversationDeviceNewDeviceMany = ' naujus renginius';
z.string.lt.conversationDeviceNewPeopleJoined = 'Prisijung nauji mons.';
z.string.lt.conversationDeviceNewPeopleJoinedVerify = ' patvirtinkite renginius';
z.string.lt.conversationJustNow = 'K tik';
z.string.lt.conversationLocationLink = 'Atverti emlap';
z.string.lt.conversationCreated = '[bold]{{name}}[/bold] pradjo susirainjim su {{users}}';
z.string.lt.conversationCreatedMore = '[bold]{{name}}[/bold] pradjo susirainjim su {{users}}, ir dar [showmore]{{count}} [/showmore]';
z.string.lt.conversationCreatedName = '[bold]{{name}}[/bold] pradjo susirainjim';
z.string.lt.conversationCreatedNameYou = '[bold]Js[/bold] pradjote susiranjim';
z.string.lt.conversationCreatedYou = 'Js pradjote susirainjim su {{users}}';
z.string.lt.conversationCreatedYouMore = 'Js pradjote susirainjim su {{users}}, ir dar [showmore]{{count}}[/showmore]';
z.string.lt.conversationCreateWithMore = 'su {{users}}, ir dar [showmore]{{count}}[/showmore]';
z.string.lt.conversationCreateTeam = 'su [showmore]visais, esaniais komandoje[/showmore]';
z.string.lt.conversationCreateTeamGuest = 'su [showmore]visais, esaniais komandoje ir sveiu[/showmore]';
z.string.lt.conversationCreateTeamGuests = 'su [showmore]visais, esaniais komandoje ir {{count}} sveiais[/showmore]';
z.string.lt.conversationMemberJoined = '[bold]{{name}}[/bold] pridjo {{users}} prie susirainjimo';
z.string.lt.conversationMemberJoinedYou = '[bold]Js[/bold] pridjote {{users}} prie susirainjimo';
z.string.lt.conversationMemberJoinedMore = '[bold]{{name}}[/bold] pridjo {{users}}, ir dar [showmore]{{count}}[/showmore] prie susirainjimo';
z.string.lt.conversationMemberJoinedYouMore = '[bold]Js[/bold] pridjote {{users}}, ir dar[showmore]{{count}}[/showmore] prie susirainjimo';
z.string.lt.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] prisijung';
z.string.lt.conversationMemberJoinedSelfYou = '[bold]Js[/bold] prisijungte';
z.string.lt.conversationMemberLeft = '[bold]{{name}}[/bold] ijo';
z.string.lt.conversationMemberLeftYou = '[bold]Js[/bold] ijote';
z.string.lt.conversationMemberRemoved = '[bold]{{name}}[/bold] paalino {{users}}';
z.string.lt.conversationMemberRemovedYou = '[bold]Js[/bold] paalinote {{users}}';
z.string.lt.conversationTeamLeft = '[bold]{{name}}[/bold] buvo paalintas (-a) i komandos';
z.string.lt.conversationMessageDelivered = 'Pristatyta';
z.string.lt.conversationRename = ' pervadino pokalb';
z.string.lt.conversationRenameYou = ' pervadino pokalb';
z.string.lt.conversationUpdatedTimer = ' nustat inut laikmat  {{time}}';
z.string.lt.conversationUpdatedTimerYou = ' nustatte inui laikmat  {{time}}';
z.string.lt.conversationResetTimer = ' ijung inut laikmat';
z.string.lt.conversationResetTimerYou = ' ijungte inui laikmat';
z.string.lt.conversationResume = 'Pradti pokalb su {{users}}';
z.string.lt.conversationPing = ' patikrino ry';
z.string.lt.conversationPingYou = ' patikrinote ry';
z.string.lt.conversationToday = 'iandien';
z.string.lt.conversationVoiceChannelDeactivate = ' skambino';
z.string.lt.conversationVoiceChannelDeactivateYou = ' skambino';
z.string.lt.conversationYesterday = 'Vakar';
z.string.lt.conversationUnableToDecrypt1 = 'inut nuo {{user}} nebuvo gauta.';
z.string.lt.conversationUnableToDecrypt2 = 'Pasikeit {{user}} renginio tapatyb. inut nepristatyta.';
z.string.lt.conversationUnableToDecryptLink = 'Kodl?';
z.string.lt.conversationUnableToDecryptErrorMessage = 'Klaida';
z.string.lt.conversationUnableToDecryptResetSession = 'Atstatyti seans';
z.string.lt.conversationMissedMessages = 'Js kur laik nenaudojote io renginio. Kai kurios inuts ia gali neatsirasti.';
z.string.lt.conversationAssetUploading = 'keliama';
z.string.lt.conversationAssetDownloading = 'Atsiuniama';
z.string.lt.conversationAssetUploadFailed = 'klimas nepavyko';
z.string.lt.conversationPlaybackError = 'Nepavyko atkurti';
z.string.lt.conversationContextMenuCopy = 'Kopijuoti';
z.string.lt.conversationContextMenuEdit = 'Taisyti';
z.string.lt.conversationContextMenuDelete = 'Itrinti man';
z.string.lt.conversationContextMenuDeleteEveryone = 'Itrinti visiems';
z.string.lt.conversationContextMenuDownload = 'Atsisisti';
z.string.lt.conversationContextMenuLike = 'Patinka';
z.string.lt.conversationContextMenuUnlike = 'Nebepatinka';
z.string.lt.conversationDeleteTimestamp = 'Itrinta: {{date}}';
z.string.lt.conversationEditTimestamp = 'Taisyta: {{date}}';
z.string.lt.conversationLikesCaption = '{{number}} monms';
z.string.lt.conversationSendPastedFile = 'Paveikslas dtas {{date}}';
z.string.lt.conversationSomeone = 'Kakas';
z.string.lt.conversationTweetAuthor = ' socialiniame tinkle Twitter';
z.string.lt.conversationServicesWarning = 'Tarnybos turi galimyb prisijungti prie io susirainjimo turinio';

z.string.lt.groupCreationPreferencesAction = 'Kitas';
z.string.lt.groupCreationPreferencesErrorNameShort = 'Bent 1 simbolis';
z.string.lt.groupCreationPreferencesErrorNameLong = 'Per daug simboli';
z.string.lt.groupCreationPreferencesHeader = 'Nauja grup';
z.string.lt.groupCreationPreferencesPlaceholder = 'Grups pavadinimas';
z.string.lt.groupCreationParticipantsActionCreate = 'Atlikta';
z.string.lt.groupCreationParticipantsActionSkip = 'Praleisti';
z.string.lt.groupCreationParticipantsHeader = 'Pridti moni';
z.string.lt.groupCreationParticipantsHeaderWithCounter = 'Pridti moni ({{number}})';
z.string.lt.groupCreationParticipantsPlaceholder = 'Iekokite pagal vard';
z.string.lt.groupSizeInfo = 'Prie pokalbio gali prisijungti iki {{count}} panekov. Vaizdo skambuiai veikai grupse iki 4 panekov.';

z.string.lt.guestRoomConversationName = 'Sveio kambarys';
z.string.lt.guestRoomToggleName = 'Leisti sveius';
z.string.lt.guestRoomToggleInfo = 'Leiskite monms nesantiems js komandoje prisijungti.';
z.string.lt.guestRoomToggleInfoExtended = 'Leiskite monms nesantiems js komandoje prisijungti. Bet kada galsite tai pakeisti.';

z.string.lt.guestRoomConversationBadge = 'Yra svei';
z.string.lt.guestRoomConversationBadgeService = 'Tarnybos aktyvios';
z.string.lt.guestRoomConversationBadgeGuestAndService = 'Yra svei ir tarnyb';

z.string.lt.guestRoomConversationHead = 'mons nesantys js komandoje gali prisijungti prie susirainjimo.';
z.string.lt.guestRoomConversationButton = 'Kviesti moni';

z.string.lt.collectionShowAll = 'Rodyti visus {{number}}';
z.string.lt.collectionSectionLinks = 'Nuorodos';
z.string.lt.collectionSectionImages = 'Paveikslai';
z.string.lt.collectionSectionFiles = 'Failai';
z.string.lt.collectionSectionAudio = 'Garso inuts';

z.string.lt.fullsearchPlaceholder = 'Iekoti tekstinse inutse';
z.string.lt.fullsearchNoResults = 'Rezultat nra.';

z.string.lt.archiveHeader = 'Archyvuoti';

z.string.lt.conversationsAllArchived = 'Viskas uarchyvuota';
z.string.lt.conversationsContacts = 'Kontaktai';
z.string.lt.conversationsConnectionRequestMany = 'Laukia {{number}} mons';
z.string.lt.conversationsConnectionRequestOne = '1 asmuo laukia';
z.string.lt.conversationsEmptyConversation = 'Grups pokalbis';
z.string.lt.conversationsNoConversations = 'Kol kas nra pokalbi';
z.string.lt.conversationsPopoverArchive = 'Archyvuoti susirainjim';
z.string.lt.conversationsPopoverBlock = 'Blokuoti kontakt';
z.string.lt.conversationsPopoverCancel = 'Atsisakyti uklausos';
z.string.lt.conversationsPopoverClear = 'Trinti turin';
z.string.lt.conversationsPopoverLeave = 'Ieiti i grups';
z.string.lt.conversationsPopoverNotify = 'jungti susirainjimo praneimus';
z.string.lt.conversationsPopoverSilence = 'Ijungti susirainjimo praneimus';
z.string.lt.conversationsPopoverUnarchive = 'Iimti susirainjim i archyvo';

z.string.lt.conversationsSecondaryLineEphemeralMessage = 'Isiunt jums inut';
z.string.lt.conversationsSecondaryLineIncomingCall = '{{user}} jums skambina';
z.string.lt.conversationsSecondaryLinePeopleLeft = '{{number}} moni ijo';
z.string.lt.conversationsSecondaryLinePersonLeft = '{{user}} ijo';
z.string.lt.conversationsSecondaryLinePersonRemoved = '{{user}} buvo paalinta(-s)';
z.string.lt.conversationsSecondaryLinePersonRemovedTeam = '{{user}} buvo paalintas i komandos';
z.string.lt.conversationsSecondaryLinePeopleAdded = 'Buvo pridta {{user}} moni';
z.string.lt.conversationsSecondaryLinePersonAdded = '{{user}} buvo pridta(-s)';
z.string.lt.conversationsSecondaryLinePersonAddedSelf = '{{user}} prisijung';
z.string.lt.conversationsSecondaryLinePersonAddedYou = '{{user}} pridjo jus';
z.string.lt.conversationsSecondaryLineRenamed = '{{user}} pervadino pokalb';
z.string.lt.conversationsSecondaryLineYouLeft = 'Js ijote';
z.string.lt.conversationsSecondaryLineYouWereRemoved = 'Js buvote paalinti';

z.string.lt.takeoverSub = 'Usirezervuokite savo unikal Wire vard.';
z.string.lt.takeoverLink = 'Suinoti daugiau';
z.string.lt.takeoverButtonChoose = 'Pasirinkti savo asmenin';
z.string.lt.takeoverButtonKeep = 'Palikti ';

z.string.lt.inviteMetaKeyMac = 'Cmd';
z.string.lt.inviteMetaKeyPc = 'Ctrl';
z.string.lt.inviteHintSelected = 'Spustelj {{metaKey}} ir C nukopijuosite';
z.string.lt.inviteHintUnselected = 'Paymkite ir spustelkite {{metaKey}} ir C';
z.string.lt.inviteHeadline = 'Pakvieskite mones  Wire';
z.string.lt.inviteMessage = 'A naudoju Wire. Iekokite mans kaip {{username}} arba apsilankykite get.wire.com.';
z.string.lt.inviteMessageNoEmail = 'A naudoju Wire. Apsilankyk get.wire.com , kad su manimi susisiektum.';

z.string.lt.extensionsBubbleButtonGif = 'Gif';

z.string.lt.extensionsGiphyButtonOk = 'Sisti';
z.string.lt.extensionsGiphyButtonMore = 'Pabandyti kit';
z.string.lt.extensionsGiphyMessage = '{{tag}}  per giphy.com';
z.string.lt.extensionsGiphyNoGifs = 'Oi, nra gif';
z.string.lt.extensionsGiphyRandom = 'Atsitiktinis';

z.string.lt.addParticipantsConfirmLabel = 'Pridti';
z.string.lt.addParticipantsHeader = 'Pridti moni';
z.string.lt.addParticipantsHeaderWithCounter = 'Pridti moni ({{number}})';
z.string.lt.addParticipantsManageServices = 'Valdyti tarnybas';
z.string.lt.addParticipantsManageServicesNoResults = 'Valdyti tarnybas';
z.string.lt.addParticipantsNoServicesManager = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eig.';
z.string.lt.addParticipantsNoServicesMember = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eig. Nordami jomis naudotis, praykite savo administratoriaus.';
z.string.lt.addParticipantsSearchPlaceholder = 'Iekokite pagal vard';
z.string.lt.addParticipantsServiceConfirmButton = 'Pridti paslaug';
z.string.lt.addParticipantsTabsPeople = 'mons';
z.string.lt.addParticipantsTabsServices = 'Paslaugos';

z.string.lt.conversationDetailsActionArchive = 'Archyvuoti susirainjim';
z.string.lt.conversationDetailsActionAddParticipants = 'Pridti dalyvi';
z.string.lt.conversationDetailsActionBlock = 'Blokuoti kontakt';
z.string.lt.conversationDetailsActionCancelRequest = 'Atsisakyti uklausos';
z.string.lt.conversationDetailsActionClear = 'Trinti turin';
z.string.lt.conversationDetailsActionConversationParticipants = 'Rodyti visus ({{number}})';
z.string.lt.conversationDetailsActionCreateGroup = 'Nauja grup';
z.string.lt.conversationDetailsActionDevices = 'renginiai';
z.string.lt.conversationDetailsActionGuestOptions = 'Svei nustatymai';
z.string.lt.conversationDetailsActionTimedMessages = 'Laikinos inuts';
z.string.lt.conversationDetailsActionNotifications = 'Praneimai';
z.string.lt.conversationDetailsActionLeave = 'Ieiti i grups';
z.string.lt.conversationDetailsGuestsOff = 'Ijungta';
z.string.lt.conversationDetailsGuestsOn = 'jungti';
z.string.lt.conversationDetailsOptions = 'Parinktys';
z.string.lt.conversationDetailsParticipantsServicesOne = 'Paslauga';
z.string.lt.conversationDetailsParticipantsServicesMany = 'Paslaugos';
z.string.lt.conversationDetailsParticipantsUsersOne = 'Asmuo';
z.string.lt.conversationDetailsParticipantsUsersMany = 'mons';
z.string.lt.conversationDetailsPeople = 'mons';
z.string.lt.conversationDetailsServices = 'Paslaugos';

z.string.lt.conversationParticipantsTitle = 'mons';
z.string.lt.conversationParticipantsSearchPlaceholder = 'Iekokite pagal vard';

z.string.lt.groupParticipantActionBlock = 'Blokuoti kontakt';
z.string.lt.groupParticipantActionCancelRequest = 'Atsisakyti uklausos';
z.string.lt.groupParticipantActionDevices = 'renginiai';
z.string.lt.groupParticipantActionIgnoreRequest = 'Nepaisyti uklausos';
z.string.lt.groupParticipantActionIncomingRequest = 'Patvirtinti uklaus';
z.string.lt.groupParticipantActionLeave = 'Ieiti i grups';
z.string.lt.groupParticipantActionOpenConversation = 'Atverti susirainjim';
z.string.lt.groupParticipantActionPending = 'Laukia';
z.string.lt.groupParticipantActionRemove = 'alinti i grups';
z.string.lt.groupParticipantActionSelfProfile = 'Atverti profil';
z.string.lt.groupParticipantActionSendRequest = 'Umegzti kontakt';
z.string.lt.groupParticipantActionUnblock = 'Atblokuoti';

z.string.lt.guestOptionsCopyLink = 'Kopijuoti nuorod';
z.string.lt.guestOptionsCopyLinkDone = 'Nuoroda nukopijuota!';
z.string.lt.guestOptionsCreateLink = 'Kurti nuorod';
z.string.lt.guestOptionsInfoHeader = 'Kviesti kitus naudojant nuorod';
z.string.lt.guestOptionsInfoText = 'Bet kas turintis nuorod gali prisijungti prie susirainjimo 24 valandoms, net jei neturi Wire.';
z.string.lt.guestOptionsRevokeLink = 'Ataukti nuorod';
z.string.lt.guestOptionsTitle = 'Svei nustatymai';

z.string.lt.notificationSettingsTitle = 'Praneimai';

z.string.lt.timedMessagesTitle = 'Laikinos inuts';
z.string.lt.timedMessageDisclaimer = 'Laikinos inuts bus jungtos visiems io pokalbio dalyviams.';

z.string.lt.participantDevicesDetailHeadline = 'sitikinkite, kad is kontrolinis kodas yra toks pats, kaip ir renginyje, kur naudoja {{html1}}{{user}}{{html2}}.';
z.string.lt.participantDevicesDetailHowTo = 'Kaip tai padaryti?';
z.string.lt.participantDevicesDetailResetSession = 'Atstatyti seans';
z.string.lt.participantDevicesDetailShowMyDevice = 'Rodyti mano renginio kontrolin kod';
z.string.lt.participantDevicesDetailVerify = 'Patvirtintas';

z.string.lt.participantDevicesHeader = 'renginiai';
z.string.lt.participantDevicesHeadline = 'Wire kiekvienam renginiui suteikia unikal kontrolin kod. Palyginkite juos su {{user}} ir patvirtinkite savo pokalb.';
z.string.lt.participantDevicesLearnMore = 'Suinoti daugiau';
z.string.lt.participantDevicesWhyVerify = 'Kam patvirtinti pokalb?';
z.string.lt.participantDevicesOutdatedClientMessage = '{{user}} naudoja sen Wire versij. ia nerodomi jokie renginiai.';

z.string.lt.participantDevicesSelfAllDevices = 'Rodyti visus mano renginius';
z.string.lt.participantDevicesSelfFingerprint = 'renginio kontrolinis kodas';

z.string.lt.userProfileButtonConnect = 'Umegzti kontakt';
z.string.lt.userProfileButtonIgnore = 'Nepaisyti';
z.string.lt.userProfileButtonUnblock = 'Atblokuoti';

z.string.lt.preferencesAbout = 'Apie';
z.string.lt.preferencesAccount = 'Paskyra';
z.string.lt.preferencesAV = 'Garsas / Vaizdas';
z.string.lt.preferencesDeviceDetails = 'Isamesn renginio informacija';
z.string.lt.preferencesDevices = 'renginiai';
z.string.lt.preferencesHeadline = 'Nuostatos';
z.string.lt.preferencesOptions = 'Parinktys';

z.string.lt.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.lt.preferencesAboutPrivacyPolicy = 'Privatumo politika';
z.string.lt.preferencesAboutSupport = 'Palaikymas';
z.string.lt.preferencesAboutSupportWebsite = 'Palaikymo svetain';
z.string.lt.preferencesAboutSupportContact = 'Susisiekti su palaikymu';
z.string.lt.preferencesAboutTermsOfUse = 'Naudojimosi slygos';
z.string.lt.preferencesAboutVersion = 'Versija {{version}}';
z.string.lt.preferencesAboutWebsite = 'Wire svetain';

z.string.lt.preferencesAccountAvaibilityUnset = 'Pasirinkite bsen';
z.string.lt.preferencesAccountCreateTeam = 'Sukurti komand';
z.string.lt.preferencesAccountData = 'Duomen naudojimo leidimas';
z.string.lt.preferencesAccountDataCheckbox = 'Sisti anonimin informacij';
z.string.lt.preferencesAccountDataDetail = 'Pagerinkite Wire sisdami anonimin naudojimosi ir triki ataskait.';
z.string.lt.preferencesAccountDelete = 'Itrinti paskyr';
z.string.lt.preferencesAccountLeaveGuestRoom = 'Ieiti i svei kambario';
z.string.lt.preferencesAccountLeaveGuestRoomDescription = 'Nebegalsite matyti io susirainjimo inui.';
z.string.lt.preferencesAccountLogOut = 'Atsijungti';
z.string.lt.preferencesAccountManageTeam = 'Tvarkyti komand';
z.string.lt.preferencesAccountMarketingConsentCheckbox = 'Gaukite naujienlaik';
z.string.lt.preferencesAccountMarketingConsentDetail = 'Gaukite naujienas ir produkt pakeitimo informacij i Wire el. patu.';
z.string.lt.preferencesAccountResetPassword = 'Atstatyti slaptaod';
z.string.lt.preferencesAccountTeam = 'komandoje {{name}}';
z.string.lt.preferencesAccountUsernamePlaceholder = 'Js vardas ir pavard';
z.string.lt.preferencesAccountUsernameHint = 'Bent 2 simboliai. Tik az, 09 ir _.';
z.string.lt.preferencesAccountUsernameAvailable = 'Prieinamas';
z.string.lt.preferencesAccountUsernameErrorTaken = 'Jau uimtas';

z.string.lt.preferencesAVCamera = 'Kamera';
z.string.lt.preferencesAVMicrophone = 'Mikrofonas';
z.string.lt.preferencesAVPermissionDetail = 'junkite savo narykls nuostatose';
z.string.lt.preferencesAVSpeakers = 'Garsiakalbiai';
z.string.lt.preferencesAVTemporaryDisclaimer = 'Sveiai negali pradti vaizdo konferencij. Pasirinkite norim kamer jei prisijungiate.';
z.string.lt.preferencesAVNoCamera = 'Wire neturi galimybs prisijungti prie kameros.[br][faqLink]Perskaitykite  pagalbos straipsn[/faqLink] ir suinosite, kaip tai sutvarkyti.';
z.string.lt.preferencesAVTryAgain = 'Bandykite dar kart';

z.string.lt.preferencesDevicesActivatedOn = 'Aktyvuotas {{date}}';
z.string.lt.preferencesDevicesActive = 'Aktyvus';
z.string.lt.preferencesDevicesActiveDetail = 'Jeigu js neatpastate aukiau esanio renginio, paalinkite j ir atstatykite savo slaptaod.';
z.string.lt.preferencesDevicesCurrent = 'Esamas';
z.string.lt.preferencesDevicesFingerprint = 'Rakto kontrolinis kodas';
z.string.lt.preferencesDevicesFingerprintDetail = 'Wire kiekvienam renginiui suteikia unikal kontrolin kod. Palyginkite juos ir patvirtinkite savo renginius ir pokalbius.';
z.string.lt.preferencesDevicesId = 'ID: ';
z.string.lt.preferencesDevicesRemove = 'Iimti';
z.string.lt.preferencesDevicesRemoveCancel = 'Atsisakyti';
z.string.lt.preferencesDevicesRemoveDetail = 'Jeigu nebenaudojate  rengin, paalinkite j. Js bsite nedelsiant atjungti i io renginio.';
z.string.lt.preferencesDevicesSessionConfirmation = 'Seansas buvo atstatytas.';
z.string.lt.preferencesDevicesSessionDetail = 'Jeigu kontroliniai kodai nesutampa, atstatykite seans, kad abiejose pusse bt sugeneruoti nauji ifravimo raktai.';
z.string.lt.preferencesDevicesSessionReset = 'Atstatyti seans';
z.string.lt.preferencesDevicesSessionOngoing = 'Atstatomas seansas';
z.string.lt.preferencesDevicesVerification = 'Patvirtintas';

z.string.lt.preferencesOptionsAudio = 'Garso signalai';
z.string.lt.preferencesOptionsAudioAll = 'Visi';
z.string.lt.preferencesOptionsAudioAllDetail = 'Visi garsai';
z.string.lt.preferencesOptionsAudioNone = 'Joki';
z.string.lt.preferencesOptionsAudioNoneDetail = 'a!';
z.string.lt.preferencesOptionsAudioSome = 'Kai kurie';
z.string.lt.preferencesOptionsAudioSomeDetail = 'Ryio tikrinimai ir skambuiai';
z.string.lt.preferencesOptionsContacts = 'Kontaktai';
z.string.lt.preferencesOptionsContactsGmail = 'Importuoti i Gmail';
z.string.lt.preferencesOptionsContactsMacos = 'Importuoti i kontakt';
z.string.lt.preferencesOptionsContactsDetail = 'Mes naudojame js kontaktinius duomenis tam, kad padtume jums umegzti kontakt su kitais. Mes padarome vis informacij anonimin ir su niekuo ja nesidaliname.';
z.string.lt.preferencesOptionsPopular = 'Pagal populiarias uklausas';
z.string.lt.preferencesOptionsEmojiReplaceCheckbox = 'Pakeisti raomus jaustukus jausmaenkliais';
z.string.lt.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.lt.preferencesOptionsPreviewsSendCheckbox = 'Rodyti js siuniam nuorod periras';
z.string.lt.preferencesOptionsPreviewsSendDetail = 'Kit moni siuniam nuorod periros vis dar gali bti rodomos.';
z.string.lt.preferencesOptionsNotifications = 'Praneimai';
z.string.lt.preferencesOptionsNotificationsNone = 'Ijungta';
z.string.lt.preferencesOptionsNotificationsObfuscate = 'Slpti isamesn informacij';
z.string.lt.preferencesOptionsNotificationsObfuscateMessage = 'Rodyti siuntj';
z.string.lt.preferencesOptionsNotificationsOn = 'Rodyti siuntj ir inut';
z.string.lt.preferencesOptionsCallLogs = 'Triki alinimas';
z.string.lt.preferencesOptionsCallLogsGet = 'Isaugoti skambui derinimo ataskait';
z.string.lt.preferencesOptionsCallLogsDetail = 'i informacija padeda Wire pagalbos centrui isprsti skambinimo nesklandumus.';

z.string.lt.preferencesOptionsBackupHeader = 'Praeitis';
z.string.lt.preferencesOptionsBackupExportHeadline = 'Kurti susirainjim atsargin kopij';
z.string.lt.preferencesOptionsBackupExportSecondary = 'Kurkite atsargin kopij, kad isaugotumte susirainjimo praeit. Jei prarasite savo kompiuter arba pasikeisite nauju, kopij galsite panaudoti praeities atkrimui.\nAtsargins kopijos failas nra apsaugotas Wire kodavimo, dl to js turite parinkti jam saugi viet.';
z.string.lt.preferencesOptionsBackupImportHeadline = 'Atkurti i atsargins kopijos';
z.string.lt.preferencesOptionsBackupImportSecondary = 'Atkurti praeit i atsargins kopijos galite tik toje paioje platformoje. Atsargin kopija pakeis visus susirainjimus, kuriuos iame renginyje turite.';

z.string.lt.backupExportGenericErrorHeadline = 'Failo isaugoti nepavyko';
z.string.lt.backupExportGenericErrorSecondary = 'Atsargins kopijos krimas nebuvo skmingas.';
z.string.lt.backupExportProgressHeadline = 'Ruoiama';
z.string.lt.backupExportProgressSecondary = 'Kuriame atsargin kopija  {{processed}} i {{total}}  {{progress}}%';
z.string.lt.backupExportProgressCompressing = 'Ruoiamas atsargins kopijos failas';
z.string.lt.backupExportSaveFileAction = 'Isaugoti fail';
z.string.lt.backupExportSuccessHeadline = 'Atsarginis kopijavimas baigtas';
z.string.lt.backupExportSuccessSecondary = 'Jei prarasite savo kompiuter arba pasikeisite nauju, kopij galsite panaudoti praeities atkrimui.';
z.string.lt.backupImportGenericErrorHeadline = 'Kakas nutiko';
z.string.lt.backupImportGenericErrorSecondary = 'Praeities atkurti nepavyko.';
z.string.lt.backupImportAccountErrorHeadline = 'Netinkama atsargin kopija';
z.string.lt.backupImportAccountErrorSecondary = 'Atkurti kitos paskyros atsargins kopijos nepavyks.';
z.string.lt.backupImportVersionErrorHeadline = 'Nesuderinama atsargin kopija';
z.string.lt.backupImportVersionErrorSecondary = 'i atsargin kopija buvo sukurta naudojant arba naujesn arba senesn Wire versij, ir negali bti naudojama atkrimui.';
z.string.lt.backupImportIncompatibleErrorHeadline = 'Netinkama atsargin kopija';
z.string.lt.backupImportIncompatibleErrorSecondary = 'Atkurti kitos paskyros atsargins kopijos nepavyks.';
z.string.lt.backupImportOutdatedErrorHeadline = 'Nesuderinama atsargin kopija';
z.string.lt.backupImportOutdatedErrorSecondary = 'i atsargin kopija buvo sukurta naudojant arba naujesn arba senesn Wire versij, ir negali bti naudojama atkrimui.';
z.string.lt.backupImportProgressHeadline = 'Ruoiama';
z.string.lt.backupImportProgressSecondary = 'Atkuriama praeitis  {{processed}} i {{total}}  {{progress}}%';
z.string.lt.backupImportSuccessHeadline = 'Praeitis atkurta.';
z.string.lt.backupCancel = 'Atsisakyti';
z.string.lt.backupTryAgain = 'Bandykite dar kart';

z.string.lt.searchConnect = 'Umegzti kontakt';
z.string.lt.searchConnections = 'Kontaktai';
z.string.lt.searchContacts = 'Kontaktai';
z.string.lt.searchCreateGroup = 'Sukurti grup';
z.string.lt.searchCreateGuestRoom = 'Kurti sveio kambar';
z.string.lt.searchGroups = 'Grups';
z.string.lt.searchPeople = 'mons';
z.string.lt.searchPlaceholder = 'Iekokite pagal vard ar naudotojo vard';
z.string.lt.searchServicePlaceholder = 'Iekokite pagal vard';
z.string.lt.searchServices = 'Paslaugos';
z.string.lt.searchManageServices = 'Valdyti tarnybas';
z.string.lt.searchManageServicesNoResults = 'Valdyti tarnybas';
z.string.lt.searchNoServicesManager = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eig.';
z.string.lt.searchNoServicesMember = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eig. Nordami jomis naudotis, praykite savo administratoriaus.';
z.string.lt.searchTeamGroups = 'Komandos pokalbiai';
z.string.lt.searchTeamMembers = 'Komandos dalyviai';
z.string.lt.searchTopPeople = 'Svarbiausi mons';
z.string.lt.searchTrySearch = 'Raskite mones pagal vard arba naudotojo vard';
z.string.lt.searchNoContactsOnWire = 'Js neturite Wire kontakt.\nPabandykite rasti mones pagal\nvard arba naudotojo vard.';
z.string.lt.searchMemberInvite = 'Kvieskite moni prisijungti prie komandos';
z.string.lt.searchOthers = 'Umegzti kontakt';

z.string.lt.searchInvite = 'Pakvieskite mones  Wire';
z.string.lt.searchInviteDetail = 'Dalinimasis kontaktais padeda jums umegzti kontakt su kitais monmis. Mes padarome vis informacij anonimin ir su niekuo ja nesidaliname.';
z.string.lt.searchInviteButtonContacts = 'I kontakt';
z.string.lt.searchInviteButtonGmail = 'I Gmail';
z.string.lt.searchInviteHeadline = 'Pasikvieskite savo draugus';
z.string.lt.searchInviteShare = 'Dalintis kontaktais';

z.string.lt.searchServiceConfirmButton = 'Pridti paslaug';

z.string.lt.searchListEveryoneParticipates = 'Visi, su kuo esate\numezg kontakt, jau yra\niame pokalbyje.';
z.string.lt.searchListNoMatches = 'Nra atitinkani rezultat.\nPabandykite vesti kit vard.';

z.string.lt.temporaryGuestCta = 'Kurti paskyr';
z.string.lt.temporaryGuestDescription = 'Apsaugokite savo versl susiraindami ir kalbdami konferenciniu bdu ifruojant.';
z.string.lt.temporaryGuestTimeRemaining = ' liko iam svei kambariui';

z.string.lt.temporaryGuestJoinMessage = 'iame susirainjime galsite dalyvauti 24 valandas.';
z.string.lt.temporaryGuestJoinDescription = 'Jei puslap udarysite arba perkrausite i naujo, prisijungti nebegalsite.';

z.string.lt.temporaryGuestLeaveMessage = ' ijo i io susirainjimo.';
z.string.lt.temporaryGuestLeaveDescription = 'Jei puslap udarysite arba perkrausite i naujo, susirainjimo praeities matyti nebegalsite.';

z.string.lt.uploadGoogleHeadline = 'Raskite mones\nsu kuriais pasikalbti.';
z.string.lt.uploadGoogleMessage = 'Mes naudojame js kontaktinius duomenis tam, kad padtume jums umegzti kontakt su kitais. Mes padarome vis informacij anonimin ir su niekuo ja nesidaliname.';

z.string.lt.warningCallUnsupportedIncoming = 'Skambina {{user}}. Js narykl nepalaiko skambui.';
z.string.lt.warningCallUnsupportedOutgoing = 'Js negalite skambinti, nes js narykl nepalaiko skambui.';
z.string.lt.warningCallIssues = 'i Wire versija negali dalyvauti pokalbyje. Naudokite';
z.string.lt.warningCallUpgradeBrowser = 'Nordami skambinti, atnaujinkite Google Chrome.';
z.string.lt.warningConnectivityConnectionLost = 'Bandoma prisijungti. Gali bti, kad Wire negals pristatyti inui.';
z.string.lt.warningConnectivityNoInternet = 'Nra interneto. Js negalsite sisti ir gauti inutes.';
z.string.lt.warningLearnMore = 'Suinoti daugiau';
z.string.lt.warningLifecycleUpdate = 'Ileista nauja Wire versija.';
z.string.lt.warningLifecycleUpdateNotes = 'Kas naujo';
z.string.lt.warningLifecycleUpdateLink = 'Atnaujinti dabar';
z.string.lt.warningNotFoundCamera = 'Js negalite skambinti, nes js kompiuteryje nra kameros.';
z.string.lt.warningNotFoundMicrophone = 'Js negalite skambinti, nes js kompiuteryje nra mikrofono.';
z.string.lt.warningPermissionDeniedCamera = 'Js negalite skambinti, nes js narykl neturi prieigos prie kameros.';
z.string.lt.warningPermissionDeniedMicrophone = 'Js negalite skambinti, nes js narykl neturi prieigos prie mikrofono.';
z.string.lt.warningPermissionDeniedScreen = 'Norint bendrinti ekran, js naryklei reikia leidim.';
z.string.lt.warningPermissionRequestCamera = '{{icon}} Leisti prieig prie kameros';
z.string.lt.warningPermissionRequestMicrophone = '{{icon}} Leisti prieig prie mikrofono';
z.string.lt.warningPermissionRequestNotification = '{{icon}} Leisti praneimus';
z.string.lt.warningPermissionRequestScreen = '{{icon}} Leisti prieig prie ekrano';

z.string.lt.userAvailabilityAvailable = 'Prieinamas';
z.string.lt.userAvailabilityAway = 'Pasialins';
z.string.lt.userAvailabilityBusy = 'Usims';
z.string.lt.userAvailabilityNone = 'Joki';

z.string.lt.notificationAssetAdd = 'Pasidalino paveikslu';
z.string.lt.notificationConnectionAccepted = 'Prim js kontakto umezgimo uklaus';
z.string.lt.notificationConnectionConnected = 'Dabar esate umezg kontakt';
z.string.lt.notificationConnectionRequest = 'Nori umegzti kontakt';
z.string.lt.notificationConversationCreate = '{{user}} pradjo pokalb';
z.string.lt.notificationConversationMessageTimerUpdate = '{{user}} nustat inui laikmat  {{time}}';
z.string.lt.notificationConversationMessageTimerReset = '{{user}} ijung inui laikmat';
z.string.lt.notificationConversationRename = '{{user}} pervadino pokalb  {{name}}';
z.string.lt.notificationMemberJoinMany = '{{user}} pridjo {{number}} mones(-i)  pokalb';
z.string.lt.notificationMemberJoinSelf = '{{user}} prisijung prie susirainjimo';
z.string.lt.notificationMemberJoinOne = '{{user1}} pridjo {{user2}}  pokalb';
z.string.lt.notificationMemberLeaveRemovedYou = '{{user}} paalino jus i pokalbio';
z.string.lt.notificationObfuscated = 'Isiunt jums inut';
z.string.lt.notificationObfuscatedTitle = 'Kakas';
z.string.lt.notificationPing = 'Patikrino ry';
z.string.lt.notificationReaction = '{{reaction}} js inut';
z.string.lt.notificationSharedAudio = 'Pasidalino garso inute';
z.string.lt.notificationSharedFile = 'Pasidalino failu';
z.string.lt.notificationSharedLocation = 'Pasidalino vieta';
z.string.lt.notificationSharedVideo = 'Pasidalino vaizdo rau';
z.string.lt.notificationTitleGroup = '{{user}} susirainjime {{conversation}}';
z.string.lt.notificationVoiceChannelActivate = 'Skambina';
z.string.lt.notificationVoiceChannelDeactivate = 'Skambino';

z.string.lt.tooltipConversationAllVerified = 'Visi kontroliniai kodai patvirtinti';
z.string.lt.tooltipConversationCall = 'Skambutis';
z.string.lt.tooltipConversationEphemeral = 'Laikina inut';
z.string.lt.tooltipConversationFile = 'Pridti fail';
z.string.lt.tooltipConversationInputPlaceholder = 'Raykite inut';
z.string.lt.tooltipConversationInputPlaceholderAvailable = '{{user}} yra prisijungs';
z.string.lt.tooltipConversationInputPlaceholderAway = '{{user}} yra pasialins';
z.string.lt.tooltipConversationInputPlaceholderBusy = '{{user}} yra usims';
z.string.lt.tooltipConversationPeople = 'mons ({{shortcut}})';
z.string.lt.tooltipConversationPicture = 'Pridti paveiksl';
z.string.lt.tooltipConversationPing = 'Tikrinti ry ({{shortcut}})';
z.string.lt.tooltipConversationSearch = 'Iekoti';
z.string.lt.tooltipConversationVideoCall = 'Vaizdo skambutis';

z.string.lt.tooltipConversationsArchive = 'Archyvuoti ({{shortcut}})';
z.string.lt.tooltipConversationsArchived = 'Rodyti archyv ({{number}})';
z.string.lt.tooltipConversationsMore = 'Daugiau';
z.string.lt.tooltipConversationsNotify = 'jungti praneimus ({{shortcut}})';
z.string.lt.tooltipConversationsPreferences = 'Atverti nuostatas';
z.string.lt.tooltipConversationsSilence = 'Ijungti praneimus ({{shortcut}})';
z.string.lt.tooltipConversationsStart = 'Pradti pokalb ({{shortcut}})';

z.string.lt.tooltipConversationDetailsAddPeople = 'Pridti dalyvi prie susirainjimo ({{shortcut}})';
z.string.lt.tooltipConversationDetailsRename = 'Pakeisti pokalbio pavadinim';

z.string.lt.tooltipPreferencesContactsGmail = 'Prisijunkite prie savo Gmail paskyros, nordami bendrinti kontaktus';
z.string.lt.tooltipPreferencesContactsMacos = 'Bendrinti visus savo kontaktus i macOS Kontakt programos';
z.string.lt.tooltipPreferencesPassword = 'Atverti kit svetain, skirt slaptaodio atstatymui';
z.string.lt.tooltipPreferencesPicture = 'Pakeisti savo paveiksl';
z.string.lt.tooltipPreferencesRename = 'Pakeisti savo vard';

z.string.lt.tooltipSearchClose = 'Uverti (Esc)';

z.string.lt.initReceivedSelfUser = 'Sveiki, {{user}}.';
z.string.lt.initValidatedClient = 'Gaunami js kontaktai ir pokalbiai';
z.string.lt.initReceivedUserData = 'Tikrinama ar yra nauj inui';
z.string.lt.initDecryption = 'Iifruojamos inuts';
z.string.lt.initEvents = 'keliamos inuts';
z.string.lt.initUpdatedFromNotifications = 'Beveik baigta  mgaukits Wire';
z.string.lt.initProgress = '  {{number1}} i {{number2}}';

z.string.lt.ephemeralUnitsNone = 'Ijungta';
z.string.lt.ephemeralUnitsSecond = 'sek.';
z.string.lt.ephemeralUnitsSeconds = 'sek.';
z.string.lt.ephemeralUnitsMinute = 'min.';
z.string.lt.ephemeralUnitsMinutes = 'min.';
z.string.lt.ephemeralUnitsHour = 'val.';
z.string.lt.ephemeralUnitsHours = 'val.';
z.string.lt.ephemeralUnitsDay = 'd.';
z.string.lt.ephemeralUnitsDays = 'd.';
z.string.lt.ephemeralUnitsWeek = 'sav.';
z.string.lt.ephemeralUnitsWeeks = 'sav.';
z.string.lt.ephemeralUnitsYear = 'm.';
z.string.lt.ephemeralUnitsYears = 'm.';
z.string.lt.ephemeralRemaining = 'liko';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.nl.wire = 'Wire';
z.string.nl.wireMacos = 'Wire voor macOS';
z.string.nl.wireWindows = 'Wire voor Windows';
z.string.nl.wireLinux = 'Wire voor Linux';
z.string.nl.nonexistentUser = 'Verwijderde gebruiker';
z.string.nl.and = 'en';
z.string.nl.enumerationAnd = ', en ';

z.string.nl.authAccountCountryCode = 'Landcode';
z.string.nl.authAccountPasswordForgot = 'Wachtwoord vergeten';
z.string.nl.authAccountPublicComputer = 'Dit is een publieke computer';
z.string.nl.authAccountSignIn = 'Inloggen';
z.string.nl.authAccountSignInPhone = 'Telefoonnummer';

z.string.nl.authBlockedCookies = 'Zet je cookies aan om in te loggen in Wire.';
z.string.nl.authBlockedDatabase = 'Wire heeft toegang nodig tot lokale opslag om je berichten te kunnen laten zien, maar dit is niet mogelijk in privmodus.';
z.string.nl.authBlockedTabs = 'Wire is al open in een ander tabblad.';

z.string.nl.authVerifyAccountAdd = 'Toevoegen';
z.string.nl.authVerifyAccountDetail = 'Dit zorgt ervoor dat je Wire op meerdere apparaten kunt gebruiken.';
z.string.nl.authVerifyAccountHeadline = 'E-mailadres en wachtwoord toevoegen.';
z.string.nl.authVerifyAccountLogout = 'Uitloggen';
z.string.nl.authVerifyCodeDescription = 'Voer de verificatiecode in die\nwe naar {{number}} hebben gestuurd.';
z.string.nl.authVerifyCodeResend = 'Geen code ontvangen?';
z.string.nl.authVerifyCodeResendDetail = 'Opnieuw sturen';
z.string.nl.authVerifyCodeResendTimer = 'Je kunt een nieuwe code aanvragen {{expiration}}.';
z.string.nl.authVerifyCodeChangePhone = 'Telefoonnummer wijzigen';
z.string.nl.authVerifyPasswordHeadline = 'Voer je wachtwoord in';

z.string.nl.authLimitDevicesHeadline = 'Apparaten';
z.string.nl.authLimitDescription = 'Verwijder een van je andere apparaten om Wire op dit apparaat te gebruiken.';
z.string.nl.authLimitButtonManage = 'Beheer apparaten';
z.string.nl.authLimitButtonSignOut = 'Uitloggen';
z.string.nl.authLimitDevicesCurrent = '(Huidig)';

z.string.nl.authHistoryHeadline = 'Het is de eerste keer dat je Wire op dit apparaat gebruikt.';
z.string.nl.authHistoryDescription = 'Om privacyredenen wordt je gespreksgeschiedenis hier niet getoond.';
z.string.nl.authHistoryReuseHeadline = 'Je hebt Wire eerder op dit apparaat gebruikt.';
z.string.nl.authHistoryReuseDescription = 'Berichten die in de tussentijd worden verzonden worden niet weergegeven.';
z.string.nl.authHistoryButton = 'OK';

z.string.nl.authPostedResend = 'Opnieuw verzenden naar {{email}}';
z.string.nl.authPostedResendAction = 'Geen e-mail ontvangen?';
z.string.nl.authPostedResendDetail = 'Controleer je inbox en volg de instructies.';
z.string.nl.authPostedResendHeadline = 'Je hebt e-mail ontvangen.';

z.string.nl.authPlaceholderEmail = 'E-mail';
z.string.nl.authPlaceholderPasswordPut = 'Wachtwoord';
z.string.nl.authPlaceholderPasswordSet = 'Wachtwoord (minimaal 8 tekens)';
z.string.nl.authPlaceholderPhone = 'Telefoonnummer';

z.string.nl.authErrorCode = 'Ongeldige code';
z.string.nl.authErrorCountryCodeInvalid = 'Ongeldige landscode';
z.string.nl.authErrorEmailExists = 'Email adres word algebruikt';
z.string.nl.authErrorEmailForbidden = 'Sorry. Dit e-mailadres is verboden.';
z.string.nl.authErrorEmailMalformed = 'Voer alsjeblieft een geldig e-mailadres in.';
z.string.nl.authErrorEmailMissing = 'Voer alsjeblieft een e-mailadres in.';
z.string.nl.authErrorMisc = 'Problemen met de verbinding. Probeer het opnieuw.';
z.string.nl.authErrorNameShort = 'Voer een naam met ten minste 2 karakters';
z.string.nl.authErrorOffline = 'Geen internet connectie';
z.string.nl.authErrorPasswordShort = 'Kies een wachtwoord van minimaal 8 tekens.';
z.string.nl.authErrorPasswordWrong = 'Fout wachtwoord. Probeer opnieuw.';
z.string.nl.authErrorPending = 'Account is nog niet geverifieerd';
z.string.nl.authErrorPhoneNumberBudget = 'Je vaak ingelogd. Probeer het later opnieuw.';
z.string.nl.authErrorPhoneNumberForbidden = 'Sorry. Dit telefoon nummer is verboden.';
z.string.nl.authErrorPhoneNumberInvalid = 'Ongeldig Telefoonnummer';
z.string.nl.authErrorPhoneNumberUnknown = 'Onbekend Telefoon Nummer';
z.string.nl.authErrorSuspended = 'Dit account is niet langer geautoriseerd om in te loggen.';
z.string.nl.authErrorSignIn = 'Controleer je gegevens en probeer het nog eens.';

z.string.nl.callStateOutgoing = 'Bellen';
z.string.nl.callStateConnecting = 'Verbinden';
z.string.nl.callStateIncoming = 'Bellen';
z.string.nl.callDecline = 'Leg op';
z.string.nl.callAccept = 'Neem op';
z.string.nl.callJoin = 'Deelnemen';
z.string.nl.callChooseSharedScreen = 'Kies een scherm om te delen';
z.string.nl.callParticipants = '{{number}} bellen';

z.string.nl.videoCallOverlayMute = 'Dempen';
z.string.nl.videoCallOverlayHangUp = 'Ophangen';

z.string.nl.modalAcknowledgeAction = 'Ok';
z.string.nl.modalConfirmSecondary = 'Annuleer';
z.string.nl.modalOptionSecondary = 'Annuleer';

z.string.nl.modalAccountCreateAction = 'OK';

z.string.nl.modalAccountDeletionAction = 'Verwijderen';
z.string.nl.modalAccountDeletionHeadline = 'Verwijder account';
z.string.nl.modalAccountDeletionMessage = 'We vesturen je een bericht via email of SMS. Volg de instructies op in de link om je account te verwijderen.';

z.string.nl.modalAccountLeaveGuestRoomAction = 'Verlaten';

z.string.nl.modalAccountLogoutAction = 'Uitloggen';
z.string.nl.modalAccountLogoutHeadline = 'Gegevens wissen?';
z.string.nl.modalAccountLogoutOption = 'Verwijder al je persoonlijke gegevens en gesprekken op dit apparaat.';

z.string.nl.modalAccountNewDevicesSecondary = 'Beheer apparaten';
z.string.nl.modalAccountNewDevicesHeadline = 'Je account werd gebruikt op:';
z.string.nl.modalAccountNewDevicesFrom = 'Van:';
z.string.nl.modalAccountNewDevicesMessage = 'Als je dit niet zelf was, verwijder dan het apparaat en stel je wachtwoord opnieuw in.';

z.string.nl.modalAccountRemoveDeviceAction = 'Verwijder apparaat';
z.string.nl.modalAccountRemoveDeviceHeadline = 'Verwijder "{{device}}"';
z.string.nl.modalAccountRemoveDeviceMessage = 'Je wachtwoord is nodig om dit apparaat te verwijderen.';
z.string.nl.modalAccountRemoveDevicePlaceholder = 'Wachtwoord';

z.string.nl.modalAssetTooLargeMessage = 'U kunt bestanden versturen tot {{number}}';

z.string.nl.modalAssetParallelUploadsMessage = 'Je kan tot {{number}} bestanden tegelijk versturen.';

z.string.nl.modalCallEmptyConversationHeadline = 'Niemand om te bellen';
z.string.nl.modalCallEmptyConversationMessage = 'Er is hier niemand meer.';

z.string.nl.modalCallNoGroupVideoHeadline = 'Geen video bellen in groepen';
z.string.nl.modalCallNoGroupVideoMessage = 'Video berichten zijn niet beschikbaar in groep gesprekken.';

z.string.nl.modalCallNoMicrophoneAction = 'Vertel me meer';
z.string.nl.modalCallNoMicrophoneMessage = 'Uw browser heeft toegang nodig tot de microfoon om te bellen.';
z.string.nl.modalCallNoMicrophoneHeadline = 'Je kan niet bellen zonder microfoon';

z.string.nl.modalCallSecondIncomingAction = 'Beantwoord';
z.string.nl.modalCallSecondIncomingHeadline = 'Oproep beantwoorden?';
z.string.nl.modalCallSecondIncomingMessage = 'Uw huidige gesprek zal worden beindigd.';

z.string.nl.modalCallSecondOngoingAction = 'Ophangen';
z.string.nl.modalCallSecondOngoingHeadline = 'Hang gesprek op op andere apparaat?';
z.string.nl.modalCallSecondOngoingMessage = 'Je kunt maar n gesprek tegelijk voeren.';

z.string.nl.modalCallSecondOutgoingAction = 'Ophangen';
z.string.nl.modalCallSecondOutgoingHeadline = 'Huidige gesprek ophangen?';
z.string.nl.modalCallSecondOutgoingMessage = 'Je kunt maar n gesprek tegelijk voeren.';

z.string.nl.modalConnectCancelAction = 'Ja';
z.string.nl.modalConnectCancelHeadline = 'Verzoek annuleren?';
z.string.nl.modalConnectCancelMessage = 'Verwijder verzoek aan {{user}}.';
z.string.nl.modalConnectCancelSecondary = 'Nee';

z.string.nl.modalConnectAcceptAction = 'Verbind';
z.string.nl.modalConnectAcceptHeadline = 'Accepteren?';
z.string.nl.modalConnectAcceptMessage = 'Dit zal een verbinding met {{user}} maken en een gesprek openen.';
z.string.nl.modalConnectAcceptSecondary = 'Negeer';

z.string.nl.modalConversationClearAction = 'Verwijderen';
z.string.nl.modalConversationClearHeadline = 'Inhoud verwijderen?';
z.string.nl.modalConversationClearOption = 'Ook het gesprek verlaten';

z.string.nl.modalConversationDeleteMessageAction = 'Verwijderen';
z.string.nl.modalConversationDeleteMessageHeadline = 'Alleen voor mij verwijderen?';
z.string.nl.modalConversationDeleteMessageMessage = 'Dit kan niet ongedaan gemaakt worden.';

z.string.nl.modalConversationDeleteMessageEveryoneAction = 'Verwijderen';
z.string.nl.modalConversationDeleteMessageEveryoneHeadline = 'Voor iedereen verwijderen?';
z.string.nl.modalConversationDeleteMessageEveryoneMessage = 'Dit kan niet ongedaan gemaakt worden.';

z.string.nl.modalConversationLeaveAction = 'Verlaten';
z.string.nl.modalConversationLeaveMessage = 'Je zal niet in staat zijn om berichten in deze conversatie te verzenden of te ontvangen.';

z.string.nl.modalConversationMessageTooLongHeadline = 'Bericht te lang';
z.string.nl.modalConversationMessageTooLongMessage = 'Je kan berichten verzenden van maximaal {{number}} tekens.';

z.string.nl.modalConversationNewDeviceHeadlineOne = '{{user}} gebruikt een nieuw apparaat';
z.string.nl.modalConversationNewDeviceHeadlineMany = '{{users}} gebruiken nieuwe apparaten';
z.string.nl.modalConversationNewDeviceHeadlineYou = '{{user}} gebruikt een nieuw apparaat';
z.string.nl.modalConversationNewDeviceIncomingCallAction = 'Gesprek aannemen';
z.string.nl.modalConversationNewDeviceIncomingCallMessage = 'Wil je het gesprek nog steeds accepteren?';
z.string.nl.modalConversationNewDeviceMessage = 'Wil je het bericht nog steeds versturen?';
z.string.nl.modalConversationNewDeviceOutgoingCallAction = 'Toch bellen';
z.string.nl.modalConversationNewDeviceOutgoingCallMessage = 'Wil je het gesprek nog steeds voeren?';

z.string.nl.modalConversationNotConnectedHeadline = 'Niemand toegevoegd tot conversatie';
z.string.nl.modalConversationNotConnectedMessageOne = '{{name}} wil niet toegevoegd worden aan gesprekken.';
z.string.nl.modalConversationNotConnectedMessageMany = 'Een van de mensen die je hebt geselecteerd wil niet worden toegevoegd aan gesprekken.';

z.string.nl.modalConversationRemoveAction = 'Verwijderen';
z.string.nl.modalConversationRemoveHeadline = 'Verwijder?';
z.string.nl.modalConversationRemoveMessage = '{{user}} zal geen berichten kunnen versturen of ontvangen in dit gesprek.';

z.string.nl.modalConversationRemoveGuestsAction = 'Verwijderen';

z.string.nl.modalConversationTooManyMembersHeadline = 'Full house';

z.string.nl.modalIntegrationUnavailableHeadline = 'Bots zijn nu niet beschikbaar';
z.string.nl.modalIntegrationUnavailableMessage = 'Dank je voor je intress voor bots. De service is nu gestopt, terwijl we nu werken aan een volgende versie.';


z.string.nl.modalImproveWireAction = 'Neem op';
z.string.nl.modalImproveWireSecondary = 'Nee';

z.string.nl.modalServiceUnavailableHeadline = 'Toevoegen van de service niet mogelijk';
z.string.nl.modalServiceUnavailableMessage = 'De service is op dit moment niet beschikbaar.';

z.string.nl.modalSessionResetHeadline = 'De sessie is gereset';
z.string.nl.modalSessionResetMessage1 = 'Als het probleem niet is opgelost, ';
z.string.nl.modalSessionResetMessageLink = 'contact';
z.string.nl.modalSessionResetMessage2 = 'ons.';

z.string.nl.modalUploadContactsAction = 'Probeer opnieuw';
z.string.nl.modalUploadContactsMessage = 'We hebben geen informatie ontvangen. Probeer opnieuw je contacten te importeren.';

z.string.nl.modalUserBlockAction = 'Blokkeren';
z.string.nl.modalUserBlockHeadline = '{{user}} blokkeren?';
z.string.nl.modalUserBlockMessage = '{{user}} zal niet in staat zijn je te contacteren of toe te voegen aan een groepsgesprek.';

z.string.nl.modalUserUnblockAction = 'Deblokkeer';
z.string.nl.modalUserUnblockHeadline = 'Deblokkeer?';
z.string.nl.modalUserUnblockMessage = '{{user}} zal weer in staat zijn je te contacteren en je toe te voegen aan een groepsgesprek.';

z.string.nl.connectionRequestConnect = 'Verbind';
z.string.nl.connectionRequestIgnore = 'Negeer';

z.string.nl.conversationGuestIndicator = 'Gast';

z.string.nl.conversationYouNominative = 'jij';
z.string.nl.conversationYouDative = 'jij';
z.string.nl.conversationYouAccusative = 'jij';

z.string.nl.conversationConnectionAccepted = 'Verbonden';
z.string.nl.conversationConnectionBlocked = 'Geblokkeerd';
z.string.nl.conversationConnectionCancelRequest = 'Stop verzoek tot connectie';
z.string.nl.conversationCreateWith = 'met {{users}}';
z.string.nl.conversationDeviceStartedUsingOne = ' begon met het gebruik van';
z.string.nl.conversationDeviceStartedUsingMany = ' begon met het gebruik van';
z.string.nl.conversationDeviceUnverified = ' unverified een van';
z.string.nl.conversationDeviceYourDevices = ' jou apparaten';
z.string.nl.conversationDeviceUserDevices = '{{user}}s apparaten';
z.string.nl.conversationDeviceNewDeviceOne = ' een nieuw apparaat';
z.string.nl.conversationDeviceNewDeviceMany = ' nieuw apparaaten';
z.string.nl.conversationDeviceNewPeopleJoinedVerify = ' controleer apparaten';
z.string.nl.conversationJustNow = 'Zojuist';
z.string.nl.conversationLocationLink = 'Open kaart';
z.string.nl.conversationMessageDelivered = 'Afgeleverd';
z.string.nl.conversationRename = ' je hebt de conversatie hernoemt';
z.string.nl.conversationRenameYou = ' je hebt de conversatie hernoemt';
z.string.nl.conversationResume = 'Begin een gesprek met {{users}}';
z.string.nl.conversationPing = ' pinged';
z.string.nl.conversationPingYou = ' pinged';
z.string.nl.conversationToday = 'vandaag';
z.string.nl.conversationVoiceChannelDeactivate = ' belde';
z.string.nl.conversationVoiceChannelDeactivateYou = ' belde';
z.string.nl.conversationYesterday = 'Gisteren';
z.string.nl.conversationUnableToDecrypt1 = 'een bericht van {{user}} is niet ontvangen.';
z.string.nl.conversationUnableToDecrypt2 = '{{user}}s apparaatidentiteit is veranderd. Het bericht is niet afgeleverd.';
z.string.nl.conversationUnableToDecryptLink = 'Waarom?';
z.string.nl.conversationUnableToDecryptErrorMessage = 'Fout';
z.string.nl.conversationUnableToDecryptResetSession = 'Reset session';
z.string.nl.conversationMissedMessages = 'Je hebt dit apparaat een tijdje niet gebruikt. Sommige berichten worden hier niet getoond.';
z.string.nl.conversationAssetDownloading = 'Downloaden';
z.string.nl.conversationAssetUploadFailed = 'Uploaden mislukt';
z.string.nl.conversationPlaybackError = 'Niet in staat om te af te spelen';
z.string.nl.conversationContextMenuCopy = 'Kopiren';
z.string.nl.conversationContextMenuEdit = 'Bewerken';
z.string.nl.conversationContextMenuDelete = 'Verwijderen voor mij';
z.string.nl.conversationContextMenuDeleteEveryone = 'Verwijderen voor iedereen';
z.string.nl.conversationContextMenuDownload = 'Download';
z.string.nl.conversationContextMenuLike = 'Vind ik leuk';
z.string.nl.conversationContextMenuUnlike = 'Vind ik niet leuk';
z.string.nl.conversationDeleteTimestamp = 'Verwijderd op {{date}}';
z.string.nl.conversationEditTimestamp = 'Bewerkt op {{date}}';
z.string.nl.conversationLikesCaption = '{{number}} mensen';
z.string.nl.conversationSendPastedFile = 'Afbeelding geplakt op {{date}}';
z.string.nl.conversationSomeone = 'Iemand';
z.string.nl.conversationTweetAuthor = ' op Twitter';

z.string.nl.groupCreationPreferencesAction = 'Volgende';
z.string.nl.groupCreationPreferencesErrorNameShort = 'Minimaal 1 teken';
z.string.nl.groupCreationPreferencesErrorNameLong = 'Te veel tekens';
z.string.nl.groupCreationPreferencesHeader = 'Nieuwe groep';
z.string.nl.groupCreationPreferencesPlaceholder = 'Groepsnaam';
z.string.nl.groupCreationParticipantsActionCreate = 'Klaar';
z.string.nl.groupCreationParticipantsActionSkip = 'Sla over';
z.string.nl.groupCreationParticipantsHeader = 'Personen toevoegen';
z.string.nl.groupCreationParticipantsPlaceholder = 'Zoeken op naam';


z.string.nl.collectionShowAll = 'Toon alle {{number}}';
z.string.nl.collectionSectionLinks = 'Links';
z.string.nl.collectionSectionImages = 'Afbeeldingen';
z.string.nl.collectionSectionFiles = 'Bestanden';
z.string.nl.collectionSectionAudio = 'Audio berichten';

z.string.nl.fullsearchPlaceholder = 'Zoek tekst berichten';
z.string.nl.fullsearchNoResults = 'Geen resultaten.';

z.string.nl.archiveHeader = 'Archiveren';

z.string.nl.conversationsAllArchived = 'Alles gearchiveerd';
z.string.nl.conversationsContacts = 'Contacten';
z.string.nl.conversationsConnectionRequestMany = '{{number}} personen wachten';
z.string.nl.conversationsConnectionRequestOne = '1 persoon wacht';
z.string.nl.conversationsEmptyConversation = 'Groepsgesprek';
z.string.nl.conversationsNoConversations = 'Nog geen gesprekken';
z.string.nl.conversationsPopoverArchive = 'Archiveren';
z.string.nl.conversationsPopoverCancel = 'Annuleer verzoek';
z.string.nl.conversationsPopoverNotify = 'Dempen opheffen';
z.string.nl.conversationsPopoverSilence = 'Dempen';
z.string.nl.conversationsPopoverUnarchive = 'Terugzetten';

z.string.nl.conversationsSecondaryLineEphemeralMessage = 'Stuurde je een bericht';
z.string.nl.conversationsSecondaryLinePeopleLeft = '{{number}} personen verlieten dit gesprek';
z.string.nl.conversationsSecondaryLinePersonLeft = '{{user}} verliet dit gesprek';
z.string.nl.conversationsSecondaryLinePersonRemoved = '{{user}} is verwijderd';
z.string.nl.conversationsSecondaryLinePeopleAdded = '{{user}} personen zijn toegevoegd';
z.string.nl.conversationsSecondaryLinePersonAdded = '{{user}} is toegevoegd';
z.string.nl.conversationsSecondaryLinePersonAddedYou = '{{user}} heeft jou toegevoegd';
z.string.nl.conversationsSecondaryLineRenamed = '{{user}} hernoemde de conversatie';
z.string.nl.conversationsSecondaryLineYouLeft = 'Je hebt het gesprek verlaten';
z.string.nl.conversationsSecondaryLineYouWereRemoved = 'Je bent verwijderd';

z.string.nl.takeoverSub = 'Claim je unieke gebruikers naam op Wire.';
z.string.nl.takeoverLink = 'Leer meer';
z.string.nl.takeoverButtonChoose = 'Kies je eigen';
z.string.nl.takeoverButtonKeep = 'Behoud deze';

z.string.nl.inviteMetaKeyMac = 'Cmd';
z.string.nl.inviteMetaKeyPc = 'Ctrl';
z.string.nl.inviteHeadline = 'Nodig anderen uit voor Wire';
z.string.nl.inviteMessage = 'Ik gebruik Wire, zoek naar {{username}} of bezoek get.wire.com.';
z.string.nl.inviteMessageNoEmail = 'Ik gebruik Wire. Ga naar get.wire.com om met mij te verbinden.';

z.string.nl.extensionsBubbleButtonGif = 'Gif';

z.string.nl.extensionsGiphyButtonOk = 'Stuur';
z.string.nl.extensionsGiphyButtonMore = 'Probeer een andere';
z.string.nl.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.nl.extensionsGiphyNoGifs = 'Oeps, geen gifjes';
z.string.nl.extensionsGiphyRandom = 'Random';

z.string.nl.addParticipantsConfirmLabel = 'Toevoegen';
z.string.nl.addParticipantsHeader = 'Personen toevoegen';
z.string.nl.addParticipantsSearchPlaceholder = 'Zoeken op naam';
z.string.nl.addParticipantsServiceConfirmButton = 'Service toevoegen';
z.string.nl.addParticipantsTabsPeople = 'Deelnemers';
z.string.nl.addParticipantsTabsServices = 'Services';

z.string.nl.conversationDetailsActionArchive = 'Archiveren';
z.string.nl.conversationDetailsActionAddParticipants = 'Personen toevoegen';
z.string.nl.conversationDetailsActionCancelRequest = 'Annuleer verzoek';
z.string.nl.conversationDetailsActionCreateGroup = 'Nieuwe groep';
z.string.nl.conversationDetailsActionDevices = 'Apparaten';
z.string.nl.conversationDetailsActionNotifications = 'Meldingen';
z.string.nl.conversationDetailsGuestsOff = 'Uit';
z.string.nl.conversationDetailsOptions = 'Opties';
z.string.nl.conversationDetailsParticipantsServicesMany = 'Services';
z.string.nl.conversationDetailsParticipantsUsersMany = 'Deelnemers';
z.string.nl.conversationDetailsPeople = 'Deelnemers';
z.string.nl.conversationDetailsServices = 'Services';

z.string.nl.conversationParticipantsTitle = 'Deelnemers';
z.string.nl.conversationParticipantsSearchPlaceholder = 'Zoeken op naam';

z.string.nl.groupParticipantActionCancelRequest = 'Annuleer verzoek';
z.string.nl.groupParticipantActionDevices = 'Apparaten';
z.string.nl.groupParticipantActionPending = 'In behandeling';
z.string.nl.groupParticipantActionSendRequest = 'Verbind';

z.string.nl.notificationSettingsTitle = 'Meldingen';

z.string.nl.participantDevicesDetailHeadline = 'Verifieer dat deze digitale vingerafdruk overeenkomt met {{html1}}{{user}}s apparaat{{html2}}.';
z.string.nl.participantDevicesDetailHowTo = 'Hoe doe ik dat?';
z.string.nl.participantDevicesDetailResetSession = 'Reset session';
z.string.nl.participantDevicesDetailShowMyDevice = 'Toon de digitale vingerafdruk van mijn apparaat';
z.string.nl.participantDevicesDetailVerify = 'Geverifieerd';

z.string.nl.participantDevicesHeader = 'Apparaten';
z.string.nl.participantDevicesHeadline = 'Wire geeft elk apparaat een unieke vingerafdruk. Vergelijk deze met {{user}} en verifieer het gesprek.';
z.string.nl.participantDevicesLearnMore = 'Leer meer';
z.string.nl.participantDevicesWhyVerify = 'Waarom gesprekken verifiren?';
z.string.nl.participantDevicesOutdatedClientMessage = '{{user}} gebruikt een oude versie van Wire. Er worden daarom geen apparaten getoond.';

z.string.nl.participantDevicesSelfAllDevices = 'Toon al mijn apparaten';
z.string.nl.participantDevicesSelfFingerprint = 'Digitale vingerafdruk';

z.string.nl.userProfileButtonConnect = 'Verbind';
z.string.nl.userProfileButtonIgnore = 'Negeer';
z.string.nl.userProfileButtonUnblock = 'Deblokkeer';

z.string.nl.preferencesAbout = 'Over ons';
z.string.nl.preferencesAccount = 'Profiel';
z.string.nl.preferencesAV = 'Geluid/ film';
z.string.nl.preferencesDeviceDetails = 'Apparaat Details';
z.string.nl.preferencesDevices = 'Apparaten';
z.string.nl.preferencesHeadline = 'Voorkeuren';
z.string.nl.preferencesOptions = 'Opties';

z.string.nl.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.nl.preferencesAboutPrivacyPolicy = 'Privacy Policy';
z.string.nl.preferencesAboutSupport = 'Ondersteuning';
z.string.nl.preferencesAboutSupportWebsite = 'Support Website';
z.string.nl.preferencesAboutSupportContact = 'Contact Support';
z.string.nl.preferencesAboutTermsOfUse = 'Gebruikersvoorwaarden';
z.string.nl.preferencesAboutVersion = 'Versie {{version}}';
z.string.nl.preferencesAboutWebsite = 'Wire Website';

z.string.nl.preferencesAccountAvaibilityUnset = 'Een status instellen';
z.string.nl.preferencesAccountCreateTeam = 'Maak een team';
z.string.nl.preferencesAccountDelete = 'Verwijder account';
z.string.nl.preferencesAccountLogOut = 'Uitloggen';
z.string.nl.preferencesAccountManageTeam = 'Beheer team';
z.string.nl.preferencesAccountResetPassword = 'Reset wachtwoord';
z.string.nl.preferencesAccountTeam = 'in {{name}}';
z.string.nl.preferencesAccountUsernamePlaceholder = 'Je volledige naam';
z.string.nl.preferencesAccountUsernameHint = 'Ten minste 2 tekens. az, 09, en _ alleen.';
z.string.nl.preferencesAccountUsernameAvailable = 'Beschikbaar';
z.string.nl.preferencesAccountUsernameErrorTaken = 'Al in gebruik';

z.string.nl.preferencesAVCamera = 'Camera';
z.string.nl.preferencesAVMicrophone = 'Microfoon';
z.string.nl.preferencesAVPermissionDetail = 'Schakel in vanuit je browser instellingen';
z.string.nl.preferencesAVSpeakers = 'Luidsprekers';

z.string.nl.preferencesDevicesActivatedOn = 'Eerste keer gebruikt op {{date}}';
z.string.nl.preferencesDevicesActive = 'Actief';
z.string.nl.preferencesDevicesActiveDetail = 'Als je een van de bovengenoemde apparaten niet kent, verwijder deze dan en wijzig je wachtwoord.';
z.string.nl.preferencesDevicesCurrent = 'Huidig';
z.string.nl.preferencesDevicesFingerprint = 'Digitale vingerafdruk';
z.string.nl.preferencesDevicesFingerprintDetail = 'Wire geeft elk apparaat een eigen vingerafdruk. Vergelijk deze en verifieer je apparaten en gesprekken.';
z.string.nl.preferencesDevicesId = 'ID: ';
z.string.nl.preferencesDevicesRemoveCancel = 'Annuleer';
z.string.nl.preferencesDevicesRemoveDetail = 'Verwijder dit apparaat als je het niet meer gebruikt. Je berichtengeschiedenis wordt verwijderd op dit apparaat en je wordt uitgelogd.';
z.string.nl.preferencesDevicesSessionConfirmation = 'De sessie is gereset.';
z.string.nl.preferencesDevicesSessionDetail = 'Als de digitale vingerafdruk niet overeenkomt, herstart dan de sessie om nieuwe encryptiesleutels aan te maken op beide apparaten.';
z.string.nl.preferencesDevicesSessionReset = 'Reset session';
z.string.nl.preferencesDevicesSessionOngoing = 'Sessie resetten';
z.string.nl.preferencesDevicesVerification = 'Geverifieerd';

z.string.nl.preferencesOptionsAudio = 'Geluidswaarschuwing';
z.string.nl.preferencesOptionsAudioAll = 'Alle';
z.string.nl.preferencesOptionsAudioAllDetail = 'Alle Geluiden';
z.string.nl.preferencesOptionsAudioNone = 'Geen';
z.string.nl.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.nl.preferencesOptionsAudioSome = 'Sommige';
z.string.nl.preferencesOptionsAudioSomeDetail = 'Pings en oproepen';
z.string.nl.preferencesOptionsContacts = 'Contacten';
z.string.nl.preferencesOptionsContactsGmail = 'Importeren uit Gmail';
z.string.nl.preferencesOptionsContactsMacos = 'Importeren uit contacten';
z.string.nl.preferencesOptionsContactsDetail = 'Dit helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';
z.string.nl.preferencesOptionsPopular = 'Op veler verzoek';
z.string.nl.preferencesOptionsEmojiReplaceCheckbox = 'Getypte emoticons vervangen door emojis';
z.string.nl.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.nl.preferencesOptionsPreviewsSendCheckbox = 'Maak linkvoorbeelden voor links die jij verstuurt';
z.string.nl.preferencesOptionsPreviewsSendDetail = 'Linkvoorbeelden kunnen nog steeds getoond worden voor links van andere mensen.';
z.string.nl.preferencesOptionsNotifications = 'Meldingen';
z.string.nl.preferencesOptionsNotificationsNone = 'Uit';
z.string.nl.preferencesOptionsNotificationsObfuscate = 'Details verbergen';
z.string.nl.preferencesOptionsNotificationsObfuscateMessage = 'Toon zender';
z.string.nl.preferencesOptionsNotificationsOn = 'Toon verzender en bericht';

z.string.nl.backupCancel = 'Annuleer';

z.string.nl.searchConnect = 'Verbind';
z.string.nl.searchConnections = 'Contacten';
z.string.nl.searchContacts = 'Contacten';
z.string.nl.searchCreateGroup = 'Maak groep';
z.string.nl.searchGroups = 'Groepen';
z.string.nl.searchPeople = 'Deelnemers';
z.string.nl.searchPlaceholder = 'Zoek op naam of gebruikersnaam';
z.string.nl.searchServicePlaceholder = 'Zoeken op naam';
z.string.nl.searchServices = 'Services';
z.string.nl.searchTeamGroups = 'Teamgesprekken';
z.string.nl.searchTeamMembers = 'Teamleden';
z.string.nl.searchTopPeople = 'Frequente personen';
z.string.nl.searchTrySearch = 'Vind mensen met hun \nnaam of gebruikersnaam';
z.string.nl.searchNoContactsOnWire = 'Je hebt geen contacten op Wire\nProbeer mensen te vinden met hun\nnaam of gebruikersnaam.';
z.string.nl.searchMemberInvite = 'Nodig andere mensen uit voor het team';
z.string.nl.searchOthers = 'Verbind';

z.string.nl.searchInvite = 'Nodig andere mensen uit voor Wire';
z.string.nl.searchInviteDetail = 'Het delen van je contacten helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';
z.string.nl.searchInviteButtonContacts = 'Van contacten';
z.string.nl.searchInviteButtonGmail = 'Van Gmail';
z.string.nl.searchInviteHeadline = 'Nodig je vrienden uit';
z.string.nl.searchInviteShare = 'Contacten delen';

z.string.nl.searchServiceConfirmButton = 'Service toevoegen';

z.string.nl.searchListEveryoneParticipates = 'Iedereen met wie je contact hebt zit al in dit gesprek.';
z.string.nl.searchListNoMatches = 'Geen overeenkomende resultaten.\nProbeer een andere gebruikersnaam.';

z.string.nl.temporaryGuestCta = 'Een account aanmaken';

z.string.nl.uploadGoogleHeadline = 'Zoek mensen \nom mee te praten.';
z.string.nl.uploadGoogleMessage = 'Dit helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';

z.string.nl.warningCallUnsupportedIncoming = '{{user}} belt, maar je browser ondersteund geen gesprekken.';
z.string.nl.warningCallUnsupportedOutgoing = 'Je kan niet bellen omdat jou browser dit niet ondersteund.';
z.string.nl.warningCallIssues = 'Deze versie kan niet deelnemen met het bellen. Gebruik alsjeblieft';
z.string.nl.warningCallUpgradeBrowser = 'Update Google Chrome om te kunnen bellen.';
z.string.nl.warningConnectivityConnectionLost = 'Wire kan misschien geen berichten versturen. ';
z.string.nl.warningConnectivityNoInternet = 'Geen internet. Je kan nu geen berichten versturen of ontvangen.';
z.string.nl.warningLearnMore = 'Leer meer';
z.string.nl.warningLifecycleUpdate = 'Er is een nieuwe versie van Wire beschikbaar.';
z.string.nl.warningLifecycleUpdateNotes = 'Wat is er nieuw';
z.string.nl.warningLifecycleUpdateLink = 'Nu bijwerken';
z.string.nl.warningNotFoundCamera = 'Je kan niet bellen omdat je computer geen toegang heeft tot je camera.';
z.string.nl.warningNotFoundMicrophone = 'Je kan niet bellen omdat je computer geen toegang heeft tot je microfoon.';
z.string.nl.warningPermissionDeniedCamera = 'Je kan niet bellen omdat je browser geen toegang heeft tot de camera.';
z.string.nl.warningPermissionDeniedMicrophone = 'Je kan niet bellen omdat je browser geen toegang heeft tot de microfoon.';
z.string.nl.warningPermissionDeniedScreen = 'Je browser heeft permissie nodig om je scherm te delen.';
z.string.nl.warningPermissionRequestCamera = '{{icon}} Toegang tot camera toestaan';
z.string.nl.warningPermissionRequestMicrophone = '{{icon}} Toegang tot de microfoon toestaan';
z.string.nl.warningPermissionRequestNotification = '{{icon}} Meldingen toestaan';
z.string.nl.warningPermissionRequestScreen = '{{icon}} Toegang tot scherm toestaan';

z.string.nl.userAvailabilityAvailable = 'Beschikbaar';
z.string.nl.userAvailabilityAway = 'Afwezig';
z.string.nl.userAvailabilityBusy = 'Bezet';
z.string.nl.userAvailabilityNone = 'Geen';

z.string.nl.notificationAssetAdd = 'Deelde een foto';
z.string.nl.notificationConnectionAccepted = 'Accepteer connectie aanvraag';
z.string.nl.notificationConnectionConnected = 'Zijn nu verbonden';
z.string.nl.notificationConnectionRequest = 'Wil met jou verbinden';
z.string.nl.notificationConversationCreate = '{{user}} is een gesprek begonnen';
z.string.nl.notificationConversationRename = '{{user}} heeft het gesprek naar {{name}} hernoemd';
z.string.nl.notificationMemberJoinMany = '{{user}} heeft {{number}} mensen aan het gesprek toegevoegd';
z.string.nl.notificationMemberJoinOne = '{{user1}} heeft {{user2}} aan het gesprek toegevoegd';
z.string.nl.notificationMemberLeaveRemovedYou = '{{user}} verwijderde je uit dit gesprek';
z.string.nl.notificationObfuscated = 'Stuurde je een bericht';
z.string.nl.notificationObfuscatedTitle = 'Iemand';
z.string.nl.notificationPing = 'Gepinged';
z.string.nl.notificationReaction = '{{reaction}} je bericht';
z.string.nl.notificationSharedAudio = 'Deelde een audio bericht';
z.string.nl.notificationSharedFile = 'Deelde een bestand';
z.string.nl.notificationSharedLocation = 'Deel een locatie';
z.string.nl.notificationSharedVideo = 'Deelde een video';
z.string.nl.notificationVoiceChannelActivate = 'Bellen';
z.string.nl.notificationVoiceChannelDeactivate = 'Heeft gebeld';

z.string.nl.tooltipConversationAllVerified = 'Alle vingerafdrukken zijn geverifieerd';
z.string.nl.tooltipConversationCall = 'Oproep';
z.string.nl.tooltipConversationEphemeral = 'Tijdelijk bericht';
z.string.nl.tooltipConversationFile = 'Bestand toevoegen';
z.string.nl.tooltipConversationInputPlaceholder = 'Typ een bericht';
z.string.nl.tooltipConversationInputPlaceholderAvailable = '{{user}} is beschikbaar';
z.string.nl.tooltipConversationInputPlaceholderAway = '{{user}} is afwezig';
z.string.nl.tooltipConversationInputPlaceholderBusy = '{{user}} is bezet';
z.string.nl.tooltipConversationPeople = 'Mensen ({{shortcut}})';
z.string.nl.tooltipConversationPicture = 'Voeg foto toe';
z.string.nl.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.nl.tooltipConversationSearch = 'Zoeken';
z.string.nl.tooltipConversationVideoCall = 'Video-oproep';

z.string.nl.tooltipConversationsArchive = 'Archief ({{shortcut}})';
z.string.nl.tooltipConversationsArchived = 'Toon archief ({{number}})';
z.string.nl.tooltipConversationsMore = 'Meer';
z.string.nl.tooltipConversationsNotify = 'Dempen uit ({{shortcut}})';
z.string.nl.tooltipConversationsPreferences = 'Open instelllingen';
z.string.nl.tooltipConversationsSilence = 'Dempen ({{shortcut}})';
z.string.nl.tooltipConversationsStart = 'Start gesprek ({{shortcut}})';

z.string.nl.tooltipConversationDetailsRename = 'Verander gesprek naam';

z.string.nl.tooltipPreferencesContactsGmail = 'Log in op je Gmail account om je contacten te delen';
z.string.nl.tooltipPreferencesContactsMacos = 'Deel al je contacten van de macOS Contact app';
z.string.nl.tooltipPreferencesPassword = 'Open andere website om je wachtwoord te resetten';
z.string.nl.tooltipPreferencesPicture = 'Verander je foto';
z.string.nl.tooltipPreferencesRename = 'Wijzig je naam';

z.string.nl.tooltipSearchClose = 'Sluiten (esc)';

z.string.nl.initReceivedSelfUser = 'Hallo {{user}}!';
z.string.nl.initValidatedClient = 'Je gesprekken en connecties worden opgehaald';
z.string.nl.initReceivedUserData = 'Controleer voor nieuwe berichten';
z.string.nl.initDecryption = 'Berichten ontsleutelen';
z.string.nl.initEvents = 'Berichten laden';
z.string.nl.initUpdatedFromNotifications = 'Bijna klaar - Geniet van Wire';
z.string.nl.initProgress = '  {{number1}} van {{number2}}';

z.string.nl.ephemeralUnitsNone = 'Uit';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.pl.wireMacos = 'Wire dla macOS';
z.string.pl.wireWindows = 'Wire dla Windows';
z.string.pl.wireLinux = 'Wire dla Linuksa';
z.string.pl.nonexistentUser = 'Uytkownik usunity';
z.string.pl.and = 'oraz';
z.string.pl.enumerationAnd = ', i ';

z.string.pl.authAccountCountryCode = 'Kierunkowy kraju';
z.string.pl.authAccountPasswordForgot = 'Zapomniaem hasa';
z.string.pl.authAccountPublicComputer = 'To jest komputer publiczny';
z.string.pl.authAccountSignIn = 'Zaloguj si';
z.string.pl.authAccountSignInPhone = 'Numer telefonu';

z.string.pl.authBlockedCookies = 'Wcz ciasteczka do zalogowania si do Wire.';
z.string.pl.authBlockedDatabase = 'Wire potrzebuje dostpu do pamici lokalnej, by wywietla wiadomoci. Pami lokalna nie jest dostpna w trybie prywatnym.';
z.string.pl.authBlockedTabs = 'Wire jest ju otwarty w innej zakadce.';

z.string.pl.authVerifyAccountAdd = 'Dodaj';
z.string.pl.authVerifyAccountDetail = 'To pozwala Ci uywa Wire na wicej ni jednym urzdzeniu.';
z.string.pl.authVerifyAccountHeadline = 'Dodaj adres e-mail i haso.';
z.string.pl.authVerifyAccountLogout = 'Wyloguj si';
z.string.pl.authVerifyCodeDescription = 'Wpisz kod weryfikacyjny, ktry wysalimy do {{number}}.';
z.string.pl.authVerifyCodeResend = 'Nie otrzymae(a) kodu?';
z.string.pl.authVerifyCodeResendDetail = 'Wylij ponownie';
z.string.pl.authVerifyCodeResendTimer = 'Moesz poprosi o nowy kod {{expiration}}.';
z.string.pl.authVerifyCodeChangePhone = 'Zmie numer telefonu';
z.string.pl.authVerifyPasswordHeadline = 'Wprowad haso';

z.string.pl.authLimitDevicesHeadline = 'Urzdzenia';
z.string.pl.authLimitDescription = 'eby doda to urzdzenie, usu jedno z poprzednich.';
z.string.pl.authLimitButtonManage = 'Zarzdzaj urzdzeniami';
z.string.pl.authLimitButtonSignOut = 'Wyloguj si';
z.string.pl.authLimitDevicesCurrent = '(Uywane urzdzenie)';

z.string.pl.authHistoryHeadline = 'Uruchomie Wire na tym urzdzeniu po raz pierwszy.';
z.string.pl.authHistoryDescription = 'Ze wzgldu na prywatno, poprzednie rozmowy nie bd tutaj widoczne.';
z.string.pl.authHistoryReuseHeadline = 'Uywae wczeniej Wire na tym urzdzeniu.';
z.string.pl.authHistoryReuseDescription = 'Wiadomoci wysane w midzyczasie nie pojawi si.';
z.string.pl.authHistoryButton = 'OK';

z.string.pl.authPostedResend = 'Wylij ponownie na {{email}}';
z.string.pl.authPostedResendAction = 'Nie otrzymae e-maila?';
z.string.pl.authPostedResendDetail = 'Sprawd swoj skrzynk e-mail i postpuj zgodnie z instrukcjami.';
z.string.pl.authPostedResendHeadline = 'Masz wiadomo.';

z.string.pl.authPlaceholderEmail = 'Adres e-mail';
z.string.pl.authPlaceholderPasswordPut = 'Haso';
z.string.pl.authPlaceholderPasswordSet = 'Haso (musi mie przynajmniej 8 znakw)';
z.string.pl.authPlaceholderPhone = 'Numer telefonu';

z.string.pl.authErrorCode = 'Nieprawidowy kod';
z.string.pl.authErrorCountryCodeInvalid = 'Bdy kierunkowy kraju';
z.string.pl.authErrorEmailExists = 'Adres e-mail ju istnieje';
z.string.pl.authErrorEmailForbidden = 'Przepraszamy. Ten adres e-mail zosta zabroniony.';
z.string.pl.authErrorEmailMalformed = 'Wpisz prosz prawidowy adres e-mail.';
z.string.pl.authErrorEmailMissing = 'Podaj adres e-mail.';
z.string.pl.authErrorMisc = 'Problemy z poczeniem. Prosz sprbowa ponownie.';
z.string.pl.authErrorNameShort = 'Wprowad nazw - musi mie co najmniej 2 znaki';
z.string.pl.authErrorOffline = 'Brak poczenia z Internetem';
z.string.pl.authErrorPasswordShort = 'Wybierz haso - musi mie co najmniej 8 znakw.';
z.string.pl.authErrorPasswordWrong = 'Niewaciwe haso, prosz sprbowa ponownie.';
z.string.pl.authErrorPending = 'Konto niezweryfikowane';
z.string.pl.authErrorPhoneNumberBudget = 'Zbyt wiele prb logowania. Odczekaj chwil i sprbuj ponownie.';
z.string.pl.authErrorPhoneNumberForbidden = 'Przepraszamy. Ten numer telefonu zosta zabroniony.';
z.string.pl.authErrorPhoneNumberInvalid = 'Nieprawidowy numer telefonu';
z.string.pl.authErrorPhoneNumberUnknown = 'Nieznany numer telefonu';
z.string.pl.authErrorSuspended = 'To konto jest ju uprawnione do zalogowania si.';
z.string.pl.authErrorSignIn = 'Prosz sprawdzi swoje dane i sprbowa ponownie.';

z.string.pl.callStateOutgoing = 'Dzwoni';
z.string.pl.callStateConnecting = 'czenie';
z.string.pl.callStateIncoming = 'Dzwoni';
z.string.pl.callDecline = 'Odrzu';
z.string.pl.callAccept = 'Odbierz';
z.string.pl.callJoin = 'Docz';
z.string.pl.callChooseSharedScreen = 'Wybierz ekran do wspdzielenia';
z.string.pl.callParticipants = '{{number}} uczestnikw';

z.string.pl.videoCallOverlayMute = 'Wycisz';
z.string.pl.videoCallOverlayHangUp = 'Rozcz';

z.string.pl.modalAcknowledgeAction = 'OK';
z.string.pl.modalAcknowledgeHeadline = 'Co poszo nie tak';
z.string.pl.modalConfirmSecondary = 'Anuluj';
z.string.pl.modalOptionSecondary = 'Anuluj';

z.string.pl.modalAccountCreateAction = 'OK';
z.string.pl.modalAccountCreateHeadline = 'Utwrz konto';

z.string.pl.modalAccountDeletionAction = 'Usu';
z.string.pl.modalAccountDeletionHeadline = 'Usu konto';
z.string.pl.modalAccountDeletionMessage = 'Wylemy wiadomo poprzez e-mail lub SMS. Prosz uy tego odnonika, eby trwale usun konto.';

z.string.pl.modalAccountLeaveGuestRoomAction = 'Opu';
z.string.pl.modalAccountLeaveGuestRoomHeadline = 'Opu pokj goci.';
z.string.pl.modalAccountLeaveGuestRoomMessage = 'Historia konwersacji zostanie usunita. eby jzatrzyma, nastpnym razem utwrz konto.';

z.string.pl.modalAccountLogoutAction = 'Wyloguj si';
z.string.pl.modalAccountLogoutHeadline = 'Usun dane?';
z.string.pl.modalAccountLogoutOption = 'Usu wszystkie informacje osobiste i histori rozmw na tym urzdzeniu.';

z.string.pl.modalAccountNewDevicesSecondary = 'Zarzdzaj urzdzeniami';
z.string.pl.modalAccountNewDevicesHeadline = 'Twoje konto byo ostatnio uyte:';
z.string.pl.modalAccountNewDevicesFrom = 'Z:';
z.string.pl.modalAccountNewDevicesMessage = 'Jeeli nie rozpoznajesz tego, usu urzdzenie z listy i zmie swoje haso.';

z.string.pl.modalAccountRemoveDeviceAction = 'Usu urzdzenie';
z.string.pl.modalAccountRemoveDeviceHeadline = 'Usu {{device}}';
z.string.pl.modalAccountRemoveDeviceMessage = 'Aby usun to urzdzenie wymagane jest haso.';
z.string.pl.modalAccountRemoveDevicePlaceholder = 'Haso';

z.string.pl.modalAssetTooLargeHeadline = 'Plik jest zbyt duy';
z.string.pl.modalAssetTooLargeMessage = 'Plik jest za duy. Maksymalny rozmiar pliku to {{number}}';

z.string.pl.modalAssetParallelUploadsHeadline = 'Za duo plikw naraz';
z.string.pl.modalAssetParallelUploadsMessage = 'Jednorazowo moesz wysa maksymalnie {{number}} plikw.';

z.string.pl.modalCallEmptyConversationHeadline = 'Brak rozmwcy';
z.string.pl.modalCallEmptyConversationMessage = 'Nikogo tutaj nie ma.';

z.string.pl.modalCallEmptyLogHeadline = 'Nie ma pocze';

z.string.pl.modalCallNoGroupVideoHeadline = 'Grupowe poczenia video nie s moliwe';
z.string.pl.modalCallNoGroupVideoMessage = 'Grupowe poczenia wideo nie s moliwe.';

z.string.pl.modalCallNoMicrophoneAction = 'Powiedz mi jak';
z.string.pl.modalCallNoMicrophoneMessage = 'Aby wykonywa poczenia, Twoja przegldarka musi mie dostp do mikrofonu.';
z.string.pl.modalCallNoMicrophoneHeadline = 'Nie mona dzwoni bez mikrofonu';

z.string.pl.modalCallSecondIncomingAction = 'Odbierz';
z.string.pl.modalCallSecondIncomingHeadline = 'Odebra poczenie?';
z.string.pl.modalCallSecondIncomingMessage = 'Biece poczenie zostanie zakoczone.';

z.string.pl.modalCallSecondOngoingAction = 'Rozcz';
z.string.pl.modalCallSecondOngoingHeadline = 'Zakoczy poczenie na innym urzdzeniu?';
z.string.pl.modalCallSecondOngoingMessage = 'Tylko jedno poczenie na raz jest moliwe.';

z.string.pl.modalCallSecondOutgoingAction = 'Rozcz';
z.string.pl.modalCallSecondOutgoingHeadline = 'Zakoczy biece poczenie?';
z.string.pl.modalCallSecondOutgoingMessage = 'Tylko jedno poczenie na raz jest moliwe.';

z.string.pl.modalConnectCancelAction = 'Tak';
z.string.pl.modalConnectCancelHeadline = 'Anuluj danie?';
z.string.pl.modalConnectCancelMessage = 'Usu danie poczenia z {{user}}.';
z.string.pl.modalConnectCancelSecondary = 'Nie';

z.string.pl.modalConnectAcceptAction = 'Pocz';
z.string.pl.modalConnectAcceptHeadline = 'Zaakceptowa?';
z.string.pl.modalConnectAcceptMessage = 'Ta akcja doda uytkownika {{user}} do listy kontaktw i rozpocznie rozmow.';
z.string.pl.modalConnectAcceptSecondary = 'Ignoruj';

z.string.pl.modalConversationClearAction = 'Usu';
z.string.pl.modalConversationClearHeadline = 'Usun zawarto?';
z.string.pl.modalConversationClearMessage = 'To wyczyci histori rozmowy na wszystkich Twoich urzdzeniach.';
z.string.pl.modalConversationClearOption = 'Rwnie opu rozmow';

z.string.pl.modalConversationDeleteMessageAction = 'Usu';
z.string.pl.modalConversationDeleteMessageHeadline = 'Usu tylko dla mnie?';
z.string.pl.modalConversationDeleteMessageMessage = 'Tego nie mona cofn.';

z.string.pl.modalConversationDeleteMessageEveryoneAction = 'Usu';
z.string.pl.modalConversationDeleteMessageEveryoneHeadline = 'Usun dla wszystkich?';
z.string.pl.modalConversationDeleteMessageEveryoneMessage = 'Tego nie mona cofn.';

z.string.pl.modalConversationLeaveAction = 'Opu';
z.string.pl.modalConversationLeaveHeadline = 'Opuci rozmow {{name}}?';
z.string.pl.modalConversationLeaveMessage = 'Nie bdziesz mg wysya ani odbiera wiadomoci w tej rozmowie.';

z.string.pl.modalConversationMessageTooLongHeadline = 'Wiadomo jest zbyt duga';
z.string.pl.modalConversationMessageTooLongMessage = 'Moesz wysya wiadomoci nie dusze ni {{number}} znakw.';

z.string.pl.modalConversationNewDeviceAction = 'Wylij mimo wszystko';
z.string.pl.modalConversationNewDeviceHeadlineOne = '{{user}} zacz korzysta z nowego urzdzenia';
z.string.pl.modalConversationNewDeviceHeadlineMany = '{{users}} zaczli korzysta z nowych urzdze';
z.string.pl.modalConversationNewDeviceHeadlineYou = '{{user}} zacz korzysta z nowego urzdzenia';
z.string.pl.modalConversationNewDeviceIncomingCallAction = 'Zaakceptuj poczenie';
z.string.pl.modalConversationNewDeviceIncomingCallMessage = 'Czy nadal chcesz odebra poczenie?';
z.string.pl.modalConversationNewDeviceMessage = 'Czy nadal chcesz wysa wiadomoci?';
z.string.pl.modalConversationNewDeviceOutgoingCallAction = 'Dzwo mimo to';
z.string.pl.modalConversationNewDeviceOutgoingCallMessage = 'Czy nadal chcesz nawiza poczenie?';

z.string.pl.modalConversationNotConnectedHeadline = 'Nikt nie zosta dodany do rozmowy';
z.string.pl.modalConversationNotConnectedMessageOne = '{{name}} nie chce by dodany do rozmowy.';
z.string.pl.modalConversationNotConnectedMessageMany = 'Jedna z osb, ktr wybrae, nie chce by dodana do rozmowy.';

z.string.pl.modalConversationRemoveAction = 'Usu';
z.string.pl.modalConversationRemoveHeadline = 'Usun?';
z.string.pl.modalConversationRemoveMessage = '{{user}} nie bdzie mg wysya, ani odbiera wiadomoci w tej rozmowie.';

z.string.pl.modalConversationRemoveGuestsAction = 'Usu goci';
z.string.pl.modalConversationRemoveGuestsHeadline = 'Wyczy dostp dla goci?';

z.string.pl.modalConversationTooManyMembersHeadline = 'Zbyt wielu uczestnikw rozmowy';

z.string.pl.modalGifTooLargeMessage = 'Maksymalny rozmiar to {{number}} MB.';

z.string.pl.modalIntegrationUnavailableHeadline = 'Boty s obecnie niedostpne';
z.string.pl.modalIntegrationUnavailableMessage = 'Dzikujemy za zainteresowanie naszymi botami. Usuga jest obecnie zawieszona, poniewa pracujemy nad nastpn wersj. Bd na bieco.';

z.string.pl.modalPictureFileFormatHeadline = 'Nie mona uy tego obrazu';
z.string.pl.modalPictureFileFormatMessage = 'Prosz wybraplik PNG lub JPEG.';

z.string.pl.modalPictureTooLargeHeadline = 'Wybrany obraz jest za duy';

z.string.pl.modalPictureTooSmallHeadline = 'Obrazek jest zbyt may';

z.string.pl.modalImproveWireAction = 'Odbierz';
z.string.pl.modalImproveWireSecondary = 'Nie teraz';
z.string.pl.modalImproveWireHeadline = 'Pom nam ulepszy Wire';

z.string.pl.modalServiceUnavailableHeadline = 'Dodanie usugi jest niemoliwe';

z.string.pl.modalSessionResetHeadline = 'Sesja zostaa zresetowana';
z.string.pl.modalSessionResetMessage1 = 'Jeli problem nie zostanie rozwizany,';
z.string.pl.modalSessionResetMessageLink = 'kontakt';
z.string.pl.modalSessionResetMessage2 = 'nas.';

z.string.pl.modalUploadContactsAction = 'Sprbuj ponownie';
z.string.pl.modalUploadContactsMessage = 'Nie otrzymalimy Twoich informacji. Sprbuj ponownie zaimportowa swoje kontakty.';

z.string.pl.modalUserBlockAction = 'Zablokuj';
z.string.pl.modalUserBlockHeadline = 'Zablokowa {{user}}?';
z.string.pl.modalUserBlockMessage = '{{user}} nie bdzie mg si z Tob skontaktowa, ani doda do rozmowy grupowej.';

z.string.pl.modalUserUnblockAction = 'Odblokuj';
z.string.pl.modalUserUnblockHeadline = 'Odblokowa?';
z.string.pl.modalUserUnblockMessage = '{{user}} bdzie mg si z Tob skontaktowa oraz doda do rozmowy grupowej.';

z.string.pl.connectionRequestConnect = 'Pocz';
z.string.pl.connectionRequestIgnore = 'Ignoruj';

z.string.pl.conversationGuestIndicator = 'Go';
z.string.pl.userRemainingTimeHours = 'Zostao {{time}}h';
z.string.pl.userRemainingTimeMinutes = 'Zostao mniej, ni {{time}}min';

z.string.pl.conversationYouNominative = 'ty';
z.string.pl.conversationYouDative = 'ty';
z.string.pl.conversationYouAccusative = 'ty';

z.string.pl.conversationConnectionAccepted = 'Poczony';
z.string.pl.conversationConnectionBlocked = 'Zablokowano';
z.string.pl.conversationConnectionCancelRequest = 'Anuluj danie poczenia';
z.string.pl.conversationCreateTemporary = 'Doczye do konwersacji';
z.string.pl.conversationCreateWith = 'z {{users}}';
z.string.pl.conversationDeviceStartedUsingOne = ' rozpoczto korzystanie';
z.string.pl.conversationDeviceStartedUsingMany = ' rozpoczto korzystanie';
z.string.pl.conversationDeviceUnverified = ' %@ nie zweryfikowa jednego z %@';
z.string.pl.conversationDeviceYourDevices = ' twoje urzdzenia';
z.string.pl.conversationDeviceUserDevices = ' urzdzenia uytkownika {{user}}';
z.string.pl.conversationDeviceNewDeviceOne = ' nowe urzdzenie';
z.string.pl.conversationDeviceNewDeviceMany = ' nowe urzdzenia';
z.string.pl.conversationDeviceNewPeopleJoinedVerify = ' sprawdzenie urzdzenia';
z.string.pl.conversationJustNow = 'Przed chwil';
z.string.pl.conversationLocationLink = 'Otwrz map';
z.string.pl.conversationMessageDelivered = 'Dostarczono';
z.string.pl.conversationRename = ' %@ zmieni nazw konwersacji';
z.string.pl.conversationRenameYou = ' %@ zmieni nazw konwersacji';
z.string.pl.conversationResume = 'Rozpocz rozmow z {{users}}';
z.string.pl.conversationPing = ' zaczepi/a';
z.string.pl.conversationPingYou = ' zaczepi/a';
z.string.pl.conversationToday = 'dzisiaj';
z.string.pl.conversationVoiceChannelDeactivate = ' poczono';
z.string.pl.conversationVoiceChannelDeactivateYou = ' poczono';
z.string.pl.conversationYesterday = 'Wczoraj';
z.string.pl.conversationUnableToDecrypt1 = 'wiadomo od {{user}} nie zostaa dostarczona.';
z.string.pl.conversationUnableToDecrypt2 = 'Uytkownik {{user}} zmieni urzdzenie. Wiadomo nie zostaa dostarczona.';
z.string.pl.conversationUnableToDecryptLink = 'Dlaczego?';
z.string.pl.conversationUnableToDecryptErrorMessage = 'Bd';
z.string.pl.conversationUnableToDecryptResetSession = 'Resetowanie sesji';
z.string.pl.conversationMissedMessages = 'Do dugo nie uywae tego urzdzenia. Niektre wiadomoci mog nie by widoczne.';
z.string.pl.conversationAssetDownloading = 'Pobieranie';
z.string.pl.conversationAssetUploadFailed = 'Bd wysyania';
z.string.pl.conversationPlaybackError = 'Nie mona odtworzy';
z.string.pl.conversationContextMenuCopy = 'Kopiuj';
z.string.pl.conversationContextMenuEdit = 'Edycja';
z.string.pl.conversationContextMenuDelete = 'Usu dla mnie';
z.string.pl.conversationContextMenuDeleteEveryone = 'Usu dla wszystkich';
z.string.pl.conversationContextMenuDownload = 'Pobierz';
z.string.pl.conversationContextMenuLike = 'Polub';
z.string.pl.conversationContextMenuUnlike = 'Przesta lubi';
z.string.pl.conversationDeleteTimestamp = 'Usunity: {{date}}';
z.string.pl.conversationEditTimestamp = 'Edytowany: {{date}}';
z.string.pl.conversationLikesCaption = '{{number}} uczestnikw';
z.string.pl.conversationSendPastedFile = 'Wklejono obraz {{date}}';
z.string.pl.conversationSomeone = 'Kto';
z.string.pl.conversationTweetAuthor = ' na Twitterze';

z.string.pl.groupCreationPreferencesAction = 'Dalej';
z.string.pl.groupCreationParticipantsActionCreate = 'Zakoczono';
z.string.pl.groupCreationParticipantsPlaceholder = 'Szukaj wedug nazwy';


z.string.pl.collectionShowAll = 'Poka wszystkie {{number}}';
z.string.pl.collectionSectionLinks = 'Linki';
z.string.pl.collectionSectionImages = 'Zdjcia';
z.string.pl.collectionSectionFiles = 'Pliki';
z.string.pl.collectionSectionAudio = 'Wiadomoci audio';

z.string.pl.fullsearchPlaceholder = 'Wyszukiwanie wiadomoci';
z.string.pl.fullsearchNoResults = 'Brak wynikw.';

z.string.pl.archiveHeader = 'Archiwizuj';

z.string.pl.conversationsAllArchived = 'Wszystko zarchiwizowane';
z.string.pl.conversationsContacts = 'Kontakty';
z.string.pl.conversationsConnectionRequestMany = '{{number}} osb oczekujcych';
z.string.pl.conversationsConnectionRequestOne = '1 osoba czeka';
z.string.pl.conversationsEmptyConversation = 'Rozmowa grupowa';
z.string.pl.conversationsNoConversations = 'Brak jeszcze konwersacji';
z.string.pl.conversationsPopoverArchive = 'Archiwizuj';
z.string.pl.conversationsPopoverCancel = 'Anuluj danie';
z.string.pl.conversationsPopoverNotify = 'Wcz dwik';
z.string.pl.conversationsPopoverSilence = 'Wycisz';
z.string.pl.conversationsPopoverUnarchive = 'Przywr z archiwum';

z.string.pl.conversationsSecondaryLineEphemeralMessage = 'Wysa(a) ci wiadomo';
z.string.pl.conversationsSecondaryLinePeopleLeft = '{{number}} osoby/b opuciy/o rozmow';
z.string.pl.conversationsSecondaryLinePersonLeft = '{{user}} wyszed';
z.string.pl.conversationsSecondaryLinePersonRemoved = '{{user}} zosta usunity';
z.string.pl.conversationsSecondaryLinePeopleAdded = 'dodanych osb: {{user}}';
z.string.pl.conversationsSecondaryLinePersonAdded = '{{user}} zosta dodany';
z.string.pl.conversationsSecondaryLinePersonAddedYou = '{{user}} doda Ci';
z.string.pl.conversationsSecondaryLineRenamed = '{{user}} zmieniono nazw konwersacji';
z.string.pl.conversationsSecondaryLineYouLeft = 'Opucie/a';
z.string.pl.conversationsSecondaryLineYouWereRemoved = 'Zostae usunity/Zostaa usunita';

z.string.pl.takeoverSub = 'Wybierz swoj unikaln nazw w Wire.';
z.string.pl.takeoverLink = 'Wicej informacji';
z.string.pl.takeoverButtonChoose = 'Wybierz swj wasny';
z.string.pl.takeoverButtonKeep = 'Zachowaj wybrany';

z.string.pl.inviteMetaKeyMac = 'Cmd';
z.string.pl.inviteMetaKeyPc = 'Ctrl';
z.string.pl.inviteHeadline = 'Zapro innych do Wire';
z.string.pl.inviteMessage = 'Jestem na Wire. Odszukaj {{username}}, lub odwied get.wire.com.';
z.string.pl.inviteMessageNoEmail = 'Uywam Wire. Wejd na get.wire.com aby si ze mn poczy.';

z.string.pl.extensionsBubbleButtonGif = 'Gif';

z.string.pl.extensionsGiphyButtonOk = 'Wylij';
z.string.pl.extensionsGiphyButtonMore = 'Sprbuj uy innego';
z.string.pl.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.pl.extensionsGiphyNoGifs = 'Ups, nie ma plikw Gif';
z.string.pl.extensionsGiphyRandom = 'Losowa kolejno';

z.string.pl.addParticipantsConfirmLabel = 'Dodaj';
z.string.pl.addParticipantsSearchPlaceholder = 'Szukaj wedug nazwy';
z.string.pl.addParticipantsTabsPeople = 'Osoby';
z.string.pl.addParticipantsTabsServices = 'Usugi';

z.string.pl.conversationDetailsActionArchive = 'Archiwizuj';
z.string.pl.conversationDetailsActionCancelRequest = 'Anuluj danie';
z.string.pl.conversationDetailsActionDevices = 'Urzdzenia';
z.string.pl.conversationDetailsActionNotifications = 'Powiadomienia';
z.string.pl.conversationDetailsGuestsOff = 'Wycz';
z.string.pl.conversationDetailsOptions = 'Opcje';
z.string.pl.conversationDetailsParticipantsServicesMany = 'Usugi';
z.string.pl.conversationDetailsParticipantsUsersMany = 'Osoby';
z.string.pl.conversationDetailsPeople = 'Osoby';
z.string.pl.conversationDetailsServices = 'Usugi';

z.string.pl.conversationParticipantsTitle = 'Osoby';
z.string.pl.conversationParticipantsSearchPlaceholder = 'Szukaj wedug nazwy';

z.string.pl.groupParticipantActionCancelRequest = 'Anuluj danie';
z.string.pl.groupParticipantActionDevices = 'Urzdzenia';
z.string.pl.groupParticipantActionPending = 'W toku';
z.string.pl.groupParticipantActionSendRequest = 'Pocz';

z.string.pl.notificationSettingsTitle = 'Powiadomienia';

z.string.pl.participantDevicesDetailHeadline = 'Sprawd, czy to odpowiada kluczowi widocznemu na {{html1}}{{user}} urzdzenia {{html2}}.';
z.string.pl.participantDevicesDetailHowTo = 'Jak to zrobi?';
z.string.pl.participantDevicesDetailResetSession = 'Resetowanie sesji';
z.string.pl.participantDevicesDetailShowMyDevice = 'Poka kody zabezpiecze moich urzdze';
z.string.pl.participantDevicesDetailVerify = 'Zweryfikowano';

z.string.pl.participantDevicesHeader = 'Urzdzenia';
z.string.pl.participantDevicesHeadline = 'Wire nadaje kademu urzdzeniu unikatowy odcisk palca. Porwnaj go z list urzdze uytkownika {{user}} i sprawd swoje rozmowy.';
z.string.pl.participantDevicesLearnMore = 'Wicej informacji';
z.string.pl.participantDevicesWhyVerify = 'Dlaczego weryfikowa konwersacje?';
z.string.pl.participantDevicesOutdatedClientMessage = '{{user}} uywa starszej wersji Wire. Brak urzdze do wywietlenia.';

z.string.pl.participantDevicesSelfAllDevices = 'Poka wszystkie moje urzdzenia';
z.string.pl.participantDevicesSelfFingerprint = 'Odcisk palca urzdzenia';

z.string.pl.userProfileButtonConnect = 'Pocz';
z.string.pl.userProfileButtonIgnore = 'Ignoruj';
z.string.pl.userProfileButtonUnblock = 'Odblokuj';

z.string.pl.preferencesAbout = 'O programie';
z.string.pl.preferencesAccount = 'Konto';
z.string.pl.preferencesAV = 'Dwik / Wideo';
z.string.pl.preferencesDeviceDetails = 'Szczegy Urzdzenia';
z.string.pl.preferencesDevices = 'Urzdzenia';
z.string.pl.preferencesHeadline = 'Ustawienia';
z.string.pl.preferencesOptions = 'Opcje';

z.string.pl.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.pl.preferencesAboutPrivacyPolicy = 'Polityka prywatnoci';
z.string.pl.preferencesAboutSupport = 'Wsparcie';
z.string.pl.preferencesAboutSupportWebsite = 'Witryna pomocy technicznej';
z.string.pl.preferencesAboutSupportContact = 'Kontakt z pomoc techniczn';
z.string.pl.preferencesAboutTermsOfUse = 'Regulamin';
z.string.pl.preferencesAboutVersion = 'Wersja {{version}}';
z.string.pl.preferencesAboutWebsite = 'Strona internetowa Wire';

z.string.pl.preferencesAccountCreateTeam = 'Utwrz nowy zesp';
z.string.pl.preferencesAccountDelete = 'Usu konto';
z.string.pl.preferencesAccountLogOut = 'Wyloguj si';
z.string.pl.preferencesAccountManageTeam = 'Zarzdzaj zespoem';
z.string.pl.preferencesAccountResetPassword = 'Zresetuj haso';
z.string.pl.preferencesAccountTeam = 'w {{name}}';
z.string.pl.preferencesAccountUsernamePlaceholder = 'Twoje pene imi inazwisko';
z.string.pl.preferencesAccountUsernameHint = 'Co najmniej 2 znaki. Tylko a-z, 0-9, _.';
z.string.pl.preferencesAccountUsernameAvailable = '&Dostpny(a)';
z.string.pl.preferencesAccountUsernameErrorTaken = 'Jest ju w uyciu';

z.string.pl.preferencesAVCamera = 'Aparat';
z.string.pl.preferencesAVMicrophone = 'Mikrofon';
z.string.pl.preferencesAVPermissionDetail = 'Wcz w Preferencjach Twojej przegldarki';
z.string.pl.preferencesAVSpeakers = 'Goniki';

z.string.pl.preferencesDevicesActivatedOn = 'Aktywowano {{date}}';
z.string.pl.preferencesDevicesActive = 'Aktywne';
z.string.pl.preferencesDevicesActiveDetail = 'Jeli nie rozpoznajesz urzdzenia poniej, usu je i zresetuj haso.';
z.string.pl.preferencesDevicesCurrent = 'Aktualny';
z.string.pl.preferencesDevicesFingerprint = 'Unikalny odcisk palca';
z.string.pl.preferencesDevicesFingerprintDetail = 'Wire daje kademu urzdzeniowi unikalny odcisk palca. Porwnaj i sprawd swoje urzdzenia oraz konwersacje.';
z.string.pl.preferencesDevicesId = 'ID: ';
z.string.pl.preferencesDevicesRemoveCancel = 'Anuluj';
z.string.pl.preferencesDevicesRemoveDetail = 'Usu urzdzenie, jeli przestae je uywa. Bdziesz natychmiast wylogowany z tego urzdzenia.';
z.string.pl.preferencesDevicesSessionConfirmation = 'Sesja zostaa zresetowana.';
z.string.pl.preferencesDevicesSessionDetail = 'Jeli odciski palca nie pasuj, zresetuj sesj, aby wygenerowa nowe klucze po obu stronach.';
z.string.pl.preferencesDevicesSessionReset = 'Resetowanie sesji';
z.string.pl.preferencesDevicesSessionOngoing = 'Resetowanie sesji';
z.string.pl.preferencesDevicesVerification = 'Zweryfikowano';

z.string.pl.preferencesOptionsAudio = 'Alarm dwikowy';
z.string.pl.preferencesOptionsAudioAll = 'Wszystko';
z.string.pl.preferencesOptionsAudioAllDetail = 'Wszystkie dwiki';
z.string.pl.preferencesOptionsAudioNone = 'aden';
z.string.pl.preferencesOptionsAudioNoneDetail = 'Csiiii!';
z.string.pl.preferencesOptionsAudioSome = 'Niektre';
z.string.pl.preferencesOptionsAudioSomeDetail = 'Pingi i poczenia';
z.string.pl.preferencesOptionsContacts = 'Kontakty';
z.string.pl.preferencesOptionsContactsGmail = 'Import z Gmail';
z.string.pl.preferencesOptionsContactsMacos = 'Import z Kontaktw';
z.string.pl.preferencesOptionsContactsDetail = 'Wykorzystujemy Twoje dane kontaktowe do czenia Ci z innymi. Wszystkie informacje s anonimowe i nie dzielimy ich z nikim innym.';
z.string.pl.preferencesOptionsPopular = 'Rne';
z.string.pl.preferencesOptionsEmojiReplaceCheckbox = 'Zastpuj tekstowe emotikony ikonkami';
z.string.pl.preferencesOptionsPreviewsSendCheckbox = 'Twrz podgldy wysyanych linkw';
z.string.pl.preferencesOptionsPreviewsSendDetail = 'Podgldy linkw otrzymanych od innych osb mog by nadal wywietlane.';
z.string.pl.preferencesOptionsNotifications = 'Powiadomienia';
z.string.pl.preferencesOptionsNotificationsNone = 'Wycz';
z.string.pl.preferencesOptionsNotificationsObfuscate = 'Ukryj szczegy';
z.string.pl.preferencesOptionsNotificationsObfuscateMessage = 'Poka nadawc';
z.string.pl.preferencesOptionsNotificationsOn = 'Poka nadawc i wiadomoci';

z.string.pl.backupImportGenericErrorHeadline = 'Co poszo nie tak';
z.string.pl.backupCancel = 'Anuluj';

z.string.pl.searchConnect = 'Pocz';
z.string.pl.searchConnections = 'Poczenia';
z.string.pl.searchContacts = 'Kontakty';
z.string.pl.searchCreateGroup = 'Stwrz grup';
z.string.pl.searchGroups = 'Grupy';
z.string.pl.searchPeople = 'Osoby';
z.string.pl.searchPlaceholder = 'Szukaj wedug nazwy lub nazwy uytkownika';
z.string.pl.searchServicePlaceholder = 'Szukaj wedug nazwy';
z.string.pl.searchServices = 'Usugi';
z.string.pl.searchTeamGroups = 'Grupowe rozmowy';
z.string.pl.searchTeamMembers = 'Czonkowie zespou';
z.string.pl.searchTopPeople = 'Osoby';
z.string.pl.searchTrySearch = 'Znajd osoby wedug nazwy lub nazwy uytkownika';
z.string.pl.searchNoContactsOnWire = 'Nie masz dodanych adnych kontaktw Sprbuj wyszuka osoby wedug nazwy lub nazwy uytkownika.';
z.string.pl.searchOthers = 'Pocz';

z.string.pl.searchInvite = 'Zapro innych do Wire';
z.string.pl.searchInviteDetail = 'Udostpnianie kontaktw pomaga poczy si z innymi. Wszystkie informacje s anonimowe i nie udostpniamy ich nikomu.';
z.string.pl.searchInviteButtonContacts = 'Z kontaktw';
z.string.pl.searchInviteButtonGmail = 'Z Gmaila';
z.string.pl.searchInviteHeadline = 'Zapro znajomych';
z.string.pl.searchInviteShare = 'Udostpnij kontakty';

z.string.pl.searchListEveryoneParticipates = 'Wszyscy, z ktrymi masz poczenie s ju w tej konwersacji.';
z.string.pl.searchListNoMatches = 'Brak wynikw. Sprbuj wprowadzi inn nazw.';

z.string.pl.temporaryGuestCta = 'Utwrz konto';

z.string.pl.uploadGoogleHeadline = 'Znajd osoby do rozmowy.';
z.string.pl.uploadGoogleMessage = 'Wykorzystujemy Twoje dane kontaktowe do czenia Ci z innymi. Wszystkie informacje s anonimowe i nie dzielimy ich z nikim innym.';

z.string.pl.warningCallUnsupportedIncoming = 'Dzwoni {{user}}. Twoja przegldarka nie obsuguje rozmw.';
z.string.pl.warningCallUnsupportedOutgoing = 'Nie moesz zadzwoni, poniewa Twoja przegldarka nie obsuguje rozmw.';
z.string.pl.warningCallIssues = 'Ta wersja Wire nie moe bra udziau w rozmowie. Prosz uyj';
z.string.pl.warningCallUpgradeBrowser = 'Uaktualnij Google Chrome aby zadzwoni.';
z.string.pl.warningConnectivityConnectionLost = 'Prbuje si poczy. Wire moe nie by w stanie dostarczy wiadomoci.';
z.string.pl.warningConnectivityNoInternet = 'Brak internetu. Wire nie bdzie w stanie wysya i odbiera wiadomoci.';
z.string.pl.warningLearnMore = 'Wicej informacji';
z.string.pl.warningLifecycleUpdate = 'Nowa wersja "%@" ju dostpna.';
z.string.pl.warningLifecycleUpdateNotes = 'Co nowego';
z.string.pl.warningLifecycleUpdateLink = 'Aktualizuj teraz';
z.string.pl.warningNotFoundCamera = 'Nie moesz zadzwoni poniewa Twj komputer nie ma kamery.';
z.string.pl.warningNotFoundMicrophone = 'Nie moesz zadzwoni poniewa Twj komputer nie ma mikrofonu.';
z.string.pl.warningPermissionDeniedCamera = 'Nie moesz zadzwoni poniewa przegldarka nie ma dostpu do kamery.';
z.string.pl.warningPermissionDeniedMicrophone = 'Nie moesz zadzwoni poniewa przegldarka nie ma dostpu do mikrofonu.';
z.string.pl.warningPermissionDeniedScreen = 'Twoja przegldarka potrzebuje pozwolenia aby pokaza pulpit.';
z.string.pl.warningPermissionRequestCamera = '{{icon}} Zezwl na dostp do aparatu';
z.string.pl.warningPermissionRequestMicrophone = '{{icon}} Zezwl na dostp do mikrofonu';
z.string.pl.warningPermissionRequestNotification = '{{icon}} Zezwl na powiadomienia';
z.string.pl.warningPermissionRequestScreen = '{{icon}} zezwl na dostp do ekranu';

z.string.pl.userAvailabilityAvailable = '&Dostpny(a)';
z.string.pl.userAvailabilityNone = 'aden';

z.string.pl.notificationAssetAdd = 'Udostpni obrazek';
z.string.pl.notificationConnectionAccepted = 'Zaakceptowane dania poczenia';
z.string.pl.notificationConnectionConnected = 'Jeste ju poczony';
z.string.pl.notificationConnectionRequest = '%@ chce si poczy';
z.string.pl.notificationConversationCreate = '{{user}} rozpocz rozmow';
z.string.pl.notificationConversationRename = '{{user}} zmieni nazw konwersacji na {{name}}';
z.string.pl.notificationMemberJoinMany = '{{user}} doda(a) {{number}} nowych osb do rozmowy';
z.string.pl.notificationMemberJoinOne = '{{user1}} doda(a) {{user2}} do rozmowy';
z.string.pl.notificationMemberLeaveRemovedYou = '{{user}} usun ci z rozmowy';
z.string.pl.notificationObfuscated = 'Wysa(a) ci wiadomo';
z.string.pl.notificationObfuscatedTitle = 'Kto';
z.string.pl.notificationPing = 'Zaczepi/a';
z.string.pl.notificationReaction = '{{reaction}} na Twoj wiadomo';
z.string.pl.notificationSharedAudio = 'Udostpnij wiadomo audio';
z.string.pl.notificationSharedFile = 'Udostpni/a plik';
z.string.pl.notificationSharedLocation = 'Udostpniana lokalizacja';
z.string.pl.notificationSharedVideo = 'Udostpniane wideo';
z.string.pl.notificationVoiceChannelActivate = 'czenie';
z.string.pl.notificationVoiceChannelDeactivate = 'Dzwoni';

z.string.pl.tooltipConversationAllVerified = 'Wszystkie odciski palcw s zweryfikowane';
z.string.pl.tooltipConversationCall = 'Zadzwo';
z.string.pl.tooltipConversationEphemeral = 'Wiadomo tymczasowa';
z.string.pl.tooltipConversationFile = 'Dodaj plik';
z.string.pl.tooltipConversationInputPlaceholder = 'Wpisz wiadomo';
z.string.pl.tooltipConversationPeople = 'Uytkownicy ({{shortcut}})';
z.string.pl.tooltipConversationPicture = 'Dodaj zdjcie';
z.string.pl.tooltipConversationPing = 'Zaczep ({{shortcut}})';
z.string.pl.tooltipConversationSearch = 'Wyszukaj';
z.string.pl.tooltipConversationVideoCall = 'Poczenie video';

z.string.pl.tooltipConversationsArchive = 'Archiwum ({{shortcut}})';
z.string.pl.tooltipConversationsArchived = 'Poka archiwum ({{number}})';
z.string.pl.tooltipConversationsMore = 'Wicej';
z.string.pl.tooltipConversationsNotify = 'Wycz wyciszenie ({{shortcut}})';
z.string.pl.tooltipConversationsPreferences = 'Ustawienia';
z.string.pl.tooltipConversationsSilence = 'Wycisz ({{shortcut}})';
z.string.pl.tooltipConversationsStart = 'Zacznij rozmow ({{shortcut}})';

z.string.pl.tooltipConversationDetailsRename = 'Zmie nazw konwersacji';

z.string.pl.tooltipPreferencesContactsGmail = 'Zaloguj si do swojego konta Gmail i udostpniaj kontakty';
z.string.pl.tooltipPreferencesContactsMacos = 'Udostpnij wszystkie kontakty z aplikacji Kontakty macOS';
z.string.pl.tooltipPreferencesPassword = 'Otwrz stron resetowania hasa';
z.string.pl.tooltipPreferencesPicture = 'Zmie swj obraz';
z.string.pl.tooltipPreferencesRename = 'Zmie swoj nazw';

z.string.pl.tooltipSearchClose = 'Zamknij (Esc)';

z.string.pl.initReceivedSelfUser = 'Cze, {{user}}.';
z.string.pl.initValidatedClient = 'Pobieranie Twoich kontaktw i rozmw';
z.string.pl.initReceivedUserData = 'Sprawdzanie nowych wiadomoci';
z.string.pl.initDecryption = 'Odszyfrowywanie wiadomoci';
z.string.pl.initEvents = 'adowanie wiadomoci';
z.string.pl.initUpdatedFromNotifications = 'Prawie skoczone - miego korzystania z Wire';
z.string.pl.initProgress = '  {{number1}} z {{number2}}';

z.string.pl.ephemeralUnitsNone = 'Wycz';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.pt.wireMacos = 'Wire para macOS';
z.string.pt.wireWindows = 'Wire para Windows';
z.string.pt.wireLinux = 'Wire para Linux';
z.string.pt.nonexistentUser = 'Utilizador eliminado';
z.string.pt.and = 'e';

z.string.pt.authAccountCountryCode = 'Cdigo de Pas';
z.string.pt.authAccountPasswordForgot = 'Esqueci a palavra-passe';
z.string.pt.authAccountPublicComputer = 'Este computador  publico';
z.string.pt.authAccountSignIn = 'Iniciar sesso';
z.string.pt.authAccountSignInPhone = 'Telefone';

z.string.pt.authBlockedCookies = 'Ative os cookies para iniciar sesso no Wire.';
z.string.pt.authBlockedDatabase = 'O Wire necessita de acesso ao armazenamento local para mostrar as suas mensagens. O armazenamento local no est disponvel no modo privado.';
z.string.pt.authBlockedTabs = 'O Wire j est aberto noutro separador.';

z.string.pt.authVerifyAccountAdd = 'Adicionar';
z.string.pt.authVerifyAccountDetail = 'Permite que use o Wire em vrios dispositivos.';
z.string.pt.authVerifyAccountHeadline = 'Adicionar o endereo de e-mail e palavra-passe.';
z.string.pt.authVerifyAccountLogout = 'Terminar sesso';
z.string.pt.authVerifyCodeDescription = 'Introduza o cdigo de verificao que foi enviado para o {{number}}.';
z.string.pt.authVerifyCodeResend = 'No chegou o cdigo?';
z.string.pt.authVerifyCodeResendDetail = 'Reenviar';
z.string.pt.authVerifyCodeResendTimer = 'Pode solicitar um novo cdigo {{expiration}}.';
z.string.pt.authVerifyCodeChangePhone = 'Alterar o nmero de telefone';
z.string.pt.authVerifyPasswordHeadline = 'Insira a sua palavra-passe';

z.string.pt.authLimitDevicesHeadline = 'Dispositivos';
z.string.pt.authLimitDescription = 'Remova um dos seus outros dispositivos para comear a usar o Wire neste.';
z.string.pt.authLimitButtonManage = 'Gerir dispositivos';
z.string.pt.authLimitButtonSignOut = 'Terminar sesso';
z.string.pt.authLimitDevicesCurrent = '(Atual)';

z.string.pt.authHistoryHeadline = ' a primeira vez que est a usar o Wire neste dispositivo.';
z.string.pt.authHistoryDescription = 'Por razes de privacidade, o seu histrico de conversa no ser mostrado aqui.';
z.string.pt.authHistoryReuseHeadline = 'Voc j usou o Wire neste dispositivo.';
z.string.pt.authHistoryReuseDescription = 'As mensagens entretanto enviadas no aparecero aqui.';
z.string.pt.authHistoryButton = 'OK';

z.string.pt.authPostedResend = 'Reenviar para {{email}}';
z.string.pt.authPostedResendAction = 'No chegou a mensagem?';
z.string.pt.authPostedResendDetail = 'Verifique sua caixa de correio eletrnico e siga as instrues.';
z.string.pt.authPostedResendHeadline = 'Recebeu email.';

z.string.pt.authPlaceholderEmail = 'E-mail';
z.string.pt.authPlaceholderPasswordPut = 'Palavra-passe';
z.string.pt.authPlaceholderPasswordSet = 'Palavra-passe (pelo menos 8 caracteres)';
z.string.pt.authPlaceholderPhone = 'Telefone';

z.string.pt.authErrorCode = 'Cdigo invlido';
z.string.pt.authErrorCountryCodeInvalid = 'Cdigo de Pas Invlido';
z.string.pt.authErrorEmailExists = 'O endereo de correio eletrnico j est a ser utilizado';
z.string.pt.authErrorEmailForbidden = 'Este endereo de e-mail no  permitido.';
z.string.pt.authErrorEmailMalformed = 'Por favor, introduza um endereo de email vlido.';
z.string.pt.authErrorEmailMissing = 'Por favor insera um endereo de email.';
z.string.pt.authErrorMisc = 'Problemas com a ligao. Tente de novo.';
z.string.pt.authErrorNameShort = 'Introduza um nome com pelo menos 2 caracteres';
z.string.pt.authErrorOffline = 'Sem ligao  Internet';
z.string.pt.authErrorPasswordShort = 'Escolha uma palavra-passe com pelo menos 8 caracteres.';
z.string.pt.authErrorPasswordWrong = 'Palavra-passe incorreta. Por favor, tente de novo.';
z.string.pt.authErrorPending = 'A conta ainda no est verificada';
z.string.pt.authErrorPhoneNumberBudget = 'Iniciou sesso demasiadas vezes. Tente novamente mais tarde.';
z.string.pt.authErrorPhoneNumberForbidden = 'Este numero de telefone no  permitido.';
z.string.pt.authErrorPhoneNumberInvalid = 'Nmero de telefone invlido';
z.string.pt.authErrorPhoneNumberUnknown = 'Nmero de telefone desconhecido';
z.string.pt.authErrorSuspended = 'Esta conta j no est autorizada a iniciar sesso.';
z.string.pt.authErrorSignIn = 'Por favor verifique os seus detalhes e tente de novo.';

z.string.pt.callStateOutgoing = 'A tocar';
z.string.pt.callStateConnecting = 'A ligar';
z.string.pt.callStateIncoming = 'A chamar';
z.string.pt.callDecline = 'Rejeitar';
z.string.pt.callAccept = 'Aceitar';
z.string.pt.callJoin = 'Juntar-se';
z.string.pt.callChooseSharedScreen = 'Escolher um ecr para partilhar';
z.string.pt.callParticipants = '{{number}} na chamada';

z.string.pt.videoCallOverlayMute = 'Desativar som';
z.string.pt.videoCallOverlayHangUp = 'Desligar';

z.string.pt.modalAcknowledgeAction = 'Ok';
z.string.pt.modalConfirmSecondary = 'Cancelar';
z.string.pt.modalOptionSecondary = 'Cancelar';

z.string.pt.modalAccountCreateAction = 'OK';

z.string.pt.modalAccountDeletionAction = 'Eliminar';
z.string.pt.modalAccountDeletionHeadline = 'Eliminar conta';
z.string.pt.modalAccountDeletionMessage = 'Ser enviada uma mensagem ou SMS. Siga a ligao para apagar a conta de forma permanente.';

z.string.pt.modalAccountLeaveGuestRoomAction = 'Sair';

z.string.pt.modalAccountLogoutAction = 'Terminar sesso';
z.string.pt.modalAccountLogoutHeadline = 'Limpar Dados?';
z.string.pt.modalAccountLogoutOption = 'Eliminar a sua informao pessoal e conversas neste dispositivo.';

z.string.pt.modalAccountNewDevicesSecondary = 'Gerir dispositivos';
z.string.pt.modalAccountNewDevicesHeadline = 'A sua conta foi usada em:';
z.string.pt.modalAccountNewDevicesFrom = 'De:';
z.string.pt.modalAccountNewDevicesMessage = 'Se no fez isto, remova o dispositivo da conta e altere a sua palavra-passe.';

z.string.pt.modalAccountRemoveDeviceAction = 'Remover o dispositivo';
z.string.pt.modalAccountRemoveDeviceHeadline = 'Remover "{{device}}"';
z.string.pt.modalAccountRemoveDeviceMessage = 'A palavra-passe  necessria para remover o dispositivo.';
z.string.pt.modalAccountRemoveDevicePlaceholder = 'Palavra-passe';

z.string.pt.modalAssetTooLargeMessage = 'Pode enviar at {{number}} ficheiros';

z.string.pt.modalAssetParallelUploadsMessage = 'Pode enviar at {{number}} ficheiros de cada vez.';

z.string.pt.modalCallEmptyConversationHeadline = 'Ningum para ligar';
z.string.pt.modalCallEmptyConversationMessage = 'No h mais ningum aqui.';

z.string.pt.modalCallNoGroupVideoHeadline = 'No h chamadas de vdeo em grupos';
z.string.pt.modalCallNoGroupVideoMessage = 'As chamadas de vdeo no esto disponveis em conversas do grupo.';

z.string.pt.modalCallNoMicrophoneAction = 'Diga-me agora';
z.string.pt.modalCallNoMicrophoneMessage = 'Seu navegador precisa de aceder ao microfone para fazer chamadas.';
z.string.pt.modalCallNoMicrophoneHeadline = 'No  possvel telefonar sem microfone';

z.string.pt.modalCallSecondIncomingAction = 'Atender';
z.string.pt.modalCallSecondIncomingHeadline = 'Atender a chamada?';
z.string.pt.modalCallSecondIncomingMessage = 'Sua chamada atual vai acabar.';

z.string.pt.modalCallSecondOngoingAction = 'Desligar';
z.string.pt.modalCallSecondOngoingHeadline = 'Desligar a chamada noutro dispositivo?';
z.string.pt.modalCallSecondOngoingMessage = 'S pode fazer uma chamada de cada vez.';

z.string.pt.modalCallSecondOutgoingAction = 'Desligar';
z.string.pt.modalCallSecondOutgoingHeadline = 'Desligar a chamada atual?';
z.string.pt.modalCallSecondOutgoingMessage = 'S pode fazer uma chamada de cada vez.';

z.string.pt.modalConnectCancelAction = 'Sim';
z.string.pt.modalConnectCancelHeadline = 'Cancelar pedido?';
z.string.pt.modalConnectCancelMessage = 'Remover o pedido de ligao a {{user}}.';
z.string.pt.modalConnectCancelSecondary = 'No';

z.string.pt.modalConnectAcceptAction = 'Ligar';
z.string.pt.modalConnectAcceptHeadline = 'Aceitar?';
z.string.pt.modalConnectAcceptMessage = 'Isto ir lig-lo e criar uma conversa com {{user}}.';
z.string.pt.modalConnectAcceptSecondary = 'Ignorar';

z.string.pt.modalConversationClearAction = 'Eliminar';
z.string.pt.modalConversationClearHeadline = 'Apagar contedo?';
z.string.pt.modalConversationClearOption = 'Tambm abandona a conversa';

z.string.pt.modalConversationDeleteMessageAction = 'Eliminar';
z.string.pt.modalConversationDeleteMessageHeadline = 'Eliminar apenas para mim?';
z.string.pt.modalConversationDeleteMessageMessage = 'No pode ser desfeito.';

z.string.pt.modalConversationDeleteMessageEveryoneAction = 'Eliminar';
z.string.pt.modalConversationDeleteMessageEveryoneHeadline = 'Eliminar para todos?';
z.string.pt.modalConversationDeleteMessageEveryoneMessage = 'No pode ser desfeito.';

z.string.pt.modalConversationLeaveAction = 'Sair';
z.string.pt.modalConversationLeaveMessage = 'No ser capaz de enviar ou receber mensagens nesta conversa.';

z.string.pt.modalConversationMessageTooLongHeadline = 'A mensagem  demasiado longa';
z.string.pt.modalConversationMessageTooLongMessage = 'Pode enviar mensagens com o mximo de {{number}} caracteres.';

z.string.pt.modalConversationNewDeviceHeadlineOne = '{{user}} comeou a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceHeadlineMany = '{{users}} comearam a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceHeadlineYou = '{{user}} comeou a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceIncomingCallAction = 'Aceitar chamada';
z.string.pt.modalConversationNewDeviceIncomingCallMessage = 'Ainda quer aceitar a chamada?';
z.string.pt.modalConversationNewDeviceMessage = 'Ainda quer enviar as suas mensagens?';
z.string.pt.modalConversationNewDeviceOutgoingCallAction = 'Telefonar assim mesmo';
z.string.pt.modalConversationNewDeviceOutgoingCallMessage = 'Ainda quer fazer a chamada?';

z.string.pt.modalConversationNotConnectedHeadline = 'Ningum foi adicionado  conversa';
z.string.pt.modalConversationNotConnectedMessageOne = '{{name}} no quer ser adicionado a qualquer conversa.';
z.string.pt.modalConversationNotConnectedMessageMany = 'Uma das pessoas selecionadas no quer ser adicionada a qualquer conversa.';

z.string.pt.modalConversationRemoveAction = 'Remover';
z.string.pt.modalConversationRemoveHeadline = 'Remover?';
z.string.pt.modalConversationRemoveMessage = '{{user}} no ser capaz de enviar ou receber mensagens nesta conversa.';

z.string.pt.modalConversationRemoveGuestsAction = 'Remover';

z.string.pt.modalConversationTooManyMembersHeadline = 'Casa cheia';

z.string.pt.modalIntegrationUnavailableHeadline = 'Atualmente os "bots" no esto disponveis';
z.string.pt.modalIntegrationUnavailableMessage = 'Obrigado pelo seu interesse nos "bots". Atualmente o servio est suspenso enquanto preparamos a nova verso. Fique atento.';


z.string.pt.modalImproveWireAction = 'Aceitar';
z.string.pt.modalImproveWireSecondary = 'No';

z.string.pt.modalSessionResetHeadline = 'A sesso foi reposta';
z.string.pt.modalSessionResetMessage1 = 'Se o problema no est resolvido,';
z.string.pt.modalSessionResetMessageLink = 'contacto';
z.string.pt.modalSessionResetMessage2 = 'ns.';

z.string.pt.modalUploadContactsAction = 'Tente de novo';
z.string.pt.modalUploadContactsMessage = 'No recebemos a sua informao. Por favor, tente importar seus contactos de novo.';

z.string.pt.modalUserBlockAction = 'Bloquear';
z.string.pt.modalUserBlockHeadline = 'Bloquear {{user}}?';
z.string.pt.modalUserBlockMessage = '{{user}} no ser capaz de o contactar ou adicion-lo para conversas em grupo.';

z.string.pt.modalUserUnblockAction = 'Desbloquear';
z.string.pt.modalUserUnblockHeadline = 'Desbloquear?';
z.string.pt.modalUserUnblockMessage = '{{user}} ser capaz de o contactar e adicion-lo para conversas em grupo.';

z.string.pt.connectionRequestConnect = 'Ligar';
z.string.pt.connectionRequestIgnore = 'Ignorar';

z.string.pt.conversationGuestIndicator = 'Convidado';

z.string.pt.conversationYouNominative = 'voc';
z.string.pt.conversationYouDative = 'voc';
z.string.pt.conversationYouAccusative = 'voc';

z.string.pt.conversationConnectionAccepted = 'Ligado';
z.string.pt.conversationConnectionBlocked = 'Bloqueado';
z.string.pt.conversationConnectionCancelRequest = 'Cancelar pedido de ligao';
z.string.pt.conversationDeviceStartedUsingOne = ' comeou a usar';
z.string.pt.conversationDeviceStartedUsingMany = ' comeou a usar';
z.string.pt.conversationDeviceUnverified = ' retirou a verificao de um de';
z.string.pt.conversationDeviceYourDevices = ' seus dispositivos';
z.string.pt.conversationDeviceUserDevices = ' dispositivos de {{user}}';
z.string.pt.conversationDeviceNewDeviceOne = ' novo dispositivo';
z.string.pt.conversationDeviceNewDeviceMany = ' novos dispositivos';
z.string.pt.conversationDeviceNewPeopleJoinedVerify = ' verificar dispositivos';
z.string.pt.conversationJustNow = 'Agora mesmo';
z.string.pt.conversationLocationLink = 'Abrir Mapa';
z.string.pt.conversationMessageDelivered = 'Entregue';
z.string.pt.conversationRename = ' renomeou a conversa';
z.string.pt.conversationRenameYou = ' renomeou a conversa';
z.string.pt.conversationResume = 'Iniciar uma conversa com {{users}}';
z.string.pt.conversationPing = ' pingou';
z.string.pt.conversationPingYou = ' pingou';
z.string.pt.conversationToday = 'hoje';
z.string.pt.conversationVoiceChannelDeactivate = ' ligou';
z.string.pt.conversationVoiceChannelDeactivateYou = ' ligou';
z.string.pt.conversationYesterday = 'Ontem';
z.string.pt.conversationUnableToDecrypt1 = 'no foi recebida uma mensagem de {{user}}.';
z.string.pt.conversationUnableToDecrypt2 = 'A identidade do dispositivo de {{user}} foi alterada. A mensagem no foi entregue.';
z.string.pt.conversationUnableToDecryptLink = 'Porqu?';
z.string.pt.conversationUnableToDecryptErrorMessage = 'Erro';
z.string.pt.conversationUnableToDecryptResetSession = 'Redefinir sesso';
z.string.pt.conversationMissedMessages = 'No usou este dispositivo durante algum tempo. Algumas mensagens podem no ser mostradas.';
z.string.pt.conversationAssetDownloading = 'A descarregar';
z.string.pt.conversationAssetUploadFailed = 'O carregamento falhou';
z.string.pt.conversationPlaybackError = 'Incapaz de reproduzir';
z.string.pt.conversationContextMenuCopy = 'Copiar';
z.string.pt.conversationContextMenuEdit = 'Editar';
z.string.pt.conversationContextMenuDelete = 'Eliminar para mim';
z.string.pt.conversationContextMenuDeleteEveryone = 'Eliminar para todos';
z.string.pt.conversationContextMenuDownload = 'Descarregar';
z.string.pt.conversationContextMenuLike = 'Gosto';
z.string.pt.conversationContextMenuUnlike = 'No gosto';
z.string.pt.conversationDeleteTimestamp = 'Eliminado em {{date}}';
z.string.pt.conversationEditTimestamp = 'Editado em {{date}}';
z.string.pt.conversationLikesCaption = '{{number}} pessoas';
z.string.pt.conversationSendPastedFile = 'Imagem colada em {{date}}';
z.string.pt.conversationSomeone = 'Algum';
z.string.pt.conversationTweetAuthor = ' no Twitter';

z.string.pt.groupCreationPreferencesAction = 'Seguinte';
z.string.pt.groupCreationParticipantsActionCreate = 'Pronto';
z.string.pt.groupCreationParticipantsPlaceholder = 'Pesquisar por nome';


z.string.pt.collectionShowAll = 'Mostrar todos os {{number}}';
z.string.pt.collectionSectionLinks = 'Ligaes';
z.string.pt.collectionSectionImages = 'Fotografias';
z.string.pt.collectionSectionFiles = 'Ficheiros';
z.string.pt.collectionSectionAudio = 'Mensagens de udio';

z.string.pt.fullsearchPlaceholder = 'Procurar mensagens de texto';
z.string.pt.fullsearchNoResults = 'Sem resultados.';

z.string.pt.archiveHeader = 'Arquivar';

z.string.pt.conversationsAllArchived = 'Foi tudo arquivado';
z.string.pt.conversationsContacts = 'Contactos';
z.string.pt.conversationsConnectionRequestMany = '{{number}} pessoas em espera';
z.string.pt.conversationsConnectionRequestOne = '1 pessoa em espera';
z.string.pt.conversationsEmptyConversation = 'Conversa em grupo';
z.string.pt.conversationsNoConversations = 'Ainda no existem conversas';
z.string.pt.conversationsPopoverArchive = 'Arquivar';
z.string.pt.conversationsPopoverCancel = 'Cancelar pedido';
z.string.pt.conversationsPopoverNotify = 'Activar som';
z.string.pt.conversationsPopoverSilence = 'Desativar som';
z.string.pt.conversationsPopoverUnarchive = 'Retirar do arquivo';

z.string.pt.conversationsSecondaryLineEphemeralMessage = 'Enviou-lhe uma mensagem';
z.string.pt.conversationsSecondaryLinePeopleLeft = 'saram {{number}} pessoas';
z.string.pt.conversationsSecondaryLinePersonLeft = '{{user}} saiu';
z.string.pt.conversationsSecondaryLinePersonRemoved = '{{user}} foi removido';
z.string.pt.conversationsSecondaryLinePeopleAdded = 'Foram adicionadas {{user}} pessoas';
z.string.pt.conversationsSecondaryLinePersonAdded = '{{user}} foi adicionado';
z.string.pt.conversationsSecondaryLinePersonAddedYou = '{{user}} adicionou-o';
z.string.pt.conversationsSecondaryLineRenamed = '{{user}} renomeou a conversa';
z.string.pt.conversationsSecondaryLineYouLeft = 'Voc deixou';
z.string.pt.conversationsSecondaryLineYouWereRemoved = 'Voc foram removido';

z.string.pt.takeoverSub = 'Reivindicar seu nome exclusivo no Wire.';
z.string.pt.takeoverLink = 'Saber mais';
z.string.pt.takeoverButtonChoose = 'Escolha a sua';
z.string.pt.takeoverButtonKeep = 'Manter esta';

z.string.pt.inviteMetaKeyMac = 'Cmd';
z.string.pt.inviteMetaKeyPc = 'Ctrl';
z.string.pt.inviteHeadline = 'Convidar pessoas para aderir ao Wire';
z.string.pt.inviteMessage = 'Eu estou no Wire, pesquise por {{username}} ou visite get.wire.com.';
z.string.pt.inviteMessageNoEmail = 'Estou no Wire. Visite get.wire.com para se ligar a mim.';

z.string.pt.extensionsBubbleButtonGif = 'Gif';

z.string.pt.extensionsGiphyButtonOk = 'Enviar';
z.string.pt.extensionsGiphyButtonMore = 'Tente outra';
z.string.pt.extensionsGiphyMessage = ' {{tag}} atravs de giphy.com';
z.string.pt.extensionsGiphyNoGifs = 'Oops, sem gifs';
z.string.pt.extensionsGiphyRandom = 'Aleatrio';

z.string.pt.addParticipantsConfirmLabel = 'Adicionar';
z.string.pt.addParticipantsSearchPlaceholder = 'Pesquisar por nome';
z.string.pt.addParticipantsTabsPeople = 'Pessoas';
z.string.pt.addParticipantsTabsServices = 'Servios';

z.string.pt.conversationDetailsActionArchive = 'Arquivar';
z.string.pt.conversationDetailsActionCancelRequest = 'Cancelar pedido';
z.string.pt.conversationDetailsActionDevices = 'Dispositivos';
z.string.pt.conversationDetailsActionNotifications = 'Notificaes';
z.string.pt.conversationDetailsGuestsOff = 'Desligado';
z.string.pt.conversationDetailsOptions = 'Opes';
z.string.pt.conversationDetailsParticipantsServicesMany = 'Servios';
z.string.pt.conversationDetailsParticipantsUsersMany = 'Pessoas';
z.string.pt.conversationDetailsPeople = 'Pessoas';
z.string.pt.conversationDetailsServices = 'Servios';

z.string.pt.conversationParticipantsTitle = 'Pessoas';
z.string.pt.conversationParticipantsSearchPlaceholder = 'Pesquisar por nome';

z.string.pt.groupParticipantActionCancelRequest = 'Cancelar pedido';
z.string.pt.groupParticipantActionDevices = 'Dispositivos';
z.string.pt.groupParticipantActionPending = 'Pendente';
z.string.pt.groupParticipantActionSendRequest = 'Ligar';

z.string.pt.notificationSettingsTitle = 'Notificaes';

z.string.pt.participantDevicesDetailHeadline = 'Verifique se corresponde  impresso digital mostrada dispositivo {{html2}} do {{html1}}{{user}}.';
z.string.pt.participantDevicesDetailHowTo = 'Como posso fazer isto?';
z.string.pt.participantDevicesDetailResetSession = 'Redefinir sesso';
z.string.pt.participantDevicesDetailShowMyDevice = 'Mostrar impresso digital do meu dispositivo';
z.string.pt.participantDevicesDetailVerify = 'Verificado';

z.string.pt.participantDevicesHeader = 'Dispositivos';
z.string.pt.participantDevicesHeadline = 'O Wire gera em cada dispositivo uma impresso digital nica. Compare-os com {{user}} e verifique a sua conversa.';
z.string.pt.participantDevicesLearnMore = 'Saber mais';
z.string.pt.participantDevicesWhyVerify = 'Porqu verificar as conversas?';
z.string.pt.participantDevicesOutdatedClientMessage = '{{user}} est a usar uma verso antiga do Wire. Os dispositivos no so mostrados aqui.';

z.string.pt.participantDevicesSelfAllDevices = 'Mostrar todos os meus dispositivos';
z.string.pt.participantDevicesSelfFingerprint = 'Impresso digital do dispositivo';

z.string.pt.userProfileButtonConnect = 'Ligar';
z.string.pt.userProfileButtonIgnore = 'Ignorar';
z.string.pt.userProfileButtonUnblock = 'Desbloquear';

z.string.pt.preferencesAbout = 'Sobre';
z.string.pt.preferencesAccount = 'Conta';
z.string.pt.preferencesAV = 'udio / vdeo';
z.string.pt.preferencesDeviceDetails = 'Detalhes do Dispositivo';
z.string.pt.preferencesDevices = 'Dispositivos';
z.string.pt.preferencesHeadline = 'Preferncias';
z.string.pt.preferencesOptions = 'Opes';

z.string.pt.preferencesAboutPrivacyPolicy = 'Poltica de privacidade';
z.string.pt.preferencesAboutSupport = 'Suporte';
z.string.pt.preferencesAboutSupportWebsite = 'Pgina de suporte';
z.string.pt.preferencesAboutSupportContact = 'Contactar o Suporte';
z.string.pt.preferencesAboutTermsOfUse = 'Condies de Utilizao';
z.string.pt.preferencesAboutVersion = 'Verso {{version}}';
z.string.pt.preferencesAboutWebsite = 'Site do Wire';

z.string.pt.preferencesAccountAvaibilityUnset = 'Definir estado';
z.string.pt.preferencesAccountCreateTeam = 'Criar uma equipa';
z.string.pt.preferencesAccountDelete = 'Eliminar conta';
z.string.pt.preferencesAccountLogOut = 'Terminar sesso';
z.string.pt.preferencesAccountManageTeam = 'Gerir equipa';
z.string.pt.preferencesAccountResetPassword = 'Alterar a palavra-passe';
z.string.pt.preferencesAccountTeam = 'em {{name}}';
z.string.pt.preferencesAccountUsernamePlaceholder = 'O seu nome completo';
z.string.pt.preferencesAccountUsernameHint = 'Pelo menos 2 caracteres. a-z, 0-9 e _ apenas.';
z.string.pt.preferencesAccountUsernameAvailable = 'Disponvel';
z.string.pt.preferencesAccountUsernameErrorTaken = 'J est ocupado';

z.string.pt.preferencesAVCamera = 'Cmera';
z.string.pt.preferencesAVMicrophone = 'Microfone';
z.string.pt.preferencesAVPermissionDetail = 'Permitir a partir das definies seu navegador';
z.string.pt.preferencesAVSpeakers = 'Altifalantes';

z.string.pt.preferencesDevicesActivatedOn = 'Ativado em {{date}}';
z.string.pt.preferencesDevicesActive = 'Ativo';
z.string.pt.preferencesDevicesActiveDetail = 'Se no reconhecer um dispositivo acima, remova-o e altere a sua palavra-passe.';
z.string.pt.preferencesDevicesCurrent = 'Atual';
z.string.pt.preferencesDevicesFingerprint = 'Impresso digital da chave';
z.string.pt.preferencesDevicesFingerprintDetail = 'O Wire gera em cada dispositivo uma impresso digital nica. Compare-os e verifique se seus dispositivos e conversas.';
z.string.pt.preferencesDevicesId = 'ID: ';
z.string.pt.preferencesDevicesRemoveCancel = 'Cancelar';
z.string.pt.preferencesDevicesRemoveDetail = 'Remove este dispositivo se tiver parado de o usar. Terminar a sua sesso neste dispositivo imediatamente.';
z.string.pt.preferencesDevicesSessionConfirmation = 'A sesso foi reposta.';
z.string.pt.preferencesDevicesSessionDetail = 'Se as impresses digitais no corresponderem, redefina a sesso para gerar novas chaves de criptografia em ambos os lados.';
z.string.pt.preferencesDevicesSessionReset = 'Redefinir sesso';
z.string.pt.preferencesDevicesSessionOngoing = 'A redefinir a sesso';
z.string.pt.preferencesDevicesVerification = 'Verificado';

z.string.pt.preferencesOptionsAudio = 'Alerta sonoro';
z.string.pt.preferencesOptionsAudioAll = 'Todos';
z.string.pt.preferencesOptionsAudioAllDetail = 'Todos os sons';
z.string.pt.preferencesOptionsAudioNone = 'Nenhum';
z.string.pt.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.pt.preferencesOptionsAudioSome = 'Alguns';
z.string.pt.preferencesOptionsAudioSomeDetail = 'Pings e chamadas';
z.string.pt.preferencesOptionsContacts = 'Contactos';
z.string.pt.preferencesOptionsContactsGmail = 'Importar do Gmail';
z.string.pt.preferencesOptionsContactsMacos = 'Importar dos Contactos';
z.string.pt.preferencesOptionsContactsDetail = 'Usamos seus dados de contacto para liga-lo aos outros. Ns anonimizamos toda a informao e no a partilhamos com outras entidades.';
z.string.pt.preferencesOptionsPopular = 'A pedido popular';
z.string.pt.preferencesOptionsEmojiReplaceCheckbox = 'Substituir emoticons por emojis';
z.string.pt.preferencesOptionsPreviewsSendCheckbox = 'Criar pr-visualizaes para ligaes que enviar';
z.string.pt.preferencesOptionsPreviewsSendDetail = 'Antevises ainda podem mostradas para ligaes de outras pessoas.';
z.string.pt.preferencesOptionsNotifications = 'Notificaes';
z.string.pt.preferencesOptionsNotificationsNone = 'Desligado';
z.string.pt.preferencesOptionsNotificationsObfuscate = 'Ocultar detalhes';
z.string.pt.preferencesOptionsNotificationsObfuscateMessage = 'Mostrar remetente';
z.string.pt.preferencesOptionsNotificationsOn = 'Mostrar o remetente e a mensagem';

z.string.pt.backupCancel = 'Cancelar';

z.string.pt.searchConnect = 'Ligar';
z.string.pt.searchConnections = 'Ligaes';
z.string.pt.searchContacts = 'Contactos';
z.string.pt.searchCreateGroup = 'Criar grupo';
z.string.pt.searchGroups = 'Grupos';
z.string.pt.searchPeople = 'Pessoas';
z.string.pt.searchPlaceholder = 'Pesquisar por nome ou nome de utilizador';
z.string.pt.searchServicePlaceholder = 'Pesquisar por nome';
z.string.pt.searchServices = 'Servios';
z.string.pt.searchTeamGroups = 'Conversas da equipa';
z.string.pt.searchTeamMembers = 'Membros da equipa';
z.string.pt.searchTopPeople = 'Pessoas mais contactadas';
z.string.pt.searchTrySearch = 'Encontrar pessoas pelo nome ou nome de utilizador';
z.string.pt.searchNoContactsOnWire = 'No tem qualquer contacto no Wire. Tente encontrar pessoas pelo nome ou nome de utilizador.';
z.string.pt.searchOthers = 'Ligar';

z.string.pt.searchInvite = 'Convidar pessoas para aderir ao Wire';
z.string.pt.searchInviteDetail = 'Partilhar os seus contacto ajuda a ligar-se aos outros. Anonimizamos toda a informao e no a partilhamos com ningum.';
z.string.pt.searchInviteButtonContacts = 'Dos contactos';
z.string.pt.searchInviteButtonGmail = 'Do Gmail';
z.string.pt.searchInviteHeadline = 'Traga os seus amigos';
z.string.pt.searchInviteShare = 'Partilhar Contactos';

z.string.pt.searchListEveryoneParticipates = 'Todas as pessoas a que est ligado j esto nesta conversa.';
z.string.pt.searchListNoMatches = 'Sem resultados. Tente um nome diferente.';


z.string.pt.uploadGoogleHeadline = 'Encontre pessoas para conversar.';
z.string.pt.uploadGoogleMessage = 'Usamos seus dados de contacto para liga-lo aos outros. Ns anonimizamos toda a informao e no a partilhamos com outras entidades.';

z.string.pt.warningCallUnsupportedIncoming = '{{user}} est a chamar. O seu navegador no suporta chamadas.';
z.string.pt.warningCallUnsupportedOutgoing = 'No pode telefonar porque o seu navegador no suporta chamadas.';
z.string.pt.warningCallIssues = 'Esta verso do Wire no pode participar na chamada. Por favor, use';
z.string.pt.warningCallUpgradeBrowser = 'Para telefonar, atualize o Google Chrome.';
z.string.pt.warningConnectivityConnectionLost = 'A tentar ligar. O Wire pode no ser capaz de entregar mensagens.';
z.string.pt.warningConnectivityNoInternet = 'Sem Internet. No ser capaz de enviar ou receber mensagens.';
z.string.pt.warningLearnMore = 'Saber mais';
z.string.pt.warningLifecycleUpdate = 'Est disponvel uma verso nova do Wire.';
z.string.pt.warningLifecycleUpdateNotes = 'O que h de novo';
z.string.pt.warningLifecycleUpdateLink = 'Actualizar agora';
z.string.pt.warningNotFoundCamera = 'No pode telefonar porque o seu computador no tem uma cmara.';
z.string.pt.warningNotFoundMicrophone = 'No pode telefonar porque o seu computador no tem um microfone.';
z.string.pt.warningPermissionDeniedCamera = 'No pode telefonar porque o seu navegador no tem acesso  cmara.';
z.string.pt.warningPermissionDeniedMicrophone = 'No pode telefonar porque o seu navegador no tem acesso ao microfone.';
z.string.pt.warningPermissionDeniedScreen = 'O seu navegador precisa de permisso para partilhar o ecr.';
z.string.pt.warningPermissionRequestCamera = '{{icon}} Permitir o acesso a cmara';
z.string.pt.warningPermissionRequestMicrophone = '{{icon}} Permitir o acesso ao microfone';
z.string.pt.warningPermissionRequestNotification = '{{icon}} Permitir notificaes';
z.string.pt.warningPermissionRequestScreen = '{{icon}} Permitir o acesso ao ecr';

z.string.pt.userAvailabilityAvailable = 'Disponvel';
z.string.pt.userAvailabilityAway = 'Ausente';
z.string.pt.userAvailabilityBusy = 'Ocupado';
z.string.pt.userAvailabilityNone = 'Nenhum';

z.string.pt.notificationAssetAdd = 'Partilhou uma foto';
z.string.pt.notificationConnectionAccepted = 'Aceitou o seu pedido de ligao';
z.string.pt.notificationConnectionConnected = 'J est ligado';
z.string.pt.notificationConnectionRequest = 'Quer ligar-se';
z.string.pt.notificationConversationCreate = '{{user}} comeou uma conversa';
z.string.pt.notificationConversationRename = '{{user}} renomeou a conversa para {{name}}';
z.string.pt.notificationMemberJoinMany = '{{user}} adicionou {{number}} pessoas  conversa';
z.string.pt.notificationMemberJoinOne = '{{user1}} adicionou {{user2}}  conversa';
z.string.pt.notificationMemberLeaveRemovedYou = '{{user}} removeu-o da conversao';
z.string.pt.notificationObfuscated = 'Enviou-lhe uma mensagem';
z.string.pt.notificationObfuscatedTitle = 'Algum';
z.string.pt.notificationPing = 'Pingado';
z.string.pt.notificationReaction = '{{reaction}} a sua mensagem';
z.string.pt.notificationSharedAudio = 'Partilhou uma mensagem udio';
z.string.pt.notificationSharedFile = 'Partilhou um ficheiro';
z.string.pt.notificationSharedLocation = 'Partilhou a localizao';
z.string.pt.notificationSharedVideo = 'Partilhou um vdeo';
z.string.pt.notificationVoiceChannelActivate = 'A chamar';
z.string.pt.notificationVoiceChannelDeactivate = 'Ligou';

z.string.pt.tooltipConversationAllVerified = 'Todas as impresses digitais esto verificadas';
z.string.pt.tooltipConversationCall = 'Chamada';
z.string.pt.tooltipConversationEphemeral = 'Mensagem agendada';
z.string.pt.tooltipConversationFile = 'Adicionar ficheiro';
z.string.pt.tooltipConversationInputPlaceholder = 'Escreva uma mensagem';
z.string.pt.tooltipConversationInputPlaceholderAvailable = '{{user}} est disponvel';
z.string.pt.tooltipConversationInputPlaceholderAway = '{{user}} est ausente';
z.string.pt.tooltipConversationInputPlaceholderBusy = '{{user}} est ocupado';
z.string.pt.tooltipConversationPeople = 'Pessoas ({{shortcut}})';
z.string.pt.tooltipConversationPicture = 'Adicionar imagem';
z.string.pt.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.pt.tooltipConversationSearch = 'Procurar';
z.string.pt.tooltipConversationVideoCall = 'Chamada de Vdeo';

z.string.pt.tooltipConversationsArchive = 'Arquivar ({{shortcut}})';
z.string.pt.tooltipConversationsArchived = 'Mostrar ficheiro ({{number}})';
z.string.pt.tooltipConversationsMore = 'Mais';
z.string.pt.tooltipConversationsNotify = 'Desligar "silenciar" ({{shortcut}})';
z.string.pt.tooltipConversationsPreferences = 'Abrir preferncias';
z.string.pt.tooltipConversationsSilence = 'Silenciar ({{shortcut}})';
z.string.pt.tooltipConversationsStart = 'Iniciar conversa ({{shortcut}})';

z.string.pt.tooltipConversationDetailsRename = 'Alterar nome da conversa';

z.string.pt.tooltipPreferencesContactsGmail = 'Iniciar sesso na sua conta do Gmail para partilhar contactos';
z.string.pt.tooltipPreferencesContactsMacos = 'Partilhe os contatos da aplicao de contactos macOS';
z.string.pt.tooltipPreferencesPassword = 'Abrir um outro site para alterar a sua palavra-passe';
z.string.pt.tooltipPreferencesPicture = 'Mude sua fotografia';
z.string.pt.tooltipPreferencesRename = 'Mudar o seu nome';

z.string.pt.tooltipSearchClose = 'Fechar (Esc)';

z.string.pt.initReceivedSelfUser = 'Ol {{user}}.';
z.string.pt.initValidatedClient = 'A descarregar as suas ligaes e conversas';
z.string.pt.initReceivedUserData = 'A verificar por novas mensagens';
z.string.pt.initDecryption = 'A desencriptar mensagens';
z.string.pt.initEvents = 'A carregar mensagens';
z.string.pt.initUpdatedFromNotifications = 'Quase pronto - Desfrute do Wire';
z.string.pt.initProgress = '  {{number1}} de {{number2}}';

z.string.pt.ephemeralUnitsNone = 'Desligado';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.ro.wire = 'Wire';
z.string.ro.wireMacos = 'Wire pentru macOS';
z.string.ro.wireWindows = 'Wire pentru Windows';
z.string.ro.wireLinux = 'Wire pentru Linux';
z.string.ro.nonexistentUser = 'Utilizator ters';
z.string.ro.and = 'i';
z.string.ro.enumerationAnd = ', i ';

z.string.ro.authAccountCountryCode = 'Codul rii';
z.string.ro.authAccountPasswordForgot = 'Am uitat parola';
z.string.ro.authAccountPublicComputer = 'Acesta este un calculator public';
z.string.ro.authAccountSignIn = 'Autentificare';
z.string.ro.authAccountSignInPhone = 'Telefon';

z.string.ro.authBlockedCookies = 'Activeaz cookie-urile pentru intra n Wire.';
z.string.ro.authBlockedDatabase = 'Wire are nevoie de acces la stocarea local pentru a afia mesaje. Stocarea local nu este disponibil n modul privat.';
z.string.ro.authBlockedTabs = 'Wire este deja deschis n alt fil.';
z.string.ro.authBlockedTabsAction = 'Folosete aceast fil n loc';

z.string.ro.authVerifyAccountAdd = 'Adaug';
z.string.ro.authVerifyAccountDetail = 'Aceasta i permite s foloseti Wire pe mai multe dispozitive.';
z.string.ro.authVerifyAccountHeadline = 'Adaug o adres de e-mail i o parol.';
z.string.ro.authVerifyAccountLogout = 'Deconectare';
z.string.ro.authVerifyCodeDescription = 'Introdu codul de verificare\nl-am trimis la {{number}}.';
z.string.ro.authVerifyCodeResend = 'Nu e afiat niciun cod?';
z.string.ro.authVerifyCodeResendDetail = 'Retrimite';
z.string.ro.authVerifyCodeResendTimer = 'Poi cere un nou cod de {{expiration}}.';
z.string.ro.authVerifyCodeChangePhone = 'Schimb numrul de telefon';
z.string.ro.authVerifyPasswordHeadline = 'Introdu parola ta';

z.string.ro.authLimitDevicesHeadline = 'Dispozitive';
z.string.ro.authLimitDescription = 'terge unul din celelalte dispozitive pentru a folosi Wire pe acesta.';
z.string.ro.authLimitButtonManage = 'Gestionare dispozitive';
z.string.ro.authLimitButtonSignOut = 'Deconectare';
z.string.ro.authLimitDevicesCurrent = '(Curent)';

z.string.ro.authHistoryHeadline = 'Foloseti Wire pentru prima dat pe acest dispozitiv.';
z.string.ro.authHistoryDescription = 'Din motive de confidenialitate, istoricul conversaiei nu va aprea aici.';
z.string.ro.authHistoryReuseHeadline = 'Ai mai folosit Wire pe acest dispozitiv.';
z.string.ro.authHistoryReuseDescription = 'Mesajele trimise ntre timp nu vor aprea aici.';
z.string.ro.authHistoryButton = 'OK';

z.string.ro.authPostedResend = 'Retrimite la {{email}}';
z.string.ro.authPostedResendAction = 'Nu a aprut nici un e-mail?';
z.string.ro.authPostedResendDetail = 'Verific e-mailul i urmeaz instruciunile.';
z.string.ro.authPostedResendHeadline = 'Ai primit un mesaj.';

z.string.ro.authPlaceholderEmail = 'E-mail';
z.string.ro.authPlaceholderPasswordPut = 'Parol';
z.string.ro.authPlaceholderPasswordSet = 'Parol (minim 8 caractere)';
z.string.ro.authPlaceholderPhone = 'Numr de telefon';

z.string.ro.authErrorCode = 'Cod nevalid';
z.string.ro.authErrorCountryCodeInvalid = 'Cod de ar nevalid';
z.string.ro.authErrorEmailExists = 'Adresa de e-mail este deja folosit';
z.string.ro.authErrorEmailForbidden = 'Ne pare ru. Aceast adresa de e-mail este interzis.';
z.string.ro.authErrorEmailMalformed = 'Te rugm s introduci o adres de e-mail valid.';
z.string.ro.authErrorEmailMissing = 'Introdu o adres de e-mail.';
z.string.ro.authErrorMisc = 'Ai probleme cu conexiunea. Rencearc.';
z.string.ro.authErrorNameShort = 'Introdu un nume de cel puin 2 caractere';
z.string.ro.authErrorOffline = 'Lipsete conexiunea la internet';
z.string.ro.authErrorPasswordShort = 'Alege o parol de cel puin 8 caractere.';
z.string.ro.authErrorPasswordWrong = 'Parol greit. Rencearc.';
z.string.ro.authErrorPending = 'Cont neverificat';
z.string.ro.authErrorPhoneNumberBudget = 'Te conectezi prea des. ncearc din nou mai trziu.';
z.string.ro.authErrorPhoneNumberForbidden = 'Ne pare ru. Acest numr de telefon este interzis.';
z.string.ro.authErrorPhoneNumberInvalid = 'Numr de telefon nevalid';
z.string.ro.authErrorPhoneNumberUnknown = 'Numr de telefon necunoscut';
z.string.ro.authErrorSuspended = 'Acest cont nu mai este autorizat pentru autentificare.';
z.string.ro.authErrorSignIn = 'Te rugm s verifici detaliile i s rencerci.';

z.string.ro.callStateOutgoing = 'Se sun';
z.string.ro.callStateConnecting = 'Se conecteaz';
z.string.ro.callStateIncoming = 'Se apeleaz';
z.string.ro.callDecline = 'Refuz';
z.string.ro.callAccept = 'Accept';
z.string.ro.callJoin = 'Altur-te';
z.string.ro.callChooseSharedScreen = 'Alege un ecran pentru a partaja';
z.string.ro.callParticipants = '{{number}} n apel';

z.string.ro.videoCallOverlayMute = 'Mutizeaz';
z.string.ro.videoCallOverlayHangUp = 'nchide';

z.string.ro.modalAcknowledgeAction = 'Ok';
z.string.ro.modalAcknowledgeHeadline = 'Ceva nu a mers bine';
z.string.ro.modalConfirmSecondary = 'Renun';
z.string.ro.modalOptionSecondary = 'Renun';

z.string.ro.modalAccountCreateAction = 'OK';
z.string.ro.modalAccountCreateHeadline = 'Doreti s creezi un cont?';
z.string.ro.modalAccountCreateMessage = 'Prin crearea unui cont vei pierde istoricul conversaiilor din aceast camer de oaspei.';

z.string.ro.modalAccountDeletionAction = 'terge';
z.string.ro.modalAccountDeletionHeadline = 'terge contul';
z.string.ro.modalAccountDeletionMessage = 'i vom trimite un mesaj pe e-mail sau SMS. Urmeaz linkul pentru a terge permanent contul tu.';

z.string.ro.modalAccountLeaveGuestRoomAction = 'Iei';
z.string.ro.modalAccountLeaveGuestRoomHeadline = 'Iei din camera de oaspei?';
z.string.ro.modalAccountLeaveGuestRoomMessage = 'Istoricul conversaiilor va fi ters. Poi pstra istoricul doar prin crearea unui cont.';

z.string.ro.modalAccountLogoutAction = 'Deconectare';
z.string.ro.modalAccountLogoutHeadline = 'Cur datele?';
z.string.ro.modalAccountLogoutOption = 'terge toate informaiile personale i conversaiile de pe acest dispozitiv.';

z.string.ro.modalAccountNewDevicesSecondary = 'Gestionare dispozitive';
z.string.ro.modalAccountNewDevicesHeadline = 'Contul tu a fost folosit n data de:';
z.string.ro.modalAccountNewDevicesFrom = 'De la:';
z.string.ro.modalAccountNewDevicesMessage = 'Dac nu ai fcut asta, elimin dispozitivul i reseteaz parola.';

z.string.ro.modalAccountRemoveDeviceAction = 'Scoate dispozitivul';
z.string.ro.modalAccountRemoveDeviceHeadline = 'Scoate {{device}}';
z.string.ro.modalAccountRemoveDeviceMessage = 'Este necesar parola pentru a elimina acest dispozitiv.';
z.string.ro.modalAccountRemoveDevicePlaceholder = 'Parol';

z.string.ro.modalAssetTooLargeHeadline = 'Fiierul este prea mare';
z.string.ro.modalAssetTooLargeMessage = 'Poi trimite fiiere pn la {{number}}';

z.string.ro.modalAssetParallelUploadsHeadline = 'Prea multe fiiere de ncrcat';
z.string.ro.modalAssetParallelUploadsMessage = 'Poi trimite maxim {{number}} fiiere simultan.';

z.string.ro.modalCallEmptyConversationHeadline = 'Nu ai pe cine apela';
z.string.ro.modalCallEmptyConversationMessage = 'Nu a mai rmas nimeni aici.';

z.string.ro.modalCallNoGroupVideoHeadline = 'Nu poi face apeluri video n grupuri';
z.string.ro.modalCallNoGroupVideoMessage = 'Apelurile video nu sunt disponibile n conversaiile de grup.';

z.string.ro.modalCallNoMicrophoneAction = 'Spune-mi cum';
z.string.ro.modalCallNoMicrophoneMessage = 'Browserul tu are nevoie de acces la microfon pentru a face apeluri.';
z.string.ro.modalCallNoMicrophoneHeadline = 'Nu se poate apela fr microfon';

z.string.ro.modalCallSecondIncomingAction = 'Rspunde';
z.string.ro.modalCallSecondIncomingHeadline = 'Rspunde la apel?';
z.string.ro.modalCallSecondIncomingMessage = 'Apelul curent se va termina.';

z.string.ro.modalCallSecondOngoingAction = 'nchide';
z.string.ro.modalCallSecondOngoingHeadline = 'nchide apelul pe un alt dispozitiv?';
z.string.ro.modalCallSecondOngoingMessage = 'Nu poi fi dect ntr-un singur apel la un moment dat.';

z.string.ro.modalCallSecondOutgoingAction = 'nchide';
z.string.ro.modalCallSecondOutgoingHeadline = 'nchide apelul curent?';
z.string.ro.modalCallSecondOutgoingMessage = 'Nu poi fi dect ntr-un singur apel la un moment dat.';

z.string.ro.modalConnectCancelAction = 'Da';
z.string.ro.modalConnectCancelHeadline = 'Anuleaz solicitarea?';
z.string.ro.modalConnectCancelMessage = 'terge solicitarea de conectare cu {{user}}.';
z.string.ro.modalConnectCancelSecondary = 'Nu';

z.string.ro.modalConnectAcceptAction = 'Conectare';
z.string.ro.modalConnectAcceptHeadline = 'Accept?';
z.string.ro.modalConnectAcceptMessage = 'Aceasta te va conecta i va deschide o conversaie cu {{user}}.';
z.string.ro.modalConnectAcceptSecondary = 'Ignor';

z.string.ro.modalConversationClearAction = 'terge';
z.string.ro.modalConversationClearHeadline = 'tergei coninutul?';
z.string.ro.modalConversationClearOption = 'Prsete conversaia';

z.string.ro.modalConversationDeleteMessageAction = 'terge';
z.string.ro.modalConversationDeleteMessageHeadline = 'terge doar pentru mine?';
z.string.ro.modalConversationDeleteMessageMessage = 'Operaiunea nu poate fi anulat.';

z.string.ro.modalConversationDeleteMessageEveryoneAction = 'terge';
z.string.ro.modalConversationDeleteMessageEveryoneHeadline = 'terge pentru toat lumea?';
z.string.ro.modalConversationDeleteMessageEveryoneMessage = 'Operaiunea nu poate fi anulat.';

z.string.ro.modalConversationLeaveAction = 'Iei';
z.string.ro.modalConversationLeaveMessage = 'Nu vei mai putea trimite sau primi mesaje n aceast conversaie.';

z.string.ro.modalConversationMessageTooLongHeadline = 'Mesajul este prea lung';
z.string.ro.modalConversationMessageTooLongMessage = 'Nu poi trimite mesaje mai lungi de {{number}} caractere.';

z.string.ro.modalConversationNewDeviceHeadlineOne = '{{user}} a nceput s foloseasc un nou dispozitiv';
z.string.ro.modalConversationNewDeviceHeadlineMany = '{{user}}s au nceput s foloseasc dispozitive noi';
z.string.ro.modalConversationNewDeviceHeadlineYou = '{{user}} a nceput s foloseasc un nou dispozitiv';
z.string.ro.modalConversationNewDeviceIncomingCallAction = 'Accept apelul';
z.string.ro.modalConversationNewDeviceIncomingCallMessage = 'nc mai doreti acest apel?';
z.string.ro.modalConversationNewDeviceMessage = 'nc doreti s fie trimise mesajele?';
z.string.ro.modalConversationNewDeviceOutgoingCallAction = 'Sun oricum';
z.string.ro.modalConversationNewDeviceOutgoingCallMessage = 'nc mai doreti s faci apelul?';

z.string.ro.modalConversationNotConnectedHeadline = 'Nimeni nu a fost adugat la conversaie';
z.string.ro.modalConversationNotConnectedMessageOne = '{{name}} nu dorete s fie adugat la conversaii.';
z.string.ro.modalConversationNotConnectedMessageMany = 'Unul din cei pe care i-ai selectat nu dorete s fie adugat la conversaii.';

z.string.ro.modalConversationRemoveAction = 'terge';
z.string.ro.modalConversationRemoveHeadline = 'terge?';
z.string.ro.modalConversationRemoveMessage = '{{user}} nu va mai putea trimite sau primi mesaje n aceast conversaie.';

z.string.ro.modalConversationRemoveGuestsAction = 'terge';

z.string.ro.modalConversationTooManyMembersHeadline = 'Canalul este plin';

z.string.ro.modalIntegrationUnavailableHeadline = 'Roboii nu sunt momentan disponibili';
z.string.ro.modalIntegrationUnavailableMessage = 'Mulumim c eti interesat de roboi. Acest serviciu este momentan suspendat n timp ce lucrm la urmtoarea versiune. Fii pe faz.';


z.string.ro.modalImproveWireAction = 'Accept';
z.string.ro.modalImproveWireSecondary = 'Nu';

z.string.ro.modalServiceUnavailableHeadline = 'Adugarea serviciului nu este posibil';
z.string.ro.modalServiceUnavailableMessage = 'Acest serviciu este indisponibil momentan.';

z.string.ro.modalSessionResetHeadline = 'Sesiunea a fost resetat';
z.string.ro.modalSessionResetMessage1 = 'Dac problema nu este rezolvat,';
z.string.ro.modalSessionResetMessageLink = 'contacteaz-';
z.string.ro.modalSessionResetMessage2 = 'ne.';

z.string.ro.modalUploadContactsAction = 'Rencearc';
z.string.ro.modalUploadContactsMessage = 'Nu am primit nicio informaie. ncearc importarea contactelor din nou.';

z.string.ro.modalUserBlockAction = 'Blocheaz';
z.string.ro.modalUserBlockHeadline = 'Blocheaz pe {{user}}?';
z.string.ro.modalUserBlockMessage = '{{user}} nu te va putea contacta sau aduga la conversaii de grup.';

z.string.ro.modalUserUnblockAction = 'Deblocheaz';
z.string.ro.modalUserUnblockHeadline = 'Deblocheaz?';
z.string.ro.modalUserUnblockMessage = '{{user}} te va putea contacta i aduga din nou la conversaii de grup.';

z.string.ro.connectionRequestConnect = 'Conectare';
z.string.ro.connectionRequestIgnore = 'Ignor';

z.string.ro.conversationGuestIndicator = 'Vizitator';

z.string.ro.conversationYouNominative = 'tu';
z.string.ro.conversationYouDative = 'tu';
z.string.ro.conversationYouAccusative = 'tu';

z.string.ro.conversationConnectionAccepted = 'Conectat';
z.string.ro.conversationConnectionBlocked = 'Blocat';
z.string.ro.conversationConnectionCancelRequest = 'Anuleaz cererea de conectare';
z.string.ro.conversationCreateWith = 'grosime {{users}}';
z.string.ro.conversationDeviceStartedUsingOne = ' a nceput s foloseasc';
z.string.ro.conversationDeviceStartedUsingMany = ' a nceput s foloseasc';
z.string.ro.conversationDeviceUnverified = ' unul dintre dispozitivele';
z.string.ro.conversationDeviceYourDevices = ' tale neverificate';
z.string.ro.conversationDeviceUserDevices = ' dispozitivele lui {{user}}';
z.string.ro.conversationDeviceNewDeviceOne = ' un nou dispozitiv';
z.string.ro.conversationDeviceNewDeviceMany = ' dispozitive noi';
z.string.ro.conversationDeviceNewPeopleJoinedVerify = ' verific dispozitivele';
z.string.ro.conversationJustNow = 'Chiar acum';
z.string.ro.conversationLocationLink = 'Deschide harta';
z.string.ro.conversationMessageDelivered = 'Livrat';
z.string.ro.conversationRename = ' ai redenumit conversaia';
z.string.ro.conversationRenameYou = ' ai redenumit conversaia';
z.string.ro.conversationResume = 'ncepe o conversaie cu {{users}}';
z.string.ro.conversationPing = ' pinguit';
z.string.ro.conversationPingYou = ' pinguit';
z.string.ro.conversationToday = 'azi';
z.string.ro.conversationVoiceChannelDeactivate = ' sunat';
z.string.ro.conversationVoiceChannelDeactivateYou = ' sunat';
z.string.ro.conversationYesterday = 'ieri';
z.string.ro.conversationUnableToDecrypt1 = 'ai primit un mesaj de la {{user}}.';
z.string.ro.conversationUnableToDecrypt2 = 'identitatea dispozitivului lui {{user}} s-a schimbat. Mesajul nu a fost livrat.';
z.string.ro.conversationUnableToDecryptLink = 'De ce?';
z.string.ro.conversationUnableToDecryptErrorMessage = 'Eroare';
z.string.ro.conversationUnableToDecryptResetSession = 'Reseteaz sesiunea';
z.string.ro.conversationMissedMessages = 'Nu ai folosit acest dispozitiv de ceva timp. Unele mesaje ar putea s nu apar aici.';
z.string.ro.conversationAssetUploading = 'Se ncarc';
z.string.ro.conversationAssetDownloading = 'Se descarc';
z.string.ro.conversationAssetUploadFailed = 'ncrcarea a euat';
z.string.ro.conversationPlaybackError = 'Nu se poate reda';
z.string.ro.conversationContextMenuCopy = 'Copiaz';
z.string.ro.conversationContextMenuEdit = 'Editeaz';
z.string.ro.conversationContextMenuDelete = 'terge pentru mine';
z.string.ro.conversationContextMenuDeleteEveryone = 'terge pentru toat lumea';
z.string.ro.conversationContextMenuDownload = 'Descarc';
z.string.ro.conversationContextMenuLike = 'Apreciaz';
z.string.ro.conversationContextMenuUnlike = 'Nu-mi mai place';
z.string.ro.conversationDeleteTimestamp = 'A fost ters la {{date}}';
z.string.ro.conversationEditTimestamp = 'A fost editat la {{date}}';
z.string.ro.conversationLikesCaption = '{{number}} persoane';
z.string.ro.conversationSendPastedFile = 'A postat o imagine pe {{date}}';
z.string.ro.conversationSomeone = 'Cineva';
z.string.ro.conversationTweetAuthor = ' pe Twitter';

z.string.ro.groupCreationPreferencesAction = 'Mai departe';
z.string.ro.groupCreationPreferencesErrorNameShort = 'Cel puin un caracter';
z.string.ro.groupCreationPreferencesErrorNameLong = 'Prea multe caractere';
z.string.ro.groupCreationPreferencesHeader = 'Grup nou';
z.string.ro.groupCreationPreferencesPlaceholder = 'Nume grup';
z.string.ro.groupCreationParticipantsActionCreate = 'Gata';
z.string.ro.groupCreationParticipantsHeader = 'Adaug persoane';
z.string.ro.groupCreationParticipantsPlaceholder = 'Caut dup nume';


z.string.ro.collectionShowAll = 'Arat toate {{number}}';
z.string.ro.collectionSectionLinks = 'Legturi';
z.string.ro.collectionSectionImages = 'Imagini';
z.string.ro.collectionSectionFiles = 'Fiiere';
z.string.ro.collectionSectionAudio = 'Mesaje audio';

z.string.ro.fullsearchPlaceholder = 'Caut prin mesaje text';
z.string.ro.fullsearchNoResults = 'Fr rezultate.';

z.string.ro.archiveHeader = 'Arhiv';

z.string.ro.conversationsAllArchived = 'Totul a fost arhivat';
z.string.ro.conversationsContacts = 'Contacte';
z.string.ro.conversationsConnectionRequestMany = '{{number}} persoane ateapt';
z.string.ro.conversationsConnectionRequestOne = '1 persoan ateapt';
z.string.ro.conversationsEmptyConversation = 'Conversaie de grup';
z.string.ro.conversationsNoConversations = 'Nu sunt nc conversaii';
z.string.ro.conversationsPopoverArchive = 'Arhiv';
z.string.ro.conversationsPopoverCancel = 'Anuleaz cererea';
z.string.ro.conversationsPopoverNotify = 'Demutizeaz';
z.string.ro.conversationsPopoverSilence = 'Mutizeaz';
z.string.ro.conversationsPopoverUnarchive = 'Dezarhiveaz';

z.string.ro.conversationsSecondaryLineEphemeralMessage = 'i-a trimis un mesaj';
z.string.ro.conversationsSecondaryLinePeopleLeft = '{{number}} persoane au plecat';
z.string.ro.conversationsSecondaryLinePersonLeft = '{{user}} a ieit';
z.string.ro.conversationsSecondaryLinePersonRemoved = '{{user}} a fost scos din conversaie';
z.string.ro.conversationsSecondaryLinePeopleAdded = '{{user}} persoane au fost adugate';
z.string.ro.conversationsSecondaryLinePersonAdded = '{{user}} a fost adugat';
z.string.ro.conversationsSecondaryLinePersonAddedYou = '{{user}} te-a adugat';
z.string.ro.conversationsSecondaryLineRenamed = '{{user}} a redenumit conversaia';
z.string.ro.conversationsSecondaryLineYouLeft = 'Ai ieit';
z.string.ro.conversationsSecondaryLineYouWereRemoved = 'Ai fost scos din conversaie';

z.string.ro.takeoverSub = 'Obine numele tu unic pe Wire.';
z.string.ro.takeoverLink = 'Afl mai multe';
z.string.ro.takeoverButtonChoose = 'Alege propriul nume';
z.string.ro.takeoverButtonKeep = 'Pstreaz acest nume';

z.string.ro.inviteMetaKeyMac = 'Cmd';
z.string.ro.inviteMetaKeyPc = 'Ctrl';
z.string.ro.inviteHeadline = 'Invit persoane pe Wire';
z.string.ro.inviteMessage = 'Bun, sunt pe Wire. Caut-m cu numele {{username}} sau viziteaz get.wire.com.';
z.string.ro.inviteMessageNoEmail = 'Sunt pe Wire. Viziteaz get.wire.com pentru a te conecta cu mine.';

z.string.ro.extensionsBubbleButtonGif = 'Gif';

z.string.ro.extensionsGiphyButtonOk = 'Trimite';
z.string.ro.extensionsGiphyButtonMore = 'ncearc altul';
z.string.ro.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.ro.extensionsGiphyNoGifs = 'Ups, nu sunt gif-uri';
z.string.ro.extensionsGiphyRandom = 'La ntmplare';

z.string.ro.addParticipantsConfirmLabel = 'Adaug';
z.string.ro.addParticipantsHeader = 'Adaug persoane';
z.string.ro.addParticipantsSearchPlaceholder = 'Caut dup nume';
z.string.ro.addParticipantsServiceConfirmButton = 'Adaug serviciu';
z.string.ro.addParticipantsTabsPeople = 'Persoane';
z.string.ro.addParticipantsTabsServices = 'Servicii';

z.string.ro.conversationDetailsActionArchive = 'Arhiv';
z.string.ro.conversationDetailsActionAddParticipants = 'Adaug persoane';
z.string.ro.conversationDetailsActionCancelRequest = 'Anuleaz cererea';
z.string.ro.conversationDetailsActionCreateGroup = 'Grup nou';
z.string.ro.conversationDetailsActionDevices = 'Dispozitive';
z.string.ro.conversationDetailsActionNotifications = 'Notificri';
z.string.ro.conversationDetailsGuestsOff = 'nchis';
z.string.ro.conversationDetailsOptions = 'Opiuni';
z.string.ro.conversationDetailsParticipantsServicesMany = 'Servicii';
z.string.ro.conversationDetailsParticipantsUsersMany = 'Persoane';
z.string.ro.conversationDetailsPeople = 'Persoane';
z.string.ro.conversationDetailsServices = 'Servicii';

z.string.ro.conversationParticipantsTitle = 'Persoane';
z.string.ro.conversationParticipantsSearchPlaceholder = 'Caut dup nume';

z.string.ro.groupParticipantActionCancelRequest = 'Anuleaz cererea';
z.string.ro.groupParticipantActionDevices = 'Dispozitive';
z.string.ro.groupParticipantActionPending = 'n ateptare';
z.string.ro.groupParticipantActionSendRequest = 'Conectare';

z.string.ro.notificationSettingsTitle = 'Notificri';

z.string.ro.participantDevicesDetailHeadline = 'Verific dac aceasta se potrivete cu amprenta artat n {{html1}}dispozitivul al lui {{user}}{{html2}}.';
z.string.ro.participantDevicesDetailHowTo = 'Cum fac asta?';
z.string.ro.participantDevicesDetailResetSession = 'Reseteaz sesiunea';
z.string.ro.participantDevicesDetailShowMyDevice = 'Arat amprenta dispozitivului';
z.string.ro.participantDevicesDetailVerify = 'Verificat';

z.string.ro.participantDevicesHeader = 'Dispozitive';
z.string.ro.participantDevicesHeadline = 'Wire ofer fiecrui dispozitiv o amprent unic. Compar amprentele cu {{user}} i verific conversaia.';
z.string.ro.participantDevicesLearnMore = 'Afl mai multe';
z.string.ro.participantDevicesWhyVerify = 'De ce s verific aceast conversaie?';
z.string.ro.participantDevicesOutdatedClientMessage = '{{user}} folosete o versiune veche de Wire. Nu sunt afiate dispozitive.';

z.string.ro.participantDevicesSelfAllDevices = 'Arat toate dispozitivele mele';
z.string.ro.participantDevicesSelfFingerprint = 'Amprent dispozitiv';

z.string.ro.userProfileButtonConnect = 'Conectare';
z.string.ro.userProfileButtonIgnore = 'Ignor';
z.string.ro.userProfileButtonUnblock = 'Deblocheaz';

z.string.ro.preferencesAbout = 'Despre';
z.string.ro.preferencesAccount = 'Cont';
z.string.ro.preferencesAV = 'Audio / video';
z.string.ro.preferencesDeviceDetails = 'Detalii dispozitiv';
z.string.ro.preferencesDevices = 'Dispozitive';
z.string.ro.preferencesHeadline = 'Preferine';
z.string.ro.preferencesOptions = 'Opiuni';

z.string.ro.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.ro.preferencesAboutPrivacyPolicy = 'Politic de confidenialitate';
z.string.ro.preferencesAboutSupport = 'Suport';
z.string.ro.preferencesAboutSupportWebsite = 'Site de suport';
z.string.ro.preferencesAboutSupportContact = 'Contacteaz echipa de asisten';
z.string.ro.preferencesAboutTermsOfUse = 'Termeni de folosire';
z.string.ro.preferencesAboutVersion = 'Versiune {{version}}';
z.string.ro.preferencesAboutWebsite = 'Site web Wire';

z.string.ro.preferencesAccountAvaibilityUnset = 'Stabilete o stare';
z.string.ro.preferencesAccountCreateTeam = 'Creeaz o echip';
z.string.ro.preferencesAccountDelete = 'terge contul';
z.string.ro.preferencesAccountLogOut = 'Deconectare';
z.string.ro.preferencesAccountManageTeam = 'Gestioneaz o echip';
z.string.ro.preferencesAccountResetPassword = 'Reseteaz parola';
z.string.ro.preferencesAccountTeam = 'n {{name}}';
z.string.ro.preferencesAccountUsernamePlaceholder = 'Numele tu complet';
z.string.ro.preferencesAccountUsernameHint = 'Cel puin dou caractere. Doar az, 09 i _ sunt permise.';
z.string.ro.preferencesAccountUsernameAvailable = 'Disponibil';
z.string.ro.preferencesAccountUsernameErrorTaken = 'Deja folosit';

z.string.ro.preferencesAVCamera = 'Camer';
z.string.ro.preferencesAVMicrophone = 'Microfon';
z.string.ro.preferencesAVPermissionDetail = 'Activeaz din preferinele browserului';
z.string.ro.preferencesAVSpeakers = 'Difuzoare';

z.string.ro.preferencesDevicesActivatedOn = 'Activat la {{date}}';
z.string.ro.preferencesDevicesActive = 'Activ';
z.string.ro.preferencesDevicesActiveDetail = 'Dac nu recunoti un dispozitiv de mai sus, elimin-l i reseteaz parola.';
z.string.ro.preferencesDevicesCurrent = 'Curent';
z.string.ro.preferencesDevicesFingerprint = 'Amprent cheie';
z.string.ro.preferencesDevicesFingerprintDetail = 'Wire genereaz cte o amprent unic pentru fiecare dispozitiv. Compar-le i verific dispozitivele i conversaiile tale.';
z.string.ro.preferencesDevicesId = 'ID: ';
z.string.ro.preferencesDevicesRemoveCancel = 'Renun';
z.string.ro.preferencesDevicesRemoveDetail = 'Elimin acest dispozitiv dac nu-l mai foloseti. Vei fi deconectat de pe acest dispozitiv imediat.';
z.string.ro.preferencesDevicesSessionConfirmation = 'Sesiunea a fost resetat.';
z.string.ro.preferencesDevicesSessionDetail = 'Dac amprentele nu se potrivesc, reseteaz sesiunea pentru a genera un nou set de chei de criptare pentru ambele pri.';
z.string.ro.preferencesDevicesSessionReset = 'Reseteaz sesiunea';
z.string.ro.preferencesDevicesSessionOngoing = 'Se reseteaz sesiunea';
z.string.ro.preferencesDevicesVerification = 'Verificat';

z.string.ro.preferencesOptionsAudio = 'Alerte sonore';
z.string.ro.preferencesOptionsAudioAll = 'Toate';
z.string.ro.preferencesOptionsAudioAllDetail = 'Toate sunetele';
z.string.ro.preferencesOptionsAudioNone = 'Niciunul';
z.string.ro.preferencesOptionsAudioNoneDetail = 'Psst!';
z.string.ro.preferencesOptionsAudioSome = 'Unele';
z.string.ro.preferencesOptionsAudioSomeDetail = 'Bipuri i apeluri';
z.string.ro.preferencesOptionsContacts = 'Contacte';
z.string.ro.preferencesOptionsContactsGmail = 'Import din Gmail';
z.string.ro.preferencesOptionsContactsMacos = 'Import din contacte';
z.string.ro.preferencesOptionsContactsDetail = 'Vom folosi datele tale de contact pentru a te conecta cu alii. Vom anonimiza toate informaiile i nu le vom mprti cu altcineva.';
z.string.ro.preferencesOptionsPopular = 'n urma cererilor populare';
z.string.ro.preferencesOptionsEmojiReplaceCheckbox = 'nlocuiete emoticoanele cu emoji';
z.string.ro.preferencesOptionsPreviewsSendCheckbox = 'Creeaz previzualizri pentru linkurile pe care le trimii';
z.string.ro.preferencesOptionsPreviewsSendDetail = 'Previzualizrile mai pot fi artate pentru linkuri din partea altor persoane.';
z.string.ro.preferencesOptionsNotifications = 'Notificri';
z.string.ro.preferencesOptionsNotificationsNone = 'nchis';
z.string.ro.preferencesOptionsNotificationsObfuscate = 'Ascunde detaliile';
z.string.ro.preferencesOptionsNotificationsObfuscateMessage = 'Arat expeditorul';
z.string.ro.preferencesOptionsNotificationsOn = 'Arat expeditorul i mesajul';

z.string.ro.backupImportGenericErrorHeadline = 'Ceva nu a mers bine';
z.string.ro.backupCancel = 'Renun';

z.string.ro.searchConnect = 'Conectare';
z.string.ro.searchConnections = 'Conexiuni';
z.string.ro.searchContacts = 'Contacte';
z.string.ro.searchCreateGroup = 'Creeaz grup';
z.string.ro.searchGroups = 'Grupuri';
z.string.ro.searchPeople = 'Persoane';
z.string.ro.searchPlaceholder = 'Caut dup nume sau nume utilizator';
z.string.ro.searchServicePlaceholder = 'Caut dup nume';
z.string.ro.searchServices = 'Servicii';
z.string.ro.searchTeamGroups = 'Conversaii de echip';
z.string.ro.searchTeamMembers = 'Membrii echipei';
z.string.ro.searchTopPeople = 'Top persoane';
z.string.ro.searchTrySearch = 'Caut oameni dup\nnume sau nume utilizator';
z.string.ro.searchNoContactsOnWire = 'Nu ai contacte pe Wire.\nncearc s gsete oameni dup\nnume sau nume utilizator.';
z.string.ro.searchMemberInvite = 'Invit oameni n echip';
z.string.ro.searchOthers = 'Conectare';

z.string.ro.searchInvite = 'Invit persoane pe Wire';
z.string.ro.searchInviteDetail = 'mprtirea contactelor ne ajut s te conectm cu alii. Noi anonimizm toate informaiile i nu le mprtim cu teri.';
z.string.ro.searchInviteButtonContacts = 'Din Contacte';
z.string.ro.searchInviteButtonGmail = 'Din Gmail';
z.string.ro.searchInviteHeadline = 'Invit prietenii';
z.string.ro.searchInviteShare = 'mprtete contacte';

z.string.ro.searchServiceConfirmButton = 'Adaug serviciu';

z.string.ro.searchListEveryoneParticipates = 'Toat lumea cu care\neti conectat este deja\nn aceast conversaie.';
z.string.ro.searchListNoMatches = 'Nu s-a gsit nimic.\nncearc s scrii un alt nume.';


z.string.ro.uploadGoogleHeadline = 'Caut persoane\ncu care s vorbeti.';
z.string.ro.uploadGoogleMessage = 'Vom folosi datele tale de contact pentru a te conecta cu alii. Vom anonimiza toate informaiile i nu le vom mprti cu altcineva.';

z.string.ro.warningCallUnsupportedIncoming = '{{user}} te sun. Browserul tu nu suport apelurile.';
z.string.ro.warningCallUnsupportedOutgoing = 'Nu poi suna pentru c browserul tu nu suport apelurile.';
z.string.ro.warningCallIssues = 'Aceast versiune de Wire nu poate participa ntr-un apel. Te rugm s foloseti';
z.string.ro.warningCallUpgradeBrowser = 'Pentru a suna, te rugm s actualizezi Google Chrome.';
z.string.ro.warningConnectivityConnectionLost = 'Se ncearc conectarea. Wire ar putea s nu trimit mesaje n acest timp.';
z.string.ro.warningConnectivityNoInternet = 'Nu este conexiune la internet. Nu vei putea trimite sau primi mesaje.';
z.string.ro.warningLearnMore = 'Afl mai multe';
z.string.ro.warningLifecycleUpdate = 'Este disponibil o nou versiune de Wire.';
z.string.ro.warningLifecycleUpdateNotes = 'Ce mai e nou';
z.string.ro.warningLifecycleUpdateLink = 'Actualizeaz acum';
z.string.ro.warningNotFoundCamera = 'Nu poi suna pentru c acest dispozitiv nu are o camer.';
z.string.ro.warningNotFoundMicrophone = 'Nu poi suna pentru c acest dispozitiv nu are un microfon.';
z.string.ro.warningPermissionDeniedCamera = 'Nu poi suna pentru c browserul tu nu are acces la camer.';
z.string.ro.warningPermissionDeniedMicrophone = 'Nu poi suna pentru c browserul tu nu are acces la microfon.';
z.string.ro.warningPermissionDeniedScreen = 'Browserul tu are nevoie de permisiuni pentru a partaja ecranul.';
z.string.ro.warningPermissionRequestCamera = '{{icon}} permite accesul la camer';
z.string.ro.warningPermissionRequestMicrophone = '{{icon}} permit accesul la microfon';
z.string.ro.warningPermissionRequestNotification = '{{icon}} permite notificrile';
z.string.ro.warningPermissionRequestScreen = '{{icon}} permite accesul la ecran';

z.string.ro.userAvailabilityAvailable = 'Disponibil';
z.string.ro.userAvailabilityAway = 'Departe';
z.string.ro.userAvailabilityBusy = 'Ocupat';
z.string.ro.userAvailabilityNone = 'Niciunul';

z.string.ro.notificationAssetAdd = 'A mprtit o imagine';
z.string.ro.notificationConnectionAccepted = 'A acceptat cererea de conectare a ta';
z.string.ro.notificationConnectionConnected = 'Acum eti conectat';
z.string.ro.notificationConnectionRequest = 'Ateapt conectarea';
z.string.ro.notificationConversationCreate = '{{user}} a nceput o conversaie';
z.string.ro.notificationConversationRename = '{{user}} a redenumit conversaia n {{name}}';
z.string.ro.notificationMemberJoinMany = '{{user}} a adugat {{number}} persoane la conversaie';
z.string.ro.notificationMemberJoinOne = '{{user1}} a adugat pe {{user2}} la conversaie';
z.string.ro.notificationMemberLeaveRemovedYou = '{{user}} te-a scos din conversaie';
z.string.ro.notificationObfuscated = 'i-a trimis un mesaj';
z.string.ro.notificationObfuscatedTitle = 'Cineva';
z.string.ro.notificationPing = 'Pinguit';
z.string.ro.notificationReaction = '{{reaction}} la mesajul tu';
z.string.ro.notificationSharedAudio = 'A mprtit un mesaj audio';
z.string.ro.notificationSharedFile = 'A distribuit un fiier';
z.string.ro.notificationSharedLocation = 'A distribuit o locaie';
z.string.ro.notificationSharedVideo = 'A distribuit un video';
z.string.ro.notificationVoiceChannelActivate = 'Se sun';
z.string.ro.notificationVoiceChannelDeactivate = 'Apel n curs';

z.string.ro.tooltipConversationAllVerified = 'Toate amprentele sunt verificate';
z.string.ro.tooltipConversationCall = 'Sun';
z.string.ro.tooltipConversationEphemeral = 'Mesaj temporizat';
z.string.ro.tooltipConversationFile = 'Adaug fiier';
z.string.ro.tooltipConversationInputPlaceholder = 'Scrie un mesaj';
z.string.ro.tooltipConversationInputPlaceholderAvailable = '{{user}} este disponibil';
z.string.ro.tooltipConversationInputPlaceholderAway = '{{user}} este plecat';
z.string.ro.tooltipConversationInputPlaceholderBusy = '{{user}} este ocupat';
z.string.ro.tooltipConversationPeople = 'Persoane ({{shortcut}})';
z.string.ro.tooltipConversationPicture = 'Adaug poz';
z.string.ro.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.ro.tooltipConversationSearch = 'Caut';
z.string.ro.tooltipConversationVideoCall = 'Apel video';

z.string.ro.tooltipConversationsArchive = 'Arhiveaz ({{shortcut}})';
z.string.ro.tooltipConversationsArchived = 'Arat arhiva ({{number}})';
z.string.ro.tooltipConversationsMore = 'Mai multe';
z.string.ro.tooltipConversationsNotify = 'Demutizeaz ({{shortcut}})';
z.string.ro.tooltipConversationsPreferences = 'Deschide preferinele';
z.string.ro.tooltipConversationsSilence = 'Mutizeaz ({{shortcut}})';
z.string.ro.tooltipConversationsStart = 'ncepe conversaia ({{shortcut}})';

z.string.ro.tooltipConversationDetailsRename = 'Schimb numele conversaiei';

z.string.ro.tooltipPreferencesContactsGmail = 'Autentific-te n conturile Gmail pentru a partaja contacte';
z.string.ro.tooltipPreferencesContactsMacos = 'Partajeaz toate contactele de pe aplicaia Contacts din macOS';
z.string.ro.tooltipPreferencesPassword = 'Deschide un alt site web pentru a reseta parola';
z.string.ro.tooltipPreferencesPicture = 'Schimb poza de profil';
z.string.ro.tooltipPreferencesRename = 'Schimb numele tu';

z.string.ro.tooltipSearchClose = 'nchide (Esc)';

z.string.ro.initReceivedSelfUser = 'Bun, {{user}}.';
z.string.ro.initValidatedClient = 'Se ncarc conexiunile i conversaiile tale';
z.string.ro.initReceivedUserData = 'Verific dac sunt mesaje noi';
z.string.ro.initDecryption = 'Se decripteaz mesaje';
z.string.ro.initEvents = 'Se ncarc mesaje';
z.string.ro.initUpdatedFromNotifications = 'Aproape gata - Bucur-te de Wire';
z.string.ro.initProgress = '  {{number1}} din {{number2}}';

z.string.ro.ephemeralUnitsNone = 'nchis';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.ru.wire = 'Wire';
z.string.ru.wireMacos = 'Wire  macOS';
z.string.ru.wireWindows = 'Wire  Windows';
z.string.ru.wireLinux = 'Wire  Linux';
z.string.ru.nonexistentUser = ' ';
z.string.ru.and = '';
z.string.ru.enumerationAnd = ',  ';

//= 
z.string.ru.authAccountCountryCode = ' ';
z.string.ru.authAccountPasswordForgot = ' ';
z.string.ru.authAccountPublicComputer = '  ';
z.string.ru.authAccountSignIn = '';
z.string.ru.authAccountSignInPhone = '   ';

z.string.ru.authBlockedCookies = '  cookie,    Wire.';
z.string.ru.authBlockedDatabase = '   Wire     .      .';
z.string.ru.authBlockedTabs = 'Wire     .';
z.string.ru.authBlockedTabsAction = '    ';

z.string.ru.authVerifyAccountAdd = '';
z.string.ru.authVerifyAccountDetail = '   Wire   .';
z.string.ru.authVerifyAccountHeadline = ' email  .';
z.string.ru.authVerifyAccountLogout = '';
z.string.ru.authVerifyCodeDescription = '  ,\n    {{number}}.';
z.string.ru.authVerifyCodeResend = '  ?';
z.string.ru.authVerifyCodeResendDetail = ' ';
z.string.ru.authVerifyCodeResendTimer = '     {{expiration}}.';
z.string.ru.authVerifyCodeChangePhone = '  ';
z.string.ru.authVerifyPasswordHeadline = '  ';

z.string.ru.authLimitDevicesHeadline = '';
z.string.ru.authLimitDescription = '    ,    Wire  .';
z.string.ru.authLimitButtonManage = '';
z.string.ru.authLimitButtonSignOut = '';
z.string.ru.authLimitDevicesCurrent = '()';

z.string.ru.authHistoryHeadline = '   Wire   .';
z.string.ru.authHistoryDescription = '      .';
z.string.ru.authHistoryReuseHeadline = '   Wire   .';
z.string.ru.authHistoryReuseDescription = ',     ,  .';
z.string.ru.authHistoryButton = 'OK';

z.string.ru.authPostedResend = '   {{email}}';
z.string.ru.authPostedResendAction = '  ?';
z.string.ru.authPostedResendDetail = '      .';
z.string.ru.authPostedResendHeadline = ' .';

z.string.ru.authPlaceholderEmail = 'Email';
z.string.ru.authPlaceholderPasswordPut = '';
z.string.ru.authPlaceholderPasswordSet = ' ( 8 )';
z.string.ru.authPlaceholderPhone = ' ';

z.string.ru.authErrorCode = ' ';
z.string.ru.authErrorCountryCodeInvalid = '  ';
z.string.ru.authErrorEmailExists = 'Email  ';
z.string.ru.authErrorEmailForbidden = ',   email .';
z.string.ru.authErrorEmailMalformed = ',   email.';
z.string.ru.authErrorEmailMissing = ',  email.';
z.string.ru.authErrorMisc = '  . ,   .';
z.string.ru.authErrorNameShort = '     2 ';
z.string.ru.authErrorOffline = '   ';
z.string.ru.authErrorPasswordShort = '     8 .';
z.string.ru.authErrorPasswordWrong = ' . ,   .';
z.string.ru.authErrorPending = '   ';
z.string.ru.authErrorPhoneNumberBudget = '       .';
z.string.ru.authErrorPhoneNumberForbidden = ',    .';
z.string.ru.authErrorPhoneNumberInvalid = '  ';
z.string.ru.authErrorPhoneNumberUnknown = '  ';
z.string.ru.authErrorSuspended = '   .';
z.string.ru.authErrorSignIn = '     .';

z.string.ru.callStateOutgoing = '';
z.string.ru.callStateConnecting = '';
z.string.ru.callStateIncoming = '';
z.string.ru.callStateIncomingGroup = '{{user}} ';
z.string.ru.callDecline = '';
z.string.ru.callAccept = '';
z.string.ru.callJoin = '';
z.string.ru.callChooseSharedScreen = '    ';
z.string.ru.callParticipants = '{{number}} ';
z.string.ru.callNoCameraAccess = '   ';

z.string.ru.videoCallOverlayFitVideoLabel = '        ';
z.string.ru.videoCallOverlayConversations = '';
z.string.ru.videoCallOverlayMute = '';
z.string.ru.videoCallOverlayVideo = '';
z.string.ru.videoCallOverlayShareScreen = ' ';
z.string.ru.videoCallOverlayHangUp = ' ';
z.string.ru.videoCallPaused = ' ';
z.string.ru.videoCallScreenShareNotSupported = '      ';

z.string.ru.modalAcknowledgeAction = 'Ok';
z.string.ru.modalAcknowledgeHeadline = '-   ';
z.string.ru.modalConfirmSecondary = '';
z.string.ru.modalOptionSecondary = '';

z.string.ru.modalAccountCreateAction = 'OK';
z.string.ru.modalAccountCreateHeadline = ' ?';
z.string.ru.modalAccountCreateMessage = '  ,        .';

z.string.ru.modalAccountDeletionAction = '';
z.string.ru.modalAccountDeletionHeadline = ' ';
z.string.ru.modalAccountDeletionMessage = '     email  SMS.   ,     .';

z.string.ru.modalAccountLeaveGuestRoomAction = '';
z.string.ru.modalAccountLeaveGuestRoomHeadline = '  ?';
z.string.ru.modalAccountLeaveGuestRoomMessage = '   .      ,     .';

z.string.ru.modalAccountLogoutAction = '';
z.string.ru.modalAccountLogoutHeadline = ' ?';
z.string.ru.modalAccountLogoutOption = '        .';

z.string.ru.modalAccountNewDevicesSecondary = '';
z.string.ru.modalAccountNewDevicesHeadline = '  :';
z.string.ru.modalAccountNewDevicesFrom = ':';
z.string.ru.modalAccountNewDevicesMessage = '    ,      .';

z.string.ru.modalAccountRemoveDeviceAction = ' ';
z.string.ru.modalAccountRemoveDeviceHeadline = ' "{{device}}"';
z.string.ru.modalAccountRemoveDeviceMessage = '     .';
z.string.ru.modalAccountRemoveDevicePlaceholder = '';

z.string.ru.modalAssetTooLargeHeadline = '  ';
z.string.ru.modalAssetTooLargeMessage = '      {{number}}';

z.string.ru.modalAssetParallelUploadsHeadline = '   ';
z.string.ru.modalAssetParallelUploadsMessage = '    {{number}}   .';

z.string.ru.modalCallEmptyConversationHeadline = ' ';
z.string.ru.modalCallEmptyConversationMessage = '   .';

z.string.ru.modalCallEmptyLogHeadline = ' ';
z.string.ru.modalCallEmptyLogMessage = '        .';

z.string.ru.modalCallNoGroupVideoHeadline = '   ';
z.string.ru.modalCallNoGroupVideoMessage = '    .';

z.string.ru.modalCallNoMicrophoneAction = ' , ';
z.string.ru.modalCallNoMicrophoneMessage = '        .';
z.string.ru.modalCallNoMicrophoneHeadline = '      ';

z.string.ru.modalCallSecondIncomingAction = '';
z.string.ru.modalCallSecondIncomingHeadline = '  ?';
z.string.ru.modalCallSecondIncomingMessage = '    .';

z.string.ru.modalCallSecondOngoingAction = ' ';
z.string.ru.modalCallSecondOngoingHeadline = '    ?';
z.string.ru.modalCallSecondOngoingMessage = '      .';

z.string.ru.modalCallSecondOutgoingAction = '';
z.string.ru.modalCallSecondOutgoingHeadline = '  ?';
z.string.ru.modalCallSecondOutgoingMessage = '      .   ,    .';

z.string.ru.modalConnectCancelAction = '';
z.string.ru.modalConnectCancelHeadline = ' ?';
z.string.ru.modalConnectCancelMessage = '    {{user}}.';
z.string.ru.modalConnectCancelSecondary = '';

z.string.ru.modalConnectAcceptAction = '';
z.string.ru.modalConnectAcceptHeadline = '?';
z.string.ru.modalConnectAcceptMessage = '    {{user}}   .';
z.string.ru.modalConnectAcceptSecondary = '';

z.string.ru.modalConversationClearAction = '';
z.string.ru.modalConversationClearHeadline = ' ?';
z.string.ru.modalConversationClearMessage = '       .';
z.string.ru.modalConversationClearOption = '  ';

z.string.ru.modalConversationDeleteMessageAction = '';
z.string.ru.modalConversationDeleteMessageHeadline = '   ?';
z.string.ru.modalConversationDeleteMessageMessage = '    .';

z.string.ru.modalConversationDeleteMessageEveryoneAction = '';
z.string.ru.modalConversationDeleteMessageEveryoneHeadline = '  ?';
z.string.ru.modalConversationDeleteMessageEveryoneMessage = '    .';

z.string.ru.modalConversationLeaveAction = '';
z.string.ru.modalConversationLeaveHeadline = '  {{name}}?';
z.string.ru.modalConversationLeaveMessage = '         .';

z.string.ru.modalConversationMessageTooLongHeadline = '  ';
z.string.ru.modalConversationMessageTooLongMessage = '      {{number}} .';

z.string.ru.modalConversationNewDeviceAction = '';
z.string.ru.modalConversationNewDeviceHeadlineOne = '{{user}} ()   ';
z.string.ru.modalConversationNewDeviceHeadlineMany = '{{users}}    ';
z.string.ru.modalConversationNewDeviceHeadlineYou = '{{user}}    ';
z.string.ru.modalConversationNewDeviceIncomingCallAction = ' ';
z.string.ru.modalConversationNewDeviceIncomingCallMessage = '    ?';
z.string.ru.modalConversationNewDeviceMessage = '      ?';
z.string.ru.modalConversationNewDeviceOutgoingCallAction = '';
z.string.ru.modalConversationNewDeviceOutgoingCallMessage = '   ?';

z.string.ru.modalConversationNotConnectedHeadline = '     ';
z.string.ru.modalConversationNotConnectedMessageOne = '{{name}}  ,     .';
z.string.ru.modalConversationNotConnectedMessageMany = '      ,     .';

z.string.ru.modalConversationRemoveAction = '';
z.string.ru.modalConversationRemoveHeadline = '?';
z.string.ru.modalConversationRemoveMessage = '{{user}}          .';

z.string.ru.modalConversationRemoveGuestsAction = '';
z.string.ru.modalConversationRemoveGuestsHeadline = ' ?';
z.string.ru.modalConversationRemoveGuestsMessage = '       .       .';

z.string.ru.modalConversationRevokeLinkAction = ' ';
z.string.ru.modalConversationRevokeLinkHeadline = '  ?';
z.string.ru.modalConversationRevokeLinkMessage = '       .       .';

z.string.ru.modalConversationGuestOptionsAllowGuestMessage = '     .  .';
z.string.ru.modalConversationGuestOptionsDisableGuestMessage = '     .  .';
z.string.ru.modalConversationGuestOptionsGetCodeMessage = '     .';
z.string.ru.modalConversationGuestOptionsRequestCodeMessage = '     .  .';
z.string.ru.modalConversationGuestOptionsRevokeCodeMessage = '     .  .';
z.string.ru.modalConversationGuestOptionsToggleGuestsMessage = '    .';

z.string.ru.modalConversationTooManyMembersHeadline = '  ';
z.string.ru.modalConversationTooManyMembersMessage = '     {{number1}} .          {{number2}} .';

z.string.ru.modalGifTooLargeHeadline = '   ';
z.string.ru.modalGifTooLargeMessage = '  {{number}} .';

z.string.ru.modalIntegrationUnavailableHeadline = '    ';
z.string.ru.modalIntegrationUnavailableMessage = '     .     ,      .   .';

z.string.ru.modalPictureFileFormatHeadline = '    ';
z.string.ru.modalPictureFileFormatMessage = '  PNG  JPEG.';

z.string.ru.modalPictureTooLargeHeadline = '   ';
z.string.ru.modalPictureTooLargeMessage = '      {{number}} .';

z.string.ru.modalPictureTooSmallHeadline = '  ';
z.string.ru.modalPictureTooSmallMessage = '     320 x 320 .';

z.string.ru.modalImproveWireAction = '';
z.string.ru.modalImproveWireSecondary = '';
z.string.ru.modalImproveWireHeadline = '   Wire ';
z.string.ru.modalImproveWireMessage = '   ,  Wire              Wire.        .';

z.string.ru.modalServiceUnavailableHeadline = '  ';
z.string.ru.modalServiceUnavailableMessage = '     .';

z.string.ru.modalSessionResetHeadline = '  ';
z.string.ru.modalSessionResetMessage1 = '   ,';
z.string.ru.modalSessionResetMessageLink = 'c';
z.string.ru.modalSessionResetMessage2 = ' .';

z.string.ru.modalUploadContactsAction = '';
z.string.ru.modalUploadContactsMessage = '    .     .';

z.string.ru.modalUserBlockAction = '';
z.string.ru.modalUserBlockHeadline = ' {{user}}?';
z.string.ru.modalUserBlockMessage = '{{user}}            .';

z.string.ru.modalUserUnblockAction = '';
z.string.ru.modalUserUnblockHeadline = '?';
z.string.ru.modalUserUnblockMessage = '{{user}}           .';

z.string.ru.modalNoCameraTitle = '   ';
z.string.ru.modalNoCameraMessage = ' Wire    .[br][faqLink]  [/faqLink],  ,   .';

z.string.ru.connectionRequestConnect = '';
z.string.ru.connectionRequestIgnore = '';

z.string.ru.conversationGuestIndicator = '';
z.string.ru.userRemainingTimeHours = ' {{time}} .';
z.string.ru.userRemainingTimeMinutes = '  {{time}} .';

z.string.ru.conversationYouNominative = '';
z.string.ru.conversationYouDative = '';
z.string.ru.conversationYouAccusative = '';

z.string.ru.conversationConnectionAccepted = '()';
z.string.ru.conversationConnectionBlocked = '()';
z.string.ru.conversationConnectionCancelRequest = ' ';
z.string.ru.conversationCreateTemporary = '   ';
z.string.ru.conversationCreateWith = '  {{users}}';
z.string.ru.conversationDeviceStartedUsingOne = ' () ';
z.string.ru.conversationDeviceStartedUsingMany = '  ';
z.string.ru.conversationDeviceUnverified = '   ';
z.string.ru.conversationDeviceYourDevices = '  ';
z.string.ru.conversationDeviceUserDevices = '  {{user}}';
z.string.ru.conversationDeviceNewDeviceOne = '  ';
z.string.ru.conversationDeviceNewDeviceMany = '  ';
z.string.ru.conversationDeviceNewPeopleJoined = '  .';
z.string.ru.conversationDeviceNewPeopleJoinedVerify = ' ';
z.string.ru.conversationJustNow = ' ';
z.string.ru.conversationLocationLink = ' ';
z.string.ru.conversationCreated = '[bold]{{name}}}[/bold] ()   {{users}}';
z.string.ru.conversationCreatedMore = '[bold]{{name}}[/bold] ()   {{users}}   [showmore]{{count}} [/showmore]';
z.string.ru.conversationCreatedName = '[bold]{{name}}[/bold] () ';
z.string.ru.conversationCreatedNameYou = '[bold][/bold]  ';
z.string.ru.conversationCreatedYou = '    {{users}}';
z.string.ru.conversationCreatedYouMore = '    {{users}}   [showmore]{{count}}[/showmore]';
z.string.ru.conversationCreateWithMore = ' {{users}},   [showmore]{{count}}[/showmore]';
z.string.ru.conversationCreateTeam = ' [showmore]  [/showmore]';
z.string.ru.conversationCreateTeamGuest = ' [showmore]     [/showmore]';
z.string.ru.conversationCreateTeamGuests = ' [showmore]    {{count}} [/showmore]';
z.string.ru.conversationMemberJoined = '[bold]{{name}}[/bold] () {{users}}  ';
z.string.ru.conversationMemberJoinedYou = '[bold][/bold]  {{users}}  ';
z.string.ru.conversationMemberJoinedMore = '[bold]{{name}}[/bold] ()   {{users}}   [showmore]{{count}}[/showmore]';
z.string.ru.conversationMemberJoinedYouMore = '[bold][/bold]    {{users}}   [showmore]{{count}}[/showmore]';
z.string.ru.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] (-)';
z.string.ru.conversationMemberJoinedSelfYou = '[bold][/bold] ';
z.string.ru.conversationMemberLeft = '[bold]{{name}}[/bold] ()';
z.string.ru.conversationMemberLeftYou = '[bold][/bold] ';
z.string.ru.conversationMemberRemoved = '[bold]{{name}}[/bold] () {{users}}';
z.string.ru.conversationMemberRemovedYou = '[bold][/bold]  {{users}}';
z.string.ru.conversationTeamLeft = '[bold]{{name}}[/bold]    ';
z.string.ru.conversationMessageDelivered = '';
z.string.ru.conversationRename = ' () ';
z.string.ru.conversationRenameYou = '  ';
z.string.ru.conversationUpdatedTimer = ' ()    {{time}}';
z.string.ru.conversationUpdatedTimerYou = '     {{time}}';
z.string.ru.conversationResetTimer = ' ()  ';
z.string.ru.conversationResetTimerYou = '   ';
z.string.ru.conversationResume = '   {{users}}';
z.string.ru.conversationPing = ' () ';
z.string.ru.conversationPingYou = '  ';
z.string.ru.conversationToday = '';
z.string.ru.conversationVoiceChannelDeactivate = ' ()';
z.string.ru.conversationVoiceChannelDeactivateYou = ' ';
z.string.ru.conversationYesterday = '';
z.string.ru.conversationUnableToDecrypt1 = '  [highlight]{{user}}[/highlight]   .';
z.string.ru.conversationUnableToDecrypt2 = '  [highlight]{{user}}[/highlight] .   .';
z.string.ru.conversationUnableToDecryptLink = '?';
z.string.ru.conversationUnableToDecryptErrorMessage = '';
z.string.ru.conversationUnableToDecryptResetSession = ' ';
z.string.ru.conversationMissedMessages = '      .     .';
z.string.ru.conversationAssetUploading = '';
z.string.ru.conversationAssetDownloading = '';
z.string.ru.conversationAssetUploadFailed = ' ';
z.string.ru.conversationPlaybackError = ' ';
z.string.ru.conversationContextMenuCopy = '';
z.string.ru.conversationContextMenuEdit = '';
z.string.ru.conversationContextMenuDelete = '  ';
z.string.ru.conversationContextMenuDeleteEveryone = '  ';
z.string.ru.conversationContextMenuDownload = '';
z.string.ru.conversationContextMenuLike = '';
z.string.ru.conversationContextMenuReply = '';
z.string.ru.conversationContextMenuUnlike = ' ';
z.string.ru.conversationDeleteTimestamp = ': {{date}}';
z.string.ru.conversationEditTimestamp = ': {{date}}';
z.string.ru.conversationLikesCaption = '{{number}} ';
z.string.ru.conversationSendPastedFile = '  {{date}}';
z.string.ru.conversationSomeone = '-';
z.string.ru.conversationTweetAuthor = '  Twitter';
z.string.ru.conversationServicesWarning = '      ';

z.string.ru.groupCreationPreferencesAction = '';
z.string.ru.groupCreationPreferencesErrorNameShort = '  1 ';
z.string.ru.groupCreationPreferencesErrorNameLong = '  ';
z.string.ru.groupCreationPreferencesHeader = ' ';
z.string.ru.groupCreationPreferencesPlaceholder = ' ';
z.string.ru.groupCreationParticipantsActionCreate = '';
z.string.ru.groupCreationParticipantsActionSkip = '';
z.string.ru.groupCreationParticipantsHeader = ' ';
z.string.ru.groupCreationParticipantsHeaderWithCounter = '  ({{number}})';
z.string.ru.groupCreationParticipantsPlaceholder = '  ';
z.string.ru.groupSizeInfo = '      {{count}} .        .';

z.string.ru.guestRoomConversationName = ' ';
z.string.ru.guestRoomToggleName = '   ';
z.string.ru.guestRoomToggleInfo = '          .';
z.string.ru.guestRoomToggleInfoExtended = '          .      .';

z.string.ru.guestRoomConversationBadge = ' ';
z.string.ru.guestRoomConversationBadgeService = ' ';
z.string.ru.guestRoomConversationBadgeGuestAndService = '   ';

z.string.ru.guestRoomConversationHead = '         .';
z.string.ru.guestRoomConversationButton = ' ';

z.string.ru.collectionShowAll = '  {{number}}';
z.string.ru.collectionSectionLinks = '';
z.string.ru.collectionSectionImages = '';
z.string.ru.collectionSectionFiles = '';
z.string.ru.collectionSectionAudio = '';

z.string.ru.fullsearchPlaceholder = '  ';
z.string.ru.fullsearchNoResults = '  .';

z.string.ru.archiveHeader = '';

z.string.ru.conversationsAllArchived = '  ';
z.string.ru.conversationsContacts = '';
z.string.ru.conversationsConnectionRequestMany = '{{number}} ';
z.string.ru.conversationsConnectionRequestOne = '1  ';
z.string.ru.conversationsEmptyConversation = ' ';
z.string.ru.conversationsNoConversations = '    .';
z.string.ru.conversationsPopoverArchive = '';
z.string.ru.conversationsPopoverBlock = '';
z.string.ru.conversationsPopoverCancel = ' ';
z.string.ru.conversationsPopoverClear = ' ';
z.string.ru.conversationsPopoverLeave = ' ';
z.string.ru.conversationsPopoverNotificationSettings = '';
z.string.ru.conversationsPopoverNotify = ' ';
z.string.ru.conversationsPopoverSilence = ' ';
z.string.ru.conversationsPopoverUnarchive = '';

z.string.ru.conversationsSecondaryLineEphemeralMention = ' ';
z.string.ru.conversationsSecondaryLineEphemeralMentionGroup = '-  ';
z.string.ru.conversationsSecondaryLineEphemeralMessage = '()  ';
z.string.ru.conversationsSecondaryLineEphemeralMessageGroup = '-  ';
z.string.ru.conversationsSecondaryLineEphemeralReply = '() ';
z.string.ru.conversationsSecondaryLineEphemeralReplyGroup = ' ';
z.string.ru.conversationsSecondaryLineIncomingCall = '{{user}} ';
z.string.ru.conversationsSecondaryLinePeopleLeft = '{{number}}  ';
z.string.ru.conversationsSecondaryLinePersonLeft = '{{user}} ()';
z.string.ru.conversationsSecondaryLinePersonRemoved = '{{user}}  ()';
z.string.ru.conversationsSecondaryLinePersonRemovedTeam = '{{user}}    ';
z.string.ru.conversationsSecondaryLinePeopleAdded = '{{user}}   ';
z.string.ru.conversationsSecondaryLinePersonAdded = '{{user}} () ()';
z.string.ru.conversationsSecondaryLinePersonAddedSelf = '{{user}} ';
z.string.ru.conversationsSecondaryLinePersonAddedYou = '{{user}}  ';
z.string.ru.conversationsSecondaryLineRenamed = '{{user}}  ';
z.string.ru.conversationsSecondaryLineSummaryMessage = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryMessages = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryMention = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryMentions = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryMissedCall = '{{number}}  ';
z.string.ru.conversationsSecondaryLineSummaryMissedCalls = '{{number}}  ';
z.string.ru.conversationsSecondaryLineSummaryPing = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryPings = '{{number}} '
z.string.ru.conversationsSecondaryLineSummaryReply = '{{number}} ';
z.string.ru.conversationsSecondaryLineSummaryReplies = '{{number}} ';
z.string.ru.conversationsSecondaryLineYouLeft = ' ';
z.string.ru.conversationsSecondaryLineYouWereRemoved = '  ';

z.string.ru.takeoverSub = '     Wire.';
z.string.ru.takeoverLink = '';
z.string.ru.takeoverButtonChoose = ' ';
z.string.ru.takeoverButtonKeep = ' ';

z.string.ru.inviteMetaKeyMac = 'Cmd';
z.string.ru.inviteMetaKeyPc = 'Ctrl';
z.string.ru.inviteHintSelected = ' {{metaKey}} + C  ';
z.string.ru.inviteHintUnselected = '   {{metaKey}} + C';
z.string.ru.inviteHeadline = '   Wire';
z.string.ru.inviteMessage = '  Wire.      {{username}}     get.wire.com.';
z.string.ru.inviteMessageNoEmail = '  Wire.   get.wire.com,    .';

z.string.ru.extensionsBubbleButtonGif = 'Gif';

z.string.ru.extensionsGiphyButtonOk = '';
z.string.ru.extensionsGiphyButtonMore = '';
z.string.ru.extensionsGiphyMessage = '{{tag}}   giphy.com';
z.string.ru.extensionsGiphyNoGifs = ',  GIF-';
z.string.ru.extensionsGiphyRandom = '';

z.string.ru.addParticipantsConfirmLabel = '';
z.string.ru.addParticipantsHeader = ' ';
z.string.ru.addParticipantsHeaderWithCounter = '  ({{number}})';
z.string.ru.addParticipantsManageServices = ' ';
z.string.ru.addParticipantsManageServicesNoResults = ' ';
z.string.ru.addParticipantsNoServicesManager = ' -  ,      .';
z.string.ru.addParticipantsNoServicesMember = ' -  ,      .   ,   .';
z.string.ru.addParticipantsSearchPlaceholder = '  ';
z.string.ru.addParticipantsServiceConfirmButton = ' ';
z.string.ru.addParticipantsTabsPeople = '';
z.string.ru.addParticipantsTabsServices = '';

z.string.ru.conversationDetailsActionArchive = '';
z.string.ru.conversationDetailsActionAddParticipants = ' ';
z.string.ru.conversationDetailsActionBlock = '';
z.string.ru.conversationDetailsActionCancelRequest = ' ';
z.string.ru.conversationDetailsActionClear = ' ';
z.string.ru.conversationDetailsActionConversationParticipants = '  ({{number}})';
z.string.ru.conversationDetailsActionCreateGroup = ' ';
z.string.ru.conversationDetailsActionDevices = '';
z.string.ru.conversationDetailsActionGuestOptions = '  ';
z.string.ru.conversationDetailsActionTimedMessages = ' ';
z.string.ru.conversationDetailsActionNotifications = '';
z.string.ru.conversationDetailsActionLeave = ' ';
z.string.ru.conversationDetailsGuestsOff = '';
z.string.ru.conversationDetailsGuestsOn = '.';
z.string.ru.conversationDetailsOptions = '';
z.string.ru.conversationDetailsParticipantsServicesOne = '';
z.string.ru.conversationDetailsParticipantsServicesMany = '';
z.string.ru.conversationDetailsParticipantsUsersOne = '';
z.string.ru.conversationDetailsParticipantsUsersMany = '';
z.string.ru.conversationDetailsPeople = '';
z.string.ru.conversationDetailsServices = '';

z.string.ru.conversationParticipantsTitle = '';
z.string.ru.conversationParticipantsSearchPlaceholder = '  ';

z.string.ru.groupParticipantActionBlock = '';
z.string.ru.groupParticipantActionCancelRequest = ' ';
z.string.ru.groupParticipantActionDevices = '';
z.string.ru.groupParticipantActionIgnoreRequest = ' ';
z.string.ru.groupParticipantActionIncomingRequest = ' ';
z.string.ru.groupParticipantActionLeave = ' ';
z.string.ru.groupParticipantActionOpenConversation = ' ';
z.string.ru.groupParticipantActionPending = '';
z.string.ru.groupParticipantActionRemove = '  ';
z.string.ru.groupParticipantActionSelfProfile = ' ';
z.string.ru.groupParticipantActionSendRequest = '';
z.string.ru.groupParticipantActionUnblock = '';

z.string.ru.guestOptionsCopyLink = ' ';
z.string.ru.guestOptionsCopyLinkDone = ' !';
z.string.ru.guestOptionsCreateLink = ' ';
z.string.ru.guestOptionsInfoHeader = '   ';
z.string.ru.guestOptionsInfoText = ',    ,       24 ,      Wire.';
z.string.ru.guestOptionsRevokeLink = ' ';
z.string.ru.guestOptionsTitle = '  ';

z.string.ru.notificationSettingsTitle = '';
z.string.ru.notificationSettingsDisclaimer = '      ( -  )    -         .';
z.string.ru.notificationSettingsEverything = '';
z.string.ru.notificationSettingsMentionsAndReplies = '  ';
z.string.ru.notificationSettingsNothing = '';

z.string.ru.timedMessagesTitle = ' ';
z.string.ru.timedMessageDisclaimer = '        .';

z.string.ru.participantDevicesDetailHeadline = ',     ,    {{html1}}{{user}}{{html2}}.';
z.string.ru.participantDevicesDetailHowTo = '  ?';
z.string.ru.participantDevicesDetailResetSession = ' ';
z.string.ru.participantDevicesDetailShowMyDevice = '   ';
z.string.ru.participantDevicesDetailVerify = '';

z.string.ru.participantDevicesHeader = '';
z.string.ru.participantDevicesHeadline = 'Wire     .    {{user}}    .';
z.string.ru.participantDevicesLearnMore = '';
z.string.ru.participantDevicesWhyVerify = '  ?';
z.string.ru.participantDevicesOutdatedClientMessage = '{{user}}    Wire.   .';

z.string.ru.participantDevicesSelfAllDevices = '   ';
z.string.ru.participantDevicesSelfFingerprint = ' ';

z.string.ru.userProfileButtonConnect = '';
z.string.ru.userProfileButtonIgnore = '';
z.string.ru.userProfileButtonUnblock = '';

z.string.ru.preferencesAbout = ' ';
z.string.ru.preferencesAccount = '';
z.string.ru.preferencesAV = ' / ';
z.string.ru.preferencesDeviceDetails = '  ';
z.string.ru.preferencesDevices = '';
z.string.ru.preferencesHeadline = '';
z.string.ru.preferencesOptions = '';

z.string.ru.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.ru.preferencesAboutPrivacyPolicy = ' ';
z.string.ru.preferencesAboutSupport = '';
z.string.ru.preferencesAboutSupportWebsite = ' ';
z.string.ru.preferencesAboutSupportContact = '  ';
z.string.ru.preferencesAboutTermsOfUse = ' ';
z.string.ru.preferencesAboutVersion = ' {{version}}';
z.string.ru.preferencesAboutWebsite = '- Wire';

z.string.ru.preferencesAccountAvaibilityUnset = ' ';
z.string.ru.preferencesAccountCreateTeam = ' ';
z.string.ru.preferencesAccountData = '   ';
z.string.ru.preferencesAccountDataCheckbox = '  ';
z.string.ru.preferencesAccountDataDetail = '  Wire ,       .';
z.string.ru.preferencesAccountDelete = ' ';
z.string.ru.preferencesAccountLeaveGuestRoom = '  ';
z.string.ru.preferencesAccountLeaveGuestRoomDescription = '          .';
z.string.ru.preferencesAccountLogOut = '';
z.string.ru.preferencesAccountManageTeam = ' ';
z.string.ru.preferencesAccountMarketingConsentCheckbox = ' ';
z.string.ru.preferencesAccountMarketingConsentDetail = '      Wire   .';
z.string.ru.preferencesAccountResetPassword = ' ';
z.string.ru.preferencesAccountTeam = ' {{name}}';
z.string.ru.preferencesAccountUsernamePlaceholder = '  ';
z.string.ru.preferencesAccountUsernameHint = '  2 .  az, 09  _';
z.string.ru.preferencesAccountUsernameAvailable = '';
z.string.ru.preferencesAccountUsernameErrorTaken = ' ';

z.string.ru.preferencesAVCamera = '';
z.string.ru.preferencesAVMicrophone = '';
z.string.ru.preferencesAVPermissionDetail = '    ';
z.string.ru.preferencesAVSpeakers = '';
z.string.ru.preferencesAVTemporaryDisclaimer = '    .  ,        .';
z.string.ru.preferencesAVNoCamera = ' Wire    .[br][faqLink]  [/faqLink],  ,   .';
z.string.ru.preferencesAVTryAgain = ' ';

z.string.ru.preferencesDevicesActivatedOn = ' {{date}}';
z.string.ru.preferencesDevicesActive = '';
z.string.ru.preferencesDevicesActiveDetail = '    -  ,     .';
z.string.ru.preferencesDevicesCurrent = '';
z.string.ru.preferencesDevicesFingerprint = ' ';
z.string.ru.preferencesDevicesFingerprintDetail = 'Wire     .        .';
z.string.ru.preferencesDevicesId = 'ID: ';
z.string.ru.preferencesDevicesRemove = '';
z.string.ru.preferencesDevicesRemoveCancel = '';
z.string.ru.preferencesDevicesRemoveDetail = '  ,     .          .';
z.string.ru.preferencesDevicesSessionConfirmation = '  .';
z.string.ru.preferencesDevicesSessionDetail = '   ,          .';
z.string.ru.preferencesDevicesSessionReset = ' ';
z.string.ru.preferencesDevicesSessionOngoing = ' ';
z.string.ru.preferencesDevicesVerification = '';

z.string.ru.preferencesOptionsAudio = ' ';
z.string.ru.preferencesOptionsAudioAll = '';
z.string.ru.preferencesOptionsAudioAllDetail = ' ';
z.string.ru.preferencesOptionsAudioNone = '';
z.string.ru.preferencesOptionsAudioNoneDetail = '!';
z.string.ru.preferencesOptionsAudioSome = '';
z.string.ru.preferencesOptionsAudioSomeDetail = '  ';
z.string.ru.preferencesOptionsContacts = '';
z.string.ru.preferencesOptionsContactsGmail = '  Gmail';
z.string.ru.preferencesOptionsContactsMacos = '  ';
z.string.ru.preferencesOptionsContactsDetail = '         .          - .';
z.string.ru.preferencesOptionsPopular = '  ';
z.string.ru.preferencesOptionsEmojiReplaceCheckbox = '    ';
z.string.ru.preferencesOptionsEmojiReplaceDetail = ':-)  [icon]';
z.string.ru.preferencesOptionsPreviewsSendCheckbox = '    ';
z.string.ru.preferencesOptionsPreviewsSendDetail = '          .';
z.string.ru.preferencesOptionsNotifications = '';
z.string.ru.preferencesOptionsNotificationsNone = '';
z.string.ru.preferencesOptionsNotificationsObfuscate = ' ';
z.string.ru.preferencesOptionsNotificationsObfuscateMessage = ' ';
z.string.ru.preferencesOptionsNotificationsOn = '   ';
z.string.ru.preferencesOptionsCallLogs = ' ';
z.string.ru.preferencesOptionsCallLogsGet = '    ';
z.string.ru.preferencesOptionsCallLogsDetail = '     Wire  ,   .';

z.string.ru.preferencesOptionsBackupHeader = '';
z.string.ru.preferencesOptionsBackupExportHeadline = '  ';
z.string.ru.preferencesOptionsBackupExportSecondary = '  ,    .             .\n      ,      .';
z.string.ru.preferencesOptionsBackupImportHeadline = '   ';
z.string.ru.preferencesOptionsBackupImportSecondary = '           .       .';

z.string.ru.backupExportGenericErrorHeadline = '   ';
z.string.ru.backupExportGenericErrorSecondary = '   .';
z.string.ru.backupExportProgressHeadline = '';
z.string.ru.backupExportProgressSecondary = '   {{processed}}  {{total}}  {{progress}}%';
z.string.ru.backupExportProgressCompressing = '   ';
z.string.ru.backupExportSaveFileAction = ' ';
z.string.ru.backupExportSuccessHeadline = '  ';
z.string.ru.backupExportSuccessSecondary = '          .';
z.string.ru.backupImportGenericErrorHeadline = '-   ';
z.string.ru.backupImportGenericErrorSecondary = '     .';
z.string.ru.backupImportAccountErrorHeadline = '  ';
z.string.ru.backupImportAccountErrorSecondary = '        .';
z.string.ru.backupImportVersionErrorHeadline = '  ';
z.string.ru.backupImportVersionErrorSecondary = '           Wire     .';
z.string.ru.backupImportIncompatibleErrorHeadline = '  ';
z.string.ru.backupImportIncompatibleErrorSecondary = '        .';
z.string.ru.backupImportOutdatedErrorHeadline = '  ';
z.string.ru.backupImportOutdatedErrorSecondary = '           Wire     .';
z.string.ru.backupImportProgressHeadline = '';
z.string.ru.backupImportProgressSecondary = '   {{processed}}  {{total}}  {{progress}}%';
z.string.ru.backupImportSuccessHeadline = ' .';
z.string.ru.backupCancel = '';
z.string.ru.backupTryAgain = ' ';

z.string.ru.searchConnect = '';
z.string.ru.searchConnections = '';
z.string.ru.searchContacts = '';
z.string.ru.searchCreateGroup = ' ';
z.string.ru.searchCreateGuestRoom = '  ';
z.string.ru.searchGroups = '';
z.string.ru.searchPeople = '';
z.string.ru.searchPlaceholder = '    ';
z.string.ru.searchServicePlaceholder = '  ';
z.string.ru.searchServices = '';
z.string.ru.searchManageServices = ' ';
z.string.ru.searchManageServicesNoResults = ' ';
z.string.ru.searchNoServicesManager = ' -  ,      .';
z.string.ru.searchNoServicesMember = ' -  ,      .   ,   .';
z.string.ru.searchTeamGroups = ' ';
z.string.ru.searchTeamMembers = ' ';
z.string.ru.searchTopPeople = '-';
z.string.ru.searchTrySearch = '  \n  ';
z.string.ru.searchNoContactsOnWire = '     Wire.\n  \n   .';
z.string.ru.searchMemberInvite = '   ';
z.string.ru.searchOthers = '';

z.string.ru.searchInvite = '   Wire';
z.string.ru.searchInviteDetail = '        .          - .';
z.string.ru.searchInviteButtonContacts = ' ';
z.string.ru.searchInviteButtonGmail = ' Gmail';
z.string.ru.searchInviteHeadline = '  ';
z.string.ru.searchInviteShare = ' ';

z.string.ru.searchServiceConfirmButton = ' ';

z.string.ru.searchListEveryoneParticipates = '   \n \n  .';
z.string.ru.searchListNoMatches = '  .\n   .';

z.string.ru.temporaryGuestCta = ' ';
z.string.ru.temporaryGuestDescription = '       .';
z.string.ru.temporaryGuestTimeRemaining = '     ';

z.string.ru.temporaryGuestJoinMessage = '       24 .';
z.string.ru.temporaryGuestJoinDescription = '      ,   .';

z.string.ru.temporaryGuestLeaveMessage = '      .';
z.string.ru.temporaryGuestLeaveDescription = '      ,      .';

z.string.ru.uploadGoogleHeadline = '   \n .';
z.string.ru.uploadGoogleMessage = '         .          - .';

z.string.ru.urlSupportRoot = '/';
z.string.ru.urlSupportArticles = '/hc/ru/articles/';
z.string.ru.urlSupportRequests = '/hc/ru/requests/';
z.string.ru.urlWebappRoot = '/';
z.string.ru.urlWebsiteRoot = '/';
z.string.ru.urlWebsiteCreateTeam = '/ru/create-team/';
z.string.ru.urlWebsitePrivacy = '/ru/privacy';
z.string.ru.warningCallUnsupportedIncoming = '{{user}} .     .';
z.string.ru.warningCallUnsupportedOutgoing = '   ,       .';
z.string.ru.warningCallIssues = '  Wire     . , ';
z.string.ru.warningCallUpgradeBrowser = '    Google Chrome.';
z.string.ru.warningConnectivityConnectionLost = ' .  Wire     .';
z.string.ru.warningConnectivityNoInternet = '   .       .';
z.string.ru.warningLearnMore = '';
z.string.ru.warningLifecycleUpdate = '   Wire.';
z.string.ru.warningLifecycleUpdateNotes = ' ';
z.string.ru.warningLifecycleUpdateLink = ' ';
z.string.ru.warningNotFoundCamera = '   ,       .';
z.string.ru.warningNotFoundMicrophone = '   ,       .';
z.string.ru.warningPermissionDeniedCamera = '   ,         .';
z.string.ru.warningPermissionDeniedMicrophone = '   ,         .';
z.string.ru.warningPermissionDeniedScreen = '      .';
z.string.ru.warningPermissionRequestCamera = '[icon]    ';
z.string.ru.warningPermissionRequestMicrophone = '[icon]    ';
z.string.ru.warningPermissionRequestNotification = '[icon]  ';
z.string.ru.warningPermissionRequestScreen = '[icon]    ';

z.string.ru.userAvailabilityAvailable = '';
z.string.ru.userAvailabilityAway = '';
z.string.ru.userAvailabilityBusy = '';
z.string.ru.userAvailabilityNone = '';

z.string.ru.notificationAssetAdd = '(-) ';
z.string.ru.notificationConnectionAccepted = '()    ';
z.string.ru.notificationConnectionConnected = '   ';
z.string.ru.notificationConnectionRequest = ' ';
z.string.ru.notificationConversationCreate = '{{user}}  ';
z.string.ru.notificationConversationMessageTimerUpdate = '{{user}} ()    {{time}}';
z.string.ru.notificationConversationMessageTimerReset = '{{user}}   ';
z.string.ru.notificationConversationRename = '{{user}}    {{name}}';
z.string.ru.notificationMemberJoinMany = '{{user}} () {{number}} ()  ';
z.string.ru.notificationMemberJoinSelf = '{{user}}   ';
z.string.ru.notificationMemberJoinOne = '{{user1}} ()   {{user2}}';
z.string.ru.notificationMemberLeaveRemovedYou = '{{user}} ()   ';
z.string.ru.notificationMention = ': {{text}}';
z.string.ru.notificationObfuscated = '()  ';
z.string.ru.notificationObfuscatedMention = ' ';
z.string.ru.notificationObfuscatedReply = '() ';
z.string.ru.notificationObfuscatedTitle = '-';
z.string.ru.notificationPing = '() ';
z.string.ru.notificationReaction = '{{reaction}}  ';
z.string.ru.notificationReply = ': {{text}}';
z.string.ru.notificationSharedAudio = '(-) ';
z.string.ru.notificationSharedFile = '(-) ';
z.string.ru.notificationSharedLocation = '(-) ';
z.string.ru.notificationSharedVideo = '(-) ';
z.string.ru.notificationTitleGroup = '{{user}}  {{conversation}}';
z.string.ru.notificationVoiceChannelActivate = '';
z.string.ru.notificationVoiceChannelDeactivate = '()';

z.string.ru.tooltipConversationAllVerified = '  ';
z.string.ru.tooltipConversationCall = '';
z.string.ru.tooltipConversationEphemeral = ' ';
z.string.ru.tooltipConversationFile = ' ';
z.string.ru.tooltipConversationInputPlaceholder = ' ';
z.string.ru.tooltipConversationInputPlaceholderAvailable = '{{user}} ';
z.string.ru.tooltipConversationInputPlaceholderAway = '{{user}} ';
z.string.ru.tooltipConversationInputPlaceholderBusy = '{{user}} ';
z.string.ru.tooltipConversationPeople = ' ({{shortcut}})';
z.string.ru.tooltipConversationPicture = ' ';
z.string.ru.tooltipConversationPing = ' ({{shortcut}})';
z.string.ru.tooltipConversationSearch = '';
z.string.ru.tooltipConversationVideoCall = '';

z.string.ru.tooltipConversationsArchive = ' ({{shortcut}})';
z.string.ru.tooltipConversationsArchived = '  ({{number}})';
z.string.ru.tooltipConversationsMore = '';
z.string.ru.tooltipConversationsNotifications = '   ({{shortcut}})';
z.string.ru.tooltipConversationsNotify = '  ({{shortcut}})';
z.string.ru.tooltipConversationsPreferences = ' ';
z.string.ru.tooltipConversationsSilence = '  ({{shortcut}})';
z.string.ru.tooltipConversationsStart = '  ({{shortcut}})';

z.string.ru.tooltipConversationDetailsAddPeople = '    ({{shortcut}})';
z.string.ru.tooltipConversationDetailsRename = '  ';

z.string.ru.tooltipPreferencesContactsGmail = '    Gmail,   ';
z.string.ru.tooltipPreferencesContactsMacos = '     macOS ';
z.string.ru.tooltipPreferencesPassword = '   ';
z.string.ru.tooltipPreferencesPicture = '  ';
z.string.ru.tooltipPreferencesRename = '  ';

z.string.ru.tooltipSearchClose = ' (Esc)';

z.string.ru.initReceivedSelfUser = ', {{user}}.';
z.string.ru.initValidatedClient = '    ';
z.string.ru.initReceivedUserData = '  ';
z.string.ru.initDecryption = ' ';
z.string.ru.initEvents = ' ';
z.string.ru.initUpdatedFromNotifications = '  -  Wire';
z.string.ru.initProgress = '  {{number1}}  {{number2}}';

z.string.ru.ephemeralUnitsNone = '';
z.string.ru.ephemeralUnitsSecond = '.';
z.string.ru.ephemeralUnitsSeconds = '.';
z.string.ru.ephemeralUnitsMinute = '.';
z.string.ru.ephemeralUnitsMinutes = '.';
z.string.ru.ephemeralUnitsHour = '';
z.string.ru.ephemeralUnitsHours = '.';
z.string.ru.ephemeralUnitsDay = '';
z.string.ru.ephemeralUnitsDays = '.';
z.string.ru.ephemeralUnitsWeek = '.';
z.string.ru.ephemeralUnitsWeeks = '.';
z.string.ru.ephemeralUnitsYear = '.';
z.string.ru.ephemeralUnitsYears = '.';
z.string.ru.ephemeralRemaining = '';

z.string.ru.replyAudioMessage = '';
z.string.ru.replyQuoteError = '     .';
z.string.ru.replyQuoteShowMore = '';
z.string.ru.replyQuoteShowLess = '';
z.string.ru.replyQuoteTimeStampDate = '   {{date}}';
z.string.ru.replyQuoteTimeStampTime = '   {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.sk.wire = 'Wire';
z.string.sk.wireMacos = 'Wire pre macOS';
z.string.sk.wireWindows = 'Wire pre Windows';
z.string.sk.wireLinux = 'Wire pre Linux';
z.string.sk.nonexistentUser = 'Odstrnen pouvate';
z.string.sk.and = 'a';

z.string.sk.authAccountCountryCode = 'Kd krajiny';
z.string.sk.authAccountPasswordForgot = 'Zabudnut heslo';
z.string.sk.authAccountPublicComputer = 'Toto je verejn pota';
z.string.sk.authAccountSignIn = 'Prihlsenie';
z.string.sk.authAccountSignInPhone = 'Telefn';

z.string.sk.authBlockedCookies = 'Povote cookies na prihlsenie k Wire.';
z.string.sk.authBlockedDatabase = 'Pre zobrazenie Vaich sprv potrebuje Wire prstup k loklnemu loisku. Loklne loisko nie je dostupn v privtnom reime.';
z.string.sk.authBlockedTabs = 'Wire je u otvoren na inej karte.';

z.string.sk.authVerifyAccountAdd = 'Prida';
z.string.sk.authVerifyAccountDetail = 'To vm umon pouva Wire na viacerch zariadeniach.';
z.string.sk.authVerifyAccountHeadline = 'Prida e-mailov adresu a heslo.';
z.string.sk.authVerifyAccountLogout = 'Odhlsenie';
z.string.sk.authVerifyCodeDescription = 'Zadajte overovac kd, ktor sme zaslali na {{number}}.';
z.string.sk.authVerifyCodeResend = 'iadny kd sa neukzal?';
z.string.sk.authVerifyCodeResendDetail = 'Posla znovu';
z.string.sk.authVerifyCodeResendTimer = 'Mete poiada o nov kd {{expiration}}.';
z.string.sk.authVerifyCodeChangePhone = 'Zmeni telefnne slo';
z.string.sk.authVerifyPasswordHeadline = 'Zadajte Vae heslo';

z.string.sk.authLimitDevicesHeadline = 'Zariadenia';
z.string.sk.authLimitDescription = 'Odstrte jedno z Vaich inch zariaden aby ste mohli pouva Wire na tomto.';
z.string.sk.authLimitButtonManage = 'Sprva zariaden';
z.string.sk.authLimitButtonSignOut = 'Odhlsenie';
z.string.sk.authLimitDevicesCurrent = '(Aktulne)';

z.string.sk.authHistoryHeadline = 'Je to prvkrt o pouvate Wire na tomto zariaden.';
z.string.sk.authHistoryDescription = 'Z dvodu ochrany osobnch dajov sa tu Vae rozhovory nezobrazia.';
z.string.sk.authHistoryReuseHeadline = 'Pouili ste Wire na tomto zariaden.';
z.string.sk.authHistoryReuseDescription = 'Medziasom odoslan sprvy sa tu nezobrazia.';
z.string.sk.authHistoryButton = 'OK';

z.string.sk.authPostedResend = 'Znovu odosla na {{email}}';
z.string.sk.authPostedResendAction = 'iadny e-mail sa nezobrazil?';
z.string.sk.authPostedResendDetail = 'Skontrolujte Vau e-mailov schrnku a postupujte poda pokynov.';
z.string.sk.authPostedResendHeadline = 'Mte e-mail.';

z.string.sk.authPlaceholderEmail = 'E-mail';
z.string.sk.authPlaceholderPasswordPut = 'Heslo';
z.string.sk.authPlaceholderPasswordSet = 'Heslo (minimlne 8 znakov)';
z.string.sk.authPlaceholderPhone = 'Telefnne slo';

z.string.sk.authErrorCode = 'Neplatn kd';
z.string.sk.authErrorCountryCodeInvalid = 'Neplatn kd krajiny';
z.string.sk.authErrorEmailExists = 'E-mailov adresa sa u pouva';
z.string.sk.authErrorEmailForbidden = 'Prepte. Tto emailov adresa je zakzan.';
z.string.sk.authErrorEmailMalformed = 'Prosm, zadajte platn e-mailov adresu.';
z.string.sk.authErrorEmailMissing = 'Zdajte e-mailov adresu.';
z.string.sk.authErrorMisc = 'Problmy s pripojenm. Prosm skste to znova.';
z.string.sk.authErrorNameShort = 'Zadajte meno s minimlne 2 znakmi';
z.string.sk.authErrorOffline = 'iadne internetov pripojenie';
z.string.sk.authErrorPasswordShort = 'Heslo mus obsahova minimlne 8 znakov.';
z.string.sk.authErrorPasswordWrong = 'Zl heslo, prosm skste to znova.';
z.string.sk.authErrorPhoneNumberBudget = 'Prihlasujete sa prli asto. Skste znova neskr.';
z.string.sk.authErrorPhoneNumberForbidden = 'Prepte. Toto telefnne slo je zakzan.';
z.string.sk.authErrorPhoneNumberInvalid = 'Neplatn telefnne slo';
z.string.sk.authErrorPhoneNumberUnknown = 'Neznme telefnne slo';
z.string.sk.authErrorSuspended = 'Toto konto u nem povolen prihlsenie.';
z.string.sk.authErrorSignIn = 'Prosm, skontrolujte svoje daje a skste to znova.';

z.string.sk.callStateOutgoing = 'Zvon';
z.string.sk.callStateConnecting = 'Pripjanie';
z.string.sk.callStateIncoming = 'Volanie';
z.string.sk.callDecline = 'Odmietnu';
z.string.sk.callAccept = 'Prija';
z.string.sk.callJoin = 'Pripoji';
z.string.sk.callChooseSharedScreen = 'Vybra obrazovku pre zdieanie';
z.string.sk.callParticipants = '{{number}} je dostupn';

z.string.sk.videoCallOverlayMute = 'Stlmi';
z.string.sk.videoCallOverlayHangUp = 'Ukoni';

z.string.sk.modalAcknowledgeAction = 'OK';
z.string.sk.modalConfirmSecondary = 'Zrui';
z.string.sk.modalOptionSecondary = 'Zrui';

z.string.sk.modalAccountCreateAction = 'OK';

z.string.sk.modalAccountDeletionAction = 'Zmaza';
z.string.sk.modalAccountDeletionHeadline = 'Vymaza et';
z.string.sk.modalAccountDeletionMessage = 'Zaleme Vm e-mail, alebo SMS. Pouite odkaz pre trval zmazanie Vho tu.';

z.string.sk.modalAccountLeaveGuestRoomAction = 'Opusti';

z.string.sk.modalAccountLogoutAction = 'Odhlsenie';
z.string.sk.modalAccountLogoutHeadline = 'Vymaza daje?';
z.string.sk.modalAccountLogoutOption = 'Odstrni vetky vae osobn daje a rozhovory na tomto zariaden.';

z.string.sk.modalAccountNewDevicesSecondary = 'Sprva zariaden';
z.string.sk.modalAccountNewDevicesHeadline = 'V et bol pouit:';
z.string.sk.modalAccountNewDevicesFrom = 'Od:';
z.string.sk.modalAccountNewDevicesMessage = 'Ak ste to neboli Vy, odpojte zariadenie a zmete si heslo.';

z.string.sk.modalAccountRemoveDeviceAction = 'Odstrni zariadenie';
z.string.sk.modalAccountRemoveDeviceHeadline = 'Odstrni "{{device}}"';
z.string.sk.modalAccountRemoveDeviceMessage = 'Na odstrnenie zariadenia je potrebn Vae heslo.';
z.string.sk.modalAccountRemoveDevicePlaceholder = 'Heslo';

z.string.sk.modalAssetTooLargeMessage = 'Mete posiela sbory a do {{number}}';

z.string.sk.modalAssetParallelUploadsMessage = 'Sasne mete posla a {{number}} sborov.';

z.string.sk.modalCallEmptyConversationHeadline = 'Nie je koho zavola';
z.string.sk.modalCallEmptyConversationMessage = 'U tu nikto nezostal.';

z.string.sk.modalCallNoGroupVideoHeadline = 'iadne video hovory v skupinch';
z.string.sk.modalCallNoGroupVideoMessage = 'Videohovory nie s k dispozcii v skupinovom rozhovore.';

z.string.sk.modalCallNoMicrophoneAction = 'Povedz mi, ako';
z.string.sk.modalCallNoMicrophoneMessage = 'Pre volanie potrebuje V prehliada prstup k mikrofnu.';
z.string.sk.modalCallNoMicrophoneHeadline = 'Nemete vola bez mikrofnu';

z.string.sk.modalCallSecondIncomingAction = 'Odpoveda';
z.string.sk.modalCallSecondIncomingHeadline = 'Prija hovor?';
z.string.sk.modalCallSecondIncomingMessage = 'V aktulny hovor sa ukon.';

z.string.sk.modalCallSecondOngoingAction = 'Ukoni';
z.string.sk.modalCallSecondOngoingHeadline = 'Ukoni hovor na inom zariaden?';
z.string.sk.modalCallSecondOngoingMessage = 'Sasne mete vies len jeden hovor.';

z.string.sk.modalCallSecondOutgoingAction = 'Ukoni';
z.string.sk.modalCallSecondOutgoingHeadline = 'Ukoni aktulny hovor?';
z.string.sk.modalCallSecondOutgoingMessage = 'Sasne mete vies len jeden hovor.';

z.string.sk.modalConnectCancelAction = 'no';
z.string.sk.modalConnectCancelHeadline = 'Zrui poiadavku?';
z.string.sk.modalConnectCancelMessage = 'Odstrni poiadavku na pripojenie k {{user}}.';
z.string.sk.modalConnectCancelSecondary = 'Nie';

z.string.sk.modalConnectAcceptAction = 'Pripoji';
z.string.sk.modalConnectAcceptHeadline = 'Prija?';
z.string.sk.modalConnectAcceptMessage = 'Toto Vs spoj a otvor rozhovor s {{user}}.';
z.string.sk.modalConnectAcceptSecondary = 'Ignorova';

z.string.sk.modalConversationClearAction = 'Zmaza';
z.string.sk.modalConversationClearHeadline = 'Vymaza obsah?';
z.string.sk.modalConversationClearOption = 'Opusti tie rozhovor';

z.string.sk.modalConversationDeleteMessageAction = 'Zmaza';
z.string.sk.modalConversationDeleteMessageHeadline = 'Zmaza iba pre ma?';
z.string.sk.modalConversationDeleteMessageMessage = 'Tto akcia sa ned vrti.';

z.string.sk.modalConversationDeleteMessageEveryoneAction = 'Zmaza';
z.string.sk.modalConversationDeleteMessageEveryoneHeadline = 'Zmaza pre vetkch?';
z.string.sk.modalConversationDeleteMessageEveryoneMessage = 'Tto akcia sa ned vrti.';

z.string.sk.modalConversationLeaveAction = 'Opusti';
z.string.sk.modalConversationLeaveMessage = 'Nebudete mc odosiela ani prijma sprvy v tomto rozhovore.';

z.string.sk.modalConversationMessageTooLongHeadline = 'Sprva je prli dlh';
z.string.sk.modalConversationMessageTooLongMessage = 'Mete odosiela sprvy a do {{number}} znakov.';

z.string.sk.modalConversationNewDeviceHeadlineOne = '{{user}} zaal pouva nov zariadenie';
z.string.sk.modalConversationNewDeviceHeadlineMany = '{{user}}s zaali pouva nov zariadenie';
z.string.sk.modalConversationNewDeviceHeadlineYou = '{{user}} zaal pouva nov zariadenie';
z.string.sk.modalConversationNewDeviceIncomingCallAction = 'Prija hovor';
z.string.sk.modalConversationNewDeviceIncomingCallMessage = 'Stle chcete prija hovor?';
z.string.sk.modalConversationNewDeviceMessage = 'Stle chcete odosla Vae sprvy?';
z.string.sk.modalConversationNewDeviceOutgoingCallAction = 'Aj tak zavola';
z.string.sk.modalConversationNewDeviceOutgoingCallMessage = 'Stle chcete zavola?';

z.string.sk.modalConversationNotConnectedHeadline = 'Nikto nebol pridan do konverzcie';
z.string.sk.modalConversationNotConnectedMessageOne = '{{name}} nechce by pridan do konverzci.';
z.string.sk.modalConversationNotConnectedMessageMany = 'Jeden z ud, ktorch ste vybrali, nechce by pridan do konverzci.';

z.string.sk.modalConversationRemoveAction = 'Odstrni';
z.string.sk.modalConversationRemoveHeadline = 'Odstrni?';
z.string.sk.modalConversationRemoveMessage = '{{user}} nebude mc odosiela ani prijma sprvy v tomto rozhovore.';

z.string.sk.modalConversationRemoveGuestsAction = 'Odstrni';

z.string.sk.modalConversationTooManyMembersHeadline = 'Privea astnkov';

z.string.sk.modalIntegrationUnavailableHeadline = 'Boti s momentlne nedostupn';
z.string.sk.modalIntegrationUnavailableMessage = 'akujeme o V zujem o Botov. Sluba je momentlne pozastaven kvli prci na novej verzii.';


z.string.sk.modalImproveWireAction = 'Prija';
z.string.sk.modalImproveWireSecondary = 'Nie';

z.string.sk.modalSessionResetHeadline = 'Relcia bola obnoven';
z.string.sk.modalSessionResetMessage1 = 'Ak problm nebol vyrieen,';
z.string.sk.modalSessionResetMessageLink = 'kontakt';
z.string.sk.modalSessionResetMessage2 = 'ns.';

z.string.sk.modalUploadContactsAction = 'Sksi znova';
z.string.sk.modalUploadContactsMessage = 'Neprijali sme Vae informcie. Skste prosm znovu importova Vae kontakty.';

z.string.sk.modalUserBlockAction = 'Blokova';
z.string.sk.modalUserBlockHeadline = 'Blokova {{user}}?';
z.string.sk.modalUserBlockMessage = '{{user}} Vs nebude mc kontaktova, alebo Vs pozva do skupinovho rozhovoru.';

z.string.sk.modalUserUnblockAction = 'Odblokova';
z.string.sk.modalUserUnblockHeadline = 'Odblokova?';
z.string.sk.modalUserUnblockMessage = '{{user}} Vs bude mc kontaktova, alebo Vs pozva do skupinovho rozhovoru.';

z.string.sk.connectionRequestConnect = 'Pripoji';
z.string.sk.connectionRequestIgnore = 'Ignorova';

z.string.sk.conversationGuestIndicator = 'Hos';

z.string.sk.conversationYouNominative = 'Vy';
z.string.sk.conversationYouDative = 'Vy';
z.string.sk.conversationYouAccusative = 'Vy';

z.string.sk.conversationConnectionAccepted = 'Pripojen';
z.string.sk.conversationConnectionBlocked = 'Blokovan';
z.string.sk.conversationConnectionCancelRequest = 'Zrui poiadavku na pripojenie';
z.string.sk.conversationDeviceStartedUsingOne = ' zaal pouva';
z.string.sk.conversationDeviceStartedUsingMany = ' zaal pouva';
z.string.sk.conversationDeviceUnverified = ' neoveren jeden z';
z.string.sk.conversationDeviceYourDevices = ' Vae zariadenia';
z.string.sk.conversationDeviceUserDevices = ' {{user}}s zariadenia';
z.string.sk.conversationDeviceNewDeviceOne = ' nov zariadenie';
z.string.sk.conversationDeviceNewDeviceMany = ' nov zariadenia';
z.string.sk.conversationDeviceNewPeopleJoinedVerify = ' overi zariadenia';
z.string.sk.conversationJustNow = 'Prve teraz';
z.string.sk.conversationLocationLink = 'Otvori mapu';
z.string.sk.conversationMessageDelivered = 'Doruen';
z.string.sk.conversationRename = ' premenoval rozhovor';
z.string.sk.conversationRenameYou = ' premenoval rozhovor';
z.string.sk.conversationResume = 'Zaa rozhovor s {{users}}';
z.string.sk.conversationPing = ' pingol';
z.string.sk.conversationPingYou = ' pingol';
z.string.sk.conversationToday = 'dnes';
z.string.sk.conversationVoiceChannelDeactivate = ' volan';
z.string.sk.conversationVoiceChannelDeactivateYou = ' volan';
z.string.sk.conversationYesterday = 'Vera';
z.string.sk.conversationUnableToDecrypt1 = 'sprva od {{user}} nebola prijat.';
z.string.sk.conversationUnableToDecrypt2 = '{{user}}s zariadenie sa zmenilo. Nedoruen sprva.';
z.string.sk.conversationUnableToDecryptLink = 'Preo?';
z.string.sk.conversationUnableToDecryptErrorMessage = 'Chyba';
z.string.sk.conversationUnableToDecryptResetSession = 'Obnovenie spojenia';
z.string.sk.conversationMissedMessages = 'Na chvu ste nepouili toto zariadenie. Niektor sprvy sa nemusia zobrazi.';
z.string.sk.conversationAssetDownloading = 'Sahovanie';
z.string.sk.conversationAssetUploadFailed = 'Nahrvanie zlyhalo';
z.string.sk.conversationPlaybackError = 'Prehrvanie sa nepodarilo';
z.string.sk.conversationContextMenuCopy = 'Koprova';
z.string.sk.conversationContextMenuEdit = 'Upravi';
z.string.sk.conversationContextMenuDelete = 'Vymaza pre ma';
z.string.sk.conversationContextMenuDeleteEveryone = 'Vymaza pre vetkch';
z.string.sk.conversationContextMenuDownload = 'Stiahnu';
z.string.sk.conversationContextMenuLike = 'Pi sa';
z.string.sk.conversationContextMenuUnlike = 'Nepi sa';
z.string.sk.conversationDeleteTimestamp = 'Odstrnen {{date}}';
z.string.sk.conversationEditTimestamp = 'Upraven {{date}}';
z.string.sk.conversationLikesCaption = '{{number}} ud';
z.string.sk.conversationSendPastedFile = 'Vloen obrzok {{date}}';
z.string.sk.conversationSomeone = 'Niekto';
z.string.sk.conversationTweetAuthor = ' na Twitteri';

z.string.sk.groupCreationParticipantsPlaceholder = 'Vyhada poda mena';


z.string.sk.collectionShowAll = 'Zobrazi vetky {{number}}';
z.string.sk.collectionSectionLinks = 'Odkazy';
z.string.sk.collectionSectionImages = 'Obrzky';
z.string.sk.collectionSectionFiles = 'Sbory';
z.string.sk.collectionSectionAudio = 'Zvukov sprvy';

z.string.sk.fullsearchPlaceholder = 'Vyhada textov sprvy';
z.string.sk.fullsearchNoResults = 'iadne vsledky.';

z.string.sk.archiveHeader = 'Archv';

z.string.sk.conversationsAllArchived = 'Vetko archivovan';
z.string.sk.conversationsContacts = 'Kontakty';
z.string.sk.conversationsConnectionRequestMany = '{{number}} ud ak';
z.string.sk.conversationsConnectionRequestOne = '1 osoba ak';
z.string.sk.conversationsEmptyConversation = 'Skupinov konverzcia';
z.string.sk.conversationsNoConversations = 'Zatia iadne konverzcie';
z.string.sk.conversationsPopoverArchive = 'Archv';
z.string.sk.conversationsPopoverCancel = 'Zrui poiadavku';
z.string.sk.conversationsPopoverNotify = 'Zapn zvuk';
z.string.sk.conversationsPopoverSilence = 'Stlmi';
z.string.sk.conversationsPopoverUnarchive = 'Zrui archivciu';

z.string.sk.conversationsSecondaryLineEphemeralMessage = 'Poslal Vm sprvu';
z.string.sk.conversationsSecondaryLinePeopleLeft = '{{number}} ud zostva';
z.string.sk.conversationsSecondaryLinePersonLeft = '{{user}} zostva';
z.string.sk.conversationsSecondaryLinePersonRemoved = '{{user}} bol odstrnen';
z.string.sk.conversationsSecondaryLinePeopleAdded = '{{user}} udia boli pridan';
z.string.sk.conversationsSecondaryLinePersonAdded = '{{user}} bol pridan';
z.string.sk.conversationsSecondaryLinePersonAddedYou = '{{user}} Vs pridal';
z.string.sk.conversationsSecondaryLineRenamed = '{{user}} premenoval konverzciu';
z.string.sk.conversationsSecondaryLineYouLeft = 'Odili ste';
z.string.sk.conversationsSecondaryLineYouWereRemoved = 'Boli ste odstrnen';

z.string.sk.takeoverSub = 'Potvrte Vae jednoznan meno pre Wire.';
z.string.sk.takeoverLink = 'Zisti viac';
z.string.sk.takeoverButtonChoose = 'Vybra vlastn';
z.string.sk.takeoverButtonKeep = 'Ponecha tento';

z.string.sk.inviteMetaKeyMac = 'Cmd';
z.string.sk.inviteMetaKeyPc = 'Ctrl';
z.string.sk.inviteHeadline = 'Pozva ud do Wire';
z.string.sk.inviteMessage = 'Pouvam Wire, hadajte {{username}} alebo navtvte get.wire.com.';
z.string.sk.inviteMessageNoEmail = 'Pouvam Wire. Ak sa chcete so mnou spoji navtvte get.wire.com.';

z.string.sk.extensionsBubbleButtonGif = 'Gif';

z.string.sk.extensionsGiphyButtonOk = 'Posla';
z.string.sk.extensionsGiphyButtonMore = 'Skste in';
z.string.sk.extensionsGiphyMessage = '{{tag}}  cez giphy.com';
z.string.sk.extensionsGiphyNoGifs = 'Ej, iadne gify';
z.string.sk.extensionsGiphyRandom = 'Nhodn';

z.string.sk.addParticipantsConfirmLabel = 'Prida';
z.string.sk.addParticipantsSearchPlaceholder = 'Vyhada poda mena';
z.string.sk.addParticipantsTabsPeople = 'udia';
z.string.sk.addParticipantsTabsServices = 'Sluby';

z.string.sk.conversationDetailsActionArchive = 'Archv';
z.string.sk.conversationDetailsActionCancelRequest = 'Zrui poiadavku';
z.string.sk.conversationDetailsActionDevices = 'Zariadenia';
z.string.sk.conversationDetailsActionNotifications = 'Notifikcie';
z.string.sk.conversationDetailsGuestsOff = 'Vypn';
z.string.sk.conversationDetailsOptions = 'Monosti';
z.string.sk.conversationDetailsParticipantsServicesMany = 'Sluby';
z.string.sk.conversationDetailsParticipantsUsersMany = 'udia';
z.string.sk.conversationDetailsPeople = 'udia';
z.string.sk.conversationDetailsServices = 'Sluby';

z.string.sk.conversationParticipantsTitle = 'udia';
z.string.sk.conversationParticipantsSearchPlaceholder = 'Vyhada poda mena';

z.string.sk.groupParticipantActionCancelRequest = 'Zrui poiadavku';
z.string.sk.groupParticipantActionDevices = 'Zariadenia';
z.string.sk.groupParticipantActionPending = 'ak sa';
z.string.sk.groupParticipantActionSendRequest = 'Pripoji';

z.string.sk.notificationSettingsTitle = 'Notifikcie';

z.string.sk.participantDevicesDetailHeadline = 'Overte, e to zodpoved identifiktoru zobrazenmu na {{html1}}zariaden {{user}}{{html2}}.';
z.string.sk.participantDevicesDetailHowTo = 'Ako to urobi?';
z.string.sk.participantDevicesDetailResetSession = 'Obnovenie spojenia';
z.string.sk.participantDevicesDetailShowMyDevice = 'Zobrazi identifiktor mjho zariadenia';
z.string.sk.participantDevicesDetailVerify = 'Overen';

z.string.sk.participantDevicesHeader = 'Zariadenia';
z.string.sk.participantDevicesHeadline = 'Wire dva kadmu zariadeniu jedinen identifiktor. Porovnajte ich s {{user}} a overte Vae rozhovory.';
z.string.sk.participantDevicesLearnMore = 'Zisti viac';
z.string.sk.participantDevicesWhyVerify = 'Preo overi rozhovor?';
z.string.sk.participantDevicesOutdatedClientMessage = '{{user}} pouva stariu verziu Wire. iadne zariadenia sa tu nezobrazuj.';

z.string.sk.participantDevicesSelfAllDevices = 'Zobrazi vetky moje zariadenia';
z.string.sk.participantDevicesSelfFingerprint = 'Identifiktor zaradenia';

z.string.sk.userProfileButtonConnect = 'Pripoji';
z.string.sk.userProfileButtonIgnore = 'Ignorova';
z.string.sk.userProfileButtonUnblock = 'Odblokova';

z.string.sk.preferencesAbout = 'O aplikci';
z.string.sk.preferencesAccount = 'et';
z.string.sk.preferencesAV = 'Audio / Video';
z.string.sk.preferencesDeviceDetails = 'Podrobnosti o zariaden';
z.string.sk.preferencesDevices = 'Zariadenia';
z.string.sk.preferencesHeadline = 'Nastavenia';
z.string.sk.preferencesOptions = 'Monosti';

z.string.sk.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.sk.preferencesAboutPrivacyPolicy = 'Pravidl ochrany skromia';
z.string.sk.preferencesAboutSupport = 'Podpora';
z.string.sk.preferencesAboutSupportWebsite = 'Webov lokalita podpory';
z.string.sk.preferencesAboutSupportContact = 'Kontaktova podporu';
z.string.sk.preferencesAboutTermsOfUse = 'Podmienky pouvania';
z.string.sk.preferencesAboutVersion = 'Verzia {{version}}';
z.string.sk.preferencesAboutWebsite = 'Webov strnka Wire';

z.string.sk.preferencesAccountCreateTeam = 'Vytvori tm';
z.string.sk.preferencesAccountDelete = 'Vymaza et';
z.string.sk.preferencesAccountLogOut = 'Odhlsenie';
z.string.sk.preferencesAccountManageTeam = 'Sprva tmu';
z.string.sk.preferencesAccountResetPassword = 'Reset hesla';
z.string.sk.preferencesAccountTeam = 'v {{name}}';
z.string.sk.preferencesAccountUsernamePlaceholder = 'Vae cel meno';
z.string.sk.preferencesAccountUsernameHint = 'Aspo 2 znaky. A vhradne a-z, 0-9.';
z.string.sk.preferencesAccountUsernameAvailable = 'Dostupn';
z.string.sk.preferencesAccountUsernameErrorTaken = 'U obsaden';

z.string.sk.preferencesAVCamera = 'Kamera';
z.string.sk.preferencesAVMicrophone = 'Mikrofn';
z.string.sk.preferencesAVPermissionDetail = 'Povoli v nastaveniach prehliadaa';
z.string.sk.preferencesAVSpeakers = 'Reproduktory';

z.string.sk.preferencesDevicesActivatedOn = 'Aktivovan {{date}}';
z.string.sk.preferencesDevicesActive = 'Aktvne';
z.string.sk.preferencesDevicesActiveDetail = 'Ak nepoznte zariadenie vyie, odstrte ho a nastavte nov heslo.';
z.string.sk.preferencesDevicesCurrent = 'Aktulny';
z.string.sk.preferencesDevicesFingerprint = 'Identifiktor ka';
z.string.sk.preferencesDevicesFingerprintDetail = 'Wire dva kadmu zariadeniu jedinen identifiktor. Porovnajte ich a overte Vae zariadenia a rozhovory.';
z.string.sk.preferencesDevicesId = 'ID: ';
z.string.sk.preferencesDevicesRemoveCancel = 'Zrui';
z.string.sk.preferencesDevicesRemoveDetail = 'Odstrte toto zariadenie, ak ste ho prestali pouva. Budete z neho ihne odhlsen.';
z.string.sk.preferencesDevicesSessionConfirmation = 'Relcia bola obnoven.';
z.string.sk.preferencesDevicesSessionDetail = 'Ak sa identifiktory nezhoduj, zanite nov relciu pre vygenerovanie novch kov na oboch stranch.';
z.string.sk.preferencesDevicesSessionReset = 'Obnovenie spojenia';
z.string.sk.preferencesDevicesSessionOngoing = 'Obnovovanie relcie';
z.string.sk.preferencesDevicesVerification = 'Overen';

z.string.sk.preferencesOptionsAudio = 'Zvukov upozornenia';
z.string.sk.preferencesOptionsAudioAll = 'Vetko';
z.string.sk.preferencesOptionsAudioAllDetail = 'Vetky zvuky';
z.string.sk.preferencesOptionsAudioNone = 'iadne';
z.string.sk.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.sk.preferencesOptionsAudioSome = 'Niektor';
z.string.sk.preferencesOptionsAudioSomeDetail = 'Pingy a hovory';
z.string.sk.preferencesOptionsContacts = 'Kontakty';
z.string.sk.preferencesOptionsContactsGmail = 'Import z Gmailu';
z.string.sk.preferencesOptionsContactsMacos = 'Import z Kontaktov';
z.string.sk.preferencesOptionsContactsDetail = 'Vae daje o kontaktoch pouvame na pripojenie k inm uvateom. Vetky informcie anonymizujeme a nezdieame ich s nikm inm.';
z.string.sk.preferencesOptionsPopular = 'Populrnej poiadavky';
z.string.sk.preferencesOptionsEmojiReplaceCheckbox = 'Nahradi emotikony pomocou emojis';
z.string.sk.preferencesOptionsPreviewsSendCheckbox = 'Vytvori nhady pre odkazy ktor odosielate';
z.string.sk.preferencesOptionsPreviewsSendDetail = 'Nhady mu by stle zobrazen pre odkazy od inch ud.';
z.string.sk.preferencesOptionsNotifications = 'Notifikcie';
z.string.sk.preferencesOptionsNotificationsNone = 'Vypn';
z.string.sk.preferencesOptionsNotificationsObfuscate = 'Skry detaily';
z.string.sk.preferencesOptionsNotificationsObfuscateMessage = 'Zobrazi odosielatea';
z.string.sk.preferencesOptionsNotificationsOn = 'Zobrazi odosielatea a sprvu';

z.string.sk.backupCancel = 'Zrui';

z.string.sk.searchConnect = 'Pripoji';
z.string.sk.searchConnections = 'Pripojenia';
z.string.sk.searchContacts = 'Kontakty';
z.string.sk.searchCreateGroup = 'Vytvori skupinu';
z.string.sk.searchGroups = 'Skupiny';
z.string.sk.searchPeople = 'udia';
z.string.sk.searchPlaceholder = 'Vyhada poda mena, alebo uvateskho mena';
z.string.sk.searchServicePlaceholder = 'Vyhada poda mena';
z.string.sk.searchServices = 'Sluby';
z.string.sk.searchTeamGroups = 'Tmov konverzcie';
z.string.sk.searchTeamMembers = 'lenovia tmu';
z.string.sk.searchTopPeople = 'Top kontakty';
z.string.sk.searchTrySearch = 'Njs ud poda nzvu, alebo uvateskho mena';
z.string.sk.searchNoContactsOnWire = 'Nemte iadne kontakty Wire. Skste njs ud poda nzvu alebo uvateskho mena.';
z.string.sk.searchOthers = 'Pripoji';

z.string.sk.searchInvite = 'Pozva ud do Wire';
z.string.sk.searchInviteDetail = 'Zdieanie kontaktov Vm pome spoji sa s ostatnmi. Anonymizujeme vetky informcie a nezdieame ich s nikm inm.';
z.string.sk.searchInviteButtonContacts = 'Z kontaktov';
z.string.sk.searchInviteButtonGmail = 'Z Gmailu';
z.string.sk.searchInviteHeadline = 'Pozva priateov';
z.string.sk.searchInviteShare = 'Zdiea kontakty';

z.string.sk.searchListEveryoneParticipates = 'Vetci pripojen s u v tomto rozhovore.';
z.string.sk.searchListNoMatches = 'iadne vsledky. Skste zada in meno.';


z.string.sk.uploadGoogleHeadline = 'Njs ud\npre rozhovor.';
z.string.sk.uploadGoogleMessage = 'Vae daje o kontaktoch pouvame na pripojenie k inm uvateom. Vetky informcie anonymizujeme a nezdieame ich s nikm inm.';

z.string.sk.warningCallUnsupportedIncoming = 'Vol {{user}}. V prehliada nepodporuje hovory.';
z.string.sk.warningCallUnsupportedOutgoing = 'Nemete vola, pretoe V prehliada nepodporuje hovory.';
z.string.sk.warningCallIssues = 'Tto verzia Wire sa neme zastni volania. Prosm pouite';
z.string.sk.warningCallUpgradeBrowser = 'Pre volanie, prosm aktualizujte Google Chrome.';
z.string.sk.warningConnectivityConnectionLost = 'Prebieha pokus o pripojenie. Wire nemus by schopn dorui sprvy.';
z.string.sk.warningConnectivityNoInternet = 'Bez prstupu na internet. Nebudete mc odosiela ani prijma sprvy.';
z.string.sk.warningLearnMore = 'Zisti viac';
z.string.sk.warningLifecycleUpdate = 'Je dostupn nov verzia programu.';
z.string.sk.warningLifecycleUpdateNotes = 'o je nov';
z.string.sk.warningLifecycleUpdateLink = 'Aktualizova';
z.string.sk.warningNotFoundCamera = 'Nemete vola, pretoe V pota nem kameru.';
z.string.sk.warningNotFoundMicrophone = 'Nemete vola, pretoe V pota nem mikrofn.';
z.string.sk.warningPermissionDeniedCamera = 'Nemete vola, pretoe V prehliada nem prstup ku kamere.';
z.string.sk.warningPermissionDeniedMicrophone = 'Nemete vola, pretoe V prehliada nem prstup k mikrofnu.';
z.string.sk.warningPermissionDeniedScreen = 'V prehliada potrebuje povolenie pre zdieanie obrazovky.';
z.string.sk.warningPermissionRequestCamera = '{{icon}} Povoli prstup ku kamere';
z.string.sk.warningPermissionRequestMicrophone = '{{icon}} Povoli prstup k mikrofnu';
z.string.sk.warningPermissionRequestNotification = '{{icon}} Povoli oznmenia';
z.string.sk.warningPermissionRequestScreen = '{{icon}} Povoli prstup k obrazovke';

z.string.sk.userAvailabilityAvailable = 'Dostupn';
z.string.sk.userAvailabilityNone = 'iadne';

z.string.sk.notificationAssetAdd = 'Zdiea obrzok';
z.string.sk.notificationConnectionAccepted = 'Prijal Vau poiadavku na pripojenie';
z.string.sk.notificationConnectionConnected = 'Teraz ste pripojen';
z.string.sk.notificationConnectionRequest = 'Chce sa pripoji';
z.string.sk.notificationConversationCreate = '{{user}} zaal rozhovor';
z.string.sk.notificationConversationRename = '{{user}} premenoval rozhovor na {{name}}';
z.string.sk.notificationMemberJoinMany = '{{user}} pridal {{number}} ud do rozhovoru';
z.string.sk.notificationMemberJoinOne = '{{user1}} pridal {{user2}} do rozhovoru';
z.string.sk.notificationMemberLeaveRemovedYou = '{{user}} Vs odstrnil z konverzcie';
z.string.sk.notificationObfuscated = 'Poslal Vm sprvu';
z.string.sk.notificationObfuscatedTitle = 'Niekto';
z.string.sk.notificationPing = 'Pingnut';
z.string.sk.notificationReaction = '{{reaction}} Vau sprvu';
z.string.sk.notificationSharedAudio = 'Zdieal zvukov sprvu';
z.string.sk.notificationSharedFile = 'Zdieal sbor';
z.string.sk.notificationSharedLocation = 'Zdieal umiestnenie';
z.string.sk.notificationSharedVideo = 'Zdieal video';
z.string.sk.notificationVoiceChannelActivate = 'Vol';
z.string.sk.notificationVoiceChannelDeactivate = 'Volal';

z.string.sk.tooltipConversationAllVerified = 'Vetky identifiktory s overen';
z.string.sk.tooltipConversationCall = 'Vola';
z.string.sk.tooltipConversationEphemeral = 'asovan sprva';
z.string.sk.tooltipConversationFile = 'Prida sbor';
z.string.sk.tooltipConversationInputPlaceholder = 'Napsa sprvu';
z.string.sk.tooltipConversationPeople = 'udia ({{shortcut}})';
z.string.sk.tooltipConversationPicture = 'Prida obrzok';
z.string.sk.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.sk.tooltipConversationSearch = 'Hlada';
z.string.sk.tooltipConversationVideoCall = 'Videohovor';

z.string.sk.tooltipConversationsArchive = 'Archv ({{shortcut}})';
z.string.sk.tooltipConversationsArchived = 'Zobrazi archv ({{number}})';
z.string.sk.tooltipConversationsMore = 'Viac';
z.string.sk.tooltipConversationsNotify = 'Zrui stlmenie ({{shortcut}})';
z.string.sk.tooltipConversationsPreferences = 'Otvori predvoby';
z.string.sk.tooltipConversationsSilence = 'Stlmi ({{shortcut}})';
z.string.sk.tooltipConversationsStart = 'Zaa rozhovor ({{shortcut}})';

z.string.sk.tooltipConversationDetailsRename = 'Zmeni nzov rozhovoru';

z.string.sk.tooltipPreferencesContactsGmail = 'Pre zdieanie kontaktov sa prihlste do svojho Gmail tu';
z.string.sk.tooltipPreferencesContactsMacos = 'Zdiea vetky svoje kontakty z aplikcie kontaktov systmu macOS';
z.string.sk.tooltipPreferencesPassword = 'Pre zmenu hesla otvorte aliu webov strnku';
z.string.sk.tooltipPreferencesPicture = 'Zmeni obrzok';
z.string.sk.tooltipPreferencesRename = 'Zmeni Vae meno';

z.string.sk.tooltipSearchClose = 'Zavrie (Esc)';

z.string.sk.initReceivedSelfUser = 'Ahoj, {{user}}.';
z.string.sk.initValidatedClient = 'Zskavanie pripojen a konverzci';
z.string.sk.initReceivedUserData = 'Kontrola novch sprv';
z.string.sk.initDecryption = 'Deifrova sprvy';
z.string.sk.initEvents = 'Natavam sprvy';

z.string.sk.ephemeralUnitsNone = 'Vypn';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.sl.wire = 'Wire';
z.string.sl.wireMacos = 'Wire za macOS';
z.string.sl.wireWindows = 'Wire za Windows';
z.string.sl.wireLinux = 'Wire za Linux';
z.string.sl.nonexistentUser = 'Izbrisan uporabnik';
z.string.sl.and = 'in';

z.string.sl.authAccountCountryCode = 'Koda drave';
z.string.sl.authAccountPasswordForgot = 'Pozabljeno geslo';
z.string.sl.authAccountPublicComputer = 'To je javni raunalnik';
z.string.sl.authAccountSignIn = 'Prijava';
z.string.sl.authAccountSignInPhone = 'Telefon';

z.string.sl.authBlockedDatabase = 'Wire potrebuje dostop do lokalnega pomnilnika za prikaz sporoil. Lokalni pomnilnik ni na voljo v privatnem nainu.';
z.string.sl.authBlockedTabs = 'Wire je e odprt v drugem oknu.';

z.string.sl.authVerifyAccountAdd = 'Dodaj';
z.string.sl.authVerifyAccountDetail = 'To vam omogoa uporabo Wire na veih napravah.';
z.string.sl.authVerifyAccountHeadline = 'Dodajte e-potni naslov in geslo.';
z.string.sl.authVerifyAccountLogout = 'Odjava';
z.string.sl.authVerifyCodeDescription = 'Vnesite verifikacijsko kodo,\nki smo jo poslali na {{number}}.';
z.string.sl.authVerifyCodeResend = 'Koda ni prispela?';
z.string.sl.authVerifyCodeResendDetail = 'Ponovno polji';
z.string.sl.authVerifyCodeResendTimer = 'Lahko zahtevate novo kodo {{expiration}}.';
z.string.sl.authVerifyCodeChangePhone = 'Spremeni telefonsko tevilko';
z.string.sl.authVerifyPasswordHeadline = 'Vnesite vae geslo';

z.string.sl.authLimitDevicesHeadline = 'Naprave';
z.string.sl.authLimitDescription = 'Odstranite eno izmed vaih naprav za zaetek uporabe Wire na tej.';
z.string.sl.authLimitButtonManage = 'Upravljanje naprav';
z.string.sl.authLimitButtonSignOut = 'Odjava';
z.string.sl.authLimitDevicesCurrent = '(Trenutna)';

z.string.sl.authHistoryHeadline = 'Prvi uporabljate Wire na tej napravi.';
z.string.sl.authHistoryDescription = 'Zaradi zasebnosti se vaa zgodovina pogovorov ne bo pojavila tukaj.';
z.string.sl.authHistoryReuseHeadline = 'Na tej napravi si e uporabljal(-a) Wire.';
z.string.sl.authHistoryReuseDescription = 'Sporoila poslana medtem tukaj ne bodo prikazana.';
z.string.sl.authHistoryButton = 'V redu';

z.string.sl.authPostedResend = 'Ponovno polji na {{email}}';
z.string.sl.authPostedResendAction = 'E-pota ni prispela?';
z.string.sl.authPostedResendDetail = 'Preverite vao e-poto in sledite navodilom.';
z.string.sl.authPostedResendHeadline = 'Imate poto.';

z.string.sl.authPlaceholderEmail = 'E-pota';
z.string.sl.authPlaceholderPasswordPut = 'Geslo';
z.string.sl.authPlaceholderPasswordSet = 'Geslo (vsaj 8 znakov)';
z.string.sl.authPlaceholderPhone = 'Telefonska tevilka';

z.string.sl.authErrorCode = 'Neveljavna koda';
z.string.sl.authErrorCountryCodeInvalid = 'Neveljavna koda drave';
z.string.sl.authErrorEmailExists = 'E-potni naslov je e zaseden';
z.string.sl.authErrorEmailForbidden = 'Se opraviujemo. Ta e-potni naslov je prepovedan.';
z.string.sl.authErrorEmailMalformed = 'Prosimo, vnesite veljaven e-potni naslov.';
z.string.sl.authErrorEmailMissing = 'Prosimo, vnesite e-potni naslov.';
z.string.sl.authErrorMisc = 'Teave s povezavo. Prosimo poizkusite znova.';
z.string.sl.authErrorNameShort = 'Vnesite ime z vsaj 2 znakoma';
z.string.sl.authErrorOffline = 'Ni spletne povezave';
z.string.sl.authErrorPasswordShort = 'Izberite geslo z vsaj 8 znaki.';
z.string.sl.authErrorPasswordWrong = 'Napano geslo. Poizkusite znova.';
z.string.sl.authErrorPhoneNumberBudget = 'Da prijavljeni prepogosto. Poskusite znova pozneje.';
z.string.sl.authErrorPhoneNumberForbidden = 'Se opraviujemo. Ta telefonska tevilka je prepovedana.';
z.string.sl.authErrorPhoneNumberInvalid = 'Neveljavna telefonska tevilka';
z.string.sl.authErrorPhoneNumberUnknown = 'Neznana telefonska tevilka';
z.string.sl.authErrorSignIn = 'Prosimo preverite vae podatke in poizkusite ponovno.';

z.string.sl.callStateOutgoing = 'Zvonjenje';
z.string.sl.callStateConnecting = 'Povezovanje';
z.string.sl.callStateIncoming = 'Klicanje';
z.string.sl.callDecline = 'Zavrni';
z.string.sl.callAccept = 'Sprejmi';
z.string.sl.callJoin = 'Pridrui';
z.string.sl.callChooseSharedScreen = 'Izberite zaslon za deljenje';

z.string.sl.videoCallOverlayMute = 'Utiaj';
z.string.sl.videoCallOverlayHangUp = 'Odloi';

z.string.sl.modalAcknowledgeAction = 'V redu';
z.string.sl.modalConfirmSecondary = 'Preklii';
z.string.sl.modalOptionSecondary = 'Preklii';

z.string.sl.modalAccountCreateAction = 'V redu';

z.string.sl.modalAccountDeletionAction = 'Izbrii';
z.string.sl.modalAccountDeletionHeadline = 'Izbrii raun';
z.string.sl.modalAccountDeletionMessage = 'Poslali bomo sporoilo preko e-pote ali SMS. Sledite povezavi za trajni izbris vaega rauna.';

z.string.sl.modalAccountLeaveGuestRoomAction = 'Zapusti';

z.string.sl.modalAccountLogoutAction = 'Odjava';
z.string.sl.modalAccountLogoutHeadline = 'Poisti podatke?';
z.string.sl.modalAccountLogoutOption = 'Izbrii vse vae osebne podatke in pogovore na tej napravi.';

z.string.sl.modalAccountNewDevicesSecondary = 'Upravljanje naprav';
z.string.sl.modalAccountNewDevicesHeadline = 'Va raun je bil uporabljen na:';
z.string.sl.modalAccountNewDevicesFrom = 'Od:';
z.string.sl.modalAccountNewDevicesMessage = 'e tega niste storili, odstranite napravo in ponastavite vae geslo.';

z.string.sl.modalAccountRemoveDeviceAction = 'Odstrani napravo';
z.string.sl.modalAccountRemoveDeviceHeadline = 'Odstrani "{{device}}"';
z.string.sl.modalAccountRemoveDeviceMessage = 'Za odstranitev naprave je potrebno vae geslo.';
z.string.sl.modalAccountRemoveDevicePlaceholder = 'Geslo';

z.string.sl.modalAssetTooLargeMessage = 'Lahko poljete zbirke do {{number}}';

z.string.sl.modalAssetParallelUploadsMessage = 'Lahko poljete do {{number}} zbirk naenkrat.';

z.string.sl.modalCallEmptyConversationHeadline = 'Ni nikogar za klic';
z.string.sl.modalCallEmptyConversationMessage = 'Nikogar ni ve tukaj.';

z.string.sl.modalCallNoGroupVideoHeadline = 'Nobenih videoklicev v skupinah';
z.string.sl.modalCallNoGroupVideoMessage = 'Videoklici niso na voljo v skupinskih pogovorih.';

z.string.sl.modalCallNoMicrophoneAction = 'Povej mi kako';
z.string.sl.modalCallNoMicrophoneMessage = 'Va brskalnik potrebuje dostop do mikrofona za klicanje.';
z.string.sl.modalCallNoMicrophoneHeadline = 'Klic ni mogo brez mikrofona';

z.string.sl.modalCallSecondIncomingAction = 'Sprejmi';
z.string.sl.modalCallSecondIncomingHeadline = 'Sprejmi klic?';
z.string.sl.modalCallSecondIncomingMessage = 'Va trenuten klic se bo konal.';

z.string.sl.modalCallSecondOngoingAction = 'Odloi';
z.string.sl.modalCallSecondOngoingHeadline = 'Odloi klic na drugi napravi?';
z.string.sl.modalCallSecondOngoingMessage = 'Naenkrat ste lahko samo v enem klicu.';

z.string.sl.modalCallSecondOutgoingAction = 'Odloi';
z.string.sl.modalCallSecondOutgoingHeadline = 'Odloi trenutni klic?';
z.string.sl.modalCallSecondOutgoingMessage = 'Naenkrat ste lahko samo v enem klicu.';

z.string.sl.modalConnectCancelAction = 'Da';
z.string.sl.modalConnectCancelHeadline = 'Preklii zahtevo?';
z.string.sl.modalConnectCancelMessage = 'Odstrani zahtevo za povezavo do {{user}}.';
z.string.sl.modalConnectCancelSecondary = 'Ne';

z.string.sl.modalConnectAcceptAction = 'Povei';
z.string.sl.modalConnectAcceptHeadline = 'Sprejmi?';
z.string.sl.modalConnectAcceptMessage = 'To vas bo povezalo in odprlo pogovor s/z {{user}}.';
z.string.sl.modalConnectAcceptSecondary = 'Ignoriraj';

z.string.sl.modalConversationClearAction = 'Izbrii';
z.string.sl.modalConversationClearHeadline = 'Izbrii vsebino?';
z.string.sl.modalConversationClearOption = 'Tudi zapusti pogovor';

z.string.sl.modalConversationDeleteMessageAction = 'Izbrii';
z.string.sl.modalConversationDeleteMessageHeadline = 'Izbrii le zame?';
z.string.sl.modalConversationDeleteMessageMessage = 'To dejanje ne more biti razveljavljeno.';

z.string.sl.modalConversationDeleteMessageEveryoneAction = 'Izbrii';
z.string.sl.modalConversationDeleteMessageEveryoneHeadline = 'Izbrii za vse?';
z.string.sl.modalConversationDeleteMessageEveryoneMessage = 'To dejanje ne more biti razveljavljeno.';

z.string.sl.modalConversationLeaveAction = 'Zapusti';
z.string.sl.modalConversationLeaveMessage = 'Ne boste mogli poiljati ali prejeti sporoila v tem pogovoru.';

z.string.sl.modalConversationMessageTooLongHeadline = 'Sporoilo je predolgo';
z.string.sl.modalConversationMessageTooLongMessage = 'Lahko poljete sporoila do {{number}} znakov.';

z.string.sl.modalConversationNewDeviceHeadlineOne = '{{user}} je zael(-a) z uporabo nove naprave';
z.string.sl.modalConversationNewDeviceHeadlineMany = '{{user}}s so zaeli z uporabo novih naprav';
z.string.sl.modalConversationNewDeviceHeadlineYou = '{{user}} je zael(-a) z uporabo nove naprave';
z.string.sl.modalConversationNewDeviceIncomingCallAction = 'Sprejmi klic';
z.string.sl.modalConversationNewDeviceIncomingCallMessage = 'Ali e vedno elite sprejeti klic?';
z.string.sl.modalConversationNewDeviceMessage = 'Ali e vedno elite poslati vaa sporoila?';
z.string.sl.modalConversationNewDeviceOutgoingCallAction = 'Vseeno poklii';
z.string.sl.modalConversationNewDeviceOutgoingCallMessage = 'Ali e vedno elite klicati?';

z.string.sl.modalConversationNotConnectedMessageOne = '{{name}} ne eli biti dodan k pogovorom.';
z.string.sl.modalConversationNotConnectedMessageMany = 'Ena izmed oseb, ki ste jo izbrali, ne eli biti dodana k pogovorom.';

z.string.sl.modalConversationRemoveAction = 'Odstrani';
z.string.sl.modalConversationRemoveHeadline = 'Odstrani?';
z.string.sl.modalConversationRemoveMessage = '{{user}} ne bo mogel poiljati ali prejeti sporoila v tem pogovoru.';

z.string.sl.modalConversationRemoveGuestsAction = 'Odstrani';

z.string.sl.modalConversationTooManyMembersHeadline = 'Polna hia';



z.string.sl.modalImproveWireAction = 'Sprejmi';
z.string.sl.modalImproveWireSecondary = 'Ne';

z.string.sl.modalSessionResetHeadline = 'Seja je bila ponastavljena';
z.string.sl.modalSessionResetMessage1 = 'e teave niste odpravili,';
z.string.sl.modalSessionResetMessageLink = 'kontaktirajte';
z.string.sl.modalSessionResetMessage2 = 'nas.';

z.string.sl.modalUploadContactsAction = 'Poskusite ponovno';
z.string.sl.modalUploadContactsMessage = 'Nismo prejeli vaih podatkov. Prosimo poizkusite ponovno uvoziti stike.';

z.string.sl.modalUserBlockAction = 'Blokiraj';
z.string.sl.modalUserBlockHeadline = 'Blokiraj {{user}}?';
z.string.sl.modalUserBlockMessage = '{{user}} vas ne bo mogel kontaktirati ali dodati v skupinske pogovore.';

z.string.sl.modalUserUnblockAction = 'Odblokiraj';
z.string.sl.modalUserUnblockHeadline = 'Odblokiraj?';
z.string.sl.modalUserUnblockMessage = '{{user}} vas ne bo mogel kontaktirati ali ponovno dodati v skupinske pogovore.';

z.string.sl.connectionRequestConnect = 'Povei';
z.string.sl.connectionRequestIgnore = 'Ignoriraj';

z.string.sl.conversationYouNominative = 'ti';
z.string.sl.conversationYouDative = 'ti';
z.string.sl.conversationYouAccusative = 'ti';

z.string.sl.conversationConnectionAccepted = 'Povezan';
z.string.sl.conversationConnectionBlocked = 'Blokiran';
z.string.sl.conversationConnectionCancelRequest = 'Preklii zahtevo za povezavo';
z.string.sl.conversationDeviceStartedUsingOne = ' zael(-a) uporabljati';
z.string.sl.conversationDeviceStartedUsingMany = ' zael(-a) uporabljati';
z.string.sl.conversationDeviceUnverified = ' odstranil(-a) preveritev ene izmed';
z.string.sl.conversationDeviceYourDevices = ' vaih naprav';
z.string.sl.conversationDeviceUserDevices = ' Naprave od {{user}}';
z.string.sl.conversationDeviceNewDeviceOne = ' nova naprava';
z.string.sl.conversationDeviceNewDeviceMany = ' nove naprave';
z.string.sl.conversationDeviceNewPeopleJoinedVerify = ' preverite naprave';
z.string.sl.conversationJustNow = 'Pravkar';
z.string.sl.conversationLocationLink = 'Odpri zemljevid';
z.string.sl.conversationMessageDelivered = 'Dostavljeno';
z.string.sl.conversationRename = ' je preimenoval(-a) pogovor';
z.string.sl.conversationRenameYou = ' je preimenoval(-a) pogovor';
z.string.sl.conversationResume = 'Zani pogovor s/z {{users}}';
z.string.sl.conversationPing = ' je pingal(-a)';
z.string.sl.conversationPingYou = ' je pingal(-a)';
z.string.sl.conversationToday = 'danes';
z.string.sl.conversationVoiceChannelDeactivate = ' je klical(-a)';
z.string.sl.conversationVoiceChannelDeactivateYou = ' je klical(-a)';
z.string.sl.conversationYesterday = 'Veraj';
z.string.sl.conversationUnableToDecrypt1 = 'sporoilo od {{user}} ni bilo prejeto.';
z.string.sl.conversationUnableToDecrypt2 = 'Identita naprave od {{user}} je bila spremenjena. Sporoilo ni dostavljeno.';
z.string.sl.conversationUnableToDecryptLink = 'Zakaj?';
z.string.sl.conversationUnableToDecryptErrorMessage = 'Napaka';
z.string.sl.conversationUnableToDecryptResetSession = 'Ponastavi sejo';
z.string.sl.conversationMissedMessages = 'Te naprave nekaj asa niste uporabljali. Nekatera sporoila se morda tukaj ne bodo pojavila.';
z.string.sl.conversationAssetDownloading = 'Prenaanje';
z.string.sl.conversationAssetUploadFailed = 'Nalaganje ni uspelo';
z.string.sl.conversationPlaybackError = 'Ni mono predvajati';
z.string.sl.conversationContextMenuCopy = 'Kopiraj';
z.string.sl.conversationContextMenuEdit = 'Uredi';
z.string.sl.conversationContextMenuDelete = 'Izbrii zame';
z.string.sl.conversationContextMenuDeleteEveryone = 'Izbrii za vse';
z.string.sl.conversationContextMenuDownload = 'Prenos';
z.string.sl.conversationContextMenuLike = 'Ve mi je';
z.string.sl.conversationContextMenuUnlike = 'Ni mi ve';
z.string.sl.conversationDeleteTimestamp = 'Izbrisan ob {{date}}';
z.string.sl.conversationEditTimestamp = 'Urejen ob {{date}}';
z.string.sl.conversationLikesCaption = '{{number}} oseb';
z.string.sl.conversationSendPastedFile = 'Prilepljena slika ob {{date}}';
z.string.sl.conversationSomeone = 'Nekdo';
z.string.sl.conversationTweetAuthor = ' na Twitterju';

z.string.sl.groupCreationParticipantsPlaceholder = 'Iskanje po imenu';


z.string.sl.collectionShowAll = 'Prikai vse {{number}}';
z.string.sl.collectionSectionLinks = 'Povezave';
z.string.sl.collectionSectionImages = 'Slike';
z.string.sl.collectionSectionFiles = 'Zbirke';
z.string.sl.collectionSectionAudio = 'Zvona sporoila';

z.string.sl.fullsearchPlaceholder = 'Ii po sporoilih';
z.string.sl.fullsearchNoResults = 'Ni rezultatov.';

z.string.sl.archiveHeader = 'Arhiviraj';

z.string.sl.conversationsAllArchived = 'Vse je arhivirano';
z.string.sl.conversationsContacts = 'Stiki';
z.string.sl.conversationsConnectionRequestMany = '{{number}} ljudi, ki akajo';
z.string.sl.conversationsConnectionRequestOne = '1 oseba aka';
z.string.sl.conversationsEmptyConversation = 'Skupinski pogovor';
z.string.sl.conversationsNoConversations = 'e ni pogovorov';
z.string.sl.conversationsPopoverArchive = 'Arhiviraj';
z.string.sl.conversationsPopoverCancel = 'Preklii pronjo';
z.string.sl.conversationsPopoverNotify = 'Povrni glasnost';
z.string.sl.conversationsPopoverSilence = 'Utiaj';
z.string.sl.conversationsPopoverUnarchive = 'Dearhiviraj';

z.string.sl.conversationsSecondaryLineEphemeralMessage = 'Vam je poslal(-a) sporoilo';
z.string.sl.conversationsSecondaryLinePeopleLeft = '{{number}} oseb je zapustilo pogovor';
z.string.sl.conversationsSecondaryLinePersonLeft = '{{user}} je zapustil(-a)';
z.string.sl.conversationsSecondaryLinePersonRemoved = '{{user}} je bil(-a) odstranjen(-a)';
z.string.sl.conversationsSecondaryLinePeopleAdded = '{{user}} oseb je bilo dodanih';
z.string.sl.conversationsSecondaryLinePersonAdded = '{{user}} je bil(-a) dodan(-a)';
z.string.sl.conversationsSecondaryLinePersonAddedYou = '{{user}} te je dodal(-a)';
z.string.sl.conversationsSecondaryLineRenamed = '{{user}} preimenoval(-a) pogovor';
z.string.sl.conversationsSecondaryLineYouLeft = 'Si zapustil(-a)';
z.string.sl.conversationsSecondaryLineYouWereRemoved = 'Bil(-a) si odstranjen(-a)';

z.string.sl.takeoverSub = 'Zavzemite vae unikatno ime na Wire.';
z.string.sl.takeoverLink = 'Naui se ve';
z.string.sl.takeoverButtonChoose = 'Izberi svojo';
z.string.sl.takeoverButtonKeep = 'Obdri to';

z.string.sl.inviteMetaKeyMac = 'Cmd';
z.string.sl.inviteMetaKeyPc = 'Ctrl';
z.string.sl.inviteHeadline = 'Povabite osebe na Wire';
z.string.sl.inviteMessage = 'Sem na Wire, poii {{username}} ali obii get.wire.com.';
z.string.sl.inviteMessageNoEmail = 'Sem na Wire. Obii get.wire.com za povezavo z mano.';

z.string.sl.extensionsBubbleButtonGif = 'Gif';

z.string.sl.extensionsGiphyButtonOk = 'Polji';
z.string.sl.extensionsGiphyButtonMore = 'Poizkusi drugega';
z.string.sl.extensionsGiphyMessage = '{{tag}}  preko giphy.com';
z.string.sl.extensionsGiphyNoGifs = 'Ups, ni najdenih gifov';
z.string.sl.extensionsGiphyRandom = 'Nakljuno';

z.string.sl.addParticipantsConfirmLabel = 'Dodaj';
z.string.sl.addParticipantsSearchPlaceholder = 'Iskanje po imenu';
z.string.sl.addParticipantsTabsPeople = 'Osebe';
z.string.sl.addParticipantsTabsServices = 'Storitve';

z.string.sl.conversationDetailsActionArchive = 'Arhiviraj';
z.string.sl.conversationDetailsActionCancelRequest = 'Preklii pronjo';
z.string.sl.conversationDetailsActionDevices = 'Naprave';
z.string.sl.conversationDetailsActionNotifications = 'Obvestila';
z.string.sl.conversationDetailsGuestsOff = 'Izklopljeno';
z.string.sl.conversationDetailsOptions = 'Monosti';
z.string.sl.conversationDetailsParticipantsServicesMany = 'Storitve';
z.string.sl.conversationDetailsParticipantsUsersMany = 'Osebe';
z.string.sl.conversationDetailsPeople = 'Osebe';
z.string.sl.conversationDetailsServices = 'Storitve';

z.string.sl.conversationParticipantsTitle = 'Osebe';
z.string.sl.conversationParticipantsSearchPlaceholder = 'Iskanje po imenu';

z.string.sl.groupParticipantActionCancelRequest = 'Preklii pronjo';
z.string.sl.groupParticipantActionDevices = 'Naprave';
z.string.sl.groupParticipantActionPending = 'V teku';
z.string.sl.groupParticipantActionSendRequest = 'Povei';

z.string.sl.notificationSettingsTitle = 'Obvestila';

z.string.sl.participantDevicesDetailHeadline = 'Preveri, da se to ujema s prstnim odtisom na {{html1}}napravi od {{user}}{{html2}}.';
z.string.sl.participantDevicesDetailHowTo = 'Kako to storim?';
z.string.sl.participantDevicesDetailResetSession = 'Ponastavi sejo';
z.string.sl.participantDevicesDetailShowMyDevice = 'Prikai prstni odtis moje naprave';
z.string.sl.participantDevicesDetailVerify = 'Preverjena';

z.string.sl.participantDevicesHeader = 'Naprave';
z.string.sl.participantDevicesHeadline = 'Wire dodeli vsaki napravi edinstven prstni odtis. Primerjajte jih z {{user}} in preverite va pogovor.';
z.string.sl.participantDevicesLearnMore = 'Naui se ve';
z.string.sl.participantDevicesWhyVerify = 'Zakaj preveriti pogovore?';
z.string.sl.participantDevicesOutdatedClientMessage = '{{user}} uporablja starejo razliico Wire. Nobenih naprav tukaj ni prikazano.';

z.string.sl.participantDevicesSelfAllDevices = 'Prikai vse moje naprave';
z.string.sl.participantDevicesSelfFingerprint = 'Prstni odtis naprave';

z.string.sl.userProfileButtonConnect = 'Povei';
z.string.sl.userProfileButtonIgnore = 'Ignoriraj';
z.string.sl.userProfileButtonUnblock = 'Odblokiraj';

z.string.sl.preferencesAbout = 'O aplikaciji';
z.string.sl.preferencesAccount = 'Raun';
z.string.sl.preferencesAV = 'Avdio / Video';
z.string.sl.preferencesDeviceDetails = 'Podrobnosti naprave';
z.string.sl.preferencesDevices = 'Naprave';
z.string.sl.preferencesHeadline = 'Monosti';
z.string.sl.preferencesOptions = 'Monosti';

z.string.sl.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.sl.preferencesAboutPrivacyPolicy = 'Politika zasebnosti';
z.string.sl.preferencesAboutSupport = 'Podpora';
z.string.sl.preferencesAboutSupportWebsite = 'Spletna stran Wire podpore';
z.string.sl.preferencesAboutSupportContact = 'Kontaktiraj podporo';
z.string.sl.preferencesAboutTermsOfUse = 'Pogoji uporabe';
z.string.sl.preferencesAboutVersion = 'Razliica {{version}}';
z.string.sl.preferencesAboutWebsite = 'Wire spletna stran';

z.string.sl.preferencesAccountCreateTeam = 'Ustvari novo ekipo';
z.string.sl.preferencesAccountDelete = 'Izbrii raun';
z.string.sl.preferencesAccountLogOut = 'Odjava';
z.string.sl.preferencesAccountManageTeam = 'Uredi nalogo';
z.string.sl.preferencesAccountResetPassword = 'Resetiraj geslo';
z.string.sl.preferencesAccountTeam = 'v {{name}}';
z.string.sl.preferencesAccountUsernamePlaceholder = 'Vae polno ime';
z.string.sl.preferencesAccountUsernameHint = 'Vsaj 2 znaka. Le az, 09 in _.';
z.string.sl.preferencesAccountUsernameAvailable = 'Na voljo';
z.string.sl.preferencesAccountUsernameErrorTaken = 'e zasedeno';

z.string.sl.preferencesAVCamera = 'Kamera';
z.string.sl.preferencesAVMicrophone = 'Mikrofon';
z.string.sl.preferencesAVPermissionDetail = 'Omogoi iz nastavitev vaega brskalnika';
z.string.sl.preferencesAVSpeakers = 'Zvoniki';

z.string.sl.preferencesDevicesActivatedOn = 'Aktiviran ob {{date}}';
z.string.sl.preferencesDevicesActive = 'Aktivno';
z.string.sl.preferencesDevicesActiveDetail = 'e ne prepoznate zgornje naprave, jo odstranite in ponastavite vae geslo.';
z.string.sl.preferencesDevicesCurrent = 'Trenutna';
z.string.sl.preferencesDevicesFingerprint = 'Klju prstnega odtisa naprave';
z.string.sl.preferencesDevicesFingerprintDetail = 'Wire dodeli vsaki napravi edinstven prstni odtis. Primerjajte jih, preverite vae naprave in pogovore.';
z.string.sl.preferencesDevicesId = 'ID: ';
z.string.sl.preferencesDevicesRemoveCancel = 'Preklii';
z.string.sl.preferencesDevicesRemoveDetail = 'Odstrani to napravo, e ste jo prenehali uporabljati. Takoj boste iz nje odjavljeni.';
z.string.sl.preferencesDevicesSessionConfirmation = 'Seja je bila ponastavljena.';
z.string.sl.preferencesDevicesSessionDetail = 'e se prstni odtisi naprav ne ujemajo, ponastavite sejo za ustvaritev novih ifrirnih kljuev na obeh straneh.';
z.string.sl.preferencesDevicesSessionReset = 'Ponastavi sejo';
z.string.sl.preferencesDevicesSessionOngoing = 'Ponastavljanje seje';
z.string.sl.preferencesDevicesVerification = 'Preverjena';

z.string.sl.preferencesOptionsAudio = 'Zvona opozorila';
z.string.sl.preferencesOptionsAudioAll = 'Vsi';
z.string.sl.preferencesOptionsAudioAllDetail = 'Vsi zvoki';
z.string.sl.preferencesOptionsAudioNone = 'Ni';
z.string.sl.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.sl.preferencesOptionsAudioSome = 'Nekateri';
z.string.sl.preferencesOptionsAudioSomeDetail = 'Pingi in klici';
z.string.sl.preferencesOptionsContacts = 'Stiki';
z.string.sl.preferencesOptionsContactsGmail = 'Uvozi iz Gmail';
z.string.sl.preferencesOptionsContactsMacos = 'Uvozi iz imenika stikov';
z.string.sl.preferencesOptionsContactsDetail = 'Uporabljamo vae podatke stikov pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';
z.string.sl.preferencesOptionsPopular = 'Po priljubljenosti';
z.string.sl.preferencesOptionsEmojiReplaceCheckbox = 'Zamenjaj ustvene simbole z emojiji';
z.string.sl.preferencesOptionsPreviewsSendCheckbox = 'Ustvari predogled za povezave, ki jih poiljate';
z.string.sl.preferencesOptionsPreviewsSendDetail = 'Predogledi se e vedno lahko prikazujejo za povezave drugih ljudi.';
z.string.sl.preferencesOptionsNotifications = 'Obvestila';
z.string.sl.preferencesOptionsNotificationsNone = 'Izklopljeno';
z.string.sl.preferencesOptionsNotificationsObfuscate = 'Skrij podrobnosti';
z.string.sl.preferencesOptionsNotificationsObfuscateMessage = 'Pokai poiljatelja';
z.string.sl.preferencesOptionsNotificationsOn = 'Pokai poiljatelja in sporoilo';

z.string.sl.backupCancel = 'Preklii';

z.string.sl.searchConnect = 'Povei';
z.string.sl.searchConnections = 'Povezave';
z.string.sl.searchContacts = 'Stiki';
z.string.sl.searchCreateGroup = 'Ustvari skupino';
z.string.sl.searchGroups = 'Skupine';
z.string.sl.searchPeople = 'Osebe';
z.string.sl.searchPlaceholder = 'Iskanje po imenu ali uporabnikem imenu';
z.string.sl.searchServicePlaceholder = 'Iskanje po imenu';
z.string.sl.searchServices = 'Storitve';
z.string.sl.searchTeamGroups = 'Ekipni pogovori';
z.string.sl.searchTeamMembers = 'lani ekipe';
z.string.sl.searchTopPeople = 'Top osebe';
z.string.sl.searchTrySearch = 'Najdi osebe po imenu ali uporabnikem imenu';
z.string.sl.searchNoContactsOnWire = 'Nimate nobenih stikov na Wire.\nPoizkusite najti osebe po imenu\nali uporabnikem imenu.';
z.string.sl.searchOthers = 'Povei';

z.string.sl.searchInvite = 'Povabi ostale osebe na Wire';
z.string.sl.searchInviteDetail = 'Deljenje vaih stikov pomaga pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';
z.string.sl.searchInviteButtonContacts = 'Iz imenika stikov';
z.string.sl.searchInviteButtonGmail = 'Iz Gmail';
z.string.sl.searchInviteHeadline = 'Pripeljite vae prijatelje';
z.string.sl.searchInviteShare = 'Deli Stike';

z.string.sl.searchListEveryoneParticipates = 'Vsi \ns katerimi ste povezani,\nso e v tem pogovoru.';
z.string.sl.searchListNoMatches = 'Brez ujemanja rezultatov. \nPoizkusite vnesti drugo ime.';


z.string.sl.uploadGoogleHeadline = 'Poiite osebe\nza pogovor.';
z.string.sl.uploadGoogleMessage = 'Uporabljamo vae podatke stikov pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';

z.string.sl.warningCallUnsupportedIncoming = '{{user}} klie. Va brskalnik ne podpira klicev.';
z.string.sl.warningCallUnsupportedOutgoing = 'Ne morete klicati, ker va brskalnik ne podpira klicev.';
z.string.sl.warningCallIssues = 'Ta razliica Wire ne more sodelovati v klicu. Prosimo uporabite';
z.string.sl.warningCallUpgradeBrowser = 'e elite klicati, posodobite Google Chrome.';
z.string.sl.warningConnectivityConnectionLost = 'Poizkus povezave. Wire morda ne bo mogel dostaviti sporoila.';
z.string.sl.warningConnectivityNoInternet = 'Ni spletne povezave. Ne boste mogli poiljati ali prejemati sporoil.';
z.string.sl.warningLearnMore = 'Naui se ve';
z.string.sl.warningLifecycleUpdate = 'Na voljo je nova razliica Wire.';
z.string.sl.warningLifecycleUpdateNotes = 'Kaj je novega';
z.string.sl.warningLifecycleUpdateLink = 'Posodobi zdaj';
z.string.sl.warningNotFoundCamera = 'Ne morete klicati, ker va raunalnik nima kamere.';
z.string.sl.warningNotFoundMicrophone = 'Ne morete klicati, ker va raunalnik nima mikrofona.';
z.string.sl.warningPermissionDeniedCamera = 'Ne morete klicati, ker va brskalnik nima dostopa do kamere.';
z.string.sl.warningPermissionDeniedMicrophone = 'Klicati ni mogoe, ker va brskalnik nima dostopa do mikrofona.';
z.string.sl.warningPermissionDeniedScreen = 'Va brskalnik potrebuje dovoljenje za deljenje vaega zaslona.';
z.string.sl.warningPermissionRequestCamera = '{{icon}} Dovoli dostop do kamere';
z.string.sl.warningPermissionRequestMicrophone = '{{icon}} Dovoli dostop do mikrofona';
z.string.sl.warningPermissionRequestNotification = '{{icon}} Dovoli obvestila';
z.string.sl.warningPermissionRequestScreen = '{{icon}} Dovoli dostop do zaslona';

z.string.sl.userAvailabilityAvailable = 'Na voljo';
z.string.sl.userAvailabilityNone = 'Ni';

z.string.sl.notificationAssetAdd = 'Je delil(-a) sliko';
z.string.sl.notificationConnectionAccepted = 'Je sprejel(-a) vao zahtevo po povezavi';
z.string.sl.notificationConnectionConnected = 'Zdaj ste povezani';
z.string.sl.notificationConnectionRequest = 'Si eli povezati';
z.string.sl.notificationConversationCreate = '{{user}} je zael(-a) pogovor';
z.string.sl.notificationConversationRename = '{{user}} je preimenoval(-a) pogovor v {{name}}';
z.string.sl.notificationMemberJoinMany = '{{user}} je dodal(-a) {{number}} oseb v pogovor';
z.string.sl.notificationMemberJoinOne = '{{user1}} je dodal(-a) {{user2}} v pogovor';
z.string.sl.notificationMemberLeaveRemovedYou = '{{user}} te je odstranil(-a) iz pogovora';
z.string.sl.notificationObfuscated = 'Vam je poslal(-a) sporoilo';
z.string.sl.notificationObfuscatedTitle = 'Nekdo';
z.string.sl.notificationPing = 'Je pingal(-a)';
z.string.sl.notificationReaction = '{{reaction}} vae sporoilo';
z.string.sl.notificationSharedAudio = 'Je delil(-a) zvono sporoilo';
z.string.sl.notificationSharedFile = 'Je delil(-a) zbirko';
z.string.sl.notificationSharedLocation = 'Je delil(-a) lokacijo';
z.string.sl.notificationSharedVideo = 'Je delil(-a) video';
z.string.sl.notificationVoiceChannelActivate = 'Klicanje';
z.string.sl.notificationVoiceChannelDeactivate = 'Je klical(-a)';

z.string.sl.tooltipConversationAllVerified = 'Vsi prstni odtisi naprav so preverjeni';
z.string.sl.tooltipConversationCall = 'Klic';
z.string.sl.tooltipConversationEphemeral = 'asovno sporoilo';
z.string.sl.tooltipConversationFile = 'Dodaj zbirko';
z.string.sl.tooltipConversationInputPlaceholder = 'Napii sporoilo';
z.string.sl.tooltipConversationPeople = 'Osebe ({{shortcut}})';
z.string.sl.tooltipConversationPicture = 'Dodaj sliko';
z.string.sl.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.sl.tooltipConversationSearch = 'Iite';
z.string.sl.tooltipConversationVideoCall = 'Videoklic';

z.string.sl.tooltipConversationsArchive = 'Arhiviraj ({{shortcut}})';
z.string.sl.tooltipConversationsArchived = 'Prikai arhiv ({{number}})';
z.string.sl.tooltipConversationsMore = 'Ve';
z.string.sl.tooltipConversationsNotify = 'Povrni zvok ({{shortcut}})';
z.string.sl.tooltipConversationsPreferences = 'Odpri nastavitve';
z.string.sl.tooltipConversationsSilence = 'Utiaj ({{shortcut}})';
z.string.sl.tooltipConversationsStart = 'Zani pogovor ({{shortcut}})';

z.string.sl.tooltipConversationDetailsRename = 'Spremeni ime pogovora';

z.string.sl.tooltipPreferencesContactsGmail = 'Prijavite se v va Gmail raun za deljenje stikov';
z.string.sl.tooltipPreferencesContactsMacos = 'Deli vse vae stike iz macOS aplikacije Contacts';
z.string.sl.tooltipPreferencesPassword = 'Odpri drugo spletno stran za ponastavitev gesla';
z.string.sl.tooltipPreferencesPicture = 'Spremenite vao sliko';
z.string.sl.tooltipPreferencesRename = 'Spremenite vae ime';

z.string.sl.tooltipSearchClose = 'Zapri (Esc)';

z.string.sl.initReceivedSelfUser = 'Hej, {{user}}.';
z.string.sl.initValidatedClient = 'Pridobivam vae povezave in pogovore';
z.string.sl.initReceivedUserData = 'Preverjanje za morebitna nova sporoila';
z.string.sl.initEvents = 'Nalagam sporoila';

z.string.sl.ephemeralUnitsNone = 'Izklopljeno';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.tr.wireMacos = 'MacOS iin Wire';
z.string.tr.wireWindows = 'Windows iin Wire';
z.string.tr.wireLinux = 'Linux iin Wire';
z.string.tr.nonexistentUser = 'Silinmi Kullanc';
z.string.tr.and = 've';

z.string.tr.authAccountCountryCode = 'lke Kodu';
z.string.tr.authAccountPasswordForgot = 'ifremi unuttum';
z.string.tr.authAccountPublicComputer = 'Bu ortak bir bilgisayar';
z.string.tr.authAccountSignIn = 'Giri yap';
z.string.tr.authAccountSignInPhone = 'Telefon';

z.string.tr.authBlockedCookies = 'Wirea giri yapabilmek iin erezleri etkinletirin.';
z.string.tr.authBlockedDatabase = 'Wiren mesajlar gsterebilmek iin yerel diske erimesi lazm. Gizli modda yerel disk kullanlamaz.';
z.string.tr.authBlockedTabs = 'Wire zaten baka bir sekmede ak.';

z.string.tr.authVerifyAccountAdd = 'Ekle';
z.string.tr.authVerifyAccountDetail = 'Bu sizin Wire birden fazla cihazda kullanmanza olanak salar.';
z.string.tr.authVerifyAccountHeadline = 'Bir e-posta adresi ve ifre ekleyin.';
z.string.tr.authVerifyAccountLogout = 'k yap';
z.string.tr.authVerifyCodeDescription = '{{number}} gnderdiimiz dorulama kodunu girin.';
z.string.tr.authVerifyCodeResend = 'Kod gelmedi mi?';
z.string.tr.authVerifyCodeResendDetail = 'Tekrar gnder';
z.string.tr.authVerifyCodeResendTimer = '{{expiration}} ierisinde yeni bir kod isteyebilirsiniz.';
z.string.tr.authVerifyCodeChangePhone = 'Telefon numarasn deitir';
z.string.tr.authVerifyPasswordHeadline = 'ifrenizi girin';

z.string.tr.authLimitDevicesHeadline = 'Cihazlar';
z.string.tr.authLimitDescription = 'Bu cihazda Wire kullanabilmek iin dier cihazlarnzdan birini kaldrnz.';
z.string.tr.authLimitButtonManage = 'Cihazlar ynet';
z.string.tr.authLimitButtonSignOut = 'k yap';
z.string.tr.authLimitDevicesCurrent = '(Mevcut)';

z.string.tr.authHistoryHeadline = 'Wire bu cihazda ilk kez kullanyorsunuz.';
z.string.tr.authHistoryDescription = 'Gizlilik sebeplerinden tr, mesaj gemiiniz burada gsterilmemektedir.';
z.string.tr.authHistoryReuseHeadline = 'Bu cihazdan daha nce Wire kullanmsnz.';
z.string.tr.authHistoryReuseDescription = 'Bu srada gnderilen mesajlar burada grnmeyecektir.';
z.string.tr.authHistoryButton = 'TAMAM';

z.string.tr.authPostedResend = '{{email}}a tekrar gnder';
z.string.tr.authPostedResendAction = 'E-posta gelmedi mi?';
z.string.tr.authPostedResendDetail = 'E-posta gelen kutunuzu kontrol edin ve talimatlar izleyin.';
z.string.tr.authPostedResendHeadline = 'E-posta geldi.';

z.string.tr.authPlaceholderEmail = 'E-posta';
z.string.tr.authPlaceholderPasswordPut = 'ifre';
z.string.tr.authPlaceholderPasswordSet = 'ifre (en az 8 karakter)';
z.string.tr.authPlaceholderPhone = 'Telefon Numaras';

z.string.tr.authErrorCode = 'Geersiz Kod';
z.string.tr.authErrorCountryCodeInvalid = 'Geersiz lke Kodu';
z.string.tr.authErrorEmailExists = 'E-posta adresi zaten kullanmda';
z.string.tr.authErrorEmailForbidden = 'zgnz. Bu e-posta adresi yasakl.';
z.string.tr.authErrorEmailMalformed = 'Ltfen geerli bir e-posta adresi girin.';
z.string.tr.authErrorEmailMissing = 'Ltfen bir e-posta adresi girin.';
z.string.tr.authErrorMisc = 'Balant sorunlar mevcut. Ltfen tekrar deneyin.';
z.string.tr.authErrorNameShort = 'En az 2 karakterlik bir isim girin';
z.string.tr.authErrorOffline = 'nternet balants yok';
z.string.tr.authErrorPasswordShort = 'En az 8 karakterlik bir ifre sein.';
z.string.tr.authErrorPasswordWrong = 'Yanl ifre. Ltfen tekrar deneyin.';
z.string.tr.authErrorPending = 'Hesap dorulanamad';
z.string.tr.authErrorPhoneNumberBudget = 'ok sk giri yaptnz. Tekrardan deneyin.';
z.string.tr.authErrorPhoneNumberForbidden = 'zgnz. Bu telefon numaras yasakl.';
z.string.tr.authErrorPhoneNumberInvalid = 'Geersiz Telefon Numaras';
z.string.tr.authErrorPhoneNumberUnknown = 'Bilinmeyen Telefon Numaras';
z.string.tr.authErrorSuspended = 'Bu hesap artk giri yapmak iin yeterli yetkiye sahip deil.';
z.string.tr.authErrorSignIn = 'Ltfen bilgilerinizi dorulayp yle tekrar deneyiniz.';

z.string.tr.callStateOutgoing = 'alyor';
z.string.tr.callStateConnecting = 'Balanyor';
z.string.tr.callStateIncoming = 'Aryor';
z.string.tr.callDecline = 'Reddet';
z.string.tr.callAccept = 'Kabul et';
z.string.tr.callJoin = 'Katl';
z.string.tr.callChooseSharedScreen = 'Paylamak iin bir ekran sein';
z.string.tr.callParticipants = '{{number}} arda';

z.string.tr.videoCallOverlayMute = 'Sustur';
z.string.tr.videoCallOverlayHangUp = 'Kapat';

z.string.tr.modalAcknowledgeAction = 'Tamam';
z.string.tr.modalConfirmSecondary = 'ptal';
z.string.tr.modalOptionSecondary = 'ptal';

z.string.tr.modalAccountCreateAction = 'TAMAM';

z.string.tr.modalAccountDeletionAction = 'Sil';
z.string.tr.modalAccountDeletionHeadline = 'Hesab Sil';
z.string.tr.modalAccountDeletionMessage = 'Size ksa mesaj veya e-posta araclyla bir mesaj gndereceiz. Mesajdaki balanty takip ederek hesabnz kalc olarak silebilirsiniz.';

z.string.tr.modalAccountLeaveGuestRoomAction = 'Ayrl';

z.string.tr.modalAccountLogoutAction = 'k yap';
z.string.tr.modalAccountLogoutHeadline = 'Veriyi Temizle?';
z.string.tr.modalAccountLogoutOption = 'Bu cihazdaki tm kiisel bilgileriniz ve grme kaytlarnz silin.';

z.string.tr.modalAccountNewDevicesSecondary = 'Cihazlar ynet';
z.string.tr.modalAccountNewDevicesHeadline = 'Hesabnz urada kullanlm:';
z.string.tr.modalAccountNewDevicesFrom = 'Cihaz:';
z.string.tr.modalAccountNewDevicesMessage = 'Eer bunu yapan siz deilseniz, cihaz kaldrn ben ifrenizi sfrlayn.';

z.string.tr.modalAccountRemoveDeviceAction = 'Cihaz kaldr';
z.string.tr.modalAccountRemoveDeviceHeadline = '"{{device}}" cihazn kaldr';
z.string.tr.modalAccountRemoveDeviceMessage = 'Cihaz kaldrmak iin ifreniz gereklidir.';
z.string.tr.modalAccountRemoveDevicePlaceholder = 'ifre';

z.string.tr.modalAssetTooLargeMessage = 'En fazla {{number}} byklnde dosyalar gnderebilirsiniz';

z.string.tr.modalAssetParallelUploadsMessage = 'Tek seferde en fazla {{number}} boyutunda dosya gnderebilirsiniz.';

z.string.tr.modalCallEmptyConversationHeadline = 'Arayacak kimse yok';
z.string.tr.modalCallEmptyConversationMessage = 'Burada kimse kalmad.';

z.string.tr.modalCallNoGroupVideoHeadline = 'Gruplarda grntl konuma yok';
z.string.tr.modalCallNoGroupVideoMessage = 'Grntl konuma, grup konumalarnda yaplamyor.';

z.string.tr.modalCallNoMicrophoneAction = 'Anlat bana';
z.string.tr.modalCallNoMicrophoneMessage = 'Sesli aramalar yapmak iin taraycnzn mikrofona eriim izni almas gerekir.';
z.string.tr.modalCallNoMicrophoneHeadline = 'Mikrofon olmadan arama yaplamaz';

z.string.tr.modalCallSecondIncomingAction = 'Cevapla';
z.string.tr.modalCallSecondIncomingHeadline = 'Aramay cevapla?';
z.string.tr.modalCallSecondIncomingMessage = 'Mevcut aramanz sonlanacak.';

z.string.tr.modalCallSecondOngoingAction = 'Kapat';
z.string.tr.modalCallSecondOngoingHeadline = 'Aramay baka bir cihazda kapa?';
z.string.tr.modalCallSecondOngoingMessage = 'Ayn anda tek bir aramada bulunabilirsiniz.';

z.string.tr.modalCallSecondOutgoingAction = 'Kapat';
z.string.tr.modalCallSecondOutgoingHeadline = 'Mevcut konumay sonlandr?';
z.string.tr.modalCallSecondOutgoingMessage = 'Ayn anda tek bir aramada bulunabilirsiniz.';

z.string.tr.modalConnectCancelAction = 'Evet';
z.string.tr.modalConnectCancelHeadline = 'stei ptal et?';
z.string.tr.modalConnectCancelMessage = '{{user}}e olan balant isteini iptal et.';
z.string.tr.modalConnectCancelSecondary = 'Hayr';

z.string.tr.modalConnectAcceptAction = 'Balan';
z.string.tr.modalConnectAcceptHeadline = 'Kabul et?';
z.string.tr.modalConnectAcceptMessage = 'Bu sizi {{user}} ile balayacak ve bir konuma balatacak.';
z.string.tr.modalConnectAcceptSecondary = 'Grmezden gel';

z.string.tr.modalConversationClearAction = 'Sil';
z.string.tr.modalConversationClearHeadline = 'erik silinsin?';
z.string.tr.modalConversationClearOption = 'Ayrca konumadan da ayrl';

z.string.tr.modalConversationDeleteMessageAction = 'Sil';
z.string.tr.modalConversationDeleteMessageHeadline = 'Sadece benim iin sil?';
z.string.tr.modalConversationDeleteMessageMessage = 'Bu ilem geri alnamaz.';

z.string.tr.modalConversationDeleteMessageEveryoneAction = 'Sil';
z.string.tr.modalConversationDeleteMessageEveryoneHeadline = 'Herkes iin sil?';
z.string.tr.modalConversationDeleteMessageEveryoneMessage = 'Bu ilem geri alnamaz.';

z.string.tr.modalConversationLeaveAction = 'Ayrl';
z.string.tr.modalConversationLeaveMessage = 'Bu konumada, artk mesaj gnderemeyecek ve mesaj alamayacaksnz.';

z.string.tr.modalConversationMessageTooLongHeadline = 'Mesaj ok uzun';
z.string.tr.modalConversationMessageTooLongMessage = 'En fazla {{number}} karakterlik mesajlar gnderebilirsiniz.';

z.string.tr.modalConversationNewDeviceHeadlineOne = '{{user}} yeni bir cihaz kullanmaya balad';
z.string.tr.modalConversationNewDeviceHeadlineMany = '{{user}}s yeni cihazlar kullanmaya baladlar';
z.string.tr.modalConversationNewDeviceHeadlineYou = '{{user}} yeni bir cihaz kullanmaya balad';
z.string.tr.modalConversationNewDeviceIncomingCallAction = 'Aramay kabul et';
z.string.tr.modalConversationNewDeviceIncomingCallMessage = 'Hala aramay kabul etmek istiyor musunuz?';
z.string.tr.modalConversationNewDeviceMessage = 'Hl mesajlarnz gndermek istiyor musunuz?';
z.string.tr.modalConversationNewDeviceOutgoingCallAction = 'Yine de ara';
z.string.tr.modalConversationNewDeviceOutgoingCallMessage = 'Hala aramay istiyor musunuz?';

z.string.tr.modalConversationNotConnectedHeadline = 'Hi kimseye konumaya katlmad';
z.string.tr.modalConversationNotConnectedMessageOne = '{{name}} sohbetlere eklenmek istemiyor.';
z.string.tr.modalConversationNotConnectedMessageMany = 'Setiin kiilerden biri sohbetlere eklenmek istemiyor.';

z.string.tr.modalConversationRemoveAction = 'kart';
z.string.tr.modalConversationRemoveHeadline = 'kar?';
z.string.tr.modalConversationRemoveMessage = '{{user}} bu konumaya mesaj gnderemeyecek ve bu konumadan mesaj alamayacak.';

z.string.tr.modalConversationRemoveGuestsAction = 'kart';

z.string.tr.modalConversationTooManyMembersHeadline = 'Dolup tam';

z.string.tr.modalIntegrationUnavailableHeadline = 'Botlar uanda kullanlabilir deil';
z.string.tr.modalIntegrationUnavailableMessage = 'Botlara ilginiz iin teekkr ederiz. Bir bir sonraki srm zerinde alrken hizmet askya alnm. Beklemede kaln.';


z.string.tr.modalImproveWireAction = 'Kabul et';
z.string.tr.modalImproveWireSecondary = 'Hayr';

z.string.tr.modalSessionResetHeadline = 'Oturum sfrland';
z.string.tr.modalSessionResetMessage1 = 'Eer sorun zlmemise,';
z.string.tr.modalSessionResetMessageLink = 'iletiime ge';
z.string.tr.modalSessionResetMessage2 = 'biz.';

z.string.tr.modalUploadContactsAction = 'Tekrar deneyin';
z.string.tr.modalUploadContactsMessage = 'Bilgilerinzi alamadk. Ltfen kiileriniz yeniden ie aktarmay deneyin.';

z.string.tr.modalUserBlockAction = 'Engelle';
z.string.tr.modalUserBlockHeadline = '{{user}} engellensin mi?';
z.string.tr.modalUserBlockMessage = '{{user}} sizinle iletiim kuramayacak ve sizi grup konumalarna ekleyemeyecek.';

z.string.tr.modalUserUnblockAction = 'Engeli kaldr';
z.string.tr.modalUserUnblockHeadline = 'Engeli kaldr?';
z.string.tr.modalUserUnblockMessage = '{{user}} sizinle tekrardan iletiim kurabilecek ve sizi grup konumalarna ekleyebilecek.';

z.string.tr.connectionRequestConnect = 'Balan';
z.string.tr.connectionRequestIgnore = 'Grmezden gel';

z.string.tr.conversationGuestIndicator = 'Misafir';

z.string.tr.conversationYouNominative = 'sen';
z.string.tr.conversationYouDative = 'sen';
z.string.tr.conversationYouAccusative = 'sen';

z.string.tr.conversationConnectionAccepted = 'Balanld';
z.string.tr.conversationConnectionBlocked = 'Engellendi';
z.string.tr.conversationConnectionCancelRequest = 'Balant isteini iptal et';
z.string.tr.conversationDeviceStartedUsingOne = ' kullanmaya balad';
z.string.tr.conversationDeviceStartedUsingMany = ' kullanmaya balad';
z.string.tr.conversationDeviceUnverified = ' dorulanmamlardan bir tane';
z.string.tr.conversationDeviceYourDevices = ' cihazlarn';
z.string.tr.conversationDeviceUserDevices = ' {{user}} in cihazlar';
z.string.tr.conversationDeviceNewDeviceOne = ' yeni bir cihaz';
z.string.tr.conversationDeviceNewDeviceMany = ' yeni cihazlar';
z.string.tr.conversationDeviceNewPeopleJoinedVerify = ' cihazlar dorula';
z.string.tr.conversationJustNow = 'imdi';
z.string.tr.conversationLocationLink = 'Haritay A';
z.string.tr.conversationMessageDelivered = 'Teslim edildi';
z.string.tr.conversationRename = ' konumay yeniden adlandrd';
z.string.tr.conversationRenameYou = ' konumay yeniden adlandrd';
z.string.tr.conversationResume = '{{users}} ile bir grme balat';
z.string.tr.conversationPing = ' pingledi';
z.string.tr.conversationPingYou = ' pingledi';
z.string.tr.conversationToday = 'bugn';
z.string.tr.conversationVoiceChannelDeactivate = ' arad';
z.string.tr.conversationVoiceChannelDeactivateYou = ' arad';
z.string.tr.conversationYesterday = 'Dn';
z.string.tr.conversationUnableToDecrypt1 = '{{user}}den gelen bir mesaj alnamad.';
z.string.tr.conversationUnableToDecrypt2 = '{{user}}nin cihaz kimlii deiti. Teslim edilmemi mesaj.';
z.string.tr.conversationUnableToDecryptLink = 'Neden?';
z.string.tr.conversationUnableToDecryptErrorMessage = 'Hata';
z.string.tr.conversationUnableToDecryptResetSession = 'Oturumu Sfrla';
z.string.tr.conversationMissedMessages = 'Bir sredir bu cihaz kullanmyorsun. Baz mesajlar gsterilmeyebilir.';
z.string.tr.conversationAssetDownloading = 'ndiriliyor';
z.string.tr.conversationAssetUploadFailed = 'Karya Ykleme Baarsz';
z.string.tr.conversationPlaybackError = 'Oynatlamyor';
z.string.tr.conversationContextMenuCopy = 'Kopyala';
z.string.tr.conversationContextMenuEdit = 'Dzenle';
z.string.tr.conversationContextMenuDelete = 'Benim iin sil';
z.string.tr.conversationContextMenuDeleteEveryone = 'Herkes iin sil';
z.string.tr.conversationContextMenuDownload = 'ndir';
z.string.tr.conversationContextMenuLike = 'Been';
z.string.tr.conversationContextMenuUnlike = 'Beenme';
z.string.tr.conversationDeleteTimestamp = '{{date}} da silinmi';
z.string.tr.conversationEditTimestamp = '{{date}} da dzenlenmi';
z.string.tr.conversationLikesCaption = '{{number}} kii';
z.string.tr.conversationSendPastedFile = 'Yaptrlm resim, {{date}} de';
z.string.tr.conversationSomeone = 'Birisi';
z.string.tr.conversationTweetAuthor = ' Twitterda';

z.string.tr.groupCreationPreferencesAction = 'leri';
z.string.tr.groupCreationParticipantsActionCreate = 'Yapld';
z.string.tr.groupCreationParticipantsPlaceholder = 'sme gre ara';


z.string.tr.collectionShowAll = '{{number}}nun tmn gster';
z.string.tr.collectionSectionLinks = 'Balantlar';
z.string.tr.collectionSectionImages = 'Resimler';
z.string.tr.collectionSectionFiles = 'Dosyalar';
z.string.tr.collectionSectionAudio = 'Sesli mesajlar';

z.string.tr.fullsearchPlaceholder = 'Metin mesajlarnda ara';
z.string.tr.fullsearchNoResults = 'Sonu yok.';

z.string.tr.archiveHeader = 'Arivle';

z.string.tr.conversationsAllArchived = 'Her ey arivlendi';
z.string.tr.conversationsContacts = 'Kiiler';
z.string.tr.conversationsConnectionRequestMany = '{{number}} kii bekliyor';
z.string.tr.conversationsConnectionRequestOne = 'Bir kii bekliyor';
z.string.tr.conversationsEmptyConversation = 'Grup sohbeti';
z.string.tr.conversationsNoConversations = 'Hi konuma yok';
z.string.tr.conversationsPopoverArchive = 'Arivle';
z.string.tr.conversationsPopoverCancel = 'stei iptal et';
z.string.tr.conversationsPopoverNotify = 'Susturmay A';
z.string.tr.conversationsPopoverSilence = 'Sustur';
z.string.tr.conversationsPopoverUnarchive = 'Arivden kar';

z.string.tr.conversationsSecondaryLineEphemeralMessage = 'Size bir mesaj gnderdi';
z.string.tr.conversationsSecondaryLinePeopleLeft = '{{number}} kii ayrld';
z.string.tr.conversationsSecondaryLinePersonLeft = '{{user}} ayrld';
z.string.tr.conversationsSecondaryLinePersonRemoved = '{{user}} kartld';
z.string.tr.conversationsSecondaryLinePeopleAdded = '{{user}} kii eklendi';
z.string.tr.conversationsSecondaryLinePersonAdded = '{{user}} eklendi';
z.string.tr.conversationsSecondaryLinePersonAddedYou = '{{user}} seni ekledi';
z.string.tr.conversationsSecondaryLineRenamed = '{{user}} konumay yeniden adlandrd';
z.string.tr.conversationsSecondaryLineYouLeft = 'Ayrldn';
z.string.tr.conversationsSecondaryLineYouWereRemoved = 'kartldnz';

z.string.tr.takeoverSub = 'Wire zerinden size zel isminizi hemen aln.';
z.string.tr.takeoverLink = 'Daha fazla bilgi';
z.string.tr.takeoverButtonChoose = 'Kendininkini se';
z.string.tr.takeoverButtonKeep = 'Bunu sakla';

z.string.tr.inviteMetaKeyMac = 'Cmd';
z.string.tr.inviteMetaKeyPc = 'Ctrl';
z.string.tr.inviteHeadline = 'nsanlarn Wirea davet et';
z.string.tr.inviteMessage = 'Wiredaym, {{username}} olarak arat ya da get.wire.com adresini ziyaret et.';
z.string.tr.inviteMessageNoEmail = 'Wiredaym. get.wire.com u ziyaret ederek bana balanabilirsin.';

z.string.tr.extensionsBubbleButtonGif = 'Gif';

z.string.tr.extensionsGiphyButtonOk = 'Gnder';
z.string.tr.extensionsGiphyButtonMore = 'Bakasn Dene';
z.string.tr.extensionsGiphyMessage = '{{tag}}  giphy.com araclyla';
z.string.tr.extensionsGiphyNoGifs = 'Olamaz, hi Gif yok';
z.string.tr.extensionsGiphyRandom = 'Rastgele';

z.string.tr.addParticipantsConfirmLabel = 'Ekle';
z.string.tr.addParticipantsSearchPlaceholder = 'sme gre ara';
z.string.tr.addParticipantsTabsPeople = 'nsanlar';
z.string.tr.addParticipantsTabsServices = 'Servisler';

z.string.tr.conversationDetailsActionArchive = 'Arivle';
z.string.tr.conversationDetailsActionCancelRequest = 'stei iptal et';
z.string.tr.conversationDetailsActionDevices = 'Cihazlar';
z.string.tr.conversationDetailsActionNotifications = 'Bildirimler';
z.string.tr.conversationDetailsGuestsOff = 'Yok';
z.string.tr.conversationDetailsOptions = 'Ayarlar';
z.string.tr.conversationDetailsParticipantsServicesMany = 'Servisler';
z.string.tr.conversationDetailsParticipantsUsersMany = 'nsanlar';
z.string.tr.conversationDetailsPeople = 'nsanlar';
z.string.tr.conversationDetailsServices = 'Servisler';

z.string.tr.conversationParticipantsTitle = 'nsanlar';
z.string.tr.conversationParticipantsSearchPlaceholder = 'sme gre ara';

z.string.tr.groupParticipantActionCancelRequest = 'stei iptal et';
z.string.tr.groupParticipantActionDevices = 'Cihazlar';
z.string.tr.groupParticipantActionPending = 'Beklemede';
z.string.tr.groupParticipantActionSendRequest = 'Balan';

z.string.tr.notificationSettingsTitle = 'Bildirimler';

z.string.tr.participantDevicesDetailHeadline = 'Bunun {{html1}}{{user}}sin aygtnda gsterilen{{html2}} parmak iziyle eletiini dorulayn.';
z.string.tr.participantDevicesDetailHowTo = 'Bunu nasl yapyoruz?';
z.string.tr.participantDevicesDetailResetSession = 'Oturumu Sfrla';
z.string.tr.participantDevicesDetailShowMyDevice = 'Cihaz parmak izimi gster';
z.string.tr.participantDevicesDetailVerify = 'Dorulanm';

z.string.tr.participantDevicesHeader = 'Cihazlar';
z.string.tr.participantDevicesHeadline = 'Wire her cihaza esiz bir parmak izi verir. {{user}} ile karlatrn ve konumay dorulayn.';
z.string.tr.participantDevicesLearnMore = 'Daha fazla bilgi';
z.string.tr.participantDevicesWhyVerify = 'Neden konumalar dorulamalyz?';
z.string.tr.participantDevicesOutdatedClientMessage = '{{user}}, Wiren eski bir versiyonunu kullanyor. Hibir cihaz burada gsterilmiyor.';

z.string.tr.participantDevicesSelfAllDevices = 'Tm cihazlarm gster';
z.string.tr.participantDevicesSelfFingerprint = 'Cihaz parmak izi';

z.string.tr.userProfileButtonConnect = 'Balan';
z.string.tr.userProfileButtonIgnore = 'Grmezden gel';
z.string.tr.userProfileButtonUnblock = 'Engeli kaldr';

z.string.tr.preferencesAbout = 'Hakknda';
z.string.tr.preferencesAccount = 'Hesap';
z.string.tr.preferencesAV = 'Ses / Grnt';
z.string.tr.preferencesDeviceDetails = 'Cihaz Detaylar';
z.string.tr.preferencesDevices = 'Cihazlar';
z.string.tr.preferencesHeadline = 'Seenekler';
z.string.tr.preferencesOptions = 'Ayarlar';

z.string.tr.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.tr.preferencesAboutPrivacyPolicy = 'Gizlilik Politikas';
z.string.tr.preferencesAboutSupport = 'Destek';
z.string.tr.preferencesAboutSupportWebsite = 'Destek nternet Sitesi';
z.string.tr.preferencesAboutSupportContact = 'Destekle letiime Ge';
z.string.tr.preferencesAboutTermsOfUse = 'Kullanm artlar';
z.string.tr.preferencesAboutVersion = 'Srm: {{version}}';
z.string.tr.preferencesAboutWebsite = 'Wire nternet Sitesi';

z.string.tr.preferencesAccountAvaibilityUnset = 'Bir durum ayarlayn';
z.string.tr.preferencesAccountCreateTeam = 'Bir takm olutur';
z.string.tr.preferencesAccountDelete = 'Hesab Sil';
z.string.tr.preferencesAccountLogOut = 'k yap';
z.string.tr.preferencesAccountManageTeam = 'Takm ynet';
z.string.tr.preferencesAccountResetPassword = 'ifreni sfrla';
z.string.tr.preferencesAccountTeam = '{{name}}de';
z.string.tr.preferencesAccountUsernamePlaceholder = 'Tam adnz';
z.string.tr.preferencesAccountUsernameHint = 'En az 2 karakter. az, 09, ve yalnzca _.';
z.string.tr.preferencesAccountUsernameAvailable = 'Alnabilir';
z.string.tr.preferencesAccountUsernameErrorTaken = 'oktan alnm';

z.string.tr.preferencesAVCamera = 'Kamera';
z.string.tr.preferencesAVMicrophone = 'Mikrofon';
z.string.tr.preferencesAVPermissionDetail = 'Tarayc Seeneklerinizden aktifletirin';
z.string.tr.preferencesAVSpeakers = 'Hoparlrler';

z.string.tr.preferencesDevicesActivatedOn = '{{date}} da aktif edildi';
z.string.tr.preferencesDevicesActive = 'Aktif';
z.string.tr.preferencesDevicesActiveDetail = 'Eer yukardaki cihaz tanmyorsanz, cihaz kaldrn ve ifrenizi sfrlayn.';
z.string.tr.preferencesDevicesCurrent = 'Mevcut';
z.string.tr.preferencesDevicesFingerprint = 'Anahtar Parmak zi';
z.string.tr.preferencesDevicesFingerprintDetail = 'Wire her cihaza kendine has bir parmak izi verir. Cihazlarnz ve konumalarnz dorulamak iin parmak izlerinizi karlatrn.';
z.string.tr.preferencesDevicesId = 'ID: ';
z.string.tr.preferencesDevicesRemoveCancel = 'ptal';
z.string.tr.preferencesDevicesRemoveDetail = 'Eer bu cihaz kullanmay braktysanz, cihaz kaldrn. Ardndan cihazdan otomatik olarak k yaplacaktr.';
z.string.tr.preferencesDevicesSessionConfirmation = 'Oturum sfrland.';
z.string.tr.preferencesDevicesSessionDetail = 'Parmak izleri elemezse, her iki tarafta da yeni ifreleme anahtarlar oluturmak iin oturumu sfrlayn.';
z.string.tr.preferencesDevicesSessionReset = 'Oturumu Sfrla';
z.string.tr.preferencesDevicesSessionOngoing = 'Oturum sfrlanyor';
z.string.tr.preferencesDevicesVerification = 'Dorulanm';

z.string.tr.preferencesOptionsAudio = 'Sesli uyarlar';
z.string.tr.preferencesOptionsAudioAll = 'Hepsi';
z.string.tr.preferencesOptionsAudioAllDetail = 'Tm Sesler';
z.string.tr.preferencesOptionsAudioNone = 'Hibiri';
z.string.tr.preferencesOptionsAudioNoneDetail = '!';
z.string.tr.preferencesOptionsAudioSome = 'Bazlar';
z.string.tr.preferencesOptionsAudioSomeDetail = 'Pingler ve aramalar';
z.string.tr.preferencesOptionsContacts = 'Kiiler';
z.string.tr.preferencesOptionsContactsGmail = 'Gmailden ie aktar';
z.string.tr.preferencesOptionsContactsMacos = 'Kiilerden ie aktar';
z.string.tr.preferencesOptionsContactsDetail = 'letiim verilerinizi sizi bakalaryla balayabilmek iin kullanyoruz. Tm bilgilerinizi gizler ve kimseyle paylamayz.';
z.string.tr.preferencesOptionsPopular = 'Youn istek zerine';
z.string.tr.preferencesOptionsEmojiReplaceCheckbox = 'Yaz halindeki emojileri, gerek emojiler ile deitir';
z.string.tr.preferencesOptionsPreviewsSendCheckbox = 'Gnderdiin balantlar iin n izlemeler olutur';
z.string.tr.preferencesOptionsPreviewsSendDetail = 'n izlemeler hala bakalarndan gelen balantlar iin grntlenebilir olabilir.';
z.string.tr.preferencesOptionsNotifications = 'Bildirimler';
z.string.tr.preferencesOptionsNotificationsNone = 'Yok';
z.string.tr.preferencesOptionsNotificationsObfuscate = 'Ayrnty gizle';
z.string.tr.preferencesOptionsNotificationsObfuscateMessage = 'Gndereni gster';
z.string.tr.preferencesOptionsNotificationsOn = 'Gndereni ve mesaj gster';

z.string.tr.backupCancel = 'ptal';

z.string.tr.searchConnect = 'Balan';
z.string.tr.searchConnections = 'Balantlar';
z.string.tr.searchContacts = 'Kiiler';
z.string.tr.searchCreateGroup = 'Grup olutur';
z.string.tr.searchGroups = 'Gruplar';
z.string.tr.searchPeople = 'nsanlar';
z.string.tr.searchPlaceholder = 'sim veya kullanc adna gre ara';
z.string.tr.searchServicePlaceholder = 'sme gre ara';
z.string.tr.searchServices = 'Servisler';
z.string.tr.searchTeamGroups = 'Takm Konumalar';
z.string.tr.searchTeamMembers = 'Takm yeleri';
z.string.tr.searchTopPeople = 'Enler';
z.string.tr.searchTrySearch = 'nsanlar isimlerine veya kullanc adlarna gre bul';
z.string.tr.searchNoContactsOnWire = 'Wireda hi kiiniz yok. nsanlar isimlerine veya kullanc adlarna gre bulmay deneyin.';
z.string.tr.searchOthers = 'Balan';

z.string.tr.searchInvite = 'nsanlar Wirea katlmaya davet edin';
z.string.tr.searchInviteDetail = 'Kiileriniz paylamak, bakalaryla balanmanz kolaylatrr. Tm bilgilerinizi gizler ve kimseyle paylamayz.';
z.string.tr.searchInviteButtonContacts = 'Kiilerden';
z.string.tr.searchInviteButtonGmail = 'Gmailden';
z.string.tr.searchInviteHeadline = 'Arkadalarnz getirin';
z.string.tr.searchInviteShare = 'Kiileri Payla';

z.string.tr.searchListEveryoneParticipates = 'Balantda olduun herkes zaten bu grme ierisinde.';
z.string.tr.searchListNoMatches = 'Eleen sonu yok.\nBaka bir isim girmeyi deneyin.';

z.string.tr.temporaryGuestCta = 'Bir hesap olutur';

z.string.tr.uploadGoogleHeadline = 'Konumak iin\ninsanlar bul.';
z.string.tr.uploadGoogleMessage = 'letiim verilerinizi sizi bakalaryla balayabilmek iin kullanyoruz. Tm bilgilerinizi gizler ve kimseyle paylamayz.';

z.string.tr.warningCallUnsupportedIncoming = '{{user}} aryor. Ancak taraycnz sesli aramalar desteklemiyor.';
z.string.tr.warningCallUnsupportedOutgoing = 'Arama yapamazsnz nk taraycnz sesli aramalar desteklemiyor.';
z.string.tr.warningCallIssues = 'Wiren bu versiyonu aramalara katlamaz. Ltfen kullann';
z.string.tr.warningCallUpgradeBrowser = 'Arama yapmak iin, Google Chromeu gncelleyin.';
z.string.tr.warningConnectivityConnectionLost = 'Balanmaya allyor. Wire mesajlarnz teslim etmekte sorun yaayabilir.';
z.string.tr.warningConnectivityNoInternet = 'nternet balants yok. Mesaj gnderemez veya mesaj alamazsnz.';
z.string.tr.warningLearnMore = 'Daha fazla bilgi';
z.string.tr.warningLifecycleUpdate = 'Wiren yeni bir versiyonu mevcut.';
z.string.tr.warningLifecycleUpdateNotes = 'Neler yeni';
z.string.tr.warningLifecycleUpdateLink = 'imdi gncelle';
z.string.tr.warningNotFoundCamera = 'Arama yapamyorsunuz nk bilgisayarnzda bir kamera bulunmamaktadr.';
z.string.tr.warningNotFoundMicrophone = 'Arama yapamyorsunuz nk bilgisayarnzda bir mikrofon bulunmamaktadr.';
z.string.tr.warningPermissionDeniedCamera = 'Arama yapamyorsunuz nk taraycnzn kameraya eriim izni bulunmamaktadr.';
z.string.tr.warningPermissionDeniedMicrophone = 'Arama yapamyorsunuz nk taraycnzn mikrofona eriim izni bulunmamaktadr.';
z.string.tr.warningPermissionDeniedScreen = 'Taraycnz ekrannz paylamak iin gerekli izinleri salamaldr.';
z.string.tr.warningPermissionRequestCamera = '{{icon}} Kameraya eriime izin ver';
z.string.tr.warningPermissionRequestMicrophone = '{{icon}} Mikrofona eriime izin ver';
z.string.tr.warningPermissionRequestNotification = '{{icon}} Bildirimlere izin ver';
z.string.tr.warningPermissionRequestScreen = '{{icon}} Ekrana eriime izin ver';

z.string.tr.userAvailabilityAvailable = 'Alnabilir';
z.string.tr.userAvailabilityAway = 'Uzakta';
z.string.tr.userAvailabilityBusy = 'Megul';
z.string.tr.userAvailabilityNone = 'Hibiri';

z.string.tr.notificationAssetAdd = 'Bir resim paylat';
z.string.tr.notificationConnectionAccepted = 'Balant isteinizi kabul etti';
z.string.tr.notificationConnectionConnected = 'u anda balsnz';
z.string.tr.notificationConnectionRequest = 'Balanmak istiyor';
z.string.tr.notificationConversationCreate = '{{user}} bir konuma balatt';
z.string.tr.notificationConversationRename = '{{user}}, konuma ismini {{name}} olarak deitirdi';
z.string.tr.notificationMemberJoinMany = '{{user}}, konumaya {{number}} kii ekledi';
z.string.tr.notificationMemberJoinOne = '{{user1}}, {{user2}}i konumaya ekledi';
z.string.tr.notificationMemberLeaveRemovedYou = '{{user}} sizi konumadan kard';
z.string.tr.notificationObfuscated = 'Size bir mesaj gnderdi';
z.string.tr.notificationObfuscatedTitle = 'Birisi';
z.string.tr.notificationPing = 'Pingledi';
z.string.tr.notificationReaction = 'mesajnz {{reaction}}';
z.string.tr.notificationSharedAudio = 'Bir sesli mesaj paylat';
z.string.tr.notificationSharedFile = 'Bir dosya paylat';
z.string.tr.notificationSharedLocation = 'Bir konum paylat';
z.string.tr.notificationSharedVideo = 'Bir video paylat';
z.string.tr.notificationVoiceChannelActivate = 'Aryor';
z.string.tr.notificationVoiceChannelDeactivate = 'Arad';

z.string.tr.tooltipConversationAllVerified = 'Tm parmak izleri dorulanm';
z.string.tr.tooltipConversationCall = 'Ara';
z.string.tr.tooltipConversationEphemeral = 'Sreli Mesaj';
z.string.tr.tooltipConversationFile = 'Dosya Ekle';
z.string.tr.tooltipConversationInputPlaceholder = 'Bir mesaj yazn';
z.string.tr.tooltipConversationInputPlaceholderAvailable = '{{user}} msait';
z.string.tr.tooltipConversationInputPlaceholderAway = '{{user}} uzakta';
z.string.tr.tooltipConversationInputPlaceholderBusy = '{{user}} megul';
z.string.tr.tooltipConversationPeople = 'nsanlar ({{shortcut}})';
z.string.tr.tooltipConversationPicture = 'Resim ekle';
z.string.tr.tooltipConversationPing = 'Pingle ({{shortcut}})';
z.string.tr.tooltipConversationSearch = 'Arama';
z.string.tr.tooltipConversationVideoCall = 'Grntl Ara';

z.string.tr.tooltipConversationsArchive = 'Arivle ({{shortcut}})';
z.string.tr.tooltipConversationsArchived = 'Arivi gster ({{number}})';
z.string.tr.tooltipConversationsMore = 'Daha';
z.string.tr.tooltipConversationsNotify = 'Sesi a ({{shortcut}})';
z.string.tr.tooltipConversationsPreferences = 'Seenekleri a';
z.string.tr.tooltipConversationsSilence = 'Sessize al ({{shortcut}})';
z.string.tr.tooltipConversationsStart = 'Konuma balat ({{shortcut}})';

z.string.tr.tooltipConversationDetailsRename = 'Konuma adn deitir';

z.string.tr.tooltipPreferencesContactsGmail = 'Kiilerinizi paylamak iin Gmail hesabnza giri yapnz';
z.string.tr.tooltipPreferencesContactsMacos = 'MacOS Kiiler uygulamas araclyla tm kiilerinizi paylan';
z.string.tr.tooltipPreferencesPassword = 'ifreyi sfrlamak iin yeni bir pencere a';
z.string.tr.tooltipPreferencesPicture = 'Resminizi deitirin';
z.string.tr.tooltipPreferencesRename = 'sminizi deitirin';

z.string.tr.tooltipSearchClose = 'Kapat (Esc)';

z.string.tr.initReceivedSelfUser = 'Merhaba, {{user}}.';
z.string.tr.initValidatedClient = 'Balantlarnz ve konumalarnz alnyor';
z.string.tr.initReceivedUserData = 'Yeni mesajlar kontrol ediliyor';
z.string.tr.initDecryption = 'Mesajlarn ifresini z';
z.string.tr.initEvents = 'letiler ykleniyor';
z.string.tr.initUpdatedFromNotifications = 'Neredeyse bitti - Wiren keyfini karn';
z.string.tr.initProgress = '  {{number2}}de/da {{number1}}';

z.string.tr.ephemeralUnitsNone = 'Yok';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.uk.wire = 'Wire';
z.string.uk.wireMacos = 'Wire  macOS';
z.string.uk.wireWindows = 'Wire  Windows';
z.string.uk.wireLinux = 'Wire  Linux';
z.string.uk.nonexistentUser = ' ';
z.string.uk.and = '';
z.string.uk.enumerationAnd = ',  ';

//= 
z.string.uk.authAccountCountryCode = ' ';
z.string.uk.authAccountPasswordForgot = ' ?';
z.string.uk.authAccountPublicComputer = '  ';
z.string.uk.authAccountSignIn = '';
z.string.uk.authAccountSignInPhone = '   ';

z.string.uk.authBlockedCookies = '  cookie,    Wire.';
z.string.uk.authBlockedDatabase = 'Wire         .       .';
z.string.uk.authBlockedTabs = 'Wire      .';
z.string.uk.authBlockedTabsAction = '  ';

z.string.uk.authVerifyAccountAdd = '';
z.string.uk.authVerifyAccountDetail = '    Wire   .';
z.string.uk.authVerifyAccountHeadline = ' email  .';
z.string.uk.authVerifyAccountLogout = '';
z.string.uk.authVerifyCodeDescription = '  ,\n     {{number}}.';
z.string.uk.authVerifyCodeResend = 'SMS    ?';
z.string.uk.authVerifyCodeResendDetail = '  ';
z.string.uk.authVerifyCodeResendTimer = '        {{expiration}}.';
z.string.uk.authVerifyCodeChangePhone = '  ';
z.string.uk.authVerifyPasswordHeadline = '  ';

z.string.uk.authLimitDevicesHeadline = '';
z.string.uk.authLimitDescription = '    ,    Wire  .';
z.string.uk.authLimitButtonManage = ' ';
z.string.uk.authLimitButtonSignOut = '';
z.string.uk.authLimitDevicesCurrent = '()';

z.string.uk.authHistoryHeadline = '  ,    Wire   .';
z.string.uk.authHistoryDescription = '  ,      .';
z.string.uk.authHistoryReuseHeadline = '   Wire    .';
z.string.uk.authHistoryReuseDescription = ',    ,     Wire,  .';
z.string.uk.authHistoryButton = 'OK';

z.string.uk.authPostedResend = '   {{email}}';
z.string.uk.authPostedResendAction = '  email?';
z.string.uk.authPostedResendDetail = '       .';
z.string.uk.authPostedResendHeadline = '   .';

z.string.uk.authPlaceholderEmail = 'Email';
z.string.uk.authPlaceholderPasswordPut = '';
z.string.uk.authPlaceholderPasswordSet = ' (  8 )';
z.string.uk.authPlaceholderPhone = ' ';

z.string.uk.authErrorCode = ' ';
z.string.uk.authErrorCountryCodeInvalid = '  ';
z.string.uk.authErrorEmailExists = 'Email  ';
z.string.uk.authErrorEmailForbidden = '.       .';
z.string.uk.authErrorEmailMalformed = ' ,   email.';
z.string.uk.authErrorEmailMissing = ' ,    .';
z.string.uk.authErrorMisc = '  .  ,   .';
z.string.uk.authErrorNameShort = '     2 ';
z.string.uk.authErrorOffline = '   ';
z.string.uk.authErrorPasswordShort = '    6  20 .';
z.string.uk.authErrorPasswordWrong = ' .  ,   .';
z.string.uk.authErrorPending = '    ';
z.string.uk.authErrorPhoneNumberBudget = '     .  .';
z.string.uk.authErrorPhoneNumberForbidden = '.     .';
z.string.uk.authErrorPhoneNumberInvalid = '  ';
z.string.uk.authErrorPhoneNumberUnknown = '  ';
z.string.uk.authErrorSuspended = '   .';
z.string.uk.authErrorSignIn = ' ,      .';

z.string.uk.callStateOutgoing = '';
z.string.uk.callStateConnecting = '';
z.string.uk.callStateIncoming = '';
z.string.uk.callStateIncomingGroup = '{{user}} ';
z.string.uk.callDecline = '';
z.string.uk.callAccept = '';
z.string.uk.callJoin = '';
z.string.uk.callChooseSharedScreen = '  ,     ';
z.string.uk.callParticipants = '{{number}} ';
z.string.uk.callNoCameraAccess = '   ';

z.string.uk.videoCallOverlayFitVideoLabel = ' ,      ';
z.string.uk.videoCallOverlayConversations = '';
z.string.uk.videoCallOverlayMute = '. ';
z.string.uk.videoCallOverlayVideo = '';
z.string.uk.videoCallOverlayShareScreen = '  ';
z.string.uk.videoCallOverlayHangUp = '';
z.string.uk.videoCallPaused = ' ';
z.string.uk.videoCallScreenShareNotSupported = '       ';

z.string.uk.modalAcknowledgeAction = '';
z.string.uk.modalAcknowledgeHeadline = '   ';
z.string.uk.modalConfirmSecondary = '';
z.string.uk.modalOptionSecondary = '';

z.string.uk.modalAccountCreateAction = 'OK';
z.string.uk.modalAccountCreateHeadline = ' ?';
z.string.uk.modalAccountCreateMessage = ' ,        .';

z.string.uk.modalAccountDeletionAction = '';
z.string.uk.modalAccountDeletionHeadline = ' ';
z.string.uk.modalAccountDeletionMessage = '        SMS.   ,     .';

z.string.uk.modalAccountLeaveGuestRoomAction = '  ';
z.string.uk.modalAccountLeaveGuestRoomHeadline = '   ?';
z.string.uk.modalAccountLeaveGuestRoomMessage = '   .  ,     .';

z.string.uk.modalAccountLogoutAction = '';
z.string.uk.modalAccountLogoutHeadline = ' ?';
z.string.uk.modalAccountLogoutOption = '         .';

z.string.uk.modalAccountNewDevicesSecondary = ' ';
z.string.uk.modalAccountNewDevicesHeadline = '   :';
z.string.uk.modalAccountNewDevicesFrom = ':';
z.string.uk.modalAccountNewDevicesMessage = '    ,     .';

z.string.uk.modalAccountRemoveDeviceAction = ' ';
z.string.uk.modalAccountRemoveDeviceHeadline = ' "{{device}}"';
z.string.uk.modalAccountRemoveDeviceMessage = '      .';
z.string.uk.modalAccountRemoveDevicePlaceholder = '';

z.string.uk.modalAssetTooLargeHeadline = ' ';
z.string.uk.modalAssetTooLargeMessage = '     {{number}}';

z.string.uk.modalAssetParallelUploadsHeadline = '     ';
z.string.uk.modalAssetParallelUploadsMessage = '    {{number}}    .';

z.string.uk.modalCallEmptyConversationHeadline = ' ';
z.string.uk.modalCallEmptyConversationMessage = '   .';

z.string.uk.modalCallEmptyLogHeadline = ' ';
z.string.uk.modalCallEmptyLogMessage = '   ,        .';

z.string.uk.modalCallNoGroupVideoHeadline = '    ';
z.string.uk.modalCallNoGroupVideoMessage = '    .';

z.string.uk.modalCallNoMicrophoneAction = '  ';
z.string.uk.modalCallNoMicrophoneMessage = '     ,   .';
z.string.uk.modalCallNoMicrophoneHeadline = '      ';

z.string.uk.modalCallSecondIncomingAction = '';
z.string.uk.modalCallSecondIncomingHeadline = '  ?';
z.string.uk.modalCallSecondIncomingMessage = '   .';

z.string.uk.modalCallSecondOngoingAction = '';
z.string.uk.modalCallSecondOngoingHeadline = '    ?';
z.string.uk.modalCallSecondOngoingMessage = '        .';

z.string.uk.modalCallSecondOutgoingAction = '';
z.string.uk.modalCallSecondOutgoingHeadline = '  ?';
z.string.uk.modalCallSecondOutgoingMessage = '        .';

z.string.uk.modalConnectCancelAction = '';
z.string.uk.modalConnectCancelHeadline = ' ?';
z.string.uk.modalConnectCancelMessage = '    {{user}}  .';
z.string.uk.modalConnectCancelSecondary = '';

z.string.uk.modalConnectAcceptAction = '  ';
z.string.uk.modalConnectAcceptHeadline = '?';
z.string.uk.modalConnectAcceptMessage = '  {{user}}      .';
z.string.uk.modalConnectAcceptSecondary = '';

z.string.uk.modalConversationClearAction = '';
z.string.uk.modalConversationClearHeadline = ' ?';
z.string.uk.modalConversationClearMessage = '       .';
z.string.uk.modalConversationClearOption = '   ';

z.string.uk.modalConversationDeleteMessageAction = '';
z.string.uk.modalConversationDeleteMessageHeadline = '   ?';
z.string.uk.modalConversationDeleteMessageMessage = '   .';

z.string.uk.modalConversationDeleteMessageEveryoneAction = '';
z.string.uk.modalConversationDeleteMessageEveryoneHeadline = '  ?';
z.string.uk.modalConversationDeleteMessageEveryoneMessage = '   .';

z.string.uk.modalConversationLeaveAction = '  ';
z.string.uk.modalConversationLeaveHeadline = '   {{name}}?';
z.string.uk.modalConversationLeaveMessage = '          .';

z.string.uk.modalConversationMessageTooLongHeadline = '  ';
z.string.uk.modalConversationMessageTooLongMessage = '     {{number}} .';

z.string.uk.modalConversationNewDeviceAction = '  ';
z.string.uk.modalConversationNewDeviceHeadlineOne = '{{user}} (-)   ';
z.string.uk.modalConversationNewDeviceHeadlineMany = '{{user}}s    ';
z.string.uk.modalConversationNewDeviceHeadlineYou = '{{user}} (-)   ';
z.string.uk.modalConversationNewDeviceIncomingCallAction = ' ';
z.string.uk.modalConversationNewDeviceIncomingCallMessage = '     ?';
z.string.uk.modalConversationNewDeviceMessage = '    ?';
z.string.uk.modalConversationNewDeviceOutgoingCallAction = ' -';
z.string.uk.modalConversationNewDeviceOutgoingCallMessage = '     ?';

z.string.uk.modalConversationNotConnectedHeadline = '      ';
z.string.uk.modalConversationNotConnectedMessageOne = '{{name}}  ,     .';
z.string.uk.modalConversationNotConnectedMessageMany = '  ,   ,  ,     .';

z.string.uk.modalConversationRemoveAction = '';
z.string.uk.modalConversationRemoveHeadline = '?';
z.string.uk.modalConversationRemoveMessage = '{{user}}          .';

z.string.uk.modalConversationRemoveGuestsAction = ' ';
z.string.uk.modalConversationRemoveGuestsHeadline = '  ?';
z.string.uk.modalConversationRemoveGuestsMessage = '       .         .';

z.string.uk.modalConversationRevokeLinkAction = ' ';
z.string.uk.modalConversationRevokeLinkHeadline = ' ?';
z.string.uk.modalConversationRevokeLinkMessage = '       .      .';

z.string.uk.modalConversationGuestOptionsAllowGuestMessage = '       .  ,  .';
z.string.uk.modalConversationGuestOptionsDisableGuestMessage = '     .  ,  .';
z.string.uk.modalConversationGuestOptionsGetCodeMessage = '     .';
z.string.uk.modalConversationGuestOptionsRequestCodeMessage = '      .  ,   .';
z.string.uk.modalConversationGuestOptionsRevokeCodeMessage = '      .  ,   .';
z.string.uk.modalConversationGuestOptionsToggleGuestsMessage = '    .';

z.string.uk.modalConversationTooManyMembersHeadline = ' ';
z.string.uk.modalConversationTooManyMembersMessage = '     {{number1}} .        {{number2}} .';

z.string.uk.modalGifTooLargeHeadline = '  ';
z.string.uk.modalGifTooLargeMessage = '   - {{number}} .';

z.string.uk.modalIntegrationUnavailableHeadline = '    ';
z.string.uk.modalIntegrationUnavailableMessage = '   ,   .      ,     ,      .   .';

z.string.uk.modalPictureFileFormatHeadline = '    ';
z.string.uk.modalPictureFileFormatMessage = ' ,  PNG-  JPEG-.';

z.string.uk.modalPictureTooLargeHeadline = '  ';
z.string.uk.modalPictureTooLargeMessage = '      {{number}} .';

z.string.uk.modalPictureTooSmallHeadline = ' ';
z.string.uk.modalPictureTooSmallMessage = ' ,       320x320 .';

z.string.uk.modalImproveWireAction = '';
z.string.uk.modalImproveWireSecondary = '';
z.string.uk.modalImproveWireHeadline = '   Wire ';
z.string.uk.modalImproveWireMessage = ' (-)  ,  Wire                 .       - .';

z.string.uk.modalServiceUnavailableHeadline = '  ';
z.string.uk.modalServiceUnavailableMessage = '   .';

z.string.uk.modalSessionResetHeadline = '  ';
z.string.uk.modalSessionResetMessage1 = '   ,';
z.string.uk.modalSessionResetMessageLink = '';
z.string.uk.modalSessionResetMessage2 = ' .';

z.string.uk.modalUploadContactsAction = '  ';
z.string.uk.modalUploadContactsMessage = '    .  ,   .';

z.string.uk.modalUserBlockAction = '';
z.string.uk.modalUserBlockHeadline = ' {{user}}?';
z.string.uk.modalUserBlockMessage = '{{user}}             .';

z.string.uk.modalUserUnblockAction = '';
z.string.uk.modalUserUnblockHeadline = '?';
z.string.uk.modalUserUnblockMessage = '{{user}}             .';

z.string.uk.modalNoCameraTitle = '   ';
z.string.uk.modalNoCameraMessage = '   .[br][faqLink] [/faqLink]  ,    .';

z.string.uk.connectionRequestConnect = '  ';
z.string.uk.connectionRequestIgnore = '';

z.string.uk.conversationGuestIndicator = '';
z.string.uk.userRemainingTimeHours = ' {{time}} ';
z.string.uk.userRemainingTimeMinutes = '  {{time}} ';

z.string.uk.conversationYouNominative = '';
z.string.uk.conversationYouDative = '';
z.string.uk.conversationYouAccusative = '';

z.string.uk.conversationConnectionAccepted = '(-)  ';
z.string.uk.conversationConnectionBlocked = '(-)';
z.string.uk.conversationConnectionCancelRequest = '     ';
z.string.uk.conversationCreateTemporary = '   ';
z.string.uk.conversationCreateWith = ' {{users}}';
z.string.uk.conversationDeviceStartedUsingOne = ' (-) ';
z.string.uk.conversationDeviceStartedUsingMany = ' (-) ';
z.string.uk.conversationDeviceUnverified = ' (-)   ';
z.string.uk.conversationDeviceYourDevices = '  ';
z.string.uk.conversationDeviceUserDevices = '  {{user}}';
z.string.uk.conversationDeviceNewDeviceOne = '  ';
z.string.uk.conversationDeviceNewDeviceMany = '  ';
z.string.uk.conversationDeviceNewPeopleJoined = '  .';
z.string.uk.conversationDeviceNewPeopleJoinedVerify = ' ';
z.string.uk.conversationJustNow = '';
z.string.uk.conversationLocationLink = ' ';
z.string.uk.conversationCreated = '[bold]{{name}}[/bold] (-)   {{users}}';
z.string.uk.conversationCreatedMore = '[bold]{{name}}[/bold] (-)   {{users}}   [showmore]{{count}} [/showmore]';
z.string.uk.conversationCreatedName = '[bold]{{name}}[/bold] (-) ';
z.string.uk.conversationCreatedNameYou = '[bold][/bold]  ';
z.string.uk.conversationCreatedYou = '    {{users}}';
z.string.uk.conversationCreatedYouMore = '    {{users}}   [showmore]{{count}}[/showmore]';
z.string.uk.conversationCreateWithMore = ' {{users}},   [showmore]{{count}}[/showmore]';
z.string.uk.conversationCreateTeam = ' [showmore]  [/showmore]';
z.string.uk.conversationCreateTeamGuest = ' [showmore]     [/showmore]';
z.string.uk.conversationCreateTeamGuests = ' [showmore]    {{count}} [/showmore]';
z.string.uk.conversationMemberJoined = '[bold]{{name}}[/bold] (-)   {{users}}';
z.string.uk.conversationMemberJoinedYou = '[bold][/bold]    {{users}}';
z.string.uk.conversationMemberJoinedMore = '[bold]{{name}}[/bold]    {{users}}   [showmore]{{count}}[/showmore]';
z.string.uk.conversationMemberJoinedYouMore = '[bold][/bold]    {{users}}   [showmore]{{count}}[/showmore]';
z.string.uk.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] (-)  ';
z.string.uk.conversationMemberJoinedSelfYou = '[bold][/bold]   ';
z.string.uk.conversationMemberLeft = '[bold]{{name}}[/bold] (-)  ';
z.string.uk.conversationMemberLeftYou = '[bold][/bold]   ';
z.string.uk.conversationMemberRemoved = '[bold]{{name}}[/bold] (-) {{users}}';
z.string.uk.conversationMemberRemovedYou = '[bold][/bold]  {{users}}';
z.string.uk.conversationTeamLeft = '[bold]{{name}}[/bold] (-) (-)  ';
z.string.uk.conversationMessageDelivered = '';
z.string.uk.conversationRename = ' (-) ';
z.string.uk.conversationRenameYou = ' (-) ';
z.string.uk.conversationUpdatedTimer = ' (-)    {{time}}';
z.string.uk.conversationUpdatedTimerYou = ' (-)    {{time}}';
z.string.uk.conversationResetTimer = ' (-)  ';
z.string.uk.conversationResetTimerYou = ' (-)  ';
z.string.uk.conversationResume = '(-)   {{users}}';
z.string.uk.conversationPing = ' (-) ';
z.string.uk.conversationPingYou = ' (-) ';
z.string.uk.conversationToday = '';
z.string.uk.conversationVoiceChannelDeactivate = ' (-)';
z.string.uk.conversationVoiceChannelDeactivateYou = ' (-)';
z.string.uk.conversationYesterday = '';
z.string.uk.conversationUnableToDecrypt1 = '  [highlight]{{user}}[/highlight]  .';
z.string.uk.conversationUnableToDecrypt2 = '  [highlight]{{user}}[/highlight] .   .';
z.string.uk.conversationUnableToDecryptLink = '?';
z.string.uk.conversationUnableToDecryptErrorMessage = '';
z.string.uk.conversationUnableToDecryptResetSession = ' ';
z.string.uk.conversationMissedMessages = '       .      .';
z.string.uk.conversationAssetUploading = '';
z.string.uk.conversationAssetDownloading = '';
z.string.uk.conversationAssetUploadFailed = '  ';
z.string.uk.conversationPlaybackError = ' ';
z.string.uk.conversationContextMenuCopy = '';
z.string.uk.conversationContextMenuEdit = '';
z.string.uk.conversationContextMenuDelete = '  ';
z.string.uk.conversationContextMenuDeleteEveryone = '  ';
z.string.uk.conversationContextMenuDownload = '';
z.string.uk.conversationContextMenuLike = '';
z.string.uk.conversationContextMenuReply = '';
z.string.uk.conversationContextMenuUnlike = ' ';
z.string.uk.conversationDeleteTimestamp = ': {{date}}';
z.string.uk.conversationEditTimestamp = ': {{date}}';
z.string.uk.conversationLikesCaption = '{{number}} ';
z.string.uk.conversationSendPastedFile = '(-)  {{date}}';
z.string.uk.conversationSomeone = '';
z.string.uk.conversationTweetAuthor = '  Twitter';
z.string.uk.conversationServicesWarning = '      ';

z.string.uk.groupCreationPreferencesAction = '';
z.string.uk.groupCreationPreferencesErrorNameShort = '  1 ';
z.string.uk.groupCreationPreferencesErrorNameLong = '  ';
z.string.uk.groupCreationPreferencesHeader = ' ';
z.string.uk.groupCreationPreferencesPlaceholder = ' ';
z.string.uk.groupCreationParticipantsActionCreate = '';
z.string.uk.groupCreationParticipantsActionSkip = '';
z.string.uk.groupCreationParticipantsHeader = ' ';
z.string.uk.groupCreationParticipantsHeaderWithCounter = '  ({{number}})';
z.string.uk.groupCreationParticipantsPlaceholder = '  ';
z.string.uk.groupSizeInfo = '     {{count}} .       4-   .';

z.string.uk.guestRoomConversationName = ' ';
z.string.uk.guestRoomToggleName = '    ';
z.string.uk.guestRoomToggleInfo = '           .';
z.string.uk.guestRoomToggleInfoExtended = '          .      .';

z.string.uk.guestRoomConversationBadge = ' ';
z.string.uk.guestRoomConversationBadgeService = ' ';
z.string.uk.guestRoomConversationBadgeGuestAndService = '   ';

z.string.uk.guestRoomConversationHead = '         .';
z.string.uk.guestRoomConversationButton = ' ';

z.string.uk.collectionShowAll = '  {{number}}';
z.string.uk.collectionSectionLinks = '';
z.string.uk.collectionSectionImages = '';
z.string.uk.collectionSectionFiles = '';
z.string.uk.collectionSectionAudio = '';

z.string.uk.fullsearchPlaceholder = '  ';
z.string.uk.fullsearchNoResults = '  .';

z.string.uk.archiveHeader = '';

z.string.uk.conversationsAllArchived = '  ';
z.string.uk.conversationsContacts = '';
z.string.uk.conversationsConnectionRequestMany = '{{number}}  ';
z.string.uk.conversationsConnectionRequestOne = '1  ';
z.string.uk.conversationsEmptyConversation = ' ';
z.string.uk.conversationsNoConversations = '    .';
z.string.uk.conversationsPopoverArchive = '';
z.string.uk.conversationsPopoverBlock = '';
z.string.uk.conversationsPopoverCancel = ' ';
z.string.uk.conversationsPopoverClear = ' ';
z.string.uk.conversationsPopoverLeave = '  ';
z.string.uk.conversationsPopoverNotificationSettings = '';
z.string.uk.conversationsPopoverNotify = '. ';
z.string.uk.conversationsPopoverSilence = '. ';
z.string.uk.conversationsPopoverUnarchive = '';

z.string.uk.conversationsSecondaryLineEphemeralMention = ' ';
z.string.uk.conversationsSecondaryLineEphemeralMentionGroup = '  ';
z.string.uk.conversationsSecondaryLineEphemeralMessage = ' ';
z.string.uk.conversationsSecondaryLineEphemeralMessageGroup = '  ';
z.string.uk.conversationsSecondaryLineEphemeralReply = '(-) ';
z.string.uk.conversationsSecondaryLineEphemeralReplyGroup = '  ';
z.string.uk.conversationsSecondaryLineIncomingCall = '{{user}} ';
z.string.uk.conversationsSecondaryLinePeopleLeft = '{{number}}  ';
z.string.uk.conversationsSecondaryLinePersonLeft = '{{user}} (-)';
z.string.uk.conversationsSecondaryLinePersonRemoved = '{{user}} (-) (-)';
z.string.uk.conversationsSecondaryLinePersonRemovedTeam = '{{user}} (-) (-)  ';
z.string.uk.conversationsSecondaryLinePeopleAdded = '{{user}}   ';
z.string.uk.conversationsSecondaryLinePersonAdded = '{{user}} (-) (-)';
z.string.uk.conversationsSecondaryLinePersonAddedSelf = '{{user}} (-)';
z.string.uk.conversationsSecondaryLinePersonAddedYou = '{{user}} (-) ';
z.string.uk.conversationsSecondaryLineRenamed = '{{user}} (-) ';
z.string.uk.conversationsSecondaryLineSummaryMessage = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryMessages = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryMention = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryMentions = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryMissedCall = '{{number}}  ';
z.string.uk.conversationsSecondaryLineSummaryMissedCalls = '{{number}}  ';
z.string.uk.conversationsSecondaryLineSummaryPing = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryPings = '{{number}} '
z.string.uk.conversationsSecondaryLineSummaryReply = '{{number}} ';
z.string.uk.conversationsSecondaryLineSummaryReplies = '{{number}} ';
z.string.uk.conversationsSecondaryLineYouLeft = ' ';
z.string.uk.conversationsSecondaryLineYouWereRemoved = ' ';

z.string.uk.takeoverSub = '     Wire.';
z.string.uk.takeoverLink = ' ';
z.string.uk.takeoverButtonChoose = ' ';
z.string.uk.takeoverButtonKeep = ' ';

z.string.uk.inviteMetaKeyMac = 'Cmd';
z.string.uk.inviteMetaKeyPc = 'Ctrl';
z.string.uk.inviteHintSelected = ' {{metaKey}} + C,  ';
z.string.uk.inviteHintUnselected = '   {{metaKey}} + C';
z.string.uk.inviteHeadline = '   Wire';
z.string.uk.inviteMessage = '  Wire.    {{username}}   get.wire.com.';
z.string.uk.inviteMessageNoEmail = '   Wire.  get.wire.com,   .';

z.string.uk.extensionsBubbleButtonGif = 'Gif';

z.string.uk.extensionsGiphyButtonOk = '';
z.string.uk.extensionsGiphyButtonMore = ' ';
z.string.uk.extensionsGiphyMessage = '{{tag}}   giphy.com';
z.string.uk.extensionsGiphyNoGifs = ',   ';
z.string.uk.extensionsGiphyRandom = '';

z.string.uk.addParticipantsConfirmLabel = '';
z.string.uk.addParticipantsHeader = ' ';
z.string.uk.addParticipantsHeaderWithCounter = '  ({{number}})';
z.string.uk.addParticipantsManageServices = ' ';
z.string.uk.addParticipantsManageServicesNoResults = ' ';
z.string.uk.addParticipantsNoServicesManager = '  ,      .';
z.string.uk.addParticipantsNoServicesMember = '  ,      .   ,     .';
z.string.uk.addParticipantsSearchPlaceholder = '  ';
z.string.uk.addParticipantsServiceConfirmButton = ' ';
z.string.uk.addParticipantsTabsPeople = ' ';
z.string.uk.addParticipantsTabsServices = '';

z.string.uk.conversationDetailsActionArchive = '';
z.string.uk.conversationDetailsActionAddParticipants = ' ';
z.string.uk.conversationDetailsActionBlock = '';
z.string.uk.conversationDetailsActionCancelRequest = ' ';
z.string.uk.conversationDetailsActionClear = ' ';
z.string.uk.conversationDetailsActionConversationParticipants = '  ({{number}})';
z.string.uk.conversationDetailsActionCreateGroup = ' ';
z.string.uk.conversationDetailsActionDevices = '';
z.string.uk.conversationDetailsActionGuestOptions = '  ';
z.string.uk.conversationDetailsActionTimedMessages = ' ';
z.string.uk.conversationDetailsActionNotifications = '';
z.string.uk.conversationDetailsActionLeave = '  ';
z.string.uk.conversationDetailsGuestsOff = '';
z.string.uk.conversationDetailsGuestsOn = '.';
z.string.uk.conversationDetailsOptions = '';
z.string.uk.conversationDetailsParticipantsServicesOne = '';
z.string.uk.conversationDetailsParticipantsServicesMany = '';
z.string.uk.conversationDetailsParticipantsUsersOne = '';
z.string.uk.conversationDetailsParticipantsUsersMany = ' ';
z.string.uk.conversationDetailsPeople = ' ';
z.string.uk.conversationDetailsServices = '';

z.string.uk.conversationParticipantsTitle = ' ';
z.string.uk.conversationParticipantsSearchPlaceholder = '  ';

z.string.uk.groupParticipantActionBlock = '';
z.string.uk.groupParticipantActionCancelRequest = ' ';
z.string.uk.groupParticipantActionDevices = '';
z.string.uk.groupParticipantActionIgnoreRequest = ' ';
z.string.uk.groupParticipantActionIncomingRequest = ' ';
z.string.uk.groupParticipantActionLeave = '  ';
z.string.uk.groupParticipantActionOpenConversation = ' ';
z.string.uk.groupParticipantActionPending = ' ';
z.string.uk.groupParticipantActionRemove = '  ';
z.string.uk.groupParticipantActionSelfProfile = ' ';
z.string.uk.groupParticipantActionSendRequest = '  ';
z.string.uk.groupParticipantActionUnblock = '';

z.string.uk.guestOptionsCopyLink = ' ';
z.string.uk.guestOptionsCopyLinkDone = ' !';
z.string.uk.guestOptionsCreateLink = ' ';
z.string.uk.guestOptionsInfoHeader = '     ';
z.string.uk.guestOptionsInfoText = '         24 ,         Wire.';
z.string.uk.guestOptionsRevokeLink = ' ';
z.string.uk.guestOptionsTitle = '  ';

z.string.uk.notificationSettingsTitle = '';
z.string.uk.notificationSettingsDisclaimer = '       (   ),   ,   .';
z.string.uk.notificationSettingsEverything = '';
z.string.uk.notificationSettingsMentionsAndReplies = '  ';
z.string.uk.notificationSettingsNothing = '';

z.string.uk.timedMessagesTitle = ' ';
z.string.uk.timedMessageDisclaimer = '        .';

z.string.uk.participantDevicesDetailHeadline = ',     ,     ,   {{html1}}{{user}}{{html2}}.';
z.string.uk.participantDevicesDetailHowTo = '  ?';
z.string.uk.participantDevicesDetailResetSession = ' ';
z.string.uk.participantDevicesDetailShowMyDevice = ' .  ';
z.string.uk.participantDevicesDetailVerify = '';

z.string.uk.participantDevicesHeader = '';
z.string.uk.participantDevicesHeadline = 'Wire     .        {{user}}    .';
z.string.uk.participantDevicesLearnMore = ' ';
z.string.uk.participantDevicesWhyVerify = '  ?';
z.string.uk.participantDevicesOutdatedClientMessage = '{{user}}    Wire,     .';

z.string.uk.participantDevicesSelfAllDevices = '   ';
z.string.uk.participantDevicesSelfFingerprint = ' ';

z.string.uk.userProfileButtonConnect = '  ';
z.string.uk.userProfileButtonIgnore = '';
z.string.uk.userProfileButtonUnblock = '';

z.string.uk.preferencesAbout = ' ';
z.string.uk.preferencesAccount = '';
z.string.uk.preferencesAV = ' / ';
z.string.uk.preferencesDeviceDetails = ' ';
z.string.uk.preferencesDevices = '';
z.string.uk.preferencesHeadline = '';
z.string.uk.preferencesOptions = '';

z.string.uk.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.uk.preferencesAboutPrivacyPolicy = ' ';
z.string.uk.preferencesAboutSupport = '';
z.string.uk.preferencesAboutSupportWebsite = ' ';
z.string.uk.preferencesAboutSupportContact = '   ';
z.string.uk.preferencesAboutTermsOfUse = ' ';
z.string.uk.preferencesAboutVersion = ' {{version}}';
z.string.uk.preferencesAboutWebsite = '- Wire';

z.string.uk.preferencesAccountAvaibilityUnset = ' ';
z.string.uk.preferencesAccountCreateTeam = ' ';
z.string.uk.preferencesAccountData = '   ';
z.string.uk.preferencesAccountDataCheckbox = '  ';
z.string.uk.preferencesAccountDataDetail = '  Wire ,         .';
z.string.uk.preferencesAccountDelete = ' ';
z.string.uk.preferencesAccountLeaveGuestRoom = '   ';
z.string.uk.preferencesAccountLeaveGuestRoomDescription = '          .';
z.string.uk.preferencesAccountLogOut = '';
z.string.uk.preferencesAccountManageTeam = ' ';
z.string.uk.preferencesAccountMarketingConsentCheckbox = ' ';
z.string.uk.preferencesAccountMarketingConsentDetail = '      Wire   .';
z.string.uk.preferencesAccountResetPassword = '  ';
z.string.uk.preferencesAccountTeam = ' {{name}}';
z.string.uk.preferencesAccountUsernamePlaceholder = '  ';
z.string.uk.preferencesAccountUsernameHint = ' 2    az, 09,  _.';
z.string.uk.preferencesAccountUsernameAvailable = '';
z.string.uk.preferencesAccountUsernameErrorTaken = ' ';

z.string.uk.preferencesAVCamera = '';
z.string.uk.preferencesAVMicrophone = '';
z.string.uk.preferencesAVPermissionDetail = '    ';
z.string.uk.preferencesAVSpeakers = '';
z.string.uk.preferencesAVTemporaryDisclaimer = '    . ,           .';
z.string.uk.preferencesAVNoCamera = '   .[br][faqLink] [/faqLink]  ,    .';
z.string.uk.preferencesAVTryAgain = '  ';

z.string.uk.preferencesDevicesActivatedOn = ': {{date}}';
z.string.uk.preferencesDevicesActive = '';
z.string.uk.preferencesDevicesActiveDetail = '     ,      .';
z.string.uk.preferencesDevicesCurrent = '';
z.string.uk.preferencesDevicesFingerprint = '';
z.string.uk.preferencesDevicesFingerprintDetail = 'Wire     .  ,      .';
z.string.uk.preferencesDevicesId = ': ';
z.string.uk.preferencesDevicesRemove = '';
z.string.uk.preferencesDevicesRemoveCancel = '';
z.string.uk.preferencesDevicesRemoveDetail = '  ,     .   ,     .';
z.string.uk.preferencesDevicesSessionConfirmation = '  .';
z.string.uk.preferencesDevicesSessionDetail = '   ,   ,        .';
z.string.uk.preferencesDevicesSessionReset = ' ';
z.string.uk.preferencesDevicesSessionOngoing = ' ';
z.string.uk.preferencesDevicesVerification = '';

z.string.uk.preferencesOptionsAudio = ' ';
z.string.uk.preferencesOptionsAudioAll = '';
z.string.uk.preferencesOptionsAudioAllDetail = ' ';
z.string.uk.preferencesOptionsAudioNone = ' ';
z.string.uk.preferencesOptionsAudioNoneDetail = '!';
z.string.uk.preferencesOptionsAudioSome = '';
z.string.uk.preferencesOptionsAudioSomeDetail = '  ';
z.string.uk.preferencesOptionsContacts = '';
z.string.uk.preferencesOptionsContactsGmail = '  Gmail';
z.string.uk.preferencesOptionsContactsMacos = '  ';
z.string.uk.preferencesOptionsContactsDetail = '     ,     ,   .          .';
z.string.uk.preferencesOptionsPopular = '    ';
z.string.uk.preferencesOptionsEmojiReplaceCheckbox = '   ';
z.string.uk.preferencesOptionsEmojiReplaceDetail = ':-)  {{icon}}';
z.string.uk.preferencesOptionsPreviewsSendCheckbox = '     ';
z.string.uk.preferencesOptionsPreviewsSendDetail = '          .';
z.string.uk.preferencesOptionsNotifications = '';
z.string.uk.preferencesOptionsNotificationsNone = '';
z.string.uk.preferencesOptionsNotificationsObfuscate = ' ';
z.string.uk.preferencesOptionsNotificationsObfuscateMessage = ' ';
z.string.uk.preferencesOptionsNotificationsOn = '   ';
z.string.uk.preferencesOptionsCallLogs = ' ';
z.string.uk.preferencesOptionsCallLogsGet = '    ';
z.string.uk.preferencesOptionsCallLogsDetail = '     Wire  ,   .';

z.string.uk.preferencesOptionsBackupHeader = '';
z.string.uk.preferencesOptionsBackupExportHeadline = '   ';
z.string.uk.preferencesOptionsBackupExportSecondary = '       .    ,   ,           . \n       Wire,      .';
z.string.uk.preferencesOptionsBackupImportHeadline = '   ';
z.string.uk.preferencesOptionsBackupImportSecondary = '       ,     .    ,  , ,     .';

z.string.uk.backupExportGenericErrorHeadline = '   ';
z.string.uk.backupExportGenericErrorSecondary = '   .';
z.string.uk.backupExportProgressHeadline = '';
z.string.uk.backupExportProgressSecondary = '   {{processed}}  {{total}}  {{progress}}%';
z.string.uk.backupExportProgressCompressing = '   ';
z.string.uk.backupExportSaveFileAction = ' ';
z.string.uk.backupExportSuccessHeadline = '  ';
z.string.uk.backupExportSuccessSecondary = '    ,           .';
z.string.uk.backupImportGenericErrorHeadline = '   ';
z.string.uk.backupImportGenericErrorSecondary = '     .';
z.string.uk.backupImportAccountErrorHeadline = '  ';
z.string.uk.backupImportAccountErrorSecondary = '       .';
z.string.uk.backupImportVersionErrorHeadline = '   ';
z.string.uk.backupImportVersionErrorSecondary = '         Wire,    .';
z.string.uk.backupImportIncompatibleErrorHeadline = '  ';
z.string.uk.backupImportIncompatibleErrorSecondary = '       .';
z.string.uk.backupImportOutdatedErrorHeadline = '   ';
z.string.uk.backupImportOutdatedErrorSecondary = '         Wire,    .';
z.string.uk.backupImportProgressHeadline = '';
z.string.uk.backupImportProgressSecondary = '    {{processed}}  {{total}}  {{progress}}%';
z.string.uk.backupImportSuccessHeadline = '  .';
z.string.uk.backupCancel = '';
z.string.uk.backupTryAgain = '  ';

z.string.uk.searchConnect = '  ';
z.string.uk.searchConnections = '';
z.string.uk.searchContacts = '';
z.string.uk.searchCreateGroup = ' ';
z.string.uk.searchCreateGuestRoom = '  ';
z.string.uk.searchGroups = '';
z.string.uk.searchPeople = ' ';
z.string.uk.searchPlaceholder = '    ';
z.string.uk.searchServicePlaceholder = '  ';
z.string.uk.searchServices = '';
z.string.uk.searchManageServices = ' ';
z.string.uk.searchManageServicesNoResults = ' ';
z.string.uk.searchNoServicesManager = '  ,      .';
z.string.uk.searchNoServicesMember = '  ,      .   ,     .';
z.string.uk.searchTeamGroups = '  ';
z.string.uk.searchTeamMembers = ' ';
z.string.uk.searchTopPeople = '-';
z.string.uk.searchTrySearch = ' \n   ';
z.string.uk.searchNoContactsOnWire = '       Wire.\n  \n    .';
z.string.uk.searchMemberInvite = '    ';
z.string.uk.searchOthers = '  ';

z.string.uk.searchInvite = '   Wire';
z.string.uk.searchInviteDetail = ' ,     Wire  ,   , , .        .';
z.string.uk.searchInviteButtonContacts = ' ';
z.string.uk.searchInviteButtonGmail = ' Gmail';
z.string.uk.searchInviteHeadline = ' ';
z.string.uk.searchInviteShare = ' ';

z.string.uk.searchServiceConfirmButton = ' ';

z.string.uk.searchListEveryoneParticipates = '  \n \n  .';
z.string.uk.searchListNoMatches = ' .\n   .';

z.string.uk.temporaryGuestCta = ' ';
z.string.uk.temporaryGuestDescription = '         -.';
z.string.uk.temporaryGuestTimeRemaining = '     ';

z.string.uk.temporaryGuestJoinMessage = '       24 .';
z.string.uk.temporaryGuestJoinDescription = '    ,     .';

z.string.uk.temporaryGuestLeaveMessage = '      .';
z.string.uk.temporaryGuestLeaveDescription = '    ,      .';

z.string.uk.uploadGoogleHeadline = ' ,\n .';
z.string.uk.uploadGoogleMessage = '     ,     ,   .          .';

z.string.uk.urlSupportRoot = '/';
z.string.uk.urlSupportArticles = '/hc/en-us/articles/';
z.string.uk.urlSupportRequests = '/hc/en-us/requests/';
z.string.uk.urlWebappRoot = '/';
z.string.uk.urlWebsiteRoot = '/';
z.string.uk.urlWebsiteCreateTeam = '/create-team/';
z.string.uk.urlWebsitePrivacy = '/privacy';
z.string.uk.warningCallUnsupportedIncoming = '{{user}} .     .';
z.string.uk.warningCallUnsupportedOutgoing = '   ,       .';
z.string.uk.warningCallIssues = '  Wire      .  , ';
z.string.uk.warningCallUpgradeBrowser = ' ,  ,  Google Chrome.';
z.string.uk.warningConnectivityConnectionLost = ' . Wire, ,    .';
z.string.uk.warningConnectivityNoInternet = '   Internet.       .';
z.string.uk.warningLearnMore = ' ';
z.string.uk.warningLifecycleUpdate = '   Wire.';
z.string.uk.warningLifecycleUpdateNotes = ' ';
z.string.uk.warningLifecycleUpdateLink = ' ';
z.string.uk.warningNotFoundCamera = '   ,        .';
z.string.uk.warningNotFoundMicrophone = '   ,        .';
z.string.uk.warningPermissionDeniedCamera = '   ,           .';
z.string.uk.warningPermissionDeniedMicrophone = '   ,           .';
z.string.uk.warningPermissionDeniedScreen = ' Wire  ,       .';
z.string.uk.warningPermissionRequestCamera = '[icon]    ';
z.string.uk.warningPermissionRequestMicrophone = '[icon]    ';
z.string.uk.warningPermissionRequestNotification = '[icon]  ';
z.string.uk.warningPermissionRequestScreen = '[icon]       ';

z.string.uk.userAvailabilityAvailable = '';
z.string.uk.userAvailabilityAway = '  ';
z.string.uk.userAvailabilityBusy = ' ';
z.string.uk.userAvailabilityNone = ' ';

z.string.uk.notificationAssetAdd = '(-) ';
z.string.uk.notificationConnectionAccepted = '(-)      ';
z.string.uk.notificationConnectionConnected = '  ';
z.string.uk.notificationConnectionRequest = '  (-)   ';
z.string.uk.notificationConversationCreate = '{{user}} (-) ';
z.string.uk.notificationConversationMessageTimerUpdate = '{{user}} (-)    {{time}}';
z.string.uk.notificationConversationMessageTimerReset = '{{user}} (-)  ';
z.string.uk.notificationConversationRename = '{{user}} (-)   {{name}}';
z.string.uk.notificationMemberJoinMany = '{{user}} (-) {{number}}   ';
z.string.uk.notificationMemberJoinSelf = '{{user}} (-)  ';
z.string.uk.notificationMemberJoinOne = '{{user1}} (-) {{user2}}  ';
z.string.uk.notificationMemberLeaveRemovedYou = '{{user}} (-)   ';
z.string.uk.notificationMention = ': {{text}}';
z.string.uk.notificationObfuscated = ' ';
z.string.uk.notificationObfuscatedMention = ' ';
z.string.uk.notificationObfuscatedReply = '(-) ';
z.string.uk.notificationObfuscatedTitle = '';
z.string.uk.notificationPing = '(-) ';
z.string.uk.notificationReaction = '{{reaction}}  ';
z.string.uk.notificationReply = ': {{text}}';
z.string.uk.notificationSharedAudio = '(-) ';
z.string.uk.notificationSharedFile = '(-) ';
z.string.uk.notificationSharedLocation = '(-) ';
z.string.uk.notificationSharedVideo = '(-) ';
z.string.uk.notificationTitleGroup = '{{user}}  {{conversation}}';
z.string.uk.notificationVoiceChannelActivate = '';
z.string.uk.notificationVoiceChannelDeactivate = '(-)';

z.string.uk.tooltipConversationAllVerified = '   ';
z.string.uk.tooltipConversationCall = '';
z.string.uk.tooltipConversationEphemeral = ' ';
z.string.uk.tooltipConversationFile = ' ';
z.string.uk.tooltipConversationInputPlaceholder = ' ';
z.string.uk.tooltipConversationInputPlaceholderAvailable = '{{user}}: ';
z.string.uk.tooltipConversationInputPlaceholderAway = '{{user}}:   ';
z.string.uk.tooltipConversationInputPlaceholderBusy = '{{user}}:  ';
z.string.uk.tooltipConversationPeople = ' ({{shortcut}})';
z.string.uk.tooltipConversationPicture = ' ';
z.string.uk.tooltipConversationPing = '  ({{shortcut}})';
z.string.uk.tooltipConversationSearch = '';
z.string.uk.tooltipConversationVideoCall = '';

z.string.uk.tooltipConversationsArchive = ' ({{shortcut}})';
z.string.uk.tooltipConversationsArchived = '  ({{number}})';
z.string.uk.tooltipConversationsMore = '';
z.string.uk.tooltipConversationsNotifications = '   ({{shortcut}})';
z.string.uk.tooltipConversationsNotify = '  ({{shortcut}})';
z.string.uk.tooltipConversationsPreferences = ' ';
z.string.uk.tooltipConversationsSilence = '  ({{shortcut}})';
z.string.uk.tooltipConversationsStart = '  ({{shortcut}})';

z.string.uk.tooltipConversationDetailsAddPeople = '    ({{shortcut}})';
z.string.uk.tooltipConversationDetailsRename = '  ';

z.string.uk.tooltipPreferencesContactsGmail = '     Gmail,   ';
z.string.uk.tooltipPreferencesContactsMacos = '       Mac OS';
z.string.uk.tooltipPreferencesPassword = '    ,    ';
z.string.uk.tooltipPreferencesPicture = '  ';
z.string.uk.tooltipPreferencesRename = '  ';

z.string.uk.tooltipSearchClose = ' (Esc)';

z.string.uk.initReceivedSelfUser = ' {{user}}.';
z.string.uk.initValidatedClient = '    ';
z.string.uk.initReceivedUserData = '   ';
z.string.uk.initDecryption = ' ';
z.string.uk.initEvents = ' ';
z.string.uk.initUpdatedFromNotifications = '  -  !';
z.string.uk.initProgress = '  {{number1}}  {{number2}}';

z.string.uk.ephemeralUnitsNone = '';
z.string.uk.ephemeralUnitsSecond = '';
z.string.uk.ephemeralUnitsSeconds = '';
z.string.uk.ephemeralUnitsMinute = '';
z.string.uk.ephemeralUnitsMinutes = '';
z.string.uk.ephemeralUnitsHour = '';
z.string.uk.ephemeralUnitsHours = '';
z.string.uk.ephemeralUnitsDay = '';
z.string.uk.ephemeralUnitsDays = '';
z.string.uk.ephemeralUnitsWeek = '';
z.string.uk.ephemeralUnitsWeeks = '';
z.string.uk.ephemeralUnitsYear = '';
z.string.uk.ephemeralUnitsYears = '';
z.string.uk.ephemeralRemaining = '';

z.string.uk.replyAudioMessage = '';
z.string.uk.replyQuoteError = '     .';
z.string.uk.replyQuoteShowMore = '';
z.string.uk.replyQuoteShowLess = '';
z.string.uk.replyQuoteTimeStampDate = '   {{date}}';
z.string.uk.replyQuoteTimeStampTime = '   {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.string.wire = 'Wire';
z.string.wireMacos = 'Wire for macOS';
z.string.wireWindows = 'Wire for Windows';
z.string.wireLinux = 'Wire for Linux';
z.string.nonexistentUser = 'Deleted User';
z.string.and = 'and';
z.string.enumerationAnd = ', and ';

// Auth
// Authentication: ACCOUNT section
z.string.authAccountCountryCode = 'Country Code';
z.string.authAccountPasswordForgot = 'Forgot password';
z.string.authAccountPublicComputer = 'This is a public computer';
z.string.authAccountSignIn = 'Log in';
z.string.authAccountSignInPhone = 'Phone Log in';

// Authentication: BLOCKED section
z.string.authBlockedCookies = 'Enable cookies to log in to Wire.';
z.string.authBlockedDatabase = 'Wire needs access to local storage to display your messages. Local storage is not available in private mode.';
z.string.authBlockedTabs = 'Wire is already open in another tab.';
z.string.authBlockedTabsAction = 'Use this tab instead';

// Authentication: VERIFY section
z.string.authVerifyAccountAdd = 'Add';
z.string.authVerifyAccountDetail = 'This lets you use Wire on multiple devices.';
z.string.authVerifyAccountHeadline = 'Add email address and password.';
z.string.authVerifyAccountLogout = 'Log out';
z.string.authVerifyCodeDescription = 'Enter the verification code\nwe sent to {{number}}.';
z.string.authVerifyCodeResend = 'No code showing up?';
z.string.authVerifyCodeResendDetail = 'Resend';
z.string.authVerifyCodeResendTimer = 'You can request a new code {{expiration}}.';
z.string.authVerifyCodeChangePhone = 'Change phone number';
z.string.authVerifyPasswordHeadline = 'Enter your password';

// Authentication: LIMIT section
z.string.authLimitDevicesHeadline = 'Devices';
z.string.authLimitDescription = 'Remove one of your other devices to start using Wire on this one.';
z.string.authLimitButtonManage = 'Manage devices';
z.string.authLimitButtonSignOut = 'Log out';
z.string.authLimitDevicesCurrent = '(Current)';

// Authentication: HISTORY section
z.string.authHistoryHeadline = 'Its the first time youre using Wire on this device.';
z.string.authHistoryDescription = 'For privacy reasons, your conversation history will not appear here.';
z.string.authHistoryReuseHeadline = 'Youve used Wire on this device before.';
z.string.authHistoryReuseDescription = 'Messages sent in the meantime will not appear here.';
z.string.authHistoryButton = 'OK';

// Authentication: POSTED section
z.string.authPostedResend = 'Resend to {{email}}';
z.string.authPostedResendAction = 'No email showing up?';
z.string.authPostedResendDetail = 'Check your email inbox and follow the instructions.';
z.string.authPostedResendHeadline = 'Youve got mail.';

// Authentication: Misc
z.string.authPlaceholderEmail = 'Email';
z.string.authPlaceholderPasswordPut = 'Password';
z.string.authPlaceholderPasswordSet = 'Password (at least 8 characters)';
z.string.authPlaceholderPhone = 'Phone Number';

// Authentication: Validation errors
z.string.authErrorCode = 'Invalid Code';
z.string.authErrorCountryCodeInvalid = 'Invalid Country Code';
z.string.authErrorEmailExists = 'Email address already taken';
z.string.authErrorEmailForbidden = 'Sorry. This email address is forbidden.';
z.string.authErrorEmailMalformed = 'Please enter a valid email address.';
z.string.authErrorEmailMissing = 'Please enter an email address.';
z.string.authErrorMisc = 'Problems with the connection. Please try again.';
z.string.authErrorNameShort = 'Enter a name with at least 2 characters';
z.string.authErrorOffline = 'No Internet connection';
z.string.authErrorPasswordShort = 'Choose a password with at least 8 characters.';
z.string.authErrorPasswordWrong = 'Wrong password. Please try again.';
z.string.authErrorPending = 'Account is not yet verified';
z.string.authErrorPhoneNumberBudget = 'You logged in too often. Try again later.';
z.string.authErrorPhoneNumberForbidden = 'Sorry. This phone number is forbidden.';
z.string.authErrorPhoneNumberInvalid = 'Invalid Phone Number';
z.string.authErrorPhoneNumberUnknown = 'Unknown Phone Number';
z.string.authErrorSuspended = 'This account is no longer authorized to log in.';
z.string.authErrorSignIn = 'Please verify your details and try again.';

// Call stuff
z.string.callStateOutgoing = 'Ringing';
z.string.callStateConnecting = 'Connecting';
z.string.callStateIncoming = 'Calling';
z.string.callStateIncomingGroup = '{{user}} is calling';
z.string.callDecline = 'Decline';
z.string.callAccept = 'Accept';
z.string.callJoin = 'Join';
z.string.callChooseSharedScreen = 'Choose a screen to share';
z.string.callParticipants = '{{number}} on call';
z.string.callNoCameraAccess = 'No camera access';

z.string.videoCallOverlayFitVideoLabel = 'Double-click to fit or fill video to frame';
z.string.videoCallOverlayConversations = 'Conversations';
z.string.videoCallOverlayMute = 'Mute';
z.string.videoCallOverlayVideo = 'Video';
z.string.videoCallOverlayShareScreen = 'Share Screen';
z.string.videoCallOverlayHangUp = 'Hang Up';
z.string.videoCallPaused = 'Video paused';
z.string.videoCallScreenShareNotSupported = 'Screen sharing is not supported in this browser';

// Modals
// Modals type defaults
z.string.modalAcknowledgeAction = 'Ok';
z.string.modalAcknowledgeHeadline = 'Something went wrong';
z.string.modalConfirmSecondary = 'Cancel';
z.string.modalOptionSecondary = 'Cancel';

// Modals content
z.string.modalAccountCreateAction = 'OK';
z.string.modalAccountCreateHeadline = 'Create an account?';
z.string.modalAccountCreateMessage = 'By creating an account you will lose the conversation history in this guest room.';

z.string.modalAccountDeletionAction = 'Delete';
z.string.modalAccountDeletionHeadline = 'Delete account';
z.string.modalAccountDeletionMessage = 'We will send a message via email or SMS. Follow the link to permanently delete your account.';

z.string.modalAccountLeaveGuestRoomAction = 'Leave';
z.string.modalAccountLeaveGuestRoomHeadline = 'Leave the guest room?';
z.string.modalAccountLeaveGuestRoomMessage = 'Conversation history will be deleted. To keep it, create an account next time.';

z.string.modalAccountLogoutAction = 'Log out';
z.string.modalAccountLogoutHeadline = 'Clear Data?';
z.string.modalAccountLogoutOption = 'Delete all your personal information and conversations on this device.';

z.string.modalAccountNewDevicesSecondary = 'Manage devices';
z.string.modalAccountNewDevicesHeadline = 'Your account was used on:';
z.string.modalAccountNewDevicesFrom = 'From:';
z.string.modalAccountNewDevicesMessage = 'If you didnt do this, remove the device and reset your password.';

z.string.modalAccountRemoveDeviceAction = 'Remove device';
z.string.modalAccountRemoveDeviceHeadline = 'Remove "{{device}}"';
z.string.modalAccountRemoveDeviceMessage = 'Your password is required to remove the device.';
z.string.modalAccountRemoveDevicePlaceholder = 'Password';

z.string.modalAssetTooLargeHeadline = 'File too large';
z.string.modalAssetTooLargeMessage = 'You can send files up to {{number}}';

z.string.modalAssetParallelUploadsHeadline = 'Too many files at once';
z.string.modalAssetParallelUploadsMessage = 'You can send up to {{number}} files at once.';

z.string.modalCallEmptyConversationHeadline = 'No one to call';
z.string.modalCallEmptyConversationMessage = 'There is no one left here.';

z.string.modalCallEmptyLogHeadline = 'No calls';
z.string.modalCallEmptyLogMessage = 'There were no calls to base the debug report on.';

z.string.modalCallNoGroupVideoHeadline = 'No video calls in groups';
z.string.modalCallNoGroupVideoMessage = 'Video calls are not available in group conversations.';

z.string.modalCallNoMicrophoneAction = 'Tell me how';
z.string.modalCallNoMicrophoneMessage = 'Your browser needs access to the microphone to make calls.';
z.string.modalCallNoMicrophoneHeadline = 'Cant call without microphone';

z.string.modalCallSecondIncomingAction = 'Answer';
z.string.modalCallSecondIncomingHeadline = 'Answer call?';
z.string.modalCallSecondIncomingMessage = 'Your current call will end.';

z.string.modalCallSecondOngoingAction = 'Hang Up';
z.string.modalCallSecondOngoingHeadline = 'Hang up call on another device?';
z.string.modalCallSecondOngoingMessage = 'You can only be in one call at a time.';

z.string.modalCallSecondOutgoingAction = 'Call Anyway';
z.string.modalCallSecondOutgoingHeadline = 'Hang up current call?';
z.string.modalCallSecondOutgoingMessage = 'A call is active in another conversation. Calling here will hang up the other call.';

z.string.modalConnectCancelAction = 'Yes';
z.string.modalConnectCancelHeadline = 'Cancel Request?';
z.string.modalConnectCancelMessage = 'Remove connection request to {{user}}.';
z.string.modalConnectCancelSecondary = 'No';

z.string.modalConnectAcceptAction = 'Connect';
z.string.modalConnectAcceptHeadline = 'Accept?';
z.string.modalConnectAcceptMessage = 'This will connect you and open the conversation with {{user}}.';
z.string.modalConnectAcceptSecondary = 'Ignore';

z.string.modalConversationClearAction = 'Delete';
z.string.modalConversationClearHeadline = 'Delete content?';
z.string.modalConversationClearMessage = 'This will clear the conversation history on all your devices.';
z.string.modalConversationClearOption = 'Also leave the conversation';

z.string.modalConversationDeleteMessageAction = 'Delete';
z.string.modalConversationDeleteMessageHeadline = 'Delete only for me?';
z.string.modalConversationDeleteMessageMessage = 'This cannot be undone.';

z.string.modalConversationDeleteMessageEveryoneAction = 'Delete';
z.string.modalConversationDeleteMessageEveryoneHeadline = 'Delete for everyone?';
z.string.modalConversationDeleteMessageEveryoneMessage = 'This cannot be undone.';

z.string.modalConversationLeaveAction = 'Leave';
z.string.modalConversationLeaveHeadline = 'Leave {{name}} conversation?';
z.string.modalConversationLeaveMessage = 'You wont be able to send or receive messages in this conversation.';

z.string.modalConversationMessageTooLongHeadline = 'Message too long';
z.string.modalConversationMessageTooLongMessage = 'You can send messages up to {{number}} characters long.';

z.string.modalConversationNewDeviceAction = 'Send anyway';
z.string.modalConversationNewDeviceHeadlineOne = '{{user}} started using a new device';
z.string.modalConversationNewDeviceHeadlineMany = '{{users}} started using new devices';
z.string.modalConversationNewDeviceHeadlineYou = '{{user}} started using a new device';
z.string.modalConversationNewDeviceIncomingCallAction = 'Accept call';
z.string.modalConversationNewDeviceIncomingCallMessage = 'Do you still want to accept the call?';
z.string.modalConversationNewDeviceMessage = 'Do you still want to send your message?';
z.string.modalConversationNewDeviceOutgoingCallAction = 'Call anyway';
z.string.modalConversationNewDeviceOutgoingCallMessage = 'Do you still want to place the call?';

z.string.modalConversationNotConnectedHeadline = 'No one added to conversation';
z.string.modalConversationNotConnectedMessageOne = '{{name}} does not want to be added to conversations.';
z.string.modalConversationNotConnectedMessageMany = 'One of the people you selected does not want to be added to conversations.';

z.string.modalConversationRemoveAction = 'Remove';
z.string.modalConversationRemoveHeadline = 'Remove?';
z.string.modalConversationRemoveMessage = '{{user}} wont be able to send or receive messages in this conversation.';

z.string.modalConversationRemoveGuestsAction = 'Remove';
z.string.modalConversationRemoveGuestsHeadline = 'Disable access?';
z.string.modalConversationRemoveGuestsMessage = 'Current guests and services will be removed from the conversation. New guests and services will not be allowed.';

z.string.modalConversationRevokeLinkAction = 'Revoke link';
z.string.modalConversationRevokeLinkHeadline = 'Revoke the link?';
z.string.modalConversationRevokeLinkMessage = 'New guests will not be able to join with this link. Current guests will still have access.';

z.string.modalConversationGuestOptionsAllowGuestMessage = 'Could not allow guests and services. Please try again.';
z.string.modalConversationGuestOptionsDisableGuestMessage = 'Could not remove guests and services. Please try again.';
z.string.modalConversationGuestOptionsGetCodeMessage = 'Could not get access link.';
z.string.modalConversationGuestOptionsRequestCodeMessage = 'Could not request access link. Please try again.';
z.string.modalConversationGuestOptionsRevokeCodeMessage = 'Could not revoke access link. Please try again.';
z.string.modalConversationGuestOptionsToggleGuestsMessage = 'Could not change guests state.';

z.string.modalConversationTooManyMembersHeadline = 'The group is full';
z.string.modalConversationTooManyMembersMessage = 'Up to {{number1}} people can join a conversation. Currently there is only room for {{number2}} more.';

z.string.modalGifTooLargeHeadline = 'Selected animation is too large';
z.string.modalGifTooLargeMessage = 'Maximum size is {{number}} MB.';

z.string.modalIntegrationUnavailableHeadline = 'Bots currently unavailable';
z.string.modalIntegrationUnavailableMessage = 'Thank you for your interest in bots. The service is currently suspended while we work on the next version. Stay tuned.';

z.string.modalPictureFileFormatHeadline = 'Cant use this picture';
z.string.modalPictureFileFormatMessage = 'Please choose a PNG or JPEG file.';

z.string.modalPictureTooLargeHeadline = 'Selected picture is too large';
z.string.modalPictureTooLargeMessage = 'You can use pictures up to {{number}} MB.';

z.string.modalPictureTooSmallHeadline = 'Picture too small';
z.string.modalPictureTooSmallMessage = 'Please choose a picture that is at least 320 x 320 px.';

z.string.modalImproveWireAction = 'I Agree';
z.string.modalImproveWireSecondary = 'No';
z.string.modalImproveWireHeadline = 'Help us make Wire better';
z.string.modalImproveWireMessage = 'I agree that Wire may create and use anonymous usage and error reports to improve the Wire App. I can revoke this consent at any time.';

z.string.modalServiceUnavailableHeadline = 'Adding service not possible';
z.string.modalServiceUnavailableMessage = 'The service is unavailable at the moment.';

z.string.modalSessionResetHeadline = 'The session has been reset';
z.string.modalSessionResetMessage1 = 'If the problem is not resolved,';
z.string.modalSessionResetMessageLink = 'contact';
z.string.modalSessionResetMessage2 = 'us.';

z.string.modalUploadContactsAction = 'Try again';
z.string.modalUploadContactsMessage = 'We did not receive your information. Please try importing your contacts again.';

z.string.modalUserBlockAction = 'Block';
z.string.modalUserBlockHeadline = 'Block {{user}}?';
z.string.modalUserBlockMessage = '{{user}} wont be able to contact you or add you to group conversations.';

z.string.modalUserUnblockAction = 'Unblock';
z.string.modalUserUnblockHeadline = 'Unblock?';
z.string.modalUserUnblockMessage = '{{user}} will be able to contact you and add you to group conversations again.';

z.string.modalNoCameraTitle = 'No camera access';
z.string.modalNoCameraMessage = 'Wire doesnt have access to the camera.[br][faqLink]Read this support article[/faqLink] to find out how to fix it.';

// Connection requests
z.string.connectionRequestConnect = 'Connect';
z.string.connectionRequestIgnore = 'Ignore';

// Guests
z.string.conversationGuestIndicator = 'Guest';
z.string.userRemainingTimeHours = '{{time}}h left';
z.string.userRemainingTimeMinutes = 'Less than {{time}}m left';

// Conversation
z.string.conversationYouNominative = 'you';
z.string.conversationYouDative = 'you';
z.string.conversationYouAccusative = 'you';

z.string.conversationConnectionAccepted = 'Connected';
z.string.conversationConnectionBlocked = 'Blocked';
z.string.conversationConnectionCancelRequest = 'Cancel connection request';
z.string.conversationCreateTemporary = 'You joined the conversation';
z.string.conversationCreateWith = 'with {{users}}';
z.string.conversationDeviceStartedUsingOne = ' started using';
z.string.conversationDeviceStartedUsingMany = ' started using';
z.string.conversationDeviceUnverified = ' unverified one of';
z.string.conversationDeviceYourDevices = ' your devices';
z.string.conversationDeviceUserDevices = ' {{user}}s devices';
z.string.conversationDeviceNewDeviceOne = ' a new device';
z.string.conversationDeviceNewDeviceMany = ' new devices';
z.string.conversationDeviceNewPeopleJoined = 'New people joined.';
z.string.conversationDeviceNewPeopleJoinedVerify = 'Verify devices';
z.string.conversationJustNow = 'Just now';
z.string.conversationLocationLink = 'Open Map';
z.string.conversationCreated = '[bold]{{name}}[/bold] started a conversation with {{users}}';
z.string.conversationCreatedMore = '[bold]{{name}}[/bold] started a conversation with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreatedName = '[bold]{{name}}[/bold] started the conversation';
z.string.conversationCreatedNameYou = '[bold]You[/bold] started the conversation';
z.string.conversationCreatedYou = 'You started a conversation with {{users}}';
z.string.conversationCreatedYouMore = 'You started a conversation with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreateWithMore = 'with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreateTeam = 'with [showmore]all team members[/showmore]';
z.string.conversationCreateTeamGuest = 'with [showmore]all team members and one guest[/showmore]';
z.string.conversationCreateTeamGuests = 'with [showmore]all team members and {{count}} guests[/showmore]';
z.string.conversationMemberJoined = '[bold]{{name}}[/bold] added {{users}} to the conversation';
z.string.conversationMemberJoinedYou = '[bold]You[/bold] added {{users}} to the conversation';
z.string.conversationMemberJoinedMore = '[bold]{{name}}[/bold] added {{users}}, and [showmore]{{count}} more[/showmore] to the conversation';
z.string.conversationMemberJoinedYouMore = '[bold]You[/bold] added {{users}}, and [showmore]{{count}} more[/showmore] to the conversation';
z.string.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] joined';
z.string.conversationMemberJoinedSelfYou = '[bold]You[/bold] joined';
z.string.conversationMemberLeft = '[bold]{{name}}[/bold] left';
z.string.conversationMemberLeftYou = '[bold]You[/bold] left';
z.string.conversationMemberRemoved = '[bold]{{name}}[/bold] removed {{users}}';
z.string.conversationMemberRemovedYou = '[bold]You[/bold] removed {{users}}';
z.string.conversationTeamLeft = '[bold]{{name}}[/bold] was removed from the team';
z.string.conversationMessageDelivered = 'Delivered';
z.string.conversationRename = ' renamed the conversation';
z.string.conversationRenameYou = ' renamed the conversation';
z.string.conversationUpdatedTimer = ' set the message timer to {{time}}';
z.string.conversationUpdatedTimerYou = ' set the message timer to {{time}}';
z.string.conversationResetTimer = ' turned off the message timer';
z.string.conversationResetTimerYou = ' turned off the message timer';
z.string.conversationResume = 'Start a conversation with {{users}}';
z.string.conversationPing = ' pinged';
z.string.conversationPingYou = ' pinged';
z.string.conversationToday = 'today';
z.string.conversationVoiceChannelDeactivate = ' called';
z.string.conversationVoiceChannelDeactivateYou = ' called';
z.string.conversationYesterday = 'Yesterday';
z.string.conversationUnableToDecrypt1 = 'A message from [highlight]{{user}}[/highlight] was not received.';
z.string.conversationUnableToDecrypt2 = '[highlight]{{user}}[/highlight]s device identity changed. Undelivered message.';
z.string.conversationUnableToDecryptLink = 'Why?';
z.string.conversationUnableToDecryptErrorMessage = 'Error';
z.string.conversationUnableToDecryptResetSession = 'Reset session';
z.string.conversationMissedMessages = 'You havent used this device for a while. Some messages may not appear here.';
z.string.conversationAssetUploading = 'Uploading';
z.string.conversationAssetDownloading = 'Downloading';
z.string.conversationAssetUploadFailed = 'Upload Failed';
z.string.conversationPlaybackError = 'Unable to play';
z.string.conversationContextMenuCopy = 'Copy';
z.string.conversationContextMenuEdit = 'Edit';
z.string.conversationContextMenuDelete = 'Delete for Me';
z.string.conversationContextMenuDeleteEveryone = 'Delete for Everyone';
z.string.conversationContextMenuDownload = 'Download';
z.string.conversationContextMenuLike = 'Like';
z.string.conversationContextMenuReply = 'Reply';
z.string.conversationContextMenuUnlike = 'Unlike';
z.string.conversationDeleteTimestamp = 'Deleted: {{date}}';
z.string.conversationEditTimestamp = 'Edited: {{date}}';
z.string.conversationLikesCaption = '{{number}} people';
z.string.conversationSendPastedFile = 'Pasted image at {{date}}';
z.string.conversationSomeone = 'Someone';
z.string.conversationTweetAuthor = ' on Twitter';
z.string.conversationServicesWarning = 'Services have access to the content of this conversation';

// Group creation
z.string.groupCreationPreferencesAction = 'Next';
z.string.groupCreationPreferencesErrorNameShort = 'At least 1 character';
z.string.groupCreationPreferencesErrorNameLong = 'Too many characters';
z.string.groupCreationPreferencesHeader = 'Create group';
z.string.groupCreationPreferencesPlaceholder = 'Group name';
z.string.groupCreationParticipantsActionCreate = 'Done';
z.string.groupCreationParticipantsActionSkip = 'Skip';
z.string.groupCreationParticipantsHeader = 'Add people';
z.string.groupCreationParticipantsHeaderWithCounter = 'Add people ({{number}})';
z.string.groupCreationParticipantsPlaceholder = 'Search by name';
z.string.groupSizeInfo = 'Up to {{count}} people can join a group conversation. Video calls work with up to 3 other people and you.';

// Guest room
z.string.guestRoomConversationName = 'Guest room';
z.string.guestRoomToggleName = 'Allow guests and services';
z.string.guestRoomToggleInfo = 'Open this conversation to services and people outside your team.';
z.string.guestRoomToggleInfoExtended = 'Open this conversation to services and people outside your team. You can always change it later.';

z.string.guestRoomConversationBadge = 'Guests are present';
z.string.guestRoomConversationBadgeService = 'Services are active';
z.string.guestRoomConversationBadgeGuestAndService = 'Guests and services are present';

z.string.guestRoomConversationHead = 'People outside your team can join this conversation.';
z.string.guestRoomConversationButton = 'Invite people';

// Collection
z.string.collectionShowAll = 'Show all {{number}}';
z.string.collectionSectionLinks = 'Links';
z.string.collectionSectionImages = 'Pictures';
z.string.collectionSectionFiles = 'Files';
z.string.collectionSectionAudio = 'Audio messages';

// Full Search
z.string.fullsearchPlaceholder = 'Search text messages';
z.string.fullsearchNoResults = 'No results.';

// Archive
z.string.archiveHeader = 'Archive';

// Conversations
z.string.conversationsAllArchived = 'Everything archived';
z.string.conversationsContacts = 'Contacts';
z.string.conversationsConnectionRequestMany = '{{number}} people waiting';
z.string.conversationsConnectionRequestOne = '1 person waiting';
z.string.conversationsEmptyConversation = 'Group conversation';
z.string.conversationsNoConversations = 'Start a conversation or create a group.';
z.string.conversationsPopoverArchive = 'Archive';
z.string.conversationsPopoverBlock = 'Block';
z.string.conversationsPopoverCancel = 'Cancel request';
z.string.conversationsPopoverClear = 'Delete content';
z.string.conversationsPopoverLeave = 'Leave group';
z.string.conversationsPopoverNotificationSettings = 'Notifications';
z.string.conversationsPopoverNotify = 'Unmute';
z.string.conversationsPopoverSilence = 'Mute';
z.string.conversationsPopoverUnarchive = 'Unarchive';

// Conversations secondary line
z.string.conversationsSecondaryLineEphemeralMention = 'Mentioned you';
z.string.conversationsSecondaryLineEphemeralMentionGroup = 'Someone mentioned you';
z.string.conversationsSecondaryLineEphemeralMessage = 'Sent a message';
z.string.conversationsSecondaryLineEphemeralMessageGroup = 'Someone sent a message';
z.string.conversationsSecondaryLineEphemeralReply = 'Replied to you';
z.string.conversationsSecondaryLineEphemeralReplyGroup = 'Someone replied to you';
z.string.conversationsSecondaryLineIncomingCall = '{{user}} is calling';
z.string.conversationsSecondaryLinePeopleLeft = '{{number}} people left';
z.string.conversationsSecondaryLinePersonLeft = '{{user}} left';
z.string.conversationsSecondaryLinePersonRemoved = '{{user}} was removed';
z.string.conversationsSecondaryLinePersonRemovedTeam = '{{user}} was removed from the team';
z.string.conversationsSecondaryLinePeopleAdded = '{{user}} people were added';
z.string.conversationsSecondaryLinePersonAdded = '{{user}} was added';
z.string.conversationsSecondaryLinePersonAddedSelf = '{{user}} joined';
z.string.conversationsSecondaryLinePersonAddedYou = '{{user}} added you';
z.string.conversationsSecondaryLineRenamed = '{{user}} renamed conversation';
z.string.conversationsSecondaryLineSummaryMessage = '{{number}} message';
z.string.conversationsSecondaryLineSummaryMessages = '{{number}} messages';
z.string.conversationsSecondaryLineSummaryMention = '{{number}} mention';
z.string.conversationsSecondaryLineSummaryMentions = '{{number}} mentions';
z.string.conversationsSecondaryLineSummaryMissedCall = '{{number}} missed call';
z.string.conversationsSecondaryLineSummaryMissedCalls = '{{number}} missed calls';
z.string.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.conversationsSecondaryLineSummaryPings = '{{number}} pings'
z.string.conversationsSecondaryLineSummaryReply = '{{number}} reply';
z.string.conversationsSecondaryLineSummaryReplies = '{{number}} replies';
z.string.conversationsSecondaryLineYouLeft = 'You left';
z.string.conversationsSecondaryLineYouWereRemoved = 'You were removed';

// Takeover
z.string.takeoverSub = 'Claim your unique name on Wire.';
z.string.takeoverLink = 'Learn more';
z.string.takeoverButtonChoose = 'Choose your own';
z.string.takeoverButtonKeep = 'Keep this one';

// Invites
z.string.inviteMetaKeyMac = 'Cmd';
z.string.inviteMetaKeyPc = 'Ctrl';
z.string.inviteHintSelected = 'Press {{metaKey}} + C to copy';
z.string.inviteHintUnselected = 'Select and Press {{metaKey}} + C';
z.string.inviteHeadline = 'Invite people to Wire';
z.string.inviteMessage = 'Im on Wire, search for {{username}} or visit get.wire.com.';
z.string.inviteMessageNoEmail = 'Im on Wire. Visit get.wire.com to connect with me.';

// Extensions
z.string.extensionsBubbleButtonGif = 'Gif';

// Extensions Giphy
z.string.extensionsGiphyButtonOk = 'Send';
z.string.extensionsGiphyButtonMore = 'Try Another';
z.string.extensionsGiphyMessage = '{{tag}}  via giphy.com';
z.string.extensionsGiphyNoGifs = 'Oops, no gifs';
z.string.extensionsGiphyRandom = 'Random';

// Panel
// Panel: Add participants
z.string.addParticipantsConfirmLabel = 'Add';
z.string.addParticipantsHeader = 'Add participants';
z.string.addParticipantsHeaderWithCounter = 'Add participants ({{number}})';
z.string.addParticipantsManageServices = 'Manage services';
z.string.addParticipantsManageServicesNoResults = 'Manage services';
z.string.addParticipantsNoServicesManager = 'Services are helpers that can improve your workflow.';
z.string.addParticipantsNoServicesMember = 'Services are helpers that can improve your workflow. To enable them, ask your administrator.';
z.string.addParticipantsSearchPlaceholder = 'Search by name';
z.string.addParticipantsServiceConfirmButton = 'Add service';
z.string.addParticipantsTabsPeople = 'People';
z.string.addParticipantsTabsServices = 'Services';

// Panel: Conversation details
z.string.conversationDetailsActionArchive = 'Archive';
z.string.conversationDetailsActionAddParticipants = 'Add participants';
z.string.conversationDetailsActionBlock = 'Block';
z.string.conversationDetailsActionCancelRequest = 'Cancel request';
z.string.conversationDetailsActionClear = 'Delete content';
z.string.conversationDetailsActionConversationParticipants = 'Show all ({{number}})';
z.string.conversationDetailsActionCreateGroup = 'Create group';
z.string.conversationDetailsActionDevices = 'Devices';
z.string.conversationDetailsActionGuestOptions = 'Guests and services';
z.string.conversationDetailsActionTimedMessages = 'Timed messages';
z.string.conversationDetailsActionNotifications = 'Notifications';
z.string.conversationDetailsActionLeave = 'Leave group';
z.string.conversationDetailsGuestsOff = 'Off';
z.string.conversationDetailsGuestsOn = 'On';
z.string.conversationDetailsOptions = 'Options';
z.string.conversationDetailsParticipantsServicesOne = 'Service';
z.string.conversationDetailsParticipantsServicesMany = 'Services';
z.string.conversationDetailsParticipantsUsersOne = 'Person';
z.string.conversationDetailsParticipantsUsersMany = 'People';
z.string.conversationDetailsPeople = 'People';
z.string.conversationDetailsServices = 'Services';

// Panel: Conversation participants
z.string.conversationParticipantsTitle = 'People';
z.string.conversationParticipantsSearchPlaceholder = 'Search by name';

// Panel: Group participant
z.string.groupParticipantActionBlock = 'Block';
z.string.groupParticipantActionCancelRequest = 'Cancel request';
z.string.groupParticipantActionDevices = 'Devices';
z.string.groupParticipantActionIgnoreRequest = 'Ignore request';
z.string.groupParticipantActionIncomingRequest = 'Accept request';
z.string.groupParticipantActionLeave = 'Leave group';
z.string.groupParticipantActionOpenConversation = 'Open conversation';
z.string.groupParticipantActionPending = 'Pending';
z.string.groupParticipantActionRemove = 'Remove from group';
z.string.groupParticipantActionSelfProfile = 'Open profile';
z.string.groupParticipantActionSendRequest = 'Connect';
z.string.groupParticipantActionUnblock = 'Unblock';

// Panel: Guest options
z.string.guestOptionsCopyLink = 'Copy link';
z.string.guestOptionsCopyLinkDone = 'Link copied!';
z.string.guestOptionsCreateLink = 'Create link';
z.string.guestOptionsInfoHeader = 'Invite others with a link';
z.string.guestOptionsInfoText = 'Anyone with the link can join the conversation, even if they dont have Wire.';
z.string.guestOptionsRevokeLink = 'Revoke link';
z.string.guestOptionsTitle = 'Guests and services';

// Panel: Notifications
z.string.notificationSettingsTitle = 'Notifications';
z.string.notificationSettingsDisclaimer = 'You can be notified about everything (including audio and video calls) or only when someone mentions you or replies to one of your messages.';
z.string.notificationSettingsEverything = 'Everything';
z.string.notificationSettingsMentionsAndReplies = 'Mentions and replies';
z.string.notificationSettingsNothing = 'Nothing';

// Panel: Timed messages
z.string.timedMessagesTitle = 'Timed messages';
z.string.timedMessageDisclaimer = 'Timed messages will be turned on for all the participants in this conversation.';

// Panel: Participant devices
z.string.participantDevicesDetailHeadline = 'Verify that this matches the fingerprint shown on {{html1}}{{user}}s device{{html2}}.';
z.string.participantDevicesDetailHowTo = 'How do I do that?';
z.string.participantDevicesDetailResetSession = 'Reset session';
z.string.participantDevicesDetailShowMyDevice = 'Show my device fingerprint';
z.string.participantDevicesDetailVerify = 'Verified';

z.string.participantDevicesHeader = 'Devices';
z.string.participantDevicesHeadline = 'Wire gives every device a unique fingerprint. Compare them with {{user}} and verify your conversation.';
z.string.participantDevicesLearnMore = 'Learn more';
z.string.participantDevicesWhyVerify = 'Why verify conversations?';
z.string.participantDevicesOutdatedClientMessage = '{{user}} is using an old version of Wire. No devices are shown here.';

z.string.participantDevicesSelfAllDevices = 'Show all my devices';
z.string.participantDevicesSelfFingerprint = 'Device fingerprint';

// User profile actions
z.string.userProfileButtonConnect = 'Connect';
z.string.userProfileButtonIgnore = 'Ignore';
z.string.userProfileButtonUnblock = 'Unblock';

// Settings
z.string.preferencesAbout = 'About';
z.string.preferencesAccount = 'Account';
z.string.preferencesAV = 'Audio / Video';
z.string.preferencesDeviceDetails = 'Device Details';
z.string.preferencesDevices = 'Devices';
z.string.preferencesHeadline = 'Preferences';
z.string.preferencesOptions = 'Options';

z.string.preferencesAboutCopyright = ' Wire Swiss GmbH';
z.string.preferencesAboutPrivacyPolicy = 'Privacy policy';
z.string.preferencesAboutSupport = 'Support';
z.string.preferencesAboutSupportWebsite = 'Support website';
z.string.preferencesAboutSupportContact = 'Contact Support';
z.string.preferencesAboutTermsOfUse = 'Terms of use';
z.string.preferencesAboutVersion = 'Version {{version}}';
z.string.preferencesAboutWebsite = 'Wire website';

z.string.preferencesAccountAvaibilityUnset = 'Set a status';
z.string.preferencesAccountCreateTeam = 'Create a team';
z.string.preferencesAccountData = 'Data usage permissions';
z.string.preferencesAccountDataCheckbox = 'Send anonymous data';
z.string.preferencesAccountDataDetail = 'Help make Wire better by sending anonymous usage and crash reports.';
z.string.preferencesAccountDelete = 'Delete account';
z.string.preferencesAccountLeaveGuestRoom = 'Leave the guest room';
z.string.preferencesAccountLeaveGuestRoomDescription = 'You will no longer be able to access the messages in this conversation.';
z.string.preferencesAccountLogOut = 'Log out';
z.string.preferencesAccountManageTeam = 'Manage team';
z.string.preferencesAccountMarketingConsentCheckbox = 'Receive newsletter';
z.string.preferencesAccountMarketingConsentDetail = 'Receive news and product updates from Wire via email.';
z.string.preferencesAccountResetPassword = 'Reset password';
z.string.preferencesAccountTeam = 'in {{name}}';
z.string.preferencesAccountUsernamePlaceholder = 'Your full name';
z.string.preferencesAccountUsernameHint = 'At least 2 characters. az, 09 and _ only.';
z.string.preferencesAccountUsernameAvailable = 'Available';
z.string.preferencesAccountUsernameErrorTaken = 'Already taken';

z.string.preferencesAVCamera = 'Camera';
z.string.preferencesAVMicrophone = 'Microphone';
z.string.preferencesAVPermissionDetail = 'Enable from your browser Preferences';
z.string.preferencesAVSpeakers = 'Speakers';
z.string.preferencesAVTemporaryDisclaimer = 'Guests cant start video conferences. Select the camera to use if you join one.';
z.string.preferencesAVNoCamera = 'Wire doesnt have access to the camera.[br][faqLink]Read this support article[/faqLink] to find out how to fix it.';
z.string.preferencesAVTryAgain= 'Try Again';

z.string.preferencesDevicesActivatedOn = 'Activated {{date}}';
z.string.preferencesDevicesActive = 'Active';
z.string.preferencesDevicesActiveDetail = 'If you dont recognize a device above, remove it and reset your password.';
z.string.preferencesDevicesCurrent = 'Current';
z.string.preferencesDevicesFingerprint = 'Key fingerprint';
z.string.preferencesDevicesFingerprintDetail = 'Wire gives every device a unique fingerprint. Compare them and verify your devices and conversations.';
z.string.preferencesDevicesId = 'ID: ';
z.string.preferencesDevicesRemove = 'Remove';
z.string.preferencesDevicesRemoveCancel = 'Cancel';
z.string.preferencesDevicesRemoveDetail = 'Remove this device if you have stopped using it. You will be logged out of this device immediately.';
z.string.preferencesDevicesSessionConfirmation = 'The session has been reset.';
z.string.preferencesDevicesSessionDetail = 'If fingerprints dont match, reset the session to generate new encryption keys on both sides.';
z.string.preferencesDevicesSessionReset = 'Reset session';
z.string.preferencesDevicesSessionOngoing = 'Resetting session';
z.string.preferencesDevicesVerification = 'Verified';

z.string.preferencesOptionsAudio = 'Sound alerts';
z.string.preferencesOptionsAudioAll = 'All';
z.string.preferencesOptionsAudioAllDetail = 'All sounds';
z.string.preferencesOptionsAudioNone = 'None';
z.string.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.preferencesOptionsAudioSome = 'Some';
z.string.preferencesOptionsAudioSomeDetail = 'Pings and calls';
z.string.preferencesOptionsContacts = 'Contacts';
z.string.preferencesOptionsContactsMacos = 'Import from Contacts';
z.string.preferencesOptionsContactsDetail = 'We use your contact data to connect you with others. We anonymize all information and do not share it with anyone else.';
z.string.preferencesOptionsPopular = 'By popular demand';
z.string.preferencesOptionsEmojiReplaceCheckbox = 'Replace type emoticons with emojis';
z.string.preferencesOptionsEmojiReplaceDetail = ':-)  [icon]';
z.string.preferencesOptionsPreviewsSendCheckbox = 'Create previews for links you send';
z.string.preferencesOptionsPreviewsSendDetail = 'Previews may still be shown for links from other people.';
z.string.preferencesOptionsNotifications = 'Notifications';
z.string.preferencesOptionsNotificationsNone = 'Off';
z.string.preferencesOptionsNotificationsObfuscate = 'Hide details';
z.string.preferencesOptionsNotificationsObfuscateMessage = 'Show sender';
z.string.preferencesOptionsNotificationsOn = 'Show sender and message';
z.string.preferencesOptionsCallLogs = 'Troubleshooting';
z.string.preferencesOptionsCallLogsGet = 'Save the calling debug report';
z.string.preferencesOptionsCallLogsDetail = 'This information helps Wire Support diagnose calling problems.';

z.string.preferencesOptionsBackupHeader = 'History';
z.string.preferencesOptionsBackupExportHeadline = 'Back up conversations';
z.string.preferencesOptionsBackupExportSecondary = 'Create a backup to preserve your conversation history. You can use this to restore history if you lose your computer or switch to a new one.\nThe backup file is not protected by Wire end-to-end encryption, so store it in a safe place.';
z.string.preferencesOptionsBackupImportHeadline = 'Restore from backup';
z.string.preferencesOptionsBackupImportSecondary = 'You can only restore history from a backup of the same platform. Your backup will overwrite the conversations that you may have on this device.';

// History Backup
z.string.backupExportGenericErrorHeadline = 'The file could not be saved';
z.string.backupExportGenericErrorSecondary = 'The backup was not completed.';
z.string.backupExportProgressHeadline = 'Preparing';
z.string.backupExportProgressSecondary = 'Backing up  {{processed}} of {{total}}  {{progress}}%';
z.string.backupExportProgressCompressing = 'Preparing backup file';
z.string.backupExportSaveFileAction = 'Save file';
z.string.backupExportSuccessHeadline = 'Backup ready';
z.string.backupExportSuccessSecondary = 'You can use this to restore history if you lose your computer or switch to a new one.';
z.string.backupImportGenericErrorHeadline = 'Something went wrong';
z.string.backupImportGenericErrorSecondary = 'Your history could not be restored.';
z.string.backupImportAccountErrorHeadline = 'Wrong backup';
z.string.backupImportAccountErrorSecondary = 'You cannot restore history from a different account.';
z.string.backupImportVersionErrorHeadline = 'Incompatible backup';
z.string.backupImportVersionErrorSecondary = 'This backup was created by a newer or outdated version of Wire and cannot be restored here.';
z.string.backupImportIncompatibleErrorHeadline = 'Wrong backup';
z.string.backupImportIncompatibleErrorSecondary = 'You cannot restore history from a different account.';
z.string.backupImportOutdatedErrorHeadline = 'Incompatible backup';
z.string.backupImportOutdatedErrorSecondary = 'This backup was created by a newer or outdated version of Wire and cannot be restored here.';
z.string.backupImportProgressHeadline = 'Preparing';
z.string.backupImportProgressSecondary = 'Restoring history  {{processed}} of {{total}}  {{progress}}%';
z.string.backupImportSuccessHeadline = 'History restored.';
z.string.backupCancel = 'Cancel';
z.string.backupTryAgain = 'Try Again';

// Search
z.string.searchConnect = 'Connect';
z.string.searchConnections = 'Connections';
z.string.searchContacts = 'Contacts';
z.string.searchCreateGroup = 'Create group';
z.string.searchCreateGuestRoom = 'Create guest room';
z.string.searchGroups = 'Groups';
z.string.searchPeople = 'People';
z.string.searchPlaceholder = 'Search by name or username';
z.string.searchServicePlaceholder = 'Search by name';
z.string.searchServices = 'Services';
z.string.searchManageServices = 'Manage Services';
z.string.searchManageServicesNoResults = 'Manage services';
z.string.searchNoServicesManager = 'Services are helpers that can improve your workflow.';
z.string.searchNoServicesMember = 'Services are helpers that can improve your workflow. To enable them, ask your administrator.';
z.string.searchTeamGroups = 'Team conversations';
z.string.searchTeamMembers = 'Team members';
z.string.searchTopPeople = 'Top people';
z.string.searchTrySearch = 'Find people by\nname or username';
z.string.searchNoContactsOnWire = 'You have no contacts on Wire.\nTry finding people by\nname or username.';
z.string.searchMemberInvite = 'Invite people to join the team';
z.string.searchOthers = 'Connect';

z.string.searchInvite = 'Invite people to join Wire';
z.string.searchInviteDetail = 'Sharing your contacts helps you connect with others. We anonymize all the information and do not share it with anyone else.';
z.string.searchInviteButtonContacts = 'From Contacts';
z.string.searchInviteHeadline = 'Bring your friends';
z.string.searchInviteShare = 'Share Contacts';

z.string.searchServiceConfirmButton = 'Open Conversation';

// Search list: User list & service list components
z.string.searchListEveryoneParticipates = 'Everyone youre\nconnected to is already in\nthis conversation.';
z.string.searchListNoMatches = 'No matching results.\nTry entering a different name.';

// Temporary guest experience
z.string.temporaryGuestCta = 'Create an account';
z.string.temporaryGuestDescription = 'Secure your business with encrypted group messaging and conference calls.';
z.string.temporaryGuestTimeRemaining = ' left in this guest room';

z.string.temporaryGuestJoinMessage = 'This conversation will be available to you for 24 hours.';
z.string.temporaryGuestJoinDescription = 'If you close or refresh this page, you will lose access.';

z.string.temporaryGuestLeaveMessage = ' are no longer part of this conversation.';
z.string.temporaryGuestLeaveDescription = 'If you close or refresh this page, you will lose access to the conversation history.';

// URLs & Warnings: Permission requests & permission callbacks
z.string.urlSupportRoot = '/';
z.string.urlSupportArticles = '/hc/en-us/articles/';
z.string.urlSupportRequests = '/hc/en-us/requests/';
z.string.urlWebappRoot = '/';
z.string.urlWebsiteRoot = '/';
z.string.urlWebsiteCreateTeam = '/create-team/';
z.string.urlWebsitePrivacy = '/privacy';
z.string.warningCallUnsupportedIncoming = '{{user}} is calling. Your browser doesnt support calls.';
z.string.warningCallUnsupportedOutgoing = 'You cannot call because your browser doesnt support calls.';
z.string.warningCallIssues = 'This version of Wire can not participate in the call. Please use';
z.string.warningCallUpgradeBrowser = 'To call, please update Google Chrome.';
z.string.warningConnectivityConnectionLost = 'Trying to connect. Wire may not be able to deliver messages.';
z.string.warningConnectivityNoInternet = 'No Internet. You wont be able to send or receive messages.';
z.string.warningLearnMore = 'Learn more';
z.string.warningLifecycleUpdate = 'A new version of Wire is available.';
z.string.warningLifecycleUpdateNotes = 'Whats new';
z.string.warningLifecycleUpdateLink = 'Update now';
z.string.warningNotFoundCamera = 'You cannot call because your computer does not have a camera.';
z.string.warningNotFoundMicrophone = 'You cannot call because your computer does not have a microphone.';
z.string.warningPermissionDeniedCamera = 'You cannot call because your browser does not have access to the camera.';
z.string.warningPermissionDeniedMicrophone = 'You cannot call because your browser does not have access to the microphone.';
z.string.warningPermissionDeniedScreen = 'Your browser needs permission to share your screen.';
z.string.warningPermissionRequestCamera = '[icon] Allow access to camera';
z.string.warningPermissionRequestMicrophone = '[icon] Allow access to microphone';
z.string.warningPermissionRequestNotification = '[icon] Allow notifications';
z.string.warningPermissionRequestScreen = '[icon] Allow access to screen';

// User Availability
z.string.userAvailabilityAvailable = 'Available';
z.string.userAvailabilityAway = 'Away';
z.string.userAvailabilityBusy = 'Busy';
z.string.userAvailabilityNone = 'None';

// Browser notifications
z.string.notificationAssetAdd = 'Shared a picture';
z.string.notificationConnectionAccepted = 'Accepted your connection request';
z.string.notificationConnectionConnected = 'You are now connected';
z.string.notificationConnectionRequest = 'Wants to connect';
z.string.notificationConversationCreate = '{{user}} started a conversation';
z.string.notificationConversationMessageTimerUpdate = '{{user}} set the message timer to {{time}}';
z.string.notificationConversationMessageTimerReset = '{{user}} turned off the message timer';
z.string.notificationConversationRename = '{{user}} renamed the conversation to {{name}}';
z.string.notificationMemberJoinMany = '{{user}} added {{number}} people to the conversation';
z.string.notificationMemberJoinSelf = '{{user}} joined the conversation';
z.string.notificationMemberJoinOne = '{{user1}} added {{user2}} to the conversation';
z.string.notificationMemberLeaveRemovedYou = '{{user}} removed you from the conversation';
z.string.notificationMention = 'Mention: {{text}}';
z.string.notificationObfuscated = 'Sent a message';
z.string.notificationObfuscatedMention = 'Mentioned you';
z.string.notificationObfuscatedReply = 'Replied to you';
z.string.notificationObfuscatedTitle = 'Someone';
z.string.notificationPing = 'Pinged';
z.string.notificationReaction = '{{reaction}} your message';
z.string.notificationReply = 'Reply: {{text}}';
z.string.notificationSharedAudio = 'Shared an audio message';
z.string.notificationSharedFile = 'Shared a file';
z.string.notificationSharedLocation = 'Shared a location';
z.string.notificationSharedVideo = 'Shared a video';
z.string.notificationTitleGroup = '{{user}} in {{conversation}}';
z.string.notificationVoiceChannelActivate = 'Calling';
z.string.notificationVoiceChannelDeactivate = 'Called';

// Tooltips
z.string.tooltipConversationAllVerified = 'All fingerprints are verified';
z.string.tooltipConversationCall = 'Call';
z.string.tooltipConversationEphemeral = 'Timed message';
z.string.tooltipConversationFile = 'Add file';
z.string.tooltipConversationInputPlaceholder = 'Type a message';
z.string.tooltipConversationInputPlaceholderAvailable = '{{user}} is available';
z.string.tooltipConversationInputPlaceholderAway = '{{user}} is away';
z.string.tooltipConversationInputPlaceholderBusy = '{{user}} is busy';
z.string.tooltipConversationPeople = 'People ({{shortcut}})';
z.string.tooltipConversationPicture = 'Add picture';
z.string.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.tooltipConversationSearch = 'Search';
z.string.tooltipConversationVideoCall = 'Video Call';

z.string.tooltipConversationsArchive = 'Archive ({{shortcut}})';
z.string.tooltipConversationsArchived = 'Show archive ({{number}})';
z.string.tooltipConversationsMore = 'More';
z.string.tooltipConversationsNotifications = 'Open notification settings ({{shortcut}})';
z.string.tooltipConversationsNotify = 'Unmute ({{shortcut}})';
z.string.tooltipConversationsPreferences = 'Open preferences';
z.string.tooltipConversationsSilence = 'Mute ({{shortcut}})';
z.string.tooltipConversationsStart = 'Start conversation ({{shortcut}})';

z.string.tooltipConversationDetailsAddPeople = 'Add participants to conversation ({{shortcut}})';
z.string.tooltipConversationDetailsRename = 'Change conversation name';

z.string.tooltipPreferencesContactsMacos = 'Share all your contacts from the macOS Contacts app';
z.string.tooltipPreferencesPassword = 'Open another website to reset your password';
z.string.tooltipPreferencesPicture = 'Change your picture';
z.string.tooltipPreferencesRename = 'Change your name';

z.string.tooltipSearchClose = 'Close (Esc)';

// App loading
z.string.initReceivedSelfUser = 'Hello, {{user}}.';
z.string.initValidatedClient = 'Fetching your connections and conversations';
z.string.initReceivedUserData = 'Checking for new messages';
z.string.initDecryption = 'Decrypting messages';
z.string.initEvents = 'Loading messages';
z.string.initUpdatedFromNotifications = 'Almost done - Enjoy Wire';
z.string.initProgress = '  {{number1}} of {{number2}}';

z.string.ephemeralUnitsNone = 'Off';
z.string.ephemeralUnitsSecond = 'second';
z.string.ephemeralUnitsSeconds = 'seconds';
z.string.ephemeralUnitsMinute = 'minute';
z.string.ephemeralUnitsMinutes = 'minutes';
z.string.ephemeralUnitsHour = 'hour';
z.string.ephemeralUnitsHours = 'hours';
z.string.ephemeralUnitsDay = 'day';
z.string.ephemeralUnitsDays = 'days';
z.string.ephemeralUnitsWeek = 'week';
z.string.ephemeralUnitsWeeks = 'weeks';
z.string.ephemeralUnitsYear = 'year';
z.string.ephemeralUnitsYears = 'years';
z.string.ephemeralRemaining = 'remaining';

// Replies
z.string.replyAudioMessage = 'Audio Message';
z.string.replyQuoteError = 'You cannot see this message.';
z.string.replyQuoteShowMore = 'Show more';
z.string.replyQuoteShowLess = 'Show less';
z.string.replyQuoteTimeStampDate = 'Original message from {{date}}';
z.string.replyQuoteTimeStampTime = 'Original message from {{time}}'

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
z.localization = z.localization || {};

class Localizer {
  constructor() {
    const DEFAULT_LOCALE = 'en';
    const queryParam = z.util.URLUtil.getParameter(z.auth.URLParameter.LOCALE);
    const currentBrowserLocale = navigator.language.substr(0, 2);
    let storedLocale = z.util.StorageUtil.getValue(z.storage.StorageKey.LOCALIZATION.LOCALE);

    if (queryParam) {
      storedLocale = z.util.StorageUtil.setValue(z.storage.StorageKey.LOCALIZATION.LOCALE, queryParam);
    }

    this.locale = storedLocale || currentBrowserLocale || DEFAULT_LOCALE;

    document.getElementsByTagName('html')[0].setAttribute('lang', this.locale);

    moment.locale([this.locale, DEFAULT_LOCALE]);

    if (z.string[this.locale]) {
      Object.assign(z.string, z.string[this.locale]);
    }
  }
}

z.localization.Localizer = new Localizer();

z.l10n = (() => {
  const isStringOrNumber = toTest => _.isString(toTest) || _.isNumber(toTest);

  const replaceSubstitute = (string, regex, substitute) => {
    const replacement = isStringOrNumber(substitute)
      ? substitute
      : (found, content) => (substitute.hasOwnProperty(content) ? substitute[content] : found);
    return string.replace(regex, replacement);
  };

  return {
    safeHtml(value, substitutions = {}) {
      const replace = isStringOrNumber(substitutions) ? substitutions : substitutions.replace;

      const defaultReplacements = {
        '/bold': '</b>',
        '/italic': '</i>',
        bold: '<b>',
        italic: '<i>',
      };

      const replaceDangerously = Object.assign({}, defaultReplacements, substitutions.replaceDangerously);

      let string = ko.unwrap(value);

      if (replace !== undefined) {
        string = replaceSubstitute(string, /{{(.+?)}}/g, replace);
      }

      string = z.util.SanitizationUtil.escapeString(string);

      string = replaceSubstitute(string, /\[(.+?)\]/g, replaceDangerously);

      return string;
    },

    /**
     * Retrieve localized string and replace placeholders
     *
     * This method give you two options to replace placeholders
     *
     * @example using a string as substitute
     * z.l10.text('Hey {{name}}', 'Tod') // returns 'Hey Tod'
     *
     * @example using an object as substitute
     * z.l10.text('{{greeting}} {{name}}', {name: 'Tod', greeting: 'Hey') // returns 'Hey Tod'
     *
     * @param {Observable|string} value - localized string in our case usually z.string.foo
     * @param {string|Object} [substitute] - data to fill all the placeholder with
     * @returns {string} - string with substituted placeholders
     */
    text: (value, substitute) => replaceSubstitute(ko.unwrap(value), /{{(.+?)}}/g, substitute),
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.ConversationType = {
  GROUP: 'group',
  ONE_TO_ONE: 'one_to_one',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.DeleteType = {
  EVERYWHERE: 'everywhere',
  LOCAL: 'local',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.MessageType = {
  FILE: 'file',
  IMAGE: 'image',
  LOCATION: 'location',
  PING: 'ping',
  SYSTEM: 'system',
  TEXT: 'text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.PlatformType = {
  BROWSER_APP: 'web',
  DESKTOP_LINUX: 'linux',
  DESKTOP_MACOS: 'mac',
  DESKTOP_WINDOWS: 'windows',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.UserType = {
  GUEST: 'guest',
  TEMPORARY_GUEST: 'temporary_guest',
  USER: 'user',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

/**
 * Definition of events used for user analytics.
 * @returns {z.tracking.EventName} Event names (defined by Business Intelligence Team)
 */
z.tracking.EventName = {
  CALLING: {
    ENDED_CALL: 'calling.ended_call',
    ENDED_VIDEO_CALL: 'calling.ended_video_call',
    ESTABLISHED_CALL: 'calling.established_call',
    ESTABLISHED_VIDEO_CALL: 'calling.established_video_call',
    FAILED_REQUEST: 'calling.failed_request',
    FAILED_REQUESTING_MEDIA: 'calling.failed_requesting_media',
    FAILED_RTC: 'calling.failed_rtc',
    INITIATED_CALL: 'calling.initiated_call',
    INITIATED_VIDEO_CALL: 'calling.initiated_video_call',
    JOINED_CALL: 'calling.joined_call',
    JOINED_VIDEO_CALL: 'calling.joined_video_call',
    RECEIVED_CALL: 'calling.received_call',
    RECEIVED_VIDEO_CALL: 'calling.received_video_call',
    SHARED_SCREEN: 'calling.shared_screen',
  },
  CONTRIBUTED: 'contributed',
  CONVERSATION: {
    ADD_PARTICIPANTS: 'conversation.add_participants',
    GROUP_CREATION_SUCCEEDED: 'conversation.group_creation_succeeded',
    OPENED_GROUP_CREATION: 'conversation.opened_group_creation',
    OPENED_SELECT_PARTICIPANTS: 'conversation.opened_select_participants',
  },
  E2EE: {
    FAILED_MESSAGE_DECRYPTION: 'e2ee.failed_message_decryption',
  },
  GUEST_ROOMS: {
    ALLOW_GUESTS: 'guest_rooms.allow_guests',
    GUEST_ROOM_CREATION: 'guest_rooms.guest_room_creation',
    LINK_COPIED: 'guest_rooms.link_copied',
    LINK_CREATED: 'guest_rooms.link_created',
    LINK_REVOKED: 'guest_rooms.link_revoked',
  },
  HISTORY: {
    BACKUP_FAILED: 'history.backup_failed',
    BACKUP_SUCCEEDED: 'history.backup_succeeded',
    RESTORE_FAILED: 'history.restore_failed',
    RESTORE_SUCCEEDED: 'history.restore_succeeded',
  },
  INTEGRATION: {
    ADDED_SERVICE: 'integration.added_service',
    REMOVED_SERVICE: 'integration.removed_service',
  },
  SETTINGS: {
    CHANGED_STATUS: 'settings.changed_status',
    OPENED_MANAGE_TEAM: 'settings.opened_manage_team',
    OPTED_IN_TRACKING: 'settings.opted_in_tracking',
    OPTED_OUT_TRACKING: 'settings.opted_out_tracking',
  },
  TELEMETRY: {
    APP_INITIALIZATION: 'telemetry.app_initialization',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

z.tracking.EventTrackingRepository = class EventTrackingRepository {
  static get CONFIG() {
    return {
      ERROR_REPORTING: {
        API_KEY: window.wire.env.RAYGUN_API_KEY,
        REPORTING_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
      },
      USER_ANALYTICS: {
        API_KEY: window.wire.env.ANALYTICS_API_KEY,
        CLIENT_TYPE: 'desktop',
        DISABLED_DOMAINS: ['localhost', 'zinfra.io'],
        DISABLED_EVENTS: [
          z.tracking.EventName.CALLING.FAILED_REQUEST,
          z.tracking.EventName.CALLING.FAILED_REQUESTING_MEDIA,
          z.tracking.EventName.CALLING.FAILED_RTC,
          z.tracking.EventName.TELEMETRY.APP_INITIALIZATION,
        ],
      },
    };
  }

  /**
   * Construct a new repository for user actions and errors reporting.
   *
   * @param {z.team.TeamRepository} teamRepository - Repository that handles teams
   * @param {z.user.UserRepository} userRepository - Repository that handles users
   * @returns {EventTrackingRepository} The new repository for user actions
   */
  constructor(teamRepository, userRepository) {
    this.updatePrivacyPreference = this.updatePrivacyPreference.bind(this);

    this.logger = new z.util.Logger('z.tracking.EventTrackingRepository', z.config.LOGGER.OPTIONS);

    this.teamRepository = teamRepository;
    this.userRepository = userRepository;

    this.providerAPI = undefined;
    this.lastReportTimestamp = undefined;
    this.privacyPreference = undefined;

    this.isErrorReportingActivated = false;
    this.isUserAnalyticsActivated = false;
  }

  /**
   * Init the repository.
   * @param {boolean} privacyPreference - Privacy preference
   * @returns {Promise} Resolves after initialization
   */
  init(privacyPreference) {
    this.privacyPreference = privacyPreference;
    this.logger.info(`Initialize analytics and error reporting: ${this.privacyPreference}`);

    const privacyPromise = this.privacyPreference ? this._enableServices(false) : Promise.resolve();
    return privacyPromise.then(() => {
      amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.PRIVACY, this.updatePrivacyPreference);
    });
  }

  updatePrivacyPreference(privacyPreference) {
    const hasPreferenceChanged = privacyPreference !== this.privacyPreference;
    if (hasPreferenceChanged) {
      this.privacyPreference = privacyPreference;

      return this.privacyPreference ? this._enableServices(true) : this._disableServices();
    }
  }

  _enableServices(isOptIn = false) {
    this._enableErrorReporting();
    return this._isDomainAllowedForAnalytics()
      ? this._enableAnalytics().then(() => {
          if (isOptIn) {
            this._trackEvent(z.tracking.EventName.SETTINGS.OPTED_IN_TRACKING);
          }
        })
      : Promise.resolve();
  }

  _disableServices() {
    this._disableErrorReporting();
    this._trackEvent(z.tracking.EventName.SETTINGS.OPTED_OUT_TRACKING);
    this._disableAnalytics();
  }

  //##############################################################################
  // Analytics
  //##############################################################################

  _disableAnalytics() {
    this.logger.debug('Analytics was disabled due to user preferences');
    this.isUserAnalyticsActivated = false;

    this._unsubscribeFromAnalyticsEvents();

    if (this.providerAPI) {
      // Disable provider API
      this.providerAPI = undefined;
    }
  }

  _enableAnalytics() {
    this.isUserAnalyticsActivated = true;

    // Check if provider API is available and reuse if possible
    const providerPromise = this.providerAPI ? Promise.resolve(this.providerAPI) : this._initAnalytics();
    return providerPromise.then(providerInstance => {
      if (providerInstance) {
        this._setSuperProperties();
        this._subscribeToAnalyticsEvents();
      }
    });
  }

  _initAnalytics() {
    // Initialize provider API
    return Promise.resolve(this.providerAPI);
  }

  _isDomainAllowedForAnalytics() {
    const trackingParameter = z.util.URLUtil.getParameter(z.auth.URLParameter.TRACKING);
    return typeof trackingParameter === 'boolean'
      ? trackingParameter
      : !EventTrackingRepository.CONFIG.USER_ANALYTICS.DISABLED_DOMAINS.some(domain => {
          if (z.util.StringUtil.includes(window.location.hostname, domain)) {
            this.logger.debug(`Analytics is disabled for domain '${window.location.hostname}'`);
            return true;
          }
        });
  }

  _resetSuperProperties() {
    if (this.providerAPI) {
      // Reset super properties on provider API and forget distinct ids
    }
  }

  _subscribeToAnalyticsEvents() {
    amplify.subscribe(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, this, (...args) => {
      if (this.isUserAnalyticsActivated) {
        this._setSuperProperty(...args);
      }
    });

    amplify.subscribe(z.event.WebApp.ANALYTICS.EVENT, this, (...args) => {
      if (this.isUserAnalyticsActivated) {
        this._trackEvent(...args);
      }
    });

    amplify.subscribe(z.event.WebApp.LIFECYCLE.SIGNED_OUT, this._resetSuperProperties.bind(this));
  }

  _setSuperProperties() {
    this._setSuperProperty(z.tracking.SuperProperty.APP, EventTrackingRepository.CONFIG.USER_ANALYTICS.CLIENT_TYPE);
    this._setSuperProperty(z.tracking.SuperProperty.APP_VERSION, z.util.Environment.version(false));
    this._setSuperProperty(z.tracking.SuperProperty.DESKTOP_APP, z.tracking.helpers.getPlatform());
    if (z.util.Environment.desktop) {
      this._setSuperProperty(z.tracking.SuperProperty.WRAPPER_VERSION, z.util.Environment.version(true));
    }

    if (this.userRepository) {
      this._setSuperProperty(z.tracking.SuperProperty.CONTACTS, this.userRepository.number_of_contacts());
      this._setSuperProperty(z.tracking.SuperProperty.TEAM.IN_TEAM, this.teamRepository.isTeam());
      this._setSuperProperty(z.tracking.SuperProperty.TEAM.SIZE, this.teamRepository.teamSize());
    }
  }

  _setSuperProperty(superPropertyName, value) {
    // Set property on provider API
    this.logger.info(`Set super property '${superPropertyName}' to value '${value}'`);
  }

  _trackEvent(eventName, attributes) {
    const isDisabledEvent = EventTrackingRepository.CONFIG.USER_ANALYTICS.DISABLED_EVENTS.includes(eventName);
    if (isDisabledEvent) {
      this.logger.info(`Skipped sending disabled event of type '${eventName}'`);
    } else {
      const logAttributes = attributes ? `with attributes: ${JSON.stringify(attributes)}` : 'without attributes';
      this.logger.info(`Tracking event '${eventName}' ${logAttributes}`);

      // Send event if provider API available
    }
  }

  _unsubscribeFromAnalyticsEvents() {
    amplify.unsubscribeAll(z.event.WebApp.ANALYTICS.SUPER_PROPERTY);
    amplify.unsubscribeAll(z.event.WebApp.ANALYTICS.EVENT);
  }

  //##############################################################################
  // Error reporting
  //##############################################################################

  /**
   * Checks if a Raygun payload should be reported.
   *
   * @see https://github.com/MindscapeHQ/raygun4js#onbeforesend
   * @param {JSON} raygunPayload - Error payload about to be send
   * @returns {JSON|boolean} Payload if error will be reported, otherwise "false"
   */
  _checkErrorPayload(raygunPayload) {
    if (!this.lastReportTimestamp) {
      this.lastReportTimestamp = Date.now();
      return raygunPayload;
    }

    const timeSinceLastReport = Date.now() - this.lastReportTimestamp;
    if (timeSinceLastReport > EventTrackingRepository.CONFIG.ERROR_REPORTING.REPORTING_THRESHOLD) {
      this.lastReportTimestamp = Date.now();
      return raygunPayload;
    }

    return false;
  }

  _disableErrorReporting() {
    this.logger.debug('Disabling Raygun error reporting');
    this.isErrorReportingActivated = false;
    Raygun.detach();
    Raygun.init(EventTrackingRepository.CONFIG.ERROR_REPORTING.API_KEY, {disableErrorTracking: true});
  }

  _enableErrorReporting() {
    this.logger.debug('Enabling Raygun error reporting');
    this.isErrorReportingActivated = true;

    const options = {
      disableErrorTracking: false,
      excludedHostnames: ['localhost', 'wire.ms'],
      ignore3rdPartyErrors: true,
      ignoreAjaxAbort: true,
      ignoreAjaxError: true,
    };

    options.debugMode = !z.util.Environment.frontend.isProduction();

    Raygun.init(EventTrackingRepository.CONFIG.ERROR_REPORTING.API_KEY, options).attach();
    Raygun.disableAutoBreadcrumbs();

    /*
    Adding a version to the Raygun reports to identify which version of the Wire ran into the issue.
    @note We cannot use our own version string as it has to be in a certain format
    @see https://github.com/MindscapeHQ/raygun4js#version-filtering
    */
    if (!z.util.Environment.frontend.isLocalhost()) {
      Raygun.setVersion(z.util.Environment.version(false));
    }
    if (z.util.Environment.desktop) {
      Raygun.withCustomData({electron_version: z.util.Environment.version(true)});
    }
    Raygun.onBeforeSend(this._checkErrorPayload.bind(this));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

z.tracking.helpers = {
  /**
   * Get corresponding tracking attribute for conversation type.
   * @param {z.entity.Conversation} conversationEntity - Conversation to map type of
   * @returns {z.tracking.attribute.ConversationType} Mapped conversation type
   */
  getConversationType(conversationEntity) {
    if (conversationEntity instanceof z.entity.Conversation) {
      return conversationEntity.is1to1()
        ? z.tracking.attribute.ConversationType.ONE_TO_ONE
        : z.tracking.attribute.ConversationType.GROUP;
    }
  },

  getGuestAttributes(conversationEntity) {
    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      const isAllowGuests = !conversationEntity.isTeamOnly();
      const _getUserType = _conversationEntity => {
        if (_conversationEntity.selfUser().isTemporaryGuest()) {
          return z.tracking.attribute.UserType.TEMPORARY_GUEST;
        }

        return _conversationEntity.isGuest() ? z.tracking.attribute.UserType.GUEST : z.tracking.attribute.UserType.USER;
      };

      return {
        is_allow_guests: isAllowGuests,
        user_type: _getUserType(conversationEntity),
      };
    }

    return {
      is_allow_guests: false,
      user_type: z.tracking.attribute.UserType.USER,
    };
  },

  getParticipantTypes(userEntities, countSelf) {
    const initialValue = {guests: 0, temporaryGuests: 0, users: countSelf ? 1 : 0};
    return userEntities.reduce((accumulator, userEntity) => {
      if (userEntity.isTemporaryGuest()) {
        accumulator.temporaryGuests += 1;
      } else if (userEntity.isGuest()) {
        accumulator.guests += 1;
      } else {
        accumulator.users += 1;
      }

      return accumulator;
    }, initialValue);
  },

  /**
   * Get the platform identifier.
   * @returns {z.tracking.attribute.PlatformType} Mapped platform type
   */
  getPlatform() {
    if (!z.util.Environment.desktop) {
      return z.tracking.attribute.PlatformType.BROWSER_APP;
    }

    if (z.util.Environment.os.win) {
      return z.tracking.attribute.PlatformType.DESKTOP_WINDOWS;
    }
    return z.util.Environment.os.mac
      ? z.tracking.attribute.PlatformType.DESKTOP_MACOS
      : z.tracking.attribute.PlatformType.DESKTOP_LINUX;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

/**
 * Enumeration of properties that should get send with every user tracking call.
 * @returns {z.tracking.SuperProperty} Super property identifier
 */
z.tracking.SuperProperty = {
  APP: 'app',
  APP_VERSION: 'App Version',
  CONTACTS: 'contacts',
  DESKTOP_APP: 'desktop_app',
  TEAM: {
    IN_TEAM: 'team.in_team',
    SIZE: 'team.size',
  },
  WRAPPER_VERSION: 'wrapper_version',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetUploadFailedReason = {
  CANCELLED: 0,
  FAILED: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetURLCache = (() => {
  const _lruCache = new LRUCache.LRUCache(100);

  const _getUrl = identifier => _lruCache.get(identifier);

  const _setUrl = (identifier, url) => {
    const isExistingUrl = _getUrl(identifier);

    if (isExistingUrl) {
      window.URL.revokeObjectURL(url);
      return isExistingUrl;
    }

    const outdatedUrl = _lruCache.set(identifier, url);

    if (outdatedUrl != null) {
      window.URL.revokeObjectURL(outdatedUrl);
    }

    return url;
  };

  return {
    getUrl: _getUrl,
    setUrl: _setUrl,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetRemoteData = class AssetRemoteData {
  /**
   * Use either z.assets.AssetRemoteData.v2 or z.assets.AssetRemoteData.v3 to initialize.
   * @param {Uint8Array} otrKey - Encryption key
   * @param {Uint8Array} sha256 - Checksum
   */
  constructor(otrKey, sha256) {
    this.otrKey = otrKey;
    this.sha256 = sha256;
    this.downloadProgress = ko.observable();
    this.cancelDownload = undefined;
    this.generateUrl = undefined;
    this.identifier = undefined;

    this.loadPromise = undefined;

    this.logger = new z.util.Logger('z.assets.AssetRemoteData', z.config.LOGGER.OPTIONS);
  }

  /**
   * Static initializer for v3 assets.
   *
   * @param {string} assetKey - ID to retrieve asset with
   * @param {Uint8Array} [otrKey] - Encryption key
   * @param {Uint8Array} [sha256] - Checksum
   * @param {string} [assetToken] - Token data
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V3 asset remote data
   */
  static v3(assetKey, otrKey, sha256, assetToken, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData(otrKey, sha256);
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrlV3(assetKey, assetToken, forceCaching);
    remoteData.identifier = `${assetKey}`;
    return remoteData;
  }

  /**
   * Static initializer for v2 assets.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} assetId - ID to retrieve asset with
   * @param {Uint8Array} otrKey - Encryption key
   * @param {Uint8Array} sha256 - Checksum
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V2 asset remote data
   */
  static v2(conversationId, assetId, otrKey, sha256, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData(otrKey, sha256);
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrlV2(assetId, conversationId, forceCaching);
    remoteData.identifier = `${conversationId}${assetId}`;
    return remoteData;
  }

  /**
   * Static initializer for v1 assets.
   *
   * @deprecated
   * @param {string} conversationId - ID of conversation
   * @param {string} assetId - ID to retrieve asset with
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V1 asset remote data
   */
  static v1(conversationId, assetId, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData();
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrl(assetId, conversationId, forceCaching);
    remoteData.identifier = `${conversationId}${assetId}`;
    return remoteData;
  }

  /**
   * Get object url for asset remote data. URLs are cached in memory.
   * @returns {Promise<string>} Object URL for asset
   */
  getObjectUrl() {
    const objectUrl = z.assets.AssetURLCache.getUrl(this.identifier);
    return objectUrl
      ? Promise.resolve(objectUrl)
      : this.load().then(blob => {
          if (blob) {
            const url = window.URL.createObjectURL(blob);
            return z.assets.AssetURLCache.setUrl(this.identifier, url);
          }
        });
  }

  /**
   * Loads and decrypts stored asset
   * @returns {Promise<Blob>} Resolves with the decrypted asset data
   */
  load() {
    let type;

    if (this.loadPromise) {
      return this.loadPromise;
    }

    this.loadPromise = this._loadBuffer()
      .then(({buffer, mimeType}) => {
        type = mimeType;
        this.loadPromise = undefined;
        const isEncryptedAsset = this.otrKey && this.sha256;
        return isEncryptedAsset
          ? z.assets.AssetCrypto.decryptAesAsset(buffer, this.otrKey.buffer, this.sha256.buffer)
          : buffer;
      })
      .then(plaintext => new Blob([new Uint8Array(plaintext)], {type}))
      .catch(error => {
        this.loadPromise = undefined;
        const errorMessage = (error && error.message) || '';
        const isAssetNotFound = errorMessage.endsWith(z.error.BackendClientError.STATUS_CODE.NOT_FOUND);
        const isServerError = errorMessage.endsWith(z.error.BackendClientError.STATUS_CODE.INTERNAL_SERVER_ERROR);

        const isExpectedError = isAssetNotFound || isServerError;
        if (!isExpectedError) {
          throw error;
        }
      });

    return this.loadPromise;
  }

  _loadBuffer() {
    return this.generateUrl()
      .then(generatedUrl => {
        return z.util.loadUrlBuffer(generatedUrl, xhr => {
          xhr.onprogress = event => this.downloadProgress(Math.round((event.loaded / event.total) * 100));
          this.cancelDownload = () => xhr.abort.call(xhr);
        });
      })
      .catch(error => {
        const isValidationUtilError = error instanceof z.util.ValidationUtilError;
        const message = isValidationUtilError
          ? `Failed to validate an asset URL (_load_buffer): ${error.message}`
          : `Failed to load asset: ${error.message || error}`;

        this.logger.error(message);

        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetRetentionPolicy = {
  ETERNAL: 'eternal',
  ETERNAL_INFREQUENT_ACCESS: 'eternal-infrequent_access',
  EXPIRING: 'expiring',
  PERSISTENT: 'persistent',
  VOLATILE: 'volatile',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetTransferState = {
  DOWNLOADING: 'downloading',
  UPLOAD_FAILED: 'upload-failed',
  UPLOADED: 'uploaded',
  UPLOADING: 'uploading',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetType = {
  FILE: 'File',
  IMAGE: 'Image',
  LOCATION: 'Location',
  TEXT: 'Text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

// AssetService for all asset handling and the calls to the backend REST API.
z.assets.AssetService = class AssetService {
  /**
   * Construct a new Asset Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.assets.AssetService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Update the user profile image by first making it usable, transforming it and then uploading the asset pair.
   * @param {File|Blob} image - Profile image
   * @returns {Promise} Resolves when profile image has been uploaded
   */
  uploadProfileImage(image) {
    return Promise.all([this._compressProfileImage(image), this._compressImage(image)])
      .then(([{compressedBytes: previewImageBytes}, {compressedBytes: mediumImageBytes}]) => {
        const assetUploadOptions = {public: true, retention: z.assets.AssetRetentionPolicy.ETERNAL};
        return Promise.all([
          this.postAsset(previewImageBytes, assetUploadOptions),
          this.postAsset(mediumImageBytes, assetUploadOptions),
        ]);
      })
      .then(([previewCredentials, mediumCredentials]) => {
        return {mediumImageKey: mediumCredentials.key, previewImageKey: previewCredentials.key};
      });
  }

  /**
   * Upload arbitrary binary data using the new asset api v3.
   * The data is AES encrypted before uploading.
   *
   * @param {Uint8Array} bytes - Asset binary data
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} [xhrAccessorFunction] - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  _uploadAsset(bytes, options, xhrAccessorFunction) {
    return z.assets.AssetCrypto.encryptAesAsset(bytes).then(({cipherText, keyBytes, sha256}) => {
      return this.postAsset(new Uint8Array(cipherText), options, xhrAccessorFunction).then(({key, token}) => ({
        key,
        keyBytes,
        sha256,
        token,
      }));
    });
  }

  /**
   * Upload file using the new asset api v3. Promise will resolve with z.proto.Asset instance.
   * In case of an successful upload the uploaded property is set.
   *
   * @param {Blob|File} file - File asset to be uploaded
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} xhrAccessorFunction - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  uploadAsset(file, options, xhrAccessorFunction) {
    return z.util
      .loadFileBuffer(file)
      .then(buffer => this._uploadAsset(buffer, options, xhrAccessorFunction))
      .then(({key, keyBytes, sha256, token}) => {
        const protoAsset = new z.proto.Asset();
        const assetRemoteData = new z.proto.Asset.RemoteData(keyBytes, sha256, key, token);

        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_UPLOADED, assetRemoteData);
        return protoAsset;
      });
  }

  /**
   * Upload image using the new asset api v3. Promise will resolve with z.proto.Asset instance.
   * In case of an successful upload the uploaded property is set.
   *
   * @param {Blob|File} image - Image asset to be uploaded
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @returns {Promise} Resolves when asset has been uploaded
   */
  uploadImageAsset(image, options) {
    return this._compressImage(image).then(({compressedBytes, compressedImage}) => {
      return this._uploadAsset(compressedBytes, options).then(({key, keyBytes, sha256, token}) => {
        const protoAsset = new z.proto.Asset();

        const assetImageMetadata = new z.proto.Asset.ImageMetaData(compressedImage.width, compressedImage.height);
        const assetOriginal = new z.proto.Asset.Original(image.type, compressedBytes.length, null, assetImageMetadata);
        const assetRemoteData = new z.proto.Asset.RemoteData(keyBytes, sha256, key, token);

        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_ORIGINAL, assetOriginal);
        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_UPLOADED, assetRemoteData);
        return protoAsset;
      });
    });
  }

  /**
   * Generates the URL an asset can be downloaded from.
   *
   * @deprecated
   * @param {string} assetId - ID of asset
   * @param {string} conversationId - Conversation ID
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v1 asset
   */
  generateAssetUrl(assetId, conversationId, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.legacy(assetId, conversationId);
      const url = this.backendClient.createUrl(`/assets/${assetId}`);
      const cachingParam = forceCaching ? '&forceCaching=true' : '';
      const conversationIdParam = `&conv_id=${window.encodeURIComponent(conversationId)}`;

      return `${url}?access_token=${this.backendClient.accessToken}${conversationIdParam}${cachingParam}`;
    });
  }

  /**
   * Generates the URL for asset api v2.
   *
   * @deprecated
   * @param {string} assetId - ID of asset
   * @param {string} conversationId - Conversation ID
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v2 asset
   */
  generateAssetUrlV2(assetId, conversationId, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.legacy(assetId, conversationId);
      const url = this.backendClient.createUrl(`/conversations/${conversationId}/otr/assets/${assetId}`);
      const cachingParam = forceCaching ? '&forceCaching=true' : '';

      return `${url}?access_token=${this.backendClient.accessToken}${cachingParam}`;
    });
  }

  /**
   * Generates the URL for asset api v3.
   *
   * @param {string} assetKey - ID of asset
   * @param {string} assetToken - Asset token
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v3 asset
   */
  generateAssetUrlV3(assetKey, assetToken, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.v3(assetKey, assetToken);
      const url = `${this.backendClient.createUrl(`/assets/v3/${assetKey}`)}`;
      const assetTokenParam = assetToken ? `&asset_token=${window.encodeURIComponent(assetToken)}` : '';
      const cachingParam = forceCaching ? '&forceCaching=true' : '';

      return `${url}?access_token=${this.backendClient.accessToken}${assetTokenParam}${cachingParam}`;
    });
  }

  getAssetRetention(userEntity, conversationEntity) {
    const isTeamMember = userEntity.inTeam();
    const isTeamConversation = conversationEntity.inTeam();
    const isTeamUserInConversation = conversationEntity
      .participating_user_ets()
      .some(conversationParticipant => conversationParticipant.inTeam());

    const isEternal = isTeamMember || isTeamConversation || isTeamUserInConversation;
    return isEternal ? z.assets.AssetRetentionPolicy.ETERNAL : z.assets.AssetRetentionPolicy.PERSISTENT;
  }

  /**
   * Post assets.
   *
   * @param {Uint8Array} assetData - Asset data
   * @param {Object} options - Asset metadata
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} [xhrAccessorFunction] - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  postAsset(assetData, options, xhrAccessorFunction) {
    return new Promise((resolve, reject) => {
      const BOUNDARY = 'frontier';

      options = Object.assign(
        {
          public: false,
          retention: z.assets.AssetRetentionPolicy.PERSISTENT,
        },
        options
      );

      options = JSON.stringify(options);

      let body = '';
      body += `--${BOUNDARY}\r\n`;
      body += 'Content-Type: application/json; charset=utf-8\r\n';
      body += `Content-length: ${options.length}\r\n`;
      body += '\r\n';
      body += `${options}\r\n`;
      body += `--${BOUNDARY}\r\n`;
      body += 'Content-Type: application/octet-stream\r\n';
      body += `Content-length: ${assetData.length}\r\n`;
      body += `Content-MD5: ${z.util.arrayToMd5Base64(assetData)}\r\n`;
      body += '\r\n';
      const footer = `\r\n--${BOUNDARY}--\r\n`;

      const xhr = new XMLHttpRequest();
      xhr.open('POST', this.backendClient.createUrl('/assets/v3'));
      xhr.setRequestHeader('Content-Type', `multipart/mixed; boundary=${BOUNDARY}`);
      xhr.setRequestHeader('Authorization', `${this.backendClient.accessTokenType} ${this.backendClient.accessToken}`);
      xhr.onload = function(event) {
        return this.status === 201 ? resolve(JSON.parse(this.response)) : reject(event);
      };
      xhr.onerror = reject;

      if (typeof xhrAccessorFunction === 'function') {
        xhrAccessorFunction(xhr);
      }

      xhr.send(new Blob([body, assetData, footer]));
    });
  }

  /**
   * Compress image.
   * @param {File|Blob} image - Image to be compressed in ServiceWorker
   * @returns {Promise} Resolves with the compressed imaged
   */
  _compressImage(image) {
    return this._compressImageWithWorker('worker/image-worker.js', image, () => image.type === 'image/gif');
  }

  /**
   * Compress profile image.
   * @param {File|Blob} image - Profile image to be compressed in ServiceWorker
   * @returns {Promise} Resolves with the compressed profile imaged
   */
  _compressProfileImage(image) {
    return this._compressImageWithWorker('worker/profile-image-worker.js', image);
  }

  /**
   * Compress image using given worker.
   * @param {string} worker - Path to worker file
   * @param {File|Blob} image - Image to be compressed in ServiceWorker
   * @param {Function} filter - Optional filter to be applied
   * @returns {Promise} Resolves with the compressed image
   */
  _compressImageWithWorker(worker, image, filter) {
    return z.util
      .loadFileBuffer(image)
      .then(buffer => {
        if (typeof filter === 'function' ? filter() : undefined) {
          return new Uint8Array(buffer);
        }
        return new z.util.Worker(worker).post(buffer);
      })
      .then(compressedBytes => {
        return z.util
          .loadImage(new Blob([compressedBytes], {type: image.type}))
          .then(compressedImage => ({compressedBytes, compressedImage}));
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetMapper = {
  /**
   * Creates asset entities out of raw asset data.
   *
   * @param {string} userId - the id of the user that will hold the asset
   * @param {Array<Object>} assets - the assets to map
   * @returns {MappedAssets} Object containing the mapped assets
   */
  mapProfileAssets: (userId, assets) => {
    const sizeMap = {
      complete: 'medium',
      preview: 'preview',
    };

    return assets
      .filter(asset => asset.type === 'image')
      .reduce((mappedAssets, asset) => {
        const assetRemoteData = z.assets.AssetRemoteData.v3(asset.key, true);

        return !sizeMap[asset.size]
          ? mappedAssets
          : Object.assign({}, mappedAssets, {[sizeMap[asset.size]]: assetRemoteData});
      }, {});
  },

  /**
   * Creates asset entities out of raw asset data.
   *
   * @param {string} userId - the id of the user that will hold the asset
   * @param {Array<Object>} pictures - the pictures to map
   * @returns {MappedAssets} Object containing the mapped assets
   */
  mapProfileAssetsV1: (userId, pictures) => {
    const [previewPicture, mediumPicture] = pictures;
    const previewAsset = previewPicture ? z.assets.AssetRemoteData.v1(userId, previewPicture.id, true) : undefined;
    const mediumAsset = mediumPicture ? z.assets.AssetRemoteData.v1(userId, mediumPicture.id, true) : undefined;

    return {medium: mediumAsset, preview: previewAsset};
  },

  /**
   * Updates the user entity's assets.
   *
   * @param {z.entity.User} userEntity - the user entity to update
   * @param {MappedAssets} mappedAssets - the assets to add to the user entity
   * @returns {void}
   */
  updateUserEntityAssets(userEntity, mappedAssets = {}) {
    const {preview, medium} = mappedAssets;
    if (preview) {
      userEntity.previewPictureResource(preview);
    }
    if (medium) {
      userEntity.mediumPictureResource(medium);
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

// Builder for creating all kinds of asset metadata
z.assets.AssetMetaDataBuilder = (() => {
  /**
   * Constructs corresponding asset metadata depending on the given file type
   * @param {File|Blob} file - the file to generate metadata for
   * @returns {Promise} Resolves with ImageMetaData, VideoMetaData or AudioMetaData
   */
  const _buildMetadata = file => {
    if (!(file instanceof Blob)) {
      throw new Error('Expected file to be type of Blob');
    }

    if (_isVideo(file)) {
      return _buildMetadataVideo(file);
    }
    if (_isAudio(file)) {
      return _buildMetadataAudio(file);
    }
    if (_isImage(file)) {
      return _buildMetadataImage(file);
    }
    return Promise.resolve();
  };

  const _buildMetadataAudio = audioFile => {
    return z.util
      .loadFileBuffer(audioFile)
      .then(buffer => {
        const audioContext = new AudioContext();
        audioContext.close();
        return audioContext.decodeAudioData(buffer);
      })
      .then(audioBuffer => {
        const durationInMillis = audioBuffer.duration * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        return new z.proto.Asset.AudioMetaData(durationInMillis, _normaliseLoudness(audioBuffer));
      });
  };

  const _buildMetadataImage = imageFile => {
    return new Promise((resolve, reject) => {
      const url = window.URL.createObjectURL(imageFile);
      const image = new Image();
      image.onload = () => {
        resolve(new z.proto.Asset.ImageMetaData(image.width, image.height));
        window.URL.revokeObjectURL(url);
      };
      image.onerror = error => {
        reject(error);
        window.URL.revokeObjectURL(url);
      };
      image.src = url;
    });
  };

  const _buildMetadataVideo = videoFile => {
    return new Promise((resolve, reject) => {
      const url = window.URL.createObjectURL(videoFile);
      const video = document.createElement('video');
      video.onloadedmetadata = () => {
        resolve(new z.proto.Asset.VideoMetaData(video.videoWidth, video.videoHeight, video.duration));
        window.URL.revokeObjectURL(url);
      };
      video.addEventListener(
        'error',
        error => {
          reject(_convertEventToError(error));
          window.URL.revokeObjectURL(url);
        },
        true
      );
      video.src = url;
    });
  };

  /**
   * Convert an error event into a plain error object.
   * This needs to be done because error events are not standardized between browser implementations.
   * @private
   * @param {Event} event - Error event
   * @returns {MediaError} Error object
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/originalTarget
   */
  const _convertEventToError = event => {
    let error = event;

    // Chrome v60
    if (event.path && event.path[0]) {
      error = event.path[0].error;
    }

    // Firefox v55
    if (event.originalTarget) {
      error = error.originalTarget.error;
    }

    return error;
  };

  const _isAudio = file => {
    return file && file.type.startsWith('audio');
  };

  const _isImage = file => {
    return file && file.type.startsWith('image');
  };

  const _isVideo = file => {
    return file && file.type.startsWith('video');
  };

  const _normaliseLoudness = audioBuffer => {
    const MAX_SAMPLES = 200;
    const AMPLIFIER = 700; // in favour of iterating all samples before we interpolate them
    const channel = audioBuffer.getChannelData(0);
    const bucketSize = parseInt(channel.length / MAX_SAMPLES);
    const buckets = z.util.ArrayUtil.chunk(channel, bucketSize);

    const audioPreview = buckets.map(bucket => {
      return z.util.NumberUtil.capToByte(AMPLIFIER * z.util.NumberUtil.rootMeanSquare(bucket));
    });

    return new Uint8Array(audioPreview);
  };

  return {
    buildMetadata: _buildMetadata,
    isAudio: _isAudio,
    isImage: _isImage,
    isVideo: _isVideo,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetCrypto = (() => {
  /**
   * @param {ArrayBuffer} cipherText - Encrypted plaintext
   * @param {ArrayBuffer} keyBytes - AES key used for encryption
   * @param {ArrayBuffer} referenceSha256 - SHA-256 checksum of the cipherText
   * @returns {Promise} Resolves with the decrypted asset
   */
  const _decryptAesAsset = (cipherText, keyBytes, referenceSha256) => {
    return window.crypto.subtle
      .digest('SHA-256', cipherText)
      .then(computedSha256 => {
        if (_equalHashes(referenceSha256, computedSha256)) {
          return window.crypto.subtle.importKey('raw', keyBytes, 'AES-CBC', false, ['decrypt']);
        }

        throw new Error('Encrypted asset does not match its SHA-256 hash');
      })
      .then(key => {
        const iv = cipherText.slice(0, 16);
        const assetCipherText = cipherText.slice(16);
        return window.crypto.subtle.decrypt({iv: iv, name: 'AES-CBC'}, key, assetCipherText);
      });
  };

  /**
   * @param {ArrayBuffer} plaintext - Plaintext asset to be encrypted
   * @returns {Promise} Resolves with the encrypted asset
   */
  const _encryptAesAsset = plaintext => {
    const iv = _generateRandomBytes(16);
    const rawKeyBytes = _generateRandomBytes(32);
    let key = null;
    let ivCipherText = null;
    let computedSha256 = null;

    return window.crypto.subtle
      .importKey('raw', rawKeyBytes.buffer, 'AES-CBC', true, ['encrypt'])
      .then(ckey => {
        key = ckey;

        return window.crypto.subtle.encrypt({iv: iv.buffer, name: 'AES-CBC'}, key, plaintext);
      })
      .then(cipherText => {
        ivCipherText = new Uint8Array(cipherText.byteLength + iv.byteLength);
        ivCipherText.set(iv, 0);
        ivCipherText.set(new Uint8Array(cipherText), iv.byteLength);

        return window.crypto.subtle.digest('SHA-256', ivCipherText);
      })
      .then(digest => {
        computedSha256 = digest;

        return window.crypto.subtle.exportKey('raw', key);
      })
      .then(keyBytes => ({cipherText: ivCipherText.buffer, keyBytes: keyBytes, sha256: computedSha256}));
  };

  const _equalHashes = (bufferA, bufferB) => {
    const arrayA = new Uint32Array(bufferA);
    const arrayB = new Uint32Array(bufferB);
    return arrayA.length === arrayB.length && arrayA.every((value, index) => value === arrayB[index]);
  };

  const _generateRandomBytes = length => {
    const getRandomValue = () => {
      const buffer = new Uint32Array(1);
      window.crypto.getRandomValues(buffer);
      return buffer[0] >>> 0;
    };

    const randomValues = new Uint32Array(length / 4).map(getRandomValue);
    const randomBytes = new Uint8Array(randomValues.buffer);
    if (randomBytes.length && !randomBytes.every(byte => byte === 0)) {
      return randomBytes;
    }
    throw Error('Failed to initialize iv with random values');
  };

  return {
    decryptAesAsset: _decryptAesAsset,
    encryptAesAsset: _encryptAesAsset,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

window.z = window.z || {};
window.z.backup = z.backup || {};

(module => {
  class ExportError extends Error {
    constructor(message = 'Something went wrong.') {
      super(message);
      Object.setPrototypeOf(this, ExportError.prototype);
    }
  }

  class CancelError extends Error {
    constructor(message = 'Action was cancelled') {
      super(message);
      Object.setPrototypeOf(this, CancelError.prototype);
    }
  }

  class ImportError extends Error {
    constructor(message = 'Something went wrong.') {
      super(message);
      Object.setPrototypeOf(this, ImportError.prototype);
    }
  }

  class InvalidMetaDataError extends ImportError {
    constructor(message = 'Meta data file is corrupt or missing properties.') {
      super(message);
      Object.setPrototypeOf(this, InvalidMetaDataError.prototype);
    }
  }

  class DifferentAccountError extends ImportError {
    constructor(message = 'You cannot restore history from a different account.') {
      super(message);
      Object.setPrototypeOf(this, DifferentAccountError.prototype);
    }
  }

  class IncompatibleBackupError extends ImportError {
    constructor(message = 'Backup created by incompatible database version') {
      super(message);
      Object.setPrototypeOf(this, IncompatibleBackupError.prototype);
    }
  }

  class IncompatiblePlatformError extends ImportError {
    constructor(message = 'Backup created by incompatible platform') {
      super(message);
      Object.setPrototypeOf(this, IncompatiblePlatformError.prototype);
    }
  }

  module.CancelError = CancelError;
  module.DifferentAccountError = DifferentAccountError;
  module.ExportError = ExportError;
  module.ImportError = ImportError;
  module.IncompatibleBackupError = IncompatibleBackupError;
  module.IncompatiblePlatformError = IncompatiblePlatformError;
  module.InvalidMetaDataError = InvalidMetaDataError;
})(z.backup);

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.backup = z.backup || {};

z.backup.BackupRepository = class BackupRepository {
  static get CONFIG() {
    return {
      FILENAME: {
        CONVERSATIONS: 'conversations.json',
        EVENTS: 'events.json',
        METADATA: 'export.json',
      },
      UINT8ARRAY_FIELDS: ['otr_key', 'sha256'],
    };
  }

  /**
   * Construct a new Backup repository.
   * @class z.backup.BackupRepository
   * @param {z.backup.BackupService} backupService - Backup service implementation
   * @param {z.client.ClientRepository} clientRepository - Repository for all client interactions
   * @param {z.connection.ConnectionRepository} connectionRepository - Repository for all connection interactions
   * @param {z.conversation.ConversationRepository} conversationRepository - Repository for all conversation interactions
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(backupService, clientRepository, connectionRepository, conversationRepository, userRepository) {
    this.logger = new z.util.Logger('z.backup.BackupRepository', z.config.LOGGER.OPTIONS);

    this.backupService = backupService;
    this.clientRepository = clientRepository;
    this.connectionRepository = connectionRepository;
    this.conversationRepository = conversationRepository;
    this.userRepository = userRepository;

    this.canceled = false;

    this.CONVERSATIONS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS;
    this.EVENTS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  cancelAction() {
    this.isCanceled = true;
  }

  get isCanceled() {
    return this.canceled;
  }

  set isCanceled(isCanceled) {
    this.canceled = isCanceled;
  }

  createMetaData() {
    return {
      client_id: this.clientRepository.currentClient().id,
      creation_time: new Date().toISOString(),
      platform: 'Web',
      user_id: this.userRepository.self().id,
      version: this.backupService.getDatabaseVersion(),
    };
  }

  /**
   * Gather needed data for the export and generates the history
   *
   * @param {function} progressCallback - called on every step of the export
   * @returns {Promise<JSZip>} The promise that contains all the exported tables
   */
  generateHistory(progressCallback) {
    this.isCanceled = false;

    return Promise.resolve()
      .then(() => this._exportHistory(progressCallback))
      .then(exportedData => this._compressHistoryFiles(exportedData))
      .catch(error => {
        this.logger.error(`Could not export history: ${error.message}`, error);

        const isCancelError = error instanceof z.backup.CancelError;
        throw isCancelError ? error : new z.backup.ExportError();
      });
  }

  _exportHistory(progressCallback) {
    const tables = this.backupService.getTables();
    const tableData = {};

    return Promise.resolve()
      .then(() => this._exportHistoryConversations(tables, progressCallback))
      .then(conversationsData => {
        tableData[this.CONVERSATIONS_STORE_NAME] = conversationsData;
        return this._exportHistoryEvents(tables, progressCallback);
      })
      .then(eventsData => {
        tableData[this.EVENTS_STORE_NAME] = eventsData;
        return tableData;
      });
  }

  _exportHistoryConversations(tables, progressCallback) {
    const conversationsTable = tables.find(table => table.name === this.CONVERSATIONS_STORE_NAME);
    const onProgress = (tableRows, exportedEntitiesCount) => {
      progressCallback(tableRows.length);
      this.logger.log(`Exported '${exportedEntitiesCount}' conversation states from history`);

      tableRows.forEach(conversation => delete conversation.verification_state);
    };

    return this._exportHistoryFromTable(conversationsTable, onProgress);
  }

  _exportHistoryEvents(tables, progressCallback) {
    const eventsTable = tables.find(table => table.name === this.EVENTS_STORE_NAME);
    const onProgress = (tableRows, exportedEntitiesCount) => {
      progressCallback(tableRows.length);
      this.logger.log(`Exported '${exportedEntitiesCount}' events from history`);

      for (let index = tableRows.length - 1; index >= 0; index -= 1) {
        const event = tableRows[index];
        const isTypeVerification = event.type === z.event.Client.CONVERSATION.VERIFICATION;
        if (isTypeVerification) {
          tableRows.splice(index, 1);
        }
      }
    };

    return this._exportHistoryFromTable(eventsTable, onProgress);
  }

  _exportHistoryFromTable(table, onProgress) {
    const tableData = [];
    let exportedEntitiesCount = 0;

    return this.backupService
      .exportTable(table, tableRows => {
        if (this.isCanceled) {
          throw new z.backup.CancelError();
        }
        exportedEntitiesCount += tableRows.length;

        onProgress(tableRows, exportedEntitiesCount);
        tableData.push(tableRows);
      })
      .then(() => [].concat(...tableData));
  }

  _compressHistoryFiles(exportedData) {
    const metaData = this.createMetaData();
    const zip = new JSZip();

    // first write the metadata file
    zip.file(BackupRepository.CONFIG.FILENAME.METADATA, JSON.stringify(metaData));

    // then all the other tables
    Object.keys(exportedData).forEach(tableName => {
      zip.file(`${tableName}.json`, JSON.stringify(exportedData[tableName]));
    });

    return zip;
  }

  getBackupInitData() {
    return this.backupService.getHistoryCount();
  }

  importHistory(archive, initCallback, progressCallback) {
    this.isCanceled = false;
    const files = archive.files;
    if (!files[BackupRepository.CONFIG.FILENAME.METADATA]) {
      throw new z.backup.InvalidMetaDataError();
    }

    return this.verifyMetadata(files)
      .then(() => this._extractHistoryFiles(files))
      .then(fileDescriptors => this._importHistoryData(fileDescriptors, initCallback, progressCallback))
      .catch(error => {
        this.logger.error(`Could not export history: ${error.message}`, error);
        throw error;
      });
  }

  _importHistoryData(fileDescriptors, initCallback, progressCallback) {
    const conversationFileDescriptor = fileDescriptors.find(fileDescriptor => {
      return fileDescriptor.filename === BackupRepository.CONFIG.FILENAME.CONVERSATIONS;
    });

    const eventFileDescriptor = fileDescriptors.find(fileDescriptor => {
      return fileDescriptor.filename === BackupRepository.CONFIG.FILENAME.EVENTS;
    });

    const conversationEntities = JSON.parse(conversationFileDescriptor.content);
    const eventEntities = JSON.parse(eventFileDescriptor.content);
    const entityCount = conversationEntities.length + eventEntities.length;
    initCallback(entityCount);

    return this._importHistoryConversations(conversationEntities, progressCallback)
      .then(importedEntities => this._importHistoryEvents(eventEntities, progressCallback).then(() => importedEntities))
      .then(importedEntities => {
        this.conversationRepository.updateConversations(importedEntities);
        this.conversationRepository.map_connections(this.connectionRepository.connectionEntities());
      });
  }

  _importHistoryConversations(conversationEntities, progressCallback) {
    const entityCount = conversationEntities.length;
    let importedEntities = [];

    const entityChunks = z.util.ArrayUtil.chunk(conversationEntities, z.backup.BackupService.CONFIG.BATCH_SIZE);

    const importConversationChunk = chunk =>
      this.conversationRepository.updateConversationStates(chunk).then(importedConversationEntities => {
        importedEntities = importedEntities.concat(importedConversationEntities);
        this.logger.log(`Imported '${importedEntities.length}' of '${entityCount}' conversation states from backup`);
        progressCallback(chunk.length);
      });

    return this._chunkImport(importConversationChunk, entityChunks).then(() => importedEntities);
  }

  _importHistoryEvents(eventEntities, progressCallback) {
    const entityCount = eventEntities.length;
    let importedEntities = 0;

    const entities = eventEntities.map(entity => this.mapEntityDataType(entity));
    const entityChunks = z.util.ArrayUtil.chunk(entities, z.backup.BackupService.CONFIG.BATCH_SIZE);

    const importEventChunk = chunk =>
      this.backupService.importEntities(this.EVENTS_STORE_NAME, chunk).then(() => {
        importedEntities += chunk.length;
        this.logger.log(`Imported '${importedEntities}' of '${entityCount}' events from backup`);
        progressCallback(chunk.length);
      });

    return this._chunkImport(importEventChunk, entityChunks);
  }

  _chunkImport(importFunction, chunks) {
    return chunks.reduce((promise, chunk) => {
      return promise.then(result => {
        if (this.isCanceled) {
          return Promise.reject(new z.backup.CancelError());
        }
        return importFunction(chunk);
      });
    }, Promise.resolve());
  }

  _extractHistoryFiles(files) {
    const unzipPromises = Object.values(files)
      .filter(zippedFile => zippedFile.name !== BackupRepository.CONFIG.FILENAME.METADATA)
      .map(zippedFile => zippedFile.async('string').then(value => ({content: value, filename: zippedFile.name})));

    return Promise.all(unzipPromises).then(fileDescriptors => {
      this.logger.log('Unzipped files for history import', fileDescriptors);
      return fileDescriptors;
    });
  }

  mapEntityDataType(entity) {
    if (entity.data) {
      BackupRepository.CONFIG.UINT8ARRAY_FIELDS.forEach(field => {
        const dataField = entity.data[field];
        if (dataField) {
          entity.data[field] = new Uint8Array(Object.values(dataField));
        }
      });
    }
    return entity;
  }

  verifyMetadata(files) {
    return files[BackupRepository.CONFIG.FILENAME.METADATA]
      .async('string')
      .then(JSON.parse)
      .then(metadata => this._verifyMetadata(metadata))
      .then(() => this.logger.log('Validated metadata during history import', files));
  }

  _verifyMetadata(archiveMetadata) {
    const localMetadata = this.createMetaData();
    const isExpectedUserId = archiveMetadata.user_id === localMetadata.user_id;
    if (!isExpectedUserId) {
      const fromUserId = archiveMetadata.user_id;
      const toUserId = localMetadata.user_id;
      const message = `History from user "${fromUserId}" cannot be restored for user "${toUserId}".`;
      throw new z.backup.DifferentAccountError(message);
    }

    const isExpectedPlatform = archiveMetadata.platform === localMetadata.platform;
    if (!isExpectedPlatform) {
      const message = `History created from "${archiveMetadata.platform}" device cannot be imported`;
      throw new z.backup.IncompatiblePlatformError(message);
    }

    const isExpectedVersion = archiveMetadata.version === localMetadata.version;
    if (!isExpectedVersion) {
      const message = `History cannot be restored: Database version mismatch`;
      throw new z.backup.IncompatibleBackupError(message);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.backup = z.backup || {};

z.backup.BackupService = class BackupService {
  static get CONFIG() {
    return {
      BATCH_SIZE: 10000,
      SUPPORTED_TABLES: [
        z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS,
        z.storage.StorageSchemata.OBJECT_STORE.EVENTS,
      ],
    };
  }

  constructor(storageService) {
    this.logger = new z.util.Logger('z.backup.BackupService', z.config.LOGGER.OPTIONS);
    this.storageService = storageService;

    this.EVENTS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  exportTable(table, onProgress) {
    const collection = table.toCollection();
    return table
      .count()
      .then(count => new DexieBatch({batchSize: BackupService.CONFIG.BATCH_SIZE, limit: count}))
      .then(batchDriver => batchDriver.eachBatch(collection, batch => onProgress(batch)))
      .then(count => this.logger.log(`Exported store '${table.name}' in '${count}' batches`));
  }

  getDatabaseVersion() {
    return this.storageService.db.verno;
  }

  getHistoryCount() {
    return Promise.all(this.getTables().map(table => table.count())).then(recordsPerTable => {
      return recordsPerTable.reduce((accumulator, recordCount) => accumulator + recordCount, 0);
    });
  }

  getTables() {
    return this.storageService.getTables(BackupService.CONFIG.SUPPORTED_TABLES);
  }

  importEntities(tableName, entities) {
    // We don't want to set the primaryKey for the events table
    const isEventsTable = tableName === this.EVENTS_STORE_NAME;
    const primaryKeys = isEventsTable ? undefined : entities.map(entity => entity.id);
    return this.storageService.db[tableName].bulkPut(entities, primaryKeys);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.broadcast = z.broadcast || {};

// Broadcast repository for all broadcast interactions with the broadcast service
z.broadcast.BroadcastRepository = class BroadcastRepository {
  /**
   * Construct a new Broadcast Repository.
   *
   * @param {BroadcastService} broadcastService - Backend REST API broadcast service implementation
   * @param {ClientRepository} clientRepository - Repository for client interactions
   * @param {ConversationRepository} conversationRepository - Repository for conversation interactions
   * @param {CryptographyRepository} cryptographyRepository - Repository for all cryptography interactions
   * @param {UserRepository} userRepository - Repository for all user interactions
   */
  constructor(broadcastService, clientRepository, conversationRepository, cryptographyRepository, userRepository) {
    this.broadcastService = broadcastService;
    this.clientRepository = clientRepository;
    this.conversationRepository = conversationRepository;
    this.cryptographyRepository = cryptographyRepository;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.broadcast.BroadcastRepository', z.config.LOGGER.OPTIONS);

    this.clientMismatchHandler = this.conversationRepository.clientMismatchHandler;

    amplify.subscribe(z.event.WebApp.BROADCAST.SEND_MESSAGE, this.broadcastGenericMessage.bind(this));
  }

  broadcastGenericMessage(genericMessage) {
    return this.conversationRepository.sending_queue.push(() => {
      return this._createBroadcastRecipients()
        .then(recipients => this.cryptographyRepository.encryptGenericMessage(recipients, genericMessage))
        .then(payload => {
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage);
          this._sendEncryptedMessage(eventInfoEntity, payload);
        });
    });
  }

  /**
   * Create a user client map for a broadcast message.
   * @private
   * @returns {Promise} Resolves with a user client map
   */
  _createBroadcastRecipients() {
    return Promise.resolve().then(() => {
      const recipients = {};

      for (const userEntity of this.userRepository.teamUsers().concat(this.userRepository.self())) {
        recipients[userEntity.id] = userEntity.devices().map(clientEntity => clientEntity.id);
      }

      return recipients;
    });
  }

  /**
   * Broadcasts an otr message.
   *
   * @private
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event to be broadcasted
   * @param {Object} payload - Payload
   * @returns {Promise} Promise that resolves after sending the encrypted message
   */
  _sendEncryptedMessage(eventInfoEntity, payload) {
    const messageType = eventInfoEntity.getType();
    this.logger.info(`Sending '${messageType}' message as broadcast`, payload);

    const options = eventInfoEntity.options;
    return this.broadcastService
      .postBroadcastMessage(payload, options.precondition)
      .then(response => {
        this.clientMismatchHandler.onClientMismatch(eventInfoEntity, response, payload);
        return response;
      })
      .catch(error => {
        const isUnknownClient = error.label === z.error.BackendClientError.LABEL.UNKNOWN_CLIENT;
        if (isUnknownClient) {
          this.clientRepository.removeLocalClient();
        }

        if (!error.missing) {
          throw error;
        }

        return this.clientMismatchHandler.onClientMismatch(eventInfoEntity, error, payload).then(updatedPayload => {
          this.logger.info(`Updated '${messageType}' message as broadcast`, updatedPayload);
          eventInfoEntity.forceSending();
          return this._sendEncryptedMessage(eventInfoEntity, updatedPayload);
        });
      });
  }

  _getNumberOfClients() {
    return this.userRepository.teamUsers().reduce((accumulator, userEntity) => {
      if (userEntity.devices().length) {
        return accumulator + userEntity.devices().length;
      }
      return accumulator + z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
    }, this.userRepository.self().devices().length);
  }

  /**
   * Estimate whether message should be send as type external.
   *
   * @private
   * @param {z.proto.GenericMessage} genericMessage - Generic message that will be send
   * @returns {boolean} Is payload likely to be too big so that we switch to type external?
   */
  _shouldSendAsExternal(genericMessage) {
    const messageInBytes = new Uint8Array(genericMessage.toArrayBuffer()).length;
    const estimatedPayloadInBytes = this._getNumberOfClients() * messageInBytes;

    return estimatedPayloadInBytes > z.conversation.ConversationRepository.CONFIG.EXTERNAL_MESSAGE_THRESHOLD;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.broadcast = z.broadcast || {};

// Broadcast service for all broadcast calls to the backend REST API.
z.broadcast.BroadcastService = class BroadcastService {
  static get CONFIG() {
    return {
      URL_BROADCAST: '/broadcast',
    };
  }

  /**
   * Construct a new Broadcast Service.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.broadcast.BroadcastService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Post an encrypted message to broadcast it.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrBroadcast
   *
   * @param {Object} payload - Payload to be posted
   * @param {Object} payload.recipients - Map with per-recipient data
   * @param {string} payload.sender - Client ID of the sender
   * @param {Array<string>|boolean} preconditionOption - Level that backend checks for missing clients
   * @returns {Promise} Promise that resolve when the message was sent
   */
  postBroadcastMessage(payload, preconditionOption) {
    let url = `${BroadcastService.CONFIG.URL_BROADCAST}/otr/messages`;
    if (_.isArray(preconditionOption)) {
      url = `${url}?report_missing=${preconditionOption.join(',')}`;
    } else if (preconditionOption) {
      url = `${url}?ignore_missing=true`;
    }

    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: url,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cache = z.cache || {};

/**
 * Cache repository for local storage interactions using amplify.
 *
 * @todo We have to come up with a smart solution to handle "amplify.store quota exceeded"
 *  This happened when doing "@cache_repository.set_entity user_et"
 *
 */
z.cache.CacheRepository = class CacheRepository {
  constructor() {
    this.logger = new z.util.Logger('z.auth.CacheRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Deletes cached data.
   *
   * @param {boolean} [keepConversationInput=false] - Should conversation input be kept
   * @param {Array<string>} [protectedKeyPatterns=[z.storage.StorageKey.AUTH.SHOW_LOGIN]] - Keys which should NOT be deleted from the cache
   * @returns {Array<string>} Keys which have been deleted from the cache
   */
  clearCache(keepConversationInput = false, protectedKeyPatterns = [z.storage.StorageKey.AUTH.SHOW_LOGIN]) {
    const deletedKeys = [];

    if (keepConversationInput) {
      protectedKeyPatterns.push(z.storage.StorageKey.CONVERSATION.INPUT);
    }

    for (const storedKey in amplify.store()) {
      const shouldBeDeleted = !protectedKeyPatterns.some(pattern => storedKey.startsWith(pattern));

      if (shouldBeDeleted) {
        z.util.StorageUtil.resetValue(storedKey);
        deletedKeys.push(storedKey);
      }
    }

    return deletedKeys;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_MESSAGE_TYPE = {
  CANCEL: 'CANCEL',
  GROUP_CHECK: 'GROUPCHECK',
  GROUP_LEAVE: 'GROUPLEAVE',
  GROUP_SETUP: 'GROUPSETUP',
  GROUP_START: 'GROUPSTART',
  HANGUP: 'HANGUP',
  PROP_SYNC: 'PROPSYNC',
  REJECT: 'REJECT',
  SETUP: 'SETUP',
  UPDATE: 'UPDATE',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_STATE = {
  CONNECTING: 'connecting',
  DISCONNECTING: 'disconnecting',
  ENDED: 'ended',
  INCOMING: 'incoming',
  ONGOING: 'ongoing',
  OUTGOING: 'outgoing',
  REJECTED: 'rejected',
  UNKNOWN: 'unknown',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_STATE_GROUP = {
  CAN_CONNECT: [
    z.calling.enum.CALL_STATE.INCOMING,
    z.calling.enum.CALL_STATE.ONGOING,
    z.calling.enum.CALL_STATE.REJECTED,
  ],
  CAN_JOIN: [z.calling.enum.CALL_STATE.INCOMING, z.calling.enum.CALL_STATE.REJECTED],
  IS_ACTIVE: [
    z.calling.enum.CALL_STATE.CONNECTING,
    z.calling.enum.CALL_STATE.DISCONNECTING,
    z.calling.enum.CALL_STATE.INCOMING,
    z.calling.enum.CALL_STATE.ONGOING,
    z.calling.enum.CALL_STATE.OUTGOING,
  ],
  IS_ENDED: [z.calling.enum.CALL_STATE.ENDED, z.calling.enum.CALL_STATE.UNKNOWN],
  UNANSWERED: [z.calling.enum.CALL_STATE.INCOMING, z.calling.enum.CALL_STATE.OUTGOING],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.PROPERTY_STATE = {
  FALSE: 'false',
  PAUSED: 'paused',
  TRUE: 'true',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.SDP_NEGOTIATION_MODE = {
  DEFAULT: 'default',
  ICE_RESTART: 'iceRestart',
  STATE_COLLISION: 'stateCollision',
  STREAM_CHANGE: 'streamChange',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.SDP_SOURCE = {
  LOCAL: 'local',
  REMOTE: 'remote',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.TERMINATION_REASON = {
  COMPLETED: 'completed',
  CONCURRENT_CALL: 'concurrent',
  CONNECTION_DROP: 'drop',
  CONNECTION_FAILED: 'failed_ice',
  GROUP_CHECK: 'group_check',
  MEMBER_LEAVE: 'member_leave',
  MISSED: 'missed',
  OTHER_USER: 'other',
  PAGE_NAVIGATION: 'page_navigation',
  RENEGOTIATION: 'renegotiation',
  SDP_FAILED: 'failed_sdp',
  SELF_USER: 'self',
  TIMEOUT: 'timeout',
  UNKNOWN: 'unknown',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// https://w3c.github.io/webrtc-pc/#dom-rtcdatachannelstate
// https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/readyState
z.calling.rtc.DATA_CHANNEL_STATE = {
  CLOSED: 'closed',
  CLOSING: 'closing',
  CONNECTING: 'connecting',
  OPEN: 'open',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtciceconnectionstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.iceConnectionState#Value
z.calling.rtc.ICE_CONNECTION_STATE = {
  CHECKING: 'checking',
  CLOSED: 'closed',
  COMPLETED: 'completed',
  CONNECTED: 'connected',
  DISCONNECTED: 'disconnected',
  FAILED: 'failed',
  NEW: 'new',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcicegatheringstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.iceGatheringState#Value
z.calling.rtc.ICE_GATHERING_STATE = {
  COMPLETE: 'complete',
  GATHERING: 'gathering',
  NEW: 'new',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcsdptype
// https://developer.mozilla.org/en-US/docs/Web/API/RTCSessionDescription#RTCSdpType
z.calling.rtc.SDP_TYPE = {
  ANSWER: 'answer',
  LOCAL: 'local',
  OFFER: 'offer',
  PROVISIONAL_ANSWER: 'pranswer',
  REMOTE: 'remote',
  ROLLBACK: 'rollback',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcpeerstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.signalingState#Value
z.calling.rtc.SIGNALING_STATE = {
  CLOSED: 'closed',
  LOCAL_OFFER: 'have-local-offer',
  LOCAL_PROVISIONAL_ANSWER: 'have-local-pranswer',
  NEW: 'new',
  REMOTE_OFFER: 'have-remote-offer',
  REMOTE_PROVISIONAL_ANSWER: 'have-remote-pranswer',
  STABLE: 'stable',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// https://www.w3.org/TR/webrtc/#dom-rtcstatstype
z.calling.rtc.STATS_TYPE = {
  CANDIDATE_PAIR: 'candidate-pair',
  GOOGLE_CANDIDATE_PAIR: 'googCandidatePair',
  INBOUND_RTP: 'inbound-rtp',
  OUTBOUND_RTP: 'outbound-rtp',
  SSRC: 'ssrc',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.CallEntity = class CallEntity {
  static get CONFIG() {
    return {
      GROUP_CHECK: {
        ACTIVITY_TIMEOUT: 2 * 60,
        MAXIMUM_TIMEOUT: 90,
        MINIMUM_TIMEOUT: 60,
      },
      STATE_TIMEOUT: 60 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      TIMER: {
        INIT_THRESHOLD: 100,
        UPDATE_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    };
  }

  /**
   * Construct a new call entity.
   *
   * @class z.calling.entities.Call
   * @param {z.entity.Conversation} conversationEntity - Conversation the call takes place in
   * @param {z.entity.User} creatingUser - Entity of user starting the call
   * @param {string} sessionId - Session ID to identify call
   * @param {z.calling.CallingRepository} callingRepository - Calling Repository
   */
  constructor(conversationEntity, creatingUser, sessionId, callingRepository) {
    this.conversationEntity = conversationEntity;
    this.creatingUser = creatingUser;
    this.sessionId = sessionId;
    this.callingRepository = callingRepository;

    const {id: conversationId, isGroup} = conversationEntity;
    const {mediaStreamHandler, mediaRepository, selfStreamState, telemetry, userRepository} = this.callingRepository;
    this.messageLog = this.callingRepository.messageLog;

    this.id = conversationId;

    const loggerName = 'z.calling.entities.CallEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info(`Created new call entity in conversation ${this.id}`);

    // IDs and references
    this.timings = undefined;

    this.mediaRepository = mediaRepository;
    this.userRepository = userRepository;
    this.selfUser = this.userRepository.self();
    this.selfState = selfStreamState;
    this.telemetry = telemetry;

    // States
    this.callTimerInterval = undefined;
    this.timerStart = undefined;
    this.durationTime = ko.observable(0);
    this.groupCheckTimeoutId = undefined;
    this.terminationReason = undefined;

    this.isConnected = ko.observable(false);
    this.isGroup = isGroup();

    this.selfClientJoined = ko.observable(false);
    this.selfUserJoined = ko.observable(false);
    this.state = ko.observable(z.calling.enum.CALL_STATE.UNKNOWN);
    this.previousState = undefined;

    this.participants = ko.observableArray([]);
    this.interruptedParticipants = ko.observableArray([]);

    // Media
    this.localMediaStream = mediaStreamHandler.localMediaStream;
    this.localMediaType = mediaStreamHandler.localMediaType;
    this.remoteMediaType = ko.observable(z.media.MediaType.NONE);

    // Statistics
    this._resetTimer();

    // Computed values
    this.isConnecting = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.CONNECTING);
    this.isDeclined = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.REJECTED);
    this.isDisconnecting = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.DISCONNECTING);
    this.isIncoming = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.INCOMING);
    this.isOngoing = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.ONGOING);
    this.isOutgoing = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.OUTGOING);

    this.canConnectState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.CAN_CONNECT.includes(this.state()));
    this.canJoinState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.CAN_JOIN.includes(this.state()));
    this.isActiveState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.IS_ACTIVE.includes(this.state()));
    this.isEndedState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.IS_ENDED.includes(this.state()));

    this.isOngoingOnAnotherClient = ko.pureComputed(() => this.selfUserJoined() && !this.selfClientJoined());
    this.isRemoteScreenSend = ko.pureComputed(() => this.remoteMediaType() === z.media.MediaType.SCREEN);
    this.isRemoteVideoSend = ko.pureComputed(() => this.remoteMediaType() === z.media.MediaType.VIDEO);

    this.isLocalVideoCall = ko.pureComputed(() => this.selfState.screenSend() || this.selfState.videoSend());
    this.isRemoteVideoCall = ko.pureComputed(() => this.isRemoteScreenSend() || this.isRemoteVideoSend());

    this.networkInterruption = ko.pureComputed(() => {
      if (this.isConnected() && !this.isGroup) {
        return this.interruptedParticipants().length > 0;
      }

      return false;
    });

    ko.pureComputed(() => {
      const additionalCount = this.selfClientJoined() ? 1 : 0;
      return this.participants().length + additionalCount;
    }).subscribe(numberOfParticipants => {
      this.telemetry.numberOfParticipantsChanged(numberOfParticipants);
    });

    // Observable subscriptions
    this.wasConnected = false;
    this.isConnected.subscribe(isConnected => {
      if (isConnected) {
        this.wasConnected = true;
        if (this.isGroup) {
          this.scheduleGroupCheck();
        }

        this.telemetry.track_event(z.tracking.EventName.CALLING.ESTABLISHED_CALL, this);
        this.timerStart = Date.now() - CallEntity.CONFIG.TIMER.INIT_THRESHOLD;

        this.callTimerInterval = window.setInterval(() => {
          const durationInSeconds = Math.floor((Date.now() - this.timerStart) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
          this.durationTime(durationInSeconds);
        }, CallEntity.CONFIG.TIMER.UPDATE_INTERVAL);
      }
    });

    this.isDeclined.subscribe(isDeclined => {
      if (isDeclined) {
        this._stopRingTone(true);
      }
    });

    this.networkInterruption.subscribe(isInterrupted => {
      if (isInterrupted) {
        return amplify.publish(z.event.WebApp.AUDIO.PLAY_IN_LOOP, z.audio.AudioType.NETWORK_INTERRUPTION);
      }
      amplify.publish(z.event.WebApp.AUDIO.STOP, z.audio.AudioType.NETWORK_INTERRUPTION);
    });

    this.selfClientJoined.subscribe(isJoined => {
      if (!isJoined) {
        this.isConnected(false);

        if (this.isOngoing() || this.isDisconnecting()) {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.TALK_LATER);
        }

        if (this.terminationReason) {
          this.telemetry.track_duration(this);
        }

        this._resetTimer();
        this._resetFlows();
      }
    });

    this.state.subscribe(state => {
      const logMessage = {
        data: {
          default: [this.id, state],
          obfuscated: [this.callLogger.obfuscate(this.id), state],
        },
        message: `Call state '{0}' changed to '{1}'`,
      };
      this.callLogger.info(logMessage);

      this._clearStateTimeout();

      const hasState = state !== z.calling.enum.CALL_STATE.UNKNOWN;
      if (hasState) {
        const isUnansweredState = z.calling.enum.CALL_STATE_GROUP.UNANSWERED.includes(state);
        if (isUnansweredState) {
          const isIncomingCall = state === z.calling.enum.CALL_STATE.INCOMING;
          this._onStateStartRinging(isIncomingCall);
        } else {
          this._onStateStopRinging();
        }
      }

      const isConnectingCall = state === z.calling.enum.CALL_STATE.CONNECTING;
      if (isConnectingCall) {
        this.telemetry.track_event(z.tracking.EventName.CALLING.JOINED_CALL, this);
      }

      this.previousState = state;
    });

    if (this.isGroup) {
      this.scheduleGroupCheck();
    }

    this.conversationEntity.call(this);
  }

  //##############################################################################
  // Call states
  //##############################################################################

  /**
   * Deactivate the call.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message for deactivation
   * @param {boolean} fromSelf - Deactivation triggered by self user change
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason=z.calling.enum.TERMINATION_REASON.SELF_USER] - Call termination reason
   * @returns {Promise<boolean>} Resolves with a boolean whether the call was deleted
   */
  deactivateCall(callMessageEntity, fromSelf, terminationReason = z.calling.enum.TERMINATION_REASON.SELF_USER) {
    this._clearTimeouts();

    const everyoneLeft = this.participants().length <= 0 + fromSelf ? 1 : 0;
    const onGroupCheck = terminationReason === z.calling.enum.TERMINATION_REASON.GROUP_CHECK;

    const shouldDeleteCall = everyoneLeft || onGroupCheck;
    if (shouldDeleteCall) {
      this.terminationReason = terminationReason;
      this._deleteCall(callMessageEntity, everyoneLeft, onGroupCheck);
      return Promise.resolve(true);
    }

    if (this.isGroup) {
      this.scheduleGroupCheck();
    }

    this.callingRepository.mediaStreamHandler.resetMediaStream();
    return Promise.resolve(false);
  }

  _deleteCall(callMessageEntity, everyoneLeft, onGroupCheck) {
    const reason = !this.wasConnected
      ? z.calling.enum.TERMINATION_REASON.MISSED
      : z.calling.enum.TERMINATION_REASON.COMPLETED;

    if (onGroupCheck && !everyoneLeft) {
      const userIds = this.participants().map(participantEntity => participantEntity.id);
      this.callLogger.warn(`Deactivation on group check with remaining users '${userIds.join(', ')}' on group check`);
    }

    const eventSource = onGroupCheck
      ? z.event.EventRepository.SOURCE.INJECTED
      : z.event.EventRepository.SOURCE.WEB_SOCKET;

    callMessageEntity.userId = this.creatingUser.id;
    this.callingRepository.injectDeactivateEvent(callMessageEntity, eventSource, reason);

    return this.callingRepository.deleteCall(this.id);
  }

  /**
   * Delete the call.
   * @returns {undefined} No return value
   */
  deleteCall() {
    this.state(z.calling.enum.CALL_STATE.ENDED);
    this._resetCall();
  }

  /**
   * Join the call.
   * @param {z.media.MediaType} [mediaType] - Media type of the call
   * @returns {void} No return value
   */
  joinCall(mediaType) {
    if (this.canConnectState()) {
      this.state(z.calling.enum.CALL_STATE.CONNECTING);
    }

    return this.isGroup ? this._joinGroupCall(mediaType) : this._join1to1Call();
  }

  /**
   * Join the 1:1 call.
   * @private
   * @returns {void} No return value
   */
  _join1to1Call() {
    const [remoteUserId] = this.conversationEntity.participating_user_ids();
    this.addOrUpdateParticipant(remoteUserId, true);
  }

  /**
   * Join group call.
   *
   * @private
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type of the call
   * @returns {void} No return value
   */
  _joinGroupCall(mediaType = z.media.MediaType.AUDIO) {
    const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;

    const response = !this.isOutgoing();
    const propSync = z.calling.CallMessageBuilder.createPropSync(this.selfState, additionalPayload, videoSend);

    const callMessageEntity = z.calling.CallMessageBuilder.buildGroupStart(response, this.sessionId, propSync);
    this.sendCallMessage(callMessageEntity);
  }

  /**
   * Leave the call.
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Call termination reason
   * @returns {undefined} No return value
   */
  leaveCall(terminationReason) {
    if (this.isOngoing() && !this.isGroup) {
      this.state(z.calling.enum.CALL_STATE.DISCONNECTING);
    }

    let callMessageEntity = this.isConnected()
      ? z.calling.CallMessageBuilder.buildHangup(false, this.sessionId)
      : z.calling.CallMessageBuilder.buildCancel(false, this.sessionId);

    const eventPromises = this.getFlows().map(({remoteClientId, remoteUserId}) => {
      const payload = z.calling.CallMessageBuilder.createPayload(
        this.id,
        this.selfUser.id,
        remoteUserId,
        remoteClientId
      );
      callMessageEntity.addProperties(payload);
      return this.sendCallMessage(callMessageEntity);
    });

    Promise.all(eventPromises)
      .then(() => Promise.all(this.participants().map(({id}) => this.resetParticipant(id))))
      .then(() => {
        const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);

        if (this.isGroup) {
          callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, this.sessionId, additionalPayload);
          this.sendCallMessage(callMessageEntity);
        } else {
          callMessageEntity.addProperties(additionalPayload);
        }

        this.setSelfState(false, terminationReason);
        return this.deactivateCall(callMessageEntity, true, terminationReason);
      })
      .then(wasDeleted => {
        if (!wasDeleted) {
          this.state(z.calling.enum.CALL_STATE.REJECTED);
        }
      });
  }

  /**
   * Check if group call should continue after participant left.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Last member leaving call
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call participant to leave
   * @returns {undefined} No return value
   */
  participantLeft(callMessageEntity, terminationReason) {
    if (!this.participants().length) {
      return this.selfClientJoined()
        ? this.leaveCall(terminationReason)
        : this.deactivateCall(callMessageEntity, false, terminationReason);
    }
  }

  /**
   * Reject the call.
   * @param {boolean} [shareRejection=false] - Send rejection message to other clients
   * @returns {undefined} No return value
   */
  rejectCall(shareRejection = false) {
    this.state(z.calling.enum.CALL_STATE.REJECTED);
    if (this.isRemoteVideoCall()) {
      this.callingRepository.mediaStreamHandler.resetMediaStream();
    }

    if (shareRejection) {
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
      const callMessageEntity = z.calling.CallMessageBuilder.buildReject(false, this.sessionId, additionalPayload);
      this.sendCallMessage(callMessageEntity);
    }
  }

  /**
   * Schedule the check for group activity.
   * @returns {undefined} No return value
   */
  scheduleGroupCheck() {
    this._clearGroupCheckTimeout();
    return this.isConnected() ? this._setSendGroupCheckTimeout() : this._setVerifyGroupCheckTimeout();
  }

  /**
   * Set the self state.
   * @param {boolean} joinedState - Self joined state
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason] - Call termination reason
   * @returns {undefined} No return value
   */
  setSelfState(joinedState, terminationReason) {
    if (terminationReason && !this.terminationReason) {
      this.terminationReason = terminationReason;
    }
    this.selfClientJoined(joinedState);
    this.selfUserJoined(joinedState);
  }

  /**
   * Toggle media of this call.
   * @param {z.media.MediaType} mediaType - MediaType to toggle
   * @returns {Promise} Resolves when state has been toggled
   */
  toggleMedia(mediaType) {
    const toggledVideo = mediaType === z.media.MediaType.SCREEN && !this.selfState.videoSend();
    const toggledScreen = mediaType === z.media.MediaType.VIDEO && !this.selfState.screenSend();
    if (toggledVideo || toggledScreen) {
      this.telemetry.setAVToggled();
    }

    const callEventPromises = this.getFlows().map(({remoteClientId, remoteUserId}) => {
      const payload = z.calling.CallMessageBuilder.createPayload(
        this.id,
        this.selfUser.id,
        remoteUserId,
        remoteClientId
      );
      const propSyncPayload = z.calling.CallMessageBuilder.createPropSync(this.selfState, payload);

      const callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(false, this.sessionId, propSyncPayload);
      return this.sendCallMessage(callMessageEntity);
    });

    return Promise.all(callEventPromises);
  }

  /**
   * Clear the group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearGroupCheckTimeout() {
    if (this.groupCheckTimeoutId) {
      this.callLogger.debug(`Clear group check timeout with ID '${this.groupCheckTimeoutId}'`);
      window.clearTimeout(this.groupCheckTimeoutId);
      this.groupCheckTimeoutId = undefined;
    }
  }

  /**
   * Clear all timeouts.
   * @private
   * @returns {undefined} No return value
   */
  _clearTimeouts() {
    this.getFlows().map(flowEntity => flowEntity.clearTimeouts());
    this._clearGroupCheckTimeout();
    this._clearStateTimeout();
  }

  /**
   * Leave group call or schedule sending new group check after timeout.
   *
   * @private
   * @param {number} timeout - Random timeout in seconds
   * @returns {undefined} No return value
   */
  _onSendGroupCheckTimeout(timeout) {
    if (this.participants().length) {
      this.callLogger.info(`Sending group check after timeout of '${timeout}s' (ID: ${this.groupCheckTimeoutId})`);
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
      const callMessageEntity = z.calling.CallMessageBuilder.buildGroupCheck(true, this.sessionId, additionalPayload);

      this.sendCallMessage(callMessageEntity);
      return this.scheduleGroupCheck();
    }

    this.leaveCall(z.calling.enum.TERMINATION_REASON.OTHER_USER);
  }

  /**
   * Remove group call after timeout.
   * @private
   * @returns {undefined} No return value
   */
  _onVerifyGroupCheckTimeout() {
    this.callLogger.info(`Removing on group check timeout (ID: ${this.groupCheckTimeoutId})`);
    const additionalPayload = z.calling.CallMessageBuilder.createPayload(
      this.id,
      this.selfUser.id,
      this.creatingUser.id
    );
    const callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, this.sessionId, additionalPayload);

    this.deactivateCall(callMessageEntity, false, z.calling.enum.TERMINATION_REASON.GROUP_CHECK);
  }

  /**
   * Set the outgoing group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setSendGroupCheckTimeout() {
    const {MAXIMUM_TIMEOUT, MINIMUM_TIMEOUT} = CallEntity.CONFIG.GROUP_CHECK;
    const timeoutInSeconds = z.util.NumberUtil.getRandomNumber(MINIMUM_TIMEOUT, MAXIMUM_TIMEOUT);

    const timeout = timeoutInSeconds * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    this.groupCheckTimeoutId = window.setTimeout(() => this._onSendGroupCheckTimeout(timeoutInSeconds), timeout);

    const timeoutId = this.groupCheckTimeoutId;
    this.callLogger.debug(`Set sending group check after timeout of '${timeoutInSeconds}s' (ID: ${timeoutId})`);
  }

  /**
   * Set the incoming group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setVerifyGroupCheckTimeout() {
    const ACTIVITY_TIMEOUT = CallEntity.CONFIG.GROUP_CHECK.ACTIVITY_TIMEOUT;
    const timeout = ACTIVITY_TIMEOUT * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;

    this.groupCheckTimeoutId = window.setTimeout(() => this._onVerifyGroupCheckTimeout(), timeout);
    this.callLogger.debug(`Set verifying group check after '${ACTIVITY_TIMEOUT}s' (ID: ${this.groupCheckTimeoutId})`);
  }

  //##############################################################################
  // Call states
  //##############################################################################

  /**
   * Confirm an incoming message.
   * @param {z.calling.entities.CallMessageEntity} incomingCallMessageEntity - Incoming call message to be confirmed
   * @returns {Promise} Resolves when message was confirmed
   */
  confirmMessage(incomingCallMessageEntity) {
    const {clientId, type, userId} = incomingCallMessageEntity;
    const payload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id, userId, clientId);

    let callMessageEntity;
    switch (type) {
      case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP: {
        callMessageEntity = z.calling.CallMessageBuilder.buildHangup(true, this.sessionId, payload);
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        const propSyncPayload = z.calling.CallMessageBuilder.createPropSync(this.selfState, payload);

        callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(true, this.sessionId, propSyncPayload);
        break;
      }

      default: {
        this.callLogger.error(`Tried to confirm call event of wrong type '${type}'`, callMessageEntity);
        return Promise.resolve();
      }
    }

    return this.sendCallMessage(callMessageEntity);
  }

  /**
   * Send call message.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be send
   * @returns {Promise} Resolves when the event has been send
   */
  sendCallMessage(callMessageEntity) {
    return this.callingRepository.sendCallMessage(this.conversationEntity, callMessageEntity);
  }

  /**
   * Set remote version of call
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to get remote version from
   * @returns {undefined} No return value
   */
  setRemoteVersion(callMessageEntity) {
    const rtcSdp = callMessageEntity.sdp;

    if (rtcSdp) {
      this.telemetry.set_remote_version(z.calling.SDPMapper.getToolVersion(rtcSdp));
    }
  }

  /**
   * Clear the state timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearStateTimeout() {
    if (this.stateTimeout) {
      window.clearTimeout(this.stateTimeout);
      this.stateTimeout = undefined;
    }
  }

  /**
   * Start ringing sound.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _onStateStartRinging(isIncoming) {
    this._playRingTone(isIncoming);
    this._setStateTimeout(isIncoming);
  }

  /**
   * Stop ringing sound.
   * @private
   * @returns {undefined} No return value
   */
  _onStateStopRinging() {
    const wasUnanswered = z.calling.enum.CALL_STATE_GROUP.UNANSWERED.includes(this.previousState);
    if (wasUnanswered) {
      const wasIncomingCall = this.previousState === z.calling.enum.CALL_STATE.INCOMING;
      this._stopRingTone(wasIncomingCall);
    }
  }

  /**
   * Play the ring tone.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _playRingTone(isIncoming) {
    const audioId = isIncoming ? z.audio.AudioType.INCOMING_CALL : z.audio.AudioType.OUTGOING_CALL;
    amplify.publish(z.event.WebApp.AUDIO.PLAY_IN_LOOP, audioId);
  }

  /**
   * Set the state timeout.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _setStateTimeout(isIncoming) {
    this.stateTimeout = window.setTimeout(() => {
      this._stopRingTone(isIncoming);

      if (isIncoming) {
        return this.isGroup ? this.rejectCall(false) : amplify.publish(z.event.WebApp.CALL.STATE.DELETE, this.id);
      }

      amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.id, z.calling.enum.TERMINATION_REASON.TIMEOUT);
    }, CallEntity.CONFIG.STATE_TIMEOUT);
  }

  /**
   * Stop the ring tone.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _stopRingTone(isIncoming) {
    const audioId = isIncoming ? z.audio.AudioType.INCOMING_CALL : z.audio.AudioType.OUTGOING_CALL;
    amplify.publish(z.event.WebApp.AUDIO.STOP, audioId);
  }

  /**
   * Update the remote participant state.
   * @private
   * @returns {undefined} No return value
   */
  _updateRemoteState() {
    let mediaTypeChanged = false;

    this.participants().forEach(({activeState}) => {
      if (activeState.screenSend()) {
        this.remoteMediaType(z.media.MediaType.SCREEN);
        mediaTypeChanged = true;
      } else if (activeState.videoSend()) {
        this.remoteMediaType(z.media.MediaType.VIDEO);
        mediaTypeChanged = true;
      }
    });

    if (!mediaTypeChanged) {
      this.remoteMediaType(z.media.MediaType.AUDIO);
    }
  }

  //##############################################################################
  // Participants
  //##############################################################################

  /**
   * Add or update a participant of the call.
   *
   * @param {string} userId - User ID of the call participant
   * @param {boolean} negotiate - Should negotiation be started immediately
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message for participant change
   * @returns {Promise} Resolves with participant entity
   */
  addOrUpdateParticipant(userId, negotiate, callMessageEntity) {
    return this.getParticipantById(userId)
      .then(participantEntity => this._updateParticipant(participantEntity, negotiate, callMessageEntity))
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (isNotFound) {
          return this._addParticipant(userId, negotiate, callMessageEntity);
        }

        throw error;
      });
  }

  /**
   * Remove an participant from the call.
   *
   * @param {string} userId - ID of user to be removed from the call
   * @param {string} clientId - ID of client that requested the removal from the call
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Call termination reason
   * @returns {Promise} Resolves with the call entity
   */
  deleteParticipant(userId, clientId, terminationReason) {
    return this.getParticipantById(userId)
      .then(participantEntity => {
        if (clientId) {
          participantEntity.verifyClientId(clientId);
        }

        participantEntity.resetParticipant();
        this.interruptedParticipants.remove(participantEntity);
        this.participants.remove(participantEntity);

        this._updateRemoteState();
        this.callingRepository.mediaElementHandler.removeMediaElement(userId);

        if (this.selfClientJoined()) {
          switch (terminationReason) {
            case z.calling.enum.TERMINATION_REASON.OTHER_USER: {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.TALK_LATER);
              break;
            }

            case z.calling.enum.TERMINATION_REASON.CONNECTION_DROP:
            case z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE: {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.CALL_DROP);
              break;
            }

            default: {
              break;
            }
          }
        }

        const logMessage = {
          data: {
            default: [participantEntity.user.name()],
            obfuscated: [this.callLogger.obfuscate(participantEntity.user.id)],
          },
          message: `Removed call participant '{0}'`,
        };
        this.callLogger.info(logMessage);
        return this;
      })
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (isNotFound) {
          return this;
        }

        throw error;
      });
  }

  /**
   * Get a call participant by his id.
   * @param {string} userId - User ID of participant to be returned
   * @returns {Promise} Resolves with the call participant that matches given user ID
   */
  getParticipantById(userId) {
    for (const participantEntity of this.participants()) {
      const isExpectedId = participantEntity.id === userId;
      if (isExpectedId) {
        return Promise.resolve(participantEntity);
      }
    }

    return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND, 'No participant found for user ID'));
  }

  /**
   * Remove an participant from the call.
   * @param {string} userId - ID of user to be removed from the call
   * @returns {Promise} Resolves with the call entity
   */
  resetParticipant(userId) {
    return this.getParticipantById(userId).then(participantEntity => {
      participantEntity.resetParticipant();
      this.interruptedParticipants.remove(participantEntity);

      this._updateRemoteState();
      this.callingRepository.mediaElementHandler.removeMediaElement(userId);
    });
  }

  /**
   * Verify call message belongs to call by session id.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity
   * @returns {Promise} Resolves with the Call entity if verification passed
   */
  verifySessionId(callMessageEntity) {
    const {userId, sessionId} = callMessageEntity;

    const isExpectedSessionId = sessionId === this.sessionId;
    if (isExpectedSessionId) {
      return Promise.resolve(this);
    }

    return this.getParticipantById(userId).then(({sessionId: participantSessionId}) => {
      const isExpectedParticipantSessionId = sessionId === participantSessionId;
      if (isExpectedParticipantSessionId) {
        return this;
      }

      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Session IDs not matching');
    });
  }

  /**
   * Add an participant to the call.
   *
   * @param {string} userId - User ID to be added to the call
   * @param {boolean} negotiate - Should negotiation be started immediately
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message entity for participant change
   * @returns {Promise} Resolves with the added participant
   */
  _addParticipant(userId, negotiate, callMessageEntity) {
    const isSelfUser = userId === this.selfUser.id;
    if (isSelfUser) {
      const errorMessage = 'Self user should not be added as call participant';
      return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.WRONG_STATE, errorMessage));
    }

    return this.userRepository.get_user_by_id(userId).then(userEntity => {
      const participantEntity = new z.calling.entities.ParticipantEntity(this, userEntity, this.timings);

      this.participants.push(participantEntity);

      const logMessage = {
        data: {
          default: [userEntity.name()],
          obfuscated: [this.callLogger.obfuscate(userEntity.id)],
        },
        message: `Adding call participant '{0}'`,
      };
      this.callLogger.info(logMessage, participantEntity);

      return this._updateParticipantState(participantEntity, negotiate, callMessageEntity);
    });
  }

  /**
   * Update call participant with call message.
   *
   * @param {z.calling.entities.ParticipantEntity} participantEntity - Participant entity to be updated in the call
   * @param {boolean} negotiate - Should negotiation be started
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to update user with
   * @returns {Promise} Resolves with the updated participant
   */
  _updateParticipant(participantEntity, negotiate, callMessageEntity) {
    if (callMessageEntity && callMessageEntity.clientId) {
      participantEntity.verifyClientId(callMessageEntity.clientId);
    }

    const logMessage = {
      data: {
        default: [participantEntity.user.name()],
        obfuscated: [this.callLogger.obfuscate(participantEntity.user.id)],
      },
      message: `Updating call participant '{0}'`,
    };
    this.callLogger.info(logMessage, callMessageEntity);

    return this._updateParticipantState(participantEntity, negotiate, callMessageEntity);
  }

  /**
   * Update call participant state.
   *
   * @param {z.calling.entities.ParticipantEntity} participantEntity - User ID to be added to the call
   * @param {boolean} negotiate - Should negotiation be started
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message to update user with
   * @returns {Promise} Resolves with the updated participant
   */
  _updateParticipantState(participantEntity, negotiate, callMessageEntity) {
    const updatePromise = callMessageEntity ? participantEntity.updateState(callMessageEntity) : Promise.resolve(false);

    return updatePromise.then(skipNegotiation => {
      if (skipNegotiation) {
        negotiate = false;
      }

      this._updateRemoteState();

      if (negotiate) {
        participantEntity.startNegotiation();
      }

      return participantEntity;
    });
  }

  //##############################################################################
  // Misc
  //##############################################################################

  /**
   * Get all flows of the call.
   * @returns {Array<z.calling.entities.FlowEntity>} Array of flows
   */
  getFlows() {
    return this.participants()
      .filter(participantEntity => participantEntity.flowEntity)
      .map(participantEntity => participantEntity.flowEntity);
  }

  /**
   * Get full flow telemetry report of the call.
   * @returns {Array<Object>} Array of flow telemetry reports for calling service automation
   */
  getFlowTelemetry() {
    return this.getFlows().map(flowEntity => flowEntity.getTelemetry());
  }

  /**
   * Initiate the call telemetry.
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @returns {undefined} No return value
   */
  initiateTelemetry(direction, mediaType = z.media.MediaType.AUDIO) {
    this.telemetry.initiateNewCall(direction, mediaType);
    this.timings = new z.telemetry.calling.CallSetupTimings(this.id);
  }

  /**
   * Calculates the panning (from left to right) to position a user in a group call.
   *
   * @private
   * @param {number} index - Index of a user in a sorted array
   * @param {number} numberOfParticipants - Number of participants
   * @returns {number} Panning in the range of -1 to 1 with -1 on the left
   */
  _calculatePanning(index, numberOfParticipants) {
    const isSingleUser = numberOfParticipants === 1;
    if (isSingleUser) {
      return 0.0;
    }

    const position = -(numberOfParticipants - 1.0) / (numberOfParticipants + 1.0);
    const delta = (-2.0 * position) / (numberOfParticipants - 1.0);

    return position + delta * index;
  }

  /**
   * Sort the call participants by their audio panning.
   *
   * @note The idea is to calculate Jenkins' one-at-a-time hash (JOAAT) for each participant and then
   *  sort all participants in an array by their JOAAT hash. After that the array index of each user
   *  is used to allocate the position with the return value of this function.
   *
   * @returns {undefined} No return value
   */
  _sortParticipantsByPanning() {
    const twoOrMoreParticipants = this.participants().length >= 2;
    if (twoOrMoreParticipants) {
      this.participants()
        .sort((participantA, participantB) => participantA.user.joaatHash - participantB.user.joaatHash)
        .forEach((participantEntity, index) => {
          const panning = this._calculatePanning(index, this.participants().length);

          this.callLogger.debug({
            data: {
              default: [participantEntity.user.name(), panning],
              obfuscated: [this.callLogger.obfuscate(participantEntity.user.id), panning],
            },
            message: `Panning for '{0}' recalculated to '{1}'`,
          });

          participantEntity.panning(panning);
        });

      const panningOrder = this.participants()
        .map(({user}) => user.name())
        .join(', ');

      this.callLogger.info(`New panning order: ${panningOrder}`);
    }
  }

  //##############################################################################
  // Reset
  //##############################################################################

  /**
   * Reset the call states.
   * @private
   * @returns {undefined} No return value
   */
  _resetCall() {
    this.setSelfState(false);
    this.isConnected(false);
    this.sessionId = undefined;
    this.terminationReason = undefined;
    amplify.publish(z.event.WebApp.AUDIO.STOP, z.audio.AudioType.NETWORK_INTERRUPTION);
  }

  /**
   * Reset the call timers.
   * @private
   * @returns {undefined} No return value
   */
  _resetTimer() {
    if (this.callTimerInterval) {
      window.clearInterval(this.callTimerInterval);
      this.timerStart = undefined;
    }
    this.durationTime(0);
  }

  /**
   * Reset all flows of the call.
   * @private
   * @returns {undefined} No return value
   */
  _resetFlows() {
    this.getFlows().forEach(flowEntity => flowEntity.resetFlow());
  }

  needsMediaStream() {
    const hasPreJoinVideo = this.isIncoming() && this.isRemoteVideoCall();
    const hasActiveCall = hasPreJoinVideo || this.selfClientJoined();
    return hasActiveCall && !this.isOngoingOnAnotherClient();
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Log flow status to console.
   * @returns {undefined} No return value
   */
  logStatus() {
    this.getFlows().forEach(flowEntity => flowEntity.logStatus());
  }

  /**
   * Log flow setup step timings to console.
   * @returns {undefined} No return value
   */
  logTimings() {
    this.getFlows().forEach(flowEntity => flowEntity.logTimings());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.CallMessageEntity = class CallMessageEntity {
  static get CONFIG() {
    return {
      PAYLOAD_TYPES: {
        PROPS: [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
          z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
        SDP: [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
        TARGETED: [
          z.calling.enum.CALL_MESSAGE_TYPE.CANCEL,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
      },
      SESSION_ID_LENGTH: 4,
      VERSION: '3.0',
    };
  }

  /**
   * Construct a new call message entity.
   *
   * @class z.calling.entities.CallMessageEntity
   * @param {z.calling.enum.CALL_MESSAGE_TYPE} type - Type of call message
   * @param {boolean} [response=false] - Is message a response, defaults to false
   * @param {string} sessionId - Optional session ID
   */
  constructor(type, response = false, sessionId) {
    this.type = type;
    this.response = response;
    this.sessionId = sessionId || this._createSessionId();
  }

  /**
   * Add additional payload to message.
   * @param {Object} [additionalProperties={}] - Optional object containing additional message payload
   * @returns {undefined} No return value
   */
  addProperties(additionalProperties = {}) {
    Object.entries(additionalProperties).forEach(([key, value]) => (this[key] = value));
  }

  /**
   * Cast call message to JSON.
   * @returns {{version: string, resp: boolean, sessid: string, type: z.calling.enum.CALL_MESSAGE_TYPE}} - JSON representation of call message
   */
  toJSON() {
    const json_payload = {
      resp: this.response,
      sessid: this.sessionId,
      type: this.type,
      version: CallMessageEntity.CONFIG.VERSION,
    };

    const isPropsMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.PROPS.includes(this.type);
    if (isPropsMessageType) {
      json_payload.props = this.properties;
      const isTypePropSync = this.type === z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC;
      if (!isTypePropSync) {
        json_payload.sdp = this.sdp;
      }
    }

    const isSdpMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.SDP.includes(this.type);
    if (isSdpMessageType) {
      json_payload.sdp = this.sdp;
    }

    const isTargetedMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.TARGETED.includes(this.type);
    if (isTargetedMessageType) {
      json_payload.dest_clientid = this.remoteClientId;
      json_payload.dest_userid = this.remoteUserId;
    }

    return json_payload;
  }

  /**
   * Cast call message to string.
   * @returns {string} Stringified JSON representation of call message
   */
  toContentString() {
    return JSON.stringify(this.toJSON());
  }

  /**
   * Create a session ID.
   * @private
   * @returns {string} Random char session ID of length CallMessageEntity.CONFIG.SESSION_ID_LENGTH
   */
  _createSessionId() {
    return _.range(CallMessageEntity.CONFIG.SESSION_ID_LENGTH)
      .map(() => z.util.StringUtil.getRandomChar())
      .join('');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.FlowEntity = class FlowEntity {
  static get CONFIG() {
    return {
      DATA_CHANNEL_LABEL: 'calling-3.0',
      MAX_ICE_CANDIDATE_GATHERING_ATTEMPTS: 5,
      NEGOTIATION_THRESHOLD: 0.5 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      RECONNECTION_TIMEOUT: 2.5 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      RENEGOTIATION_TIMEOUT: 30 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      SDP_SEND_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
    };
  }

  /**
   * Construct a new flow entity.
   *
   * @class z.calling.entities.FlowEntity
   * @param {z.calling.entities.CallEntity} callEntity - Call entity that the flow belongs to
   * @param {z.calling.entities.ParticipantEntity} participantEntity - Participant entity that the flow belongs to
   * @param {CallSetupTimings} timings - Timing statistics of call setup steps
   */
  constructor(callEntity, participantEntity, timings) {
    this.callingRepository = callEntity.callingRepository;

    this.callEntity = callEntity;
    this.participantEntity = participantEntity;

    this.id = this.participantEntity.id;
    this.conversationId = this.callEntity.id;
    this.messageLog = this.participantEntity.messageLog;

    const loggerName = 'z.calling.entities.FlowEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    // States
    this.isAnswer = ko.observable(false);
    this.selfState = this.callEntity.selfState;

    // Users
    this.remoteClientId = undefined;
    this.remoteUser = this.participantEntity.user;
    this.remoteUserId = this.remoteUser.id;
    this.selfUser = this.callEntity.selfUser;
    this.selfUserId = this.selfUser.id;

    // Audio
    this.audio = new z.calling.entities.FlowAudioEntity(this, this.callingRepository.mediaRepository);

    // Telemetry
    this.telemetry = new z.telemetry.calling.FlowTelemetry(this.id, this.remoteUserId, this.callEntity, timings);

    this.callLogger.info({
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Created new flow entity for user {0}`,
    });

    //##############################################################################
    // PeerConnection
    //##############################################################################

    this.peerConnection = undefined;
    /*
      Because Chrome seems to not have the `getConfiguration` method on the peerConnection object when connection is not established,
      we also need to keep track of the configuration we feed the peerConnection.
      It might need reconsideration when Chrome 70 is out https://www.chromestatus.com/feature/5271355306016768
    */
    this.peerConnectionConfiguration = undefined;
    this.iceCandidatesGatheringAttempts = 1;
    this.pcInitialized = ko.observable(false);

    this.mediaStream = this.callEntity.localMediaStream;
    this.dataChannel = undefined;
    this.dataChannelOpened = false;

    this.connectionState = ko.observable(z.calling.rtc.ICE_CONNECTION_STATE.NEW);
    this.gatheringState = ko.observable(z.calling.rtc.ICE_GATHERING_STATE.NEW);
    this.signalingState = ko.observable(z.calling.rtc.SIGNALING_STATE.NEW);

    this.connectionState.subscribe(iceConnectionState => {
      switch (iceConnectionState) {
        case z.calling.rtc.ICE_CONNECTION_STATE.COMPLETED:
        case z.calling.rtc.ICE_CONNECTION_STATE.CONNECTED: {
          this._clearNegotiationTimeout();
          this.negotiationMode(z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT);
          this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED);

          this.callEntity.isConnected(true);
          this.participantEntity.isConnected(true);

          this.callEntity.interruptedParticipants.remove(this.participantEntity);
          this.callEntity.state(z.calling.enum.CALL_STATE.ONGOING);
          this.callEntity.terminationReason = undefined;
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.CLOSED: {
          this.participantEntity.isConnected(false);

          if (this.callEntity.selfClientJoined()) {
            this.callEntity.deleteParticipant(this.participantEntity.id, this.remoteClientId);
          }
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.DISCONNECTED: {
          this._setNegotiationRestartTimeout();
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.FAILED: {
          if (this.callEntity.selfClientJoined()) {
            this._removeDroppedParticipant();
          }
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.CHECKING:
        default: {
          break;
        }
      }
    });

    this.signalingState.subscribe(signalingState => {
      switch (signalingState) {
        case z.calling.rtc.SIGNALING_STATE.CLOSED: {
          const logMessage = {
            data: {
              default: [this.remoteUser.name()],
              obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
            },
            message: `PeerConnection with '{0}' was closed`,
          };
          this.callLogger.info(logMessage);

          this.callEntity.deleteParticipant(this.participantEntity.id, this.remoteClientId);
          break;
        }

        case z.calling.rtc.SIGNALING_STATE.STABLE: {
          this._clearNegotiationTimeout();
          break;
        }

        default: {
          break;
        }
      }
    });

    this.negotiationMode = ko.observable(z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT);
    this.negotiationNeeded = ko.observable(false);
    this.negotiationTimeout = undefined;

    this.sdpStateChanging = ko.observable(false);

    //##############################################################################
    // Local SDP
    //##############################################################################

    this.localSdpType = ko.observable(undefined);
    this.localSdp = ko.observable(undefined);
    this.localSdp.subscribe((sdp = {}) => {
      this.localSdpType(sdp.type);

      if (sdp.type) {
        if (!this.shouldSendLocalSdp()) {
          this.shouldSendLocalSdp(true);
          this.shouldSetLocalSdp(true);
        }
      }
    });

    this.shouldSendLocalSdp = ko.observable(false);
    this.shouldSetLocalSdp = ko.observable(false);

    this.sendSdpTimeout = undefined;

    this.properLocalSdpState = ko.pureComputed(() => {
      const isAnswer = this.localSdpType() === z.calling.rtc.SDP_TYPE.ANSWER;
      const isOffer = this.localSdpType() === z.calling.rtc.SDP_TYPE.OFFER;
      const inRemoteOfferState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.REMOTE_OFFER;
      const inStableState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;

      const isProperAnswerState = isAnswer && inRemoteOfferState;
      const isProperOfferState = isOffer && inStableState;
      return isProperOfferState || isProperAnswerState;
    });

    this.canSetLocalSdp = ko.pureComputed(() => {
      const inConnectionProgress = this.connectionState() === z.calling.rtc.ICE_CONNECTION_STATE.CHECKING;
      const progressGatheringStates = [
        z.calling.rtc.ICE_GATHERING_STATE.COMPLETE,
        z.calling.rtc.ICE_GATHERING_STATE.GATHERING,
      ];
      const inProgress = inConnectionProgress && progressGatheringStates.includes(this.gatheringState());

      const isProperState = this.localSdp() && this.shouldSetLocalSdp() && this.properLocalSdpState();
      const changeInProgress = inProgress || this.sdpStateChanging();
      return isProperState && !changeInProgress;
    });

    this.canSetLocalSdp.subscribe(canSet => {
      if (canSet) {
        this._setLocalSdp();
      }
    });

    //##############################################################################
    // Remote SDP
    //##############################################################################

    this.remoteSdpType = ko.observable(undefined);
    this.remoteSdp = ko.observable(undefined);
    this.remoteSdp.subscribe((sdp = {}) => {
      this.remoteSdpType(sdp.type);

      if (sdp.type) {
        this.shouldSetRemoteSdp(true);
      }
    });

    this.shouldSetRemoteSdp = ko.observable(false);

    this.properRemoteSdpState = ko.pureComputed(() => {
      const isAnswer = this.remoteSdpType() === z.calling.rtc.SDP_TYPE.ANSWER;
      const isOffer = this.remoteSdpType() === z.calling.rtc.SDP_TYPE.OFFER;
      const inLocalOfferState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.LOCAL_OFFER;
      const inStableState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;

      const isProperAnswerState = isAnswer && inLocalOfferState;
      const isProperOfferState = isOffer && inStableState;
      return isProperOfferState || isProperAnswerState;
    });

    this.canSetRemoteSdp = ko.pureComputed(() => {
      const isProperState = this.pcInitialized() && this.shouldSetRemoteSdp() && this.properRemoteSdpState();
      return isProperState && !this.sdpStateChanging();
    });

    this.canSetRemoteSdp.subscribe(canSet => {
      if (canSet) {
        this._setRemoteSdp();
      }
    });

    //##############################################################################
    // Gates
    //##############################################################################

    this.canCreateSdp = ko.pureComputed(() => {
      const isConnectionClosed = this.signalingState() === z.calling.rtc.SIGNALING_STATE.CLOSED;
      const inStateForCreation = this.negotiationNeeded() && !isConnectionClosed;
      return this.pcInitialized() && inStateForCreation;
    });

    this.canCreateSdpAnswer = ko.pureComputed(() => {
      const answerState = this.isAnswer() && this.signalingState() === z.calling.rtc.SIGNALING_STATE.REMOTE_OFFER;
      return this.canCreateSdp() && answerState;
    });

    this.canCreateSdpAnswer.subscribe(canCreate => {
      if (canCreate) {
        this._createSdpAnswer();
      }
    });

    this.canCreateSdpOffer = ko.pureComputed(() => {
      const offerState = !this.isAnswer() && this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;
      return this.canCreateSdp() && offerState;
    });

    this.canCreateSdpOffer.subscribe(canCreate => {
      if (canCreate) {
        this._createSdpOffer();
      }
    });
  }

  /**
   * Restart the peer connection negotiation.
   *
   * @param {z.calling.enum.SDP_NEGOTIATION_MODE} negotiationMode - Mode for renegotiation
   * @param {boolean} isAnswer - Flow is answer
   * @param {MediaStream} [mediaStream] - Local media stream
   * @returns {undefined} No return value
   */
  restartNegotiation(negotiationMode, isAnswer, mediaStream) {
    this.callLogger.info(`Negotiation restart triggered by '${negotiationMode}'`);

    this.clearTimeouts();
    this._closePeerConnection();
    this._closeDataChannel();
    this._resetSignalingStates();
    this.isAnswer(isAnswer);
    this._resetSdp();

    const isModeStateCollision = negotiationMode === z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION;
    if (!isModeStateCollision) {
      this.startNegotiation(negotiationMode, mediaStream);
    }
  }

  /**
   * Set the remote client ID.
   * @param {string} clientId - Remote client ID
   * @returns {Undefined} No return value
   */
  setRemoteClientId(clientId) {
    if (!this.remoteClientId) {
      this.remoteClientId = clientId;
      const logMessage = {
        data: {
          default: [clientId],
          obfuscated: [this.callLogger.obfuscate(clientId)],
        },
        message: `Identified remote client as '{0}'`,
      };
      this.callLogger.info(logMessage);
    }
  }

  /**
   * Start the peer connection negotiation.
   *
   * @param {z.calling.enum.SDP_NEGOTIATION_MODE} [negotiationMode=z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT] - Mode for renegotiation
   * @param {MediaStream} [mediaStream=this.mediaStream()] - Local media stream
   * @returns {undefined} No return value
   */
  startNegotiation(negotiationMode = z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT, mediaStream = this.mediaStream()) {
    const logMessage = {
      data: {
        default: [this.remoteUser.name(), negotiationMode],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id), negotiationMode],
      },
      message: `Start negotiating PeerConnection with '{0}' triggered by '{1}'`,
    };
    this.callLogger.info(logMessage);

    const hadMediaStream = !!mediaStream;
    this._createPeerConnection().then(() => {
      if (!mediaStream) {
        // @todo Remove report after debugging purpose achieved
        const customData = {
          hadMediaStream,
          hasMediaStream: !!mediaStream,
          isAnswer: this.isAnswer(),
          isGroup: this.callEntity.isGroup,
          selfClientJoined: this.callEntity.selfClientJoined(),
          state: this.callEntity.state(),
        };
        Raygun.send(new Error('Media Stream missing when negotiation call'), customData);

        throw new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND);
      }

      this._addMediaStream(mediaStream);
      this.audio.hookup(true);
      this._setSdpStates();
      this.negotiationMode(negotiationMode);
      this.negotiationNeeded(true);
      this.pcInitialized(true);

      const isDefaultNegotiationMode = negotiationMode === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
      this._setNegotiationFailedTimeout(isDefaultNegotiationMode);
    });
  }

  /**
   * Remove the participant from the call
   *
   * @private
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason] - Reason for termination
   * @returns {undefined} No return value
   */
  _removeDroppedParticipant(terminationReason) {
    this.participantEntity.isConnected(false);

    const deletionTerminationReason = z.calling.enum.TERMINATION_REASON.CONNECTION_DROP;
    this.callEntity
      .deleteParticipant(this.participantEntity.id, this.remoteClientId, deletionTerminationReason)
      .then(() => {
        if (!this.callEntity.participants().length) {
          if (!terminationReason) {
            terminationReason = this.callEntity.isConnected()
              ? z.calling.enum.TERMINATION_REASON.CONNECTION_DROP
              : z.calling.enum.TERMINATION_REASON.CONNECTION_FAILED;
          }
          amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.callEntity.id, terminationReason);
        }
      });
  }

  /**
   * Set SDP gate states.
   * @private
   * @returns {undefined} No return value
   */
  _setSdpStates() {
    this.shouldSetRemoteSdp(true);
    this.shouldSetLocalSdp(true);
    this.shouldSendLocalSdp(true);
  }

  //##############################################################################
  // PeerConnection handling
  //##############################################################################

  /**
   * Close the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _closePeerConnection() {
    const peerConnectionInActiveState =
      this.peerConnection && this.peerConnection.signalingState !== z.calling.rtc.SIGNALING_STATE.CLOSED;

    if (!peerConnectionInActiveState) {
      const logMessage = {
        data: {
          default: [this.remoteUser.name()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `PeerConnection with '{0}' was previously closed`,
      };
      this.callLogger.info(logMessage);
      return;
    }

    this.peerConnection.oniceconnectionstatechange = () => {
      this.callLogger.log(this.callLogger.levels.OFF, 'State change ignored - ICE connection');
    };

    this.peerConnection.onsignalingstatechange = event => {
      const peerConnection = event.target;
      const logMessage = `State change ignored - signaling state: ${peerConnection.signalingState}`;
      this.callLogger.log(this.callLogger.levels.OFF, logMessage);
    };

    const connectionMediaStreamTracks = this.peerConnection.getReceivers
      ? this.peerConnection.getReceivers().map(receiver => receiver.track)
      : this.peerConnection.getRemoteStreams().reduce((tracks, stream) => tracks.concat(stream.getTracks()), []);

    amplify.publish(z.event.WebApp.CALL.MEDIA.CONNECTION_CLOSED, connectionMediaStreamTracks);
    this.peerConnection.close();
    this.peerConnection = undefined;

    const logMessage = {
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Closing PeerConnection with '{0}' successful`,
    };
    this.callLogger.info(logMessage);
  }

  /**
   * Create the PeerConnection configuration.
   * @private
   * @returns {Promise} Resolves with the configuration object to initialize PeerConnection
   */
  _createPeerConnectionConfiguration() {
    return this.callingRepository.getConfig().then(({ice_servers}) => {
      return {
        bundlePolicy: 'max-bundle',
        iceServers: ice_servers,
        rtcpMuxPolicy: 'require', // @deprecated Default value beginning Chrome 57
      };
    });
  }

  /**
   * Initialize the PeerConnection for the flow.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration
   * @private
   * @returns {Promise} Resolves when the PeerConnection was created
   */
  _createPeerConnection() {
    return this._createPeerConnectionConfiguration().then(pcConfiguration => {
      this.peerConnection = new window.RTCPeerConnection(pcConfiguration);
      this.peerConnectionConfiguration = pcConfiguration;
      this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED);
      this.signalingState(this.peerConnection.signalingState);

      const logMessage = {
        data: {
          default: [this.remoteUser.name(), this.isAnswer()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id), this.isAnswer()],
        },
        message: `PeerConnection with '{0}' created - isAnswer '{1}'`,
      };
      this.callLogger.debug(logMessage, pcConfiguration);

      this.peerConnection.onaddstream = this._onAddStream.bind(this);
      this.peerConnection.ontrack = this._onTrack.bind(this);
      this.peerConnection.ondatachannel = this._onDataChannel.bind(this);
      this.peerConnection.onicecandidate = this._onIceCandidate.bind(this);
      this.peerConnection.oniceconnectionstatechange = this._onIceConnectionStateChange.bind(this);
      this.peerConnection.onremovestream = this._onRemoveStream.bind(this);
      this.peerConnection.onsignalingstatechange = this._onSignalingStateChange.bind(this);

      this.telemetry.set_peer_connection(this.peerConnection);
    });
  }

  /**
   * A MediaStream was added to the PeerConnection.
   *
   * @deprecated
   * @private
   * @param {MediaStream} mediaStream - MediaStream from event
   * @returns {undefined} No return value
   */
  _onAddStream({stream: mediaStream}) {
    this.callLogger.info('Remote MediaStream added to PeerConnection', {
      audioTracks: mediaStream.getAudioTracks(),
      stream: mediaStream,
      videoTracks: mediaStream.getVideoTracks(),
    });

    const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
    const isTypeAudio = mediaType === z.media.MediaType.AUDIO;
    if (isTypeAudio) {
      mediaStream = this.audio.wrapAudioOutputStream(mediaStream);
    }

    const mediaStreamInfo = new z.media.MediaStreamInfo(
      z.media.MediaStreamSource.REMOTE,
      this.remoteUser.id,
      mediaStream,
      this.callEntity
    );
    amplify.publish(z.event.WebApp.CALL.MEDIA.ADD_STREAM, mediaStreamInfo);
  }

  /**
   * A local ICE candidates is available.
   *
   * @private
   * @param {RTCIceCandidate} iceCandidate - RTCIceCandidate from event
   * @returns {undefined} No return value
   */
  _onIceCandidate({candidate: iceCandidate}) {
    if (!iceCandidate) {
      if (this.shouldSendLocalSdp()) {
        this.callLogger.info('Generation of ICE candidates completed');
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED);
        this.sendLocalSdp();
      }
    }
  }

  /**
   * ICE connection state has changed.
   *
   * @private
   * @param {Object} event - State change event
   * @returns {undefined} No return value
   */
  _onIceConnectionStateChange(event) {
    if (this.callEntity.isActiveState()) {
      const peerConnection = event.target;

      this.callLogger.info('State changed - ICE connection', event);
      const connectionMessage = `ICE connection state: ${peerConnection.iceConnectionState}`;
      this.callLogger.log(this.callLogger.levels.LEVEL_1, connectionMessage);
      const gatheringMessage = `ICE gathering state: ${peerConnection.iceGatheringState}`;
      this.callLogger.log(this.callLogger.levels.LEVEL_1, gatheringMessage);

      this.gatheringState(peerConnection.iceGatheringState);
      this.connectionState(peerConnection.iceConnectionState);
    }
  }

  /**
   * A MediaStream was removed from the PeerConnection.
   *
   * @private
   * @param {MediaStreamEvent} event - Event that a MediaStream has been removed
   * @returns {undefined} No return value
   */
  _onRemoveStream(event) {
    this.callLogger.info('Remote MediaStream removed from PeerConnection', event);
  }

  /**
   * Signaling state has changed.
   *
   * @private
   * @param {Object} event - State change event
   * @returns {undefined} No return value
   */
  _onSignalingStateChange(event) {
    const peerConnection = event.target;
    this.callLogger.info(`State changed - signaling state: ${peerConnection.signalingState}`, event);
    this.signalingState(peerConnection.signalingState);
  }

  /**
   * A MediaStreamTrack was added to the PeerConnection.
   *
   * @private
   * @param {RTCTrackEvent} event - Event that contains the newly added MediaStreamTrack
   * @returns {undefined} No return value
   */
  _onTrack(event) {
    const mediaStreamTrack = event.track;
    this.callLogger.info(`Remote '${mediaStreamTrack.kind}' MediaStreamTrack added to PeerConnection`, event);
  }

  //##############################################################################
  // Data channel handling
  //##############################################################################

  /**
   * Send a call message through the data channel.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be send
   * @returns {undefined} No return value
   */
  sendMessage(callMessageEntity) {
    const {conversationId, response, type} = callMessageEntity;

    if (this.dataChannel && this.dataChannelOpened) {
      try {
        this.dataChannel.send(callMessageEntity.toContentString());

        const logMessage = {
          data: {
            default: [type, conversationId],
            obfuscated: [type, this.callLogger.obfuscate(conversationId)],
          },
          message: `Sending '{0}' message to conversation '{1}' via data channel`,
        };
        this.callLogger.info(logMessage, callMessageEntity.toJSON());
        return;
      } catch (error) {
        if (!response) {
          this.callLogger.warn(`Failed to send calling message via data channel: ${error.name}`, error);
          throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
        }
      }
    }

    throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
  }

  /**
   * Close the data channel.
   * @private
   * @returns {undefined} No return value
   */
  _closeDataChannel() {
    if (this.dataChannel) {
      const isReadyStateOpen = this.dataChannel.readyState === z.calling.rtc.DATA_CHANNEL_STATE.OPEN;
      if (isReadyStateOpen) {
        this.dataChannel.close();
      }
      delete this.dataChannel;
    }
    this.dataChannelOpened = false;
  }

  /**
   * Initialize the data channel.
   * @private
   * @returns {undefined} No return value
   */
  _initializeDataChannel() {
    if (this.peerConnection.createDataChannel && !this.dataChannel) {
      const label = FlowEntity.CONFIG.DATA_CHANNEL_LABEL;
      this._setupDataChannel(this.peerConnection.createDataChannel(label, {ordered: true}));
    }
  }

  /**
   * Set up the data channel.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel object
   * @returns {undefined} No return value
   */
  _setupDataChannel(dataChannel) {
    this.dataChannel = dataChannel;
    dataChannel.onclose = this._onClose.bind(this);
    dataChannel.onerror = this._onError.bind(this);
    dataChannel.onmessage = this._onMessage.bind(this);
    dataChannel.onopen = this._onOpen.bind(this);
  }

  /**
   * A data channel was received on the PeerConnection.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel from event
   * @returns {undefined} No return value
   */
  _onDataChannel({channel: dataChannel}) {
    this._setupDataChannel(dataChannel);
  }

  /**
   * Data channel was closed.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel that was closed
   * @returns {undefined} No return value
   */
  _onClose({target: dataChannel}) {
    this.callLogger.info(`Data channel '${dataChannel.label}' was closed`, dataChannel);

    if (this.dataChannel && this.dataChannel.readyState === z.calling.rtc.DATA_CHANNEL_STATE.CLOSED) {
      delete this.dataChannel;
      this.dataChannelOpened = false;
    }
  }

  /**
   * An error was caught on the data channel.
   *
   * @private
   * @param {Error} error - Error thrown
   * @returns {undefined} No return value
   */
  _onError(error) {
    throw error;
  }

  /**
   * New incoming message on the data channel.
   *
   * @private
   * @param {string} message - Incoming message
   * @returns {undefined} No return value
   */
  _onMessage({data: message}) {
    const callMessage = JSON.parse(message);
    const {resp: response, type} = callMessage;
    const conversationEntity = this.callEntity.conversationEntity;

    const logMessage = response
      ? `Received confirmation for '${type}' message via data channel`
      : `Received '${type}' (response: ${response}) message via data channel`;
    this.callLogger.debug(logMessage, callMessage);

    const callEvent = z.conversation.EventBuilder.buildCalling(
      conversationEntity,
      callMessage,
      this.remoteUserId,
      this.remoteClientId
    );
    amplify.publish(z.event.WebApp.CALL.EVENT_FROM_BACKEND, callEvent, z.event.EventRepository.SOURCE.WEB_SOCKET);
  }

  /**
   * Data channel was successfully opened.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Opened data channel
   * @returns {undefined} No return value
   */
  _onOpen({target: dataChannel}) {
    this.callLogger.info(`Data channel '${dataChannel.label}' was opened and can be used`, dataChannel);
    this.dataChannelOpened = true;
  }

  //##############################################################################
  // SDP handling
  //##############################################################################

  /**
   * Save the remote SDP received via a call message within the flow.
   *
   * @note The resolving value indicates whether negotiation should be skipped for the current state.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {Promise} Resolves when the remote SDP was saved
   */
  saveRemoteSdp(callMessageEntity) {
    let skipNegotiation = false;

    return z.calling.SDPMapper.mapCallMessageToObject(callMessageEntity)
      .then(rtcSdp => z.calling.SDPMapper.rewriteSdp(rtcSdp, z.calling.enum.SDP_SOURCE.REMOTE, this))
      .then(({sdp: remoteSdp}) => {
        const isRemoteOffer = remoteSdp.type === z.calling.rtc.SDP_TYPE.OFFER;
        if (isRemoteOffer) {
          switch (this.signalingState()) {
            case z.calling.rtc.SIGNALING_STATE.LOCAL_OFFER: {
              if (this._solveCollidingStates()) {
                return true;
              }
              break;
            }

            case z.calling.rtc.SIGNALING_STATE.NEW:
            case z.calling.rtc.SIGNALING_STATE.STABLE: {
              const isUpdate = callMessageEntity.type === z.calling.enum.CALL_MESSAGE_TYPE.UPDATE;

              if (isUpdate) {
                this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STREAM_CHANGE, true);
                skipNegotiation = true;
              }

              this.isAnswer(true);
              break;
            }

            default: {
              break;
            }
          }
        }

        this.remoteSdp(remoteSdp);
        this.callLogger.debug(`Saved remote '${remoteSdp.type}' SDP`, this.remoteSdp());
        return skipNegotiation;
      });
  }

  /**
   * Initiates sending the local RTCSessionDescriptionProtocol to the remote user.
   * @param {boolean} [sendingOnTimeout=false] - SDP sending on timeout
   * @returns {undefined} No return value
   */
  sendLocalSdp(sendingOnTimeout = false) {
    this.callLogger.info(`Sending local SDP${sendingOnTimeout ? ' on timeout' : ''}`);
    this._clearSendSdpTimeout();

    if (!this.peerConnection) {
      this.callLogger.warn('Cannot send local SDP without existing PeerConnection');
      return;
    }

    const mappedSdp = z.calling.SDPMapper.rewriteSdp(
      this.peerConnection.localDescription,
      z.calling.enum.SDP_SOURCE.LOCAL,
      this
    );
    Promise.resolve(mappedSdp)
      .then(({iceCandidates, sdp: localSdp}) => {
        this.localSdp(localSdp);

        const isModeDefault = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
        if (isModeDefault && sendingOnTimeout) {
          const connectionConfig =
            (this.peerConnection.getConfiguration && this.peerConnection.getConfiguration()) ||
            this.peerConnectionConfiguration;
          const isValidGathering = z.util.PeerConnectionUtil.isValidIceCandidatesGathering(
            connectionConfig,
            iceCandidates
          );
          const attempts = this.iceCandidatesGatheringAttempts;
          const hasReachMaxGatheringAttempts = attempts >= FlowEntity.CONFIG.MAX_ICE_CANDIDATE_GATHERING_ATTEMPTS;
          if (!hasReachMaxGatheringAttempts && !isValidGathering) {
            const logMessage = `Not enough ICE candidates gathered (attempt '${attempts}'). Restarting timeout\n${iceCandidates}`;
            this.iceCandidatesGatheringAttempts++;
            this.callLogger.warn(logMessage);
            return this._setSendSdpTimeout();
          }
        }

        const iceCandidateTypes = z.util.PeerConnectionUtil.getIceCandidatesTypes(iceCandidates);

        const iceCandidateTypesLog = Object.keys(iceCandidateTypes)
          .map(candidateType => `${iceCandidateTypes[candidateType]} ${candidateType}`)
          .join(', ');

        const logMessage = {
          data: {
            default: [
              localSdp.type,
              iceCandidates.length,
              iceCandidateTypesLog,
              this.remoteUser.name(),
              this.localSdp().sdp,
            ],
            obfuscated: [
              localSdp.type,
              iceCandidates.length,
              this.callLogger.obfuscate(this.remoteUser.id),
              this.callLogger.obfuscateSdp(this.localSdp().sdp),
            ],
          },
          message: `Sending local '{0}' SDP containing '{1}' ICE candidates ({2}) for flow with '{3}'\n{4}`,
        };
        this.callLogger.debug(logMessage);

        this.shouldSendLocalSdp(false);

        const response = localSdp.type === z.calling.rtc.SDP_TYPE.ANSWER;
        let callMessageEntity;

        const additionalPayload = this._createAdditionalPayload();
        const sessionId = this.callEntity.sessionId;
        const inDefaultMode = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
        if (inDefaultMode) {
          callMessageEntity = this.callEntity.isGroup
            ? z.calling.CallMessageBuilder.buildGroupSetup(response, sessionId, additionalPayload)
            : z.calling.CallMessageBuilder.buildSetup(response, sessionId, additionalPayload);
        } else {
          callMessageEntity = z.calling.CallMessageBuilder.buildUpdate(response, sessionId, additionalPayload);
        }

        return this.callEntity.sendCallMessage(callMessageEntity).then(() => {
          this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND);
          this.callLogger.debug(`Sending local '${localSdp.type}' SDP successful`, this.localSdp());
        });
      })
      .catch(error => {
        this.shouldSendLocalSdp(true);
        throw error;
      });
  }

  /**
   * Clear the negotiation timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearNegotiationTimeout() {
    if (this.negotiationTimeout) {
      window.clearTimeout(this.negotiationTimeout);
      this.negotiationTimeout = undefined;
    }
  }

  /**
   * Clear the SDP send timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearSendSdpTimeout() {
    if (this.sendSdpTimeout) {
      window.clearTimeout(this.sendSdpTimeout);
      this.sendSdpTimeout = undefined;
    }
  }

  /**
   * Build RTCOfferAnswerOptions for SDP creation
   *
   * @see https://www.w3.org/TR/webrtc/#offer/answer-options
   *
   * @private
   * @param {boolean} iceRestart - Is ICE restart
   * @returns {RTCOfferAnswerOptions} Object containing the RTCOfferAnswerOptions
   */
  _createOfferAnswerOptions(iceRestart) {
    return {iceRestart, voiceActivityDetection: true};
  }

  /**
   * Create a local SDP of type 'answer'.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createAnswer
   * @private
   * @returns {undefined} No return value
   */
  _createSdpAnswer() {
    this.negotiationNeeded(false);

    const logMessage = {
      data: {
        default: [z.calling.rtc.SDP_TYPE.ANSWER, this.remoteUser.name()],
        obfuscated: [z.calling.rtc.SDP_TYPE.ANSWER, this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Creating '{0}' for flow with '{1}'`,
    };
    this.callLogger.debug(logMessage);

    this.peerConnection
      .createAnswer(this._createOfferAnswerOptions())
      .then(rtcSdp => this._createSdpSuccess(rtcSdp))
      .catch(error => this._createSdpFailure(error, z.calling.rtc.SDP_TYPE.ANSWER));
  }

  /**
   * Failed to create local SDP
   *
   * @private
   * @param {Error} error - Error that was thrown
   * @param {z.calling.rtc.SDP_TYPE} sdpType - Type of SDP
   * @returns {undefined} No return value
   */
  _createSdpFailure(error, sdpType) {
    const {message, name} = error;
    this.callLogger.error(`Creating '${sdpType}' failed: ${name} - ${message}`, error);

    const attributes = {cause: name, step: 'create_sdp', type: sdpType};
    this.callEntity.telemetry.track_event(z.tracking.EventName.CALLING.FAILED_RTC, undefined, attributes);

    amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.callEntity.id, z.calling.enum.TERMINATION_REASON.SDP_FAILED);
  }

  /**
   * Creating local SDP succeeded.
   *
   * @private
   * @param {RTCSessionDescription} rctSdp - New local SDP
   * @returns {undefined} No return value
   */
  _createSdpSuccess(rctSdp) {
    this.callLogger.info(`Creating '${rctSdp.type}' successful`, rctSdp);

    const mappedSdp = z.calling.SDPMapper.rewriteSdp(rctSdp, z.calling.enum.SDP_SOURCE.LOCAL, this);
    this.localSdp(mappedSdp.sdp);
  }

  /**
   * Create a local SDP of type 'offer'.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer
   * @private
   * @param {boolean} iceRestart - Is ICE restart negotiation
   * @returns {undefined} No return value
   */
  _createSdpOffer(iceRestart) {
    this.negotiationNeeded(false);
    this._initializeDataChannel();

    const logMessage = {
      data: {
        default: [z.calling.rtc.SDP_TYPE.OFFER, this.remoteUser.name()],
        obfuscated: [z.calling.rtc.SDP_TYPE.OFFER, this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Creating '{0}' for flow with '{1}'`,
    };
    this.callLogger.debug(logMessage);

    this.peerConnection
      .createOffer(this._createOfferAnswerOptions(iceRestart))
      .then(rtcSdp => this._createSdpSuccess(rtcSdp))
      .catch(error => this._createSdpFailure(error, z.calling.rtc.SDP_TYPE.OFFER));
  }

  /**
   * Create the additional payload.
   * @private
   * @returns {Object} Additional payload
   */
  _createAdditionalPayload() {
    const payload = z.calling.CallMessageBuilder.createPayload(
      this.conversationId,
      this.selfUserId,
      this.remoteUserId,
      this.remoteClientId
    );
    const additionalPayload = Object.assign({remoteUser: this.remoteUser, sdp: this.localSdp().sdp}, payload);

    const selfState = this.callEntity.selfState;
    return z.calling.CallMessageBuilder.createPropSync(selfState, additionalPayload);
  }

  /**
   * Sets the local Session Description Protocol on the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _setLocalSdp() {
    this.sdpStateChanging(true);
    const localSdp = this.localSdp();
    this.callLogger.debug(`Setting local '${localSdp.type}' SDP`, localSdp);

    this.peerConnection
      .setLocalDescription(localSdp)
      .then(() => {
        this.callLogger.info(`Setting local '${localSdp.type}' SDP successful`, this.peerConnection.localDescription);
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET);

        this.shouldSetLocalSdp(false);
        this.sdpStateChanging(false);
        this._setSendSdpTimeout();
      })
      .catch(error => this._setSdpFailure(error, z.calling.enum.SDP_SOURCE.LOCAL, localSdp.type));
  }

  /**
   * Sets the remote Session Description Protocol on the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _setRemoteSdp() {
    this.sdpStateChanging(false);
    const remoteSdp = this.remoteSdp();
    this.callLogger.debug(`Setting remote '${remoteSdp.type}' SDP\n${remoteSdp.sdp}`, remoteSdp);

    this.peerConnection
      .setRemoteDescription(remoteSdp)
      .then(() => {
        const logMessage = `Setting remote '${remoteSdp.type}' SDP successful`;
        this.callLogger.info(logMessage, this.peerConnection.remoteDescription);
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET);

        this.shouldSetRemoteSdp(false);
        this.sdpStateChanging(false);
      })
      .catch(error => this._setSdpFailure(error, z.calling.enum.SDP_SOURCE.REMOTE, remoteSdp.type));
  }

  /**
   * Failed to set SDP.
   *
   * @private
   * @param {Error} error - Error that was thrown
   * @param {z.calling.enum.SDP_SOURCE} sdpSource - Source of SDP
   * @param {z.calling.rtc.SDP_TYPE} sdpType - SDP type
   * @returns {undefined} No return value
   */
  _setSdpFailure(error, sdpSource, sdpType) {
    const {message, name} = error;

    const failedLocalSdp = sdpSource === z.calling.enum.SDP_SOURCE.LOCAL && !this.properLocalSdpState();
    const failedRemoteSdp = sdpSource === z.calling.enum.SDP_SOURCE.REMOTE && !this.properRemoteSdpState();

    const shouldSolveCollision = failedLocalSdp || failedRemoteSdp;
    if (shouldSolveCollision) {
      this._solveCollidingSdps(failedLocalSdp);
      return this.sdpStateChanging(false);
    }

    this.callLogger.error(`Setting ${sdpSource} '${sdpType}' SDP failed: ${name} - ${message}`, error);

    const attributes = {cause: name, location: sdpSource, step: 'set_sdp', type: sdpType};
    this.callEntity.telemetry.track_event(z.tracking.EventName.CALLING.FAILED_RTC, undefined, attributes);

    this._removeDroppedParticipant(z.calling.enum.TERMINATION_REASON.SDP_FAILED);
  }

  /**
   * Set the negotiation failed timeout.
   *
   * @private
   * @param {boolean} isInitialNegotiation - Is negotiation during initial call setup
   * @returns {undefined} No return value
   */
  _setNegotiationFailedTimeout(isInitialNegotiation) {
    const timeout = isInitialNegotiation
      ? z.calling.entities.CallEntity.CONFIG.STATE_TIMEOUT
      : FlowEntity.CONFIG.RENEGOTIATION_TIMEOUT;

    this.negotiationTimeout = window.setTimeout(() => {
      this.callLogger.info('Removing call participant on negotiation timeout');
      this._removeDroppedParticipant(z.calling.enum.TERMINATION_REASON.RENEGOTIATION);
    }, timeout + FlowEntity.CONFIG.NEGOTIATION_THRESHOLD);
  }

  /**
   * Set the negotiation restart timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setNegotiationRestartTimeout() {
    this.negotiationTimeout = window.setTimeout(() => {
      this.callEntity.terminationReason = z.calling.enum.TERMINATION_REASON.CONNECTION_DROP;
      this.participantEntity.isConnected(false);

      this.callEntity.interruptedParticipants.push(this.participantEntity);
      const isModeDefault = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
      if (isModeDefault) {
        this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.ICE_RESTART, false);
      }
    }, FlowEntity.CONFIG.RECONNECTION_TIMEOUT);
  }

  /**
   * Set the SDP send timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setSendSdpTimeout() {
    this.sendSdpTimeout = window.setTimeout(() => this.sendLocalSdp(true), FlowEntity.CONFIG.SDP_SEND_TIMEOUT);
  }

  //##############################################################################
  // SDP state collision handling
  //##############################################################################

  /**
   * Solve colliding SDP states.
   *
   * @note If we receive a remote offer while we have a local offer, we need to check who needs to switch his SDP type.
   * @private
   * @param {boolean} [forceRenegotiation=false] - Force local renegotiation to switch to
   * @returns {boolean} False if we locally needed to switch sides
   */
  _solveCollidingStates(forceRenegotiation = false) {
    const logMessage = {
      data: {
        default: [this.selfUserId, this.remoteUserId, forceRenegotiation],
        obfuscated: [
          this.callLogger.obfuscate(this.selfUserId),
          this.callLogger.obfuscate(this.remoteUserId),
          forceRenegotiation,
        ],
      },
      message: `Solving state collision: Self user ID '{0}', remote user ID '{1}', forceRenegotiation '{2}'`,
    };
    this.callLogger.debug(logMessage);

    const selfUserIdLooses = this.selfUserId < this.remoteUserId;
    const shouldRenegotiate = selfUserIdLooses || forceRenegotiation;
    if (shouldRenegotiate) {
      const log = {
        data: {
          default: [this.remoteUser.name()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `We need to switch SDP state of flow with '{0}' to answer.`,
      };
      this.callLogger.warn(log);

      this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION, true);
      return forceRenegotiation || false;
    }

    const log = {
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Remote side '{0}' needs to switch SDP state flow to answer.`,
    };
    this.callLogger.warn(log);

    return true;
  }

  /**
   * Solve colliding SDP states when setting SDP failed.
   * @private
   * @param {boolean} failedLocalSdp - Failed to set local SDP
   * @returns {undefined} No return value
   */
  _solveCollidingSdps(failedLocalSdp) {
    const remoteSdp = this.remoteSdp();

    if (!this._solveCollidingStates(failedLocalSdp)) {
      this.remoteSdp(remoteSdp);
    }
  }

  //##############################################################################
  // Media stream handling
  //##############################################################################

  /**
   * Replace the MediaStream attached to the PeerConnection.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Object containing the required MediaStream information
   * @param {MediaStream} outdatedMediaStream - Previous MediaStream
   * @returns {Promise} Resolves when negotiation has been restarted
   */
  replaceMediaStream(mediaStreamInfo, outdatedMediaStream) {
    const mediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    const negotiationMode = z.calling.enum.SDP_NEGOTIATION_MODE.STREAM_CHANGE;

    return Promise.resolve()
      .then(() => this._removeMediaStream(outdatedMediaStream))
      .then(() => this.restartNegotiation(negotiationMode, false, mediaStream))
      .then(() => this.callLogger.debug(`Replaced the '${mediaType}' track`))
      .catch(error => {
        this.callLogger.error(`Failed to replace local MediaStream: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Replace the MediaStreamTrack attached to the MediaStream of the PeerConnection.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Object containing the required MediaStream information
   * @returns {Promise} Resolves when a MediaStreamTrack has been replaced
   */
  replaceMediaTrack(mediaStreamInfo) {
    const mediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    const [mediaStreamTrack] = mediaStream.getTracks();

    return Promise.resolve()
      .then(() => this._getRtcSender(mediaType))
      .then(rtpSender => rtpSender.replaceTrack(mediaStreamTrack))
      .then(() => this.callLogger.debug(`Replaced the MediaStream containing '${mediaType}'`))
      .catch(error => {
        this.callLogger.error(`Failed to replace local MediaStreamTrack: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check for support of MediaStreamTrack replacement.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type to check replacement capability for
   * @returns {Promise<boolean>} Resolves when the replacement capability has been checked
   */
  supportsTrackReplacement(mediaType) {
    return Promise.resolve()
      .then(() => {
        const supportsGetSenders = typeof this.peerConnection.getSenders === 'function';
        return supportsGetSenders ? this._getRtcSender(mediaType) : false;
      })
      .then(rtpSender => !!rtpSender)
      .catch(() => false);
  }

  /**
   * Adds a local MediaStream to the PeerConnection.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to add to the PeerConnection
   * @returns {undefined} No return value
   */
  _addMediaStream(mediaStream) {
    if (mediaStream) {
      const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
      const containsAudio = z.media.MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_AUDIO.includes(mediaType);
      if (containsAudio) {
        mediaStream = this.audio.wrapAudioInputStream(mediaStream);
      }

      if (this.peerConnection.addTrack) {
        mediaStream.getTracks().forEach(mediaStreamTrack => {
          this.peerConnection.addTrack(mediaStreamTrack, mediaStream);

          this.callLogger.debug(`Added local '${mediaStreamTrack.kind}' MediaStreamTrack to PeerConnection`, {
            audioTracks: mediaStream.getAudioTracks(),
            stream: mediaStream,
            videoTracks: mediaStream.getVideoTracks(),
          });
        });
      } else {
        this.peerConnection.addStream(mediaStream);
        this.callLogger.debug(`Added local '${mediaStream.type}' MediaStream to PeerConnection`, {
          audioTracks: mediaStream.getAudioTracks(),
          stream: mediaStream,
          videoTracks: mediaStream.getVideoTracks(),
        });
      }
    } else {
      throw new Error('Failed to add MediaStream: Provided MediaStream undefined');
    }
  }

  /**
   * Get RTC Sender of matching type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested MediaType
   * @returns {RTCRtpSender} Matching RTC Rtp Sender
   */
  _getRtcSender(mediaType) {
    for (const rtpSender of this.peerConnection.getSenders()) {
      const mediaStreamTrack = rtpSender.track;

      const isExpectedType = mediaStreamTrack && mediaStreamTrack.kind === mediaType;
      if (isExpectedType) {
        const supportsReplaceTrack = typeof rtpSender.replaceTrack === 'function';
        if (supportsReplaceTrack) {
          return rtpSender;
        }

        throw new z.error.CallError(z.error.CallError.TYPE.RTP_SENDER_NOT_SUPPORTED);
      }
    }

    throw new z.error.CallError(z.error.CallError.TYPE.NO_REPLACEABLE_TRACK);
  }

  /**
   * Removes a MediaStreamTrack from the PeerConnection.
   *
   * @private
   * @param {string} trackId - ID of MediaStreamTrack
   * @param {z.media.MediaType} mediaType - MediaType of MediaStreamTrack
   * @returns {undefined} No return value
   */
  _removeMediaStreamTrack(trackId, mediaType) {
    for (const rtpSender of this.peerConnection.getSenders()) {
      const mediaStreamTrack = rtpSender.track;

      const isExpectedId = mediaStreamTrack && mediaStreamTrack.id === trackId;
      if (isExpectedId) {
        this.peerConnection.removeTrack(rtpSender);
        this.callLogger.debug(`Removed local '${mediaType}' MediaStreamTrack from PeerConnection`);
        break;
      }
    }
  }

  /**
   * Remove all MediaStreamTracks of a MediaStream from the PeerConnection.
   *
   * @private
   * @param {MediaStream} mediaStream - Local MediaStream to remove from the PeerConnection
   * @returns {undefined} No return value
   */
  _removeMediaStreamTracks(mediaStream) {
    mediaStream
      .getTracks()
      .forEach(({id: trackId, kind: mediaType}) => this._removeMediaStreamTrack(trackId, mediaType));
  }

  /**
   * Remove the MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - Local MediaStream to stop
   * @returns {undefined} No return value
   */
  _removeMediaStream(mediaStream) {
    if (this.peerConnection) {
      const signalingStateStable = this.peerConnection.signalingState === z.calling.rtc.SIGNALING_STATE.STABLE;
      const supportsRemoveTrack = typeof this.peerConnection.removeTrack === 'function';
      if (signalingStateStable && supportsRemoveTrack) {
        return this._removeMediaStreamTracks(mediaStream);
      }

      const isSignalingStateClosed = this.peerConnection.signalingState === z.calling.rtc.SIGNALING_STATE.CLOSED;
      const supportsRemoveStream = typeof this.peerConnection.removeStream === 'function';
      if (!isSignalingStateClosed && supportsRemoveStream) {
        this.peerConnection.removeStream(mediaStream);
        const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
        this.callLogger.debug(`Removed local '${mediaType}' MediaStream from PeerConnection`, {
          audioTracks: mediaStream.getAudioTracks(),
          stream: mediaStream,
          videoTracks: mediaStream.getVideoTracks(),
        });
      }
    }
  }

  //##############################################################################
  // Reset
  //##############################################################################

  /**
   * Clear the timeouts.
   * @returns {undefined} No return value
   */
  clearTimeouts() {
    this._clearNegotiationTimeout();
    this._clearSendSdpTimeout();
  }

  /**
   * Reset the flow.
   * @returns {undefined} No return value
   */
  resetFlow() {
    if (this.mediaStream()) {
      this._removeMediaStream(this.mediaStream());
    }

    if (this.pcInitialized()) {
      const logMessage = {
        data: {
          default: [this.remoteUser.id],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `Resetting flow with user '{0}'`,
      };
      this.callLogger.debug(logMessage);

      this.remoteClientId = undefined;
      this.telemetry.disconnected();

      this.clearTimeouts();
      this.iceCandidatesGatheringAttempts = 1;
      this._closeDataChannel();
      this._closePeerConnection();
      this._resetSignalingStates();
      this._resetSdp();
      this.pcInitialized(false);
    }
  }

  /**
   * Reset the SDP.
   * @private
   * @returns {undefined} No return value
   */
  _resetSdp() {
    this.localSdp(undefined);
    this.remoteSdp(undefined);
  }

  /**
   * Reset the signaling states.
   * @private
   * @returns {undefined} No return value
   */
  _resetSignalingStates() {
    this.connectionState(z.calling.rtc.ICE_CONNECTION_STATE.NEW);
    this.gatheringState(z.calling.rtc.ICE_GATHERING_STATE.NEW);
    this.signalingState(z.calling.rtc.SIGNALING_STATE.NEW);
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Get full telemetry report for automation.
   * @returns {Object} Automation report
   */
  getTelemetry() {
    return this.telemetry.get_automation_report();
  }

  /**
   * Log flow status to console.
   * @returns {undefined} No return value
   */
  logStatus() {
    this.telemetry.log_status(this.participantEntity);
  }

  /**
   * Log flow setup step timings to console.
   * @returns {undefined} No return value
   */
  logTimings() {
    this.telemetry.log_timings();
  }

  /**
   * Report flow status to Raygun.
   * @returns {undefined} No return value
   */
  reportStatus() {
    this.telemetry.report_status();
  }

  /**
   * Report flow setup step timings to Raygun.
   * @returns {undefined} No return value
   */
  reportTimings() {
    this.telemetry.report_timings();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.FlowAudioEntity = class FlowAudioEntity {
  /**
   * Create a new flow audio.
   *
   * @class z.calling.entities.FlowAudioEntity
   * @param {z.calling.entities.FlowEntity} flowEntity - Flow entity
   * @param {MediaRepository} mediaRepository - Media repository
   */
  constructor(flowEntity, mediaRepository) {
    this.setGainNode = this.setGainNode.bind(this);

    this.flowEntity = flowEntity;
    this.mediaRepository = mediaRepository;

    this.messageLog = this.flowEntity.messageLog;

    const id = this.flowEntity.id;
    const loggerName = 'z.calling.entities.FlowAudio';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info({
      data: {
        default: [this.flowEntity.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.flowEntity.remoteUser.id)],
      },
      message: `Created new flow audio entity for user {0}`,
    });

    this.audioContext = undefined;

    // Panning
    this.panning = this.flowEntity.participantEntity.panning;
    this.panning.subscribe(updatedPanningValue => {
      this.callLogger.debug({
        data: {
          default: [this.flowEntity.remoteUser.name(), updatedPanningValue],
          obfuscated: [this.callLogger.obfuscate(this.flowEntity.remoteUser.id), updatedPanningValue],
        },
        message: `Panning of {0} changed to '{1}'`,
      });

      this.setPan(updatedPanningValue);
    });

    this.panNode = undefined;
    this.gainNode = undefined;
    this.audioSource = undefined;
    this.audioRemote = undefined;

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.MUTE_AUDIO, this.setGainNode);
  }

  /**
   * Hookup flow audio.
   * @param {boolean} isActive - Whether the flow is active
   * @returns {undefined} No return value
   */
  hookup(isActive) {
    if (isActive) {
      return this._hookupAudio();
    }

    if (this.audioSource) {
      this.audioSource.disconnect();
    }
  }

  /**
   * Set muted state on gain node.
   * @param {boolean} isMuted - Muted state
   * @returns {undefined} No return value
   */
  setGainNode(isMuted) {
    if (this.gainNode) {
      this.gainNode.gain.value = isMuted ? 0 : 1;
      this.callLogger.debug(`Outgoing audio on flow muted '${isMuted}'`);
    }
  }

  /**
   * Set pan value.
   * @param {number} panningValue - Updated panning value
   * @returns {undefined} No return value
   */
  setPan(panningValue) {
    if (this.panNode) {
      this.panNode.pan.value = panningValue;
    }
  }

  /**
   * Wrap audio input stream.
   * @param {MediaStream} mediaStream - MediaStream to wrap
   * @returns {MediaStream} Wrapped MediaStream
   */
  wrapAudioInputStream(mediaStream) {
    const audioContext = this._getAudioContext();

    if (audioContext) {
      this.audioSource = audioContext.createMediaStreamSource(mediaStream);
      this.gainNode = audioContext.createGain();
      this.audioRemote = audioContext.createMediaStreamDestination();
      this._hookupAudio();

      Object.assign(mediaStream, this.audioRemote.stream);
      this.callLogger.debug('Wrapped audio stream from microphone', mediaStream);
    }

    return mediaStream;
  }

  /**
   * Wrap audio output stream.
   * @param {MediaStream} mediaStream - MediaStream to wrap
   * @returns {MediaStream} Wrapped MediaStream
   */
  wrapAudioOutputStream(mediaStream) {
    if (z.util.Environment.browser.firefox) {
      const audioContext = this._getAudioContext();

      if (audioContext) {
        const remoteSource = audioContext.createMediaStreamSource(mediaStream);
        const audioOutputDevice = audioContext.createMediaStreamDestination();

        this.panNode = audioContext.createStereoPanner();
        this.panNode.pan.value = this.panning();

        remoteSource.connect(this.panNode);
        this.panNode.connect(audioOutputDevice);

        Object.assign(mediaStream, audioOutputDevice.stream);
        const logMessage = `Wrapped audio stream to speaker for stereo. Initial panning set to '${this.panning()}'.`;
        this.callLogger.debug(logMessage, mediaStream);
      }
    }

    return mediaStream;
  }

  /**
   * Get running AudioContext.
   * @returns {AudioContext} Active AudioContext
   */
  _getAudioContext() {
    if (!this.audioContext || this.audioContext.state === z.media.MediaRepository.AUDIO_CONTEXT_STATE.CLOSED) {
      this.audioContext = this.mediaRepository.getAudioContext();
    }
    return this.audioContext;
  }

  /**
   * Hookup flow audio.
   * @private
   * @returns {undefined} No return value
   */
  _hookupAudio() {
    if (this.audioSource && this.gainNode) {
      this.audioSource.connect(this.gainNode);
      this.gainNode.connect(this.audioRemote);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.ParticipantEntity = class ParticipantEntity {
  static get CONFIG() {
    return {
      PROPERTY_STATES: {
        ACTIVE: [z.calling.enum.PROPERTY_STATE.PAUSED, z.calling.enum.PROPERTY_STATE.TRUE],
        EXPECTED: [
          z.calling.enum.PROPERTY_STATE.FALSE,
          z.calling.enum.PROPERTY_STATE.PAUSED,
          z.calling.enum.PROPERTY_STATE.TRUE,
        ],
      },
    };
  }
  /**
   * Construct a new participant.
   *
   * @class z.calling.entities.ParticipantEntity
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.entity.User} user - User entity to base the participant on
   * @param {CallSetupTimings} timings - Timing statistics of call setup steps
   */
  constructor(callEntity, user, timings) {
    this.callEntity = callEntity;
    this.user = user;

    this.id = this.user.id;
    this.messageLog = this.callEntity.messageLog;
    this.sessionId = undefined;

    const loggerName = 'z.calling.entities.ParticipantEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info(`Created new participant entity for user ${this.id}`);

    this.isConnected = ko.observable(false);
    this.panning = ko.observable(0.0);
    this.wasConnected = false;

    this.state = {
      audioSend: ko.observable(z.calling.enum.PROPERTY_STATE.TRUE),
      screenSend: ko.observable(z.calling.enum.PROPERTY_STATE.FALSE),
      videoSend: ko.observable(z.calling.enum.PROPERTY_STATE.FALSE),
    };

    this.activeState = {
      audioSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.audioSend());
      }),
      screenSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.screenSend());
      }),
      videoSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.videoSend());
      }),
    };

    this.hasActiveVideo = ko.pureComputed(() => this.activeState.screenSend() || this.activeState.videoSend());

    this.flowEntity = new z.calling.entities.FlowEntity(this.callEntity, this, timings);

    this.isConnected.subscribe(isConnected => {
      if (isConnected && !this.wasConnected) {
        amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.READY_TO_TALK);
        this.wasConnected = true;
      }
    });
  }

  /**
   * Reset the participant.
   * @returns {undefined} No return value
   */
  resetParticipant() {
    if (this.flowEntity) {
      this.flowEntity.resetFlow();
    }
  }

  /**
   * Start negotiating the peer connection.
   * @returns {undefined} No return value
   */
  startNegotiation() {
    this.flowEntity.startNegotiation();
  }

  /**
   * Update the participant state.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to update state from.
   * @returns {Promise} Resolves when the state was updated
   */
  updateState(callMessageEntity) {
    const {clientId, properties, sdp: rtcSdp, sessionId, type} = callMessageEntity;

    return this.updateProperties(properties).then(() => {
      this.sessionId = sessionId;
      this.flowEntity.setRemoteClientId(clientId);

      const isGroupStart = type === z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START;
      if (isGroupStart && this.flowEntity.pcInitialized()) {
        this.flowEntity.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION, false);
      }

      return rtcSdp ? this.flowEntity.saveRemoteSdp(callMessageEntity) : false;
    });
  }

  /**
   * Update the state properties
   * @param {Object} properties - Properties to update with
   * @returns {Promise} Resolves when the properties have been updated
   */
  updateProperties(properties) {
    return Promise.resolve().then(() => {
      if (properties) {
        const {audiosend, screensend, videosend} = properties;

        const hasAudioSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(audiosend);
        if (hasAudioSend) {
          this.state.audioSend(audiosend);
        }

        const hasScreenSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(screensend);
        if (hasScreenSend) {
          this.state.screenSend(screensend);
        }

        const hasVideoSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(videosend);
        if (hasVideoSend) {
          this.state.videoSend(videosend);
        }
      }
    });
  }

  /**
   * Verify client IDs match.
   * @param {string} clientId - Client ID to match with participant one
   * @returns {undefined} No return value
   */
  verifyClientId(clientId) {
    if (clientId) {
      const connectedClientId = this.flowEntity.remoteClientId;

      const isExpectedId = clientId === connectedClientId;
      const requestedByWrongSender = connectedClientId && !isExpectedId;
      if (requestedByWrongSender) {
        const logMessage = {
          data: {
            default: [clientId, connectedClientId],
            obfuscated: [this.callLogger.obfuscate(clientId), this.callLogger.obfuscate(connectedClientId)],
          },
          message: `State change requested from '{0}' while we are connected to '{1}'`,
        };
        this.callLogger.warn(logMessage, this);
        throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER);
      }

      this.flowEntity.remoteClientId = clientId;
    } else {
      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Sender ID missing');
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallingRepository = class CallingRepository {
  static get CONFIG() {
    return {
      DATA_CHANNEL_MESSAGE_TYPES: [z.calling.enum.CALL_MESSAGE_TYPE.HANGUP, z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC],
      DEFAULT_CONFIG_TTL: 60 * 60, // 60 minutes in seconds
      MAX_FIREFOX_TURN_COUNT: 3,
      MAX_VIDEO_PARTICIPANTS: 4,
      PROTOCOL_VERSION: '3.0',
    };
  }

  /**
   * Extended check for calling support of browser.
   * @returns {boolean} True if calling is supported
   */
  static get supportsCalling() {
    return z.util.Environment.browser.supports.calling;
  }

  /**
   * Extended check for screen sharing support of browser.
   * @returns {boolean} True if screen sharing is supported
   */
  static get supportsScreenSharing() {
    return z.util.Environment.browser.supports.screenSharing;
  }

  /**
   * Construct a new Calling repository.
   *
   * @param {CallingService} callingService -  Backend REST API calling service implementation
   * @param {ClientRepository} clientRepository - Repository for client interactions
   * @param {ConversationRepository} conversationRepository -  Repository for conversation interactions
   * @param {EventRepository} eventRepository -  Repository that handles events
   * @param {MediaRepository} mediaRepository -  Repository for media interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {UserRepository} userRepository -  Repository for all user interactions
   */
  constructor(
    callingService,
    clientRepository,
    conversationRepository,
    eventRepository,
    mediaRepository,
    serverTimeRepository,
    userRepository
  ) {
    this.getConfig = this.getConfig.bind(this);

    this.callingService = callingService;
    this.clientRepository = clientRepository;
    this.conversationRepository = conversationRepository;
    this.eventRepository = eventRepository;
    this.mediaRepository = mediaRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;

    this.messageLog = [];
    const loggerName = 'z.calling.CallingRepository';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, null, z.config.LOGGER.OPTIONS, this.messageLog);

    this.selfUserId = ko.pureComputed(() => {
      if (this.userRepository.self()) {
        return this.userRepository.self().id;
      }
    });

    this.callingConfig = undefined;
    this.callingConfigTimeout = undefined;

    // Telemetry
    this.telemetry = new z.telemetry.calling.CallTelemetry();

    // Media Handler
    this.mediaDevicesHandler = this.mediaRepository.devicesHandler;
    this.mediaStreamHandler = this.mediaRepository.streamHandler;
    this.mediaElementHandler = this.mediaRepository.elementHandler;

    this.selfStreamState = this.mediaStreamHandler.selfStreamState;

    this.calls = ko.observableArray([]);
    this.joinedCall = ko.pureComputed(() => {
      for (const callEntity of this.calls()) {
        if (callEntity.selfClientJoined()) {
          return callEntity;
        }
      }
    });

    this.flowStatus = undefined;

    this.shareCallStates();
    this.subscribeToEvents();
    this._enableDebugging();
  }

  /**
   * Share call states with MediaRepository.
   * @returns {undefined} No return value
   */
  shareCallStates() {
    this.calls.subscribe(callEntities => this.mediaStreamHandler.updateCurrentCalls(callEntities));
    this.joinedCall.subscribe(joinedCallEntity => this.mediaStreamHandler.setJoinedCall(joinedCallEntity));
  }

  /**
   * Subscribe to amplify topics.
   * @returns {undefined} No return value
   */
  subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.CALL.EVENT_FROM_BACKEND, this.onCallEvent.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.MEDIA.TOGGLE, this.toggleMedia.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.DELETE, this.deleteCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.JOIN, this.joinCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.LEAVE, this.leaveCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.REJECT, this.rejectCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.REMOVE_PARTICIPANT, this.removeParticipant.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.TOGGLE, this.toggleState.bind(this));
    amplify.subscribe(z.event.WebApp.DEBUG.UPDATE_LAST_CALL_STATUS, this.storeFlowStatus.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.getConfig);
  }

  //##############################################################################
  // Inbound call events
  //##############################################################################

  /**
   * Handle incoming calling events from backend.
   *
   * @param {Object} event - Event payload
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onCallEvent(event, source) {
    const {content: eventContent, time: eventDate, type: eventType} = event;
    const isCall = eventType === z.event.Client.CALL.E_CALL;

    const logObject = {eventJson: JSON.stringify(event), eventObject: event};
    this.callLogger.info(` Call Event: '${eventType}' (Source: ${source})`, logObject);

    if (isCall) {
      const isSupportedVersion = eventContent.version === z.calling.entities.CallMessageEntity.CONFIG.VERSION;
      if (!isSupportedVersion) {
        throw new z.error.CallError(z.error.CallError.TYPE.UNSUPPORTED_VERSION);
      }

      const callMessageEntity = z.calling.CallMessageMapper.mapEvent(event);
      this._logMessage(false, callMessageEntity, eventDate);

      this._validateMessageType(callMessageEntity)
        .then(conversationEntity => {
          const isBackendTimestamp = source !== z.event.EventRepository.SOURCE.INJECTED;
          conversationEntity.update_timestamp_server(callMessageEntity.time, isBackendTimestamp);
        })
        .then(() => {
          return z.calling.CallingRepository.supportsCalling
            ? this._onCallEventInSupportedBrowsers(callMessageEntity, source)
            : this._onCallEventInUnsupportedBrowsers(callMessageEntity, source);
        });
    }
  }

  /**
   * Call event handling for browsers supporting calling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Mapped incoming call message entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCallEventInSupportedBrowsers(callMessageEntity, source) {
    const messageType = callMessageEntity.type;

    switch (messageType) {
      case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
        return this._onCancel(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK: {
        return this._onGroupCheck(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE: {
        return this._onGroupLeave(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP: {
        return this._onGroupSetup(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START: {
        return this._onGroupStart(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP: {
        return this._onHangup(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        return this._onPropSync(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.REJECT: {
        return this._onReject(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
        return this._onSetup(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
        return this._onUpdate(callMessageEntity);
      }

      default: {
        this.callLogger.warn(`Call event of unknown type '${messageType}' was ignored`, callMessageEntity);
      }
    }
  }

  /**
   * Call event handling for browsers not supporting calling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Mapped incoming call message entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCallEventInUnsupportedBrowsers(callMessageEntity, source) {
    const {response, type, userId} = callMessageEntity;

    if (!response) {
      switch (type) {
        case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
          this.injectActivateEvent(callMessageEntity, source);
          this.userRepository.get_user_by_id(userId).then(userEntity => {
            const warningOptions = {name: userEntity.name()};
            const warningType = z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_INCOMING_CALL;

            amplify.publish(z.event.WebApp.WARNING.SHOW, warningType, warningOptions);
          });
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_INCOMING_CALL);
          break;
        }

        default: {
          break;
        }
      }
    }
  }

  /**
   * Call cancel message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.CANCEL
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCancel(callMessageEntity, source) {
    const {clientId, conversationId, response, userId} = callMessageEntity;

    if (!response) {
      const terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER;
      this.getCallById(conversationId)
        .then(callEntity => callEntity.verifySessionId(callMessageEntity))
        .then(callEntity => callEntity.deleteParticipant(userId, clientId, terminationReason))
        .then(callEntity => {
          const fromSelf = userId === this.selfUserId();
          return callEntity.deactivateCall(callMessageEntity, fromSelf, terminationReason).then(wasDeleted => {
            if (!wasDeleted && fromSelf) {
              callEntity.state(z.calling.enum.CALL_STATE.REJECTED);
            }
          });
        })
        .catch(error => {
          const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
          if (!isNotFound) {
            throw error;
          }
        });
    }
  }

  /**
   * Call group check message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onGroupCheck(callMessageEntity, source) {
    this.getCallById(callMessageEntity.conversationId)
      .then(callEntity => callEntity.scheduleGroupCheck())
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call group leave message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason=z.calling.enum.TERMINATION_REASON.OTHER_USER] - Reason for participant to leave
   * @returns {undefined} No return value
   */
  _onGroupLeave(callMessageEntity, terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER) {
    const {conversationId, clientId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        if (callEntity.isOutgoing()) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Remote user leaving outgoing call');
        }

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          callEntity.selfUserJoined(false);
          return callEntity;
        }

        return callEntity.deleteParticipant(userId, clientId, terminationReason);
      })
      .then(callEntity => callEntity.participantLeft(callMessageEntity, terminationReason))
      .catch(this._throwMessageError);
  }

  /**
   * Call group setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP
   * @returns {undefined} No return value
   */
  _onGroupSetup(callMessageEntity) {
    const {conversationId, response, userId} = callMessageEntity;

    // @todo Grant message for ongoing call
    this.getCallById(conversationId)
      .then(callEntity => this._validateMessageDestination(callEntity, callMessageEntity))
      .then(callEntity => {
        callEntity.setRemoteVersion(callMessageEntity);
        const shouldNegotiate = response !== true;
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity);
      })
      .catch(this._throwMessageError);
  }

  /**
   * Call group start message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onGroupStart(callMessageEntity, source) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        // @todo Grant message for ongoing call

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          return this._remoteSelfJoin(callEntity, callMessageEntity);
        }

        if (callEntity.isOutgoing()) {
          callEntity.state(z.calling.enum.CALL_STATE.CONNECTING);
        }

        // Add the correct participant, start negotiating
        const shouldNegotiate = callEntity.selfClientJoined();
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity);
      })
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call hangup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.HANGUP
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for the participant to hangup
   * @returns {undefined} No return value
   */
  _onHangup(callMessageEntity, terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER) {
    const {conversationId, clientId, response, userId} = callMessageEntity;

    if (!response) {
      this.getCallById(conversationId)
        .then(callEntity => callEntity.verifySessionId(callMessageEntity))
        .then(callEntity => this._confirmCallMessage(callEntity, callMessageEntity))
        .then(callEntity => callEntity.deleteParticipant(userId, clientId, terminationReason))
        .then(callEntity => callEntity.participantLeft(callMessageEntity, terminationReason))
        .catch(this._throwMessageError);
    }
  }

  /**
   * Call prop-sync message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {undefined} No return value
   */
  _onPropSync(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => callEntity.verifySessionId(callMessageEntity))
      .then(callEntity => this._confirmCallMessage(callEntity, callMessageEntity))
      .then(callEntity => callEntity.addOrUpdateParticipant(userId, false, callMessageEntity))
      .catch(this._throwMessageError);
  }

  /**
   * Call reject message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.REJECT
   * @returns {undefined} No return value
   */
  _onReject(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        const isSelfUser = userId !== this.selfUserId();
        if (!isSelfUser) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Call rejected by wrong user');
        }

        if (!callEntity.selfClientJoined()) {
          this.callLogger.info(`Rejecting call in conversation '${conversationId}'`, callEntity);
          callEntity.rejectCall(false);
        }
      })
      .catch(this._throwMessageError);
  }

  /**
   * Call setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onSetup(callMessageEntity, source) {
    const {conversationId, response, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        callEntity.setRemoteVersion(callMessageEntity);

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          return this._remoteSelfJoin(callEntity, callMessageEntity);
        }

        const shouldNegotiate = response !== true;
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity).then(() => {
          if (response) {
            callEntity.state(z.calling.enum.CALL_STATE.CONNECTING);
          }
        });
      })
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {undefined} No return value
   */
  _onUpdate(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => this._validateMessageDestination(callEntity, callMessageEntity))
      .then(callEntity => callEntity.verifySessionId(callMessageEntity))
      .then(callEntity => callEntity.addOrUpdateParticipant(userId, false, callMessageEntity))
      .catch(this._throwMessageError);
  }

  /**
   * Handle remote self join message.
   *
   * @private
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity from remote self client
   * @returns {Promise} Resolves when self join was handled
   */
  _remoteSelfJoin(callEntity, callMessageEntity) {
    const conversationEntity = callEntity.conversationEntity;

    if (callEntity.selfClientJoined()) {
      const logMessage = {
        data: {
          default: [conversationEntity.display_name()],
          obfuscated: [this.callLogger.obfuscate(conversationEntity.id)],
        },
        message: `Attempt to join ongoing call in conversation '{0}' from other device`,
      };

      this.callLogger.warn(logMessage, callEntity);
    } else {
      const logMessage = {
        data: {
          default: [conversationEntity.display_name()],
          obfuscated: [this.callLogger.obfuscate(conversationEntity.id)],
        },
        message: `Call in conversation '{0}' accepted on other device`,
      };
      this.callLogger.info(logMessage, callEntity);

      if (callEntity.isGroup) {
        callEntity.selfUserJoined(true);
        callEntity.wasConnected = true;
        return callEntity.rejectCall(false);
      }

      return this.deleteCall(conversationEntity.id);
    }
  }

  /**
   * Throw error is not expected types.
   *
   * @private
   * @param {z.error.CallError|Error} error - Error thrown during call message handling
   * @returns {undefined} No return value
   */
  _throwMessageError(error) {
    const expectedErrorTypes = [z.error.CallError.TYPE.MISTARGETED_MESSAGE, z.error.CallError.TYPE.NOT_FOUND];
    const isExpectedError = expectedErrorTypes.includes(error.type);

    if (!isExpectedError) {
      throw error;
    }
  }

  /**
   * Verify validity of incoming call.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.error.CallError|Error} error - Error thrown during call message handling
   * @returns {undefined} No return value
   */
  _validateIncomingCall(callMessageEntity, source, error) {
    this._throwMessageError(error);

    const {conversationId, response, type, userId} = callMessageEntity;

    const isTypeGroupCheck = type === z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK;
    const isSelfUser = userId === this.selfUserId();
    const validMessage = response === isTypeGroupCheck;

    if (!isSelfUser && validMessage) {
      const eventFromStream = source === z.event.EventRepository.SOURCE.STREAM;
      const silentCall = isTypeGroupCheck || eventFromStream;
      const promises = [this._createIncomingCall(callMessageEntity, source, silentCall)];

      if (!eventFromStream) {
        const eventInfoEntity = new z.conversation.EventInfoEntity(undefined, conversationId, {recipients: [userId]});
        eventInfoEntity.setType(z.cryptography.GENERIC_MESSAGE_TYPE.CALLING);
        const consentType = z.conversation.ConversationRepository.CONSENT_TYPE.INCOMING_CALL;
        const grantPromise = this.conversationRepository.grantMessage(eventInfoEntity, consentType);

        promises.push(grantPromise);
      }

      Promise.all(promises)
        .then(([callEntity, grantedCall]) => {
          if (grantedCall) {
            const mediaType = callEntity.isRemoteVideoCall() ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
            this.joinCall(conversationId, mediaType);
          }
        })
        .catch(_error => {
          const isDegraded = _error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
          if (!isDegraded) {
            throw _error;
          }

          this.rejectCall(conversationId);
        });
    }
  }

  /**
   * Validate that content of call message is targeted at local client.
   * @param {z.calling.entities.CallEntity} callEntity - Call the message belongs to
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @returns {CallEntity} Call entity if message is valid
   */
  _validateMessageDestination(callEntity, callMessageEntity) {
    if (callEntity.isGroup) {
      const {destinationClientId: clientId, destinationUserId: userId, type} = callMessageEntity;

      const isSelfUser = userId === this.selfUserId();
      const isCurrentClient = clientId === this.clientRepository.currentClient().id;
      const mistargetedMessage = !isSelfUser || !isCurrentClient;
      if (mistargetedMessage) {
        this.callLogger.log(`Ignored '${type}' call message for targeted at client '${clientId}' of user '${userId}'`);
        throw new z.error.CallError(z.error.CallError.TYPE.MISTARGETED_MESSAGE);
      }
    }

    return callEntity;
  }

  /**
   * Validate that type of call message matches conversation type.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @returns {Promise} Resolves if the message is valid
   */
  _validateMessageType(callMessageEntity) {
    const {conversationId, type} = callMessageEntity;

    return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
      if (conversationEntity.is1to1()) {
        const groupMessageTypes = [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
        ];

        if (groupMessageTypes.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
        }
      } else if (conversationEntity.isGroup()) {
        const one2oneMessageTypes = [z.calling.enum.CALL_MESSAGE_TYPE.SETUP];

        if (one2oneMessageTypes.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
        }
      } else {
        throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
      }

      return conversationEntity;
    });
  }

  //##############################################################################
  // Outbound call events
  //##############################################################################

  /**
   * Send a call event.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to send message in
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity
   * @returns {Promise} Resolves when the event has been sent
   */
  sendCallMessage(conversationEntity, callMessageEntity) {
    if (!_.isObject(callMessageEntity)) {
      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_PAYLOAD_FORMAT);
    }

    const {conversationId, remoteUserId, response, type} = callMessageEntity;

    return this.getCallById(conversationId || conversationEntity.id)
      .then(callEntity => {
        if (!CallingRepository.CONFIG.DATA_CHANNEL_MESSAGE_TYPES.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
        }

        return callEntity.getParticipantById(remoteUserId);
      })
      .then(({flowEntity}) => flowEntity.sendMessage(callMessageEntity))
      .catch(error => {
        const expectedErrorTypes = [z.error.CallError.TYPE.NO_DATA_CHANNEL, z.error.CallError.TYPE.NOT_FOUND];
        const isExpectedError = expectedErrorTypes.includes(error.type);

        if (!isExpectedError) {
          throw error;
        }

        return this._limitMessageRecipients(callMessageEntity).then(({precondition, recipients}) => {
          const isTypeHangup = type === z.calling.enum.CALL_MESSAGE_TYPE.HANGUP;
          if (isTypeHangup) {
            if (response) {
              throw error;
            }

            callMessageEntity.type = z.calling.enum.CALL_MESSAGE_TYPE.CANCEL;
          }

          this._logMessage(true, callMessageEntity);

          const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
          const protoCalling = new z.proto.Calling(callMessageEntity.toContentString());
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CALLING, protoCalling);

          const options = {precondition, recipients};
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id, options);

          return this.conversationRepository.sendCallingMessage(eventInfoEntity, conversationEntity, callMessageEntity);
        });
      });
  }

  /**
   *
   * @private
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.calling.entities.CallMessageEntity} incomingCallMessageEntity - Incoming call message
   * @returns {Promise} Resolves with the call
   */
  _confirmCallMessage(callEntity, incomingCallMessageEntity) {
    const response = incomingCallMessageEntity.response;

    const skipConfirmation = response || !callEntity.selfClientJoined();
    return skipConfirmation
      ? Promise.resolve(callEntity)
      : callEntity
          .confirmMessage(incomingCallMessageEntity)
          .catch(error => {
            const isNotDataChannel = error.type === z.error.CallError.TYPE.NO_DATA_CHANNEL;
            if (!isNotDataChannel) {
              throw error;
            }
          })
          .then(() => callEntity);
  }

  /**
   * Limit the message recipients for a call message.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to target at clients
   * @returns {Promise} Resolves with the client user map and precondition option
   */
  _limitMessageRecipients(callMessageEntity) {
    const {remoteClientId, remoteUser, remoteUserId, response, type} = callMessageEntity;
    const recipientsPromise = remoteUserId
      ? this.userRepository.get_user_by_id(remoteUserId)
      : Promise.resolve(remoteUser);

    return recipientsPromise.then(remoteUserEntity => {
      const selfUserEntity = this.userRepository.self();
      let precondition;
      let recipients;

      switch (type) {
        case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
          if (response) {
            // Send to remote client that initiated call
            precondition = true;
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
            };
          } else {
            // Send to all clients of remote user
            precondition = [remoteUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: remoteUserEntity.devices().map(device => device.id),
            };
          }
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP:
        case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP:
        case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC:
        case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
          // Send to remote client that call is connected with
          if (remoteClientId) {
            precondition = true;
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
            };
          }
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.REJECT: {
          // Send to all clients of self user
          precondition = [selfUserEntity.id];
          recipients = {
            [selfUserEntity.id]: selfUserEntity.devices().map(device => device.id),
          };
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
          if (response) {
            // Send to remote client that initiated call and all clients of self user
            precondition = [selfUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
              [selfUserEntity.id]: selfUserEntity.devices().map(device => device.id),
            };
          } else {
            // Send to all clients of remote user
            precondition = [remoteUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: remoteUserEntity.devices().map(device => device.id),
            };
          }
          break;
        }

        default: {
          break;
        }
      }

      return {precondition, recipients};
    });
  }

  //##############################################################################
  // Call actions
  //##############################################################################

  /**
   * Delete a call.
   * @param {string} conversationId - ID of conversation to delete call from
   * @returns {undefined} No return value
   */
  deleteCall(conversationId) {
    this.getCallById(conversationId)
      .then(callEntity => this._deleteCall(callEntity))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Join a call.
   *
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @returns {undefined} No return value
   */
  joinCall(conversationId, mediaType) {
    this.getCallById(conversationId)
      .then(callEntity => ({callEntity, callState: callEntity.state()}))
      .catch(error => {
        this._handleNotFoundError(error);
        return {callState: z.calling.enum.CALL_STATE.OUTGOING};
      })
      .then(({callEntity, callState}) => this._joinCall(conversationId, mediaType, callState, callEntity))
      .catch(error => this._handleJoinCallError(error, conversationId));
  }

  /**
   * User action to leave a call.
   *
   * @param {string} conversationId - ID of conversation to leave call in
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call termination
   * @returns {undefined} No return value
   */
  leaveCall(conversationId, terminationReason) {
    this.getCallById(conversationId)
      .then(callEntity => {
        const leftConversation = terminationReason === z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE;
        return leftConversation ? this._deleteCall(callEntity) : this._leaveCall(callEntity, terminationReason);
      })
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Remove a participant from a call if he was removed from the group.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} userId - ID of user to be removed
   * @returns {undefined} No return value
   */
  removeParticipant(conversationId, userId) {
    this.getCallById(conversationId)
      .then(callEntity => this._removeParticipant(callEntity, userId))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * User action to reject incoming call.
   * @param {string} conversationId - ID of conversation to ignore call in
   * @param {boolean} shareRejection - Send rejection to other clients
   * @returns {undefined} No return value
   */
  rejectCall(conversationId, shareRejection = true) {
    this.getCallById(conversationId)
      .then(callEntity => this._rejectCall(callEntity, shareRejection))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * User action to toggle one of the media states of a call.
   *
   * @param {string} conversationId - ID of conversation with call
   * @param {z.media.MediaType} mediaType - MediaType of requested change
   * @returns {undefined} No return value
   */
  toggleMedia(conversationId, mediaType) {
    return this.getCallById(conversationId)
      .then(callEntity => this._toggleMediaState(mediaType).then(() => callEntity))
      .then(callEntity => callEntity.toggleMedia(mediaType))
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (!isNotFound) {
          if (mediaType === z.media.MediaType.VIDEO || mediaType === z.media.MediaType.AUDIO_VIDEO) {
            this.mediaRepository.showNoCameraModal();
          }
          this.callLogger.error(`Failed to toggle media of type '${mediaType}'`, error);
        }
      });
  }

  /**
   * User action to toggle the call state.
   *
   * @param {z.media.MediaType} mediaType - Media type of call
   * @param {Conversation} [conversationEntity=this.conversationRepository.active_conversation()] - Conversation for which state will be toggled
   * @returns {undefined} No return value
   */
  toggleState(mediaType, conversationEntity = this.conversationRepository.active_conversation()) {
    if (conversationEntity) {
      const isActiveCall = conversationEntity.id === this._selfClientOnACall();
      return isActiveCall
        ? this.leaveCall(conversationEntity.id, z.calling.enum.TERMINATION_REASON.SELF_USER)
        : this.joinCall(conversationEntity.id, mediaType);
    }
  }

  /**
   * Check whether conversation supports calling.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @param {z.calling.enum.CALL_STATE} callState - Current state of call
   * @returns {Promise} Resolves when conversation supports calling
   */
  _checkCallingSupport(conversationId, mediaType, callState) {
    return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
      const noConversationParticipants = !conversationEntity.participating_user_ids().length;
      if (noConversationParticipants) {
        this._showModal(z.string.modalCallEmptyConversationHeadline, z.string.modalCallEmptyConversationMessage);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }

      const isOutgoingCall = callState === z.calling.enum.CALL_STATE.OUTGOING;
      if (isOutgoingCall && !z.calling.CallingRepository.supportsCalling) {
        amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_OUTGOING_CALL);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }

      const isVideoCall = mediaType === z.media.MediaType.AUDIO_VIDEO;
      if (isVideoCall && !conversationEntity.supportsVideoCall(isOutgoingCall)) {
        this._showModal(z.string.modalCallNoGroupVideoHeadline, z.string.modalCallNoGroupVideoMessage);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }
    });
  }

  /**
   * Check whether we are actively participating in a call.
   *
   * @private
   * @param {string} newCallId - Conversation ID of call about to be joined
   * @param {z.calling.enum.CALL_STATE} callState - Call state of new call
   * @returns {Promise} Resolves when the new call was joined
   */
  _checkConcurrentJoinedCall(newCallId, callState) {
    return new Promise(resolve => {
      const ongoingCallId = this._selfParticipantOnACall();

      if (!ongoingCallId) {
        resolve();
      } else {
        let actionStringId;
        let messageStringId;
        let titleStringId;

        switch (callState) {
          case z.calling.enum.CALL_STATE.INCOMING:
          case z.calling.enum.CALL_STATE.REJECTED: {
            actionStringId = z.string.modalCallSecondIncomingAction;
            messageStringId = z.string.modalCallSecondIncomingMessage;
            titleStringId = z.string.modalCallSecondIncomingHeadline;
            break;
          }

          case z.calling.enum.CALL_STATE.ONGOING: {
            actionStringId = z.string.modalCallSecondOngoingAction;
            messageStringId = z.string.modalCallSecondOngoingMessage;
            titleStringId = z.string.modalCallSecondOngoingHeadline;
            break;
          }

          case z.calling.enum.CALL_STATE.OUTGOING: {
            actionStringId = z.string.modalCallSecondOutgoingAction;
            messageStringId = z.string.modalCallSecondOutgoingMessage;
            titleStringId = z.string.modalCallSecondOutgoingHeadline;
            break;
          }

          default: {
            this.callLogger.error(`Tried to join second call in unexpected state '${callState}'`);
            throw new z.error.CallError(z.error.CallError.TYPE.WRONG_STATE);
          }
        }

        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            const terminationReason = z.calling.enum.TERMINATION_REASON.CONCURRENT_CALL;
            amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, ongoingCallId, terminationReason);
            window.setTimeout(resolve, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
          },
          close: () => {
            const isIncomingCall = callState === z.calling.enum.CALL_STATE.INCOMING;
            if (isIncomingCall) {
              amplify.publish(z.event.WebApp.CALL.STATE.REJECT, newCallId);
            }
          },
          text: {
            action: z.l10n.text(actionStringId),
            message: z.l10n.text(messageStringId),
            title: z.l10n.text(titleStringId),
          },
        });
        this.callLogger.warn(`You cannot join a second call while calling in conversation '${ongoingCallId}'.`);
      }
    });
  }

  /**
   * Delete a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to delete
   * @returns {undefined} No return value
   */
  _deleteCall(callEntity) {
    const conversationId = callEntity.id;
    this.callLogger.info(`Deleting call in conversation '${conversationId}'`, callEntity);

    callEntity.deleteCall();
    this.calls.remove(call => call.id === conversationId);
    this.mediaStreamHandler.resetMediaStream();
  }

  /**
   * Handle join call errors.
   *
   * @private
   * @param {Error} error - Error to handle
   * @param {string} conversationId - Id of conversation
   * @returns {undefined} No return value
   */
  _handleJoinCallError(error, conversationId) {
    const isNotSupported = error.type === z.error.CallError.TYPE.NOT_SUPPORTED;
    if (!isNotSupported) {
      this.deleteCall(conversationId);
      const isMediaError = error instanceof z.error.MediaError;
      if (!isMediaError) {
        throw error;
      }
    }
  }

  /**
   * Handle not found error.
   *
   * @private
   * @param {Error} error - Error to handle
   * @returns {undefined} No return value
   */
  _handleNotFoundError(error) {
    const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
    if (!isNotFound) {
      throw error;
    }
  }

  /**
   * Handle error when joining a call.
   *
   * @private
   * @param {string} conversationId - ID of call where joining failed
   * @param {boolean} isOutgoingCall - Was outgoing call
   * @param {Error} joinError - Error that occured
   * @returns {undefined} No return value
   */
  _handleJoinError(conversationId, isOutgoingCall, joinError) {
    this.getCallById(conversationId)
      .then(callEntity => {
        callEntity.setSelfState(false);

        const logMessage = `Failed to join call in '${callEntity.state()}' conversation '${conversationId}'`;
        this.callLogger.warn(logMessage, joinError);

        const accessErrors = [
          z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE,
          z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION,
        ];
        const isAccessError = accessErrors.includes(joinError.type);
        if (isAccessError) {
          this.mediaRepository.showNoCameraModal();
        }

        return isOutgoingCall ? this._deleteCall(callEntity) : this._rejectCall(callEntity, true);
      })
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Actively join a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @param {z.media.MediaType} mediaType - Media type of the call
   * @returns {undefined} No return value
   */
  _initiateJoinCall(callEntity, mediaType) {
    callEntity.timings.time_step(z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED);
    callEntity.joinCall(mediaType);
  }

  /**
   * Initiate an outgoing call.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @param {z.calling.enum.CALL_STATE} callState - State of call
   * @returns {Promise} Resolves with a call entity
   */
  _initiateOutgoingCall(conversationId, mediaType, callState) {
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;
    const payload = {conversationId};
    const messagePayload = z.calling.CallMessageBuilder.createPropSync(this.selfStreamState, payload, videoSend);
    const callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(false, undefined, messagePayload);
    return this._createOutgoingCall(callMessageEntity);
  }

  /**
   * Prepare to join a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @returns {undefined} No return value
   */
  _initiatePreJoinCall(callEntity) {
    this.callLogger.info(`Joining call in conversation '${callEntity.id}'`, callEntity);
    callEntity.setSelfState(true);
    return callEntity;
  }

  /**
   * Initiate media stream for call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @returns {Promise} Resolves with the call entity
   */
  _initiateMediaStream(callEntity, mediaType) {
    return this.mediaStreamHandler.localMediaStream()
      ? Promise.resolve(callEntity)
      : this.mediaStreamHandler
          .initiateMediaStream(callEntity.id, mediaType, callEntity.isGroup)
          .then(() => callEntity);
  }

  /**
   * Join a call.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type of the call
   * @param {z.calling.enum.CALL_STATE} callState - State of call
   * @param {CallEntity} [callEntity] - Retrieved call entity
   * @returns {undefined} No return value
   */
  _joinCall(conversationId, mediaType, callState, callEntity) {
    this._checkCallingSupport(conversationId, mediaType, callState)
      .then(() => this._checkConcurrentJoinedCall(conversationId, callState))
      .then(() => callEntity || this._initiateOutgoingCall(conversationId, mediaType, callState))
      .then(callEntityToJoin => this._initiatePreJoinCall(callEntityToJoin))
      .then(callEntityToJoin => this._initiateMediaStream(callEntityToJoin, mediaType))
      .then(callEntityToJoin => this._initiateJoinCall(callEntityToJoin, mediaType))
      .catch(error => this._handleJoinError(conversationId, !callEntity, error));
  }

  /**
   * Leave a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to leave
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call termination
   * @returns {undefined} No return value
   */
  _leaveCall(callEntity, terminationReason) {
    const conversationId = callEntity.id;
    const logMessage = `Leaving call in conversation '${conversationId}' triggered by '${terminationReason}'`;
    this.callLogger.info(logMessage, callEntity);

    if (!callEntity.isOngoing()) {
      terminationReason = undefined;
    }

    this.mediaStreamHandler.releaseMediaStream();
    callEntity.leaveCall(terminationReason);
  }

  /**
   * Reject a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call entity to ignore
   * @param {boolean} shareRejection - Share rejection with other clients
   * @returns {undefined} No return value
   */
  _rejectCall(callEntity, shareRejection) {
    this.callLogger.info(`Rejecting call in conversation '${callEntity.id}'`, callEntity);
    callEntity.rejectCall(shareRejection);
  }

  /**
   * Remove a participant from a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call entity
   * @param {string} userId - ID of user to be removed
   * @returns {Promise} Resolves when the participant was found
   */
  _removeParticipant(callEntity, userId) {
    return callEntity.getParticipantById(userId).then(() => {
      const {id, sessionId} = callEntity;
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(id, this.selfUserId(), userId);
      const callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, sessionId, additionalPayload);

      this._onGroupLeave(callMessageEntity, z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE);
    });
  }

  /**
   * Show acknowledgement warning modal.
   *
   * @private
   * @param {string} titleStringId - String ID for modal title
   * @param {string} messageStringId - String ID for modal message
   * @returns {undefined} No return value
   */
  _showModal(titleStringId, messageStringId) {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: z.l10n.text(messageStringId),
        title: z.l10n.text(titleStringId),
      },
    });
  }

  /**
   * Toggle media state of a call.
   *
   * @param {z.media.MediaType} mediaType - MediaType of requested change
   * @returns {undefined} No return value
   */
  _toggleMediaState(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return this.mediaStreamHandler.toggleAudioSend();
      }

      case z.media.MediaType.SCREEN: {
        return this.mediaStreamHandler.toggleScreenSend();
      }

      case z.media.MediaType.VIDEO: {
        return this.mediaStreamHandler.toggleVideoSend();
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  //##############################################################################
  // call entity creation
  //##############################################################################

  /**
   * Constructs a call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.entity.User} creatingUserEntity - User that created call
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @returns {Promise} Resolves with the new call entity
   */
  _createCall(callMessageEntity, creatingUserEntity, direction) {
    const {conversationId, sessionId, properties} = callMessageEntity;
    const mediaType = this._getMediaTypeFromProperties(properties);

    return this.getCallById(conversationId).catch(() => {
      return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
        const callEntity = new z.calling.entities.CallEntity(conversationEntity, creatingUserEntity, sessionId, this);

        callEntity.initiateTelemetry(direction, mediaType);
        this.calls.push(callEntity);
        return callEntity;
      });
    });
  }

  /**
   * Constructs an incoming call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {boolean} [silent=false] - Start call in rejected mode
   * @returns {Promise} Resolves with the new call entity
   */
  _createIncomingCall(callMessageEntity, source, silent = false) {
    const {conversationId, properties, userId} = callMessageEntity;

    return this.userRepository
      .get_user_by_id(userId)
      .then(remoteUserEntity => {
        return this._createCall(callMessageEntity, remoteUserEntity, z.calling.enum.CALL_STATE.INCOMING);
      })
      .then(callEntity => {
        const mediaType = this._getMediaTypeFromProperties(properties);
        const conversationName = callEntity.conversationEntity.display_name();

        const logMessage = {
          data: {
            default: [mediaType, conversationName],
            obfuscated: [mediaType, this.callLogger.obfuscate(conversationId)],
          },
          message: `Incoming '{0}' call in conversation '{1}'`,
        };
        this.callLogger.info(logMessage, callEntity);

        callEntity.setRemoteVersion(callMessageEntity);

        if (!callEntity.conversationEntity.showNotificationsEverything()) {
          silent = true;
        }

        const callState = silent ? z.calling.enum.CALL_STATE.REJECTED : z.calling.enum.CALL_STATE.INCOMING;
        callEntity.state(callState);

        return callEntity.addOrUpdateParticipant(userId, false, callMessageEntity).then(() => {
          this.telemetry.track_event(z.tracking.EventName.CALLING.RECEIVED_CALL, callEntity);
          this.injectActivateEvent(callMessageEntity, source);

          const eventFromWebSocket = source === z.event.EventRepository.SOURCE.WEB_SOCKET;
          const hasOtherCalls = this.calls().some(call => call.id !== callEntity.id);
          const hasCallWithoutVideo = hasOtherCalls && !this.mediaStreamHandler.selfStreamState.videoSend();

          if (eventFromWebSocket && callEntity.isRemoteVideoSend() && !hasCallWithoutVideo) {
            const mediaStreamType = z.media.MediaType.AUDIO_VIDEO;
            this.mediaStreamHandler.initiateMediaStream(callEntity.id, mediaStreamType, callEntity.isGroup);
          }

          return callEntity;
        });
      })
      .catch(error => {
        this.deleteCall(conversationId);

        const isMediaError = error instanceof z.error.MediaError;
        if (!isMediaError) {
          throw error;
        }
      });
  }

  /**
   * Constructs an outgoing call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC
   * @returns {Promise} Resolves with the new call entity
   */
  _createOutgoingCall(callMessageEntity) {
    const properties = callMessageEntity.properties;

    const direction = z.calling.enum.CALL_STATE.OUTGOING;
    return this._createCall(callMessageEntity, this.userRepository.self(), direction).then(callEntity => {
      const mediaType = this._getMediaTypeFromProperties(properties);
      const conversationName = callEntity.conversationEntity.display_name();
      const conversationId = callEntity.conversationEntity.id;

      const logMessage = {
        data: {
          default: [mediaType, conversationName],
          obfuscated: [mediaType, this.callLogger.obfuscate(conversationId)],
        },
        message: `Outgoing '{0}' call in conversation '{1}'`,
      };
      this.callLogger.info(logMessage, callEntity);

      callEntity.state(z.calling.enum.CALL_STATE.OUTGOING);

      this.telemetry.track_event(z.tracking.EventName.CALLING.INITIATED_CALL, callEntity);
      return callEntity;
    });
  }

  //##############################################################################
  // Notifications
  //##############################################################################

  /**
   * Inject a call activate event.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to create event from
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  injectActivateEvent(callMessageEntity, source) {
    const event = z.conversation.EventBuilder.buildVoiceChannelActivate(callMessageEntity);
    this.eventRepository.injectEvent(event, source);
  }

  /**
   * Inject a call deactivate event.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to create event from
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.calling.enum.TERMINATION_REASON} [reason] - Reason for call to end
   * @returns {undefined} No return value
   */
  injectDeactivateEvent(callMessageEntity, source, reason) {
    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const event = z.conversation.EventBuilder.buildVoiceChannelDeactivate(callMessageEntity, reason, currentTimestamp);
    this.eventRepository.injectEvent(event, source);
  }

  //##############################################################################
  // Helper functions
  //##############################################################################

  /**
   * Get a call entity for a given conversation ID.
   * @param {string} conversationId - ID of Conversation of requested call
   * @returns {Promise} Resolves with the call entity for conversation ID
   */
  getCallById(conversationId) {
    if (!conversationId) {
      return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NO_CONVERSATION_ID));
    }

    for (const callEntity of this.calls()) {
      const isExpectedId = callEntity.id === conversationId;
      if (isExpectedId) {
        return Promise.resolve(callEntity);
      }
    }

    return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND));
  }

  /**
   * Leave a call we are joined immediately in case the browser window is closed.
   * @note Should only used by "window.onbeforeunload".
   * @returns {undefined} No return value
   */
  leaveCallOnUnload() {
    const conversationId = this._selfClientOnACall();

    if (conversationId) {
      this.leaveCall(conversationId, z.calling.enum.TERMINATION_REASON.PAGE_NAVIGATION);
    }
  }

  /**
   * Get the MediaType from given call event properties.
   * @param {Object} properties - call event properties
   * @returns {z.media.MediaType} MediaType of call
   */
  _getMediaTypeFromProperties(properties) {
    const isVideoSend = properties && properties.videosend === z.calling.enum.PROPERTY_STATE.TRUE;
    const isScreenSend = properties && properties.screensend === z.calling.enum.PROPERTY_STATE.TRUE;
    const isTypeVideo = isVideoSend || isScreenSend;
    return isTypeVideo ? z.media.MediaType.VIDEO : z.media.MediaType.AUDIO;
  }

  /**
   * Check if self client is participating in a call.
   * @private
   * @returns {string|boolean} Conversation ID of call or false
   */
  _selfClientOnACall() {
    for (const callEntity of this.calls()) {
      if (callEntity.selfClientJoined()) {
        return callEntity.id;
      }
    }

    return false;
  }

  /**
   * Check if self participant is participating in a call.
   * @private
   * @returns {string|boolean} Conversation ID of call or false
   */
  _selfParticipantOnACall() {
    for (const callEntity of this.calls()) {
      if (callEntity.selfUserJoined()) {
        return callEntity.id;
      }
    }

    return false;
  }

  //##############################################################################
  // Calling config
  //##############################################################################

  /**
   * Get the current calling config.
   * @returns {Promise} Resolves with calling config
   */
  getConfig() {
    if (this.callingConfig) {
      const isExpiredConfig = this.callingConfig.expiration.getTime() < Date.now();

      if (!isExpiredConfig) {
        this.callLogger.debug('Returning local calling configuration. No update needed.', this.callingConfig);
        return Promise.resolve(this.callingConfig);
      }

      this._clearConfig();
    }

    return this._getConfigFromBackend();
  }

  _clearConfig() {
    if (this.callingConfig) {
      const expirationDate = this.callingConfig.expiration.toISOString();
      this.callLogger.debug(`Removing calling configuration with expiration of '${expirationDate}'`);
      this.callingConfig = undefined;
    }
  }

  _clearConfigTimeout() {
    if (this.callingConfigTimeout) {
      window.clearTimeout(this.callingConfigTimeout);
      this.callingConfigTimeout = undefined;
    }
  }

  /**
   * Get the calling config from the backend and store it.
   *
   * @private
   * @returns {Promise} Resolves with the updated calling config
   */
  _getConfigFromBackend() {
    const limit = z.util.Environment.browser.firefox ? CallingRepository.CONFIG.MAX_FIREFOX_TURN_COUNT : undefined;

    return this.callingService.getConfig(limit).then(callingConfig => {
      if (callingConfig) {
        this._clearConfigTimeout();

        const DEFAULT_CONFIG_TTL = CallingRepository.CONFIG.DEFAULT_CONFIG_TTL;
        const ttl = callingConfig.ttl * 0.9 || DEFAULT_CONFIG_TTL;
        const timeout = Math.min(ttl, DEFAULT_CONFIG_TTL) * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        const expirationDate = new Date(Date.now() + timeout);
        callingConfig.expiration = expirationDate;

        const logMessage = `Updated calling configuration expires on '${expirationDate.toISOString()}'`;
        this.callLogger.info(logMessage, callingConfig);
        this.callingConfig = callingConfig;

        this.callingConfigTimeout = window.setTimeout(() => {
          this._clearConfig();
          this.getConfig();
        }, timeout);

        return this.callingConfig;
      }
    });
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Print the call message log.
   * @returns {undefined} No return value
   */
  printLog() {
    this.callLogger.force_log(`Call message log contains '${this.messageLog.length}' events`, this.messageLog);
    this.messageLog.forEach(logMessage => this.callLogger.force_log(logMessage));
  }

  /**
   * Report a call for call analysis.
   * @param {string} conversationId - ID of conversation
   * @returns {undefined} No return value
   */
  reportCall(conversationId) {
    this.getCallById(conversationId)
      .catch(() => {
        for (const callEntity of this.calls()) {
          if (!callEntity.isEndedState()) {
            return callEntity;
          }
        }
      })
      .then(callEntity => {
        if (callEntity) {
          return this._sendReport(callEntity.getFlows().map(flowEntity => flowEntity.reportStatus()));
        }

        if (this.flowStatus) {
          return this._sendReport(this.flowStatus);
        }

        this.callLogger.warn('Could not find flows to report for call analysis');
      });
  }

  /**
   * Set logging on adapter.js.
   * @returns {undefined} No return value
   */
  _enableDebugging() {
    if (window.adapter) {
      window.adapter.disableLog = false;
    } else {
      this.callLogger.warn('WebRTC Adapter not found while trying to enable logging');
    }
  }

  /**
   * Store last flow status.
   * @param {Object} flowStatus - Status to store
   * @returns {undefined} No return value
   */
  storeFlowStatus(flowStatus) {
    if (flowStatus) {
      this.flowStatus = flowStatus;
    }
  }

  /**
   * Log call messages for debugging.
   *
   * @private
   * @param {boolean} isOutgoing - Is message outgoing
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be logged in the sequence
   * @param {string} [date] - Date of message as ISO string
   * @returns {undefined} No return value
   */
  _logMessage(isOutgoing, callMessageEntity, date = new Date().toISOString()) {
    const {conversationId, destinationUserId, remoteUserId, response, type, userId} = callMessageEntity;

    let log;
    const target = `conversation '${conversationId}'`;
    if (isOutgoing) {
      const additionalMessage = remoteUserId ? `user '${remoteUserId}' in ${target}` : `${target}`;
      log = `Sending '${type}' message (response: ${response}) to ${additionalMessage}`;
    } else {
      const isSelfUser = destinationUserId === this.selfUserId();
      if (destinationUserId && !isSelfUser) {
        return;
      }

      log = `Received '${type}' message (response: ${response}) from user '${userId}' in ${target}`;
    }

    if (callMessageEntity.properties) {
      log = log.concat(`: ${JSON.stringify(callMessageEntity.properties)}`);
    }

    this.callLogger.info(log, callMessageEntity);
  }

  /**
   * Send Raygun report.
   *
   * @private
   * @param {Object} customData - Information to add to the call report
   * @returns {undefined} No return value
   */
  _sendReport(customData) {
    Raygun.send(new Error('Call failure report'), customData);
    this.callLogger.debug(`Reported status of flow id '${customData.meta.flowId}' for call analysis`, customData);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallingService = class CallingService {
  /**
   * Construct an new CallingService.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
  }

  /**
   * Retrieves a calling config from the backend.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//getCallsConfigV2
   * @see ./documentation/blob/master/topics/web/calling/calling-v3.md#limiting
   *
   * @param {number} [limit] - Limit the number of TURNs servers in the response (range 1, 10)
   * @returns {Promise} Resolves with call config information
   */
  getConfig(limit) {
    return this.backendClient.sendRequest({
      cache: false,
      data: {
        limit,
      },
      type: 'GET',
      url: '/calls/config/v2',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallMessageBuilder = (() => {
  const _buildCallMessage = (type, response, sessionId, additionalPayload) => {
    const callMessageEntity = new z.calling.entities.CallMessageEntity(type, response, sessionId);

    if (additionalPayload) {
      callMessageEntity.addProperties(additionalPayload);
    }

    return callMessageEntity;
  };

  const _buildCancel = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.CANCEL, response, sessionId, additionalPayload);
  };

  const _buildGroupCheck = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK, response, sessionId, additionalPayload);
  };

  const _buildGroupLeave = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE, response, sessionId, additionalPayload);
  };

  const _buildGroupSetup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP, response, sessionId, additionalPayload);
  };

  const _buildGroupStart = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START, response, sessionId, additionalPayload);
  };

  const _buildHangup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.HANGUP, response, sessionId, additionalPayload);
  };

  const _buildPropSync = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC, response, sessionId, additionalPayload);
  };

  const _buildReject = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.REJECT, response, sessionId, additionalPayload);
  };

  const _buildSetup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.SETUP, response, sessionId, additionalPayload);
  };

  const _buildUpdate = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.UPDATE, response, sessionId, additionalPayload);
  };

  /**
   * Create additional payload.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} selfUserId - ID of self user
   * @param {string} [remoteUserId] - Optional ID of remote user
   * @param {string} [remoteClientId] - Optional ID of remote client
   * @returns {{conversationId: string, remoteClientId: string, remoteUserId: *, time: string, userId: string}} Additional payload
   */
  const _createPayload = (conversationId, selfUserId, remoteUserId, remoteClientId) => {
    return {conversationId, remoteClientId, remoteUserId, time: new Date().toISOString(), userId: selfUserId};
  };

  /**
   * Create properties payload for call events.
   *
   * @param {Object} selfState - Current self state
   * @param {Object} additionalPayload - Optional additional payload to be added
   * @param {boolean} [videoStateOverwrite] - Forces the videosend property to be this value instead of the one in the selfState
   * @returns {Object} call message props object
   */
  const _createPropSync = (selfState, additionalPayload, videoStateOverwrite) => {
    const payload = {};
    const {audioSend: audioState, videoSend: videoState, screenSend: screenState} = selfState;
    const videoSend = _.isBoolean(videoStateOverwrite) ? videoStateOverwrite : videoState();

    payload.properties = {
      audiosend: `${audioState()}`,
      screensend: `${screenState()}`,
      videosend: `${videoSend}`,
    };

    return additionalPayload ? Object.assign(payload, additionalPayload) : payload;
  };

  return {
    buildCancel: _buildCancel,
    buildGroupCheck: _buildGroupCheck,
    buildGroupLeave: _buildGroupLeave,
    buildGroupSetup: _buildGroupSetup,
    buildGroupStart: _buildGroupStart,
    buildHangup: _buildHangup,
    buildPropSync: _buildPropSync,
    buildReject: _buildReject,
    buildSetup: _buildSetup,
    buildUpdate: _buildUpdate,
    createPayload: _createPayload,
    createPropSync: _createPropSync,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallMessageMapper = {
  /**
   * Map incoming call message into entity.
   *
   * @private
   * @param {Object} event - Call event object
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  mapEvent(event) {
    const {content: callMessage, conversation: conversationId, from: userId, sender: clientId, time} = event;

    const additionalProperties = {clientId, conversationId, time, userId};

    let content = undefined;
    switch (callMessage.type) {
      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP:
      case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
        const {
          dest_clientid: destinationClientId,
          dest_userid: destinationUserId,
          props: properties,
          sdp,
        } = callMessage;

        content = {destinationClientId, destinationUserId, properties, sdp};
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        const properties = callMessage.props;

        content = {properties};
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START:
      case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
        const {props: properties, sdp} = callMessage;

        content = {properties, sdp};
        break;
      }

      default: {
        break;
      }
    }

    if (content) {
      Object.assign(additionalProperties, content);
    }

    const {type, resp: response, sessid: sessionId} = callMessage;
    const callMessageEntity = new z.calling.entities.CallMessageEntity(type, response, sessionId);

    callMessageEntity.addProperties(additionalProperties);

    return callMessageEntity;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.SDPMapper = {
  CONFIG: {
    AUDIO_BITRATE: '30',
    AUDIO_PTIME: '60',
  },

  /**
   * Get the tool version that generated the SDP
   * @param {string} sdpString - Full SDP string
   * @returns {string} Tool version of SDP
   */
  getToolVersion(sdpString) {
    for (const sdpLine of sdpString.split('\r\n')) {
      if (sdpLine.startsWith('a=tool')) {
        return sdpLine.replace('a=tool:', '');
      }
    }
  },

  /**
   * Map call setup message to RTCSessionDescription.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {Promise} Resolves with a webRTC standard compliant RTCSessionDescription
   */
  mapCallMessageToObject(callMessageEntity) {
    const {response, sdp: sdpString} = callMessageEntity;
    const sdp = {
      sdp: sdpString,
      type: response ? z.calling.rtc.SDP_TYPE.ANSWER : z.calling.rtc.SDP_TYPE.OFFER,
    };

    return Promise.resolve(sdp);
  },

  /**
   * Rewrite the SDP for compatibility reasons.
   *
   * @param {RTCSessionDescription} rtcSdp - Session Description Protocol to be rewritten
   * @param {z.calling.enum.SDP_SOURCE} [sdpSource=z.calling.enum.SDP_SOURCE.REMOTE] - Source of the SDP - local or remote
   * @param {z.calling.entities.FlowEntity} flowEntity - Flow entity
   * @returns {Object} Object containing rewritten Session Description Protocol and number of ICE candidates
   */
  rewriteSdp(rtcSdp, sdpSource = z.calling.enum.SDP_SOURCE.REMOTE, flowEntity) {
    if (!rtcSdp) {
      throw new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND, 'Cannot rewrite undefined SDP');
    }

    const {sdp, type} = rtcSdp;
    const sdpLines = [];
    const iceCandidates = [];
    let sessionDescription;

    const isIceRestart = flowEntity.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.ICE_RESTART;
    const isLocalSdp = sdpSource === z.calling.enum.SDP_SOURCE.LOCAL;
    const isLocalSdpInGroup = isLocalSdp && flowEntity.isGroup;
    const isOffer = rtcSdp.type === z.calling.rtc.SDP_TYPE.OFFER;

    sessionDescription = isLocalSdp ? sdp.replace('UDP/TLS/', '') : sdp;

    sessionDescription.split('\r\n').forEach(sdpLine => {
      let outline = sdpLine;

      if (sdpLine.startsWith('t=')) {
        if (isLocalSdp) {
          sdpLines.push(sdpLine);

          const browserString = `${z.util.Environment.browser.name} ${z.util.Environment.browser.version}`;
          const webappVersion = z.util.Environment.version(false);

          outline = z.util.Environment.desktop
            ? `a=tool:electron ${z.util.Environment.version(true)} ${webappVersion} (${browserString})`
            : `a=tool:webapp ${webappVersion} (${browserString})`;
        }
      } else if (sdpLine.startsWith('a=candidate')) {
        iceCandidates.push(sdpLine);
      } else if (sdpLine.startsWith('m=')) {
        if (sdpLine.startsWith('m=audio')) {
          // Code to nail in bit-rate and ptime settings for improved performance and experience
          const shouldAddBitRate = isLocalSdpInGroup || isIceRestart;
          if (shouldAddBitRate) {
            sdpLines.push(sdpLine);
            outline = `b=AS:${z.calling.SDPMapper.CONFIG.AUDIO_BITRATE}`;
          }
        } else if (z.util.Environment.browser.firefox && isLocalSdp && isOffer) {
          // Set ports to activate media in outgoing Firefox SDP to ensure enabled media
          outline = sdpLine.replace(/^m=(application|video) 0/, 'm=$1 9');
        }
      } else if (sdpLine.startsWith('a=rtpmap')) {
        const shouldAddPTime = isLocalSdpInGroup || isIceRestart;
        if (shouldAddPTime && z.util.StringUtil.includes(sdpLine, 'opus')) {
          sdpLines.push(sdpLine);
          outline = `a=ptime:${z.calling.SDPMapper.CONFIG.AUDIO_PTIME}`;
        }
      }

      if (outline !== undefined) {
        sdpLines.push(outline);
      }
    });

    sessionDescription = sdpLines.join('\r\n');
    const sdpInit = {sdp: sessionDescription, type};
    return {iceCandidates, sdp: sdpInit};
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.VideoGridRepository = class VideoGridRepository {
  /**
   * Construct an new VideoGridRepository.
   * @param {CallingRepository} callingRepository - Repository for the calls
   * @param {MediaRepository} mediaRepository - Repository for the media streams
   */
  constructor(callingRepository, mediaRepository) {
    const streamHandler = mediaRepository.streamHandler;
    const streamsInfo = streamHandler.remoteMediaStreamInfoIndex.video;
    const {hasActiveVideo, localMediaStream, selfStreamState} = streamHandler;

    const calls = callingRepository.calls;
    this.grid = ko.observableArray([0, 0, 0, 0]);
    this.thumbnailStream = ko.observable();

    const selfStream = ko.pureComputed(() => {
      const stream = hasActiveVideo() ? localMediaStream() : undefined;
      return {
        audioSend: selfStreamState.audioSend,
        id: stream && stream.id,
        isSelf: true,
        screenSend: selfStreamState.screenSend,
        stream: stream,
        videoSend: selfStreamState.videoSend,
      };
    });

    this.streams = ko.pureComputed(() => {
      const videoParticipants = calls()
        .reduce((participantEntities, callEntity) => participantEntities.concat(callEntity.participants()), [])
        .filter(participantEntity => participantEntity.hasActiveVideo());

      const videoParticipantIds = videoParticipants.map(participant => participant.id);

      const remoteStreams = streamsInfo()
        .filter(mediaStreamInfo => videoParticipantIds.includes(mediaStreamInfo.flowId))
        .map(mediaStreamInfo => {
          const stream = mediaStreamInfo.stream;
          const participant = videoParticipants.find(videoParticipant => {
            return videoParticipant.id === mediaStreamInfo.flowId;
          });

          return {
            id: stream.id,
            picture: participant.user.mediumPictureResource,
            screenSend: participant.state.screenSend,
            stream: stream,
            videoSend: participant.state.videoSend,
          };
        });

      if (remoteStreams.length === 1) {
        this.thumbnailStream(selfStream());
        return remoteStreams;
      }
      this.thumbnailStream(undefined);
      return selfStream().stream ? remoteStreams.concat(selfStream()) : remoteStreams;
    });

    this.streams.subscribe(this.updateGrid.bind(this));
    this.updateGrid(this.streams());
  }

  /**
   * Will compute the next grid layout according to the previous state and the new array of streams
   * The grid will fill according to this pattern
   * - 1 stream : [id, 0, 0, 0]
   * - 2 streams: [id, 0, id, 0]
   * - 3 streams: [id, 0, id, id]
   * - 3 streams: [id, id, 0, id]
   * - 4 streams: [id, id, id, id]
   * @param {Array<string|0>} previousGrid - the previous state of the grid
   * @param {Array<MediaStream>} streams - the new array of streams to dispatch in the grid
   *
   * @returns {Array<string|0>} the new grid
   */
  computeGrid(previousGrid, streams) {
    const previousStreamIds = previousGrid.filter(streamId => streamId !== 0);
    const currentStreamIds = streams.map(stream => stream.id);

    const addedStreamIds = z.util.ArrayUtil.getDifference(previousStreamIds, currentStreamIds);

    const filteredGrid = previousGrid.map(id => (currentStreamIds.includes(id) ? id : 0));

    const streamIds = filteredGrid.filter(streamId => streamId !== 0);
    // Add the new streams at the end
    const newStreamsIds = streamIds.concat(addedStreamIds);
    return newStreamsIds.length === 2
      ? [newStreamsIds[0], 0, newStreamsIds[1], 0]
      : [newStreamsIds[0] || 0, newStreamsIds[3] || 0, newStreamsIds[1] || 0, newStreamsIds[2] || 0];
  }

  updateGrid(streams) {
    const newGrid = this.computeGrid(this.grid(), streams);
    this.grid(newGrid);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectService = class ConnectService {
  /**
   * Construct an new ConnectService.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.connect.ConnectService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Upload address book data for matching.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/addressbook/onboardingV3
   *
   * @param {z.connect.PhoneBook} phoneBook - Phone book containing the address cards
   * @returns {Promise} Resolves with the matched contacts from the user's phone book
   */
  postOnboarding(phoneBook) {
    return this.backendClient.sendJson({
      data: phoneBook,
      type: 'POST',
      url: '/onboarding/v3',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectRepository = class ConnectRepository {
  constructor(connectService, propertiesRepository) {
    this.connectService = connectService;
    this.propertiesRepository = propertiesRepository;
    this.logger = new z.util.Logger('z.connect.ConnectRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Get user's contacts for matching.
   * @param {z.connect.ConnectSource} source - Source for phone book retrieval
   * @returns {Promise} Resolves with the matched user IDs
   */
  getContacts(source) {
    return this._getMacosContacts().then(phoneBook => this._uploadContacts(phoneBook, source));
  }

  /**
   * Encode phone book
   *
   * @private
   * @param {z.connect.PhoneBook} phoneBook - Object containing un-encoded phone book data
   * @returns {z.connect.PhoneBook} Object containing encoded phone book data
   */
  _encodePhoneBook(phoneBook) {
    const {cards, self} = phoneBook;
    self.forEach((contact, contactIndex) => (self[contactIndex] = z.util.encodeSha256Base64(contact)));

    cards.forEach((card, cardIndex) => {
      card.contact.forEach((contact, contactIndex) => {
        card.contact[contactIndex] = z.util.encodeSha256Base64(contact);
      });
      cards[cardIndex] = card;
    });

    return phoneBook;
  }

  /**
   * Retrieve a user's macOS address book contacts.
   * @private
   * @returns {Promise} Resolves with the user's address book contacts that match on Wire
   */
  _getMacosContacts() {
    return this._parseMacosContacts();
  }

  /**
   * Parse a user's macOS address book Contacts.
   * @private
   * @returns {Promise} Resolves with encoded phone book data
   */
  _parseMacosContacts() {
    return new Promise((resolve, reject) => {
      if (!window.wAddressBook) {
        return reject(new z.error.ConnectError(z.error.ConnectError.TYPE.NOT_SUPPORTED));
      }
      const addressBook = window.wAddressBook;
      const phoneBook = new z.connect.PhoneBook();

      const {numbers: selfNumbers} = addressBook.getMe();
      selfNumbers.forEach(number => phoneBook.self.push(number));

      addressBook.getContacts(
        percentage => {
          this.logger.info('Importing Contacts', percentage);
        },
        contacts => {
          contacts.forEach(({firstName, lastName, numbers}) => {
            const card = {
              card_id: CryptoJS.MD5(`${firstName}${lastName}`).toString(),
              contact: [],
            };

            numbers.forEach(number => card.contact.push(z.util.phoneNumberToE164(number, navigator.language)));

            if (card.contact.length) {
              phoneBook.cards.push(card);
            }
          });

          return resolve(this._encodePhoneBook(phoneBook));
        }
      );
    });
  }

  /**
   * Upload hashed phone booked to backend for matching.
   *
   * @private
   * @param {z.connect.PhoneBook} phoneBook - Encoded phone book data
   * @param {z.connect.ConnectSource} source - Source of phone book data
   * @returns {Promise} Resolves when phone book was uploaded
   */
  _uploadContacts(phoneBook, source) {
    const cards = phoneBook.cards;

    if (!cards.length) {
      this.logger.warn('No contacts found for upload');
      throw new z.error.ConnectError(z.error.ConnectError.TYPE.NO_CONTACTS);
    }

    this.logger.info(`Uploading hashes of '${cards.length}' contacts for matching`, phoneBook);
    return this.connectService
      .postOnboarding(phoneBook)
      .then(({results}) => {
        this.logger.info(`Upload of '${source}' contacts upload successful: ${results.length} matches`, results);
        return results.map(result => result.id);
      })
      .catch(error => {
        switch (error.type) {
          case z.error.ConnectError.TYPE.NO_CONTACTS:
            return {};
          default:
            if (error.code === z.error.BackendClientError.STATUS_CODE.TOO_MANY_REQUESTS) {
              this.logger.error(`Backend refused upload of '${source}' contacts: Endpoint used too frequent`, error);
            } else {
              this.logger.error(`Upload of '${source}' contacts failed`, error);
            }
            throw new z.error.ConnectError(z.error.ConnectError.TYPE.UPLOAD);
        }
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectSource = {
  ICLOUD: 'icloud',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.PhoneBook = class PhoneBook {
  /**
   * Construct a new Phone book.
   */
  constructor() {
    this.self = [];
    this.cards = [];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionEntity = class ConnectionEntity {
  constructor() {
    this.conversationId = null;
    this.from = null;
    this.lastUpdate = null;
    this.message = null;
    this.status = ko.observable(z.connection.ConnectionStatus.UNKNOWN);
    this.userId = null;

    this.isBlocked = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.BLOCKED);
    this.isCanceled = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.CANCELLED);
    this.isConnected = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.ACCEPTED);
    this.isIgnored = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.IGNORED);
    this.isIncomingRequest = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.PENDING);
    this.isOutgoingRequest = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.SENT);
    this.isUnknown = ko.pureComputed(() =>
      [z.connection.ConnectionStatus.CANCELLED, z.connection.ConnectionStatus.UNKNOWN].includes(this.status())
    );

    this.isRequest = ko.pureComputed(() => this.isIncomingRequest() || this.isOutgoingRequest());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

/**
 * Connection mapper to convert all server side JSON connections into core connection entities.
 * @class z.connection.ConnectionMapper
 */
z.connection.ConnectionMapper = class ConnectionMapper {
  // Construct a new connection mapper.
  constructor() {
    this.logger = new z.util.Logger('z.connection.ConnectionMapper', z.config.LOGGER.OPTIONS);

    /**
     * Converts JSON connection into connection entity.
     * @param {Object} connectionData - Connection data
     * @returns {z.connection.ConnectionEntity} Mapped connection entity
     */
    this.mapConnectionFromJson = connectionData => {
      const connectionEntitiy = new z.connection.ConnectionEntity();
      return this.updateConnectionFromJson(connectionEntitiy, connectionData);
    };

    /**
     * Convert multiple JSON connections into connection entities.
     * @param {Array<Object>} connectionsData - Connection data
     * @returns {Array<z.connection.ConnectionEntity>} Mapped connection entities
     */
    this.mapConnectionsFromJson = connectionsData => {
      return connectionsData
        .filter(connectionData => connectionData)
        .map(connectionData => this.mapConnectionFromJson(connectionData));
    };

    /**
     * Maps JSON connection into a blank connection entity or updates an existing one.
     * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity that the info shall be mapped to
     * @param {JSON} connectionData - Connection data
     * @returns {z.connection.ConnectionEntity} Mapped connection entity
     */
    this.updateConnectionFromJson = (connectionEntity, connectionData) => {
      const {conversation, from, last_update, message, status, to: remoteUserId} = connectionData;

      connectionEntity.status(status);
      connectionEntity.conversationId = conversation;
      connectionEntity.userId = remoteUserId;
      connectionEntity.from = from;
      connectionEntity.lastUpdate = last_update;
      connectionEntity.message = message;
      return connectionEntity;
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionRepository = class ConnectionRepository {
  static get CONFIG() {
    return {
      SUPPORTED_EVENTS: [z.event.Backend.USER.CONNECTION],
    };
  }
  /**
   * Construct a new Connection repository.
   * @class z.connection.ConnectionRepository
   * @param {z.connection.ConnectionService} connectionService - Backend REST API connection service implementation
   * @param {z.repository.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(connectionService, userRepository) {
    this.connectionService = connectionService;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.connection.ConnectionRepository', z.config.LOGGER.OPTIONS);

    this.connectionMapper = new z.connection.ConnectionMapper();
    this.connectionEntities = ko.observableArray([]);

    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.onUserEvent.bind(this));
  }

  /**
   * Listener for incoming user events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onUserEvent(eventJson, source) {
    const eventType = eventJson.type;

    const isSupportedType = ConnectionRepository.CONFIG.SUPPORTED_EVENTS.includes(eventType);
    if (isSupportedType) {
      const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
      this.logger.info(` User Event: '${eventType}' (Source: ${source})`, logObject);

      const isUserConnection = eventType === z.event.Backend.USER.CONNECTION;
      if (isUserConnection) {
        this.onUserConnection(eventJson, source);
      }
    }
  }

  /**
   * Convert a JSON event into an entity and get the matching conversation.
   *
   * @param {Object} eventJson - JSON data of 'user.connection' event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {boolean} [showConversation] - Should the new conversation be opened?
   * @returns {undefined} No return value
   */
  onUserConnection(eventJson, source, showConversation) {
    if (!eventJson) {
      throw new z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }

    const connectionData = eventJson.connection;

    let connectionEntity = this.getConnectionByUserId(connectionData.to);
    let previousStatus = null;

    if (connectionEntity) {
      previousStatus = connectionEntity.status();
      this.connectionMapper.updateConnectionFromJson(connectionEntity, connectionData);
    } else {
      connectionEntity = this.connectionMapper.mapConnectionFromJson(connectionData);
    }

    this.updateConnection(connectionEntity).then(() => {
      const shouldUpdateUser = previousStatus === z.connection.ConnectionStatus.SENT && connectionEntity.isConnected();
      if (shouldUpdateUser) {
        this.userRepository.updateUserById(connectionEntity.userId);
      }
      this._sendNotification(connectionEntity, source, previousStatus);
      amplify.publish(z.event.WebApp.CONVERSATION.MAP_CONNECTION, connectionEntity, showConversation);
    });
  }

  /**
   * Accept a connection request.
   * @param {z.entity.User} userEntity - User to update connection with
   * @param {boolean} [showConversation=false] - Show new conversation on success
   * @returns {Promise} Promise that resolves when the connection request was accepted
   */
  acceptRequest(userEntity, showConversation = false) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.ACCEPTED, showConversation);
  }

  /**
   * Block a user.
   *
   * @param {z.entity.User} userEntity - User to block
   * @param {boolean} [hideConversation=false] - Hide current conversation
   * @param {z.entity.Conversation} [nextConversationEntity] - Conversation to be switched to
   * @returns {Promise} Promise that resolves when the user was blocked
   */
  blockUser(userEntity, hideConversation = false, nextConversationEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.BLOCKED).then(() => {
      if (hideConversation) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEntity);
      }
    });
  }

  /**
   * Cancel a connection request.
   *
   * @param {z.entity.User} userEntity - User to cancel the sent connection request
   * @param {boolean} [hideConversation=false] - Hide current conversation
   * @param {z.entity.Conversation} [nextConversationEntity] - Conversation to be switched to
   * @returns {Promise} Promise that resolves when an outgoing connection request was cancelled
   */
  cancelRequest(userEntity, hideConversation = false, nextConversationEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.CANCELLED).then(() => {
      if (hideConversation) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEntity);
      }
    });
  }

  /**
   * Create a connection request.
   *
   * @param {z.entity.User} userEntity - User to connect to
   * @param {boolean} [showConversation=false] - Should we open the new conversation
   * @returns {Promise} Promise that resolves when the connection request was successfully created
   */
  createConnection(userEntity, showConversation = false) {
    return this.connectionService
      .postConnections(userEntity.id, userEntity.name())
      .then(response => {
        const connectionEvent = {connection: response};
        return this.onUserConnection(connectionEvent, z.event.EventRepository.SOURCE.INJECTED, showConversation);
      })
      .catch(error => {
        this.logger.error(`Failed to send connection request to user '${userEntity.id}': ${error.message}`, error);
      });
  }

  /**
   * Get a connection for a user ID.
   * @param {string} userId - User ID
   * @returns {z.connection.ConnectionEntity} User connection entity
   */
  getConnectionByUserId(userId) {
    return this.connectionEntities().find(connectionEntity => connectionEntity.userId === userId);
  }

  /**
   * Get a connection for a conversation ID.
   * @param {string} conversationId - Conversation ID
   * @returns {z.connection.ConnectionEntity} User connection entity
   */
  getConnectionByConversationId(conversationId) {
    return this.connectionEntities().find(connectionEntity => connectionEntity.conversationId === conversationId);
  }

  /**
   * Retrieve all connections from backend.
   *.
   * @note Initially called by Wire for Web's app start to retrieve connections.
   *
   * @param {number} [limit=500] - Query limit for user connections
   * @param {string} [userId] - User ID of the latest connection
   * @param {Array<z.connection.ConnectionEntity>} [connectionEntities=[]] - Unordered array of user connections
   * @returns {Promise} Promise that resolves when all connections have been retrieved and mapped
   */
  getConnections(limit = 500, userId, connectionEntities = []) {
    return this.connectionService
      .getConnections(limit, userId)
      .then(response => {
        const {connections: connectionData, has_more: hasMore} = response;

        if (connectionData.length) {
          const newConnectionEntities = this.connectionMapper.mapConnectionsFromJson(connectionData);
          connectionEntities = connectionEntities.concat(newConnectionEntities);
        }

        if (hasMore) {
          const lastConnectionEntity = connectionEntities[connectionEntities.length - 1];
          return this.getConnections(limit, lastConnectionEntity.userId, connectionEntities);
        }

        return connectionEntities.length ? this.updateConnections(connectionEntities) : this.connectionEntities();
      })
      .catch(error => {
        this.logger.error(`Failed to retrieve connections from backend: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Ignore connection request.
   * @param {z.entity.User} userEntity - User to ignore the connection request
   * @returns {Promise} Promise that resolves when an incoming connection request was ignored
   */
  ignoreRequest(userEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.IGNORED);
  }

  /**
   * Unblock a user.
   *
   * @param {z.entity.User} userEntity - User to unblock
   * @param {boolean} [showConversation=false] - Show new conversation on success
   * @returns {Promise} Promise that resolves when a user was unblocked
   */
  unblockUser(userEntity, showConversation = true) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.ACCEPTED, showConversation);
  }

  /**
   * Update user matching a given connection.
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @returns {Promise} Promise that resolves when the connection have been updated
   */
  updateConnection(connectionEntity) {
    return Promise.resolve()
      .then(() => {
        if (!connectionEntity) {
          throw z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER);
        }

        this.connectionEntities.push(connectionEntity);
        return this.userRepository.get_user_by_id(connectionEntity.userId);
      })
      .then(userEntity => userEntity.connection(connectionEntity));
  }

  /**
   * Update users matching the given connections.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connection entities
   * @returns {Promise<Array<z.connection.ConnectionEntity>>} Promise that resolves when all connections have been updated
   */
  updateConnections(connectionEntities) {
    return Promise.resolve()
      .then(() => {
        if (!connectionEntities.length) {
          throw z.error.ConnectionError(z.error.BaseError.TYPE.INVALID_PARAMETER);
        }

        z.util.koArrayPushAll(this.connectionEntities, connectionEntities);

        return this.userRepository.updateUsersFromConnections(connectionEntities);
      })
      .then(() => this.connectionEntities());
  }

  /**
   * Update the status of a connection.
   * @private
   * @param {z.entity.User} userEntity - User to update connection with
   * @param {string} connectionStatus - Connection status
   * @param {boolean} [showConversation=false] - Show conversation on success
   * @returns {Promise} Promise that resolves when the connection status was updated
   */
  _updateStatus(userEntity, connectionStatus, showConversation = false) {
    if (!userEntity || !connectionStatus) {
      this.logger.error('Missing parameter to update connection');
      return Promise.reject(new z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const currentStatus = userEntity.connection().status();
    if (currentStatus === connectionStatus) {
      this.logger.error(`Connection status change to '${connectionStatus}' for '${userEntity.id}' is no change`);
      return Promise.reject(new z.error.ConnectionError(z.error.BaseError.TYPE.INVALID_PARAMETER));
    }

    return this.connectionService
      .putConnections(userEntity.id, connectionStatus)
      .then(response => {
        const connectionEvent = {connection: response};
        return this.onUserConnection(connectionEvent, z.event.EventRepository.SOURCE.INJECTED, showConversation);
      })
      .catch(error => {
        const logMessage = `Connection change from '${currentStatus}' to '${connectionStatus}' failed`;
        this.logger.error(`${logMessage} for '${userEntity.id}' failed: ${error.message}`, error);

        const customData = {
          currentStatus,
          newStatus: connectionStatus,
          serverError: error,
        };

        Raygun.send(new Error(logMessage), customData);
      });
  }

  /**
   * Send the user connection notification.
   *
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.connection.ConnectionStatus} previousStatus - Previous connection status
   * @returns {undefined} No return value
   */
  _sendNotification(connectionEntity, source, previousStatus) {
    // We accepted the connection request or unblocked the user
    const expectedPreviousStatus = [z.connection.ConnectionStatus.BLOCKED, z.connection.ConnectionStatus.PENDING];
    const wasExpectedPreviousStatus = expectedPreviousStatus.includes(previousStatus);
    const selfUserAccepted = connectionEntity.isConnected() && wasExpectedPreviousStatus;
    const isWebSocketEvent = source === z.event.EventRepository.SOURCE.WEB_SOCKET;

    const showNotification = isWebSocketEvent && !selfUserAccepted;
    if (showNotification) {
      this.userRepository.get_user_by_id(connectionEntity.userId).then(userEntity => {
        const messageEntity = new z.entity.MemberMessage();
        messageEntity.user(userEntity);

        if (connectionEntity.isConnected()) {
          const statusWasSent = previousStatus === z.connection.ConnectionStatus.SENT;
          messageEntity.memberMessageType = statusWasSent
            ? z.message.SystemMessageType.CONNECTION_ACCEPTED
            : z.message.SystemMessageType.CONNECTION_CONNECTED;
        } else if (connectionEntity.isIncomingRequest()) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_REQUEST;
        }

        amplify.publish(z.event.WebApp.NOTIFICATION.NOTIFY, messageEntity, connectionEntity);
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionService = class ConnectionService {
  static get URL() {
    return {
      CONNECTIONS: '/connections',
    };
  }

  /**
   * Construct a new Connection Service.
   * @class z.connection.ConnectionService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.connection.ConnectionService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Retrieves a list of connections to other users.
   *
   * @note The list is already pre-ordered by the backend, so in order to fetch more connections
   * than the limit, you only have to pass the User ID (which is not from the self user)
   * of the last connection item from the received list.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//connections
   *
   * @param {number} limit - Number of results to return (default 100, max 500)
   * @param {string} userId - User ID to start from
   * @returns {Promise} Promise that resolves with user connections
   */
  getConnections(limit = 500, userId) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: userId,
      },
      type: 'GET',
      url: ConnectionService.URL.CONNECTIONS,
    });
  }

  /**
   * Create a connection request to another user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//createConnection
   *
   * @param {string} userId - User ID of the user to request a connection with
   * @param {string} name - Name of the conversation being initiated (1 - 256 characters)
   * @returns {Promise} Promise that resolves when the connection request was created
   */
  postConnections(userId, name) {
    return this.backendClient.sendJson({
      data: {
        message: ' ',
        name: name,
        user: userId,
      },
      type: 'POST',
      url: ConnectionService.URL.CONNECTIONS,
    });
  }

  /**
   * Updates a connection to another user.
   *
   * @example status: ['accepted', 'blocked', 'pending', 'ignored', 'sent' or 'cancelled']
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//updateConnection
   *
   * @param {string} userId - User ID of the other user
   * @param {z.connection.ConnectionStatus} connectionStatus - New relation status
   * @returns {Promise} Promise that resolves when the status was updated
   */
  putConnections(userId, connectionStatus) {
    return this.backendClient.sendJson({
      data: {
        status: connectionStatus,
      },
      type: 'PUT',
      url: `${ConnectionService.URL.CONNECTIONS}/${userId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionStatus = {
  ACCEPTED: 'accepted',
  BLOCKED: 'blocked',
  CANCELLED: 'cancelled',
  IGNORED: 'ignored',
  PENDING: 'pending',
  SENT: 'sent',
  UNKNOWN: '',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientEntity = class ClientEntity {
  static get CONFIG() {
    return {
      DEFAULT_VALUE: '?',
    };
  }

  constructor(isSelfClient = false) {
    this.isSelfClient = isSelfClient;

    this.class = ClientEntity.CONFIG.DEFAULT_VALUE;
    this.id = '';

    if (this.isSelfClient) {
      this.address = '';
      this.cookie = '';
      this.label = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.location = {};
      this.model = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.time = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.type = z.client.ClientType.TEMPORARY;
    }

    // Metadata maintained by us
    this.meta = {
      isVerified: ko.observable(false),
      primaryKey: undefined,
    };

    this.session = {};
  }

  /**
   * Splits an ID into user ID & client ID.
   * @param {string} id - Client ID to be dismantled
   * @returns {Object} Object containing the user ID & client ID
   */
  static dismantleUserClientId(id) {
    const [userId, clientId] = _.isString(id) ? id.split('@') : [];
    return {clientId, userId};
  }

  /**
   * Returns the ID of a client in a format suitable for UI display in user preferences.
   * @returns {Array<string>} Client ID in pairs of two as an array
   */
  formatId() {
    return z.util.zeroPadding(this.id, 16).match(/.{1,2}/g);
  }

  /**
   * @returns {boolean} True, if the client is the self user's permanent client.
   */
  isPermanent() {
    return this.type === z.client.ClientType.PERMANENT;
  }

  /**
   * @returns {boolean} - True, if it is NOT the client of the self user.
   */
  isRemote() {
    return !this.isPermanent() && !this.isTemporary();
  }

  /**
   * @returns {boolean} - True, if the client is the self user's temporary client.
   */
  isTemporary() {
    return this.type === z.client.ClientType.TEMPORARY;
  }

  /**
   * This method returns a JSON object which can be stored in our local database.
   * @returns {Object} Client data as JSON object
   */
  toJson() {
    const jsonObject = JSON.parse(ko.toJSON(this));
    delete jsonObject.isSelfClient;
    delete jsonObject.session;

    z.client.ClientMapper.CONFIG.CLIENT_PAYLOAD.forEach(name => this._removeDefaultValues(jsonObject, name));

    if (this.isSelfClient) {
      z.client.ClientMapper.CONFIG.SELF_CLIENT_PAYLOAD.forEach(name => this._removeDefaultValues(jsonObject, name));
    }

    jsonObject.meta.is_verified = jsonObject.meta.isVerified;
    delete jsonObject.meta.isVerified;

    if (jsonObject.meta.primaryKey) {
      jsonObject.meta.primary_key = jsonObject.meta.primaryKey;
      delete jsonObject.meta.primaryKey;
    }

    return jsonObject;
  }

  _removeDefaultValues(jsonObject, memberName) {
    if (jsonObject.hasOwnProperty(memberName)) {
      const isDefaultValue = jsonObject[memberName] === ClientEntity.CONFIG.DEFAULT_VALUE;
      if (isDefaultValue) {
        jsonObject[memberName] = '';
      }
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientMapper = class ClientMapper {
  static get CONFIG() {
    return {
      CLIENT_PAYLOAD: ['class', 'id'],
      SELF_CLIENT_PAYLOAD: ['address', 'cookie', 'label', 'location', 'model', 'time', 'type'],
    };
  }

  constructor() {}

  /**
   * Maps a JSON into a Client entity.
   *
   * @param {Object} clientPayload - Client data
   * @param {boolean} isSelfClient - Creating self client
   * @returns {z.client.ClientEntity} Mapped client entity
   */
  mapClient(clientPayload, isSelfClient) {
    const clientEntity = new z.client.ClientEntity(isSelfClient);

    ClientMapper.CONFIG.CLIENT_PAYLOAD.forEach(name => this._mapMember(clientEntity, clientPayload, name));

    if (isSelfClient) {
      ClientMapper.CONFIG.SELF_CLIENT_PAYLOAD.forEach(name => this._mapMember(clientEntity, clientPayload, name));
    }

    if (clientPayload.meta) {
      const {userId} = z.client.ClientEntity.dismantleUserClientId(clientPayload.meta.primary_key);

      clientEntity.meta.isVerified(clientPayload.meta.is_verified);
      clientEntity.meta.primaryKey = clientPayload.meta.primary_key;
      clientEntity.meta.userId = userId;
    }

    return clientEntity;
  }

  /**
   * Maps an object of client IDs with their payloads to client entities.
   *
   * @param {Array<Object>} clientsPayload - Clients data
   * @param {boolean} isSelfClient - Creating self client
   * @returns {Array<z.client.ClientEntity>} - Mapped client entities
   */
  mapClients(clientsPayload, isSelfClient) {
    return clientsPayload.map(clientPayload => this.mapClient(clientPayload, isSelfClient));
  }

  /**
   * Update a client entity or object from JSON.
   *
   * @param {z.client.ClientEntity|Object} clientData - Client data
   * @param {Object} updatePayload - JSON possibly containing updates
   * @returns {Object} Contains the client and whether there was a change
   */
  updateClient(clientData, updatePayload) {
    let containsUpdate = false;

    for (const member in updatePayload) {
      const isDataChange = JSON.stringify(clientData[member]) !== JSON.stringify(updatePayload[member]);

      if (isDataChange) {
        containsUpdate = true;
        clientData[member] = updatePayload[member];
      }
    }

    return {client: clientData, wasUpdated: containsUpdate};
  }

  _mapMember(clientEntity, clientPayload, memberName) {
    const payloadValue = clientPayload[memberName];
    const isMemberUndefined = payloadValue === undefined;
    if (!isMemberUndefined) {
      clientEntity[memberName] = payloadValue;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientRepository = class ClientRepository {
  static get CONFIG() {
    return {
      AVERAGE_NUMBER_OF_CLIENTS: 4,
    };
  }

  static get PRIMARY_KEY_CURRENT_CLIENT() {
    return 'local_identity';
  }

  constructor(clientService, cryptographyRepository) {
    this.clientService = clientService;
    this.cryptographyRepository = cryptographyRepository;
    this.selfUser = ko.observable(undefined);
    this.logger = new z.util.Logger('z.client.ClientRepository', z.config.LOGGER.OPTIONS);

    this.clientMapper = new z.client.ClientMapper();
    this.clients = ko.pureComputed(() => (this.selfUser() ? this.selfUser().devices() : []));
    this.currentClient = ko.observable();

    this.isTemporaryClient = ko.pureComputed(() => this.currentClient() && this.currentClient().isTemporary());

    amplify.subscribe(z.event.WebApp.LIFECYCLE.ASK_TO_CLEAR_DATA, this.logoutClient.bind(this));
    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.onUserEvent.bind(this));
  }

  init(selfUser) {
    this.selfUser(selfUser);
    this.logger.info(`Initialized repository with user ID '${this.selfUser().id}'`);
  }

  //##############################################################################
  // Service interactions
  //##############################################################################

  deleteClientFromDb(userId, clientId) {
    return this.clientService.deleteClientFromDb(this._constructPrimaryKey(userId, clientId));
  }

  /**
   * Delete the temporary client on the backend.
   * @returns {Promise} Resolves when the temporary client was deleted on the backend
   */
  deleteTemporaryClient() {
    return this.clientService.deleteTemporaryClient(this.currentClient().id);
  }

  /**
   * Load all known clients from the database.
   * @returns {Promise} Resolves with all the clients found in the local database
   */
  getAllClientsFromDb() {
    return this.clientService.loadAllClientsFromDb().then(clients => {
      const recipients = {};
      const skippedUserIds = [this.selfUser().id, z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT];

      for (const client of clients) {
        const {userId} = z.client.ClientEntity.dismantleUserClientId(client.meta.primary_key);
        if (userId && !skippedUserIds.includes(userId)) {
          recipients[userId] = recipients[userId] || [];
          recipients[userId].push(this.clientMapper.mapClient(client, false));
        }
      }
      return recipients;
    });
  }

  /**
   * Retrieves meta information about specific client of the self user.
   * @param {string} clientId - ID of client to be retrieved
   * @returns {Promise} Resolves with the retrieved client information
   */
  getClientByIdFromBackend(clientId) {
    return this.clientService.getClientById(clientId).catch(error => {
      const clientNotFoundBackend = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
      if (clientNotFoundBackend) {
        this.logger.warn(`Local client '${clientId}' no longer exists on the backend`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.NO_VALID_CLIENT);
      }

      throw error;
    });
  }

  /**
   * Loads a client from the database (if it exists).
   * @returns {Promise<z.client.ClientEntity>} Resolves with the local client
   */
  getCurrentClientFromDb() {
    return this.clientService
      .loadClientFromDb(z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT)
      .catch(() => {
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(clientPayload => {
        if (_.isString(clientPayload)) {
          this.logger.info('No local client found in database');
          throw new z.error.ClientError(z.error.ClientError.TYPE.NO_VALID_CLIENT);
        }

        const currentClient = this.clientMapper.mapClient(clientPayload, true);
        this.currentClient(currentClient);
        this.logger.info(`Loaded local client '${currentClient.id}'`, this.currentClient());
        return this.currentClient();
      });
  }

  /**
   * Construct the primary key to store clients in database.
   * @private
   *
   * @param {string} userId - User ID from the owner of the client
   * @param {string} clientId - ID of the client
   * @returns {string} Primary key
   */
  _constructPrimaryKey(userId, clientId) {
    if (!userId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_USER_ID);
    }
    if (!clientId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_CLIENT_ID);
    }
    return `${userId}@${clientId}`;
  }

  /**
   * Save the a client into the database.
   *
   * @private
   * @param {string} userId - ID of user client to be stored belongs to
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  saveClientInDb(userId, clientPayload) {
    const primaryKey = this._constructPrimaryKey(userId, clientPayload.id);
    return this.clientService.saveClientInDb(primaryKey, clientPayload);
  }

  /**
   * Updates properties for a client record in database.
   *
   * @todo Merge "meta" property before updating it, Object.assign(payload.meta, changes.meta)
   * @param {string} userId - User ID of the client owner
   * @param {string} clientId - Client ID which needs to get updated
   * @param {string} changes - New values which should be updated on the client
   * @returns {number} Number of updated records
   */
  updateClientInDb(userId, clientId, changes) {
    const primaryKey = this._constructPrimaryKey(userId, clientId);
    // Preserve primary key on update
    changes.meta.primary_key = primaryKey;
    return this.clientService.updateClientInDb(primaryKey, changes);
  }

  /**
   * Change verification state of client.
   *
   * @param {string} userId - User ID of the client owner
   * @param {z.client.ClientEntity} clientEntity - Client which needs to get updated
   * @param {boolean} isVerified - New state to apply
   * @returns {Promise} Resolves when the verification state has been updated
   */
  verifyClient(userId, clientEntity, isVerified) {
    return this.updateClientInDb(userId, clientEntity.id, {meta: {is_verified: isVerified}}).then(() => {
      clientEntity.meta.isVerified(isVerified);
      amplify.publish(z.event.WebApp.CLIENT.VERIFICATION_STATE_CHANGED, userId, clientEntity, isVerified);
    });
  }

  /**
   * Save the local client into the database.
   *
   * @private
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  _saveCurrentClientInDb(clientPayload) {
    clientPayload.meta = {is_verified: true};
    return this.clientService.saveClientInDb(z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT, clientPayload);
  }

  /**
   * Updates a client payload if it does not fit the current database structure.
   *
   * @private
   * @param {string} userId - User ID of the client owner
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  _updateClientSchemaInDb(userId, clientPayload) {
    clientPayload.meta = {
      is_verified: false,
      primary_key: this._constructPrimaryKey(userId, clientPayload.id),
    };
    return this.saveClientInDb(userId, clientPayload);
  }

  //##############################################################################
  // Login and registration
  //##############################################################################

  /**
   * Constructs the value for a cookie label.
   * @param {string} login - Email or phone number of the user
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @returns {string} Cookie label
   */
  constructCookieLabel(login, clientType = this._loadCurrentClientType()) {
    const loginHash = z.util.murmurhash3(login || this.selfUser().id, 42);
    return `webapp@${loginHash}@${clientType}@${Date.now()}`;
  }

  /**
   * Constructs the key for a cookie label.
   * @param {string} login - Email or phone number of the user
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @returns {string} Cookie label key
   */
  constructCookieLabelKey(login, clientType = this._loadCurrentClientType()) {
    const loginHash = z.util.murmurhash3(login || this.selfUser().id, 42);
    return `${z.storage.StorageKey.AUTH.COOKIE_LABEL}@${loginHash}@${clientType}`;
  }

  /**
   * Get and validate the local client.
   * @returns {Promise} Resolve with an observable containing the client if valid
   */
  getValidLocalClient() {
    return this.getCurrentClientFromDb()
      .then(clientEntity => this.getClientByIdFromBackend(clientEntity.id))
      .then(clientPayload => {
        this.logger.info(`Client with ID '${clientPayload.id}' (${clientPayload.type}) validated on backend`);
        return this.currentClient;
      })
      .catch(error => {
        const clientNotValidated = error.type === z.error.ClientError.TYPE.NO_VALID_CLIENT;
        if (!clientNotValidated) {
          this.logger.error(`Getting valid local client failed: ${error.code || error.message}`, error);
        }

        throw error;
      });
  }

  /**
   * Register a new client.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/registerClient
   *
   * @note Password is needed for the registration of a client once 1st client has been registered.
   * @param {string|undefined} password - User password for verification
   * @returns {Promise<z.client.ClientEntity>} Resolve with the newly registered client
   */
  registerClient(password) {
    const clientType = this._loadCurrentClientType();

    return this.cryptographyRepository
      .generateClientKeys()
      .then(keys => this.clientService.postClients(this._createRegistrationPayload(clientType, password, keys)))
      .catch(error => {
        const tooManyClients = error.label === z.error.BackendClientError.LABEL.TOO_MANY_CLIENTS;
        if (tooManyClients) {
          throw new z.error.ClientError(z.error.ClientError.TYPE.TOO_MANY_CLIENTS);
        }
        this.logger.error(`Client registration request failed: ${error.message}`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.REQUEST_FAILURE);
      })
      .then(response => {
        const {cookie, id, type} = response;
        this.logger.info(`Registered '${type}' client '${id}' with cookie label '${cookie}'`, response);
        const currentClient = this.clientMapper.mapClient(response, true);
        this.currentClient(currentClient);
        return this._saveCurrentClientInDb(response);
      })
      .catch(error => {
        const handledErrors = [z.error.ClientError.TYPE.REQUEST_FAILURE, z.error.ClientError.TYPE.TOO_MANY_CLIENTS];

        if (handledErrors.includes(error.type)) {
          throw error;
        }
        this.logger.error(`Failed to save client: ${error.message}`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(clientPayload => this._transferCookieLabel(clientType, clientPayload.cookie))
      .then(() => this.currentClient)
      .catch(error => {
        this.logger.error(`Client registration failed: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Create payload for client registration.
   *
   * @private
   * @param {z.client.ClientType} clientType - Type of client to be registered
   * @param {string} password - User password
   * @param {string} lastResortKey - Last resort key
   * @param {Array<string>} preKeys - Pre-keys
   * @param {Array<string>} signalingKeys - Signaling keys
   * @returns {Object} - Payload to register client with backend
   */
  _createRegistrationPayload(clientType, password, [lastResortKey, preKeys, signalingKeys]) {
    let deviceLabel = `${platform.os.family}`;

    if (platform.os.version) {
      deviceLabel += ` ${platform.os.version}`;
    }

    let deviceModel = platform.name;

    if (z.util.Environment.desktop) {
      let identifier;
      if (z.util.Environment.os.mac) {
        identifier = z.string.wireMacos;
      } else if (z.util.Environment.os.win) {
        identifier = z.string.wireWindows;
      } else {
        identifier = z.string.wireLinux;
      }
      deviceModel = z.l10n.text(identifier);
      if (!z.util.Environment.frontend.isProduction()) {
        deviceModel = `${deviceModel} (Internal)`;
      }
    } else if (clientType === z.client.ClientType.TEMPORARY) {
      deviceModel = `${deviceModel} (Temporary)`;
    }

    return {
      class: 'desktop',
      cookie: this._getCookieLabelValue(this.selfUser().email() || this.selfUser().phone()),
      label: deviceLabel,
      lastkey: lastResortKey,
      model: deviceModel,
      password: password,
      prekeys: preKeys,
      sigkeys: signalingKeys,
      type: clientType,
    };
  }

  /**
   * Gets the value for a cookie label.
   * @private
   * @param {string} login - Email or phone number of the user
   * @returns {string} Cookie label
   */
  _getCookieLabelValue(login) {
    return z.util.StorageUtil.getValue(this.constructCookieLabelKey(login));
  }

  /**
   * Loads the cookie label value from the Local Storage and saves it into IndexedDB.
   *
   * @private
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @param {string} cookieLabel - Cookie label, something like "webapp@2153234453@temporary@145770538393"
   * @returns {Promise} Resolves with the key of the stored cookie label
   */
  _transferCookieLabel(clientType, cookieLabel) {
    const indexedDbKey = z.storage.StorageKey.AUTH.COOKIE_LABEL;
    const userIdentifier = this.selfUser().email() || this.selfUser().phone();
    const localStorageKey = this.constructCookieLabelKey(userIdentifier, clientType);

    if (cookieLabel === undefined) {
      cookieLabel = this.constructCookieLabel(userIdentifier, clientType);
      this.logger.warn(`Cookie label is in an invalid state. We created a new one: '${cookieLabel}'`);
      z.util.StorageUtil.setValue(localStorageKey, cookieLabel);
    }

    this.logger.info(`Saving cookie label '${cookieLabel}' in IndexedDB`, {
      key: localStorageKey,
      value: cookieLabel,
    });

    return this.cryptographyRepository.storageRepository.saveValue(indexedDbKey, cookieLabel);
  }

  /**
   * Load current client type from amplify store.
   * @private
   * @returns {z.client.ClientType} Type of current client
   */
  _loadCurrentClientType() {
    if (this.currentClient()) {
      return this.currentClient().type;
    }
    const isPermanent = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.PERSIST);
    const type = isPermanent ? z.client.ClientType.PERMANENT : z.client.ClientType.TEMPORARY;
    return z.util.Environment.electron ? z.client.ClientType.PERMANENT : type;
  }

  //##############################################################################
  // Client handling
  //##############################################################################

  /**
   * Delete client of a user on backend and removes it locally.
   *
   * @param {string} clientId - ID of the client that should be deleted
   * @param {string} password - Password entered by user
   * @returns {Promise} Resolves with the remaining user devices
   */
  deleteClient(clientId, password) {
    return this.clientService
      .deleteClient(clientId, password)
      .then(() => this.deleteClientFromDb(this.selfUser().id, clientId))
      .then(() => {
        this.selfUser().remove_client(clientId);
        amplify.publish(z.event.WebApp.USER.CLIENT_REMOVED, this.selfUser().id, clientId);
        return this.clients();
      })
      .catch(error => {
        this.logger.error(`Unable to delete client '${clientId}': ${error.message}`, error);

        const isForbidden = z.error.BackendClientError.STATUS_CODE.FORBIDDEN;
        const errorType = isForbidden
          ? z.error.ClientError.TYPE.REQUEST_FORBIDDEN
          : z.error.ClientError.TYPE.REQUEST_FAILURE;
        throw new z.error.ClientError(errorType);
      });
  }

  removeLocalClient() {
    this.cryptographyRepository.storageRepository.deleteCryptographyStores().then(() => {
      const shouldClearData = this.currentClient().isTemporary();
      amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.CLIENT_REMOVED, shouldClearData);
    });
  }

  logoutClient() {
    if (this.currentClient()) {
      if (this.isTemporaryClient()) {
        return this.deleteTemporaryClient().then(() =>
          amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.USER_REQUESTED, true)
        );
      }

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.OPTION, {
        action: clearData => {
          return amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.USER_REQUESTED, clearData);
        },
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalAccountLogoutAction),
          option: z.l10n.text(z.string.modalAccountLogoutOption),
          title: z.l10n.text(z.string.modalAccountLogoutHeadline),
        },
        warning: false,
      });
    }
  }

  /**
   * Removes a stored client and the session connected with it.
   *
   * @param {string} userId - ID of user
   * @param {string} clientId - ID of client to be deleted
   * @returns {Promise} Resolves when a client and its session have been deleted
   */
  removeClient(userId, clientId) {
    return this.cryptographyRepository
      .deleteSession(userId, clientId)
      .then(() => this.deleteClientFromDb(userId, clientId));
  }

  /**
   * Retrieves meta information about all the clients of a given user.
   * @note If you want to get very detailed information about the devices from the own user, then use "@getClients"
   *
   * @param {string} userId - User ID to retrieve client information for
   * @returns {Promise} Resolves with an array of client entities
   */
  getClientsByUserId(userId) {
    return this.clientService
      .getClientsByUserId(userId)
      .then(clientsData => this._updateClientsOfUserById(userId, clientsData));
  }

  getClientByUserIdFromDb(requestedUserId) {
    return this.clientService.loadAllClientsFromDb().then(clients => {
      return clients.filter(client => {
        const {userId} = z.client.ClientEntity.dismantleUserClientId(client.meta.primary_key);
        return userId === requestedUserId;
      });
    });
  }

  /**
   * Retrieves meta information about all other locally known clients of the self user.
   * @returns {Promise} Resolves with all locally known clients except the current one
   */
  getClientsForSelf() {
    this.logger.info(`Retrieving all clients of the self user from database`);
    return this.getClientByUserIdFromDb(this.selfUser().id)
      .then(clientsData => this.clientMapper.mapClients(clientsData, true))
      .then(clientEntities => {
        clientEntities.forEach(clientEntity => this.selfUser().add_client(clientEntity));
        return this.selfUser().devices();
      });
  }

  /**
   * Is the current client permanent.
   * @returns {boolean} Type of current client is permanent
   */
  isCurrentClientPermanent() {
    if (!this.currentClient()) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.CLIENT_NOT_SET);
    }
    return z.util.Environment.electron || this.currentClient().isPermanent();
  }

  /**
   * Update clients of the self user.
   * @returns {Promise} Resolves when the clients have been updated
   */
  updateClientsForSelf() {
    return this.clientService
      .getClients()
      .then(clientsData => this._updateClientsOfUserById(this.selfUser().id, clientsData, false));
  }

  /**
   * Update clients of a user with the given backend data.
   * @note This function matches clients retrieved from the backend with the data stored in the local database.
   *   Clients will then be updated with the backend payload in the database and mapped into entities.
   *
   * @private
   * @param {string} userId - ID of user whose clients are updated
   * @param {Object} clientsData - Clients data from backend
   * @param {booelan} [publish=true] - Publish changes clients using amplify
   * @returns {Promise<Array<z.client.Client>>} Resolves with the entities once clients have been updated
   */
  _updateClientsOfUserById(userId, clientsData, publish = true) {
    const clientsFromBackend = {};
    const clientsStoredInDb = [];
    const isSelfUser = userId === this.selfUser().id;

    for (const client of clientsData) {
      clientsFromBackend[client.id] = client;
    }

    // Find clients in database
    return this.getClientByUserIdFromDb(userId)
      .then(clientsFromDatabase => {
        const promises = [];

        for (const databaseClient of clientsFromDatabase) {
          const clientId = databaseClient.id;
          const backendClient = clientsFromBackend[clientId];

          if (backendClient) {
            const {client, wasUpdated} = this.clientMapper.updateClient(databaseClient, backendClient);

            delete clientsFromBackend[clientId];

            if (this.currentClient() && this._isCurrentClient(userId, clientId)) {
              this.logger.warn(`Removing duplicate self client '${clientId}' locally`);
              this.removeClient(userId, clientId);
            }

            // Locally known client changed on backend
            if (wasUpdated) {
              this.logger.info(`Updating client '${clientId}' of user '${userId}' locally`);
              promises.push(this.saveClientInDb(userId, client));
              continue;
            }

            // Locally known client unchanged on backend
            clientsStoredInDb.push(client);
            continue;
          }

          // Locally known client deleted on backend
          this.logger.warn(`Removing client '${clientId}' of user '${userId}' locally`);
          this.removeClient(userId, clientId);
        }

        for (const clientId in clientsFromBackend) {
          const clientPayload = clientsFromBackend[clientId];

          if (this.currentClient() && this._isCurrentClient(userId, clientId)) {
            continue;
          }

          // Locally unknown client new on backend
          this.logger.info(`New client '${clientId}' of user '${userId}' will be stored locally`);
          if (this.selfUser().id === userId) {
            this.onClientAdd({client: clientPayload});
          }
          promises.push(this._updateClientSchemaInDb(userId, clientPayload));
        }

        return Promise.all(promises);
      })
      .then(newRecords => this.clientMapper.mapClients(clientsStoredInDb.concat(newRecords), isSelfUser))
      .then(clientEntities => {
        if (publish) {
          amplify.publish(z.event.WebApp.CLIENT.UPDATE, userId, clientEntities);
        }
        return clientEntities;
      })
      .catch(error => {
        this.logger.error(`Unable to retrieve clients for user '${userId}': ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check if client is current local client.
   *
   * @private
   * @param {string} userId - User ID to be checked
   * @param {string} clientId - ID of client to be checked
   * @returns {boolean} Is the client the current local client
   */
  _isCurrentClient(userId, clientId) {
    if (!this.currentClient()) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.CLIENT_NOT_SET);
    }
    if (!userId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_USER_ID);
    }
    if (!clientId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_CLIENT_ID);
    }
    return userId === this.selfUser().id && clientId === this.currentClient().id;
  }

  //##############################################################################
  // Conversation Events
  //##############################################################################

  /**
   * Listener for incoming user events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onUserEvent(eventJson, source) {
    const type = eventJson.type;

    const isClientAdd = type === z.event.Backend.USER.CLIENT_ADD;
    if (isClientAdd) {
      return this.onClientAdd(eventJson);
    }

    const isClientRemove = type === z.event.Backend.USER.CLIENT_REMOVE;
    if (isClientRemove) {
      this.onClientRemove(eventJson);
    }
  }

  /**
   * A client was added by the self user.
   * @param {Object} eventJson - JSON data of 'user.client-add' event
   * @returns {undefined} No return value
   */
  onClientAdd(eventJson) {
    this.logger.info('Client of self user added', eventJson);
    amplify.publish(z.event.WebApp.CLIENT.ADD, this.selfUser().id, eventJson.client, true);
  }

  /**
   * A client was removed by the self user.
   * @param {Object} [eventJson={}] - JSON data of 'user.client-remove' event
   * @returns {Promise} Resolves when the event has been handled
   */
  onClientRemove(eventJson = {}) {
    const clientId = eventJson.client ? eventJson.client.id : undefined;
    if (clientId) {
      const isCurrentClient = clientId === this.currentClient().id;
      if (isCurrentClient) {
        return this.removeLocalClient();
      }

      amplify.publish(z.event.WebApp.CLIENT.REMOVE, this.selfUser().id, clientId);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientService = class ClientService {
  static get URL_CLIENTS() {
    return '/clients';
  }

  static get URL_USERS() {
    return '/users';
  }

  /**
   * Construct a new client service.
   * @param {BackendClient} backendClient - Client for the API calls
   * @param {z.storage.StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.client.ClientService', z.config.LOGGER.OPTIONS);

    this.CLIENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CLIENTS;
  }

  //##############################################################################
  // Backend requests
  //##############################################################################

  /**
   * Deletes a specific client from a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/deleteClient
   *
   * @param {string} clientId - ID of client to be deleted
   * @param {string} password - User password
   * @returns {Promise} Resolves once the deletion of the client is complete
   */
  deleteClient(clientId, password) {
    return this.backendClient.sendJson({
      data: {
        password,
      },
      type: 'DELETE',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Deletes the temporary client of a user.
   * @param {string} clientId - ID of the temporary client to be deleted
   * @returns {Promise} - Resolves once the deletion of the temporary client is complete
   */
  deleteTemporaryClient(clientId) {
    return this.backendClient.sendJson({
      data: {},
      type: 'DELETE',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Retrieves meta information about a specific client.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getClients
   *
   * @param {string} clientId - ID of client to be retrieved
   * @returns {Promise} Resolves with the requested client
   */
  getClientById(clientId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Retrieves meta information about all the clients self user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/listClients
   * @returns {Promise} Resolves with the clients of the self user
   */
  getClients() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: ClientService.URL_CLIENTS,
    });
  }

  /**
   * Retrieves meta information about all the clients of a specific user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getClients
   *
   * @param {string} userId - ID of user to retrieve clients for
   * @returns {Promise} Resolves with the clients of a user
   */
  getClientsByUserId(userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ClientService.URL_USERS}/${userId}${ClientService.URL_CLIENTS}`,
    });
  }

  /**
   * Register a new client.
   * @param {Object} payload - Client payload
   * @returns {Promise} Resolves with the registered client information
   */
  postClients(payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: ClientService.URL_CLIENTS,
    });
  }

  //##############################################################################
  // Database requests
  //##############################################################################

  /**
   * Removes a client from the database.
   * @param {string} primaryKey - Primary key used to find the client for deletion in the database
   * @returns {Promise} Resolves once the client is deleted
   */
  deleteClientFromDb(primaryKey) {
    return this.storageService.delete(this.CLIENT_STORE_NAME, primaryKey);
  }

  /**
   * Load all clients we have stored in the database.
   * @returns {Promise} Resolves with all the clients payloads
   */
  loadAllClientsFromDb() {
    return this.storageService.getAll(this.CLIENT_STORE_NAME);
  }

  /**
   * Loads a persisted client from the database.
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @returns {Promise<JSON|string>} Resolves with the client's payload or the primary key if not found
   */
  loadClientFromDb(primaryKey) {
    return this.storageService.db[this.CLIENT_STORE_NAME]
      .where('meta.primary_key')
      .equals(primaryKey)
      .first()
      .then(clientRecord => {
        if (clientRecord === undefined) {
          this.logger.info(`Client with primary key '${primaryKey}' not found in database`);
          return primaryKey;
        }
        this.logger.info(`Loaded client record from database '${primaryKey}'`, clientRecord);
        return clientRecord;
      });
  }

  /**
   * Persists a client.
   *
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @param {Object} clientPayload - Client payload
   * @returns {Promise<Object>} Resolves with the client payload stored in database
   */
  saveClientInDb(primaryKey, clientPayload) {
    if (!clientPayload.meta) {
      clientPayload.meta = {};
    }

    clientPayload.meta.primary_key = primaryKey;

    return this.storageService.save(this.CLIENT_STORE_NAME, primaryKey, clientPayload).then(() => {
      this.logger.info(`Client '${clientPayload.id}' stored with primary key '${primaryKey}'`, clientPayload);
      return clientPayload;
    });
  }

  /**
   * Updates a persisted client in the database.
   *
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @param {Object} changes - Incremental update changes of the client JSON
   * @returns {Promise<Integer>} Number of updated records (1 if an object was updated, otherwise 0)
   */
  updateClientInDb(primaryKey, changes) {
    return this.storageService.update(this.CLIENT_STORE_NAME, primaryKey, changes);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientType = {
  PERMANENT: 'permanent',
  TEMPORARY: 'temporary',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

/**
 * @typedef {Object} EventHandlingConfig - Object representing conversation event handlers
 * @property {() => void} [eventId: string] - an event handler function
 */

z.conversation.AbstractConversationEventHandler = class AbstractConversationEventHandler {
  /**
   * Abstract class that represents an entity that can react to a conversation event.
   */
  constructor() {
    this.eventHandlingConfig = {};
  }

  /**
   * Adds an event handling config to the current instance.
   *
   * @param {EventHandlingConfig} eventHandlingConfig - Config containing events name and the associated callback
   * @returns {void} No return value
   */
  setEventHandlingConfig(eventHandlingConfig) {
    this.eventHandlingConfig = eventHandlingConfig;
  }

  /**
   * Handles a conversation event.
   *
   * @param {z.entity.Conversation} conversationEntity - the conversation the event relates to
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  handleConversationEvent(conversationEntity, eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    const handler = this.eventHandlingConfig[eventJson.type] || (() => Promise.resolve());
    return handler.bind(this)(conversationEntity, eventJson);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_MODE = {
  CODE: 'code',
  INVITE: 'invite',
  PRIVATE: 'private',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_ROLE = {
  ACTIVATED: 'activated',
  NON_ACTIVATED: 'non_activated',
  PRIVATE: 'private',
  TEAM: 'team',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_STATE = {
  PERSONAL: {
    GROUP: 'z.conversation.ACCESS_STATE.PERSONAL.GROUP',
    ONE2ONE: 'z.conversation.ACCESS_STATE.PERSONAL.ONE2ONE',
  },
  SELF: 'z.conversation.ACCESS_STATE.SELF',
  TEAM: {
    GUEST_ROOM: 'z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM',
    LEGACY: 'z.conversation.ACCESS_STATE.TEAM.LEGACY',
    ONE2ONE: 'z.conversation.ACCESS_STATE.TEAM.ONE2ONE',
    TEAM_ONLY: 'z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY',
  },
  UNKNOWN: 'z.conversation.ACCESS_STATE.UNKNOWN',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ClientMismatchHandler = class ClientMismatchHandler {
  constructor(conversationRepository, cryptographyRepository, eventRepository, serverTimeRepository, userRepository) {
    this.conversationRepository = conversationRepository;
    this.cryptographyRepository = cryptographyRepository;
    this.eventRepository = eventRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.conversation.ClientMismatchHandler', z.config.LOGGER.OPTIONS);
  }

  /**
   * Handle client mismatch response from backend.
   *
   * @note As part of 412 or general response when sending encrypted message
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about message
   * @param {Object} clientMismatch - Client mismatch object containing client user maps for deleted, missing and obsolete clients
   * @param {Object} payload - Initial payload resulting in a 412
   * @returns {Promise} Resolve when mismatch was handled
   */
  onClientMismatch(eventInfoEntity, clientMismatch, payload) {
    const {deleted: deletedClients, missing: missingClients, redundant: redundantClients} = clientMismatch;

    return Promise.resolve()
      .then(() => this._handleClientMismatchRedundant(redundantClients, payload, eventInfoEntity))
      .then(updatedPayload => this._handleClientMismatchDeleted(deletedClients, updatedPayload))
      .then(updatedPayload => this._handleClientMismatchMissing(missingClients, updatedPayload, eventInfoEntity));
  }

  /**
   * Handle the deleted client mismatch.
   *
   * @note Contains clients of which the backend is sure that they should not be recipient of a message and verified they no longer exist.
   * @private
   *
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchDeleted(recipients, payload) {
    if (_.isEmpty(recipients)) {
      return Promise.resolve(payload);
    }
    this.logger.debug(`Message contains deleted clients of '${Object.keys(recipients).length}' users`, recipients);

    const _removeDeletedClient = (userId, clientId) => {
      delete payload.recipients[userId][clientId];
      return this.userRepository.remove_client_from_user(userId, clientId);
    };

    const _removeDeletedUser = userId => {
      const clientIdsOfUser = Object.keys(payload.recipients[userId]);
      const noRemainingClients = !clientIdsOfUser.length;

      if (noRemainingClients) {
        delete payload.recipients[userId];
      }
    };

    return Promise.all(this._mapRecipients(recipients, _removeDeletedClient, _removeDeletedUser)).then(() => {
      this.conversationRepository.verification_state_handler.onClientRemoved();
      return payload;
    });
  }

  /**
   * Handle the missing client mismatch.
   *
   * @private
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchMissing(recipients, payload, eventInfoEntity) {
    const missingUserIds = Object.keys(recipients);
    if (!missingUserIds.length) {
      return Promise.resolve(payload);
    }

    this.logger.debug(`Message is missing clients of '${missingUserIds.length}' users`, recipients);
    const {conversationId, genericMessage, timestamp} = eventInfoEntity;

    const skipParticipantsCheck = !conversationId;
    const participantsCheckPromise = skipParticipantsCheck
      ? Promise.resolve()
      : this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
          const knownUserIds = conversationEntity.participating_user_ids();
          const unknownUserIds = z.util.ArrayUtil.getDifference(knownUserIds, missingUserIds);

          if (unknownUserIds.length) {
            return this.conversationRepository.addMissingMember(conversationId, unknownUserIds, timestamp - 1);
          }
        });

    return participantsCheckPromise
      .then(() => this.cryptographyRepository.encryptGenericMessage(recipients, genericMessage, payload))
      .then(updatedPayload => {
        payload = updatedPayload;

        const _addMissingClient = (userId, clientId) => this.userRepository.addClientToUser(userId, {id: clientId});
        return Promise.all(this._mapRecipients(recipients, _addMissingClient));
      })
      .then(() => {
        this.conversationRepository.verification_state_handler.onClientsAdded(Object.keys(recipients));
        return payload;
      });
  }

  /**
   * Handle the redundant client mismatch.

   * @note Contains clients of which the backend is sure that they should not be recipient of a message but cannot say whether they exist.
   *   Normally only contains clients of users no longer participating in a conversation.
   *   Sometimes clients of the self user are listed. Thus we cannot remove the payload for all the clients of a user without checking.
   * @private
   *
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchRedundant(recipients, payload, eventInfoEntity) {
    if (_.isEmpty(recipients)) {
      return Promise.resolve(payload);
    }
    this.logger.debug(`Message contains redundant clients of '${Object.keys(recipients).length}' users`, recipients);
    const conversationId = eventInfoEntity.conversationId;

    const conversationPromise = conversationId
      ? this.conversationRepository.get_conversation_by_id(conversationId).catch(error => {
          const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
          if (!isConversationNotFound) {
            throw error;
          }
        })
      : Promise.resolve();

    return conversationPromise.then(conversationEntity => {
      const _removeRedundantClient = (userId, clientId) => delete payload.recipients[userId][clientId];

      const _removeRedundantUser = userId => {
        const clientIdsOfUser = Object.keys(payload.recipients[userId]);
        const noRemainingClients = !clientIdsOfUser.length;

        if (noRemainingClients) {
          const isGroupConversation = conversationEntity && conversationEntity.isGroup();
          if (isGroupConversation) {
            const timestamp = this.serverTimeRepository.toServerTimestamp();
            const event = z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, false, timestamp);

            this.eventRepository.injectEvent(event);
          }

          delete payload.recipients[userId];
        }
      };

      return Promise.all(this._mapRecipients(recipients, _removeRedundantClient, _removeRedundantUser)).then(() => {
        if (conversationEntity) {
          this.conversationRepository.updateParticipatingUserEntities(conversationEntity);
        }

        return payload;
      });
    });
  }

  /**
   * Map a function to recipients.
   *
   * @private
   * @param {Object} recipients - User client map
   * @param {Function} clientFn - Function to be executed on clients first
   * @param {Function} [userFn] - Function to be executed on users at the end
   * @returns {Array} Function array
   */
  _mapRecipients(recipients, clientFn, userFn) {
    const result = [];

    Object.entries(recipients).forEach(([userId, clientIds = []]) => {
      if (_.isFunction(clientFn)) {
        clientIds.forEach(clientId => result.push(clientFn(userId, clientId)));
      }

      if (_.isFunction(userFn)) {
        result.push(userFn(userId));
      }
    });

    return result;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationCellState = (() => {
  const ACTIVITY_TYPE = {
    CALL: 'ConversationCellState.ACTIVITY_TYPE.CALL',
    MENTION: 'ConversationCellState.ACTIVITY_TYPE.MENTION',
    MESSAGE: 'ConversationCellState.ACTIVITY_TYPE.MESSAGE',
    PING: 'ConversationCellState.ACTIVITY_TYPE.PING',
    REPLY: 'ConversationCellState.ACTIVITY_TYPE.REPLY',
  };

  const _accumulateSummary = (conversationEntity, prioritizeMentionAndReply) => {
    const {
      calls: unreadCalls,
      otherMessages: unreadOtherMessages,
      pings: unreadPings,
      selfMentions: unreadSelfMentions,
      selfReplies: unreadSelfReplies,
    } = conversationEntity.unreadState();

    // Sorted in order of alert type priority
    const activities = {
      [ACTIVITY_TYPE.MENTION]: unreadSelfMentions.length,
      [ACTIVITY_TYPE.REPLY]: unreadSelfReplies.length,
      [ACTIVITY_TYPE.CALL]: unreadCalls.length,
      [ACTIVITY_TYPE.PING]: unreadPings.length,
      [ACTIVITY_TYPE.MESSAGE]: unreadOtherMessages.length,
    };

    const alertCount = Object.values(activities).reduce((accumulator, value) => accumulator + value, 0);
    const hasSingleAlert = alertCount === 1;
    const hasOnlyReplies = activities[ACTIVITY_TYPE.REPLY] > 0 && alertCount === activities[ACTIVITY_TYPE.REPLY];

    if (prioritizeMentionAndReply && (hasSingleAlert || hasOnlyReplies)) {
      const hasSingleMention = activities[ACTIVITY_TYPE.MENTION] === 1;

      if (hasSingleMention || hasOnlyReplies) {
        const [mentionMessageEntity] = unreadSelfMentions;
        const [replyMessageEntity] = unreadSelfReplies;
        const messageEntity = mentionMessageEntity || replyMessageEntity;

        if (messageEntity.is_ephemeral()) {
          let stringId;

          if (hasSingleMention) {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralMentionGroup
              : z.string.conversationsSecondaryLineEphemeralMention;
          } else {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralReplyGroup
              : z.string.conversationsSecondaryLineEphemeralReply;
          }

          return z.l10n.text(stringId);
        }

        return conversationEntity.isGroup()
          ? `${messageEntity.unsafeSenderName()}: ${messageEntity.get_first_asset().text}`
          : messageEntity.get_first_asset().text;
      }
    }

    return _generateSummaryDescription(activities);
  };

  const _generateSummaryDescription = activities => {
    return Object.entries(activities)
      .map(([activity, activityCount]) => {
        if (activityCount) {
          const activityCountIsOne = activityCount === 1;
          let stringId = undefined;

          switch (activity) {
            case ACTIVITY_TYPE.CALL: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMissedCall
                : z.string.conversationsSecondaryLineSummaryMissedCalls;
              break;
            }

            case ACTIVITY_TYPE.MENTION: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMention
                : z.string.conversationsSecondaryLineSummaryMentions;
              break;
            }

            case ACTIVITY_TYPE.MESSAGE: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMessage
                : z.string.conversationsSecondaryLineSummaryMessages;
              break;
            }

            case ACTIVITY_TYPE.PING: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryPing
                : z.string.conversationsSecondaryLineSummaryPings;
              break;
            }

            case ACTIVITY_TYPE.REPLY: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryReply
                : z.string.conversationsSecondaryLineSummaryReplies;
              break;
            }

            default:
              throw new z.error.ConversationError();
          }

          return z.l10n.text(stringId, activityCount);
        }
      })
      .filter(activityString => !!activityString)
      .join(', ');
  };

  const _getStateAlert = {
    description: conversationEntity => _accumulateSummary(conversationEntity, true),
    icon: conversationEntity => {
      const {
        calls: unreadCalls,
        pings: unreadPings,
        selfMentions: unreadSelfMentions,
        selfReplies: unreadSelfReplies,
      } = conversationEntity.unreadState();

      if (unreadSelfMentions.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_MENTION;
      }

      if (unreadSelfReplies.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_REPLY;
      }

      if (unreadCalls.length) {
        return z.conversation.ConversationStatusIcon.MISSED_CALL;
      }

      if (unreadPings.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_PING;
      }
    },
    match: conversationEntity => {
      const {
        calls: unreadCalls,
        pings: unreadPings,
        selfMentions: unreadSelfMentions,
        selfReplies: unreadSelfReplies,
      } = conversationEntity.unreadState();

      const hasUnreadActivities =
        unreadCalls.length > 0 ||
        unreadPings.length > 0 ||
        unreadSelfMentions.length > 0 ||
        unreadSelfReplies.length > 0;

      return hasUnreadActivities;
    },
  };

  const _getStateCall = {
    description: conversationEntity => {
      const creatorName = conversationEntity.call().creatingUser.first_name();
      return z.l10n.text(z.string.conversationsSecondaryLineIncomingCall, creatorName);
    },
    icon: () => z.conversation.ConversationStatusIcon.NONE,
    match: conversationEntity => {
      return conversationEntity.call()
        ? conversationEntity.call().canJoinState() && !conversationEntity.call().selfUserJoined()
        : false;
    },
  };

  const _getStateDefault = {
    description: () => '',
    icon: () => z.conversation.ConversationStatusIcon.NONE,
  };

  const _getStateGroupActivity = {
    description: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();

      if (lastMessageEntity.is_member()) {
        const userCount = lastMessageEntity.userEntities().length;
        const hasUserCount = userCount >= 1;

        if (hasUserCount) {
          const userCountIsOne = userCount === 1;

          if (lastMessageEntity.isMemberJoin()) {
            if (userCountIsOne) {
              if (!lastMessageEntity.remoteUserEntities().length) {
                return z.l10n.text(z.string.conversationsSecondaryLinePersonAddedYou, lastMessageEntity.user().name());
              }

              const [remoteUserEntity] = lastMessageEntity.remoteUserEntities();
              const userSelfJoined = lastMessageEntity.user().id === remoteUserEntity.id;
              const stringId = userSelfJoined
                ? z.string.conversationsSecondaryLinePersonAddedSelf
                : z.string.conversationsSecondaryLinePersonAdded;

              return z.l10n.text(stringId, remoteUserEntity.name());
            }

            return z.l10n.text(z.string.conversationsSecondaryLinePeopleAdded, userCount);
          }

          if (lastMessageEntity.isMemberRemoval()) {
            if (userCountIsOne) {
              const [remoteUserEntity] = lastMessageEntity.remoteUserEntities();

              if (remoteUserEntity) {
                if (lastMessageEntity.isTeamMemberLeave()) {
                  const name = lastMessageEntity.name() || remoteUserEntity.name();
                  return z.l10n.text(z.string.conversationsSecondaryLinePersonRemovedTeam, name);
                }

                const userSelfLeft = remoteUserEntity.id === lastMessageEntity.user().id;
                const stringId = userSelfLeft
                  ? z.string.conversationsSecondaryLinePersonLeft
                  : z.string.conversationsSecondaryLinePersonRemoved;

                return z.l10n.text(stringId, remoteUserEntity.name());
              }
            }

            return z.l10n.text(z.string.conversationsSecondaryLinePeopleLeft, userCount);
          }
        }
      }

      const isConversationRename = lastMessageEntity.is_system() && lastMessageEntity.is_conversation_rename();
      if (isConversationRename) {
        return z.l10n.text(z.string.conversationsSecondaryLineRenamed, lastMessageEntity.user().name());
      }
    },
    icon: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isMemberRemoval = lastMessageEntity.is_member() && lastMessageEntity.isMemberRemoval();

      if (isMemberRemoval) {
        return conversationEntity.showNotificationsEverything()
          ? z.conversation.ConversationStatusIcon.UNREAD_MESSAGES
          : z.conversation.ConversationStatusIcon.MUTED;
      }
    },
    match: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isExpectedType = lastMessageEntity ? lastMessageEntity.is_member() || lastMessageEntity.is_system() : false;
      const unreadEvents = conversationEntity.unreadState().allEvents;

      return conversationEntity.isGroup() && unreadEvents.length > 0 && isExpectedType;
    },
  };

  const _getStateMuted = {
    description: conversationEntity => {
      return _accumulateSummary(conversationEntity, conversationEntity.showNotificationsMentionsAndReplies());
    },
    icon: conversationEntity => {
      const hasSelfMentions = conversationEntity.unreadState().selfMentions.length > 0;
      const hasSelfReplies = conversationEntity.unreadState().selfReplies.length > 0;
      const showMentionsIcon = hasSelfMentions && conversationEntity.showNotificationsMentionsAndReplies();
      const showRepliesIcon = hasSelfReplies && conversationEntity.showNotificationsMentionsAndReplies();

      if (showMentionsIcon) {
        return z.conversation.ConversationStatusIcon.UNREAD_MENTION;
      }

      if (showRepliesIcon) {
        return z.conversation.ConversationStatusIcon.UNREAD_REPLY;
      }

      return z.conversation.ConversationStatusIcon.MUTED;
    },
    match: conversationEntity => !conversationEntity.showNotificationsEverything(),
  };

  const _getStateRemoved = {
    description: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const selfUserId = conversationEntity.selfUser().id;

      const isMemberRemoval = lastMessageEntity && lastMessageEntity.is_member() && lastMessageEntity.isMemberRemoval();
      const wasSelfRemoved = isMemberRemoval && lastMessageEntity.userIds().includes(selfUserId);
      if (wasSelfRemoved) {
        const selfLeft = lastMessageEntity.user().id === selfUserId;
        const stringId = selfLeft
          ? z.string.conversationsSecondaryLineYouLeft
          : z.string.conversationsSecondaryLineYouWereRemoved;

        return z.l10n.text(stringId);
      }

      return '';
    },
    icon: () => z.conversation.ConversationStatusIcon.NONE,
    match: conversationEntity => conversationEntity.removed_from_conversation(),
  };

  const _getStateUnreadMessage = {
    description: conversationEntity => {
      const unreadMessages = conversationEntity.unreadState().allMessages;

      for (const messageEntity of unreadMessages) {
        let stringId;

        if (messageEntity.is_ping()) {
          stringId = z.string.notificationPing;
        } else if (messageEntity.has_asset_text()) {
          stringId = true;
        } else if (messageEntity.has_asset()) {
          const assetEntity = messageEntity.get_first_asset();
          const isUploaded = assetEntity.status() === z.assets.AssetTransferState.UPLOADED;

          if (isUploaded) {
            if (assetEntity.is_audio()) {
              stringId = z.string.notificationSharedAudio;
            } else if (assetEntity.is_video()) {
              stringId = z.string.notificationSharedVideo;
            } else {
              stringId = z.string.notificationSharedFile;
            }
          }
        } else if (messageEntity.has_asset_location()) {
          stringId = z.string.notificationSharedLocation;
        } else if (messageEntity.has_asset_image()) {
          stringId = z.string.notificationAssetAdd;
        }

        if (!!stringId) {
          if (messageEntity.is_ephemeral()) {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralMessageGroup
              : z.string.conversationsSecondaryLineEphemeralMessage;
            return z.l10n.text(stringId);
          }

          const hasStringId = stringId && stringId !== true;
          const stateText = hasStringId ? z.l10n.text(stringId) : messageEntity.get_first_asset().text;
          return conversationEntity.isGroup() ? `${messageEntity.unsafeSenderName()}: ${stateText}` : stateText;
        }
      }
    },
    icon: () => z.conversation.ConversationStatusIcon.UNREAD_MESSAGES,
    match: conversationEntity => conversationEntity.unreadState().allMessages.length > 0,
  };

  const _getStateUserName = {
    description: conversationEntity => {
      const [userEntity] = conversationEntity.participating_user_ets();
      const hasUsername = userEntity && userEntity.username();
      return hasUsername ? `@${userEntity.username()}` : '';
    },
    icon: conversationEntity => {
      if (conversationEntity.isRequest()) {
        return z.conversation.ConversationStatusIcon.PENDING_CONNECTION;
      }
    },
    match: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isMemberJoin = lastMessageEntity && lastMessageEntity.is_member() && lastMessageEntity.isMemberJoin();
      const isEmpty1to1Conversation = conversationEntity.is1to1() && isMemberJoin;

      return conversationEntity.isRequest() || isEmpty1to1Conversation;
    },
  };

  return {
    generate: conversationEntity => {
      const states = [
        _getStateCall,
        _getStateRemoved,
        _getStateMuted,
        _getStateAlert,
        _getStateGroupActivity,
        _getStateUnreadMessage,
        _getStateUserName,
      ];
      const matchingState = states.find(state => state.match(conversationEntity)) || _getStateDefault;

      return {
        description: matchingState.description(conversationEntity),
        icon: matchingState.icon(conversationEntity),
      };
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationEphemeralHandler = class ConversationEphemeralHandler extends z.conversation
  .AbstractConversationEventHandler {
  static get CONFIG() {
    return {
      INTERVAL_TIME: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.25,
      TIMER_RANGE: {
        MAX: z.util.TimeUtil.UNITS_IN_MILLIS.YEAR,
        MIN: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    };
  }

  static validateTimer(messageTimer) {
    const TIMER_RANGE = ConversationEphemeralHandler.CONFIG.TIMER_RANGE;
    const isTimerReset = messageTimer === null;

    return isTimerReset ? messageTimer : z.util.NumberUtil.clamp(messageTimer, TIMER_RANGE.MIN, TIMER_RANGE.MAX);
  }

  constructor(conversationMapper, eventService, eventListeners) {
    super();

    const defaultEventListeners = {onMessageTimeout: z.util.noop};
    this.eventListeners = Object.assign({}, defaultEventListeners, eventListeners);
    this.eventService = eventService;

    this.setEventHandlingConfig({
      [z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE]: this._updateEphemeralTimer.bind(this),
    });

    this.checkMessageTimer = this.checkMessageTimer.bind(this);

    this.conversationMapper = conversationMapper;
    this.logger = new z.util.Logger('z.conversation.ConversationEphemeralHandler', z.config.LOGGER.OPTIONS);

    this.timedMessages = ko.observableArray([]);

    let updateIntervalId = null;
    this.timedMessages.subscribe(messageEntities => {
      const shouldClearInterval = !messageEntities.length && updateIntervalId;
      if (shouldClearInterval) {
        window.clearInterval(updateIntervalId);
        updateIntervalId = null;
        return this.logger.info('Cleared ephemeral message check interval');
      }

      const shouldSetInterval = messageEntities.length && !updateIntervalId;
      if (shouldSetInterval) {
        const INTERVAL_TIME = ConversationEphemeralHandler.CONFIG.INTERVAL_TIME;
        updateIntervalId = window.setInterval(() => this._updateTimedMessages(), INTERVAL_TIME);
        this.logger.info('Started ephemeral message check interval');
      }
    });
  }

  /**
   * Check the remaining lifetime for a given ephemeral message.
   *
   * @param {Message} messageEntity - Message to check
   * @param {number} timeOffset - Approximate time different to backend in milliseconds
   * @returns {undefined} No return value
   */
  checkMessageTimer(messageEntity, timeOffset) {
    const hasHitBackend = messageEntity.status() > z.message.StatusType.SENDING;
    if (!hasHitBackend) {
      return;
    }

    switch (messageEntity.ephemeral_status()) {
      case z.message.EphemeralStatusType.TIMED_OUT: {
        this._timeoutEphemeralMessage(messageEntity);
        break;
      }

      case z.message.EphemeralStatusType.ACTIVE: {
        messageEntity.startMessageTimer(timeOffset);
        break;
      }

      case z.message.EphemeralStatusType.INACTIVE: {
        messageEntity.startMessageTimer(timeOffset);

        const changes = {
          ephemeral_expires: messageEntity.ephemeral_expires(),
          ephemeral_started: messageEntity.ephemeral_started(),
        };

        this.eventService.updateEvent(messageEntity.primary_key, changes);
        break;
      }

      default:
        this.logger.info(this.logger.levels.OFF, `Non-ephemeral message of type: ${messageEntity.type}`);
    }
  }

  validateMessage(messageEntity) {
    const isEphemeralMessage = messageEntity.ephemeral_status() !== z.message.EphemeralStatusType.NONE;
    if (!isEphemeralMessage) {
      return messageEntity;
    }

    const isExpired = !!this._updateTimedMessage(messageEntity);
    if (!isExpired) {
      const {id, conversation_id: conversationId} = messageEntity;
      const matchingMessageEntity = this.timedMessages().find(timedMessageEntity => {
        const {conversation_id: timedConversationId, id: timedMessageId} = timedMessageEntity;
        return timedMessageId === id && timedConversationId === conversationId;
      });

      if (matchingMessageEntity) {
        this.timedMessages.replace(matchingMessageEntity, messageEntity);
      } else {
        this.timedMessages.push(messageEntity);
      }

      return messageEntity;
    }
  }

  validateMessages(messageEntities) {
    return messageEntities
      .map(messageEntity => this.validateMessage(messageEntity))
      .filter(messageEntity => messageEntity);
  }

  _obfuscateAssetMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const changes = {
      data: {
        content_type: assetEntity.file_type,
        meta: {},
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated asset message '${messageEntity.id}'`);
  }

  _obfuscateImageMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const changes = {
      data: {
        info: {
          height: assetEntity.height,
          tag: 'medium',
          width: assetEntity.width,
        },
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated image message '${messageEntity.id}'`);
  }

  _obfuscateMessage(messageEntity) {
    if (messageEntity.has_asset_text()) {
      this._obfuscateTextMessage(messageEntity);
    } else if (messageEntity.has_asset()) {
      this._obfuscateAssetMessage(messageEntity);
    } else if (messageEntity.has_asset_image()) {
      this._obfuscateImageMessage(messageEntity);
    } else {
      this.logger.warn(`Ephemeral message of unsupported type: ${messageEntity.type}`, messageEntity);
    }
  }

  _obfuscateTextMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const obfuscatedAsset = new z.entity.Text(messageEntity.id);
    const obfuscatedPreviews = assetEntity.previews().map(linkPreview => {
      linkPreview.obfuscate();
      const protoArticle = new z.proto.Article(linkPreview.url, linkPreview.title); // deprecated format
      return new z.proto.LinkPreview(linkPreview.url, 0, protoArticle, linkPreview.url, linkPreview.title).encode64();
    });

    obfuscatedAsset.text = z.util.StringUtil.obfuscate(assetEntity.text);
    obfuscatedAsset.previews(assetEntity.previews());

    messageEntity.assets([obfuscatedAsset]);
    const changes = {
      data: {
        content: obfuscatedAsset.text,
        previews: obfuscatedPreviews,
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated text message '${messageEntity.id}'`);
  }

  _timeoutEphemeralMessage(messageEntity) {
    if (!messageEntity.is_expired()) {
      if (messageEntity.user().is_me) {
        this._obfuscateMessage(messageEntity);
      }

      this.eventListeners.onMessageTimeout(messageEntity);
    }
  }

  /**
   * Updates the ephemeral timer of a conversation when an timer-update message is received.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity which message timer was changed
   * @param {Object} eventJson - JSON data of 'conversation.message-timer-update' event
   * @returns {Promise} Resolves when the event was handled
   */
  _updateEphemeralTimer(conversationEntity, eventJson) {
    const updates = {globalMessageTimer: ConversationEphemeralHandler.validateTimer(eventJson.data.message_timer)};
    this.conversationMapper.updateProperties(conversationEntity, updates);
    return Promise.resolve(conversationEntity);
  }

  _updateTimedMessage(messageEntity) {
    if (_.isString(messageEntity.ephemeral_expires())) {
      const remainingTime = Math.max(0, messageEntity.ephemeral_expires() - Date.now());
      messageEntity.ephemeral_remaining(remainingTime);

      const isExpired = remainingTime === 0;
      if (isExpired) {
        this._timeoutEphemeralMessage(messageEntity);
        return messageEntity;
      }
    }
  }

  _updateTimedMessages() {
    const expiredMessages = this.timedMessages()
      .map(messageEntity => this._updateTimedMessage(messageEntity))
      .filter(messageEntity => messageEntity);

    if (expiredMessages.length) {
      this.timedMessages.remove(messageEntity => {
        for (const expiredMessage of expiredMessages) {
          const {conversation_id: conversationId, id: messageId} = expiredMessage;
          const isExpiredMessage = messageEntity.id === messageId && messageEntity.conversation_id === conversationId;
          if (isExpiredMessage) {
            return true;
          }
        }

        return false;
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

// @ts-check

'use strict';

/**
 * @typedef {object} ConversationBackendData
 * @property {string[]=} access
 * @property {string=} access_role
 * @property {string=} creator
 * @property {string=} id
 * @property {string=} last_event
 * @property {string=} last_event_time
 * @property {ConversationMembers=} members
 * @property {number=} message_timer
 * @property {string=} name
 * @property {string=} team
 * @property {number} type
 */

/**
 * @typedef {object} ConversationMembers
 * @property {OtherMember[]} others
 * @property {Member} self
 */

/**
 * @typedef {object} Member
 * @property {string=} hidden_ref
 * @property {boolean=} hidden
 * @property {string=} id
 * @property {string=} otr_archived_ref
 * @property {boolean=} otr_archived
 * @property {string=} otr_muted_ref
 * @property {boolean=} otr_muted
 * @property {ServiceRef=} service
 */

/**
 * @typedef {object} OtherMember
 * @property {string} id
 * @property {number} status
 */

/**
 * @typedef {object} SelfStatusUpdate
 * @property {number=} archived_timestamp
 * @property {number=} cleared_timestamp
 * @property {number=} ephemeral_timer
 * @property {number=} message_timer
 * @property {number=} last_event_timestamp
 * @property {number=} last_read_timestamp
 * @property {number=} last_server_timestamp
 * @property {boolean=} otr_archived
 * @property {string=} otr_archived_ref
 * @property {boolean=} otr_muted
 * @property {string=} otr_muted_ref
 * @property {boolean=} muted_state
 * @property {number=} status
 * @property {number=} verification_state
 */

/**
 * @typedef {object} ServiceRef
 * @property {string} id
 * @property {string} provider
 */

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation Mapper to convert all server side JSON conversation objects into core entities.
z.conversation.ConversationMapper = class ConversationMapper {
  // Construct a new Conversation Mapper.
  constructor() {
    this.logger = new z.util.Logger('z.conversation.ConversationMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Converts JSON conversations into conversation entities.
   *
   * @param {Array} conversationsData - Conversation data
   * @param {number} [timestamp=1] - Initial timestamp for conversation
   * @returns {Array<Conversation>} Mapped conversation entities
   */
  mapConversations(conversationsData, timestamp = 1) {
    if (conversationsData === undefined) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }
    if (!_.isArray(conversationsData) || !conversationsData.length) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    }
    return conversationsData.map((conversationData, index) => {
      return this._createConversationEntity(conversationData, timestamp + index);
    });
  }

  /**
   * Updates all properties of a conversation specified.
   *
   * @example data: {"name":"ThisIsMyNewConversationName"}
   * @todo make utility?
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {ConversationBackendData} conversationData - Conversation data from backend
   * @returns {Conversation} Updated conversation entity
   */
  updateProperties(conversationEntity, conversationData) {
    Object.entries(conversationData).forEach(([key, value]) => {
      if (key !== 'id') {
        if (value !== undefined && conversationEntity.hasOwnProperty(key)) {
          if (ko.isObservable(conversationEntity[key])) {
            conversationEntity[key](value);
          } else {
            conversationEntity[key] = value;
          }
        }
      }
    });

    return conversationEntity;
  }

  /**
   * Update the membership properties of a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {SelfStatusUpdate} selfState - Conversation self data from the database
   * @param {boolean} [disablePersistence=false] - Disable persistence of state changes during update
   * @returns {Conversation} Updated conversation entity
   */
  updateSelfStatus(conversationEntity, selfState, disablePersistence = false) {
    if (conversationEntity) {
      if (disablePersistence) {
        conversationEntity.setStateChangePersistence(false);
      }

      // Database states
      const {
        archived_timestamp,
        cleared_timestamp,
        ephemeral_timer,
        message_timer,
        last_event_timestamp,
        last_read_timestamp,
        last_server_timestamp,
        muted_timestamp,
        status,
        verification_state,
      } = selfState;

      if (archived_timestamp) {
        conversationEntity.setTimestamp(archived_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.ARCHIVED);
        conversationEntity.archivedState(selfState.archived_state);
      }

      if (cleared_timestamp !== undefined) {
        conversationEntity.setTimestamp(cleared_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.CLEARED, true);
      }

      if (ephemeral_timer !== undefined) {
        conversationEntity.localMessageTimer(ephemeral_timer);
      }

      if (message_timer !== undefined) {
        conversationEntity.globalMessageTimer(message_timer);
      }

      if (last_event_timestamp) {
        conversationEntity.setTimestamp(last_event_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_EVENT);
      }

      if (last_read_timestamp) {
        conversationEntity.setTimestamp(last_read_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ);
      }

      if (last_server_timestamp) {
        conversationEntity.setTimestamp(last_server_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_SERVER);
      }

      if (muted_timestamp) {
        conversationEntity.setTimestamp(muted_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.MUTED);
        conversationEntity.mutedState(selfState.muted_state);
      }

      if (status !== undefined) {
        conversationEntity.status(status);
      }

      if (verification_state !== undefined) {
        conversationEntity.verification_state(verification_state);
      }

      // Backend states
      const {otr_archived, otr_muted} = selfState;

      if (otr_archived !== undefined) {
        const archivedTimestamp = new Date(selfState.otr_archived_ref).getTime();
        conversationEntity.setTimestamp(archivedTimestamp, z.entity.Conversation.TIMESTAMP_TYPE.ARCHIVED);
        conversationEntity.archivedState(otr_archived);
      }

      if (otr_muted !== undefined) {
        const mutedTimestamp = new Date(selfState.otr_muted_ref).getTime();
        conversationEntity.setTimestamp(mutedTimestamp, z.entity.Conversation.TIMESTAMP_TYPE.MUTED);

        const mutedState = this.getMutedState(otr_muted, selfState.otr_muted_status);
        conversationEntity.mutedState(mutedState);
      }

      if (disablePersistence) {
        conversationEntity.setStateChangePersistence(true);
      }

      return conversationEntity;
    }
  }

  /**
   * Creates a conversation entity from backend JSON data.
   *
   * @private
   * @param {Object} conversationData - Either locally stored or backend data
   * @param {number} [initialTimestamp] - Initial timestamp for conversation in milliseconds
   * @returns {Conversation} Mapped conversation entity
   */
  _createConversationEntity(conversationData, initialTimestamp) {
    if (conversationData === undefined) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }
    if (!_.isObject(conversationData) || !Object.keys(conversationData).length) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    }

    const {creator, id, members, name, others, type} = conversationData;
    let conversationEntity = new z.entity.Conversation(id);

    conversationEntity.creator = creator;
    conversationEntity.type(type);
    conversationEntity.name(name ? name : '');

    const selfState = members ? members.self : conversationData;
    conversationEntity = this.updateSelfStatus(conversationEntity, selfState);

    if (!conversationEntity.last_event_timestamp() && initialTimestamp) {
      conversationEntity.last_event_timestamp(initialTimestamp);
      conversationEntity.last_server_timestamp(initialTimestamp);
    }

    // Active participants from database or backend payload
    const participatingUserIds = others ? others : members.others.map(other => other.id);
    conversationEntity.participating_user_ids(participatingUserIds);

    // Team ID from database or backend payload
    const teamId = conversationData.team_id || conversationData.team;
    if (teamId) {
      conversationEntity.team_id = teamId;
    }

    if (conversationData.is_guest) {
      conversationEntity.isGuest(conversationData.is_guest);
    }

    // Access related data
    const accessModes = conversationData.accessModes || conversationData.access;
    const accessRole = conversationData.accessRole || conversationData.access_role;
    if (accessModes && accessRole) {
      this.mapAccessState(conversationEntity, accessModes, accessRole);
    }

    return conversationEntity;
  }

  /**
   * Get the valid muted state.
   *
   * @param {boolean} mutedState - Outdated muted state
   * @param {z.conversation.NotificationSetting.STATE} [notificationState] - Bit mask based notification setting
   * @returns {z.conversation.NotificationSetting.STATE} validated notification setting
   */
  getMutedState(mutedState, notificationState) {
    const validNotifcationStates = Object.values(z.conversation.NotificationSetting.STATE);
    if (validNotifcationStates.includes(notificationState)) {
      // Ensure bit at offset 0 to be 1 for backwards compatibility of deprecated boolean based state is true
      return mutedState ? notificationState | 0b1 : z.conversation.NotificationSetting.STATE.EVERYTHING;
    }

    return typeof mutedState === 'boolean' ? mutedState : z.conversation.NotificationSetting.STATE.EVERYTHING;
  }

  /**
   * Merge local database records with remote backend payload.
   *
   * @param {Array<Object>} localConversations - Database records
   * @param {Array<Object>} remoteConversations - Backend payload
   * @returns {Array<Object>} Merged conversation data
   */
  mergeConversation(localConversations, remoteConversations) {
    localConversations = localConversations.filter(conversationData => conversationData);

    return remoteConversations.map((remoteConversationData, index) => {
      const conversationId = remoteConversationData.id;
      const localConversationData = localConversations.find(({id}) => id === conversationId) || {id: conversationId};

      const {access, access_role, creator, members, message_timer, name, team, type} = remoteConversationData;
      const {others: othersStates, self: selfState} = members;

      const updates = {
        accessModes: access,
        accessRole: access_role,
        creator,
        message_timer,
        name,
        status: selfState.status,
        team_id: team,
        type,
      };
      const mergedConversation = Object.assign({}, localConversationData, updates);

      const isGroup = type === z.conversation.ConversationType.GROUP;
      const noOthers = !mergedConversation.others || !mergedConversation.others.length;
      if (isGroup || noOthers) {
        mergedConversation.others = othersStates
          .filter(otherState => otherState.status === z.conversation.ConversationStatus.CURRENT_MEMBER)
          .map(otherState => otherState.id);
      }

      // This should ensure a proper order
      if (!mergedConversation.last_event_timestamp) {
        mergedConversation.last_event_timestamp = index + 1;
      }

      // Set initially or correct server timestamp
      const wrongServerTimestamp = mergedConversation.last_server_timestamp < mergedConversation.last_event_timestamp;
      if (!mergedConversation.last_server_timestamp || wrongServerTimestamp) {
        mergedConversation.last_server_timestamp = mergedConversation.last_event_timestamp;
      }

      const isRemoteTimestampNewer = (localTimestamp, remoteTimestamp) => {
        return localTimestamp !== undefined && remoteTimestamp > localTimestamp;
      };

      // Some archived timestamp were not properly stored in the database.
      // To fix this we check if the remote one is newer and update our local timestamp.
      const {archived_state: archivedState, archived_timestamp: archivedTimestamp} = localConversationData;
      const remoteArchivedTimestamp = new Date(selfState.otr_archived_ref).getTime();
      const isRemoteArchivedTimestampNewer = isRemoteTimestampNewer(archivedTimestamp, remoteArchivedTimestamp);

      if (isRemoteArchivedTimestampNewer || archivedState === undefined) {
        mergedConversation.archived_state = selfState.otr_archived;
        mergedConversation.archived_timestamp = remoteArchivedTimestamp;
      }

      const {muted_state: mutedState, muted_timestamp: mutedTimestamp} = localConversationData;
      const remoteMutedTimestamp = new Date(selfState.otr_muted_ref).getTime();
      const isRemoteMutedTimestampNewer = isRemoteTimestampNewer(mutedTimestamp, remoteMutedTimestamp);

      if (isRemoteMutedTimestampNewer || mutedState === undefined) {
        const remoteMutedState = this.getMutedState(selfState.otr_muted, selfState.otr_muted_statu);
        mergedConversation.muted_state = remoteMutedState;
        mergedConversation.muted_timestamp = remoteMutedTimestamp;
      }

      return mergedConversation;
    });
  }

  mapAccessCode(conversationEntity, accessCode) {
    const isTeamConversation = conversationEntity && conversationEntity.team_id;

    if (accessCode.uri && isTeamConversation) {
      conversationEntity.accessCode(accessCode.uri);
    }
  }

  mapAccessState(conversationEntity, accessModes, accessRole) {
    if (conversationEntity.team_id) {
      if (conversationEntity.is1to1()) {
        return conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.ONE2ONE);
      }

      const isTeamRole = accessRole === z.conversation.ACCESS_ROLE.TEAM;

      const includesInviteMode = accessModes.includes(z.conversation.ACCESS_MODE.INVITE);
      const isInviteModeOnly = includesInviteMode && accessModes.length === 1;

      const isTeamOnlyMode = isTeamRole && isInviteModeOnly;
      if (isTeamOnlyMode) {
        return conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY);
      }

      const isNonVerifiedRole = accessRole === z.conversation.ACCESS_ROLE.NON_ACTIVATED;

      const includesCodeMode = accessModes.includes(z.conversation.ACCESS_MODE.CODE);
      const isExpectedModes = includesCodeMode && includesInviteMode && accessModes.length === 2;

      const isGuestRoomMode = isNonVerifiedRole && isExpectedModes;
      return isGuestRoomMode
        ? conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM)
        : conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.LEGACY);
    }

    if (conversationEntity.isSelf()) {
      return conversationEntity.accessState(z.conversation.ACCESS_STATE.SELF);
    }

    const personalAccessState = conversationEntity.isGroup()
      ? z.conversation.ACCESS_STATE.PERSONAL.GROUP
      : z.conversation.ACCESS_STATE.PERSONAL.ONE2ONE;
    return conversationEntity.accessState(personalAccessState);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation repository for all conversation interactions with the conversation service
z.conversation.ConversationRepository = class ConversationRepository {
  static get CONFIG() {
    return {
      CONFIRMATION_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      EXTERNAL_MESSAGE_THRESHOLD: 200 * 1024,
      GROUP: {
        MAX_NAME_LENGTH: 64,
        MAX_SIZE: 300,
      },
    };
  }

  static get CONSENT_TYPE() {
    return {
      INCOMING_CALL: 'incoming_call',
      MESSAGE: 'message',
      OUTGOING_CALL: 'outgoing_call',
    };
  }

  /**
   * Construct a new Conversation Repository.
   *
   * @param {ConversationService} conversation_service - Backend REST API conversation service implementation
   * @param {AssetService} asset_service - Backend REST API asset service implementation
   * @param {ClientRepository} client_repository - Repository for client interactions
   * @param {ConnectionRepository} connectionRepository - Repository for all connnection interactions
   * @param {CryptographyRepository} cryptography_repository - Repository for all cryptography interactions
   * @param {EventRepository} eventRepository - Repository that handles events
   * @param {GiphyRepository} giphy_repository - Repository for Giphy GIFs
   * @param {LinkPreviewRepository} link_repository - Repository for link previews
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {TeamRepository} team_repository - Repository for teams
   * @param {UserRepository} user_repository - Repository for all user interactions
   */
  constructor(
    conversation_service,
    asset_service,
    client_repository,
    connectionRepository,
    cryptography_repository,
    eventRepository,
    giphy_repository,
    link_repository,
    serverTimeRepository,
    team_repository,
    user_repository
  ) {
    this.eventRepository = eventRepository;
    this.eventService = eventRepository.eventService;
    this.conversation_service = conversation_service;
    this.asset_service = asset_service;
    this.client_repository = client_repository;
    this.connectionRepository = connectionRepository;
    this.cryptography_repository = cryptography_repository;
    this.giphy_repository = giphy_repository;
    this.link_repository = link_repository;
    this.serverTimeRepository = serverTimeRepository;
    this.team_repository = team_repository;
    this.user_repository = user_repository;
    this.logger = new z.util.Logger('z.conversation.ConversationRepository', z.config.LOGGER.OPTIONS);

    this.conversationMapper = new z.conversation.ConversationMapper();
    this.event_mapper = new z.conversation.EventMapper();
    this.verification_state_handler = new z.conversation.ConversationVerificationStateHandler(
      this,
      this.eventRepository,
      this.serverTimeRepository
    );
    this.clientMismatchHandler = new z.conversation.ClientMismatchHandler(
      this,
      this.cryptography_repository,
      this.eventRepository,
      this.serverTimeRepository,
      this.user_repository
    );

    this.active_conversation = ko.observable();
    this.conversations = ko.observableArray([]);

    this.isTeam = this.team_repository.isTeam;
    this.isTeam.subscribe(() => this.map_guest_status_self());
    this.team = this.team_repository.team;
    this.teamMembers = this.team_repository.teamMembers;

    this.selfUser = this.user_repository.self;

    this.block_event_handling = ko.observable(true);
    this.fetching_conversations = {};
    this.conversationsWithNewEvents = new Map();
    this.block_event_handling.subscribe(eventHandlingState => {
      if (!eventHandlingState) {
        this._checkChangedConversations();
      }
    });

    this.self_conversation = ko.pureComputed(() => {
      if (this.selfUser()) {
        return this._find_conversation_by_id(this.selfUser().id);
      }
    });

    this.filtered_conversations = ko.pureComputed(() => {
      return this.conversations().filter(conversation_et => {
        const states_to_filter = [
          z.connection.ConnectionStatus.BLOCKED,
          z.connection.ConnectionStatus.CANCELLED,
          z.connection.ConnectionStatus.PENDING,
        ];

        if (conversation_et.isSelf() || states_to_filter.includes(conversation_et.connection().status())) {
          return false;
        }

        return !(conversation_et.is_cleared() && conversation_et.removed_from_conversation());
      });
    });

    this.sorted_conversations = ko.pureComputed(() => {
      return this.filtered_conversations().sort(z.util.sortGroupsByLastEvent);
    });

    this.receiving_queue = new z.util.PromiseQueue({name: 'ConversationRepository.Receiving'});
    this.sending_queue = new z.util.PromiseQueue({name: 'ConversationRepository.Sending', paused: true});

    // @note Only use the client request queue as to unblock if not blocked by event handling or the cryptographic order of messages will be ruined and sessions might be deleted
    this.conversation_service.backendClient.queueState.subscribe(queueState => {
      const queueReady = queueState === z.service.QUEUE_STATE.READY;
      this.sending_queue.pause(!queueReady || this.block_event_handling());
    });

    this.conversations_archived = ko.observableArray([]);
    this.conversations_calls = ko.observableArray([]);
    this.conversations_cleared = ko.observableArray([]);
    this.conversations_unarchived = ko.observableArray([]);

    this.init_handled = 0;
    this.init_promise = undefined;
    this.init_total = 0;

    this._init_subscriptions();

    this.stateHandler = new z.conversation.ConversationStateHandler(this.conversation_service, this.conversationMapper);
    this.ephemeralHandler = new z.conversation.ConversationEphemeralHandler(
      this.conversationMapper,
      this.eventService,
      {onMessageTimeout: this.handleMessageExpiration.bind(this)}
    );
  }

  checkMessageTimer(messageEntity) {
    this.ephemeralHandler.checkMessageTimer(messageEntity, this.serverTimeRepository.getTimeOffset());
  }

  _initStateUpdates() {
    ko.computed(() => {
      const conversationsArchived = [];
      const conversationsCalls = [];
      const conversationsCleared = [];
      const conversationsUnarchived = [];

      this.sorted_conversations().forEach(conversationEntity => {
        const conversationWithCall = this.selfUser().isTemporaryGuest()
          ? conversationEntity.hasActiveCall() || conversationEntity.hasJoinableCall()
          : conversationEntity.hasActiveCall();
        if (conversationWithCall) {
          if (conversationEntity.call().isOngoing()) {
            conversationsCalls.unshift(conversationEntity);
          } else {
            conversationsCalls.push(conversationEntity);
          }
        }
        if (conversationEntity.is_cleared()) {
          conversationsCleared.push(conversationEntity);
        } else if (conversationEntity.is_archived()) {
          conversationsArchived.push(conversationEntity);
        } else {
          conversationsUnarchived.push(conversationEntity);
        }
      });

      this.conversations_archived(conversationsArchived);
      this.conversations_calls(conversationsCalls);
      this.conversations_cleared(conversationsCleared);
      this.conversations_unarchived(conversationsUnarchived);
    });
  }

  _init_subscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.ASSET.CANCEL, this.cancel_asset_upload.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.EVENT_FROM_BACKEND, this.onConversationEvent.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MAP_CONNECTION, this.map_connection.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MISSED_EVENTS, this.on_missed_events.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.PERSIST_STATE, this.save_conversation_state_in_db.bind(this));
    amplify.subscribe(
      z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE,
      this.set_notification_handling_state.bind(this)
    );
    amplify.subscribe(z.event.WebApp.TEAM.MEMBER_LEAVE, this.teamMemberLeave.bind(this));
    amplify.subscribe(z.event.WebApp.USER.UNBLOCKED, this.unblocked_user.bind(this));
  }

  /**
   * Remove obsolete conversations locally.
   * @returns {undefined} No return value
   */
  cleanup_conversations() {
    this.conversations().forEach(conversation_et => {
      if (conversation_et.isGroup() && conversation_et.is_cleared() && conversation_et.removed_from_conversation()) {
        this.conversation_service.delete_conversation_from_db(conversation_et.id);
        this.delete_conversation(conversation_et.id);
      }
    });
  }

  //##############################################################################
  // Conversation service interactions
  //##############################################################################

  /**
   * Create a group conversation.
   * @note Do not include the requestor among the users
   *
   * @param {Array<z.entity.User>} userEntities - Users (excluding the requestor) to be part of the conversation
   * @param {string} [groupName] - Name for the conversation
   * @param {string} [accessState] - State for conversation access
   * @returns {Promise} Resolves when the conversation was created
   */
  createGroupConversation(userEntities, groupName, accessState) {
    const userIds = userEntities.map(userEntity => userEntity.id);
    const payload = {
      name: groupName,
      users: userIds,
    };

    if (this.team().id) {
      payload.team = {
        managed: false,
        teamid: this.team().id,
      };

      if (accessState) {
        let accessPayload;

        switch (accessState) {
          case z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM:
            accessPayload = {
              access: [z.conversation.ACCESS_MODE.INVITE, z.conversation.ACCESS_MODE.CODE],
              access_role: z.conversation.ACCESS_ROLE.NON_ACTIVATED,
            };
            break;
          case z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY:
            accessPayload = {
              access: [z.conversation.ACCESS_MODE.INVITE],
              access_role: z.conversation.ACCESS_ROLE.TEAM,
            };
            break;
          default:
            break;
        }

        if (accessPayload) {
          Object.assign(payload, accessPayload);
        }
      }
    }

    return this.conversation_service
      .postConversations(payload)
      .then(response => this._onCreate({conversation: response.id, data: response}))
      .then(({conversationEntity}) => conversationEntity)
      .catch(error => this._handleConversationCreateError(error, userIds));
  }

  /**
   * Create a guest room.
   * @returns {Promise} Resolves with the conversation that was created
   */
  createGuestRoom() {
    const groupName = z.l10n.text(z.string.guestRoomConversationName);
    return this.createGroupConversation([], groupName, z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
  }

  /**
   * Get a conversation from the backend.
   * @param {string} conversation_id - Conversation to be retrieved from the backend
   * @returns {Promise} Resolve with the conversation entity
   */
  fetch_conversation_by_id(conversation_id) {
    if (this.fetching_conversations.hasOwnProperty(conversation_id)) {
      return new Promise((resolve, reject) => {
        this.fetching_conversations[conversation_id].push({reject_fn: reject, resolve_fn: resolve});
      });
    }

    this.fetching_conversations[conversation_id] = [];

    return this.conversation_service
      .get_conversation_by_id(conversation_id)
      .then(response => {
        const conversation_et = this.mapConversations(response);

        this.logger.info(`Fetched conversation '${conversation_id}' from backend`);
        this.save_conversation(conversation_et);

        this.fetching_conversations[conversation_id].forEach(({resolve_fn}) => resolve_fn(conversation_et));
        delete this.fetching_conversations[conversation_id];

        return conversation_et;
      })
      .catch(() => {
        const error = new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);

        this.fetching_conversations[conversation_id].forEach(({reject_fn}) => reject_fn(error));
        delete this.fetching_conversations[conversation_id];

        throw error;
      });
  }

  getConversations() {
    const remoteConversationsPromise = this.conversation_service.getAllConversations().catch(error => {
      this.logger.error(`Failed to get all conversations from backend: ${error.message}`);
      return [];
    });

    return Promise.all([this.conversation_service.load_conversation_states_from_db(), remoteConversationsPromise])
      .then(([localConversations, remoteConversations]) => {
        if (!remoteConversations.length) {
          return localConversations;
        }

        const data = this.conversationMapper.mergeConversation(localConversations, remoteConversations);
        return this.conversation_service.save_conversations_in_db(data);
      })
      .then(conversationsData => this.mapConversations(conversationsData))
      .then(conversationEntities => {
        this.save_conversations(conversationEntities);
        return this.conversations();
      });
  }

  updateConversationStates(conversationsData) {
    const handledConversationEntities = [];

    return Promise.resolve()
      .then(() => {
        const unknownConversations = [];

        conversationsData.forEach(conversationData => {
          const localEntity = this.conversations().find(({id}) => id === conversationData.id);

          if (localEntity) {
            const entity = this.conversationMapper.updateSelfStatus(localEntity, conversationData, true);
            return handledConversationEntities.push(entity);
          }

          unknownConversations.push(conversationData);
        });

        return unknownConversations.length ? this.mapConversations(unknownConversations) : [];
      })
      .then(conversationEntities => {
        if (conversationEntities.length) {
          this.save_conversations(conversationEntities);
        }
        conversationEntities = conversationEntities.concat(handledConversationEntities);

        const handledConversationData = conversationEntities.map(conversationEntity => conversationEntity.serialize());
        this.conversation_service.save_conversations_in_db(handledConversationData);
        return conversationEntities;
      });
  }

  /**
   * Get Message with given ID from the database.
   *
   * @param {Conversation} conversationEntity - Conversation message belongs to
   * @param {string} messageId - ID of message
   * @param {boolean} skipConversationMessages - Don't use message entity from conversation
   * @param {boolean} ensureUser - Make sure message entity has a valid user
   * @returns {Promise} Resolves with the message
   */
  get_message_in_conversation_by_id(
    conversationEntity,
    messageId,
    skipConversationMessages = false,
    ensureUser = false
  ) {
    const messageEntity = !skipConversationMessages && conversationEntity.getMessage(messageId);
    const messagePromise = messageEntity
      ? Promise.resolve(messageEntity)
      : this.eventService.loadEvent(conversationEntity.id, messageId).then(event => {
          if (event) {
            return this.event_mapper.mapJsonEvent(event, conversationEntity);
          }
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
        });

    if (ensureUser) {
      return messagePromise.then(message => {
        if (message.from && !message.user().id) {
          return this.user_repository.get_user_by_id(message.from).then(userEntity => {
            message.user(userEntity);
            return message;
          });
        }
        return message;
      });
    }
    return messagePromise;
  }

  /**
   * Get preceding messages starting with the given message.
   * @param {Conversation} conversationEntity - Respective conversation
   * @returns {Promise} Resolves with the messages
   */
  getPrecedingMessages(conversationEntity) {
    conversationEntity.is_pending(true);

    const firstMessageEntity = conversationEntity.getFirstMessage();
    const upperBound = firstMessageEntity
      ? new Date(firstMessageEntity.timestamp())
      : new Date(conversationEntity.get_latest_timestamp(this.serverTimeRepository.toServerTimestamp()) + 1);

    return this.eventService
      .loadPrecedingEvents(conversationEntity.id, new Date(0), upperBound, z.config.MESSAGES_FETCH_LIMIT)
      .then(events => this._addPrecedingEventsToConversation(events, conversationEntity))
      .then(mappedMessageEntities => {
        conversationEntity.is_pending(false);
        return mappedMessageEntities;
      });
  }

  _addPrecedingEventsToConversation(events, conversationEntity) {
    const hasAdditionalMessages = events.length === z.config.MESSAGES_FETCH_LIMIT;

    return this._addEventsToConversation(events, conversationEntity).then(mappedMessageEntities => {
      conversationEntity.hasAdditionalMessages(hasAdditionalMessages);

      if (!hasAdditionalMessages) {
        const firstMessage = conversationEntity.getFirstMessage();
        const checkCreationMessage = firstMessage && firstMessage.is_member() && firstMessage.isCreation();
        if (checkCreationMessage) {
          const groupCreationMessageIn1to1 = conversationEntity.is1to1() && firstMessage.isGroupCreation();
          const one2oneConnectionMessageInGroup = conversationEntity.isGroup() && firstMessage.isConnection();
          const wrongMessageTypeForConversation = groupCreationMessageIn1to1 || one2oneConnectionMessageInGroup;

          if (wrongMessageTypeForConversation) {
            this.deleteMessage(conversationEntity, firstMessage);
            conversationEntity.hasCreationMessage = false;
          } else {
            conversationEntity.hasCreationMessage = true;
          }
        }

        const addCreationMessage = !conversationEntity.hasCreationMessage;
        if (addCreationMessage) {
          this._addCreationMessage(conversationEntity, this.selfUser().isTemporaryGuest());
        }
      }

      return mappedMessageEntities;
    });
  }

  _addCreationMessage(conversationEntity, isTemporaryGuest, timestamp, eventSource) {
    conversationEntity.hasCreationMessage = true;

    if (conversationEntity.inTeam()) {
      const allTeamMembersParticipate = this.teamMembers().length
        ? this.teamMembers().every(teamMember => conversationEntity.participating_user_ids().includes(teamMember.id))
        : false;

      conversationEntity.withAllTeamMembers(allTeamMembersParticipate);
    }

    const creationEvent = conversationEntity.isGroup()
      ? z.conversation.EventBuilder.buildGroupCreation(conversationEntity, isTemporaryGuest, timestamp)
      : z.conversation.EventBuilder.build1to1Creation(conversationEntity);

    this.eventRepository.injectEvent(creationEvent, eventSource);
  }

  /**
   * Get specified message and load number preceding and subsequent messages defined by padding.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Message} messageEntity - Message entity
   * @param {number} [padding=30] - Number of messages to load around the targeted message
   * @returns {Promise} Resolves with the message
   */
  getMessagesWithOffset(conversationEntity, messageEntity, padding = 30) {
    const messageDate = new Date(messageEntity.timestamp());
    const conversationId = conversationEntity.id;

    conversationEntity.is_pending(true);

    return this.eventService
      .loadPrecedingEvents(conversationId, new Date(0), messageDate, Math.floor(padding / 2))
      .then(precedingMessages => {
        return this.eventService
          .loadFollowingEvents(conversationEntity.id, messageDate, padding - precedingMessages.length)
          .then(followingMessages => precedingMessages.concat(followingMessages));
      })
      .then(messages => this._addEventsToConversation(messages, conversationEntity))
      .then(mappedMessageEntities => {
        conversationEntity.is_pending(false);
        return mappedMessageEntities;
      });
  }

  /**
   * Get subsequent messages starting with the given message.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Message} messageEntity - Message entity
   * @param {boolean} includeMessage - Include given message in the results
   * @returns {Promise} Resolves with the messages
   */
  getSubsequentMessages(conversationEntity, messageEntity, includeMessage) {
    const messageDate = new Date(messageEntity.timestamp());
    conversationEntity.is_pending(true);

    return this.eventService
      .loadFollowingEvents(conversationEntity.id, messageDate, z.config.MESSAGES_FETCH_LIMIT, includeMessage)
      .then(events => this._addEventsToConversation(events, conversationEntity))
      .then(mappedNessageEntities => {
        conversationEntity.is_pending(false);
        return mappedNessageEntities;
      });
  }

  /**
   * Get messages for given category. Category param acts as lower bound.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {MessageCategory} [category=z.message.MessageCategory.NONE] - Message category
   * @returns {Promise} Array of message entities
   */
  get_events_for_category(conversationEntity, category = z.message.MessageCategory.NONE) {
    return this.eventService
      .loadEventsWithCategory(conversationEntity.id, category)
      .then(events => this.event_mapper.mapJsonEvents(events, conversationEntity))
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities));
  }

  /**
   * Search for given text in conversation.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {string} query - Query strings
   * @returns {Promise} Array of message entities
   */
  searchInConversation(conversationEntity, query) {
    if (!conversationEntity || !query.length) {
      return Promise.resolve({});
    }

    return this.conversation_service
      .search_in_conversation(conversationEntity.id, query)
      .then(events => this.event_mapper.mapJsonEvents(events, conversationEntity))
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities))
      .then(messageEntities => ({messageEntities, query}));
  }

  /**
   * Get conversation unread events.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation to start from
   * @returns {undefined} No return value
   */
  _get_unread_events(conversation_et) {
    const first_message = conversation_et.getFirstMessage();
    const lower_bound = new Date(conversation_et.last_read_timestamp());
    const upper_bound = first_message
      ? new Date(first_message.timestamp())
      : new Date(conversation_et.get_latest_timestamp(this.serverTimeRepository.toServerTimestamp()) + 1);

    if (lower_bound < upper_bound) {
      conversation_et.is_pending(true);

      return this.eventService
        .loadPrecedingEvents(conversation_et.id, lower_bound, upper_bound)
        .then(events => {
          if (events.length) {
            this._addEventsToConversation(events, conversation_et);
          }
          conversation_et.is_pending(false);
        })
        .catch(error => {
          this.logger.info(`Could not load unread events for conversation: ${conversation_et.id}`, error);
        });
    }
  }

  /**
   * Update conversation with a user you just unblocked
   * @param {User} user_et - User you unblocked
   * @returns {undefined} No return value
   */
  unblocked_user(user_et) {
    this.get1To1Conversation(user_et).then(conversation_et =>
      conversation_et.status(z.conversation.ConversationStatus.CURRENT_MEMBER)
    );
  }

  /**
   * Update all conversations on app init.
   * @returns {undefined} No return value
   */
  updateConversationsOnAppInit() {
    this.logger.info('Updating group participants');
    this.updateUnarchivedConversations();
    this.sorted_conversations().map(conversationEntity => {
      this.updateParticipatingUserEntities(conversationEntity, true);
    });
  }

  /**
   * Update users and events for archived conversations currently visible.
   * @returns {undefined} No return value
   */
  updateArchivedConversations() {
    this.updateConversations(this.conversations_archived());
  }

  /**
   * Update users and events for all unarchived conversations.
   * @returns {undefined} No return value
   */
  updateUnarchivedConversations() {
    this.updateConversations(this.conversations_unarchived());
  }

  updateConversationFromBackend(conversationEntity) {
    return this.conversation_service.get_conversation_by_id(conversationEntity.id).then(conversationData => {
      const {name, message_timer} = conversationData;
      this.conversationMapper.updateProperties(conversationEntity, {name});
      this.conversationMapper.updateSelfStatus(conversationEntity, {message_timer});
    });
  }

  /**
   * Get users and events for conversations.
   *
   * @note To reduce the number of backend calls we merge the user IDs of all conversations first.
   * @param {Array<Conversation>} conversationEntities - Array of conversation entities to be updated
   * @returns {undefined} No return value
   */
  updateConversations(conversationEntities) {
    const mapOfUserIds = conversationEntities.map(conversationEntity => conversationEntity.participating_user_ids());
    const userIds = _.flatten(mapOfUserIds);

    this.user_repository
      .get_users_by_id(userIds)
      .then(() => conversationEntities.forEach(conversationEntity => this._fetch_users_and_events(conversationEntity)));
  }

  //##############################################################################
  // Repository interactions
  //##############################################################################

  /**
   * Deletes a conversation from the repository.
   * @param {string} conversation_id - ID of conversation to be deleted from the repository
   * @returns {undefined} No return value
   */
  delete_conversation(conversation_id) {
    this.conversations.remove(conversation_et => conversation_et.id === conversation_id);
  }

  /**
   * Find a local conversation by ID.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the conversation entity
   */
  find_conversation_by_id(conversation_id) {
    return Promise.resolve().then(() => {
      if (!conversation_id) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CONVERSATION_ID);
      }

      const conversation_et = this._find_conversation_by_id(conversation_id);
      if (conversation_et) {
        return conversation_et;
      }

      throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
    });
  }

  /**
   * Check for conversation locally.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Conversation} Conversation is locally available
   */
  _find_conversation_by_id(conversation_id) {
    return this.conversations().find(conversation => conversation.id === conversation_id);
  }

  get_all_users_in_conversation(conversation_id) {
    return this.get_conversation_by_id(conversation_id).then(conversation_et =>
      [this.selfUser()].concat(conversation_et.participating_user_ets())
    );
  }

  /**
   * Check for conversation locally and fetch it from the server otherwise.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the Conversation entity
   */
  get_conversation_by_id(conversation_id) {
    if (!_.isString(conversation_id)) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CONVERSATION_ID));
    }

    return this.find_conversation_by_id(conversation_id)
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (isConversationNotFound) {
          return this.fetch_conversation_by_id(conversation_id);
        }

        throw error;
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          this.logger.error(`Failed to get conversation '${conversation_id}': ${error.message}`, error);
        }

        throw error;
      });
  }

  /**
   * Get group conversations by name.
   *
   * @param {string} query - Query to be searched in group conversation names
   * @param {boolean} isHandle - Query string is handle
   * @returns {Array<Conversation>} Matching group conversations
   */
  getGroupsByName(query, isHandle) {
    return this.sorted_conversations()
      .filter(conversationEntity => {
        if (!conversationEntity.isGroup()) {
          return false;
        }

        const queryString = isHandle ? `@${query}` : query;
        if (z.util.StringUtil.compareTransliteration(conversationEntity.display_name(), queryString)) {
          return true;
        }

        for (const userEntity of conversationEntity.participating_user_ets()) {
          const nameString = isHandle ? userEntity.username() : userEntity.name();
          if (z.util.StringUtil.startsWith(nameString, query)) {
            return true;
          }
        }

        return false;
      })
      .sort((conversationA, conversationB) => {
        return z.util.StringUtil.sortByPriority(conversationA.display_name(), conversationB.display_name(), query);
      })
      .map(conversationEntity => {
        this.updateParticipatingUserEntities(conversationEntity);
        return conversationEntity;
      });
  }

  /**
   * Get the most recent event timestamp from any conversation.
   * @param {boolean} [increment=false] - Increment by one for unique timestamp
   * @returns {number} Timestamp value
   */
  getLatestEventTimestamp(increment = false) {
    const mostRecentConversation = this.getMostRecentConversation(true);
    if (mostRecentConversation) {
      const lastEventTimestamp = mostRecentConversation.last_event_timestamp();
      return lastEventTimestamp + (increment ? 1 : 0);
    }

    return 1;
  }

  /**
   * Get the next unarchived conversation.
   *
   * @param {Conversation} conversation_et - Conversation to start from
   * @returns {Conversation} Next conversation
   */
  get_next_conversation(conversation_et) {
    return z.util.ArrayUtil.getNextItem(this.conversations_unarchived(), conversation_et);
  }

  /**
   * Get unarchived conversation with the most recent event.
   * @param {boolean} [allConversations=false] - Search all conversations
   * @returns {Conversation} Most recent conversation
   */
  getMostRecentConversation(allConversations = false) {
    const [conversation_et] = allConversations ? this.sorted_conversations() : this.conversations_unarchived();
    return conversation_et;
  }

  /**
   * Returns a list of sorted conversation ids based on the number of messages in the last 30 days.
   * @returns {Promise} Resolve with the most active conversations
   */
  get_most_active_conversations() {
    return this.conversation_service.get_active_conversations_from_db().then(conversation_ids => {
      return conversation_ids
        .map(conversation_id => this._find_conversation_by_id(conversation_id))
        .filter(conversation_et => conversation_et);
    });
  }

  /**
   * Get conversation with a user.
   * @param {User} userEntity - User entity for whom to get the conversation
   * @returns {Promise} Resolves with the conversation with requested user
   */
  get1To1Conversation(userEntity) {
    const inCurrentTeam = userEntity.inTeam() && userEntity.isTeamMember();

    if (inCurrentTeam) {
      const matchingConversationEntity = this.conversations().find(conversationEntity => {
        if (!conversationEntity.is1to1()) {
          // Disregard conversations that are not 1:1
          return false;
        }

        const inTeam = userEntity.teamId === conversationEntity.team_id;
        if (!inTeam) {
          // Disregard conversations that are not in the team
          return false;
        }

        const isActiveConversation = !conversationEntity.removed_from_conversation();
        if (!isActiveConversation) {
          // Disregard coversations that self is no longer part of
          return false;
        }

        const [userId] = conversationEntity.participating_user_ids();
        return userEntity.id === userId;
      });

      return matchingConversationEntity
        ? Promise.resolve(matchingConversationEntity)
        : this.createGroupConversation([userEntity]);
    }

    const conversationId = userEntity.connection().conversationId;
    return this.get_conversation_by_id(conversationId)
      .then(conversationEntity => {
        conversationEntity.connection(userEntity.connection());
        return this.updateParticipatingUserEntities(conversationEntity);
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }
      });
  }

  /**
   * Check whether conversation is currently displayed.
   * @param {Conversation} conversation_et - Conversation to be saved
   * @returns {boolean} Is the conversation active
   */
  is_active_conversation(conversation_et) {
    if (this.active_conversation()) {
      return this.active_conversation().id === conversation_et.id;
    }
  }

  /**
   * Check whether message has been read.
   *
   * @param {string} conversation_id - Conversation ID
   * @param {string} message_id - Message ID
   * @returns {Promise} Resolves with true if message is marked as read
   */
  is_message_read(conversation_id, message_id) {
    if (!conversation_id || !message_id) {
      return Promise.resolve(false);
    }

    return this.get_conversation_by_id(conversation_id)
      .then(conversation_et => {
        return this.get_message_in_conversation_by_id(conversation_et, message_id).then(
          message_et => conversation_et.last_read_timestamp() >= message_et.timestamp()
        );
      })
      .catch(error => {
        const messageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (messageNotFound) {
          return true;
        }

        throw error;
      });
  }

  initialize_conversations() {
    this._initStateUpdates();
    this.init_total = this.receiving_queue.getLength();

    if (this.init_total > 5) {
      this.logger.log(`Handling '${this.init_total}' additional messages on app start`);
      return new Promise((resolve, reject) => (this.init_promise = {reject_fn: reject, resolve_fn: resolve}));
    }
  }

  joinConversationWithCode(key, code) {
    return this.conversation_service.postConversationJoin(key, code).then(response => {
      if (response) {
        return this._onCreate(response);
      }
    });
  }

  /**
   * Maps user connection to the corresponding conversation.
   *
   * @note If there is no conversation it will request it from the backend
   * @param {z.connection.ConnectionEntity} connectionEntity - Connections
   * @param {boolean} [show_conversation=false] - Open the new conversation
   * @returns {Promise} Resolves when connection was mapped return value
   */
  map_connection(connectionEntity, show_conversation = false) {
    return this.find_conversation_by_id(connectionEntity.conversationId)
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }

        if (connectionEntity.isConnected() || connectionEntity.isOutgoingRequest()) {
          return this.fetch_conversation_by_id(connectionEntity.conversationId);
        }

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      })
      .then(conversation_et => {
        conversation_et.connection(connectionEntity);

        if (connectionEntity.isConnected()) {
          conversation_et.type(z.conversation.ConversationType.ONE2ONE);
        }

        this.updateParticipatingUserEntities(conversation_et).then(updated_conversation_et => {
          if (show_conversation) {
            amplify.publish(z.event.WebApp.CONVERSATION.SHOW, updated_conversation_et);
          }

          this.conversations.notifySubscribers();
        });

        return conversation_et;
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }
      });
  }

  /**
   * Maps user connections to the corresponding conversations.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connections entities
   * @returns {undefined} No return value
   */
  map_connections(connectionEntities) {
    this.logger.info(`Mapping '${connectionEntities.length}' user connection(s) to conversations`, connectionEntities);
    connectionEntities.map(connectionEntity => this.map_connection(connectionEntity));
  }

  /**
   * Map conversation payload.
   *
   * @param {JSON} payload - Payload to map
   * @param {number} [initialTimestamp=this.getLatestEventTimestamp()] - Initial server and event timestamp
   * @returns {z.entity.Conversation|Array<z.entity.Conversation>} Mapped conversation/s
   */
  mapConversations(payload, initialTimestamp = this.getLatestEventTimestamp()) {
    const conversationsData = payload.length ? payload : [payload];

    const entitites = this.conversationMapper.mapConversations(conversationsData, initialTimestamp);
    entitites.forEach(conversationEntity => {
      this._mapGuestStatusSelf(conversationEntity);
      conversationEntity.selfUser(this.selfUser());
      conversationEntity.setStateChangePersistence(true);
    });

    return payload.length ? entitites : entitites[0];
  }

  map_guest_status_self() {
    this.filtered_conversations().forEach(conversation_et => this._mapGuestStatusSelf(conversation_et));

    if (this.isTeam()) {
      this.selfUser().inTeam(true);
      this.selfUser().isTeamMember(true);
    }
  }

  _mapGuestStatusSelf(conversationEntity) {
    const conversationTeamId = conversationEntity.team_id;
    const selfTeamId = this.team() && this.team().id;
    const isConversationGuest = !!(conversationTeamId && (!selfTeamId || selfTeamId !== conversationTeamId));
    conversationEntity.isGuest(isConversationGuest);
  }

  /**
   * Mark conversation as read.
   * @param {Conversation} conversationEntity - Conversation to be marked as read
   * @returns {undefined} No return value
   */
  markAsRead(conversationEntity) {
    if (conversationEntity) {
      const hasUnreadEvents = conversationEntity.last_read_timestamp() < conversationEntity.last_server_timestamp();
      const isNotMarkedAsRead = hasUnreadEvents || conversationEntity.unreadState().allEvents.length;
      if (isNotMarkedAsRead && !this.block_event_handling()) {
        this._updateLastReadTimestamp(conversationEntity);
        amplify.publish(z.event.WebApp.NOTIFICATION.REMOVE_READ);
      }
    }
  }

  /**
   * Save a conversation in the repository.
   * @param {Conversation} conversation_et - Conversation to be saved in the repository
   * @returns {Promise} Resolves when conversation was saved
   */
  save_conversation(conversation_et) {
    return this.find_conversation_by_id(conversation_et.id).catch(error => {
      const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
      if (isConversationNotFound) {
        this.conversations.push(conversation_et);
        return this.save_conversation_state_in_db(conversation_et);
      }

      throw error;
    });
  }

  /**
   * Persists a conversation state in the database.
   * @param {Conversation} conversation_et - Conversation of which the state should be persisted
   * @returns {Promise} Resolves when conversation was saved
   */
  save_conversation_state_in_db(conversation_et) {
    return this.conversation_service.save_conversation_state_in_db(conversation_et);
  }

  /**
   * Save conversations in the repository.
   * @param {Array<Conversation>} conversation_ets - Conversations to be saved in the repository
   * @returns {undefined} No return value
   */
  save_conversations(conversation_ets) {
    z.util.koArrayPushAll(this.conversations, conversation_ets);
  }

  /**
   * Set the notification handling state.
   *
   * @note Temporarily do not unarchive conversations when handling the notification stream
   * @param {z.event.NOTIFICATION_HANDLING_STATE} handling_state - State of the notifications stream handling
   * @returns {undefined} No return value
   */
  set_notification_handling_state(handling_state) {
    const updated_handling_state = handling_state !== z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    if (this.block_event_handling() !== updated_handling_state) {
      this.block_event_handling(updated_handling_state);
      this.sending_queue.pause(this.block_event_handling());
      this.logger.info(`Block handling of conversation events: ${this.block_event_handling()}`);
    }
  }

  /**
   * Update participating users in a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {boolean} [offline=false] - Should we only look for cached contacts
   * @param {boolean} [updateGuests=false] - Update conversation guests
   * @returns {Promise} Resolves when users have been updated
   */
  updateParticipatingUserEntities(conversationEntity, offline = false, updateGuests = false) {
    return this.user_repository
      .get_users_by_id(conversationEntity.participating_user_ids(), offline)
      .then(userEntities => {
        userEntities.sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
        conversationEntity.participating_user_ets(userEntities);

        if (updateGuests) {
          conversationEntity.updateGuests();
        }

        return conversationEntity;
      });
  }

  //##############################################################################
  // Send events
  //##############################################################################

  /**
   * Add users to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add users to
   * @param {Array<z.entity.User>} userEntities - Users to be added to the conversation
   * @returns {Promise} Resolves when members were added
   */
  addMembers(conversationEntity, userEntities) {
    const userIds = userEntities.map(userEntity => userEntity.id);

    return this.conversation_service
      .postMembers(conversationEntity.id, userIds)
      .then(response => {
        if (response) {
          this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        }
      })
      .catch(error => this._handleAddToConversationError(error, conversationEntity, userIds));
  }

  addMissingMember(conversationId, userIds, timestamp) {
    return this.get_conversation_by_id(conversationId).then(conversationEntity => {
      const [sender] = userIds;
      const event = z.conversation.EventBuilder.buildMemberJoin(conversationEntity, sender, userIds, timestamp);
      return this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.INJECTED);
    });
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add service to
   * @param {string} providerId - ID of service provider
   * @param {string} serviceId - ID of service
   * @returns {Promise} Resolves when service was added
   */
  addService(conversationEntity, providerId, serviceId) {
    return this.conversation_service
      .postBots(conversationEntity.id, providerId, serviceId)
      .then(response => {
        const event = response ? response.event : undefined;
        if (event) {
          const logMessage = `Successfully added service to conversation '${conversationEntity.display_name()}'`;
          this.logger.debug(logMessage, response);
          return this.eventRepository.injectEvent(response.event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        }

        return event;
      })
      .catch(error => this._handleAddToConversationError(error, conversationEntity, [serviceId]));
  }

  _handleAddToConversationError(error, conversationEntity, userIds) {
    switch (error.label) {
      case z.error.BackendClientError.LABEL.NOT_CONNECTED: {
        this._handleUsersNotConnected(userIds);
        break;
      }

      case z.error.BackendClientError.LABEL.BAD_GATEWAY:
      case z.error.BackendClientError.LABEL.SERVER_ERROR:
      case z.error.BackendClientError.LABEL.SERVICE_DISABLED:
      case z.error.BackendClientError.LABEL.TOO_MANY_BOTS: {
        const messageText = z.l10n.text(z.string.modalServiceUnavailableMessage);
        const titleText = z.l10n.text(z.string.modalServiceUnavailableHeadline);

        this._showModal(messageText, titleText);
        break;
      }

      case z.error.BackendClientError.LABEL.TOO_MANY_MEMBERS: {
        this._handleTooManyMembersError(conversationEntity.getNumberOfParticipants());
        break;
      }

      default: {
        throw error;
      }
    }
  }

  /**
   * Clear conversation content and archive the conversation.
   *
   * @note According to spec we archive a conversation when we clear it.
   * It will be unarchived once it is opened through search. We use the archive flag to distinguish states.
   *
   * @param {Conversation} conversation_et - Conversation to clear
   * @param {boolean} [leave_conversation=false] - Should we leave the conversation before clearing the content?
   * @returns {undefined} No return value
   */
  clear_conversation(conversation_et, leave_conversation = false) {
    const is_active_conversation = this.is_active_conversation(conversation_et);
    const next_conversation_et = this.get_next_conversation(conversation_et);

    if (leave_conversation) {
      conversation_et.status(z.conversation.ConversationStatus.PAST_MEMBER);
    }

    this._updateClearedTimestamp(conversation_et);
    this._clear_conversation(conversation_et);

    if (leave_conversation) {
      this.removeMember(conversation_et, this.selfUser().id);
    }

    if (is_active_conversation) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, next_conversation_et);
    }
  }

  /**
   * Update cleared of conversation using timestamp.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to update
   * @returns {undefined} No return value
   */
  _updateClearedTimestamp(conversationEntity) {
    const timestamp = conversationEntity.get_last_known_timestamp(this.serverTimeRepository.toServerTimestamp());

    if (timestamp && conversationEntity.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.CLEARED)) {
      const protoCleared = new z.proto.Cleared(conversationEntity.id, timestamp);
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CLEARED, protoCleared);

      const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
      this.sendGenericMessageToConversation(eventInfoEntity).then(() => {
        this.logger.info(`Cleared conversation '${conversationEntity.id}' on '${new Date(timestamp).toISOString()}'`);
      });
    }
  }

  leaveGuestRoom() {
    if (this.selfUser().isTemporaryGuest()) {
      const conversationEntity = this.getMostRecentConversation(true);
      return this.conversation_service.deleteMembers(conversationEntity.id, this.selfUser().id);
    }
  }

  /**
   * Remove member from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove member from
   * @param {string} userId - ID of member to be removed from the conversation
   * @returns {Promise} Resolves when member was removed from the conversation
   */
  removeMember(conversationEntity, userId) {
    return this.conversation_service.deleteMembers(conversationEntity.id, userId).then(response => {
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = !!response
        ? response
        : z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, true, currentTimestamp);

      this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
      return event;
    });
  }

  /**
   * Remove service from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove service from
   * @param {z.entity.User} userId - ID of service user to be removed from the conversation
   * @returns {Promise} Resolves when service was removed from the conversation
   */
  removeService(conversationEntity, userId) {
    return this.conversation_service.deleteBots(conversationEntity.id, userId).then(response => {
      const hasResponse = response && response.event;
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = hasResponse
        ? response.event
        : z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, true, currentTimestamp);

      this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
      return event;
    });
  }

  /**
   * Rename conversation.
   *
   * @param {Conversation} conversation_et - Conversation to rename
   * @param {string} name - New conversation name
   * @returns {Promise} Resolves when conversation was renamed
   */
  renameConversation(conversation_et, name) {
    return this.conversation_service.updateConversationName(conversation_et.id, name).then(response => {
      if (response) {
        this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        return response;
      }
    });
  }

  /**
   * Set the global message timer
   *
   * @param {Conversation} conversationEntity - Conversation to update
   * @param {number} messageTimer - New message timer value
   * @returns {Promise} Resolves when conversation was updated on server side
   */
  updateConversationMessageTimer(conversationEntity, messageTimer) {
    messageTimer = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    return this.conversation_service
      .updateConversationMessageTimer(conversationEntity.id, messageTimer)
      .then(response => {
        if (response) {
          this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
          return response;
        }
      });
  }

  reset_session(user_id, client_id, conversation_id) {
    this.logger.info(`Resetting session with client '${client_id}' of user '${user_id}'.`);

    return this.cryptography_repository
      .deleteSession(user_id, client_id)
      .then(session_id => {
        if (session_id) {
          this.logger.info(`Deleted session with client '${client_id}' of user '${user_id}'.`);
        } else {
          this.logger.warn('No local session found to delete.');
        }

        return this.sendSessionReset(user_id, client_id, conversation_id);
      })
      .catch(error => {
        const logMessage = `Failed to reset session for client '${client_id}' of user '${user_id}': ${error.message}`;
        this.logger.warn(logMessage, error);
        throw error;
      });
  }

  /**
   * Send a specific GIF to a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to send message in
   * @param {string} url - URL of giphy image
   * @param {string} tag - tag tag used for gif search
   * @returns {Promise} Resolves when the gif was posted
   */
  sendGif(conversationEntity, url, tag) {
    if (!tag) {
      tag = z.l10n.text(z.string.extensionsGiphyRandom);
    }

    return z.util.loadUrlBlob(url).then(blob => {
      const textMessage = z.l10n.text(z.string.extensionsGiphyMessage, tag);
      this.sendText(conversationEntity, textMessage);
      return this.upload_images(conversationEntity, [blob]);
    });
  }

  /**
   * Team member was removed.
   * @param {string} teamId - ID of team that member was removed from
   * @param {string} userId - ID of leaving user
   * @param {Date} isoDate - Date of member removal
   * @returns {undefined} No return value
   */
  teamMemberLeave(teamId, userId, isoDate) {
    this.user_repository.get_user_by_id(userId).then(userEntity => {
      this.conversations()
        .filter(conversationEntity => {
          const conversationInTeam = conversationEntity.team_id === teamId;
          const userIsParticipant = conversationEntity.participating_user_ids().includes(userId);
          return conversationInTeam && userIsParticipant && !conversationEntity.removed_from_conversation();
        })
        .forEach(conversationEntity => {
          const leaveEvent = z.conversation.EventBuilder.buildTeamMemberLeave(conversationEntity, userEntity, isoDate);
          this.eventRepository.injectEvent(leaveEvent);
        });
    });
  }

  /**
   * Set the notification state of a conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to change notification state off
   * @param {z.conversation.NotificationSetting} notificationState - New notification state
   * @returns {Promise} Resolves when the notification stated was change
   */
  setNotificationState(conversationEntity, notificationState) {
    if (!conversationEntity || notificationState === undefined) {
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const validNotificationStates = Object.values(z.conversation.NotificationSetting.STATE);
    if (!validNotificationStates.includes(notificationState)) {
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER));
    }

    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const otrMuted = notificationState !== z.conversation.NotificationSetting.STATE.EVERYTHING;
    const payload = {
      otr_muted: otrMuted,
      otr_muted_ref: new Date(conversationEntity.get_last_known_timestamp(currentTimestamp)).toISOString(),
      otr_muted_status: notificationState,
    };

    return this.conversation_service
      .update_member_properties(conversationEntity.id, payload)
      .then(() => {
        const response = {data: payload, from: this.selfUser().id};
        this._onMemberUpdate(conversationEntity, response);

        const {otr_muted: muted, otr_muted_ref: mutedRef, otr_muted_status: mutedStatus} = payload;
        const logMessage = `Changed notification state of conversation to '${muted} | ${mutedStatus}' on '${mutedRef}'`;
        this.logger.info(logMessage);
        return response;
      })
      .catch(error => {
        const log = `Failed to change notification state of conversation '${conversationEntity.id}': ${error.message}`;
        const rejectError = new Error(log);
        this.logger.warn(rejectError.message, error);
        throw rejectError;
      });
  }

  /**
   * Archive a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to rename
   * @returns {Promise} Resolves when the conversation was archived
   */
  archiveConversation(conversationEntity) {
    return this._toggleArchiveConversation(conversationEntity, true).then(() => {
      this.logger.info(`Conversation '${conversationEntity.id}' archived`);
    });
  }

  /**
   * Un-archive a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to unarchive
   * @param {boolean} [forceChange=false] - Force state change without new message
   * @param {string} trigger - Trigger for unarchive
   * @returns {Promise} Resolves when the conversation was unarchived
   */
  unarchiveConversation(conversationEntity, forceChange = false, trigger = 'unknown') {
    return this._toggleArchiveConversation(conversationEntity, false, forceChange).then(() => {
      this.logger.info(`Conversation '${conversationEntity.id}' unarchived by trigger '${trigger}'`);
    });
  }

  _toggleArchiveConversation(conversationEntity, newState, forceChange) {
    if (!conversationEntity) {
      const error = new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      return Promise.reject(error);
    }

    const stateChange = conversationEntity.is_archived() !== newState;

    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const archiveTimestamp = conversationEntity.get_last_known_timestamp(currentTimestamp);
    const sameTimestamp = conversationEntity.archivedTimestamp() === archiveTimestamp;
    const skipChange = sameTimestamp && !forceChange;

    if (!stateChange && skipChange) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES));
    }

    const payload = {
      otr_archived: newState,
      otr_archived_ref: new Date(archiveTimestamp).toISOString(),
    };

    const conversationId = conversationEntity.id;

    const updatePromise = conversationEntity.removed_from_conversation()
      ? Promise.resolve()
      : this.conversation_service.update_member_properties(conversationId, payload).catch(error => {
          const logMessage = `Failed to change archived state of '${conversationId}' to '${newState}': ${error.code}`;
          this.logger.error(logMessage);

          const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (!isNotFound) {
            throw error;
          }
        });

    return updatePromise.then(() => {
      const response = {
        data: payload,
        from: this.selfUser().id,
      };

      this._onMemberUpdate(conversationEntity, response);
    });
  }

  _checkChangedConversations() {
    this.conversationsWithNewEvents.forEach(conversationEntity => {
      if (conversationEntity.shouldUnarchive()) {
        this.unarchiveConversation(conversationEntity, false, 'event from notification stream');
      }
    });

    this.conversationsWithNewEvents.clear();
  }

  /**
   * Clears conversation content from view and the database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation entity to delete
   * @param {number} [timestamp] - Optional timestamps for which messages to remove
   * @returns {undefined} No return value
   */
  _clear_conversation(conversation_et, timestamp) {
    this._deleteMessages(conversation_et, timestamp);

    if (conversation_et.removed_from_conversation()) {
      this.conversation_service.delete_conversation_from_db(conversation_et.id);
      this.delete_conversation(conversation_et.id);
    }
  }

  _handleConversationCreateError(error, userIds) {
    switch (error.label) {
      case z.error.BackendClientError.LABEL.CLIENT_ERROR:
        this._handleTooManyMembersError();
        break;
      case z.error.BackendClientError.LABEL.NOT_CONNECTED:
        this._handleUsersNotConnected(userIds);
        break;
      default:
        throw error;
    }
  }

  _handleTooManyMembersError(participants = ConversationRepository.CONFIG.GROUP.MAX_SIZE) {
    const openSpots = ConversationRepository.CONFIG.GROUP.MAX_SIZE - participants;
    const substitutions = {number1: ConversationRepository.CONFIG.GROUP.MAX_SIZE, number2: Math.max(0, openSpots)};

    const messageText = z.l10n.text(z.string.modalConversationTooManyMembersMessage, substitutions);
    const titleText = z.l10n.text(z.string.modalConversationTooManyMembersHeadline);
    this._showModal(messageText, titleText);
  }

  _handleUsersNotConnected(userIds = []) {
    const [userID] = userIds;
    const userPromise = userIds.length === 1 ? this.user_repository.get_user_by_id(userID) : Promise.resolve();

    userPromise.then(userEntity => {
      const username = userEntity ? userEntity.first_name() : undefined;
      const messageStringId = username
        ? z.string.modalConversationNotConnectedMessageOne
        : z.string.modalConversationNotConnectedMessageMany;

      const messageText = z.l10n.text(messageStringId, username);
      const titleText = z.l10n.text(z.string.modalConversationNotConnectedHeadline);
      this._showModal(messageText, titleText);
    });
  }

  _showModal(messageText, titleText) {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: messageText,
        title: titleText,
      },
    });
  }

  /**
   * Update last read of conversation using timestamp.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to update
   * @returns {undefined} No return value
   */
  _updateLastReadTimestamp(conversationEntity) {
    const timestamp = conversationEntity.get_last_known_timestamp(this.serverTimeRepository.toServerTimestamp());
    const conversationId = conversationEntity.id;

    if (timestamp && conversationEntity.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ)) {
      const protoLeastRead = new z.proto.LastRead(conversationId, conversationEntity.last_read_timestamp());
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.LAST_READ, protoLeastRead);

      const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
      this.sendGenericMessageToConversation(eventInfoEntity)
        .then(() => {
          this.logger.info(`Marked conversation '${conversationId}' as read on '${new Date(timestamp).toISOString()}'`);
        })
        .catch(error => {
          const errorMessage = 'Failed to update last read timestamp';
          this.logger.error(`${errorMessage}: ${error.message}`, error);
          Raygun.send(new Error(errorMessage), {label: error.label, message: error.message});
        });
    }
  }

  //##############################################################################
  // Send encrypted events
  //##############################################################################

  send_asset_remotedata(conversationEntity, file, messageId) {
    let genericMessage;

    return this.get_message_in_conversation_by_id(conversationEntity, messageId)
      .then(messageEntity => {
        const assetEntity = messageEntity.get_first_asset();
        const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
        const options = {retention};

        assetEntity.uploaded_on_this_client(true);
        return this.asset_service.uploadAsset(file, options, xhr => {
          xhr.upload.onprogress = event => assetEntity.upload_progress(Math.round((event.loaded / event.total) * 100));
          assetEntity.upload_cancel = () => xhr.abort();
        });
      })
      .then(asset => {
        genericMessage = new z.proto.GenericMessage(messageId);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversationEntity.messageTimer()) {
          genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
        }

        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
        return this.sendGenericMessageToConversation(eventInfoEntity);
      })
      .then(payload => {
        const {uploaded: assetData} = conversationEntity.messageTimer()
          ? genericMessage.ephemeral.asset
          : genericMessage.asset;

        const data = {
          key: assetData.asset_id,
          otr_key: assetData.otr_key,
          sha256: assetData.sha256,
          token: assetData.asset_token,
        };

        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const assetAddEvent = z.conversation.EventBuilder.buildAssetAdd(conversationEntity, data, currentTimestamp);

        assetAddEvent.id = messageId;
        assetAddEvent.time = payload.time;

        return this._on_asset_upload_complete(conversationEntity, assetAddEvent);
      });
  }

  /**
   * Send asset metadata message to specified conversation.
   *
   * @param {Conversation} conversation_et - Conversation that should receive the file
   * @param {File} file - File to send
   * @returns {Promise} Resolves when the asset metadata was sent
   */
  send_asset_metadata(conversation_et, file) {
    return z.assets.AssetMetaDataBuilder.buildMetadata(file)
      .catch(error => {
        const logMessage = `Couldn't render asset preview from metadata. Asset might be corrupt: ${error.message}`;
        this.logger.warn(logMessage, error);
        return undefined;
      })
      .then(metadata => {
        const protoAsset = new z.proto.Asset();

        let assetOriginal = undefined;
        if (z.assets.AssetMetaDataBuilder.isAudio(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, null, null, metadata);
        } else if (z.assets.AssetMetaDataBuilder.isVideo(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, null, metadata);
        } else if (z.assets.AssetMetaDataBuilder.isImage(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, metadata);
        } else {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name);
        }
        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_ORIGINAL, assetOriginal);

        return protoAsset;
      })
      .then(asset => {
        let generic_message = new z.proto.GenericMessage(z.util.createRandomUuid());
        generic_message.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversation_et.messageTimer()) {
          generic_message = this._wrap_in_ephemeral_message(generic_message, conversation_et.messageTimer());
        }

        return this._send_and_inject_generic_message(conversation_et, generic_message);
      })
      .catch(error => {
        const log = `Failed to upload metadata for asset in conversation '${conversation_et.id}': ${error.message}`;
        this.logger.warn(log, error);

        if (error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }
      });
  }

  /**
   * Send asset preview message to specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the preview
   * @param {File} file - File to generate preview from
   * @param {string} messageId - Message ID of the message to generate a preview for
   * @returns {Promise} Resolves when the asset preview was sent
   */
  sendAssetPreview(conversationEntity, file, messageId) {
    return poster(file)
      .then(imageBlob => {
        if (!imageBlob) {
          throw Error('No image available');
        }

        const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
        const options = {retention};

        return this.asset_service.uploadAsset(imageBlob, options).then(uploadedImageAsset => {
          const protoAsset = new z.proto.Asset();
          const assetPreview = new z.proto.Asset.Preview(imageBlob.type, imageBlob.size, uploadedImageAsset.uploaded);
          protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_PREVIEW, assetPreview);

          const genericMessage = new z.proto.GenericMessage(messageId);
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, protoAsset);

          return this._send_and_inject_generic_message(conversationEntity, genericMessage, false);
        });
      })
      .catch(error => {
        const message = `No preview for asset '${messageId}' in conversation '${conversationEntity.id}' uploaded `;
        this.logger.warn(message, error);
      });
  }

  /**
   * Send asset upload failed message to specified conversation.
   *
   * @param {Conversation} conversation_et - Conversation that should receive the file
   * @param {string} messageId - ID of the metadata message
   * @param {z.assets.AssetUploadFailedReason} [reason=z.assets.AssetUploadFailedReason.FAILED] - Cause for the failed upload (optional)
   * @returns {Promise} Resolves when the asset failure was sent
   */
  send_asset_upload_failed(conversation_et, messageId, reason = z.assets.AssetUploadFailedReason.FAILED) {
    const wasCancelled = reason === z.assets.AssetUploadFailedReason.CANCELLED;
    const protoReason = wasCancelled ? z.proto.Asset.NotUploaded.CANCELLED : z.proto.Asset.NotUploaded.FAILED;
    const protoAsset = new z.proto.Asset();
    protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_NOT_UPLOADED, protoReason);

    const generic_message = new z.proto.GenericMessage(messageId);
    generic_message.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, protoAsset);

    return this._send_and_inject_generic_message(conversation_et, generic_message);
  }

  /**
   * Send confirmation for a content message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that content message was received in
   * @param {Message} messageEntity - Message for which to acknowledge receipt
   * @returns {undefined} No return value
   */
  sendConfirmationStatus(conversationEntity, messageEntity) {
    const otherUserIn1To1 = !messageEntity.user().is_me && conversationEntity.is1to1();
    const CONFIRMATION_THRESHOLD = ConversationRepository.CONFIG.CONFIRMATION_THRESHOLD;
    const withinThreshold = messageEntity.timestamp() >= Date.now() - CONFIRMATION_THRESHOLD;
    const typeToConfirm = z.event.EventTypeHandling.CONFIRM.includes(messageEntity.type);

    const sendConfirmation = otherUserIn1To1 && withinThreshold && typeToConfirm;
    if (sendConfirmation) {
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      const protoConfirmation = new z.proto.Confirmation(z.proto.Confirmation.Type.DELIVERED, messageEntity.id);
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CONFIRMATION, protoConfirmation);

      this.sending_queue.push(() => {
        return this.create_recipients(conversationEntity.id, true, [messageEntity.user().id]).then(recipients => {
          const options = {nativePush: false, precondition: [messageEntity.user().id], recipients};
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id, options);

          return this._sendGenericMessage(eventInfoEntity);
        });
      });
    }
  }

  /**
   * Send call message in specified conversation.
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event info to be send
   * @param {Conversation} conversationEntity - Conversation to send call message to
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Content for call message
   * @returns {Promise} Resolves when the confirmation was sent
   */
  sendCallingMessage(eventInfoEntity, conversationEntity, callMessageEntity) {
    return this.sending_queue
      .push(() => {
        const options = eventInfoEntity.options;
        const recipientsPromise = options.recipients
          ? Promise.resolve(eventInfoEntity)
          : this.create_recipients(conversationEntity.id, false).then(recipients => {
              eventInfoEntity.updateOptions({recipients});
              return eventInfoEntity;
            });

        return recipientsPromise.then(infoEntity => this._sendGenericMessage(infoEntity));
      })
      .then(() => {
        const initiatingCallMessage = [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
        ];

        const isCallInitiation = initiatingCallMessage.includes(callMessageEntity.type);
        if (isCallInitiation) {
          return this._trackContributed(conversationEntity, eventInfoEntity.genericMessage, callMessageEntity);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }

        amplify.publish(z.event.WebApp.CALL.STATE.DELETE, callMessageEntity.conversationId);
      });
  }

  /**
   * Sends image asset in specified conversation using v3 api.
   *
   * @param {Conversation} conversationEntity - Conversation to send image in
   * @param {File|Blob} image - Image
   * @returns {Promise} Resolves when the image was sent
   */
  send_image_asset(conversationEntity, image) {
    const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
    const options = {retention};

    return this.asset_service
      .uploadImageAsset(image, options)
      .then(asset => {
        let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversationEntity.messageTimer()) {
          genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
        }

        return this._send_and_inject_generic_message(conversationEntity, genericMessage);
      })
      .catch(error => {
        const message = `Failed to upload otr asset for conversation ${conversationEntity.id}: ${error.message}`;
        this.logger.error(message, error);
        throw error;
      });
  }

  /**
   * Send knock in specified conversation.
   * @param {Conversation} conversationEntity - Conversation to send knock in
   * @returns {Promise} Resolves after sending the knock
   */
  sendKnock(conversationEntity) {
    let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoKnock = new z.proto.Knock(false);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.KNOCK, protoKnock);

    if (conversationEntity.messageTimer()) {
      genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
    }

    return this._send_and_inject_generic_message(conversationEntity, genericMessage).catch(error => {
      if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
        this.logger.error(`Error while sending knock: ${error.message}`, error);
        throw error;
      }
    });
  }

  /**
   * Send link preview in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message that possibly contains link
   * @param {z.proto.GenericMessage} genericMessage - GenericMessage of containing text or edited message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of message
   * @returns {Promise} Resolves after sending the message
   */
  sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities) {
    const conversationId = conversationEntity.id;
    const messageId = genericMessage.message_id;

    return this.link_repository
      .getLinkPreviewFromString(textMessage)
      .then(linkPreview => {
        if (linkPreview) {
          const protoText = this._createTextProto(messageId, textMessage, mentionEntities, undefined, [linkPreview]);
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.TEXT, protoText);

          return this.get_message_in_conversation_by_id(conversationEntity, messageId);
        }

        this.logger.debug(`No link preview for message '${messageId}' in conversation '${conversationId}' created`);
      })
      .then(messageEntity => {
        if (messageEntity) {
          const assetEntity = messageEntity.get_first_asset();
          const messageContentUnchanged = assetEntity.text === textMessage;

          if (messageContentUnchanged) {
            this.logger.debug(`Sending link preview for message '${messageId}' in conversation '${conversationId}'`);
            return this._send_and_inject_generic_message(conversationEntity, genericMessage, false);
          }

          this.logger.debug(`Skipped sending link preview as message '${messageId}' in '${conversationId}' changed`);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          this.logger.warn(`Failed sending link preview for message '${messageId}' in '${conversationId}'`);
          throw error;
        }

        this.logger.warn(`Skipped link preview for unknown message '${messageId}' in '${conversationId}'`);
      });
  }

  /**
   * Send location message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {number} longitude - Longitude of the location
   * @param {number} latitude - Latitude of the location
   * @param {string} name - Name of the location
   * @param {number} zoom - Zoom factor for the map (Google Maps)
   * @returns {Promise} Resolves after sending the location
   */
  sendLocation(conversationEntity, longitude, latitude, name, zoom) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoLocation = new z.proto.Location(longitude, latitude, name, zoom);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.LOCATION, protoLocation);

    const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
    return this.sendGenericMessageToConversation(eventInfoEntity);
  }

  /**
   * Send edited message in specified conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation entity
   * @param {string} textMessage - Edited plain text message
   * @param {z.entity.Message} originalMessageEntity - Original message entity
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of the message
   * @returns {Promise} Resolves after sending the message
   */
  sendMessageEdit(conversationEntity, textMessage, originalMessageEntity, mentionEntities) {
    const hasDifferentText = z.util.MessageComparator.isTextDifferent(originalMessageEntity, textMessage);
    const hasDifferentMentions = z.util.MessageComparator.areMentionsDifferent(originalMessageEntity, mentionEntities);
    const wasEdited = hasDifferentText || hasDifferentMentions;

    if (!wasEdited) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_MESSAGE_CHANGES));
    }

    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoText = this._createTextProto(genericMessage.message_id, textMessage, mentionEntities);
    const protoMessageEdit = new z.proto.MessageEdit(originalMessageEntity.id, protoText);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.EDITED, protoMessageEdit);

    return this._send_and_inject_generic_message(conversationEntity, genericMessage, false)
      .then(() => {
        if (z.util.Environment.desktop) {
          return this.sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          this.logger.error(`Error while editing message: ${error.message}`, error);
          throw error;
        }
      });
  }

  /**
   * Toggle like status of message.
   *
   * @param {Conversation} conversation_et - Conversation entity
   * @param {Message} message_et - Message to react to
   * @param {boolean} button - Source of toggle
   * @returns {undefined} No return value
   */
  toggle_like(conversation_et, message_et, button) {
    if (!conversation_et.removed_from_conversation()) {
      const reaction = message_et.is_liked() ? z.message.ReactionType.NONE : z.message.ReactionType.LIKE;
      message_et.is_liked(!message_et.is_liked());

      window.setTimeout(() => this.sendReaction(conversation_et, message_et, reaction), 100);
    }
  }

  /**
   * Send reaction to a content message in specified conversation.
   * @param {Conversation} conversationEntity - Conversation to send reaction in
   * @param {Message} messageEntity - Message to react to
   * @param {z.message.ReactionType} reaction - Reaction
   * @returns {Promise} Resolves after sending the reaction
   */
  sendReaction(conversationEntity, messageEntity, reaction) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoReaction = new z.proto.Reaction(reaction, messageEntity.id);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.REACTION, protoReaction);

    return this._send_and_inject_generic_message(conversationEntity, genericMessage);
  }

  /**
   * Sending a message to the remote end of a session reset.
   *
   * @note When we reset a session then we must inform the remote client about this action. It sends a ProtocolBuffer message
   *  (which will not be rendered in the view) to the remote client. This message only needs to be sent to the affected
   *  remote client, therefore we force the message sending.
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @param {string} conversationId - Conversation ID
   * @returns {Promise} Resolves after sending the session reset
   */
  sendSessionReset(userId, clientId, conversationId) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CLIENT_ACTION, z.proto.ClientAction.RESET_SESSION);

    const options = {
      precondition: true,
      recipients: {[userId]: [clientId]},
    };
    const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationId, options);

    return this._sendGenericMessage(eventInfoEntity)
      .then(response => {
        this.logger.info(`Sent info about session reset to client '${clientId}' of user '${userId}'`);
        return response;
      })
      .catch(error => {
        this.logger.error(`Sending conversation reset failed: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Send text message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of the message
   * @param {z.message.QuoteEntity} [quoteEntity] - Quote as part of the message
   * @returns {Promise} Resolves after sending the message
   */
  sendText(conversationEntity, textMessage, mentionEntities, quoteEntity) {
    let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoText = this._createTextProto(genericMessage.message_id, textMessage, mentionEntities, quoteEntity);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.TEXT, protoText);

    if (conversationEntity.messageTimer()) {
      genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
    }

    return this._send_and_inject_generic_message(conversationEntity, genericMessage).then(() => genericMessage);
  }

  /**
   * Send text message with link preview in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions part of the message
   * @param {z.message.QuoteEntity} [quoteEntity] - Quoted message
   * @returns {Promise} Resolves after sending the message
   */
  sendTextWithLinkPreview(conversationEntity, textMessage, mentionEntities, quoteEntity) {
    return this.sendText(conversationEntity, textMessage, mentionEntities, quoteEntity)
      .then(genericMessage => {
        if (z.util.Environment.desktop) {
          return this.sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          this.logger.error(`Error while sending text message: ${error.message}`, error);
          throw error;
        }
      });
  }

  _createTextProto(messageId, textMessage, mentionEntities, quoteEntity, linkPreviews) {
    const protoText = new z.proto.Text(textMessage);

    if (mentionEntities && mentionEntities.length) {
      const logMessage = `Adding '${mentionEntities.length}' mentions to message '${messageId}'`;
      this.logger.debug(logMessage, mentionEntities);

      const protoMentions = mentionEntities
        .filter(mentionEntity => {
          if (mentionEntity) {
            try {
              return mentionEntity.validate(textMessage);
            } catch (error) {
              const log = `Removed invalid mention when sending message '${messageId}': ${error.message}`;
              this.logger.warn(log, mentionEntity);
              return false;
            }
          }
        })
        .map(mentionEntity => mentionEntity.toProto());
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.MENTIONS, protoMentions);
    }

    if (quoteEntity) {
      const protoQuote = quoteEntity.toProto();
      this.logger.debug(`Adding quote to message '${messageId}'`, protoQuote);
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.QUOTE, protoQuote);
    }

    if (linkPreviews && linkPreviews.length) {
      this.logger.debug(`Adding link preview to message '${messageId}'`, linkPreviews);
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEWS, linkPreviews);
    }

    return protoText;
  }

  /**
   * Wraps generic message in ephemeral message.
   *
   * @param {z.proto.GenericMessage} genericMessage - Message to be wrapped
   * @param {number} millis - Expire time in milliseconds
   * @returns {z.proto.Message} New proto message
   */
  _wrap_in_ephemeral_message(genericMessage, millis) {
    const protoEphemeral = new z.proto.Ephemeral();
    const ephemeralExpiration = z.conversation.ConversationEphemeralHandler.validateTimer(millis);

    protoEphemeral.set(z.cryptography.PROTO_MESSAGE_TYPE.EPHEMERAL_EXPIRATION, ephemeralExpiration);
    protoEphemeral.set(genericMessage.content, genericMessage[genericMessage.content]);

    genericMessage = new z.proto.GenericMessage(genericMessage.message_id);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL, protoEphemeral);
    return genericMessage;
  }

  //##############################################################################
  // Send Generic Messages
  //##############################################################################

  /**
   * Create a user client map for a given conversation.
   *
   * @param {string} conversation_id - Conversation ID
   * @param {boolean} [skip_own_clients=false] - True, if other own clients should be skipped (to not sync messages on own clients)
   * @param {Array<string>} user_ids - Optionally the intended recipient users
   * @returns {Promise} Resolves with a user client map
   */
  create_recipients(conversation_id, skip_own_clients = false, user_ids) {
    return this.get_all_users_in_conversation(conversation_id).then(user_ets => {
      const recipients = {};

      for (const user_et of user_ets) {
        if (!(skip_own_clients && user_et.is_me)) {
          if (user_ids && !user_ids.includes(user_et.id)) {
            continue;
          }

          recipients[user_et.id] = user_et.devices().map(client_et => client_et.id);
        }
      }

      return recipients;
    });
  }

  sendGenericMessageToConversation(eventInfoEntity) {
    return this.sending_queue.push(() => {
      return this.create_recipients(eventInfoEntity.conversationId).then(recipients => {
        eventInfoEntity.updateOptions({recipients});
        return this._sendGenericMessage(eventInfoEntity);
      });
    });
  }

  _send_and_inject_generic_message(conversationEntity, genericMessage, syncTimestamp = true) {
    return Promise.resolve()
      .then(() => {
        if (conversationEntity.removed_from_conversation()) {
          throw new Error('Cannot send message to conversation you are not part of');
        }

        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const optimisticEvent = z.conversation.EventBuilder.buildMessageAdd(conversationEntity, currentTimestamp);
        return this.cryptography_repository.cryptographyMapper.mapGenericMessage(genericMessage, optimisticEvent);
      })
      .then(mappedEvent => {
        const {KNOCK: TYPE_KNOCK, EPHEMERAL: TYPE_EPHEMERAL} = z.cryptography.GENERIC_MESSAGE_TYPE;
        const isPing = message => message.content === TYPE_KNOCK;
        const isEphemeralPing = message => message.content === TYPE_EPHEMERAL && isPing(message.ephemeral);
        const shouldPlayPingAudio = isPing(genericMessage) || isEphemeralPing(genericMessage);
        if (shouldPlayPingAudio) {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.OUTGOING_PING);
        }

        return mappedEvent;
      })
      .then(mappedEvent => this.eventRepository.injectEvent(mappedEvent))
      .then(injectedEvent => {
        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
        eventInfoEntity.setTimestamp(injectedEvent.time);
        return this.sendGenericMessageToConversation(eventInfoEntity).then(sentPayload => {
          return {event: injectedEvent, sentPayload};
        });
      })
      .then(({event, sentPayload}) => {
        this._trackContributed(conversationEntity, genericMessage);
        const backendIsoDate = syncTimestamp ? sentPayload.time : '';
        return this._updateMessageAsSent(conversationEntity, event, backendIsoDate).then(() => event);
      });
  }

  /**
   * Update message as sent in db and view.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Object} eventJson - Event object
   * @param {string} isoDate - If defined it will update event timestamp
   * @returns {Promise} Resolves when sent status was updated
   */
  _updateMessageAsSent(conversationEntity, eventJson, isoDate) {
    return this.get_message_in_conversation_by_id(conversationEntity, eventJson.id)
      .then(messageEntity => {
        messageEntity.status(z.message.StatusType.SENT);

        const changes = {status: z.message.StatusType.SENT};
        if (isoDate) {
          changes.time = isoDate;

          const timestamp = new Date(isoDate).getTime();
          if (!_.isNaN(timestamp)) {
            messageEntity.timestamp(timestamp);
            conversationEntity.update_timestamp_server(timestamp, true);
            conversationEntity.update_timestamps(messageEntity);
          }
        }

        this.checkMessageTimer(messageEntity);
        if (z.event.EventTypeHandling.STORE.includes(messageEntity.type) || messageEntity.has_asset_image()) {
          return this.eventService.updateEvent(messageEntity.primary_key, changes);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          throw error;
        }
      });
  }

  /**
   * Send encrypted external message
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event to be send
   * @returns {Promise} Resolves after sending the external message
   */
  _sendExternalGenericMessage(eventInfoEntity) {
    const {genericMessage, options} = eventInfoEntity;
    const messageType = eventInfoEntity.getType();
    this.logger.info(`Sending external message of type '${messageType}'`, genericMessage);

    return z.assets.AssetCrypto.encryptAesAsset(genericMessage.toArrayBuffer())
      .then(({cipherText, keyBytes, sha256}) => {
        const genericMessageExternal = new z.proto.GenericMessage(z.util.createRandomUuid());
        const externalMessage = new z.proto.External(new Uint8Array(keyBytes), new Uint8Array(sha256));
        genericMessageExternal.set(z.cryptography.GENERIC_MESSAGE_TYPE.EXTERNAL, externalMessage);

        return this.cryptography_repository
          .encryptGenericMessage(options.recipients, genericMessageExternal)
          .then(payload => {
            payload.data = z.util.arrayToBase64(cipherText);
            payload.native_push = options.nativePush;
            return this._sendEncryptedMessage(eventInfoEntity, payload);
          });
      })
      .catch(error => {
        this.logger.info('Failed sending external message', error);
        throw error;
      });
  }

  /**
   * Sends a generic message to a conversation.
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves when the message was sent
   */
  _sendGenericMessage(eventInfoEntity) {
    return this._grantOutgoingMessage(eventInfoEntity)
      .then(() => this._shouldSendAsExternal(eventInfoEntity))
      .then(sendAsExternal => {
        if (sendAsExternal) {
          return this._sendExternalGenericMessage(eventInfoEntity);
        }

        const {genericMessage, options} = eventInfoEntity;
        return this.cryptography_repository.encryptGenericMessage(options.recipients, genericMessage).then(payload => {
          payload.native_push = options.nativePush;
          return this._sendEncryptedMessage(eventInfoEntity, payload);
        });
      })
      .catch(error => {
        const isRequestTooLarge = error.code === z.error.BackendClientError.STATUS_CODE.REQUEST_TOO_LARGE;
        if (isRequestTooLarge) {
          return this._sendExternalGenericMessage(eventInfoEntity);
        }

        throw error;
      });
  }

  /**
   * Sends otr message to a conversation.
   *
   * @private
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about message to be sent
   * @param {Object} payload - Payload
   * @returns {Promise} Promise that resolves after sending the encrypted message
   */
  _sendEncryptedMessage(eventInfoEntity, payload) {
    const {conversationId, genericMessage, options} = eventInfoEntity;
    const messageId = genericMessage.message_id;
    const messageType = eventInfoEntity.getType();

    const logMessage = `Sending '${messageType}' message '${messageId}' to conversation '${conversationId}'`;
    this.logger.info(logMessage, payload);

    return this.conversation_service
      .post_encrypted_message(conversationId, payload, options.precondition)
      .then(response => {
        this.clientMismatchHandler.onClientMismatch(eventInfoEntity, response, payload);
        return response;
      })
      .catch(error => {
        const isUnknownClient = error.label === z.error.BackendClientError.LABEL.UNKNOWN_CLIENT;
        if (isUnknownClient) {
          return this.client_repository.removeLocalClient();
        }

        if (!error.missing) {
          throw error;
        }

        let updatedPayload;
        return this.clientMismatchHandler
          .onClientMismatch(eventInfoEntity, error, payload)
          .then(payloadWithMissingClients => {
            updatedPayload = payloadWithMissingClients;

            const userIds = Object.keys(error.missing);
            return this._grantOutgoingMessage(eventInfoEntity, userIds);
          })
          .then(() => {
            this.logger.info(`Updated '${messageType}' message for conversation '${conversationId}'`, updatedPayload);
            return this.conversation_service.post_encrypted_message(conversationId, updatedPayload, true);
          });
      });
  }

  _grantOutgoingMessage(eventInfoEntity, userIds) {
    const messageType = eventInfoEntity.getType();
    const allowedMessageTypes = ['cleared', 'confirmation', 'deleted', 'lastRead'];
    if (allowedMessageTypes.includes(messageType)) {
      return Promise.resolve();
    }

    const isCallingMessage = messageType === z.cryptography.GENERIC_MESSAGE_TYPE.CALLING;
    const consentType = isCallingMessage
      ? ConversationRepository.CONSENT_TYPE.OUTGOING_CALL
      : ConversationRepository.CONSENT_TYPE.MESSAGE;

    return this.grantMessage(eventInfoEntity, consentType, userIds);
  }

  grantMessage(eventInfoEntity, consentType, userIds) {
    return this.get_conversation_by_id(eventInfoEntity.conversationId).then(conversationEntity => {
      const verificationState = conversationEntity.verification_state();
      const conversationDegraded = verificationState === z.conversation.ConversationVerificationState.DEGRADED;

      if (!conversationDegraded) {
        return false;
      }

      return new Promise((resolve, reject) => {
        let sendAnyway = false;

        userIds = userIds || conversationEntity.getUsersWithUnverifiedClients().map(userEntity => userEntity.id);

        return this.user_repository
          .get_users_by_id(userIds)
          .then(userEntities => {
            let actionStringId;
            let messageStringId;
            let titleStringId;

            const hasMultipleUsers = userEntities.length > 1;
            if (hasMultipleUsers) {
              titleStringId = z.string.modalConversationNewDeviceHeadlineMany;
            } else {
              const [userEntity] = userEntities;

              if (userEntity) {
                titleStringId = userEntity.is_me
                  ? z.string.modalConversationNewDeviceHeadlineYou
                  : z.string.modalConversationNewDeviceHeadlineOne;
              } else {
                const conversationId = eventInfoEntity.conversationId;
                const type = eventInfoEntity.getType();

                const log = `Missing user IDs to grant '${type}' message in '${conversationId}' (${consentType})`;
                this.logger.error(log);

                const error = new Error('Failed to grant outgoing message');
                const customData = {
                  consentType,
                  messageType: type,
                  participants: conversationEntity.getNumberOfParticipants(false),
                  verificationState,
                };

                Raygun.send(error, customData);

                reject(error);
              }
            }

            const userNames = z.util.LocalizerUtil.joinNames(userEntities, z.string.Declension.NOMINATIVE);
            const titleSubstitutions = z.util.StringUtil.capitalizeFirstChar(userNames);

            switch (consentType) {
              case ConversationRepository.CONSENT_TYPE.INCOMING_CALL: {
                actionStringId = z.string.modalConversationNewDeviceIncomingCallAction;
                messageStringId = z.string.modalConversationNewDeviceIncomingCallMessage;
                break;
              }

              case ConversationRepository.CONSENT_TYPE.OUTGOING_CALL: {
                actionStringId = z.string.modalConversationNewDeviceOutgoingCallAction;
                messageStringId = z.string.modalConversationNewDeviceOutgoingCallMessage;
                break;
              }

              default: {
                actionStringId = z.string.modalConversationNewDeviceAction;
                messageStringId = z.string.modalConversationNewDeviceMessage;
                break;
              }
            }

            amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
              action: () => {
                sendAnyway = true;
                conversationEntity.verification_state(z.conversation.ConversationVerificationState.UNVERIFIED);

                resolve(true);
              },
              close: () => {
                if (!sendAnyway) {
                  const errorType = z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
                  reject(new z.error.ConversationError(errorType));
                }
              },
              text: {
                action: z.l10n.text(actionStringId),
                message: z.l10n.text(messageStringId),
                title: z.l10n.text(titleStringId, titleSubstitutions),
              },
            });
          })
          .catch(reject);
      });
    });
  }

  /**
   * Estimate whether message should be send as type external.
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {boolean} Is payload likely to be too big so that we switch to type external?
   */
  _shouldSendAsExternal(eventInfoEntity) {
    const {conversationId, genericMessage} = eventInfoEntity;

    return this.get_conversation_by_id(conversationId).then(conversationEntity => {
      const messageInBytes = new Uint8Array(genericMessage.toArrayBuffer()).length;
      const estimatedPayloadInBytes = conversationEntity.getNumberOfClients() * messageInBytes;

      return estimatedPayloadInBytes > ConversationRepository.CONFIG.EXTERNAL_MESSAGE_THRESHOLD;
    });
  }

  /**
   * Post images to a conversation.
   *
   * @param {Conversation} conversation_et - Conversation to post the images
   * @param {Array|FileList} images - Images
   * @returns {undefined} No return value
   */
  upload_images(conversation_et, images) {
    if (this._can_upload_assets_to_conversation(conversation_et)) {
      Array.from(images).forEach(image => this.send_image_asset(conversation_et, image));
    }
  }

  /**
   * Post files to a conversation.
   *
   * @param {Conversation} conversation_et - Conversation to post the files
   * @param {Array|FileList} files - files
   * @returns {undefined} No return value
   */
  upload_files(conversation_et, files) {
    if (this._can_upload_assets_to_conversation(conversation_et)) {
      Array.from(files).forEach(file => this.upload_file(conversation_et, file));
    }
  }

  /**
   * Post file to a conversation using v3
   *
   * @param {Conversation} conversation_et - Conversation to post the file
   * @param {Object} file - File object
   * @returns {Promise} Resolves when file was uploaded
   */
  upload_file(conversation_et, file) {
    let message_id;
    const upload_started = Date.now();

    return this.send_asset_metadata(conversation_et, file)
      .then(({id}) => {
        message_id = id;
        return this.sendAssetPreview(conversation_et, file, message_id);
      })
      .then(() => this.send_asset_remotedata(conversation_et, file, message_id))
      .then(() => {
        const upload_duration = (Date.now() - upload_started) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        this.logger.info(`Finished to upload asset for conversation'${conversation_et.id} in ${upload_duration}`);
      })
      .catch(error => {
        if (error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }

        this.logger.error(`Failed to upload asset for conversation '${conversation_et.id}': ${error.message}`, error);
        return this.get_message_in_conversation_by_id(conversation_et, message_id).then(message_et => {
          this.send_asset_upload_failed(conversation_et, message_et.id);
          return this.update_message_as_upload_failed(message_et);
        });
      });
  }

  /**
   * Delete message for everyone.
   *
   * @param {Conversation} conversationEntity - Conversation to delete message from
   * @param {Message} messageEntity - Message to delete
   * @param {Array<string>|boolean} [precondition] - Optional level that backend checks for missing clients
   * @returns {Promise} Resolves when message was deleted
   */
  deleteMessageForEveryone(conversationEntity, messageEntity, precondition) {
    const conversationId = conversationEntity.id;
    const messageId = messageEntity.id;

    return Promise.resolve()
      .then(() => {
        if (!messageEntity.user().is_me && !messageEntity.ephemeral_expires()) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        const protoMessageDelete = new z.proto.MessageDelete(messageId);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.DELETED, protoMessageDelete);

        return this.sending_queue.push(() => {
          return this.create_recipients(conversationId, false, precondition).then(recipients => {
            const options = {precondition, recipients};
            const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationId, options);
            this._sendGenericMessage(eventInfoEntity);
          });
        });
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, messageId, conversationId);
        return this._delete_message_by_id(conversationEntity, messageId);
      })
      .catch(error => {
        const isConversationNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (isConversationNotFound) {
          this.logger.warn(`Conversation '${conversationId}' not found. Deleting message for self user only.`);
          return this.deleteMessage(conversationEntity, messageEntity);
        }
        const message = `Failed to delete message '${messageId}' in conversation '${conversationId}' for everyone`;
        this.logger.info(message, error);
        throw error;
      });
  }

  /**
   * Delete message on your own clients.
   *
   * @param {Conversation} conversationEntity - Conversation to delete message from
   * @param {Message} messageEntity - Message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  deleteMessage(conversationEntity, messageEntity) {
    return Promise.resolve()
      .then(() => {
        const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        const protoMessageHide = new z.proto.MessageHide(conversationEntity.id, messageEntity.id);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.HIDDEN, protoMessageHide);

        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
        return this.sendGenericMessageToConversation(eventInfoEntity);
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, messageEntity.id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, messageEntity.id);
      })
      .catch(error => {
        this.logger.info(
          `Failed to send delete message with id '${messageEntity.id}' for conversation '${conversationEntity.id}'`,
          error
        );
        throw error;
      });
  }

  /**
   * Can user upload assets to conversation.
   * @param {Conversation} conversation_et - Conversation to check
   * @returns {boolean} Can assets be uploaded
   */
  _can_upload_assets_to_conversation(conversation_et) {
    return !!conversation_et && !conversation_et.isRequest() && !conversation_et.removed_from_conversation();
  }

  /**
   * Count number of pending uploads
   * @returns {number} Number of pending uploads
   */
  get_number_of_pending_uploads() {
    return this.conversations().reduce((sum, conversationEntity) => {
      return sum + conversationEntity.get_number_of_pending_uploads();
    }, 0);
  }

  //##############################################################################
  // Event callbacks
  //##############################################################################

  /**
   * Listener for incoming events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} [eventSource=z.event.EventRepository.SOURCE.STREAM] - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  onConversationEvent(eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
    const logMessage = ` Conversation Event: '${eventJson.type}' (Source: ${eventSource})`;
    this.logger.info(logMessage, logObject);

    return this._pushToReceivingQueue(eventJson, eventSource);
  }

  _handleConversationEvent(eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    if (!eventJson) {
      return Promise.reject(new Error('Conversation Repository Event Handling: Event missing'));
    }

    const {conversation, data: eventData, type} = eventJson;
    const conversationId = (eventData && eventData.conversationId) || conversation;
    this.logger.info(`Handling event '${type}' in conversation '${conversationId}' (Source: ${eventSource})`);

    const inSelfConversation = conversationId === this.self_conversation() && this.self_conversation().id;
    if (inSelfConversation) {
      const typesInSelfConversation = [
        z.event.Backend.CONVERSATION.MEMBER_UPDATE,
        z.event.Client.CONVERSATION.MESSAGE_HIDDEN,
      ];

      const isExpectedType = typesInSelfConversation.includes(type);
      if (!isExpectedType) {
        return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION));
      }
    }

    const isConversationCreate = type === z.event.Backend.CONVERSATION.CREATE;
    const onEventPromise = isConversationCreate ? Promise.resolve() : this.get_conversation_by_id(conversationId);
    let previouslyArchived;

    return onEventPromise
      .then(conversationEntity => {
        if (conversationEntity) {
          // Check if conversation was archived
          previouslyArchived = conversationEntity.is_archived();

          const isBackendTimestamp = eventSource !== z.event.EventRepository.SOURCE.INJECTED;
          conversationEntity.update_timestamp_server(eventJson.server_time || eventJson.time, isBackendTimestamp);
        }

        return conversationEntity;
      })
      .then(conversationEntity => this._checkConversationParticipants(conversationEntity, eventJson, eventSource))
      .then(conversationEntity => this._triggerFeatureEventHandlers(conversationEntity, eventJson, eventSource))
      .then(conversationEntity => this._reactToConversationEvent(conversationEntity, eventJson, eventSource))
      .then((entityObject = {}) => this._handleConversationNotification(entityObject, eventSource, previouslyArchived))
      .catch(error => {
        const isMessageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isMessageNotFound) {
          throw error;
        }
      });
  }

  /**
   * Check that sender of received event is a known conversation participant.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when the participant list has been checked
   */
  _checkConversationParticipants(conversationEntity, eventJson, eventSource) {
    // We ignore injected events
    const isInjectedEvent = eventSource === z.event.EventRepository.SOURCE.INJECTED;
    if (isInjectedEvent || !conversationEntity) {
      return conversationEntity;
    }

    const {from: sender, id, type, time} = eventJson;

    if (sender) {
      const allParticipantIds = conversationEntity.participating_user_ids().concat(this.selfUser().id);
      const isFromUnknownUser = !allParticipantIds.includes(sender);

      if (isFromUnknownUser) {
        const leavingEventTypes = [
          z.event.Backend.CONVERSATION.MEMBER_LEAVE,
          z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
        ];
        const isLeaveEvent = leavingEventTypes.includes(eventJson.type);
        if (isLeaveEvent) {
          const isFromLeavingUser = eventJson.data.user_ids.includes(sender);
          if (isFromLeavingUser) {
            // we ignore leave events that are sent by the user actually leaving
            return conversationEntity;
          }
        }

        const message = `Received '${type}' event '${id}' from user '${sender}' unknown in '${conversationEntity.id}'`;
        this.logger.warn(message, eventJson);

        const timestamp = new Date(time).getTime() - 1;
        return this.addMissingMember(conversationEntity.id, [sender], timestamp).then(() => conversationEntity);
      }
    }

    return conversationEntity;
  }

  /**
   * Triggers the methods associated with a specific event.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise<any>} Resolves when the event has been treated
   */
  _reactToConversationEvent(conversationEntity, eventJson, eventSource) {
    switch (eventJson.type) {
      case z.event.Backend.CONVERSATION.CREATE:
        return this._onCreate(eventJson, eventSource);

      case z.event.Backend.CONVERSATION.MEMBER_JOIN:
        return this._onMemberJoin(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MEMBER_LEAVE:
      case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE:
        return this._onMemberLeave(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MEMBER_UPDATE:
        return this._onMemberUpdate(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.RENAME:
        return this._onRename(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.ASSET_ADD:
        return this._onAssetAdd(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.CONFIRMATION:
        return this._on_confirmation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.GROUP_CREATION:
        return this._onGroupCreation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.MESSAGE_DELETE:
        return this._onMessageDeleted(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.MESSAGE_HIDDEN:
        return this._onMessageHidden(eventJson);

      case z.event.Client.CONVERSATION.ONE2ONE_CREATION:
        return this._on1to1Creation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.REACTION:
        return this._onReaction(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE:
      case z.event.Client.CONVERSATION.DELETE_EVERYWHERE:
      case z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:
      case z.event.Client.CONVERSATION.KNOCK:
      case z.event.Client.CONVERSATION.LOCATION:
      case z.event.Client.CONVERSATION.MESSAGE_ADD:
      case z.event.Client.CONVERSATION.MISSED_MESSAGES:
      case z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT:
      case z.event.Client.CONVERSATION.VERIFICATION:
      case z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE:
      case z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE:
        return this._addEventToConversation(conversationEntity, eventJson);
    }
  }

  /**
   * Calls the feature specific event handler on the current event being handled.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when all the handlers have done their job
   */
  _triggerFeatureEventHandlers(conversationEntity, eventJson, eventSource) {
    const conversationEventHandlers = [this.ephemeralHandler, this.stateHandler];
    const handlePromises = conversationEventHandlers.map(handler =>
      handler.handleConversationEvent(conversationEntity, eventJson, eventSource)
    );
    return Promise.all(handlePromises).then(() => conversationEntity);
  }

  /**
   * Handles conversation update and notification message.
   *
   * @private
   * @param {Object} entityObject - Object containing the conversation and the message that are targeted by the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @param {boolean} previouslyArchived - true if the previous state of the conversation was archived
   * @returns {Promise} Resolves when the conversation was updated
   */
  _handleConversationNotification(entityObject = {}, eventSource, previouslyArchived) {
    const {conversationEntity, messageEntity} = entityObject;

    if (conversationEntity) {
      const eventFromWebSocket = eventSource === z.event.EventRepository.SOURCE.WEB_SOCKET;
      const eventFromStream = eventSource === z.event.EventRepository.SOURCE.STREAM;

      if (messageEntity) {
        const isRemoteEvent = eventFromStream || eventFromWebSocket;

        if (isRemoteEvent) {
          this.sendConfirmationStatus(conversationEntity, messageEntity);
        }

        if (!eventFromStream) {
          amplify.publish(z.event.WebApp.NOTIFICATION.NOTIFY, messageEntity, undefined, conversationEntity);
        }

        if (conversationEntity.is_cleared()) {
          conversationEntity.cleared_timestamp(0);
        }
      }

      // Check if event needs to be un-archived
      if (previouslyArchived) {
        // Add to check for un-archiving at the end of stream handling
        if (eventFromStream) {
          return this.conversationsWithNewEvents.set(conversationEntity.id, conversationEntity);
        }

        if (eventFromWebSocket && conversationEntity.shouldUnarchive()) {
          return this.unarchiveConversation(conversationEntity, false, 'event from WebSocket');
        }
      }
    }
  }

  /**
   * Push to receiving queue.
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _pushToReceivingQueue(eventJson, source) {
    this.receiving_queue
      .push(() => this._handleConversationEvent(eventJson, source))
      .then(() => {
        if (this.init_promise) {
          const eventFromStream = source === z.event.EventRepository.SOURCE.STREAM;
          if (eventFromStream) {
            this.init_handled = this.init_handled + 1;
            if (this.init_handled % 5 === 0 || this.init_handled < 5) {
              const content = {
                handled: this.init_handled,
                total: this.init_total,
              };
              const progress = (this.init_handled / this.init_total) * 20 + 75;

              amplify.publish(z.event.WebApp.APP.UPDATE_PROGRESS, progress, z.string.initEvents, content);
            }
          }

          if (!this.receiving_queue.getLength() || !eventFromStream) {
            this.init_promise.resolve_fn();
            this.init_promise = undefined;
          }
        }
      })
      .catch(error => {
        if (this.init_promise) {
          this.init_promise.reject_fn(error);
          this.init_promise = undefined;
        } else {
          throw error;
        }
      });
  }

  /**
   * Add missed events message to conversations.
   * @returns {undefined} No return value
   */
  on_missed_events() {
    this.filtered_conversations()
      .filter(conversation_et => !conversation_et.removed_from_conversation())
      .forEach(conversation_et => {
        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const missed_event = z.conversation.EventBuilder.buildMissed(conversation_et, currentTimestamp);
        this.eventRepository.injectEvent(missed_event);
      });
  }

  _on1to1Creation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity)
      .then(messageEntity => this._updateMessageUserEntities(messageEntity))
      .then(messageEntity => {
        const userEntity = messageEntity.otherUser();
        const isOutgoingRequest = userEntity && userEntity.isOutgoingRequest();
        if (isOutgoingRequest) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_REQUEST;
        }

        conversationEntity.add_message(messageEntity);
        return {conversationEntity};
      });
  }

  /**
   * An asset was uploaded.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation to add the event to
   * @param {Object} event_json - JSON data of 'conversation.asset-upload-complete' event
   * @returns {Promise} Resolves when the event was handled
   */
  _on_asset_upload_complete(conversation_et, event_json) {
    return this.get_message_in_conversation_by_id(conversation_et, event_json.id)
      .then(message_et => this.update_message_as_upload_complete(conversation_et, message_et, event_json))
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          throw error;
        }

        this.logger.error(`Upload complete: Could not find message with id '${event_json.id}'`, event_json);
      });
  }

  /**
   * Received confirmation of message.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation entity that a message was reacted upon in
   * @param {Object} event_json - JSON data of 'conversation.confirmation' event
   * @returns {Promise} Resolves when the event was handled
   */
  _on_confirmation(conversation_et, event_json) {
    const event_data = event_json.data;

    return this.get_message_in_conversation_by_id(conversation_et, event_data.message_id)
      .then(message_et => {
        const was_updated = message_et.update_status(event_data.status);

        if (was_updated) {
          const changes = {status: message_et.status()};
          return this.eventService.updateEvent(message_et.primary_key, changes);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          this.logger.info(
            `Failed to handle status update of a message in conversation '${conversation_et.id}'`,
            error
          );
          throw error;
        }
      });
  }

  /**
   * A conversation was created.
   *
   * @private
   * @param {Object} eventJson - JSON data of 'conversation.create' event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when the event was handled
   */
  _onCreate(eventJson, eventSource) {
    const {conversation: conversationId, data: eventData, time} = eventJson;
    const eventTimestamp = new Date(time).getTime();
    const initialTimestamp = _.isNaN(eventTimestamp) ? this.getLatestEventTimestamp(true) : eventTimestamp;

    return this.find_conversation_by_id(conversationId)
      .then(conversationEntity => {
        if (conversationEntity) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES);
        }
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (isConversationNotFound) {
          return this.mapConversations(eventData, initialTimestamp);
        }

        throw error;
      })
      .then(conversationEntity => this.updateParticipatingUserEntities(conversationEntity))
      .then(conversationEntity => this.save_conversation(conversationEntity))
      .then(conversationEntity => {
        if (conversationEntity) {
          if (conversationEntity.participating_user_ids().length) {
            this._addCreationMessage(conversationEntity, false, initialTimestamp, eventSource);
          }

          this.verification_state_handler.onConversationCreate(conversationEntity);
          return {conversationEntity};
        }
      })
      .catch(error => {
        const isNoChanges = error.type === z.error.ConversationError.TYPE.NO_CHANGES;
        if (!isNoChanges) {
          throw error;
        }
      });
  }

  _onGroupCreation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity)
      .then(messageEntity => {
        const creatorId = conversationEntity.creator;
        const createdByParticipant = !!conversationEntity.participating_user_ids().find(userId => userId === creatorId);
        const createdBySelfUser = this.selfUser().id === creatorId && !conversationEntity.removed_from_conversation();

        const creatorIsParticipant = createdByParticipant || createdBySelfUser;
        if (!creatorIsParticipant) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_RESUME;
        }

        return this._updateMessageUserEntities(messageEntity);
      })
      .then(messageEntity => {
        if (conversationEntity && messageEntity) {
          conversationEntity.add_message(messageEntity);
        }

        return {conversationEntity, messageEntity};
      });
  }

  /**
   * User were added to a group conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add users to
   * @param {Object} eventJson - JSON data of 'conversation.member-join' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberJoin(conversationEntity, eventJson) {
    // Ignore if we join a 1to1 conversation (accept a connection request)
    const connectionEntity = this.connectionRepository.getConnectionByConversationId(conversationEntity.id);
    const isPendingConnection = connectionEntity && connectionEntity.isIncomingRequest();
    if (isPendingConnection) {
      return Promise.resolve();
    }

    const eventData = eventJson.data;

    eventData.user_ids.forEach(userId => {
      const isSelfUser = userId === this.selfUser().id;
      const isParticipatingUser = conversationEntity.participating_user_ids().includes(userId);
      if (!isSelfUser && !isParticipatingUser) {
        conversationEntity.participating_user_ids.push(userId);
      }
    });

    // Self user joins again
    const selfUserRejoins = eventData.user_ids.includes(this.selfUser().id);
    if (selfUserRejoins) {
      conversationEntity.status(z.conversation.ConversationStatus.CURRENT_MEMBER);
    }

    const updateSequence = selfUserRejoins ? this.updateConversationFromBackend(conversationEntity) : Promise.resolve();

    return updateSequence
      .then(() => this.updateParticipatingUserEntities(conversationEntity, false, true))
      .then(() => this._addEventToConversation(conversationEntity, eventJson))
      .then(({messageEntity}) => {
        this.verification_state_handler.onMemberJoined(conversationEntity, eventData.user_ids);
        return {conversationEntity, messageEntity};
      });
  }

  /**
   * Members of a group conversation were removed or left.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to remove users from
   * @param {Object} eventJson - JSON data of 'conversation.member-leave' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberLeave(conversationEntity, eventJson) {
    const {data: eventData, from} = eventJson;
    const isFromSelf = from === this.selfUser().id;
    const removesSelfUser = eventData.user_ids.includes(this.selfUser().id);
    const selfLeavingClearedConversation = isFromSelf && removesSelfUser && conversationEntity.is_cleared();

    if (removesSelfUser) {
      conversationEntity.status(z.conversation.ConversationStatus.PAST_MEMBER);

      if (conversationEntity.call()) {
        const reason = z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE;
        amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, conversationEntity.id, reason);
      }

      if (this.selfUser().isTemporaryGuest()) {
        eventJson.from = this.selfUser().id;
      }
    }

    if (!selfLeavingClearedConversation) {
      return this._addEventToConversation(conversationEntity, eventJson)
        .then(({messageEntity}) => {
          messageEntity
            .userEntities()
            .filter(userEntity => !userEntity.is_me)
            .forEach(userEntity => {
              conversationEntity.participating_user_ids.remove(userEntity.id);

              if (userEntity.isTemporaryGuest()) {
                userEntity.clearExpirationTimeout();
              }

              if (conversationEntity.call()) {
                amplify.publish(z.event.WebApp.CALL.STATE.REMOVE_PARTICIPANT, conversationEntity.id, userEntity.id);
              }
            });

          return this.updateParticipatingUserEntities(conversationEntity).then(() => messageEntity);
        })
        .then(messageEntity => {
          this.verification_state_handler.onMemberLeft(conversationEntity);

          if (isFromSelf && conversationEntity.removed_from_conversation()) {
            this.archiveConversation(conversationEntity);
          }

          return {conversationEntity, messageEntity};
        });
    }
  }

  /**
   * Membership properties for a conversation were updated.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that will be updated
   * @param {Object} eventJson - JSON data of 'conversation.member-update' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberUpdate(conversationEntity, eventJson) {
    const {conversation: conversationId, data: eventData, from} = eventJson;

    const isBackendEvent = eventData.otr_archived_ref || eventData.otr_muted_ref;
    const inSelfConversation = !this.self_conversation() || conversationId === this.self_conversation().id;
    if (!inSelfConversation && conversationId && !isBackendEvent) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION);
    }

    const isFromSelf = !this.selfUser() || from === this.selfUser().id;
    if (!isFromSelf) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
    }

    const isActiveConversation = this.is_active_conversation(conversationEntity);
    const nextConversationEt = isActiveConversation ? this.get_next_conversation(conversationEntity) : undefined;
    const previouslyArchived = conversationEntity.is_archived();

    this.conversationMapper.updateSelfStatus(conversationEntity, eventData);

    const wasUnarchived = previouslyArchived && !conversationEntity.is_archived();
    if (wasUnarchived) {
      return this._fetch_users_and_events(conversationEntity);
    }

    if (conversationEntity.is_cleared()) {
      this._clear_conversation(conversationEntity, conversationEntity.cleared_timestamp());
    }

    if (!conversationEntity.showNotificationsEverything()) {
      const hasIncomingCall = conversationEntity.call() && conversationEntity.call().isIncoming();
      if (hasIncomingCall) {
        amplify.publish(z.event.WebApp.CALL.STATE.REJECT, conversationEntity.id, false);
      }
    }

    if (isActiveConversation && (conversationEntity.is_archived() || conversationEntity.is_cleared())) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEt);
    }
  }

  /**
   * An asset received in a conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add the event to
   * @param {Object} event - JSON data of 'conversation.asset-add'
   * @returns {Promise} Resolves when the event was handled
   */
  _onAssetAdd(conversationEntity, event) {
    const fromSelf = event.from === this.selfUser().id;

    const isRemoteFailure = !fromSelf && event.data.status === z.assets.AssetTransferState.UPLOAD_FAILED;
    const isLocalCancel = fromSelf && event.data.reason === z.assets.AssetUploadFailedReason.CANCELLED;

    if (isRemoteFailure || isLocalCancel) {
      return conversationEntity.remove_message_by_id(event.id);
    }

    return this._addEventToConversation(conversationEntity, event).then(({messageEntity}) => {
      const firstAsset = messageEntity.get_first_asset();
      if (firstAsset.is_image() || firstAsset.status() === z.assets.AssetTransferState.UPLOADED) {
        return {conversationEntity, messageEntity};
      }
    });
  }

  /**
   * A hide message received in a conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add the event to
   * @param {Object} eventJson - JSON data of 'conversation.message-delete'
   * @returns {Promise} Resolves when the event was handled
   */
  _onMessageDeleted(conversationEntity, eventJson) {
    const {data: eventData, from, id: eventId, time} = eventJson;

    return this.get_message_in_conversation_by_id(conversationEntity, eventData.message_id)
      .then(deletedMessageEntity => {
        if (deletedMessageEntity.ephemeral_expires()) {
          return;
        }

        const isSameSender = from === deletedMessageEntity.from;
        if (!isSameSender) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        const isFromSelf = from === this.selfUser().id;
        if (!isFromSelf) {
          return this._addDeleteMessage(conversationEntity.id, eventId, time, deletedMessageEntity);
        }
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, eventData.message_id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, eventData.message_id);
      })
      .catch(error => {
        const isNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isNotFound) {
          this.logger.info(`Failed to delete message for conversation '${conversationEntity.id}'`, error);
          throw error;
        }
      });
  }

  /**
   * A hide message received in a conversation.
   *
   * @private
   * @param {Object} eventJson - JSON data of 'conversation.message-hidden'
   * @returns {Promise} Resolves when the event was handled
   */
  _onMessageHidden(eventJson) {
    const {conversation: conversationId, data: eventData, from} = eventJson;

    return Promise.resolve()
      .then(() => {
        const inSelfConversation = !this.self_conversation() || conversationId === this.self_conversation().id;
        if (!inSelfConversation) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION);
        }

        const isFromSelf = !this.selfUser() || from === this.selfUser().id;
        if (!isFromSelf) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        return this.get_conversation_by_id(eventData.conversation_id);
      })
      .then(conversationEntity => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, eventData.message_id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, eventData.message_id);
      })
      .catch(error => {
        this.logger.info(
          `Failed to delete message '${eventData.message_id}' for conversation '${eventData.conversation_id}'`,
          error
        );
        throw error;
      });
  }

  /**
   * Someone reacted to a message.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that a message was reacted upon in
   * @param {Object} eventJson - JSON data of 'conversation.reaction' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onReaction(conversationEntity, eventJson) {
    const conversationId = conversationEntity.id;
    const eventData = eventJson.data;
    const messageId = eventData.message_id;

    return this.get_message_in_conversation_by_id(conversationEntity, messageId)
      .then(messageEntity => {
        if (!messageEntity || !messageEntity.is_content()) {
          const type = messageEntity ? messageEntity.type : 'unknown';

          const log = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationId}'`;
          this.logger.error(log, messageEntity);
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_TYPE);
        }

        const changes = messageEntity.update_reactions(eventJson);
        if (changes) {
          const log = `Updating reactions of message '${messageId}' in conversation '${conversationId}'`;
          this.logger.debug(log, {changes, event: eventJson});

          return this._updateMessageUserEntities(messageEntity).then(changedMessageEntity => {
            this.eventService.updateEventSequentially(changedMessageEntity.primary_key, changes);
            return this._prepareReactionNotification(conversationEntity, changedMessageEntity, eventJson);
          });
        }
      })
      .catch(error => {
        const isNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isNotFound) {
          const log = `Failed to handle reaction to message '${messageId}' in conversation '${conversationId}'`;
          this.logger.error(log, {error, event: eventJson});
          throw error;
        }
      });
  }

  /**
   * A conversation was renamed.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that will be renamed
   * @param {Object} eventJson - JSON data of 'conversation.rename' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onRename(conversationEntity, eventJson) {
    return this._addEventToConversation(conversationEntity, eventJson).then(({messageEntity}) => {
      this.conversationMapper.updateProperties(conversationEntity, eventJson.data);
      return {conversationEntity, messageEntity};
    });
  }

  handleMessageExpiration(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, messageEntity);
    const shouldDeleteMessage = !messageEntity.user().is_me || messageEntity.is_ping();
    if (shouldDeleteMessage) {
      this.get_conversation_by_id(messageEntity.conversation_id).then(conversationEntity => {
        const isPingFromSelf = messageEntity.user().is_me && messageEntity.is_ping();
        const deleteForSelf = isPingFromSelf || conversationEntity.removed_from_conversation();
        if (deleteForSelf) {
          return this.deleteMessage(conversationEntity, messageEntity);
        }

        const userIds = conversationEntity.isGroup() ? [this.selfUser().id, messageEntity.from] : undefined;
        this.deleteMessageForEveryone(conversationEntity, messageEntity, userIds);
      });
    }
  }

  //##############################################################################
  // Private
  //##############################################################################

  /**
   * Convert a JSON event into an entity and add it to a given conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity the event will be added to
   * @param {Object} eventJson - Event data
   * @returns {Promise} Promise that resolves with the message entity for the event
   */
  _addEventToConversation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity, true)
      .then(messageEntity => this._updateMessageUserEntities(messageEntity))
      .then(messageEntity => this.ephemeralHandler.validateMessage(messageEntity))
      .then(messageEntity => {
        if (conversationEntity && messageEntity) {
          const replacedEntity = conversationEntity.add_message(messageEntity, true);
          if (replacedEntity) {
            const messages = conversationEntity.messages_unordered();

            const updatedMessages = messages.map(message => {
              const hasEditedQuote =
                message.quote && message.quote() && message.quote().messageId === replacedEntity.id;
              if (hasEditedQuote) {
                const {error, userId} = message.quote();
                const newQuote = new z.message.QuoteEntity({error, messageId: messageEntity.id, userId});
                message.quote(newQuote);
              }
              return message;
            });

            conversationEntity.messages_unordered(updatedMessages);
            amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, replacedEntity.id, messageEntity);
          }
        }
        return {conversationEntity, messageEntity};
      });
  }

  /**
   * Convert multiple JSON events into entities and add them to a given conversation.
   *
   * @private
   * @param {Array} events - Event data
   * @param {Conversation} conversationEntity - Conversation entity the events will be added to
   * @param {boolean} [prepend=true] - Should existing messages be prepended
   * @returns {Promise} Resolves with an array of mapped messages
   */
  _addEventsToConversation(events, conversationEntity, prepend = true) {
    return this.event_mapper
      .mapJsonEvents(events, conversationEntity, true)
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities))
      .then(messageEntities => this.ephemeralHandler.validateMessages(messageEntities))
      .then(messageEntities => {
        if (prepend && conversationEntity.messages().length) {
          conversationEntity.prepend_messages(messageEntities);
        } else {
          conversationEntity.add_messages(messageEntities);
        }
        return messageEntities;
      });
  }

  /**
   * Fetch all unread events and users of a conversation.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation fetch events and users for
   * @returns {undefined} No return value
   */
  _fetch_users_and_events(conversation_et) {
    if (!conversation_et.is_loaded() && !conversation_et.is_pending()) {
      this.updateParticipatingUserEntities(conversation_et);
      this._get_unread_events(conversation_et);
    }
  }

  /**
   * Forward the reaction event to the Notification repository for browser and audio notifications.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation that event was received in
   * @param {Message} messageEntity - Message that has been reacted upon
   * @param {Object} eventJson -] JSON data of received reaction event
   * @returns {Promise} Resolves when the notification was prepared
   */
  _prepareReactionNotification(conversationEntity, messageEntity, eventJson) {
    const {data: event_data, from} = eventJson;

    const messageFromSelf = messageEntity.from === this.selfUser().id;
    if (messageFromSelf && event_data.reaction) {
      return this.user_repository.get_user_by_id(from).then(userEntity => {
        const reactionMessageEntity = new z.entity.Message(messageEntity.id, z.message.SuperType.REACTION);
        reactionMessageEntity.user(userEntity);
        reactionMessageEntity.reaction = event_data.reaction;
        return {conversationEntity, messageEntity: reactionMessageEntity};
      });
    }

    return Promise.resolve({conversationEntity});
  }

  _updateMessagesUserEntities(messageEntities) {
    return Promise.all(messageEntities.map(messageEntity => this._updateMessageUserEntities(messageEntity)));
  }

  /**
   * Updates the user entities that are part of a message.
   *
   * @private
   * @param {Message} messageEntity - Message to be updated
   * @returns {Promise} Resolves when users have been update
   */
  _updateMessageUserEntities(messageEntity) {
    return this.user_repository.get_user_by_id(messageEntity.from).then(userEntity => {
      messageEntity.user(userEntity);

      if (messageEntity.is_member() || messageEntity.userEntities) {
        return this.user_repository.get_users_by_id(messageEntity.userIds()).then(userEntities => {
          userEntities.sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
          messageEntity.userEntities(userEntities);
          return messageEntity;
        });
      }

      if (messageEntity.is_content()) {
        const userIds = Object.keys(messageEntity.reactions());

        messageEntity.reactions_user_ets.removeAll();
        if (userIds.length) {
          return this.user_repository.get_users_by_id(userIds).then(userEntities => {
            messageEntity.reactions_user_ets(userEntities);
            return messageEntity;
          });
        }

        if (messageEntity.has_asset_text()) {
          messageEntity.assets().forEach(assetEntity => {
            if (assetEntity.is_text()) {
              assetEntity.theme_color = messageEntity.user().accent_color();
            }
          });
        }
      }

      return messageEntity;
    });
  }

  /**
   * Cancel asset upload.
   * @param {Message} message_et - Message on which the cancel was initiated
   * @returns {undefined} No return value
   */
  cancel_asset_upload(message_et) {
    this.send_asset_upload_failed(
      this.active_conversation(),
      message_et.id,
      z.assets.AssetUploadFailedReason.CANCELLED
    );
  }

  /**
   * Delete message from UI and database. Primary key is used to delete message in database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {Message} message_et - Message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  _delete_message(conversation_et, message_et) {
    conversation_et.remove_message_by_id(message_et.id);
    return this.eventService.deleteEventByKey(message_et.primary_key);
  }

  /**
   * Delete message from UI and database. Primary key is used to delete message in database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {string} message_id - ID of message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  _delete_message_by_id(conversation_et, message_id) {
    conversation_et.remove_message_by_id(message_id);
    return this.eventService.deleteEvent(conversation_et.id, message_id);
  }

  /**
   * Delete messages from UI and database.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation that contains the message
   * @param {number} [timestamp] - Timestamp as upper bound which messages to remove
   * @returns {undefined} No return value
   */
  _deleteMessages(conversationEntity, timestamp) {
    conversationEntity.remove_messages(timestamp);
    conversationEntity.hasCreationMessage = false;

    const iso_date = timestamp ? new Date(timestamp).toISOString() : undefined;
    this.eventService.deleteEvents(conversationEntity.id, iso_date);
  }

  /**
   * Add delete message to conversation.
   *
   * @private
   * @param {string} conversationId - ID of conversation
   * @param {string} messageId - ID of message
   * @param {string} time - ISO 8601 formatted time string
   * @param {Message} messageEntity - Message to delete
   * @returns {undefined} No return value
   */
  _addDeleteMessage(conversationId, messageId, time, messageEntity) {
    const deleteEvent = z.conversation.EventBuilder.buildDelete(conversationId, messageId, time, messageEntity);
    this.eventRepository.injectEvent(deleteEvent);
  }

  //##############################################################################
  // Message updates
  //##############################################################################

  /**
   * Update asset in UI and DB as failed
   * @param {Message} message_et - Message to update
   * @param {string} [reason=z.assets.AssetTransferState.UPLOAD_FAILED] - Failure reason
   * @returns {Promise} Resolve when message was updated
   */
  update_message_as_upload_failed(message_et, reason = z.assets.AssetTransferState.UPLOAD_FAILED) {
    if (message_et) {
      if (!message_et.is_content()) {
        throw new Error(`Tried to update wrong message type as upload failed '${message_et.super_type}'`);
      }

      const asset_et = message_et.get_first_asset();
      if (asset_et) {
        const is_proper_asset = asset_et.is_audio() || asset_et.is_file() || asset_et.is_video();
        if (!is_proper_asset) {
          throw new Error(`Tried to update message with wrong asset type as upload failed '${asset_et.type}'`);
        }

        asset_et.status(reason);
        asset_et.upload_failed_reason(z.assets.AssetUploadFailedReason.FAILED);
      }

      return this.eventService.updateEventAsUploadFailed(message_et.primary_key, reason);
    }
  }

  /**
   * Update asset in UI and DB as completed.
   *
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {Message} message_et - Message to update
   * @param {Object} event_json - Uploaded asset event information
   * @returns {Promise} Resolve when message was updated
   */
  update_message_as_upload_complete(conversation_et, message_et, event_json) {
    const {id, key, otr_key, sha256, token} = event_json.data;
    const asset_et = message_et.get_first_asset();

    const resource = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token)
      : z.assets.AssetRemoteData.v2(conversation_et.id, id, otr_key, sha256);

    asset_et.original_resource(resource);
    asset_et.status(z.assets.AssetTransferState.UPLOADED);
    message_et.status(z.message.StatusType.SENT);

    return this.eventService.updateEventAsUploadSucceeded(message_et.primary_key, event_json);
  }

  //##############################################################################
  // Tracking helpers
  //##############################################################################

  /**
   * Track generic messages for media actions.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {z.proto.GenericMessage} genericMessage - Protobuf message
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Optional call message
   * @returns {undefined} No return value
   */
  _trackContributed(conversationEntity, genericMessage, callMessageEntity) {
    let messageTimer;
    const isEphemeral = genericMessage.content === z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL;

    if (isEphemeral) {
      genericMessage = genericMessage.ephemeral;
      messageTimer = genericMessage.expire_after_millis / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    }

    const messageContentType = genericMessage.content;
    let actionType;
    let numberOfMentions;
    switch (messageContentType) {
      case 'asset': {
        const protoAsset = genericMessage.asset;
        if (protoAsset.original) {
          actionType = protoAsset.original.image ? 'photo' : 'file';
        }
        break;
      }

      case 'calling': {
        const properties = callMessageEntity.properties;
        const isVideoCall = properties.videosend === z.calling.enum.PROPERTY_STATE.TRUE;
        actionType = isVideoCall ? 'video_call' : 'audio_call';
        break;
      }

      case 'image': {
        actionType = 'photo';
        break;
      }

      case 'knock': {
        actionType = 'ping';
        break;
      }

      case 'text': {
        const protoText = genericMessage.text;
        if (!protoText.link_preview.length) {
          actionType = 'text';
          numberOfMentions = protoText.mentions.length;
        }
        break;
      }

      default:
        break;
    }

    if (actionType) {
      const attributes = {
        action: actionType,
        conversation_type: z.tracking.helpers.getConversationType(conversationEntity),
        ephemeral_time: isEphemeral ? messageTimer : undefined,
        is_ephemeral: isEphemeral,
        is_global_ephemeral: !!conversationEntity.globalMessageTimer(),
        mention_num: numberOfMentions,
        with_service: conversationEntity.hasService(),
      };

      const isTeamConversation = !!conversationEntity.team_id;
      if (isTeamConversation) {
        Object.assign(attributes, z.tracking.helpers.getGuestAttributes(conversationEntity));
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONTRIBUTED, attributes);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation service for all conversation calls to the backend REST API.
z.conversation.ConversationService = class ConversationService {
  static get CONFIG() {
    return {
      URL_CONVERSATIONS: '/conversations',
    };
  }

  /**
   * Construct a new Conversation Service.
   * @param {BackendClient} backendClient - Client for the API calls
   * @param {EventService} eventService - Service that handles events
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, eventService, storageService) {
    this.backendClient = backendClient;
    this.eventService = eventService;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.conversation.ConversationService', z.config.LOGGER.OPTIONS);

    this.CONVERSATION_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS;
    this.EVENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  //##############################################################################
  // Create conversations
  //##############################################################################

  /**
   * Create a group conversation.
   *
   * @note Do not include yourself as the requestor
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createGroupConversation
   *
   * @param {Object} payload - Payload object for group creation
   * @returns {Promise} Resolves when the conversation was created
   */
  postConversations(payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: ConversationService.CONFIG.URL_CONVERSATIONS,
    });
  }

  //##############################################################################
  // Get conversations
  //##############################################################################

  /**
   * Retrieves paged meta information about the conversations of a user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversations
   *
   * @param {number} [limit=100] - Number of results to return (default 100, max 500)
   * @param {string} conversation_id - Conversation ID to start from
   * @returns {Promise} Resolves with the conversation information
   */
  getConversations(limit = 100, conversation_id) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: conversation_id,
      },
      type: 'GET',
      url: ConversationService.CONFIG.URL_CONVERSATIONS,
    });
  }

  /**
   * Retrieves all the conversations of a user.
   * @param {number} [limit=500] - Number of results to return (default 500, max 500)
   * @returns {Promise} Resolves with the conversation information
   */
  getAllConversations(limit = 500) {
    let allConversations = [];

    const _getConversations = conversationId => {
      return this.getConversations(limit, conversationId).then(({conversations, has_more: hasMore}) => {
        if (conversations.length) {
          allConversations = allConversations.concat(conversations);
        }

        return hasMore ? _getConversations(conversations.pop().id) : allConversations;
      });
    };

    return _getConversations();
  }

  /**
   * Get a conversation by ID.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversation
   *
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the server response
   */
  get_conversation_by_id(conversation_id) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}`,
    });
  }

  /**
   * Update the conversation name.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversation
   *
   * @param {string} conversationId - ID of conversation to rename
   * @param {string} name - new name of the conversation
   * @returns {Promise} Resolves with the server response
   */
  updateConversationName(conversationId, name) {
    return this.backendClient.sendJson({
      data: {name},
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}`,
    });
  }

  /**
   * Update the conversation message timer value.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer
   *
   * @param {string} conversationId - ID of conversation to rename
   * @param {number} messageTimer - new message timer of the conversation
   * @returns {Promise} Resolves with the server response
   */
  updateConversationMessageTimer(conversationId, messageTimer) {
    return this.backendClient.sendJson({
      data: {message_timer: messageTimer},
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/message-timer`,
    });
  }
  /**
   * Update self membership properties.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateSelf
   *
   * @param {string} conversation_id - ID of conversation to update
   * @param {Object} payload - Updated properties
   * @returns {Promise} Resolves with the server response
   */
  update_member_properties(conversation_id, payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}/self`,
    });
  }

  //##############################################################################
  // Conversation access
  //##############################################################################

  /**
   * Delete the conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/deleteConversationCode
   * @param {string} conversationId - ID of conversation to delete access code for
   * @returns {Promise} Resolves with the server response
   */
  deleteConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Get the conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/getConversationCode
   * @param {string} conversationId - ID of conversation to get access code for
   * @returns {Promise} Resolves with the server response
   */
  getConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Request a conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createConversationCode
   * @param {string} conversationId - ID of conversation to request access code for
   * @returns {Promise} Resolves with the server response
   */
  postConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Join a conversation using a code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode
   * @param {string} key - Conversation identifier
   * @param {string} code - Conversation access code
   * @returns {Promise} Resolves with the server response
   */
  postConversationJoin(key, code) {
    return this.backendClient.sendJson({
      data: {
        code: code,
        key: key,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/join`,
    });
  }

  /**
   * Update conversation access mode.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationAccess
   *
   * @param {string} conversationId - ID of conversation
   * @param {Array<z.conversation.ACCESS_MODE>} accessModes - Conversation access mode
   * @param {z.conversation.ACCESS_ROLE} accessRole - Conversation access role
   * @returns {Promise} Resolves with the server response
   */
  putConversationAccess(conversationId, accessModes, accessRole) {
    return this.backendClient.sendJson({
      data: {
        access: accessModes,
        access_role: accessRole,
      },
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/access`,
    });
  }

  //##############################################################################
  // Send events
  //##############################################################################

  /**
   * Remove service from conversation.
   *
   * @param {string} conversationId - ID of conversation to remove service from
   * @param {string} userId - ID of service to be removed from the the conversation
   * @returns {Promise} Resolves with the server response
   */
  deleteBots(conversationId, userId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/bots/${userId}`,
    });
  }

  /**
   * Remove member from conversation.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember
   *
   * @param {string} conversationId - ID of conversation to remove member from
   * @param {string} userId - ID of member to be removed from the the conversation
   * @returns {Promise} Resolves with the server response
   */
  deleteMembers(conversationId, userId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/members/${userId}`,
    });
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {string} providerId - ID of service provider
   * @param {string} serviceId - ID of service
   * @returns {Promise} Resolves with the server response
   */
  postBots(conversationId, providerId, serviceId) {
    return this.backendClient.sendJson({
      data: {
        provider: providerId,
        service: serviceId,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/bots`,
    });
  }

  /**
   * Post an encrypted message to a conversation.
   *
   * @note If "recipients" are not specified you will receive a list of all missing OTR recipients (user-client-map).
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrMessage
   * @example How to send "recipients" payload
   * "recipients": {
   *   "<user-id>": {
   *     "<client-id>": "<base64-encoded-encrypted-content>"
   *   }
   * }
   *
   * @param {string} conversation_id - ID of conversation to send message in
   * @param {Object} payload - Payload to be posted
   * @param {Object} payload.recipients - Map with per-recipient data
   * @param {string} payload.sender - Client ID of the sender
   * @param {Array<string>|boolean} precondition_option - Level that backend checks for missing clients
   * @returns {Promise} Promise that resolves when the message was sent
   */
  post_encrypted_message(conversation_id, payload, precondition_option) {
    let url = `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}/otr/messages`;

    if (_.isArray(precondition_option)) {
      url = `${url}?report_missing=${precondition_option.join(',')}`;
    } else if (precondition_option) {
      url = `${url}?ignore_missing=true`;
    }

    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: url,
    });
  }

  /**
   * Add users to an existing conversation.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/addMembers
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {Array<string>} userIds - IDs of users to be added to the conversation
   * @returns {Promise} Resolves with the server response
   */
  postMembers(conversationId, userIds) {
    return this.backendClient.sendJson({
      data: {
        users: userIds,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/members`,
    });
  }

  //##############################################################################
  // Database interactions
  //##############################################################################

  /**
   * Deletes a conversation entity from the local database.
   * @param {string} conversation_id - ID of conversation to be deleted
   * @returns {Promise} Resolves when the entity was deleted
   */
  delete_conversation_from_db(conversation_id) {
    return this.storageService.delete(this.CONVERSATION_STORE_NAME, conversation_id).then(primary_key => {
      this.logger.info(`State of conversation '${primary_key}' was deleted`);
      return primary_key;
    });
  }

  /**
   * Get active conversations from database.
   * @returns {Promise} Resolves with active conversations
   */
  get_active_conversations_from_db() {
    const min_date = new Date();
    min_date.setDate(min_date.getDate() - 30);

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('time')
      .aboveOrEqual(min_date.toISOString())
      .toArray()
      .then(events => {
        const conversations = events.reduce((accumulated, event) => {
          if (accumulated[event.conversation]) {
            accumulated[event.conversation] = accumulated[event.conversation] + 1;
          } else {
            accumulated[event.conversation] = 1;
          }

          return accumulated;
        }, {});

        return Object.keys(conversations).sort((id_a, id_b) => conversations[id_b] - conversations[id_a]);
      });
  }

  /**
   * Loads conversation states from the local database.
   * @returns {Promise} Resolves with all the stored conversation states
   */
  load_conversation_states_from_db() {
    return this.storageService.getAll(this.CONVERSATION_STORE_NAME);
  }

  /**
   * Saves a list of conversation records in the local database.
   * @param {Array<Conversation>} conversations - Conversation entity
   * @returns {Promise<Array>} Resolves with a list of conversation records
   */
  save_conversations_in_db(conversations) {
    const keys = conversations.map(conversation => conversation.id);
    return this.storageService.db[this.CONVERSATION_STORE_NAME].bulkPut(conversations, keys).then(() => conversations);
  }

  /**
   * Saves a conversation entity in the local database.
   * @param {Conversation} conversation_et - Conversation entity
   * @returns {Promise} Resolves with the conversation entity
   */
  save_conversation_state_in_db(conversation_et) {
    const conversationData = conversation_et.serialize();

    return this.storageService
      .save(this.CONVERSATION_STORE_NAME, conversation_et.id, conversationData)
      .then(primary_key => {
        this.logger.info(`State of conversation '${primary_key}' was stored`, conversationData);
        return conversation_et;
      });
  }

  /**
   * Search for text in given conversation.
   *
   * @param {string} conversation_id - ID of conversation to add users to
   * @param {string} query - will be checked in against all text messages
   * @returns {Promise} Resolves with the matching events
   */
  search_in_conversation(conversation_id, query) {
    const category_min = z.message.MessageCategory.TEXT;
    const category_max =
      z.message.MessageCategory.TEXT | z.message.MessageCategory.LINK | z.message.MessageCategory.LINK_PREVIEW;

    return this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max).then(events => {
      return events.filter(({data: event_data}) => z.search.FullTextSearch.search(event_data.content, query));
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationStateHandler = class ConversationStateHandler extends z.conversation
  .AbstractConversationEventHandler {
  /**
   * Construct a new conversation state handler.
   * @param {ConversationService} conversationService - Service for conversation related backend interactions
   * @param {ConversationRepository} conversationMapper - Repository for conversation interactions
   */
  constructor(conversationService, conversationMapper) {
    super();
    const eventHandlingConfig = {
      [z.event.Backend.CONVERSATION.ACCESS_UPDATE]: this._mapConversationAccessState.bind(this),
      [z.event.Backend.CONVERSATION.CODE_DELETE]: this._resetConversationAccessCode.bind(this),
      [z.event.Backend.CONVERSATION.CODE_UPDATE]: this._updateConversationAccessCode.bind(this),
    };
    this.setEventHandlingConfig(eventHandlingConfig);
    this.conversationMapper = conversationMapper;
    this.conversationService = conversationService;
  }

  changeAccessState(conversationEntity, accessState) {
    const isConversationInTeam = conversationEntity && conversationEntity.inTeam();
    if (isConversationInTeam) {
      const isStateChange = conversationEntity.accessState() !== accessState;

      if (isStateChange) {
        let accessModes;
        let accessRole;

        const changeToGuestRoom = accessState === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM;
        const changeToTeamOnly = accessState === z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY;
        if (changeToGuestRoom) {
          accessModes = [z.conversation.ACCESS_MODE.INVITE, z.conversation.ACCESS_MODE.CODE];
          accessRole = z.conversation.ACCESS_ROLE.NON_ACTIVATED;
        } else if (changeToTeamOnly) {
          accessModes = [z.conversation.ACCESS_MODE.INVITE];
          accessRole = z.conversation.ACCESS_ROLE.TEAM;
        }

        if (accessModes && accessRole) {
          return this.conversationService
            .putConversationAccess(conversationEntity.id, accessModes, accessRole)
            .then(() => {
              conversationEntity.accessState(accessState);

              if (changeToTeamOnly) {
                conversationEntity.accessCode(undefined);
              }

              const attribute = {is_allow_guests: changeToGuestRoom};
              amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.ALLOW_GUESTS, attribute);
            })
            .catch(() => {
              const messageStringId = changeToGuestRoom
                ? z.string.modalConversationGuestOptionsAllowGuestMessage
                : z.string.modalConversationGuestOptionsDisableGuestMessage;

              this._showModal(messageStringId);
            });
        }
      }
    }

    this._showModal(z.string.modalConversationGuestOptionsToggleGuestsMessage);
    return Promise.resolve();
  }

  getAccessCode(conversationEntity) {
    return this.conversationService
      .getConversationCode(conversationEntity.id)
      .then(response => this.conversationMapper.mapAccessCode(conversationEntity, response))
      .catch(error => {
        const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (!isNotFound) {
          this._showModal(z.string.modalConversationGuestOptionsGetCodeMessage);
        }
      });
  }

  requestAccessCode(conversationEntity) {
    return this.conversationService
      .postConversationCode(conversationEntity.id)
      .then(response => {
        const accessCode = response && response.data;
        if (accessCode) {
          this.conversationMapper.mapAccessCode(conversationEntity, accessCode);
          amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_CREATED);
        }
      })
      .catch(() => this._showModal(z.string.modalConversationGuestOptionsRequestCodeMessage));
  }

  revokeAccessCode(conversationEntity) {
    return this.conversationService
      .deleteConversationCode(conversationEntity.id)
      .then(() => {
        conversationEntity.accessCode(undefined);
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_REVOKED);
      })
      .catch(() => this._showModal(z.string.modalConversationGuestOptionsRevokeCodeMessage));
  }

  _mapConversationAccessState(conversationEntity, eventJson) {
    const {access: accessModes, access_role: accessRole} = eventJson.data;
    this.conversationMapper.mapAccessState(conversationEntity, accessModes, accessRole);
  }

  _resetConversationAccessCode(conversationEntity) {
    conversationEntity.accessCode(undefined);
  }

  _updateConversationAccessCode(conversationEntity, eventJson) {
    this.conversationMapper.mapAccessCode(conversationEntity, eventJson.data);
  }

  _showModal(messageStringId) {
    const modalOptions = {text: {message: z.l10n.text(messageStringId)}};
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Enum of a user's participation status in a conversation.
z.conversation.ConversationStatus = {
  CURRENT_MEMBER: 0,
  PAST_MEMBER: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationStatusIcon = {
  ACTIVE_CALL: 'active-call',
  MISSED_CALL: 'missed-call',
  MUTED: 'muted',
  NONE: 'none',
  PENDING_CONNECTION: 'pending',
  TYPING: 'typing',
  UNREAD_MENTION: 'mention',
  UNREAD_MESSAGES: 'messages',
  UNREAD_PING: 'ping',
  UNREAD_REPLY: 'reply',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Enum of different conversation types.
z.conversation.ConversationType = {
  CONNECT: 3,
  GROUP: 0,
  ONE2ONE: 2,
  SELF: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationVerificationState = {
  DEGRADED: 2,
  UNVERIFIED: 0,
  VERIFIED: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationVerificationStateHandler = class ConversationVerificationStateHandler {
  constructor(conversationRepository, eventRepository, serverTimeRepository) {
    this.conversationRepository = conversationRepository;
    this.eventRepository = eventRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.logger = new z.util.Logger('z.conversation.ConversationVerificationStateHandler', z.config.LOGGER.OPTIONS);

    amplify.subscribe(z.event.WebApp.USER.CLIENT_ADDED, this.onClientAdded.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_REMOVED, this.onClientRemoved.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENTS_UPDATED, this.onClientsUpdated.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.VERIFICATION_STATE_CHANGED, this.onClientVerificationChanged.bind(this));
  }

  /**
   * Handle client verification state change.
   * @param {string} userId - Self user ID
   * @returns {undefined} No return value
   */
  onClientVerificationChanged(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      const isStateChange = this._checkChangeToVerified(conversationEntity);
      if (!isStateChange) {
        this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.UNVERIFIED);
      }
    });
  }

  /**
   * Self user or other participant added clients.
   * @param {string} userId - ID of user that added client (can be self user ID)
   * @returns {undefined} No return value
   */
  onClientAdded(userId) {
    this.onClientsAdded([userId]);
  }

  /**
   * Multiple participants added clients.
   * @param {Array<string>} userIds - Multiple user IDs (can include self user ID)
   * @returns {undefined} No return value
   */
  onClientsAdded(userIds) {
    this._getActiveConversationsWithUsers(userIds).forEach(({conversationEntity, userIds: matchingUserIds}) => {
      this._checkChangeToDegraded(conversationEntity, matchingUserIds, z.message.VerificationMessageType.NEW_DEVICE);
    });
  }

  /**
   * Self user removed a client or other participants deleted clients.
   * @param {string} userId - ID of user that added client (can be self user ID)
   * @returns {undefined} No return value
   */
  onClientRemoved(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      this._checkChangeToVerified(conversationEntity);
    });
  }

  /**
   * A new conversation was created.
   * @param {z.entity.Conversation} conversationEntity - New conversation entity
   * @returns {undefined} No return value
   */
  onConversationCreate(conversationEntity) {
    this._checkChangeToVerified(conversationEntity);
  }

  /**
   * Clients of a user were updated.
   * @param {string} userId - User ID
   * @returns {undefined} No return value
   */
  onClientsUpdated(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      const isStateChange = this._checkChangeToVerified(conversationEntity);
      if (!isStateChange) {
        this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.NEW_DEVICE);
      }
    });
  }

  /**
   * New member(s) joined the conversation.
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @param {Array<string>} userIds - IDs of added members
   * @returns {undefined} No return value
   */
  onMemberJoined(conversationEntity, userIds) {
    this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.NEW_MEMBER);
  }

  /**
   * Member(s) left the conversation.
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @returns {undefined} No return value
   */
  onMemberLeft(conversationEntity) {
    this._checkChangeToVerified(conversationEntity);
  }

  /**
   * Change that could verify conversation.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @returns {boolean} True if state changed
   */
  _checkChangeToVerified(conversationEntity) {
    if (this._willChangeToVerified(conversationEntity)) {
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const allVerifiedEvent = z.conversation.EventBuilder.buildAllVerified(conversationEntity, currentTimestamp);
      this.eventRepository.injectEvent(allVerifiedEvent);
      return true;
    }
  }

  /**
   * Change that could degrade conversation.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @param {Array<string>} userIds - IDs of affected users
   * @param {z.message.VerificationMessageType} type - Type of degradation
   * @returns {boolean} True if state changed
   */
  _checkChangeToDegraded(conversationEntity, userIds, type) {
    const isConversationDegraded = this._willChangeToDegraded(conversationEntity);
    if (isConversationDegraded) {
      /**
       * TEMPORARY DEBUGGING FIX:
       * We have seen conversations in a degraded state without an unverified device in there.
       * Previously the code would hide this fact, not create a system message and then fail when it tried to prompt
       * the user to grant subsequent message sending - essentially blocking the conversation.
       *
       * As we are unsure of the trigger of the degradation we temporarly throw an error to get to the bottom of this.
       * The conversation is also reset to the verified state to ensure we can continue to send messages.
       */
      if (!userIds.length) {
        conversationEntity.verification_state(z.conversation.ConversationVerificationState.VERIFIED);
        throw new Error('Conversation degraded without affected users');
      }

      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = z.conversation.EventBuilder.buildDegraded(conversationEntity, userIds, type, currentTimestamp);
      this.eventRepository.injectEvent(event);

      return true;
    }
  }

  /**
   * Get all conversation where self user and the given users are active.
   *
   * @private
   * @param {Array<string>} userIds - Multiple user IDs (can include self user ID)
   * @returns {Array<Object>} Array of objects containing the conversation entities and matching user IDs
   */
  _getActiveConversationsWithUsers(userIds) {
    return this.conversationRepository
      .filtered_conversations()
      .map(conversationEntity => {
        if (!conversationEntity.removed_from_conversation()) {
          const selfUserId = this.conversationRepository.selfUser().id;
          const userIdsInConversation = conversationEntity.participating_user_ids().concat(selfUserId);
          const matchingUserIds = _.intersection(userIdsInConversation, userIds);

          if (!!matchingUserIds.length) {
            return {conversationEntity, userIds: matchingUserIds};
          }
        }
      })
      .filter(activeConversationInfo => !!activeConversationInfo);
  }

  /**
   * Check whether to degrade conversation and set corresponding state.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to evaluate
   * @returns {boolean} Conversation changing to degraded
   */
  _willChangeToDegraded(conversationEntity) {
    const state = conversationEntity.verification_state();
    const isDegraded = state === z.conversation.ConversationVerificationState.DEGRADED;
    if (isDegraded) {
      return false;
    }

    // Explicit Boolean check to prevent state changes on undefined
    const isStateVerified = state === z.conversation.ConversationVerificationState.VERIFIED;
    const isConversationUnverified = conversationEntity.is_verified() === false;
    if (isStateVerified && isConversationUnverified) {
      conversationEntity.verification_state(z.conversation.ConversationVerificationState.DEGRADED);
      this.logger.log(`Verification of conversation '${conversationEntity.id}' changed to degraded`);
      return true;
    }

    return false;
  }

  /**
   * Check whether to verify conversation and set corresponding state
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to evaluate
   * @returns {boolean} Conversation changing to verified
   */
  _willChangeToVerified(conversationEntity) {
    const state = conversationEntity.verification_state();
    const isStateVerified = state === z.conversation.ConversationVerificationState.VERIFIED;
    if (isStateVerified) {
      return false;
    }

    // Explicit Boolean check to prevent state changes on undefined
    const isConversationVerified = conversationEntity.is_verified() === true;
    if (isConversationVerified) {
      conversationEntity.verification_state(z.conversation.ConversationVerificationState.VERIFIED);
      this.logger.log(`Verification state of conversation '${conversationEntity.id}' changed to verified`);
      return true;
    }

    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.EventBuilder = {
  build1to1Creation(conversationEntity, timestamp) {
    const {creator: creatorId, id} = conversationEntity;
    const isoDate = new Date(timestamp || 0).toISOString();

    return {
      conversation: id,
      data: {
        userIds: conversationEntity.participating_user_ids(),
      },
      from: creatorId,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.ONE2ONE_CREATION,
    };
  },
  buildAllVerified(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        type: z.message.VerificationMessageType.VERIFIED,
      },
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.VERIFICATION,
    };
  },
  buildAssetAdd(conversationEntity, data, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: data,
      from: conversationEntity.selfUser().id,
      status: z.message.StatusType.SENDING,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.ASSET_ADD,
    };
  },
  buildCalling(conversationEntity, callMessage, userId, clientId) {
    return {
      content: callMessage,
      conversation: conversationEntity.id,
      from: userId,
      sender: clientId,
      type: z.event.Client.CALL.E_CALL,
    };
  },
  buildDegraded(conversationEntity, userIds, type, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        type: type,
        userIds: userIds,
      },
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.VERIFICATION,
    };
  },
  buildDelete(conversationId, messageId, time, deletedMessageEntity) {
    return {
      conversation: conversationId,
      data: {
        deleted_time: time,
      },
      from: deletedMessageEntity.from,
      id: messageId,
      time: new Date(deletedMessageEntity.timestamp()).toISOString(),
      type: z.event.Client.CONVERSATION.DELETE_EVERYWHERE,
    };
  },
  buildGroupCreation(conversationEntity, isTemporaryGuest = false, timestamp) {
    const {creator: creatorId, id} = conversationEntity;
    const selfUserId = conversationEntity.selfUser().id;
    const isoDate = new Date(timestamp || 0).toISOString();

    const userIds = conversationEntity.participating_user_ids().slice();
    const createdBySelf = creatorId === selfUserId || isTemporaryGuest;
    if (!createdBySelf) {
      userIds.push(selfUserId);
    }

    return {
      conversation: id,
      data: {
        allTeamMembers: conversationEntity.withAllTeamMembers(),
        name: conversationEntity.name(),
        userIds: userIds,
      },
      from: isTemporaryGuest ? selfUserId : creatorId,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.GROUP_CREATION,
    };
  },
  buildIncomingMessageTooBig(event, messageError, errorCode) {
    const {conversation: conversationId, data: eventData, from, time} = event;

    return {
      conversation: conversationId,
      error: `${messageError.message} (${eventData.sender})`,
      error_code: `${errorCode} (${eventData.sender})`,
      from: from,
      id: z.util.createRandomUuid(),
      time: time,
      type: z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG,
    };
  },
  buildMemberJoin(conversationEntity, sender, joiningUserIds, timestamp) {
    timestamp = timestamp ? timestamp : conversationEntity.get_last_known_timestamp() + 1;
    const isoDate = new Date(timestamp).toISOString();

    return {
      conversation: conversationEntity.id,
      data: {
        user_ids: joiningUserIds,
      },
      from: sender,
      time: isoDate,
      type: z.event.Backend.CONVERSATION.MEMBER_JOIN,
    };
  },
  buildMemberLeave(conversationEntity, userId, removedBySelfUser, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        user_ids: [userId],
      },
      from: removedBySelfUser ? conversationEntity.selfUser().id : userId,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Backend.CONVERSATION.MEMBER_LEAVE,
    };
  },
  buildMessageAdd(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {},
      from: conversationEntity.selfUser().id,
      status: z.message.StatusType.SENDING,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.MESSAGE_ADD,
    };
  },
  buildMissed(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.MISSED_MESSAGES,
    };
  },
  buildTeamMemberLeave(conversationEntity, userEntity, isoDate) {
    return {
      conversation: conversationEntity.id,
      data: {
        name: userEntity.name(),
        user_ids: [userEntity.id],
      },
      from: userEntity.id,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
    };
  },
  buildUnableToDecrypt(event, decryptionError, errorCode) {
    const {conversation: conversationId, data: eventData, from, time} = event;

    return {
      conversation: conversationId,
      error: `${decryptionError.message} (${eventData.sender})`,
      error_code: `${errorCode} (${eventData.sender})`,
      from: from,
      id: z.util.createRandomUuid(),
      time: time,
      type: z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT,
    };
  },
  buildVoiceChannelActivate(callMessageEntity) {
    const {conversationId, userId, time} = callMessageEntity;

    return {
      conversation: conversationId,
      from: userId,
      id: z.util.createRandomUuid(),
      protocol_version: z.calling.CallingRepository.CONFIG.PROTOCOL_VERSION,
      time: time,
      type: z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE,
    };
  },
  buildVoiceChannelDeactivate(callMessageEntity, reason, currentTimestamp = 0) {
    const {conversationId, userId} = callMessageEntity;
    const time = callMessageEntity.time || new Date(currentTimestamp).toISOString();

    return {
      conversation: conversationId,
      data: {
        reason: reason || z.calling.enum.TERMINATION_REASON.COMPLETED,
      },
      from: userId,
      id: z.util.createRandomUuid(),
      protocol_version: z.calling.CallingRepository.CONFIG.PROTOCOL_VERSION,
      time: time,
      type: z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE,
    };
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.EventInfoEntity = class EventInfoEntity {
  /**
   * Constructs a new event info entity.
   * @class z.conversation.EventInfoEntity
   * @param {z.proto.GenericMessage} [genericMessage] - Generic message
   * @param {string} [conversationId=''] - Conversation ID
   * @param {Object} options - Message sending options
   * @param {Array<string>|boolean} [options.nativePush=true] - Send native push notification for message
   * @param {Array<string>|boolean} [options.precondition=false] - Level that backend checks for missing clients
   * @param {Object} [options.recipients={}] - Message recipients
   * @param {number} timestamp - Timestamp of optimistic event
   */
  constructor(genericMessage, conversationId = '', options) {
    this.conversationId = conversationId;
    this.genericMessage = genericMessage;

    this.options = Object.assign({nativePush: true, precondition: false}, options);

    this.timestamp = undefined;
    this.type = undefined;
  }

  forceSending() {
    this.options.precondition = true;
  }

  getType() {
    return this.type ? this.type : this.genericMessage && this.genericMessage.content;
  }

  setTimestamp(time) {
    this.timestamp = new Date(time).getTime();
  }

  setType(type) {
    this.type = type;
  }

  updateOptions(updatedOptions) {
    this.options = Object.assign(this.options, updatedOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Event Mapper to convert all server side JSON events into core entities.
z.conversation.EventMapper = class EventMapper {
  /**
   * Construct a new Event Mapper.
   */
  constructor() {
    this.logger = new z.util.Logger('z.conversation.EventMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Convert multiple JSON events into message entities.
   *
   * @param {Array} events - Event data
   * @param {Conversation} conversationEntity - Conversation entity the events belong to
   * @param {boolean} [createDummyImage] - Create a dummy image
   * @returns {Promise<Array<Message>>} Resolves with the mapped message entities
   */
  mapJsonEvents(events, conversationEntity, createDummyImage) {
    return Promise.resolve().then(() => {
      return events
        .filter(event => event)
        .reverse()
        .map(event => {
          try {
            return this._mapJsonEvent(event, conversationEntity, createDummyImage);
          } catch (error) {
            const errorMessage = `Failure while mapping events. Affected '${event.type}' event: ${error.message}`;
            this.logger.error(errorMessage, {error, event});

            const customData = {eventTime: new Date(event.time).toISOString(), eventType: event.type};
            Raygun.send(new Error(errorMessage), customData);
          }
        })
        .filter(messageEntity => messageEntity);
    });
  }

  /**
   * Convert JSON event into a message entity.
   *
   * @param {Object} event - Event data
   * @param {Conversation} conversationEntity - Conversation entity the event belong to
   * @param {boolean} [createDummyImage] - Create a dummy image
   * @returns {Promise} Resolves with the mapped message entity
   */
  mapJsonEvent(event, conversationEntity, createDummyImage) {
    return Promise.resolve()
      .then(() => this._mapJsonEvent(event, conversationEntity, createDummyImage))
      .catch(error => {
        const isMessageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (isMessageNotFound) {
          throw error;
        }
        const errorMessage = `Failure while mapping events. Affected '${event.type}' event: ${error.message}`;
        this.logger.error(errorMessage, {error, event});

        const customData = {eventTime: new Date(event.time).toISOString(), eventType: event.type};
        Raygun.send(new Error(errorMessage), customData);

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
      });
  }

  /**
   * Convert JSON event into a message entity.
   *
   * @param {Object} event - Event data
   * @param {Conversation} conversationEntity - Conversation entity the event belong to
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {Message} Mapped message entity
   */
  _mapJsonEvent(event, conversationEntity, createDummyImage) {
    let messageEntity;

    switch (event.type) {
      case z.event.Backend.CONVERSATION.MEMBER_JOIN: {
        messageEntity = this._mapEventMemberJoin(event, conversationEntity);
        break;
      }

      case z.event.Backend.CONVERSATION.MEMBER_LEAVE: {
        messageEntity = this._mapEventMemberLeave(event);
        break;
      }

      case z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE: {
        messageEntity = this._mapEventMessageTimerUpdate(event);
        break;
      }

      case z.event.Backend.CONVERSATION.RENAME: {
        messageEntity = this._mapEventRename(event);
        break;
      }

      case z.event.Client.CONVERSATION.ASSET_ADD: {
        messageEntity = this._mapEventAssetAdd(event, createDummyImage);
        break;
      }

      case z.event.Client.CONVERSATION.DELETE_EVERYWHERE: {
        messageEntity = this._mapEventDeleteEverywhere(event);
        break;
      }

      case z.event.Client.CONVERSATION.GROUP_CREATION: {
        messageEntity = this._mapEventGroupCreation(event);
        break;
      }

      case z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:
      case z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT: {
        messageEntity = this._mapEventUnableToDecrypt(event);
        break;
      }

      case z.event.Client.CONVERSATION.KNOCK: {
        messageEntity = this._mapEventPing();
        break;
      }

      case z.event.Client.CONVERSATION.LOCATION: {
        messageEntity = this._mapEventLocation(event);
        break;
      }

      case z.event.Client.CONVERSATION.MESSAGE_ADD: {
        messageEntity = this._mapEventMessageAdd(event);
        break;
      }

      case z.event.Client.CONVERSATION.MISSED_MESSAGES: {
        messageEntity = this._mapEventMissedMessages();
        break;
      }

      case z.event.Client.CONVERSATION.ONE2ONE_CREATION: {
        messageEntity = this._mapEvent1to1Creation(event);
        break;
      }

      case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE: {
        messageEntity = this._mapEventTeamMemberLeave(event);
        break;
      }

      case z.event.Client.CONVERSATION.VERIFICATION: {
        messageEntity = this._mapEventVerification(event);
        break;
      }

      case z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE: {
        messageEntity = this._mapEventVoiceChannelActivate();
        break;
      }

      case z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE: {
        messageEntity = this._mapEventVoiceChannelDeactivate(event);
        break;
      }

      default: {
        this.logger.warn(`Ignored unhandled '${event.type}' event ${event.id ? `'${event.id}' ` : ''}`, event);
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
      }
    }

    const {category, from, id, primary_key, time, type, version} = event;

    messageEntity.category = category;
    messageEntity.conversation_id = conversationEntity.id;
    messageEntity.from = from;
    messageEntity.id = id;
    messageEntity.primary_key = primary_key;
    messageEntity.timestamp(new Date(time).getTime());
    messageEntity.type = type;
    messageEntity.version = version || 1;

    if (messageEntity.is_content() || messageEntity.is_ping()) {
      messageEntity.status(event.status || z.message.StatusType.SENT);
    }

    if (messageEntity.isReactable()) {
      messageEntity.reactions(event.reactions || {});
    }

    if (event.ephemeral_expires) {
      messageEntity.ephemeral_expires(event.ephemeral_expires);
      messageEntity.ephemeral_started(event.ephemeral_started || '0');
    }

    if (window.isNaN(messageEntity.timestamp())) {
      this.logger.warn(`Could not get timestamp for message '${messageEntity.id}'. Skipping it.`, event);
      messageEntity = undefined;
    }

    return messageEntity;
  }

  //##############################################################################
  // Event mappers
  //##############################################################################

  /**
   * Maps JSON data of conversation.one2one-creation message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {ContentMessage} Member message entity
   */
  _mapEvent1to1Creation({data: eventData}) {
    const {has_service: hasService, userIds} = eventData;

    const messageEntity = new z.entity.MemberMessage();
    messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_ACCEPTED;
    messageEntity.userIds(userIds);

    if (hasService) {
      messageEntity.showServicesWarning = true;
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.asset_add message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {ContentMessage} Content message entity
   */
  _mapEventAssetAdd(event, createDummyImage) {
    const eventData = event.data;
    const messageEntity = new z.entity.ContentMessage();

    const assetInfo = eventData.info;
    const isMediumImage = assetInfo && assetInfo.tag === 'medium';
    const assetEntity = isMediumImage ? this._mapAssetImage(event, createDummyImage) : this._mapAssetFile(event);
    messageEntity.assets.push(assetEntity);

    return messageEntity;
  }

  /**
   * Maps JSON data of delete everywhere event to message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {DeleteMessage} Delete message entity
   */
  _mapEventDeleteEverywhere({data: eventData}) {
    const messageEntity = new z.entity.DeleteMessage();
    messageEntity.deleted_timestamp = new Date(eventData.deleted_time).getTime();
    return messageEntity;
  }

  /**
   * Map JSON ata of group creation event to message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventGroupCreation({data: eventData}) {
    const messageEntity = new z.entity.MemberMessage();
    messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_CREATE;
    messageEntity.name(eventData.name || '');
    messageEntity.userIds(eventData.userIds);
    messageEntity.allTeamMembers = eventData.allTeamMembers;
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.location message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {ContentMessage} Location message entity
   */
  _mapEventLocation({data: eventData}) {
    const location = eventData.location;
    const messageEntity = new z.entity.ContentMessage();
    const assetEntity = new z.entity.Location();

    assetEntity.longitude = location.longitude;
    assetEntity.latitude = location.latitude;
    assetEntity.name = location.name;
    assetEntity.zoom = location.zoom;

    messageEntity.assets.push(assetEntity);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.member_join message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @param {z.entity.Conversation} conversationEntity - Conversation entity the event belong to
   * @returns {MemberMessage} Member message entity
   */
  _mapEventMemberJoin(event, conversationEntity) {
    const {data: eventData, from: sender} = event;
    const {has_service: hasService, user_ids: userIds} = eventData;

    const messageEntity = new z.entity.MemberMessage();

    const isSingleModeConversation = conversationEntity.is1to1() || conversationEntity.isRequest();
    messageEntity.visible(!isSingleModeConversation);

    if (conversationEntity.isGroup()) {
      const messageFromCreator = sender === conversationEntity.creator;
      const creatorIndex = userIds.indexOf(sender);
      const creatorIsJoiningMember = messageFromCreator && creatorIndex !== -1;

      if (creatorIsJoiningMember) {
        userIds.splice(creatorIndex, 1);
        messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_CREATE;
      }

      if (hasService) {
        messageEntity.showServicesWarning = true;
      }

      messageEntity.userIds(userIds);
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.member_leave message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventMemberLeave({data: eventData}) {
    const messageEntity = new z.entity.MemberMessage();
    messageEntity.userIds(eventData.user_ids);
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.message_add message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @returns {ContentMessage} Content message entity
   */
  _mapEventMessageAdd(event) {
    const {data: eventData, edited_time: editedTime} = event;
    const messageEntity = new z.entity.ContentMessage();

    messageEntity.assets.push(this._mapAssetText(eventData));
    messageEntity.replacing_message_id = eventData.replacing_message_id;
    messageEntity.edited_timestamp = new Date(editedTime || eventData.edited_time).getTime();

    if (eventData.quote) {
      const {message_id: messageId, user_id: userId, error} = eventData.quote;
      messageEntity.quote(new z.message.QuoteEntity({error, messageId, userId}));
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of local missed message event to message entity.
   * @private
   * @returns {MissedMessage} Missed message entity
   */
  _mapEventMissedMessages() {
    return new z.entity.MissedMessage();
  }

  /**
   * Maps JSON data of conversation.knock message into message entity.
   * @private
   * @returns {PingMessage} Ping message entity
   */
  _mapEventPing() {
    return new z.entity.PingMessage();
  }

  /**
   * Maps JSON data of conversation.rename message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {RenameMessage} Rename message entity
   */
  _mapEventRename({data: eventData}) {
    const messageEntity = new z.entity.RenameMessage();
    messageEntity.name = eventData.name;
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.message-timer-update message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MessageTimerUpdateMessage} message timer update message entity
   */
  _mapEventMessageTimerUpdate({data: eventData}) {
    return new z.entity.MessageTimerUpdateMessage(eventData.message_timer);
  }

  /**
   * Maps JSON data of conversation.team_leave message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventTeamMemberLeave(event) {
    const messageEntity = this._mapEventMemberLeave(event);
    const eventData = event.data;
    messageEntity.name(eventData.name || z.l10n.text(z.string.conversationSomeone));
    return messageEntity;
  }

  /**
   * Maps JSON data of local decrypt errors to message entity.
   *
   * @private
   * @param {Object} error_code - Error data received as JSON
   * @returns {DecryptErrorMessage} Decrypt error message entity
   */
  _mapEventUnableToDecrypt({error_code: errorCode}) {
    const messageEntity = new z.entity.DecryptErrorMessage();

    if (errorCode) {
      const [code] = errorCode.split(' ');
      messageEntity.error_code = code;
      messageEntity.client_id = errorCode.substring(code.length + 1).replace(/[()]/g, '');
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.verification message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {VerificationMessage} Verification message entity
   */
  _mapEventVerification({data: eventData}) {
    const messageEntity = new z.entity.VerificationMessage();

    // Database can contain non-camelCased naming. For backwards compatibility reasons we handle both.
    messageEntity.userIds(eventData.userIds || eventData.user_ids);
    messageEntity.verificationMessageType(eventData.type);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.voice-channel-activate message into message entity.
   * @private
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  _mapEventVoiceChannelActivate() {
    const messageEntity = new z.entity.CallMessage();

    messageEntity.call_message_type = z.message.CALL_MESSAGE_TYPE.ACTIVATED;
    messageEntity.visible(false);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.voice-channel-deactivate message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  _mapEventVoiceChannelDeactivate({data: eventData}) {
    const messageEntity = new z.entity.CallMessage();

    messageEntity.call_message_type = z.message.CALL_MESSAGE_TYPE.DEACTIVATED;
    messageEntity.finished_reason = eventData.reason;
    messageEntity.visible(messageEntity.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED);

    return messageEntity;
  }

  //##############################################################################
  // Asset mappers
  //##############################################################################

  _createDummyImage(width, height) {
    return `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${width} ${height}' width='${width}' height='${height}'></svg>`;
  }

  /**
   * Maps JSON data of file asset into asset entity.
   *
   * @private
   * @param {Object} event - Asset data received as JSON
   * @returns {File} File asset entity
   */
  _mapAssetFile(event) {
    const {conversation: conversationId, data: eventData} = event;
    const {content_length, content_type, id, info, meta, status} = eventData;

    const assetEntity = new z.entity.File(id);

    assetEntity.conversationId = conversationId;

    // Original
    assetEntity.file_size = content_length;
    assetEntity.file_type = content_type;
    assetEntity.meta = meta;

    // info
    if (info) {
      const {correlation_id, name} = info;
      assetEntity.correlation_id = correlation_id;
      assetEntity.file_name = name;
    }

    // Remote data - full
    const {key, otr_key, sha256, token} = eventData;
    const remoteData = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token)
      : z.assets.AssetRemoteData.v2(conversationId, id, otr_key, sha256);
    assetEntity.original_resource(remoteData);

    // Remote data - preview
    const {preview_id, preview_key, preview_otr_key, preview_sha256, preview_token} = eventData;
    if (preview_otr_key) {
      const remoteDataPreview = preview_key
        ? z.assets.AssetRemoteData.v3(preview_key, preview_otr_key, preview_sha256, preview_token, true)
        : z.assets.AssetRemoteData.v2(conversationId, preview_id, preview_otr_key, preview_sha256, true);
      assetEntity.preview_resource(remoteDataPreview);
    }

    assetEntity.status(status || z.assets.AssetTransferState.UPLOADING);

    return assetEntity;
  }

  /**
   * Maps JSON data of medium image asset into asset entity.
   *
   * @private
   * @param {Object} event - Asset data received as JSON
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {z.entity.MediumImage} Medium image asset entity
   */
  _mapAssetImage(event, createDummyImage) {
    const {data: eventData, conversation: conversationId} = event;
    const {content_length, content_type, id: assetId, info} = eventData;
    const assetEntity = new z.entity.MediumImage(assetId);

    assetEntity.file_size = content_length;
    assetEntity.file_type = content_type;
    assetEntity.ratio = assetEntity.height / assetEntity.width;

    if (info) {
      const {height, width} = info;
      assetEntity.width = width;
      assetEntity.height = height;
    }

    const {key, otr_key, sha256, token} = eventData;

    const remoteData = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token, true)
      : z.assets.AssetRemoteData.v2(conversationId, assetId, otr_key, sha256, true);
    assetEntity.resource(remoteData);

    if (createDummyImage) {
      assetEntity.dummy_url = this._createDummyImage(assetEntity.width, assetEntity.height);
    }

    return assetEntity;
  }

  /**
   * Map link preview from proto message.
   *
   * @private
   * @param {z.proto.LinkPreview} linkPreview - Link preview proto message
   * @returns {LinkPreview} Mapped link preview
   */
  _mapAssetLinkPreview(linkPreview) {
    if (linkPreview) {
      const {image, title, url, meta_data} = linkPreview;
      const {image: article_image, title: article_title} = linkPreview.article || {};

      const linkPreviewEntity = new z.entity.LinkPreview(title || article_title, url);
      linkPreviewEntity.meta_data_type = meta_data;
      linkPreviewEntity.meta_data = linkPreview[meta_data];

      const previewImage = image || article_image;
      if (previewImage && previewImage.uploaded) {
        const {asset_token, asset_id: asset_key} = previewImage.uploaded;

        if (asset_key) {
          let {otr_key, sha256} = previewImage.uploaded;

          otr_key = new Uint8Array(otr_key.toArrayBuffer());
          sha256 = new Uint8Array(sha256.toArrayBuffer());

          linkPreviewEntity.image_resource(z.assets.AssetRemoteData.v3(asset_key, otr_key, sha256, asset_token, true));
        }
      }

      return linkPreviewEntity;
    }
  }

  /**
   * Map link previews from proto messages.
   *
   * @private
   * @param {Array} linkPreviews - Link previews as base64 encoded proto messages
   * @returns {Array<LinkPreview>} Array of mapped link previews
   */
  _mapAssetLinkPreviews(linkPreviews) {
    return linkPreviews
      .map(encodedLinkPreview => z.proto.LinkPreview.decode64(encodedLinkPreview))
      .map(linkPreview => this._mapAssetLinkPreview(linkPreview))
      .filter(linkPreviewEntity => linkPreviewEntity);
  }

  /**
   * Map mentions from proto messages.
   *
   * @private
   * @param {Array} mentions - Mentions as base64 encoded proto messages
   * @param {string} messageText - Text of message
   * @returns {Array<z.message.MentionEntity>} Array of mapped mentions
   */
  _mapAssetMentions(mentions, messageText) {
    return mentions
      .map(encodedMention => {
        const protoMention = z.proto.Mention.decode64(encodedMention);
        return new z.message.MentionEntity(protoMention.start, protoMention.length, protoMention.user_id);
      })
      .filter(mentionEntity => {
        if (mentionEntity) {
          try {
            return mentionEntity.validate(messageText);
          } catch (error) {
            this.logger.warn(`Removed invalid mention when mapping message: ${error.message}`, mentionEntity);
            return false;
          }
        }
      });
  }

  /**
   * Maps JSON data of text asset into asset entity.
   *
   * @private
   * @param {Object} eventData - Asset data received as JSON
   * @returns {Text} Text asset entity
   */
  _mapAssetText(eventData) {
    const {id, content, mentions, message, previews} = eventData;
    const messageText = content || message;
    const assetEntity = new z.entity.Text(id, messageText);

    if (mentions && mentions.length) {
      assetEntity.mentions(this._mapAssetMentions(mentions, messageText));
    }
    if (previews && previews.length) {
      assetEntity.previews(this._mapAssetLinkPreviews(previews));
    }

    return assetEntity;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.NotificationSetting = {
  /* eslint-disable sort-keys */

  STATE: {
    EVERYTHING: 0b00,
    MENTIONS_AND_REPLIES: 0b01,
    NOTHING: 0b11,
  },

  /* eslint-enable sort-keys */

  getText(status) {
    const statusTexts = {
      [z.conversation.NotificationSetting.STATE.EVERYTHING]: z.string.notificationSettingsEverything,
      [z.conversation.NotificationSetting.STATE.MENTIONS_AND_REPLIES]: z.string.notificationSettingsMentionsAndReplies,
      [z.conversation.NotificationSetting.STATE.NOTHING]: z.string.notificationSettingsNothing,
    };
    return z.l10n.text(statusTexts[status]);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyMapper = class CryptographyMapper {
  static get CONFIG() {
    return {
      MAX_MENTIONS_PER_MESSAGE: 500,
    };
  }

  // Construct a new CryptographyMapper.
  constructor() {
    this.logger = new z.util.Logger('z.cryptography.CryptographyMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Maps a generic message into an event in JSON.
   *
   * @param {z.proto.GenericMessage} genericMessage - Received ProtoBuffer message
   * @param {JSON} event - Event of z.event.Backend.CONVERSATION.OTR-ASSET-ADD or z.event.Backend.CONVERSATION.OTR-MESSAGE-ADD
   * @returns {Promise} Resolves with the mapped event
   */
  mapGenericMessage(genericMessage, event) {
    if (!genericMessage) {
      return Promise.reject(new z.error.CryptographyError(z.error.CryptographyError.TYPE.NO_GENERIC_MESSAGE));
    }

    return Promise.resolve()
      .then(() => (genericMessage.external ? this._unwrapExternal(genericMessage.external, event) : genericMessage))
      .then(unwrappedGenericMessage => this._mapGenericMessage(unwrappedGenericMessage, event));
  }

  _mapGenericMessage(genericMessage, event) {
    let specificContent;

    switch (genericMessage.content) {
      case z.cryptography.GENERIC_MESSAGE_TYPE.ASSET: {
        specificContent = this._mapAsset(genericMessage.asset);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.AVAILABILITY: {
        specificContent = this._mapAvailability(genericMessage.availability);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CALLING: {
        specificContent = this._mapCalling(genericMessage.calling, event.data);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CLEARED: {
        specificContent = this._mapCleared(genericMessage.cleared);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CONFIRMATION: {
        specificContent = this._mapConfirmation(genericMessage.confirmation);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.DELETED: {
        specificContent = this._mapDeleted(genericMessage.deleted);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.EDITED: {
        specificContent = this._mapEdited(genericMessage.edited, genericMessage.message_id);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL: {
        specificContent = this._mapEphemeral(genericMessage, event);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.HIDDEN: {
        specificContent = this._mapHidden(genericMessage.hidden);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.IMAGE: {
        specificContent = this._mapImage(genericMessage.image, event.data.id);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.KNOCK: {
        specificContent = this._mapKnock();
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.LAST_READ: {
        specificContent = this._mapLastRead(genericMessage.lastRead);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.LOCATION: {
        specificContent = this._mapLocation(genericMessage.location);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.REACTION: {
        specificContent = this._mapReaction(genericMessage.reaction);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.TEXT: {
        specificContent = this._mapText(genericMessage.text);
        break;
      }

      default: {
        const logMessage = `Skipped event '${genericMessage.message_id}' of unhandled type '${genericMessage.content}'`;
        this.logger.debug(logMessage, {event, generic_message: genericMessage});
        throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
      }
    }

    const genericContent = {
      conversation: event.conversation,
      from: event.from,
      id: genericMessage.message_id,
      status: event.status,
      time: event.time,
    };

    return Object.assign(genericContent, specificContent);
  }

  _mapAsset(asset) {
    const {original, preview, uploaded, not_uploaded: notUploaded} = asset;
    let data = {};

    if (original) {
      data = {
        content_length: original.size.toNumber(),
        content_type: original.mime_type,
        info: {
          name: original.name,
        },
      };

      if (original.image) {
        data.info.height = original.image.height;
        data.info.width = original.image.width;
      } else {
        data.meta = this._mapAssetMetaData(original);
      }
    }

    if (preview) {
      const remote = preview.remote;

      data = Object.assign(data, {
        preview_key: remote.asset_id,
        preview_otr_key: new Uint8Array(remote.otr_key.toArrayBuffer()),
        preview_sha256: new Uint8Array(remote.sha256.toArrayBuffer()),
        preview_token: remote.asset_token,
      });
    }

    const isImage = uploaded && uploaded.asset_id && original && original.image;
    if (isImage) {
      data.info.tag = 'medium';
    }

    if (uploaded !== null) {
      data = Object.assign(data, {
        key: uploaded.asset_id,
        otr_key: new Uint8Array(uploaded.otr_key.toArrayBuffer()),
        sha256: new Uint8Array(uploaded.sha256.toArrayBuffer()),
        status: z.assets.AssetTransferState.UPLOADED,
        token: uploaded.asset_token,
      });
    }

    if (notUploaded !== null) {
      data = Object.assign(data, {
        reason: notUploaded,
        status: z.assets.AssetTransferState.UPLOAD_FAILED,
      });
    }

    return {data, type: z.event.Client.CONVERSATION.ASSET_ADD};
  }

  _mapAssetMetaData(original) {
    const audioData = original.audio;
    if (audioData) {
      const loudnessArray = audioData.normalized_loudness ? audioData.normalized_loudness.toArrayBuffer() : [];
      const durationInSeconds = audioData.duration_in_millis
        ? audioData.duration_in_millis / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND
        : 0;

      return {
        duration: durationInSeconds,
        loudness: new Uint8Array(loudnessArray),
      };
    }
  }

  _mapAvailability(availability) {
    return {
      data: {
        availability: (() => {
          switch (availability.type) {
            case z.proto.Availability.Type.NONE:
              return z.user.AvailabilityType.NONE;
            case z.proto.Availability.Type.AVAILABLE:
              return z.user.AvailabilityType.AVAILABLE;
            case z.proto.Availability.Type.AWAY:
              return z.user.AvailabilityType.AWAY;
            case z.proto.Availability.Type.BUSY:
              return z.user.AvailabilityType.BUSY;
            default:
              const message = 'Unhandled availability type';
              throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE, message);
          }
        })(),
      },
      type: z.event.Client.USER.AVAILABILITY,
    };
  }

  _mapCalling(calling, eventData) {
    return {
      content: JSON.parse(calling.content),
      sender: eventData.sender,
      type: z.event.Client.CALL.E_CALL,
    };
  }

  _mapCleared(cleared) {
    return {
      data: {
        cleared_timestamp: cleared.cleared_timestamp.toString(),
        conversationId: cleared.conversation_id,
      },
      type: z.event.Backend.CONVERSATION.MEMBER_UPDATE,
    };
  }

  _mapConfirmation(confirmation) {
    return {
      data: {
        message_id: confirmation.first_message_id,
        status: (() => {
          switch (confirmation.type) {
            case z.proto.Confirmation.Type.DELIVERED:
              return z.message.StatusType.DELIVERED;
            case z.proto.Confirmation.Type.READ:
              return z.message.StatusType.SEEN;
            default:
              const message = 'Unhandled confirmation type';
              throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE, message);
          }
        })(),
      },
      type: z.event.Client.CONVERSATION.CONFIRMATION,
    };
  }

  _mapDeleted(deleted) {
    return {
      data: {
        message_id: deleted.message_id,
      },
      type: z.event.Client.CONVERSATION.MESSAGE_DELETE,
    };
  }

  _mapEdited(edited, eventId) {
    const mappedMessage = this._mapText(edited.text, eventId);
    mappedMessage.data.replacing_message_id = edited.replacing_message_id;
    return mappedMessage;
  }

  _mapEphemeral(genericMessage, event) {
    const messageTimer = genericMessage.ephemeral.expire_after_millis.toNumber();
    genericMessage.ephemeral.message_id = genericMessage.message_id;

    const embeddedMessage = this._mapGenericMessage(genericMessage.ephemeral, event);
    embeddedMessage.ephemeral_expires = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    return embeddedMessage;
  }

  /**
   * Unpacks a specific generic message which is wrapped inside an external generic message.
   *
   * @note Wrapped messages get the 'message_id' of their wrappers (external message)
   * @param {z.proto.External} external - Generic message of type 'external'
   * @param {JSON} event - Backend event of type 'conversation.otr-message-add'
   * @returns {Promise} Resolves with generic message
   */
  _unwrapExternal(external, event) {
    return Promise.resolve(external)
      .then(({otr_key: otrKey, sha256}) => {
        const eventData = event.data;
        if (!eventData.data || !otrKey || !sha256) {
          throw new Error('Not all expected properties defined');
        }

        const cipherText = z.util.base64ToArray(eventData.data).buffer;
        const keyBytes = new Uint8Array(otrKey.toArrayBuffer()).buffer;
        const referenceSha256 = new Uint8Array(sha256.toArrayBuffer()).buffer;

        return z.assets.AssetCrypto.decryptAesAsset(cipherText, keyBytes, referenceSha256);
      })
      .then(externalMessageBuffer => z.proto.GenericMessage.decode(externalMessageBuffer))
      .catch(error => {
        this.logger.error(`Failed to unwrap external message: ${error.message}`, error);
        throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.BROKEN_EXTERNAL);
      });
  }

  _mapHidden(hidden) {
    return {
      data: {
        conversation_id: hidden.conversation_id,
        message_id: hidden.message_id,
      },
      type: z.event.Client.CONVERSATION.MESSAGE_HIDDEN,
    };
  }

  _mapImage(image, eventId) {
    const isMediumImage = image.tag === 'medium';
    if (isMediumImage) {
      return this._mapImageMedium(image, eventId);
    }

    this.logger.info(`Skipped event '${eventId}': ${z.error.CryptographyError.MESSAGE.IGNORED_PREVIEW}`);
    throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.IGNORED_PREVIEW);
  }

  _mapImageMedium(image, eventId) {
    // set ID even if asset id is missing
    eventId = eventId || z.util.createRandomUuid();

    return {
      data: {
        content_length: image.size,
        content_type: image.mime_type,
        id: eventId,
        info: {
          height: image.height,
          tag: image.tag,
          width: image.width,
        },
        otr_key: new Uint8Array(image.otr_key ? image.otr_key.toArrayBuffer() : []),
        sha256: new Uint8Array(image.sha256 ? image.sha256.toArrayBuffer() : []),
      },
      type: z.event.Client.CONVERSATION.ASSET_ADD,
    };
  }

  _mapKnock() {
    return {type: z.event.Client.CONVERSATION.KNOCK};
  }

  _mapLastRead(lastRead) {
    return {
      data: {
        conversationId: lastRead.conversation_id,
        last_read_timestamp: lastRead.last_read_timestamp.toString(),
      },
      type: z.event.Backend.CONVERSATION.MEMBER_UPDATE,
    };
  }

  _mapLocation(location) {
    return {
      data: {
        location: {
          latitude: location.latitude,
          longitude: location.longitude,
          name: location.name,
          zoom: location.zoom,
        },
      },
      type: z.event.Client.CONVERSATION.LOCATION,
    };
  }

  _mapReaction(reaction) {
    return {
      data: {
        message_id: reaction.message_id,
        reaction: reaction.emoji,
      },
      type: z.event.Client.CONVERSATION.REACTION,
    };
  }

  _mapText(text) {
    const {link_preview: protoLinkPreviews, mentions: protoMentions, quote: protoQuote} = text;

    if (protoMentions && protoMentions.length > CryptographyMapper.CONFIG.MAX_MENTIONS_PER_MESSAGE) {
      this.logger.warn(`Message contains '${protoMentions.length}' mentions exceeding limit`, text);
      protoMentions.length = CryptographyMapper.CONFIG.MAX_MENTIONS_PER_MESSAGE;
    }

    return {
      data: {
        content: `${text.content}`,
        mentions: protoMentions.map(protoMention => protoMention.encode64()),
        previews: protoLinkPreviews.map(protoLinkPreview => protoLinkPreview.encode64()),
        quote: protoQuote && protoQuote.encode64(),
      },
      type: z.event.Client.CONVERSATION.MESSAGE_ADD,
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyRepository = class CryptographyRepository {
  static get CONFIG() {
    return {
      UNKNOWN_DECRYPTION_ERROR_CODE: 999,
    };
  }

  static get REMOTE_ENCRYPTION_FAILURE() {
    return '';
  }

  /**
   * Construct a new Cryptography repository.
   * @param {z.cryptography.CryptographyService} cryptographyService - Backend REST API cryptography service implementation
   * @param {z.storage.StorageRepository} storageRepository - Repository for all storage interactions
   */
  constructor(cryptographyService, storageRepository) {
    this.cryptographyService = cryptographyService;
    this.storageRepository = storageRepository;
    this.logger = new z.util.Logger('z.cryptography.CryptographyRepository', z.config.LOGGER.OPTIONS);

    this.cryptographyMapper = new z.cryptography.CryptographyMapper();

    this.currentClient = undefined;
    this.cryptobox = undefined;
  }

  /**
   * Initializes the repository by loading an existing Cryptobox.
   * @param {Object} database - Database object
   * @returns {Promise} Resolves after initialization
   */
  createCryptobox(database) {
    return this._init(database).then(() => this.cryptobox.create());
  }

  /**
   * Initializes the repository by creating a new Cryptobox.
   * @param {Object} database - Database object
   * @returns {Promise} Resolves after initialization
   */
  loadCryptobox(database) {
    return this._init(database).then(() => this.cryptobox.load());
  }

  resetCryptobox(clientEntity) {
    const deleteEverything = clientEntity ? clientEntity.isTemporary() : false;
    const deletePromise = deleteEverything
      ? this.storageRepository.deleteDatabase()
      : this.storageRepository.deleteCryptographyStores();

    return deletePromise
      .catch(databaseError => {
        const message = `Failed cryptography-related db deletion on client validation error: ${databaseError.message}`;
        this.logger.error(message, databaseError);
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(() => deleteEverything);
  }

  /**
   * Initialize the repository.
   *
   * @private
   * @param {Object} database - Dexie instance
   * @returns {Promise} Resolves after initialization
   */
  _init(database) {
    return Promise.resolve().then(() => {
      this.logger.info(`Initializing Cryptobox with database '${database.name}'...`);
      const storeEngine = new StoreEngine.IndexedDBEngine();
      storeEngine.initWithDb(database);
      this.cryptobox = new cryptobox.Cryptobox(storeEngine, 10);

      this.cryptobox.on(cryptobox.Cryptobox.TOPIC.NEW_PREKEYS, preKeys => {
        const serializedPreKeys = preKeys.map(preKey => this.cryptobox.serialize_prekey(preKey));

        this.logger.log(`Received '${preKeys.length}' new PreKeys.`, serializedPreKeys);
        return this.cryptographyService.putClientPreKeys(this.currentClient().id, serializedPreKeys).then(() => {
          this.logger.log(`Successfully uploaded '${serializedPreKeys.length}' PreKeys.`, serializedPreKeys);
        });
      });

      this.cryptobox.on(cryptobox.Cryptobox.TOPIC.NEW_SESSION, sessionId => {
        const {userId, clientId} = z.client.ClientEntity.dismantleUserClientId(sessionId);
        amplify.publish(z.event.WebApp.CLIENT.ADD, userId, {id: clientId}, true);
      });
    });
  }

  /**
   * Generate all keys needed for client registration.
   * @returns {Promise} Resolves with an array of last resort key, pre-keys, and signaling keys
   */
  generateClientKeys() {
    return Promise.all([
      this.cryptobox.get_serialized_last_resort_prekey(),
      this.cryptobox.get_serialized_standard_prekeys(),
      this._generateSignalingKeys(),
    ]).catch(error => {
      throw new Error(`Failed to generate client keys: ${error.message}`);
    });
  }

  /**
   * Get the fingerprint of the local identity.
   * @returns {string} Fingerprint of local identity public key
   */
  getLocalFingerprint() {
    return this._formatFingerprint(this.cryptobox.identity.public_key.fingerprint());
  }

  /**
   * Get the fingerprint of a remote identity.
   * @param {string} userId - ID of user
   * @param {string} clientId - ID of client
   * @returns {Promise} Resolves with the remote fingerprint
   */
  getRemoteFingerprint(userId, clientId) {
    return this._loadSession(userId, clientId).then(cryptoboxSession => {
      return cryptoboxSession ? this._formatFingerprint(cryptoboxSession.fingerprint_remote()) : '';
    });
  }

  _formatFingerprint(fingerprint) {
    return z.util.zeroPadding(fingerprint, 16).match(/.{1,2}/g) || [];
  }

  /**
   * Get a pre-key for the given client of the user.
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @returns {Promise} Resolves with a map of pre-keys for the requested clients
   */
  getUserPreKeyByIds(userId, clientId) {
    return this.cryptographyService
      .getUserPreKeyByIds(userId, clientId)
      .then(response => response.prekey)
      .catch(error => {
        const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (isNotFound) {
          throw new z.error.UserError(z.error.UserError.TYPE.PRE_KEY_NOT_FOUND);
        }

        this.logger.error(`Failed to get pre-key from backend: ${error.message}`);
        throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
      });
  }

  /**
   * Get a pre-key for each client in the user client map.
   * @param {Object} recipients - User client map to request pre-keys for
   * @returns {Promise} Resolves with a map of pre-keys for the requested clients
   */
  getUsersPreKeys(recipients) {
    return this.cryptographyService.getUsersPreKeys(recipients).catch(error => {
      const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
      if (isNotFound) {
        throw new z.error.UserError(z.error.UserError.TYPE.PRE_KEY_NOT_FOUND);
      }

      this.logger.error(`Failed to get pre-key from backend: ${error.message}`);
      throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
    });
  }

  _loadSession(userId, clientId) {
    const sessionId = this._constructSessionId(userId, clientId);

    return this.cryptobox.session_load(sessionId).catch(() => {
      return this.getUserPreKeyByIds(userId, clientId).then(preKey => {
        return this._createSessionFromPreKey(preKey, userId, clientId);
      });
    });
  }

  /**
   * Generate the signaling keys (which are used for mobile push notifications).
   * @note Signaling Keys are  required by the backend but unimportant for the webapp
   *   (because they are used for iOS or Android push notifications).
   *   Thus this method returns a static Signaling Key Pair.
   *
   * @private
   * @returns {Object} Object containing the signaling keys
   */
  _generateSignalingKeys() {
    return {
      enckey: 'Wuec0oJi9/q9VsgOil9Ds4uhhYwBT+CAUrvi/S9vcz0=',
      mackey: 'Wuec0oJi9/q9VsgOil9Ds4uhhYwBT+CAUrvi/S9vcz0=',
    };
  }

  /**
   * Construct a session ID.
   *
   * @todo Make public
   * @private
   * @param {string} userId - User ID for the remote participant
   * @param {string} clientId - Client ID of the remote participant
   * @returns {string} Session ID
   */
  _constructSessionId(userId, clientId) {
    return `${userId}@${clientId}`;
  }

  deleteSession(userId, clientId) {
    const sessionId = this._constructSessionId(userId, clientId);
    return this.cryptobox.session_delete(sessionId);
  }

  /**
   * Bundles and encrypts the generic message for all given clients.
   *
   * @param {Object} recipients - Contains all users and their known clients
   * @param {z.proto.GenericMessage} genericMessage - Proto buffer message to be encrypted
   * @param {Object} [payload={sender: string, recipients: {}, native_push: true}] - Object to contain encrypted message payload
   * @returns {Promise} Resolves with the encrypted payload
   */
  encryptGenericMessage(recipients, genericMessage, payload = this._constructPayload(this.currentClient().id)) {
    return Promise.resolve()
      .then(() => {
        const receivingUsers = Object.keys(recipients).length;
        const logMessage = `Encrypting message of type '${genericMessage.content}' for '${receivingUsers}' users.`;
        this.logger.log(logMessage, recipients);

        return this._encryptGenericMessage(recipients, genericMessage, payload);
      })
      .then(({messagePayload, missingRecipients}) => {
        return Object.keys(missingRecipients).length
          ? this._encryptGenericMessageForMissingRecipients(missingRecipients, genericMessage, messagePayload)
          : {messagePayload, missingRecipients};
      })
      .then(({messagePayload, missingRecipients}) => {
        const payloadUsers = Object.keys(messagePayload.recipients).length;
        const logMessage = `Encrypted message of type '${genericMessage.content}' for '${payloadUsers}' users.`;
        this.logger.log(logMessage, messagePayload.recipients);

        const missingUsers = Object.keys(missingRecipients).length;
        if (missingUsers) {
          this.logger.warn(`Failed to encrypt message for '${missingUsers}' users`, missingRecipients);
        }

        return messagePayload;
      });
  }

  /**
   * Handle an encrypted event.
   * @param {Object} event - Backend event to decrypt
   * @returns {Promise} Resolves with decrypted and mapped message
   */
  handleEncryptedEvent(event) {
    const {data: eventData, from: userId, id} = event;

    if (!eventData) {
      const logMessage = `Encrypted event with ID '${id}' from user '${userId}' does not have a 'data' property.`;
      this.logger.error(logMessage, event);

      return Promise.reject(new z.error.CryptographyError(z.error.CryptographyError.TYPE.NO_DATA_CONTENT));
    }

    // Check the length of the message
    const genericMessageIsTooBig = eventData.text.length > z.config.MAXIMUM_MESSAGE_LENGTH_RECEIVING;
    const isExternal = typeof eventData.data === 'string';
    const externalMessageIsTooBig = isExternal && eventData.data.length > z.config.MAXIMUM_MESSAGE_LENGTH_RECEIVING;
    if (genericMessageIsTooBig || externalMessageIsTooBig) {
      const error = new Proteus.errors.DecryptError.InvalidMessage('The received message was too big.', 300);
      const errorEvent = z.conversation.EventBuilder.buildIncomingMessageTooBig(event, error, error.code);
      return Promise.resolve(errorEvent);
    }

    const failedEncryption = eventData.text === CryptographyRepository.REMOTE_ENCRYPTION_FAILURE;
    if (failedEncryption) {
      const decryptionError = new Proteus.errors.DecryptError.InvalidMessage(
        'Sender failed to encrypt a message.',
        213
      );
      return Promise.resolve(this._handleDecryptionFailure(decryptionError, event));
    }

    return this._decryptEvent(event)
      .then(genericMessage => this.cryptographyMapper.mapGenericMessage(genericMessage, event))
      .catch(error => {
        const isUnhandledType = error.type === z.error.CryptographyError.TYPE.UNHANDLED_TYPE;
        if (isUnhandledType) {
          throw error;
        }

        return this._handleDecryptionFailure(error, event);
      });
  }

  _createSessionFromPreKey(preKey, userId, clientId) {
    return Promise.resolve()
      .then(() => {
        if (preKey) {
          this.logger.log(`Initializing session with user '${userId}' (${clientId}) with pre-key ID '${preKey.id}'.`);
          const sessionId = this._constructSessionId(userId, clientId);

          return this.cryptobox.session_from_prekey(sessionId, z.util.base64ToArray(preKey.key).buffer);
        }

        Raygun.send(new Error('Failed to create session: No pre-key found'));
        this.logger.warn(`No pre-key for user '${userId}' ('${clientId}') found. The client might have been deleted.`);
        return undefined;
      })
      .catch(error => {
        Raygun.send(new Error(`Failed to create session: ${error.message}`));

        const message = `Pre-key for user '${userId}' ('${clientId}') invalid. Skipping encryption: ${error.message}`;
        this.logger.warn(message, error);
        return undefined;
      });
  }

  _encryptGenericMessage(recipients, genericMessage, messagePayload) {
    return Promise.resolve()
      .then(() => {
        const cipherPayloadPromises = [];

        Object.entries(recipients).forEach(([userId, clientIds]) => {
          if (clientIds && clientIds.length) {
            messagePayload.recipients[userId] = messagePayload.recipients[userId] || {};
            clientIds.forEach(clientId => {
              const sessionId = this._constructSessionId(userId, clientId);
              const encryptionPromise = this._encryptPayloadForSession(sessionId, genericMessage);

              cipherPayloadPromises.push(encryptionPromise);
            });
          }
        });

        return Promise.all(cipherPayloadPromises);
      })
      .then(cipherPayload => this._mapCipherTextToPayload(messagePayload, cipherPayload));
  }

  _encryptGenericMessageForMissingRecipients(missingRecipients, genericMessage, messagePayload) {
    return this.getUsersPreKeys(missingRecipients)
      .then(userPreKeyMap => {
        this.logger.info(`Fetched pre-keys for '${Object.keys(userPreKeyMap).length}' users.`, userPreKeyMap);

        const cipherPayloadPromises = [];

        Object.entries(userPreKeyMap).forEach(([userId, clientPreKeyMap]) => {
          if (clientPreKeyMap && Object.keys(clientPreKeyMap).length) {
            Object.entries(clientPreKeyMap).forEach(([clientId, preKeyPayload]) => {
              if (preKeyPayload) {
                const sessionId = this._constructSessionId(userId, clientId);
                const preKeyBundle = z.util.base64ToArray(preKeyPayload.key).buffer;
                const encryptionPromise = this._encryptPayloadForSession(sessionId, genericMessage, preKeyBundle);

                cipherPayloadPromises.push(encryptionPromise);
              }
            });
          }
        });

        return Promise.all(cipherPayloadPromises);
      })
      .then(cipherPayload => this._mapCipherTextToPayload(messagePayload, cipherPayload));
  }

  _mapCipherTextToPayload(messagePayload, cipherPayload) {
    const missingRecipients = {};

    cipherPayload.forEach(({cipherText, sessionId}) => {
      const {userId, clientId} = z.client.ClientEntity.dismantleUserClientId(sessionId);

      if (cipherText) {
        messagePayload.recipients[userId][clientId] = cipherText;
      } else {
        missingRecipients[userId] = missingRecipients[userId] || [];
        missingRecipients[userId].push(clientId);
      }
    });

    return {messagePayload, missingRecipients};
  }

  /**
   * Construct the payload for an encrypted message.
   *
   * @private
   * @param {string} sender - Client ID of message sender
   * @returns {Object} Payload to send to backend
   */
  _constructPayload(sender) {
    return {
      native_push: true,
      recipients: {},
      sender: sender,
    };
  }

  /**
   * Decrypt an event.
   *
   * @private
   * @param {Object} event - Backend event to decrypt
   * @returns {Promise} Resolves with the decrypted message in ProtocolBuffer format
   */
  _decryptEvent(event) {
    const {data: eventData, from: userId} = event;
    const cipherText = z.util.base64ToArray(eventData.text || eventData.key).buffer;
    const sessionId = this._constructSessionId(userId, eventData.sender);

    return this.cryptobox.decrypt(sessionId, cipherText).then(plaintext => z.proto.GenericMessage.decode(plaintext));
  }

  /**
   * Encrypt the generic message for a given session.
   * @note We created the convention that whenever we fail to encrypt for a specific client, we send a Bomb Emoji (no joke!)
   *
   * @private
   * @param {string} sessionId - ID of session to encrypt for
   * @param {z.proto.GenericMessage} genericMessage - ProtoBuffer message
   * @param {Object} [preKeyBundle] - Pre-key bundle
   * @returns {Object} Contains session ID and encrypted message as base64 encoded string
   */
  _encryptPayloadForSession(sessionId, genericMessage, preKeyBundle) {
    return this.cryptobox
      .encrypt(sessionId, genericMessage.toArrayBuffer(), preKeyBundle)
      .then(cipherText => ({cipherText: z.util.arrayToBase64(cipherText), sessionId}))
      .catch(error => {
        if (error instanceof StoreEngine.error.RecordNotFoundError) {
          this.logger.log(`Session '${sessionId}' needs to get initialized...`);
          return {sessionId};
        }

        const message = `Failed encrypting '${genericMessage.content}' for session '${sessionId}': ${error.message}`;
        this.logger.warn(message, error);
        return {cipherText: CryptographyRepository.REMOTE_ENCRYPTION_FAILURE, sessionId};
      });
  }

  _handleDecryptionFailure(error, event) {
    // Get error information
    const errorCode = error.code || CryptographyRepository.CONFIG.UNKNOWN_DECRYPTION_ERROR_CODE;

    const {data: eventData, from: remoteUserId, time: formattedTime} = event;

    const isDuplicateMessage = error instanceof Proteus.errors.DecryptError.DuplicateMessage;
    const isOutdatedMessage = error instanceof Proteus.errors.DecryptError.OutdatedMessage;
    // We don't need to show these message errors to the user
    if (isDuplicateMessage || isOutdatedMessage) {
      throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
    }

    const isCryptographyError = error instanceof z.error.CryptographyError;
    if (isCryptographyError && error.type === z.error.CryptographyError.TYPE.PREVIOUSLY_STORED) {
      throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
    }

    const remoteClientId = eventData.sender;

    const isInvalidMessage = error instanceof Proteus.errors.DecryptError.InvalidMessage;
    const isInvalidSignature = error instanceof Proteus.errors.DecryptError.InvalidSignature;
    const isRemoteIdentityChanged = error instanceof Proteus.errors.DecryptError.RemoteIdentityChanged;
    // Session is broken, let's see what's really causing it...
    if (isInvalidMessage || isInvalidSignature) {
      this.logger.error(
        `Session with user '${remoteUserId}' (${remoteClientId}) is broken.\nReset the session for possible fix.`
      );
    } else if (isRemoteIdentityChanged) {
      this.logger.error(`Remote identity of client '${remoteClientId}' from user '${remoteUserId}' changed`);
    }

    this.logger.warn(
      `Failed to decrypt event from client '${remoteClientId}' of user '${remoteUserId}' (${formattedTime}).\nError Code: '${errorCode}'\nError Message: ${
        error.message
      }`,
      error
    );
    this._reportDecryptionFailure(error, event);

    return z.conversation.EventBuilder.buildUnableToDecrypt(event, error, errorCode);
  }

  /**
   * Report decryption error to Localytics and stack traces to Raygun.
   *
   * @private
   * @param {Error} error - Error from event decryption
   * @param {Object} eventData - Event data
   * @param {string} userId - Remote user ID
   * @param {string} eventType - Event type
   * @returns {undefined} No return value
   */
  _reportDecryptionFailure(error, {data: eventData, type: eventType}) {
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.E2EE.FAILED_MESSAGE_DECRYPTION, {
      cause: error.code || error.message,
    });

    const customData = {
      clientLocalClass: this.currentClient().class,
      clientLocalType: this.currentClient().type,
      cryptoboxVersion: cryptobox.version,
      errorCode: error.code,
      eventType: eventType,
    };

    const raygunError = new Error(`Decryption failed: ${error.code || error.message}`);
    raygunError.stack = error.stack;
    Raygun.send(raygunError, customData);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyService = class CryptographyService {
  static get CONFIG() {
    return {
      URL_CLIENTS: '/clients',
      URL_USERS: '/users',
    };
  }

  /**
   * Construct a new Cryptography Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.cryptography.CryptographyService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Gets a pre-key for a client of a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getPrekey
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @returns {Promise} Resolves with a pre-key for given the client of the user
   */
  getUserPreKeyByIds(userId, clientId) {
    return this.backendClient.sendJson({
      type: 'GET',
      url: `${CryptographyService.CONFIG.URL_USERS}/${userId}/prekeys/${clientId}`,
    });
  }

  /**
   * Gets a pre-key for each client of a user client map.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getMultiPrekeyBundles
   *
   * @param {Object} recipients - User client map to request pre-keys for
   * @returns {Promise} Resolves with a pre-key for each client of the given map
   */
  getUsersPreKeys(recipients) {
    return this.backendClient.sendJson({
      data: recipients,
      type: 'POST',
      url: `${CryptographyService.CONFIG.URL_USERS}/prekeys`,
    });
  }

  /**
   * Put pre-keys for client to be used by remote clients for session initialization.
   *
   * @param {string} clientId - Local client ID
   * @param {Array<string>} serializedPreKeys - Additional pre-keys to be made available
   * @returns {Promise} Resolves once the pre-keys are accepted
   */
  putClientPreKeys(clientId, serializedPreKeys) {
    return this.backendClient.sendJson({
      data: {
        prekeys: serializedPreKeys,
      },
      type: 'PUT',
      url: `${CryptographyService.CONFIG.URL_CLIENTS}/${clientId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.GENERIC_MESSAGE_TYPE = {
  ASSET: 'asset',
  AVAILABILITY: 'availability',
  CALLING: 'calling',
  CLEARED: 'cleared',
  CLIENT_ACTION: 'clientAction',
  CONFIRMATION: 'confirmation',
  DELETED: 'deleted',
  EDITED: 'edited',
  EPHEMERAL: 'ephemeral',
  EXTERNAL: 'external',
  HIDDEN: 'hidden',
  IMAGE: 'image',
  KNOCK: 'knock',
  LAST_READ: 'lastRead',
  LOCATION: 'location',
  REACTION: 'reaction',
  TEXT: 'text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.PROTO_MESSAGE_TYPE = {
  ASSET_NOT_UPLOADED: 'not_uploaded',
  ASSET_ORIGINAL: 'original',
  ASSET_PREVIEW: 'preview',
  ASSET_UPLOADED: 'uploaded',
  EPHEMERAL_EXPIRATION: 'expire_after_millis',
  LINK_PREVIEW_IMAGE: 'image',
  LINK_PREVIEW_TITLE: 'title',
  LINK_PREVIEWS: 'link_preview',
  MENTION_TYPE_USER_ID: 'user_id',
  MENTIONS: 'mentions',
  QUOTE: 'quote',
  TWEET: 'tweet',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ephemeral = z.ephemeral || {};

z.ephemeral.timings = class {
  static get VALUES() {
    return [
      z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
      z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE * 5,
      z.util.TimeUtil.UNITS_IN_MILLIS.HOUR,
      z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      z.util.TimeUtil.UNITS_IN_MILLIS.WEEK * 4,
    ];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.Backend = {
  CONVERSATION: {
    ACCESS_UPDATE: 'conversation.access-update',
    CODE_DELETE: 'conversation.code-delete',
    CODE_UPDATE: 'conversation.code-update',
    CONNECT_REQUEST: 'conversation.connect-request',
    CREATE: 'conversation.create',
    DELETE: 'conversation.delete',
    MEMBER_JOIN: 'conversation.member-join',
    MEMBER_LEAVE: 'conversation.member-leave',
    MEMBER_UPDATE: 'conversation.member-update',
    MESSAGE_TIMER_UPDATE: 'conversation.message-timer-update',
    OTR_MESSAGE_ADD: 'conversation.otr-message-add',
    RENAME: 'conversation.rename',
    TYPING: 'conversation.typing',
  },
  TEAM: {
    CONVERSATION_CREATE: 'team.conversation-create',
    CONVERSATION_DELETE: 'team.conversation-delete',
    CREATE: 'team.create',
    DELETE: 'team.delete',
    MEMBER_JOIN: 'team.member-join',
    MEMBER_LEAVE: 'team.member-leave',
    MEMBER_UPDATE: 'team.member-update',
    UPDATE: 'team.update',
  },
  USER: {
    ACTIVATE: 'user.activate',
    CLIENT_ADD: 'user.client-add',
    CLIENT_REMOVE: 'user.client-remove',
    CONNECTION: 'user.connection',
    DELETE: 'user.delete',
    UPDATE: 'user.update',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.Client = {
  CALL: {
    E_CALL: 'call.e-call',
  },
  CONVERSATION: {
    ASSET_ADD: 'conversation.asset-add',
    CONFIRMATION: 'conversation.confirmation',
    DELETE_EVERYWHERE: 'conversation.delete-everywhere',
    GROUP_CREATION: 'conversation.group-creation',
    INCOMING_MESSAGE_TOO_BIG: 'conversation.incoming-message-too-big',
    KNOCK: 'conversation.knock',
    LOCATION: 'conversation.location',
    MESSAGE_ADD: 'conversation.message-add',
    MESSAGE_DELETE: 'conversation.message-delete',
    MESSAGE_HIDDEN: 'conversation.message-hidden',
    MISSED_MESSAGES: 'conversation.missed-messages',
    ONE2ONE_CREATION: 'conversation.one2one-creation',
    REACTION: 'conversation.reaction',
    TEAM_MEMBER_LEAVE: 'conversation.team-member-leave',
    UNABLE_TO_DECRYPT: 'conversation.unable-to-decrypt',
    VERIFICATION: 'conversation.verification',
    VOICE_CHANNEL_ACTIVATE: 'conversation.voice-channel-activate',
    VOICE_CHANNEL_DEACTIVATE: 'conversation.voice-channel-deactivate',
  },
  USER: {
    AVAILABILITY: 'user.availability',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EventRepository = class EventRepository {
  static get CONFIG() {
    return {
      E_CALL_EVENT_LIFETIME: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 30,
      IGNORED_ERRORS: [
        z.error.CryptographyError.TYPE.IGNORED_ASSET,
        z.error.CryptographyError.TYPE.IGNORED_PREVIEW,
        z.error.CryptographyError.TYPE.PREVIOUSLY_STORED,
        z.error.CryptographyError.TYPE.UNHANDLED_TYPE,
        z.error.EventError.TYPE.OUTDATED_E_CALL_EVENT,
        z.error.EventError.TYPE.VALIDATION_FAILED,
      ],
      NOTIFICATION_BATCHES: {
        INITIAL: 500,
        MAX: 10000,
        SUBSEQUENT: 5000,
      },
    };
  }

  static get SOURCE() {
    return {
      BACKEND_RESPONSE: 'backend_response',
      INJECTED: 'injected',
      STREAM: 'Notification Stream',
      WEB_SOCKET: 'WebSocket',
    };
  }

  /**
   * Construct a new Event Repository.
   *
   * @param {z.event.EventService} eventService - Service that handles interactions with events
   * @param {z.event.NotificationService} notificationService - Service handling the notification stream
   * @param {z.event.WebSocketService} webSocketService - Service that connects to WebSocket
   * @param {z.conversation.ConversationService} conversationService - Service to handle conversation related tasks
   * @param {z.cryptography.CryptographyRepository} cryptographyRepository - Repository for all cryptography interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(
    eventService,
    notificationService,
    webSocketService,
    conversationService,
    cryptographyRepository,
    serverTimeRepository,
    userRepository
  ) {
    this.eventService = eventService;
    this.notificationService = notificationService;
    this.webSocketService = webSocketService;
    this.conversationService = conversationService;
    this.cryptographyRepository = cryptographyRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.event.EventRepository', z.config.LOGGER.OPTIONS);

    this.currentClient = undefined;

    this.notificationHandlingState = ko.observable(z.event.NOTIFICATION_HANDLING_STATE.STREAM);
    this.notificationHandlingState.subscribe(handling_state => {
      amplify.publish(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, handling_state);

      const isHandlingWebSocket = handling_state === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (isHandlingWebSocket) {
        this._handleBufferedNotifications();
        const previouslyHandlingRecovery = this.previousHandlingState === z.event.NOTIFICATION_HANDLING_STATE.RECOVERY;
        if (previouslyHandlingRecovery) {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY);
        }
      }
      this.previousHandlingState = handling_state;
    });

    this.previousHandlingState = this.notificationHandlingState();

    this.notificationsHandled = 0;
    this.notificationsLoaded = ko.observable(false);
    this.notificationsPromises = undefined;
    this.notificationsTotal = 0;
    this.notificationsQueue = ko.observableArray([]);
    this.notificationsBlocked = false;

    this.loadEvent = this.eventService.loadEvent.bind(this.eventService);

    this.notificationsQueue.subscribe(notifications => {
      if (notifications.length) {
        if (this.notificationsBlocked) {
          return;
        }

        const [notification] = notifications;
        this.notificationsBlocked = true;

        return this._handleNotification(notification)
          .catch(error => {
            const errorMessage = `We failed to handle a notification but will continue with queue: ${error.message}`;
            this.logger.warn(errorMessage, error);
          })
          .then(() => {
            this.notificationsBlocked = false;
            this.notificationsQueue.shift();
            this.notificationsHandled++;

            const isHandlingStream = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.STREAM;
            if (isHandlingStream) {
              this._updateProgress();
            }
          });
      }

      const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (this.notificationsLoaded() && !isHandlingWebSocket) {
        this.logger.info(`Done handling '${this.notificationsTotal}' notifications from the stream`);
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);
        this.notificationsLoaded(false);
        this.notificationsPromises[0](this.lastNotificationId());
      }
    });

    this.webSocketBuffer = [];

    this.lastNotificationId = ko.observable();
    this.lastEventDate = ko.observable();

    this.eventProcessMiddlewares = [];

    amplify.subscribe(z.event.WebApp.CONNECTION.ONLINE, this.recoverFromStream.bind(this));
  }

  /**
   * Will set a middleware to run before the EventRepository actually processes the event.
   * Middleware is just a function with the following signature (Event) => Promise<Event>.
   *
   * @param {Array<Function>} middlewares - middlewares to run when a new event is about to be processed
   * @returns {void} - returns nothing
   */
  setEventProcessMiddlewares(middlewares) {
    this.eventProcessMiddlewares = middlewares;
  }

  //##############################################################################
  // WebSocket handling
  //##############################################################################

  /**
   * Initiate the WebSocket connection.
   * @returns {undefined} No return value
   */
  connectWebSocket() {
    if (!this.currentClient().id) {
      throw new z.error.EventError(z.error.EventError.TYPE.NO_CLIENT_ID);
    }

    this.webSocketService.clientId = this.currentClient().id;
    this.webSocketService.connect(notification => {
      const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (isHandlingWebSocket) {
        return this.notificationsQueue.push(notification);
      }
      this._bufferWebSocketNotification(notification);
    });
  }

  /**
   * Close the WebSocket connection.
   * @param {z.event.WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the disconnect
   * @returns {undefined} No return value
   */
  disconnectWebSocket(trigger) {
    this.webSocketService.reset(trigger);
  }

  /**
   * Re-connect the WebSocket connection.
   * @param {z.event.WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reconnect
   * @returns {undefined} No return value
   */
  reconnectWebSocket(trigger) {
    this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.RECOVERY);
    this.webSocketService.reconnect(trigger);
  }

  /**
   * Buffer an incoming notification.
   * @param {Object} notification - Notification data
   * @returns {undefined} No return value
   */
  _bufferWebSocketNotification(notification) {
    this.webSocketBuffer.push(notification);
  }

  /**
   * Handle buffered notifications.
   * @returns {undefined} No return value
   */
  _handleBufferedNotifications() {
    this.logger.info(`Received '${this.webSocketBuffer.length}' notifications via WebSocket while handling stream`);
    if (this.webSocketBuffer.length) {
      z.util.koArrayPushAll(this.notificationsQueue, this.webSocketBuffer);
      this.webSocketBuffer.length = 0;
    }
  }

  //##############################################################################
  // Notification Stream handling
  //##############################################################################

  /**
   * Get notifications for the current client from the stream.
   *
   * @param {string} notificationId - Event ID to start from
   * @param {number} [limit=EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX] - Max. number of notifications to retrieve from backend at once
   * @returns {Promise} Resolves when all new notifications from the stream have been handled
   */
  getNotifications(notificationId, limit = EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX) {
    return new Promise((resolve, reject) => {
      const _gotNotifications = ({has_more: hasAdditionalNotifications, notifications, time}) => {
        if (time) {
          this.serverTimeRepository.computeTimeOffset(time);
        }

        if (notifications.length > 0) {
          notificationId = notifications[notifications.length - 1].id;

          this.logger.info(`Added '${notifications.length}' notifications to the queue`);
          z.util.koArrayPushAll(this.notificationsQueue, notifications);

          if (!this.notificationsPromises) {
            this.notificationsPromises = [resolve, reject];
          }

          this.notificationsTotal += notifications.length;

          if (hasAdditionalNotifications) {
            return this.getNotifications(notificationId, EventRepository.CONFIG.NOTIFICATION_BATCHES.SUBSEQUENT);
          }

          this.notificationsLoaded(true);
          this.logger.info(`Fetched '${this.notificationsTotal}' notifications from the backend`);
          return notificationId;
        }
        this.logger.info(`No notifications found since '${notificationId}'`);
        return reject(new z.error.EventError(z.error.EventError.TYPE.NO_NOTIFICATIONS));
      };

      return this.notificationService
        .getNotifications(this.currentClient().id, notificationId, limit)
        .then(_gotNotifications)
        .catch(errorResponse => {
          // When asking for notifications with a since set to a notification ID that does not belong to our client ID,
          // we will get a 404 AND notifications
          if (errorResponse.notifications) {
            this._missedEventsFromStream();
            return _gotNotifications(errorResponse);
          }

          const isNotFound = errorResponse.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (isNotFound) {
            this.logger.info(`No notifications found since '${notificationId}'`, errorResponse);
            return reject(new z.error.EventError(z.error.EventError.TYPE.NO_NOTIFICATIONS));
          }

          this.logger.error(`Failed to get notifications: ${errorResponse.message}`, errorResponse);
          return reject(new z.error.EventError(z.error.EventError.TYPE.REQUEST_FAILURE));
        });
    });
  }

  /**
   * Get the last notification.
   * @returns {Promise} Resolves with the last handled notification ID
   */
  getStreamState() {
    return this.notificationService
      .getLastNotificationIdFromDb()
      .catch(error => {
        const isNoLastId = error.type === z.error.EventError.TYPE.NO_LAST_ID;
        if (!isNoLastId) {
          throw error;
        }

        this.logger.warn('Last notification ID not found in database. Resetting...');
        return this.setStreamState(this.currentClient().id).then(() => {
          this._missedEventsFromStream();
          return this.lastNotificationId();
        });
      })
      .then(notificationId => {
        this.lastNotificationId(notificationId);
        return this.notificationService.getLastEventDateFromDb();
      })
      .then(eventDate => this.lastEventDate(eventDate))
      .catch(error => {
        const isNoLastDate = error.type === z.error.EventError.TYPE.NO_LAST_DATE;
        if (!isNoLastDate) {
          throw error;
        }

        this.logger.warn('Last event date not found in database. Resetting...');
        this.lastEventDate(new Date(0).toISOString());
      })
      .then(() => ({eventDate: this.lastEventDate(), notificationId: this.lastNotificationId()}));
  }

  /**
   * Set state for notification stream.
   * @returns {Promise} Resolves when all notifications have been handled
   */
  initializeFromStream() {
    return this.getStreamState()
      .then(({notificationId}) => this._updateFromStream(notificationId))
      .catch(error => {
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);

        const isNoLastId = error.type === z.error.EventError.TYPE.NO_LAST_ID;
        if (isNoLastId) {
          this.logger.info('No notifications found for this user', error);
          return 0;
        }

        throw error;
      });
  }

  /**
   * Retrieve missed notifications from the stream after a connectivity loss.
   * @returns {Promise} Resolves when all missed notifications have been handled
   */
  recoverFromStream() {
    this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.RECOVERY);
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY);

    return this._updateFromStream(this._getLastKnownNotificationId())
      .then(numberOfNotifications => {
        this.logger.info(`Retrieved '${numberOfNotifications}' notifications from stream after connectivity loss`);
      })
      .catch(error => {
        const isNoNotifications = error.type === z.error.EventError.TYPE.NO_NOTIFICATIONS;
        if (!isNoNotifications) {
          this.logger.error(`Failed to recover from notification stream: ${error.message}`, error);
          this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);
          // @todo What do we do in this case?
          amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        }
      });
  }

  /**
   * Get the last notification ID and set event date for a given client.
   *
   * @param {string} clientId - Client ID to retrieve last notification ID for
   * @param {boolean} [isInitialization=false] - Set initial date to 0 if not found
   * @returns {Promise} Resolves when stream state has been initialized
   */
  setStreamState(clientId, isInitialization = false) {
    return this.notificationService.getNotificationsLast(clientId).then(({id: notificationId, payload}) => {
      const [event] = payload;
      const isoDateString = this._getIsoDateFromEvent(event, isInitialization);

      if (notificationId) {
        const logMessage = isoDateString
          ? `Set starting point on notification stream to '${notificationId}' (isoDateString)`
          : `Reset starting point on notification stream to '${notificationId}'`;
        this.logger.info(logMessage);

        return Promise.all([this._updateLastEventDate(isoDateString), this._updateLastNotificationId(notificationId)]);
      }
    });
  }

  _getIsoDateFromEvent(event, defaultValue = false) {
    const {client, connection, time: eventDate, type: eventType} = event;

    if (eventDate) {
      return eventDate;
    }

    const isTypeUserClientAdd = eventType === z.event.Backend.USER.CLIENT_ADD;
    if (isTypeUserClientAdd) {
      return client.time;
    }

    const isTypeUserConnection = eventType === z.event.Backend.USER.CONNECTION;
    if (isTypeUserConnection) {
      return connection.lastUpdate;
    }

    if (defaultValue) {
      return new Date(0).toISOString();
    }
  }

  /**
   * Get the ID of the last known notification.
   * @note Notifications that have not yet been handled but are in the queue should not be fetched again on recovery
   *
   * @private
   * @returns {string} ID of last known notification
   */
  _getLastKnownNotificationId() {
    return this.notificationsQueue().length
      ? this.notificationsQueue()[this.notificationsQueue().length - 1].id
      : this.lastNotificationId();
  }

  _missedEventsFromStream() {
    this.notificationService.getMissedIdFromDb().then(notificationId => {
      const lastNotificationIdEqualsMissedId = this.lastNotificationId() === notificationId;
      if (!lastNotificationIdEqualsMissedId) {
        amplify.publish(z.event.WebApp.CONVERSATION.MISSED_EVENTS);
        this.notificationService.saveMissedIdToDb(this.lastNotificationId());
      }
    });
  }

  /**
   * Fetch all missed events from the notification stream since the given last notification ID.
   *
   * @private
   * @param {string} lastNotificationId - Last known notification ID to start update from
   * @returns {Promise} Resolves with the total number of notifications
   */
  _updateFromStream(lastNotificationId) {
    this.notificationsTotal = 0;

    return this.getNotifications(lastNotificationId, EventRepository.CONFIG.NOTIFICATION_BATCHES.INITIAL)
      .then(updatedLastNotificationId => {
        if (updatedLastNotificationId) {
          this.logger.info(`ID of last notification fetched from stream is '${updatedLastNotificationId}'`);
        }
        return this.notificationsTotal;
      })
      .catch(error => {
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);

        const isNoNotifications = error.type === z.error.EventError.TYPE.NO_NOTIFICATIONS;
        if (isNoNotifications) {
          this.logger.info('No notifications found for this user', error);
          return 0;
        }

        this.logger.error(`Failed to handle notification stream: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Persist updated last event timestamp.
   *
   * @private
   * @param {string} eventDate - Updated last event date
   * @returns {Promise} Resolves when the last event date was stored
   */
  _updateLastEventDate(eventDate) {
    const didDateIncrease = eventDate > this.lastEventDate();
    if (didDateIncrease) {
      this.lastEventDate(eventDate);
      return this.notificationService.saveLastEventDateToDb(eventDate);
    }
  }

  /**
   * Persist updated last notification ID.
   *
   * @private
   * @param {string} notificationId - Updated last notification ID
   * @returns {Promise} Resolves when the last notification ID was stored
   */
  _updateLastNotificationId(notificationId) {
    if (notificationId) {
      this.lastNotificationId(notificationId);
      return this.notificationService.saveLastNotificationIdToDb(notificationId);
    }
  }

  _updateProgress() {
    if (this.notificationsHandled % 5 === 0 || this.notificationsHandled < 5) {
      const content = {
        handled: this.notificationsHandled,
        total: this.notificationsTotal,
      };
      const progress = (this.notificationsHandled / this.notificationsTotal) * 50 + 25;

      amplify.publish(z.event.WebApp.APP.UPDATE_PROGRESS, progress, z.string.initDecryption, content);
    }
  }

  //##############################################################################
  // Notification/Event handling
  //##############################################################################

  /**
   * Inject event into a conversation.
   * @note Don't add unable to decrypt to self conversation
   *
   * @param {Object} event - Event payload to be injected
   * @param {z.event.EventRepository.SOURCE} [source=EventRepository.SOURCE.INJECTED] - Source of injection
   * @returns {Promise<Event>} Resolves when the event has been processed
   */
  injectEvent(event, source = EventRepository.SOURCE.INJECTED) {
    if (!event) {
      throw new z.error.EventError(z.error.EventError.TYPE.NO_EVENT);
    }

    const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
    if (!isHandlingWebSocket) {
      source = EventRepository.SOURCE.INJECTED;
    }

    const {conversation: conversationId, id = 'ID not specified', type} = event;
    const inSelfConversation = conversationId === this.userRepository.self().id;
    if (!inSelfConversation) {
      this.logger.info(`Injected event ID '${id}' of type '${type}'`, event);
      return this._handleEvent(event, source);
    }
    return Promise.resolve(event);
  }

  /**
   * Distribute the given event.
   *
   * @private
   * @param {Object} event - Mapped event to be distributed
   * @param {z.event.EventRepository.SOURCE} source - Source of notification
   * @returns {undefined} No return value
   */
  _distributeEvent(event, source) {
    const {conversation: conversationId, from: userId, type} = event;

    const hasIds = conversationId && userId;
    const logMessage = hasIds
      ? `Distributed '${type}' event for conversation '${conversationId}' from user '${userId}'`
      : `Distributed '${type}' event`;
    this.logger.info(logMessage, event);

    const [category] = type.split('.');
    switch (category) {
      case z.event.EVENT_TYPE.CALL:
        amplify.publish(z.event.WebApp.CALL.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.CONVERSATION:
        amplify.publish(z.event.WebApp.CONVERSATION.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.TEAM:
        amplify.publish(z.event.WebApp.TEAM.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.USER:
        amplify.publish(z.event.WebApp.USER.EVENT_FROM_BACKEND, event, source);
        break;
      default:
        amplify.publish(type, event, source);
    }
  }

  /**
   * Handle a single event from the notification stream or WebSocket.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved record or boolean true if the event was skipped
   */
  _handleEvent(event, source) {
    return this._handleEventValidation(event, source)
      .then(validatedEvent => this.processEvent(validatedEvent, source))
      .catch(error => {
        const isIgnoredError = EventRepository.CONFIG.IGNORED_ERRORS.includes(error.type);
        if (!isIgnoredError) {
          throw error;
        }

        return event;
      });
  }

  /**
   * Decrypts, saves and distributes an event received from the backend.
   *
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved record or boolean true if the event was skipped
   */
  processEvent(event, source) {
    const isEncryptedEvent = event.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
    const mapEvent = isEncryptedEvent
      ? this.cryptographyRepository.handleEncryptedEvent(event)
      : Promise.resolve(event);

    return mapEvent
      .then(mappedEvent => {
        return this.eventProcessMiddlewares.reduce((eventPromise, middleware) => {
          // use reduce to resolve promises sequentially
          // see https://hackernoon.com/functional-javascript-resolving-promises-sequentially-7aac18c4431e
          return eventPromise.then(middleware);
        }, Promise.resolve(mappedEvent));
      })
      .then(mappedEvent => {
        const shouldSaveEvent = z.event.EventTypeHandling.STORE.includes(mappedEvent.type);
        return shouldSaveEvent ? this._handleEventSaving(mappedEvent, source) : mappedEvent;
      })
      .then(savedEvent => this._handleEventDistribution(savedEvent, source));
  }

  /**
   * Handle a saved event and distribute it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {JSON} The distributed event
   */
  _handleEventDistribution(event, source) {
    const eventDate = this._getIsoDateFromEvent(event);
    const isInjectedEvent = source === EventRepository.SOURCE.INJECTED;
    const canSetEventDate = !isInjectedEvent && eventDate;
    if (canSetEventDate) {
      this._updateLastEventDate(eventDate);
    }

    const isCallEvent = event.type === z.event.Client.CALL.E_CALL;
    if (isCallEvent) {
      this._validateCallEventLifetime(event);
    }

    this._distributeEvent(event, source);

    return event;
  }

  /**
   * Handle a mapped event, check for malicious ID use and save it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved event
   */
  _handleEventSaving(event, source) {
    const conversationId = event.conversation;
    const mappedData = event.data || {};

    //first check if a message that should be replaced exists in DB
    const findEventToReplacePromise = mappedData.replacing_message_id
      ? this.eventService.loadEvent(conversationId, mappedData.replacing_message_id)
      : Promise.resolve();

    return findEventToReplacePromise.then(eventToReplace => {
      const hasLinkPreview = mappedData.previews && mappedData.previews.length;
      const isReplacementWithoutOriginal = !eventToReplace && mappedData.replacing_message_id;
      if (isReplacementWithoutOriginal && !hasLinkPreview) {
        // the only valid case of a replacement with no original message is when an edited message gets a link preview
        this._throwValidationError(event, 'Edit event without original event');
      }

      const handleEvent = newEvent => {
        // check for duplicates (same id)
        const loadEventPromise = newEvent.id
          ? this.eventService.loadEvent(conversationId, newEvent.id)
          : Promise.resolve();

        return loadEventPromise.then(storedEvent => {
          return storedEvent
            ? this._handleDuplicatedEvent(storedEvent, newEvent)
            : this.eventService.saveEvent(newEvent);
        });
      };

      return eventToReplace ? this._handleEventReplacement(eventToReplace, event) : handleEvent(event);
    });
  }

  _handleEventReplacement(originalEvent, newEvent) {
    const newData = newEvent.data || {};
    if (originalEvent.data.from !== newData.from) {
      const logMessage = `ID previously used by user '${newEvent.from}'`;
      const errorMessage = 'ID reused by other user';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }
    const primaryKeyUpdate = {primary_key: originalEvent.primary_key};
    const isLinkPreviewEdit = newData.previews && !!newData.previews.length;

    let updates = this._getUpdatesForMessageEdit(originalEvent, newEvent);

    if (isLinkPreviewEdit) {
      updates = Object.assign({}, this._getUpdatesForLinkPreview(originalEvent, newEvent), updates);
    }
    const identifiedUpdates = Object.assign({}, primaryKeyUpdate, updates);
    return this.eventService.replaceEvent(identifiedUpdates);
  }

  _handleDuplicatedEvent(originalEvent, newEvent) {
    switch (newEvent.type) {
      case z.event.Client.CONVERSATION.ASSET_ADD:
        return this._handleAssetUpdate(originalEvent, newEvent);

      case z.event.Client.CONVERSATION.MESSAGE_ADD:
        return this._handleLinkPreviewUpdate(originalEvent, newEvent);

      default:
        this._throwValidationError(newEvent, `Forbidden type '${newEvent.type}' for duplicate events`);
    }
  }

  _handleAssetUpdate(originalEvent, newEvent) {
    const newEventData = newEvent.data;
    // the preview status is not sent by the client so we fake a 'preview' status in order to cleany handle it in the switch statement
    const ASSET_PREVIEW = 'preview';
    const isPreviewEvent = !newEventData.status && newEventData.preview_key;
    const status = isPreviewEvent ? ASSET_PREVIEW : newEventData.status;

    switch (status) {
      case ASSET_PREVIEW:
      case z.assets.AssetTransferState.UPLOADED: {
        const updatedData = Object.assign({}, originalEvent.data, newEventData);
        const updatedEvent = Object.assign({}, originalEvent, {data: updatedData});
        return this.eventService.replaceEvent(updatedEvent);
      }

      case z.assets.AssetTransferState.UPLOAD_FAILED: {
        // case of both failed or canceled upload
        const fromOther = newEvent.from !== this.userRepository.self().id;
        const selfCancel = !fromOther && newEvent.data.reason === z.assets.AssetUploadFailedReason.CANCELLED;
        // we want to delete the event in the case of an error from the remote client or a cancel on the user's own client
        const shouldDeleteEvent = fromOther || selfCancel;
        return shouldDeleteEvent
          ? this.eventService.deleteEvent(newEvent.conversation, newEvent.id).then(() => newEvent)
          : this.eventService.updateEventAsUploadFailed(originalEvent.primary_key, newEvent.data.reason);
      }

      default:
        return this._throwValidationError(newEvent, `Unhandled asset status update '${newEvent.data.status}'`);
    }
  }

  _handleLinkPreviewUpdate(originalEvent, newEvent) {
    const newEventData = newEvent.data;
    const originalData = originalEvent.data;
    if (originalEvent.from !== newEvent.from) {
      const logMessage = `ID previously used by user '${newEvent.from}'`;
      const errorMessage = 'ID reused by other user';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    const containsLinkPreview = newEventData.previews && !!newEventData.previews.length;
    if (!containsLinkPreview) {
      const errorMessage = 'Link preview event does not contain previews';
      this._throwValidationError(newEvent, errorMessage);
    }

    const textContentMatches = newEventData.content === originalData.content;
    if (!textContentMatches) {
      const errorMessage = 'ID of link preview reused';
      const logMessage = 'Text content for link preview not matching';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    const bothAreMessageAddType = newEvent.type === originalEvent.type;
    if (!bothAreMessageAddType) {
      this._throwValidationError(newEvent, 'ID reused by same user');
    }

    const updates = this._getUpdatesForLinkPreview(originalEvent, newEvent);
    const identifiedUpdates = Object.assign({}, {primary_key: originalEvent.primary_key}, updates);
    return this.eventService.replaceEvent(identifiedUpdates);
  }

  _getUpdatesForMessageEdit(originalEvent, newEvent) {
    return Object.assign({}, newEvent, {
      edited_time: newEvent.time,
      time: originalEvent.time,
      version: 1,
    });
  }

  _getUpdatesForLinkPreview(originalEvent, newEvent) {
    const newData = newEvent.data;
    const originalData = originalEvent.data;
    const updatingLinkPreview = !!originalData.previews.length;
    if (updatingLinkPreview) {
      this._throwValidationError(newEvent, 'ID of link preview reused');
    }

    const textContentMatches = !newData.previews.length || newData.content === originalData.content;
    if (!textContentMatches) {
      const logMessage = 'Text content for link preview not matching';
      const errorMessage = 'ID of link preview reused';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    return Object.assign({}, newEvent, {
      category: z.message.MessageCategorization.categoryFromEvent(newEvent),
      ephemeral_expires: originalEvent.ephemeral_expires,
      ephemeral_started: originalEvent.ephemeral_started,
      ephemeral_time: originalEvent.ephemeral_time,
      server_time: newEvent.time,
      time: originalEvent.time,
      version: originalEvent.version,
    });
  }

  _throwValidationError(event, errorMessage, logMessage) {
    const baseLogMessage = `Ignored '${event.type}' (${event.id}) in '${event.conversation}' from '${event.from}':'`;
    const baseErrorMessage = 'Event validation failed:';
    this.logger.warn(`${baseLogMessage} ${logMessage || errorMessage}`, event);
    throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, `${baseErrorMessage} ${errorMessage}`);
  }

  /**
   * Handle an event by validating it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the event
   */
  _handleEventValidation(event, source) {
    return Promise.resolve().then(() => {
      const {time: eventDate, type: eventType} = event;

      const isIgnoredEvent = z.event.EventTypeHandling.IGNORE.includes(eventType);
      if (isIgnoredEvent) {
        this.logger.info(`Event ignored: '${event.type}'`, {event_json: JSON.stringify(event), event_object: event});
        const errorMessage = 'Event ignored: Type ignored';
        throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, errorMessage);
      }

      const eventFromStream = source === EventRepository.SOURCE.STREAM;
      const shouldCheckEventDate = eventFromStream && eventDate;
      if (shouldCheckEventDate) {
        const outdatedEvent = this.lastEventDate() >= new Date(eventDate).toISOString();

        if (outdatedEvent) {
          const logObject = {eventJson: JSON.stringify(event), eventObject: event};
          this.logger.info(`Event from stream skipped as outdated: '${eventType}'`, logObject);
          const errorMessage = 'Event validation failed: Outdated timestamp';
          throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, errorMessage);
        }
      }

      return event;
    });
  }

  /**
   * Handle all events from the payload of an incoming notification.
   *
   * @private
   * @param {Array} events - Events contained in a notification
   * @param {string} id - Notification ID
   * @param {boolean} transient - Type of notification
   * @returns {Promise} Resolves with the ID of the handled notification
   */
  _handleNotification({payload: events, id, transient}) {
    const source = transient !== undefined ? EventRepository.SOURCE.WEB_SOCKET : EventRepository.SOURCE.STREAM;
    const isTransientEvent = !!transient;
    this.logger.info(`Handling notification '${id}' from '${source}' containing '${events.length}' events`, events);

    if (!events.length) {
      this.logger.warn('Notification payload does not contain any events');
      return isTransientEvent ? Promise.resolve(id) : this._updateLastNotificationId(id);
    }

    return Promise.all(events.map(event => this._handleEvent(event, source)))
      .then(() => (isTransientEvent ? id : this._updateLastNotificationId(id)))
      .catch(error => {
        this.logger.error(`Failed to handle notification '${id}' from '${source}': ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check if call event is handled within its valid lifespan.
   *
   * @private
   * @param {Object} event - Event to validate
   * @returns {boolean} Returns true if event is handled within is lifetime, otherwise throws error
   */
  _validateCallEventLifetime(event) {
    const {content = {}, conversation: conversationId, time, type} = event;
    const forcedEventTypes = [z.calling.enum.CALL_MESSAGE_TYPE.CANCEL, z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE];

    const correctedTimestamp = this.serverTimeRepository.toServerTimestamp();
    const thresholdTimestamp = new Date(time).getTime() + EventRepository.CONFIG.E_CALL_EVENT_LIFETIME;

    const isForcedEventType = forcedEventTypes.includes(content.type);
    const eventWithinThreshold = correctedTimestamp < thresholdTimestamp;
    const stateIsWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isValidEvent = isForcedEventType || eventWithinThreshold || stateIsWebSocket;
    if (isValidEvent) {
      return true;
    }

    const eventIsoDate = new Date(time).toISOString();
    const logMessage = `Ignored outdated '${type}' event (${eventIsoDate}) in conversation '${conversationId}'`;
    const logObject = {
      eventJson: JSON.stringify(event),
      eventObject: event,
      eventTime: eventIsoDate,
      localTime: new Date(correctedTimestamp).toISOString(),
    };
    this.logger.info(logMessage, logObject);
    throw new z.error.EventError(z.error.EventError.TYPE.OUTDATED_E_CALL_EVENT);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

/** Handles all databases interactions related to events */
z.event.EventService = class EventService {
  /**
   * Construct a new Event Service.
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(storageService) {
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.conversation.EventService', z.config.LOGGER.OPTIONS);
    this.EVENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  /**
   * Load event from database.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} eventId - ID of event to retrieve
   * @returns {Promise} Resolves with the stored record
   */
  loadEvent(conversationId, eventId) {
    if (!conversationId || !eventId) {
      this.logger.error(`Cannot get event '${eventId}' in conversation '${conversationId}' without IDs`);
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('id')
      .equals(eventId)
      .filter(record => record.conversation === conversationId)
      .first()
      .catch(error => {
        const logMessage = `Failed to get event '${eventId}' for conversation '${conversationId}': ${error.message}`;
        this.logger.error(logMessage, error);
        throw error;
      });
  }

  /**
   * Load all events that match a minimun category from database.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {MessageCategory} categoryMin - Minimum message category
   * @param {MessageCategory} [categoryMax=z.message.MessageCategory.LIKED] - Maximum message category
   * @returns {Promise} Resolves with matching events
   */
  loadEventsWithCategory(conversationId, categoryMin, categoryMax = z.message.MessageCategory.LIKED) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('[conversation+category]')
      .between([conversationId, categoryMin], [conversationId, categoryMax], true, true)
      .sortBy('time');
  }

  loadEventsReplyingToMessage(conversationId, quotedMessageId, quotedMessageTime) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where(['conversation', 'time'])
      .between([conversationId, quotedMessageTime], [conversationId, new Date().toISOString()], true, true)
      .filter(event => event.data && event.data.quote && event.data.quote.message_id === quotedMessageId)
      .toArray();
  }

  /**
   * Load events starting from the fromDate going back in history until either limit or toDate is reached.
   *
   * @param {string} conversationId - ID of conversation
   * @param {Date} [fromDate=new Date(0)] - Load from this date (included)
   * @param {Date} [toDate=new Date()] - Load until this date (excluded)
   * @param {number} [limit=Number.MAX_SAFE_INTEGER] - Amount of events to load
   * @returns {Promise} Resolves with the retrieved records
   */
  loadPrecedingEvents(conversationId, fromDate = new Date(0), toDate = new Date(), limit = Number.MAX_SAFE_INTEGER) {
    const includeParams = {
      includeFrom: true,
      includeTo: false,
    };

    return this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams)
      .reverse()
      .sortBy('time')
      .catch(error => {
        const message = `Failed to load events for conversation '${conversationId}' from database: '${error.message}'`;
        this.logger.error(message);
        throw error;
      });
  }

  /**
   * Load events starting from the fromDate to the present until the limit is reached.
   *
   * @param {string} conversationId - ID of conversation
   * @param {Date} fromDate - Load until this date (excluded)
   * @param {number} [limit=Number.MAX_SAFE_INTEGER] - Amount of events to load
   * @param {number} [includeFrom=true] - Should upper bound be part of the messages
   * @returns {Promise} Resolves with the retrieved records
   */
  loadFollowingEvents(conversationId, fromDate, limit = Number.MAX_SAFE_INTEGER, includeFrom = true) {
    const includeParams = {
      includeFrom,
      includeTo: true,
    };
    if (!_.isDate(fromDate)) {
      const errorMessage = `fromDate ('${typeof fromDate}') must be of type 'Date'.`;
      throw new Error(errorMessage);
    }
    const toDate = new Date(Math.max(fromDate.getTime() + 1, Date.now()));

    return this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams).sortBy('time');
  }

  _loadEventsInDateRange(conversationId, fromDate, toDate, limit, includes) {
    const {includeFrom, includeTo} = includes;
    if (!_.isDate(toDate) || !_.isDate(fromDate)) {
      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;
      throw new Error(errorMessage);
    }

    if (fromDate.getTime() > toDate.getTime()) {
      const errorMessage = `Lower bound (${fromDate.getTime()}) cannot be greater than upper bound (${toDate.getTime()}).`;
      throw new Error(errorMessage);
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('[conversation+time]')
      .between([conversationId, fromDate.toISOString()], [conversationId, toDate.toISOString()], includeFrom, includeTo)
      .limit(limit);
  }

  /**
   * Save an unencrypted conversation event.
   * Will also recompute the category of the event to be stored.
   *
   * @param {Object} event - JSON event to be stored
   * @returns {Promise<Event>} Resolves with the stored record
   */
  saveEvent(event) {
    event.category = z.message.MessageCategorization.categoryFromEvent(event);
    return this.storageService.save(this.EVENT_STORE_NAME, undefined, event).then(() => event);
  }

  /**
   * Update an unencrypted event.
   *
   * @param {Object} event - JSON event to be stored
   * @returns {Promise<Event>} Resolves with the updated record
   */
  replaceEvent(event) {
    return this.storageService.update(this.EVENT_STORE_NAME, event.primary_key, event).then(() => event);
  }

  /**
   * Update event as uploaded in database.
   *
   * @param {string} primaryKey - Primary key used to find an event in the database
   * @param {Object} event - Updated event asset data
   * @returns {Promise} Resolves when the message was updated in database
   */
  updateEventAsUploadSucceeded(primaryKey, event) {
    return this.storageService.load(this.EVENT_STORE_NAME, primaryKey).then(record => {
      if (!record) {
        return this.logger.warn('Did not find message to update asset (uploaded)', primaryKey);
      }
      const assetData = event.data;

      record.data.id = assetData.id;
      record.data.key = assetData.key;
      record.data.otr_key = assetData.otr_key;
      record.data.sha256 = assetData.sha256;
      record.data.status = z.assets.AssetTransferState.UPLOADED;
      record.data.token = assetData.token;
      record.status = z.message.StatusType.SENT;

      return this.replaceEvent(record).then(() => this.logger.info('Updated asset message_et (uploaded)', primaryKey));
    });
  }

  /**
   * Update event as upload failed in database.
   *
   * @param {string} primaryKey - Primary key used to find an event in the database
   * @param {string} reason - Failure reason
   * @returns {Promise} Resolves when the message was updated in database
   */
  updateEventAsUploadFailed(primaryKey, reason) {
    return this.storageService.load(this.EVENT_STORE_NAME, primaryKey).then(record => {
      if (!record) {
        return this.logger.warn('Did not find message to update asset (failed)', primaryKey);
      }
      record.data.reason = reason;
      record.data.status = z.assets.AssetTransferState.UPLOAD_FAILED;

      return this.replaceEvent(record).then(() => {
        this.logger.info('Updated asset message_et (failed)', primaryKey);
        return record;
      });
    });
  }

  /**
   * Update an unencrypted event.
   * A valid update must not contain a 'version' property.
   *
   * @param {number} primaryKey - event's primary key
   * @param {Object<Event>} [updates={}] - Updates to perform on the message.
   * @returns {Promise} Resolves when the message was updated in database.
   */
  updateEvent(primaryKey, updates) {
    return Promise.resolve(primaryKey).then(key => {
      const hasChanges = updates && !!Object.keys(updates).length;
      if (!hasChanges) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES);
      }

      const hasVersionedUpdates = !!updates.version;
      if (hasVersionedUpdates) {
        const error = new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CHANGE);
        error.message += ' Use the `updateEventSequentially` method to perform a versioned update of an event';
        throw error;
      }

      const identifiedUpdates = Object.assign({}, updates, {primary_key: key});
      return this.replaceEvent(identifiedUpdates);
    });
  }

  /**
   * Update an event in the database and checks that the update is sequential.
   *
   * @param {number} primaryKey - Event primary key
   * @param {Object} [changes={}] - Changes to update message with
   * @returns {Promise<Event>} Resolves when the message was updated in database
   */
  updateEventSequentially(primaryKey, changes = {}) {
    return Promise.resolve(primaryKey).then(key => {
      const hasVersionedChanges = !!changes.version;
      if (!hasVersionedChanges) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CHANGE);
      }

      // Create a DB transaction to avoid concurrent sequential update.
      return this.storageService.db.transaction('rw', this.EVENT_STORE_NAME, () => {
        return this.storageService.load(this.EVENT_STORE_NAME, key).then(record => {
          if (!record) {
            throw new z.error.StorageError(z.error.StorageError.TYPE.NOT_FOUND);
          }

          const databaseVersion = record.version || 1;

          const isSequentialUpdate = changes.version === databaseVersion + 1;
          if (isSequentialUpdate) {
            return this.storageService.update(this.EVENT_STORE_NAME, primaryKey, changes);
          }

          const logMessage = 'Failed sequential database update';
          const logObject = {
            databaseVersion: databaseVersion,
            updateVersion: changes.version,
          };

          this.logger.error(logMessage, logObject);

          Raygun.send(new Error(logMessage), logObject);
          throw new z.error.StorageError(z.error.StorageError.TYPE.NON_SEQUENTIAL_UPDATE);
        });
      });
    });
  }

  /**
   * Delete an event from a conversation. Duplicates are delete as well.
   *
   * @param {string} conversationId - ID of conversation to remove message from
   * @param {string} eventId - ID of the actual message
   * @returns {Promise} Resolves with the number of deleted records
   */
  deleteEvent(conversationId, eventId) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('id')
      .equals(eventId)
      .and(record => record.conversation === conversationId)
      .delete();
  }

  /**
   * Delete an event from a conversation with the given primary.
   *
   * @param {string} primaryKey - ID of the actual message
   * @returns {Promise} Resolves with the number of deleted records
   */
  deleteEventByKey(primaryKey) {
    return this.storageService.db[this.EVENT_STORE_NAME].delete(primaryKey);
  }

  /**
   * Delete all events of a conversation.
   *
   * @param {string} conversationId - Delete events for this conversation
   * @param {string} [isoDate] - Date in ISO string format as upper bound which events should be removed
   * @returns {Promise} Resolves when the events was deleted
   */
  deleteEvents(conversationId, isoDate) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .filter(record => !isoDate || isoDate >= record.time)
      .delete();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

// TODO: This function can be removed once Microsoft Edge's IndexedDB supports compound indices:
// - https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/
z.event.EventServiceNoCompound = class EventServiceNoCompound extends z.event.EventService {
  constructor(storage_service) {
    super(storage_service);
  }

  /**
   * Get events with given category.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {z.message.MessageCategory} category - Will be used as lower bound
   * @returns {Promise} Resolves with matching events
   */
  loadEventsWithCategory(conversationId, category) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .sortBy('time')
      .then(records => records.filter(record => record.category >= category));
  }

  _loadEventsInDateRange(conversationId, fromDate, toDate, limit, includes) {
    const {includeFrom, includeTo} = includes;
    if (!_.isDate(toDate) || !_.isDate(fromDate)) {
      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;
      throw new Error(errorMessage);
    }

    if (fromDate.getTime() > toDate.getTime()) {
      const errorMessage = `Lower bound (${toDate.getTime()}) cannot be greater than upper bound (${fromDate.getTime()}).`;
      throw new Error(errorMessage);
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .and(record => {
        const timestamp = new Date(record.time).getTime();
        const fromCompareFunction = includeFrom ? date => timestamp >= date : date => timestamp > date;
        const toCompareFunction = includeTo ? date => timestamp <= date : date => timestamp < date;
        return fromCompareFunction(fromDate) && toCompareFunction(toDate);
      })
      .limit(limit);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EVENT_TYPE = {
  CALL: 'call',
  CONVERSATION: 'conversation',
  TEAM: 'team',
  USER: 'user',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EventTypeHandling = {
  CONFIRM: [
    z.event.Client.CONVERSATION.ASSET_ADD,
    z.event.Client.CONVERSATION.KNOCK,
    z.event.Client.CONVERSATION.LOCATION,
    z.event.Client.CONVERSATION.MESSAGE_ADD,
  ],
  IGNORE: [z.event.Backend.CONVERSATION.TYPING],
  STORE: [
    z.event.Backend.CONVERSATION.MEMBER_JOIN,
    z.event.Backend.CONVERSATION.MEMBER_LEAVE,
    z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE,
    z.event.Backend.CONVERSATION.RENAME,
    z.event.Client.CONVERSATION.ASSET_ADD,
    z.event.Client.CONVERSATION.DELETE_EVERYWHERE,
    z.event.Client.CONVERSATION.GROUP_CREATION,
    z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG,
    z.event.Client.CONVERSATION.KNOCK,
    z.event.Client.CONVERSATION.LOCATION,
    z.event.Client.CONVERSATION.MESSAGE_ADD,
    z.event.Client.CONVERSATION.MISSED_MESSAGES,
    z.event.Client.CONVERSATION.ONE2ONE_CREATION,
    z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
    z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT,
    z.event.Client.CONVERSATION.VERIFICATION,
    z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE,
    z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.NOTIFICATION_HANDLING_STATE = {
  RECOVERY: 'z.event.NOTIFICATION_HANDLING_STATE.RECOVERY',
  STREAM: 'z.event.NOTIFICATION_HANDLING_STATE.STREAM',
  WEB_SOCKET: 'z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.NotificationService = class NotificationService {
  static get CONFIG() {
    return {
      PRIMARY_KEY_LAST_EVENT: 'z.storage.StorageKey.EVENT.LAST_DATE',
      PRIMARY_KEY_LAST_NOTIFICATION: 'z.storage.StorageKey.NOTIFICATION.LAST_ID',
      PRIMARY_KEY_MISSED: 'z.storage.StorageKey.NOTIFICATION.MISSED',
      URL_NOTIFICATIONS: '/notifications',
      URL_NOTIFICATIONS_LAST: '/notifications/last',
    };
  }

  /**
   * Construct a new Notification Service.
   *
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   * @param {z.storage.StorageService} storageService - Service for all storage related tasks
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.event.NotificationService', z.config.LOGGER.OPTIONS);

    this.AMPLIFY_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY;
  }

  /**
   * Get notifications from the stream.
   *
   * @param {string} clientId - Only return notifications targeted at the given client
   * @param {string} notificationId - Only return notifications more recent than this notification ID (like "7130304a-c839-11e5-8001-22000b0fe035")
   * @param {number} size - Maximum number of notifications to return
   * @returns {Promise} Resolves with the retrieved notifications
   */
  getNotifications(clientId, notificationId, size) {
    return this.backendClient.sendRequest({
      data: {
        client: clientId,
        since: notificationId,
        size: size,
      },
      type: 'GET',
      url: NotificationService.CONFIG.URL_NOTIFICATIONS,
    });
  }

  /**
   * Get the last notification for a given client.
   * @param {string} clientId - Client ID to retrieve notification ID for
   * @returns {Promise} Resolves with the last known notification ID for given client
   */
  getNotificationsLast(clientId) {
    return this.backendClient.sendRequest({
      data: {
        client: clientId,
      },
      type: 'GET',
      url: NotificationService.CONFIG.URL_NOTIFICATIONS_LAST,
    });
  }

  /**
   * Load last event date from storage.
   * @returns {Promise} Resolves with the stored last event date.
   */
  getLastEventDateFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_EVENT)
      .catch(error => {
        this.logger.error(`Failed to get last event timestamp from storage: ${error.message}`, error);
        throw new z.error.EventError(z.error.EventError.TYPE.DATABASE_FAILURE);
      })
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
        throw new z.error.EventError(z.error.EventError.TYPE.NO_LAST_DATE);
      });
  }

  /**
   * Load last notifications ID from storage.
   * @returns {Promise} Resolves with the stored last notification ID.
   */
  getLastNotificationIdFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_NOTIFICATION)
      .catch(error => {
        this.logger.error(`Failed to get last notification ID from storage: ${error.message}`, error);
        throw new z.error.EventError(z.error.EventError.TYPE.DATABASE_FAILURE);
      })
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
        throw new z.error.EventError(z.error.EventError.TYPE.NO_LAST_ID);
      });
  }

  /**
   * Load missed ID from storage.
   * @returns {Promise} Resolves with the stored missed ID.
   */
  getMissedIdFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_MISSED)
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
      });
  }

  /**
   * Save last event date to storage.
   * @param {string} eventDate - Event date to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveLastEventDateToDb(eventDate) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_EVENT, {
      value: eventDate,
    });
  }

  /**
   * Save last notifications ID to storage.
   * @param {string} notificationId - Notification ID to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveLastNotificationIdToDb(notificationId) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_NOTIFICATION, {
      value: notificationId,
    });
  }

  /**
   * Save missed notifications ID to storage.
   * @param {string} notificationId - Notification ID to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveMissedIdToDb(notificationId) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_MISSED, {
      value: notificationId,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};
window.z.event.preprocessor = z.event.preprocessor || {};

z.event.preprocessor.QuotedMessageMiddleware = class QuotedMessageMiddleware {
  /**
   * Construct a new QuotedMessageMiddleware.
   * This class is reponsible for parsing incoming text messages that contains quoted messages.
   * It will handle validating the quote and adding metadata to the event.
   *
   * @param {z.event.EventService} eventService - Repository that handles events
   * @param {z.message.MessageHasher} messageHasher - Handles hashing messages
   */
  constructor(eventService, messageHasher) {
    this.eventService = eventService;
    this.messageHasher = messageHasher;
    this.logger = new z.util.Logger('z.event.preprocessor.QuotedMessageMiddleware', z.config.LOGGER.OPTIONS);
  }

  /**
   * Handles validation of the event if it contains a quote.
   * If the event does contain a quote, will also decorate the event with some metadata regarding the quoted message
   *
   * @param {Object} event - event in the DB format
   * @returns {Object} event - the original event if no quote is found (or does not validate). The decorated event if the quote is valid
   */
  processEvent(event) {
    switch (event.type) {
      case z.event.Client.CONVERSATION.MESSAGE_ADD:
        if (event.data.replacing_message_id) {
          return this._handleEditEvent(event);
        }
        return this._handleAddEvent(event);

      case z.event.Client.CONVERSATION.MESSAGE_DELETE:
        return this._handleDeleteEvent(event);

      default:
        return Promise.resolve(event);
    }
  }

  _handleDeleteEvent(event) {
    const originalMessageId = event.data.message_id;
    return this._findRepliesToMessage(event.conversation, originalMessageId).then(({replies}) => {
      this.logger.info(`Invalidating '${replies.length}' replies to deleted message '${originalMessageId}'`);
      replies.forEach(reply => {
        reply.data.quote = {error: {type: z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND}};
        this.eventService.replaceEvent(reply);
      });
      return event;
    });
  }

  _handleEditEvent(event) {
    const originalMessageId = event.data.replacing_message_id;
    return this._findRepliesToMessage(event.conversation, originalMessageId).then(({originalEvent, replies}) => {
      if (!originalEvent) {
        return event;
      }

      this.logger.info(`Updating '${replies.length}' replies to updated message '${originalMessageId}'`);

      replies.forEach(reply => {
        reply.data.quote.message_id = event.id;
        this.eventService.replaceEvent(reply);
      });

      const decoratedData = Object.assign({}, event.data, {quote: originalEvent.data.quote});
      return Object.assign({}, event, {data: decoratedData});
    });
  }

  _handleAddEvent(event) {
    const rawQuote = event.data && event.data.quote;

    if (!rawQuote) {
      return Promise.resolve(event);
    }

    const quote = z.proto.Quote.decode64(rawQuote);
    this.logger.info('Found quoted message', quote);

    return this.eventService.loadEvent(event.conversation, quote.quoted_message_id).then(quotedMessage => {
      if (!quotedMessage) {
        this.logger.warn(`Quoted message with ID "${quote.quoted_message_id}" not found.`);
        const quoteData = {
          error: {
            type: z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND,
          },
        };

        const decoratedData = Object.assign({}, event.data, {quote: quoteData});
        return Promise.resolve(Object.assign({}, event, {data: decoratedData}));
      }

      return this.messageHasher
        .validateHash(quotedMessage, quote.quoted_message_sha256.toArrayBuffer())
        .then(isValid => {
          let quoteData;

          if (!isValid) {
            this.logger.warn(`Quoted message hash for message ID "${quote.quoted_message_id}" does not match.`);
            quoteData = {
              error: {
                type: z.message.QuoteEntity.ERROR.INVALID_HASH,
              },
            };
          } else {
            quoteData = {
              message_id: quote.quoted_message_id,
              user_id: quotedMessage.from,
            };
          }

          const decoratedData = Object.assign({}, event.data, {quote: quoteData});
          return Promise.resolve(Object.assign({}, event, {data: decoratedData}));
        });
    });
  }

  _findRepliesToMessage(conversationId, messageId) {
    return this.eventService.loadEvent(conversationId, messageId).then(originalEvent => {
      if (!originalEvent) {
        return {
          replies: [],
        };
      }
      return this.eventService
        .loadEventsReplyingToMessage(conversationId, messageId, originalEvent.time)
        .then(replies => ({
          originalEvent,
          replies,
        }));
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};
window.z.event.preprocessor = z.event.preprocessor || {};

z.event.preprocessor.ServiceMiddleware = class ServiceMiddleware {
  /**
   * Construct a new ServiceMiddleware.
   *
   * @param {z.conversation.ConverationRepository} conversationRepository - Repository to handle conversation related tasks
   * @param {z.conversation.UserRepository} userRepository - Repository to handle user related tasks
   */
  constructor(conversationRepository, userRepository) {
    this.userRepository = userRepository;
    this.conversationRepository = conversationRepository;
    this.logger = new z.util.Logger('z.event.preprocessor.ServiceMiddleware', z.config.LOGGER.OPTIONS);
  }

  processEvent(event) {
    switch (event.type) {
      case z.event.Client.CONVERSATION.ONE2ONE_CREATION:
        return this._process1To1ConversationCreationEvent(event);

      case z.event.Backend.CONVERSATION.MEMBER_JOIN:
        return this._processMemberJoinEvent(event);

      default:
        return Promise.resolve(event);
    }
  }

  _processMemberJoinEvent(event) {
    this.logger.info(`Preprocessing event of type ${event.type}`);

    const {conversation: conversationId, data: eventData} = event;
    const selfUserId = this.userRepository.self().id;
    const containsSelfUser = eventData.user_ids.includes(selfUserId);

    const getUsersPromise = containsSelfUser
      ? this.conversationRepository
          .get_conversation_by_id(conversationId)
          .then(conversationEntity => conversationEntity.participating_user_ids())
      : Promise.resolve(eventData.user_ids);

    return getUsersPromise
      .then(userIds => this._containsService(userIds))
      .then(hasService => (hasService ? this._decorateWithHasServiceFlag(event) : event));
  }

  _process1To1ConversationCreationEvent(event) {
    this.logger.info(`Preprocessing event of type ${event.type}`);
    return this._containsService(event.data.userIds).then(hasService => {
      return hasService ? this._decorateWithHasServiceFlag(event) : event;
    });
  }

  _containsService(userIds) {
    return this.userRepository.get_users_by_id(userIds).then(userEntities => {
      return userEntities.some(userEntity => userEntity.isService);
    });
  }

  _decorateWithHasServiceFlag(event) {
    const updatedData = Object.assign({}, event.data, {has_service: true});
    return Object.assign({}, event, {data: updatedData});
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

// Enum of different webapp events.
z.event.WebApp = {
  ANALYTICS: {
    EVENT: 'wire.webapp.analytics.event',
    SUPER_PROPERTY: 'wire.webapp.analytics.super_property',
  },
  APP: {
    UPDATE_PROGRESS: 'wire.webapp.app.update_progress',
  },
  AUDIO: {
    PLAY: 'wire.webapp.audio.play',
    PLAY_IN_LOOP: 'wire.webapp.audio.play_in_loop',
    STOP: 'wire.webapp.audio.stop',
  },
  BACKUP: {
    EXPORT: {
      START: 'wire.webapp.backup.export.start',
    },
    IMPORT: {
      START: 'wire.webapp.backup.import.start',
    },
  },
  BROADCAST: {
    SEND_MESSAGE: 'wire.app.broadcast.send_message',
  },
  CALL: {
    EVENT_FROM_BACKEND: 'wire.webapp.call.event_from_backend',
    MEDIA: {
      ADD_STREAM: 'wire.webapp.call.media.add_stream',
      CHOOSE_SCREEN: 'wire.webapp.call.media.choose_screen',
      CONNECTION_CLOSED: 'wire.webapp.call.media.connection_closed',
      MUTE_AUDIO: 'wire.webapp.call.media.mute_audio',
      TOGGLE: 'wire.webapp.call.media.toggle',
    },
    SIGNALING: {
      DELETE_FLOW: 'wire.webapp.call.signaling.delete_flow',
      POST_FLOWS: 'wire.webapp.call.signaling.post_flows',
      SEND_ICE_CANDIDATE_INFO: 'wire.webapp.call.signaling.send_ice_candidate_info',
      SEND_LOCAL_SDP_INFO: 'wire.webapp.call.signaling.send_local_sdp_info',
    },
    STATE: {
      CHECK: 'wire.webapp.call.state.check',
      DELETE: 'wire.webapp.call.state.delete',
      JOIN: 'wire.webapp.call.state.join',
      LEAVE: 'wire.webapp.call.state.leave',
      REJECT: 'wire.webapp.call.state.reject',
      REMOVE_PARTICIPANT: 'wire.webapp.call.state.remove_participant',
      TOGGLE: 'wire.webapp.call.state.toggle',
    },
  },
  CLIENT: {
    ADD: 'wire.webapp.user.client.add',
    REMOVE: 'wire.webapp.client.remove',
    UPDATE: 'wire.webapp.client.update',
    VERIFICATION_STATE_CHANGED: 'wire.webapp.client.verification_state_changed',
  },
  CONNECT: {
    IMPORT_CONTACTS: 'wire.webapp.connect.import_contacts',
  },
  CONNECTION: {
    ACCESS_TOKEN: {
      RENEW: 'wire.webapp.connection.access_token.renew',
      RENEWED: 'wire.webapp.connection.access_token.renewed',
    },
    ONLINE: 'wire.webapp.connection.online',
  },
  CONTENT: {
    SWITCH: 'wire.webapp.content.switch',
  },
  CONTEXT_MENU: 'wire.webapp.context_menu',
  CONVERSATION: {
    ASSET: {
      CANCEL: 'wire.webapp.conversation.asset.cancel',
    },
    CREATE_GROUP: 'wire.webapp.conversation.create_group',
    DEBUG: 'wire.webapp.conversation.debug',
    DETAIL_VIEW: {
      SHOW: 'wire.webapp.conversation.detail_view.show',
    },
    EPHEMERAL_MESSAGE_TIMEOUT: 'wire.webapp.conversation.ephemeral_message_timeout',
    EVENT_FROM_BACKEND: 'wire.webapp.conversation.event_from_backend',
    IMAGE: {
      SEND: 'wire.webapp.conversation.image.send',
    },
    MAP_CONNECTION: 'wire.webapp.conversation.map_connection',
    MESSAGE: {
      ADDED: 'wire.webapp.conversation.message.added',
      EDIT: 'wire.webapp.conversation.message.edit',
      REMOVED: 'wire.webapp.conversation.message.removed',
      REPLY: 'wire.webapp.conversation.message.reply',
      UPDATED: 'wire.webapp.conversation.message.updated',
    },
    MISSED_EVENTS: 'wire.webapp.conversation.missed_events',
    PEOPLE: {
      HIDE: 'wire.webapp.conversation.people.hide',
    },
    PERSIST_STATE: 'wire.webapp.conversation.persist_state',
    SHOW: 'wire.webapp.conversation.show',
  },
  DEBUG: {
    UPDATE_LAST_CALL_STATUS: 'wire.webapp.debug.update_last_call_status',
  },
  EVENT: {
    NOTIFICATION_HANDLING_STATE: 'wire.webapp.event.notification_handling',
  },
  EXTENSIONS: {
    GIPHY: {
      SEND: 'wire.webapp.extionsions.giphy.send',
      SHOW: 'wire.webapp.extionsions.giphy.show',
    },
  },
  INPUT: {
    RESIZE: 'wire.webapp.input.resize',
  },
  LEFT: {
    FADE_IN: 'wire.webapp.left.fade_in',
    HIDE: 'wire.webapp.left.hide',
  },
  LIFECYCLE: {
    ASK_TO_CLEAR_DATA: 'wire.webapp.lifecycle.ask_to_clear_data',
    LOADED: 'wire.webapp.lifecycle.loaded',
    REFRESH: 'wire.webapp.lifecycle.refresh',
    RESTART: 'wire.webapp.lifecycle.restart',
    SIGN_OUT: 'wire.webapp.lifecycle.sign_out',
    SIGNED_OUT: 'wire.webapp.lifecycle.signed_out',
    UNREAD_COUNT: 'wire.webapp.lifecycle.unread_count',
    UPDATE: 'wire.webapp.lifecycle.update',
  },
  NOTIFICATION: {
    CLICK: 'wire.webapp.notification.click',
    NOTIFY: 'wire.webapp.notification.notify',
    PERMISSION_STATE: 'wire.webapp.notification.permissionState',
    REMOVE_READ: 'wire.webapp.notification.remove_read',
    SHOW: 'wire.webapp.notification.show',
  },
  PENDING: {
    SHOW: 'wire.webapp.pending.show',
  },
  PREFERENCES: {
    MANAGE_ACCOUNT: 'wire.webapp.preferences.manage_account',
    MANAGE_DEVICES: 'wire.webapp.preferences.manage_devices',
    UPLOAD_PICTURE: 'wire.webapp.preferences.upload_picture',
  },
  PROFILE: {
    SETTINGS: {
      SHOW: 'wire.webapp.profile.settings.show',
    },
  },
  PROPERTIES: {
    UPDATE: {
      CONTACTS: 'wire.webapp.properties.update.contacts',
      EMOJI: {
        REPLACE_INLINE: 'wire.webapp.properties.update.emoji.replace_inline',
      },
      NOTIFICATIONS: 'wire.webapp.properties.update.notifications',
      PREVIEWS: {
        SEND: 'wire.webapp.properties.update.previews.send',
      },
      PRIVACY: 'wire.webapp.properties.update.privacy',
      SOUND_ALERTS: 'wire.webapp.properties.update.sound_alerts',
    },
    UPDATED: 'wire.webapp.properties.updated',
  },
  SEARCH: {
    BADGE: {
      HIDE: 'wire.webapp.search.badge.hide',
      SHOW: 'wire.webapp.search.badge.show',
    },
    HIDE: 'wire.webapp.search.hide',
    SHOW: 'wire.webapp.search.show',
  },
  SHORTCUT: {
    ADD_PEOPLE: 'wire.webapp.shortcut.add_people',
    ARCHIVE: 'wire.webapp.shortcut.archive',
    CALL_MUTE: 'wire.webapp.shortcut.call_mute',
    CALL_REJECT: 'wire.webapp.shortcut.call_reject',
    DELETE: 'wire.webapp.shortcut.delete',
    NEXT: 'wire.webapp.shortcut.next',
    NOTIFICATIONS: 'wire.webapp.shortcut.notifications',
    PEOPLE: 'wire.webapp.shortcut.people',
    PICTURE: 'wire.webapp.shortcut.picture',
    PING: 'wire.webapp.shortcut.ping',
    PREV: 'wire.webapp.shortcut.prev',
    SILENCE: 'wire.webapp.shortcut.silence', // todo: deprecated - remove when user base of wrappers version >= 3.4 is large enough
    START: 'wire.webapp.shortcut.start',
  },
  SIGN_OUT: 'wire.webapp.logout',
  STORAGE: {
    SAVE_ENTITY: 'wire.webapp.storage.save_entity',
  },
  SYSTEM_NOTIFICATION: {
    CLICK: 'wire.webapp.notification.click', // todo: deprecated - remove when user base of wrappers version >= 3.2 is large enough
  },
  TEAM: {
    EVENT_FROM_BACKEND: 'wire.webapp.team.event_from_backend',
    INFO: 'wire.webapp.team.info',
    MEMBER_LEAVE: 'wire.webapp.team.member_leave',
    UPDATE_INFO: 'wire.webapp.team.update_info',
  },
  TELEMETRY: {
    BACKEND_REQUESTS: 'wire.webapp.telemetry.backend_requests',
  },
  USER: {
    CLIENT_ADDED: 'wire.webapp.user.client_added',
    CLIENT_REMOVED: 'wire.webapp.user.client_removed',
    CLIENTS_UPDATED: 'wire.webapp.user.clients_updated',
    EVENT_FROM_BACKEND: 'wire.webapp.user.event_from_backend',
    PERSIST: 'wire.webapp.user.persist',
    SET_AVAILABILITY: 'wire.webapp.user.set_availability',
    UNBLOCKED: 'wire.webapp.user.unblocked',
    UPDATE: 'wire.webapp.user.update',
  },
  WARNING: {
    DISMISS: 'wire.webapp.warning.dismiss',
    MODAL: 'wire.webapp.warning.modal',
    SHOW: 'wire.webapp.warning.show',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.WebSocketService = class WebSocketService {
  static get CHANGE_TRIGGER() {
    return {
      CLEANUP: 'WebSocketService.CHANGE_TRIGGER.CLEANUP',
      CLOSE: 'WebSocketService.CHANGE_TRIGGER.CLOSE',
      ERROR: 'WebSocketService.CHANGE_TRIGGER.ERROR',
      LOGOUT: 'WebSocketService.CHANGE_TRIGGER.LOGOUT',
      LONG_INACTIVITY: 'WebSocketService.CHANGE_TRIGGER.LONG_INACTIVITY',
      OFFLINE: 'WebSocketService.CHANGE_TRIGGER.OFFLINE',
      ONLINE: 'WebSocketService.CHANGE_TRIGGER.ONLINE',
      PAGE_NAVIGATION: 'WebSocketService.CHANGE_TRIGGER.PAGE_NAVIGATION',
      PING_INTERVAL: 'WebSocketService.CHANGE_TRIGGER.PING_INTERVAL',
      READY_STATE: 'WebSocketService.CHANGE_TRIGGER.READY_STATE',
      WARNING_BAR: 'WebSocketService.CHANGE_TRIGGER.WARNING_BAR',
    };
  }

  static get CONFIG() {
    return {
      PING_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 30,
      PING_INTERVAL_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
      RECONNECT_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 15,
    };
  }

  /**
   * Construct a new WebSocket Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.sendPing = this.sendPing.bind(this);

    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.event.WebSocketService', z.config.LOGGER.OPTIONS);

    this.clientId = undefined;
    this.connectionUrl = '';
    this.socket = undefined;

    this.onNotification = undefined;

    this.pingIntervalId = undefined;
    this.lastPingTime = undefined;

    this.reconnectTimeoutId = undefined;
    this.reconnectCount = 0;

    this.pendingReconnectTrigger = undefined;

    amplify.subscribe(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEWED, this.pendingReconnect.bind(this));
  }

  /**
   * Establish the WebSocket connection.
   * @param {Function} onNotification - Function to be called on incoming notifications
   * @returns {Promise} Resolves once the WebSocket connects
   */
  connect(onNotification) {
    this.onNotification = onNotification;

    return new Promise((resolve, reject) => {
      this.connectionUrl = `${this.backendClient.webSocketUrl}/await?access_token=${this.backendClient.accessToken}`;
      if (this.clientId) {
        this.connectionUrl = z.util.URLUtil.appendParameter(this.connectionUrl, `client=${this.clientId}`);
      }

      const wrongSocketType = typeof this.socket === 'object';
      if (wrongSocketType) {
        this.reset(WebSocketService.CHANGE_TRIGGER.CLEANUP);
      }

      this.socket = new WebSocket(this.connectionUrl);
      this.socket.binaryType = 'blob';

      // http://stackoverflow.com/a/27828483/451634
      delete this.socket.URL;

      this.socket.onopen = () => {
        this.logger.info(`Connected WebSocket to: ${this.backendClient.webSocketUrl}/await`);
        this.pingIntervalId = window.setInterval(this.sendPing, WebSocketService.CONFIG.PING_INTERVAL);
        resolve();
      };

      this.socket.onerror = event => {
        this.logger.error('WebSocket connection error.', event);
        this.reset(WebSocketService.CHANGE_TRIGGER.ERROR, true);
      };

      this.socket.onclose = event => {
        this.logger.warn('Closed WebSocket connection', event);
        this.reset(WebSocketService.CHANGE_TRIGGER.CLOSE, true);
      };

      this.socket.onmessage = event => {
        if (this._pingHasExperiencedSuspiciousInactivity()) {
          const secondsSinceLastPing = (Date.now() - this.lastPingTime) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
          this.logger.warn(`Message received but ping was inactive for "${secondsSinceLastPing}" sec, reconnecting.`);
          return this.reconnect(WebSocketService.CHANGE_TRIGGER.LONG_INACTIVITY);
        }
        if (event.data instanceof Blob) {
          const blobReader = new FileReader();
          blobReader.onload = () => onNotification(JSON.parse(blobReader.result));
          blobReader.readAsText(event.data);
        }
      };
    });
  }

  /**
   * Reconnect WebSocket after access token has been refreshed.
   * @returns {undefined} No return value
   */
  pendingReconnect() {
    if (this.pendingReconnectTrigger) {
      this.logger.info(`Reconnecting WebSocket (TRIGGER: ${this.pendingReconnectTrigger}) after access token refresh`);
      this.reconnect(this.pendingReconnectTrigger);
      this.pendingReconnectTrigger = undefined;
    }
  }

  /**
   * Try to re-establish the WebSocket connection.
   * @param {WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reconnect
   * @returns {undefined} No return value
   */
  reconnect(trigger) {
    if (!z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION)) {
      this.logger.info(`Access token has to be refreshed before reconnecting the WebSocket triggered by '${trigger}'`);
      this.pendingReconnectTrigger = trigger;
      return amplify.publish(
        z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW,
        z.auth.AuthRepository.ACCESS_TOKEN_TRIGGER.WEB_SOCKET
      );
    }

    this.reconnectCount++;
    const reconnect = () => {
      this.logger.info(`Trying to re-establish WebSocket connection. Try #${this.reconnectCount}`);
      return this.connect(this.onNotification).then(() => {
        this.reconnectCount = 0;
        this.logger.info(`Reconnect to WebSocket triggered by '${trigger}'`);
        return this.reconnected();
      });
    };

    const isFirstReconnectAttempt = this.reconnectCount === 1;
    if (isFirstReconnectAttempt) {
      return reconnect();
    }
    this.reconnectTimeoutId = window.setTimeout(() => reconnect(), WebSocketService.CONFIG.RECONNECT_INTERVAL);
  }

  /**
   * Behavior when WebSocket connection is re-established after a connection drop.
   * @returns {undefined} No return value
   */
  reconnected() {
    amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
    this.logger.warn('Re-established WebSocket connection. Recovering from Notification Stream...');
    amplify.publish(z.event.WebApp.CONNECTION.ONLINE);
  }

  /**
   * Reset the WebSocket connection.
   *
   * @param {WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reset
   * @param {boolean} [reconnect=false] - Re-establish the WebSocket connection
   * @returns {undefined} No return value
   */
  reset(trigger, reconnect = false) {
    if (this.socket && this.socket.onclose) {
      this.logger.info(`WebSocket reset triggered by '${trigger}'`);
      this.socket.onerror = undefined;
      this.socket.onclose = undefined;
      this.socket.close();
      window.clearInterval(this.pingIntervalId);
      window.clearTimeout(this.reconnectTimeoutId);
      this.lastPingTime = undefined;
    }

    if (reconnect) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
      this.reconnect(trigger);
    }
  }

  /**
   * Send a WebSocket ping.
   * @returns {undefined} No return value
   */
  sendPing() {
    const isReadyStateOpen = this.socket.readyState === 1;
    if (isReadyStateOpen) {
      if (this._pingHasExperiencedSuspiciousInactivity()) {
        this.logger.warn('Ping interval check failed');
        return this.reconnect(WebSocketService.CHANGE_TRIGGER.PING_INTERVAL);
      }
      this.logger.info('Sending ping to WebSocket');
      this.lastPingTime = Date.now();
      return this.socket.send('Wire is so much nicer with internet!');
    }

    this.logger.warn(`WebSocket connection is closed. Current ready state: ${this.socket.readyState}`);
    this.reconnect(WebSocketService.CHANGE_TRIGGER.READY_STATE);
  }

  /**
   * Returns true if the gap between the last ping and the current time is too big.
   *
   * @returns {boolean} Was the last ping too long ago
   */
  _pingHasExperiencedSuspiciousInactivity() {
    const currentTime = Date.now();
    const lastPingTime = this.lastPingTime || currentTime;
    const pingIntervalDifference = currentTime - lastPingTime;

    const maxDifference = WebSocketService.CONFIG.PING_INTERVAL + WebSocketService.CONFIG.PING_INTERVAL_THRESHOLD;
    return pingIntervalDifference > maxDifference;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

z.extension.GiphyService = class GiphyService {
  static get CONFIG() {
    return {
      ENDPOINT_BASE: '/proxy/giphy/v1/gifs',
    };
  }

  /**
   * Construct a new Giphy Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
  }

  /**
   * Get GIFs for IDs.
   * @param {string|Array} ids - A single id or comma separated list of IDs to fetch GIF size data
   * @returns {Promise} Resolves with the size data
   */
  getById(ids) {
    ids = [].concat(ids);

    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/${ids.join(',')}`,
    });
  }

  /**
   * Search all Giphy GIFs for a word or phrase.
   * @param {string} tag - GIF tag to limit randomness by
   * @returns {Promise} Resolves with random gifs for given tag
   */
  getRandom(tag) {
    return this.backendClient.sendRequest({
      data: {
        tag: tag,
      },
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/random`,
    });
  }

  /**
   * Search GIFs for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.q - Search query term or phrase
   * @param {number} [options.limit=25] - Number of results to return (maximum 100)
   * @param {number} [options.offset=0] - Results offset
   * @param {string} [options.sorting='relevant'] - Specify sorting ('relevant' or 'recent')
   * @returns {Promise} Resolves with matches
   */
  getSearch(options) {
    return this.backendClient.sendRequest({
      data: Object.assign(
        {
          limit: 25,
          offset: 0,
          sort: 'relevant',
        },
        options
      ),
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/search`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

z.extension.GiphyRepository = class GiphyRepository {
  static get CONFIG() {
    return {
      MAX_RETRIES: 3,
      MAX_SIZE: 3 * 1024 * 1024, // 3MB
      NUMBER_OF_RESULTS: 6,
    };
  }

  /**
   * Construct a new Giphy Repository.
   * @param {z.extension.GiphyService} giphyService - Giphy REST API implementation
   */
  constructor(giphyService) {
    this.giphyService = giphyService;
    this.logger = new z.util.Logger('z.extension.GiphyRepository', z.config.LOGGER.OPTIONS);
    this.gifQueryCache = {};
  }

  /**
   * Get random GIF for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.tag - Search query term or phrase
   * @param {number} [options.retry=3] - How many retries to get the correct size
   * @param {number} [options.max_size=3MB] - Maximum gif size in bytes
   * @returns {Promise} Resolves with a random matching gif
   */
  getRandomGif(options) {
    options = $.extend(
      {
        maxRetries: GiphyRepository.CONFIG.MAX_RETRIES,
        maxSize: GiphyRepository.CONFIG.MAX_SIZE,
      },
      options
    );

    const _getRandomGif = (retry = 0) => {
      const hasReachedRetryLimit = retry >= options.maxRetries;
      if (hasReachedRetryLimit) {
        throw new Error(`Unable to fetch a proper gif within ${options.maxRetries} retries`);
      }

      return this.giphyService
        .getRandom(options.tag)
        .then(({data: randomGif}) => {
          if (!randomGif.id) {
            throw new Error(`Could not find any gif with tag '${options.tag}'`);
          }
          return this.giphyService.getById(randomGif.id);
        })
        .then(({data: {images, url}}) => {
          const staticGif = images[z.extension.GiphyContentSizes.FIXED_WIDTH_STILL];
          const animatedGif = images[z.extension.GiphyContentSizes.DOWNSIZED];

          const exceedsMaxSize = animatedGif.size > options.maxSize;
          if (exceedsMaxSize) {
            this.logger.info(`Gif size (${animatedGif.size}) is over maximum size (${animatedGif.size})`);
            return _getRandomGif(retry + 1);
          }

          return {
            animated: animatedGif.url,
            static: staticGif.url,
            url: url,
          };
        });
    };

    return _getRandomGif();
  }

  /**
   * Get random GIFs for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.query - Search query term or phrase
   * @param {number} options.number - Amount of GIFs to retrieve
   * @param {number} [options.max_size=3MB] - Maximum gif size in bytes
   * @param {boolean} [options.random=true] - Will return an randomized result
   * @param {string} [options.sorting='recent'] - Specify sorting ('relevant' or 'recent')
   * @returns {Promise} Resolves with gifs
   */
  getGifs(options) {
    let offset = 0;

    options = $.extend(
      {
        maxSize: GiphyRepository.CONFIG.MAX_SIZE,
        random: true,
        results: GiphyRepository.CONFIG.NUMBER_OF_RESULTS,
        sorting: 'relevant',
      },
      options
    );

    if (!options.query) {
      const error = new Error('No query specified');
      this.logger.error(error.message, error);
      throw error;
    }

    if (options.random) {
      const total = this.gifQueryCache[options.query];
      if (total) {
        const resultExceedsTotal = options.results >= total;
        offset = resultExceedsTotal ? 0 : Math.floor(Math.random() * (total - options.number));
      }
    }

    return this.giphyService
      .getSearch({
        limit: 100,
        offset: offset,
        // eslint-disable-next-line id-length
        q: options.query,
        sort: options.sorting,
      })
      .then(({data: gifs, pagination}) => {
        const result = [];

        if (options.random) {
          gifs = gifs.sort(() => 0.5 - Math.random());
        }

        this.gifQueryCache[options.query] = pagination.total_count;

        for (const {images, url} of gifs.slice(0, options.number)) {
          const staticGif = images[z.extension.GiphyContentSizes.FIXED_WIDTH_STILL];
          const animatedGif = images[z.extension.GiphyContentSizes.DOWNSIZED];

          const exceedsMaxSize = animatedGif.size > options.maxSize;
          if (!exceedsMaxSize) {
            result.push({
              animated: animatedGif.url,
              static: staticGif.url,
              url: url,
            });
          }
        }

        return result;
      })
      .catch(error => {
        this.logger.info(`Unable to fetch gif for query: ${options.query}`, error);
        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

// Enum of different Giphy content sizes.
z.extension.GiphyContentSizes = {
  DOWNSIZED: 'downsized',
  DOWNSIZED_LARGE: 'downsized_large',
  DOWNSIZED_STILL: 'downsized_still',
  FIXED_HEIGHT: 'fixed_height',
  FIXED_HEIGHT_DOWNSAMPLED: 'fixed_height_downsampled',
  FIXED_HEIGHT_SMALL: 'fixed_height_small',
  FIXED_HEIGHT_SMALL_STILL: 'fixed_height_small_still',
  FIXED_HEIGHT_STILL: 'fixed_height_still',
  FIXED_WIDTH: 'fixed_width',
  FIXED_WIDTH_DOWNSAMPLED: 'fixed_width_downsampled',
  FIXED_WIDTH_SMALL: 'fixed_width_small',
  FIXED_WIDTH_SMALL_STILL: 'fixed_width_small_still',
  FIXED_WIDTH_STILL: 'fixed_width_still',
  ORIGINAL: 'original',
  ORIGINAL_STILL: 'original_still',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationMapper = (() => {
  const _mapProviderFromObject = providerData => {
    return _updateProviderFromObject(providerData);
  };

  const _mapServicesFromArray = (servicesData = []) => {
    return servicesData
      .filter(serviceData => serviceData.enabled)
      .map(serviceData => _updateServiceFromObject(serviceData));
  };

  const _mapServiceFromObject = serviceData => {
    return _updateServiceFromObject(serviceData);
  };

  const _updateProviderFromObject = (providerData, providerEntity = new z.integration.ProviderEntity()) => {
    if (providerData) {
      const {description, email, id, name, url} = providerData;

      if (id) {
        providerEntity.id = id;
      }

      if (description) {
        providerEntity.description = description;
      }

      if (email) {
        providerEntity.email = email;
      }

      if (name) {
        providerEntity.name = name;
      }

      if (url) {
        providerEntity.url = url;
      }
    }

    return providerEntity;
  };

  const _updateServiceFromObject = (serviceData, serviceEntity = new z.integration.ServiceEntity()) => {
    if (serviceData) {
      const {assets, description, id, name, provider: providerId, summary, tags} = serviceData;

      if (id) {
        serviceEntity.id = id;
      }

      if (assets && assets.length) {
        const mappedAssets = z.assets.AssetMapper.mapProfileAssets(serviceEntity.id, assets);
        z.assets.AssetMapper.updateUserEntityAssets(serviceEntity, mappedAssets);
      }

      if (description) {
        serviceEntity.description = description;
      }

      if (name) {
        serviceEntity.name = name;
      }

      if (providerId) {
        serviceEntity.providerId = providerId;
      }

      if (summary) {
        serviceEntity.summary = summary;
      }

      if (tags) {
        serviceEntity.tags = tags;
      }
    }

    return serviceEntity;
  };

  return {
    mapProviderFromObject: _mapProviderFromObject,
    mapServiceFromObject: _mapServiceFromObject,
    mapServicesFromArray: _mapServicesFromArray,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationRepository = class IntegrationRepository {
  /**
   * Trim query string for search.
   * @param {string} query - Service search string
   * @returns {string} Normalized service search query
   */
  static normalizeQuery(query) {
    if (!_.isString(query)) {
      return '';
    }
    return query.trim().toLowerCase();
  }

  constructor(integrationService, conversationRepository, teamRepository) {
    this.logger = new z.util.Logger('z.integration.IntegrationRepository', z.config.LOGGER.OPTIONS);

    this.integrationService = integrationService;

    this.conversationRepository = conversationRepository;
    this.teamRepository = teamRepository;

    this.isTeam = this.teamRepository.isTeam;
    this.services = ko.observableArray([]);
  }

  /**
   * Get provider name for entity.
   * @param {ServiceEntity|User} entity - Service or user to add provider name to
   * @returns {Promise} - Resolves with the entity
   */
  addProviderNameToParticipant(entity) {
    const shouldUpdateProviderName = entity.providerName && !entity.providerName().trim();
    return shouldUpdateProviderName
      ? this.getProviderById(entity.providerId).then(providerEntity => {
          entity.providerName(providerEntity.name);
          return entity;
        })
      : entity;
  }

  /**
   * Get ServiceEntity for entity.
   * @param {z.integration.ServiceEntity|User} entity - Service or user to resolve to ServiceEntity
   * @returns {Promise} - Resolves with the ServiceEntity
   */
  getServiceFromUser(entity) {
    if (entity instanceof z.integration.ServiceEntity) {
      return Promise.resolve(entity);
    }
    const {providerId, serviceId} = entity;
    return this.getServiceById(providerId, serviceId);
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add service to
   * @param {z.integration.ServiceEntity} serviceEntity - Service to be added to conversation
   * @param {string} method - Method used to add service
   * @returns {Promise} Resolves when service was added
   */
  addService(conversationEntity, serviceEntity, method) {
    const {id: serviceId, name, providerId} = serviceEntity;
    this.logger.info(`Adding service '${name}' to conversation '${conversationEntity.id}'`, serviceEntity);

    return this.conversationRepository.addService(conversationEntity, providerId, serviceId).then(event => {
      if (event) {
        const attributes = {
          conversation_size: conversationEntity.getNumberOfParticipants(true, false),
          method: method,
          service_id: serviceId,
          services_size: conversationEntity.getNumberOfServices(),
        };

        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.INTEGRATION.ADDED_SERVICE, attributes);
      }

      return event;
    });
  }

  /**
   * Add service to conversation.
   *
   * @param {z.integration.ServiceEntity} serviceEntity - Information about service to be added
   * @returns {Promise} Resolves when conversation with the integration was was created
   */
  create1to1ConversationWithService(serviceEntity) {
    return this.conversationRepository
      .createGroupConversation([], undefined, z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM)
      .then(conversationEntity => {
        if (conversationEntity) {
          return this.addService(conversationEntity, serviceEntity, 'start_ui').then(() => conversationEntity);
        }

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      })
      .catch(error => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
          text: {
            message: z.l10n.text(z.string.modalIntegrationUnavailableMessage),
            title: z.l10n.text(z.string.modalIntegrationUnavailableHeadline),
          },
        });
        throw error;
      });
  }

  /**
   * Get conversation with a service.
   * @param {Service} serviceEntity - Service entity for whom to get the conversation
   * @returns {Promise} Resolves with the conversation with requested service
   */
  get1To1ConversationWithService(serviceEntity) {
    const matchingConversationEntity = this.conversationRepository.conversations().find(conversationEntity => {
      if (!conversationEntity.is1to1()) {
        // Disregard conversations that are not 1:1
        return false;
      }

      const isActiveConversation = !conversationEntity.removed_from_conversation();
      if (!isActiveConversation) {
        // Disregard coversations that self is no longer part of
        return false;
      }

      const [userEntity] = conversationEntity.participating_user_ets();
      if (!userEntity) {
        // Disregard conversations with no user entities
        return false;
      }

      if (!userEntity.isService) {
        // Disregard conversations with users instead of services
        return false;
      }

      const {serviceId, providerId} = userEntity;
      const isExpectedServiceId = serviceEntity.id === serviceId;
      const isExpectedProviderId = serviceEntity.providerId === providerId;
      return isExpectedServiceId && isExpectedProviderId;
    });

    return matchingConversationEntity
      ? Promise.resolve(matchingConversationEntity)
      : this.create1to1ConversationWithService(serviceEntity);
  }

  getProviderById(providerId) {
    return this.integrationService.getProvider(providerId).then(providerData => {
      if (providerData) {
        return z.integration.IntegrationMapper.mapProviderFromObject(providerData);
      }
    });
  }

  getServiceById(providerId, serviceId) {
    return this.integrationService.getService(providerId, serviceId).then(serviceData => {
      if (serviceData) {
        return z.integration.IntegrationMapper.mapServiceFromObject(serviceData);
      }
    });
  }

  getServices(tags, start) {
    const tagsArray = _.isArray(tags) ? tags.slice(0, 3) : [z.integration.ServiceTag.INTEGRATION];

    return this.integrationService.getServices(tagsArray.join(','), start).then(({services: servicesData}) => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  getServicesByProvider(providerId) {
    return this.integrationService.getProviderServices(providerId).then(servicesData => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  /**
   * Remove service from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove service from
   * @param {z.entity.User} userEntity - Service user to be removed from the conversation
   * @returns {Promise} Resolves when service was removed from the conversation
   */
  removeService(conversationEntity, userEntity) {
    const {id: userId, serviceId} = userEntity;

    return this.conversationRepository.removeService(conversationEntity, userId).then(event => {
      if (event) {
        const attributes = {service_id: serviceId};
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.INTEGRATION.REMOVED_SERVICE, attributes);
        return event;
      }
    });
  }

  searchForServices(query, queryObservable) {
    const normalizedQuery = IntegrationRepository.normalizeQuery(query);

    return this.teamRepository
      .getWhitelistedServices(this.teamRepository.team().id, 20)
      .then(serviceEntities => {
        const isCurrentQuery = normalizedQuery === IntegrationRepository.normalizeQuery(queryObservable());
        if (isCurrentQuery) {
          serviceEntities = serviceEntities
            .filter(serviceEntity => z.util.StringUtil.compareTransliteration(serviceEntity.name, normalizedQuery))
            .sort((serviceA, serviceB) => {
              return z.util.StringUtil.sortByPriority(serviceA.name, serviceB.name, normalizedQuery);
            });
          this.services(serviceEntities);
        }
      })
      .catch(error => this.logger.error(`Error searching for services: ${error.message}`, error));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationService = class IntegrationService {
  static get URL() {
    return {
      PROVIDERS: '/providers',
      SERVICES: '/services',
    };
  }

  /**
   * Construct a new Integration Service.
   * @class z.integration.IntegrationService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.integration.IntegrationService', z.config.LOGGER.OPTIONS);
  }

  getProvider(providerId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}`,
    });
  }

  getProviderServices(providerId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}${IntegrationService.URL.SERVICES}`,
    });
  }

  getService(providerId, serviceId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}${IntegrationService.URL.SERVICES}/${serviceId}`,
    });
  }

  getServices(tags, start) {
    const params = {tags};
    if (start) {
      params.start = start;
    }

    return this.backendClient.sendRequest({
      data: params,
      type: 'GET',
      url: IntegrationService.URL.SERVICES,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ProviderEntity = class ProviderEntity {
  constructor(providerData = {}) {
    const {description, id, name, url, email} = providerData;

    this.id = id || '';

    this.description = description || '';
    this.email = email || '';
    this.name = name || '';
    this.url = url || '';
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ServiceEntity = class ServiceEntity {
  constructor(serviceData = {}) {
    const {description, id, name, provider: providerId, summary, tags} = serviceData;

    this.id = id || '';

    this.description = description || '';
    this.name = name || '';
    this.providerId = providerId || '';
    this.providerName = ko.observable(' ');
    this.summary = summary || '';
    this.tags = tags || [];

    this.mediumPictureResource = ko.observable();
    this.previewPictureResource = ko.observable();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ServiceTag = {
  AUDIO: 'audio',
  BOOKS: 'books',
  BUSINESS: 'business',
  DESIGN: 'design',
  EDUCATION: 'education',
  ENTERTAINMENT: 'entertainment',
  FINANCE: 'finance',
  FITNESS: 'fitness',
  FOOD_DRINK: 'food-drink',
  GAMES: 'games',
  GRAPHICS: 'graphics',
  HEALTH: 'health',
  INTEGRATION: 'integration',
  LIFETSTYLE: 'lifestyle',
  MEDIA: 'media',
  MEDICAL: 'medical',
  MOVIES: 'movies',
  MUSIC: 'music',
  NEWS: 'news',
  PHOTOGRAPHY: 'photography',
  POLL: 'poll',
  PRODUCTIVITY: 'productivity',
  QUIZ: 'quiz',
  RATING: 'rating',
  SHOPPING: 'shopping',
  SOCIAL: 'social',
  SPORTS: 'sports',
  TRAVEL: 'travel',
  TUTORIAL: 'tutorial',
  VIDEO: 'video',
  WEATHER: 'weather',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.LifecycleService = class LifecycleService {
  static get CONFIG() {
    return {
      URL: {
        VERSION: '/version/',
      },
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.lifecycle.LifecycleService', z.config.LOGGER.OPTIONS);
  }

  getVersion() {
    return this._fetchData(LifecycleService.CONFIG.URL.VERSION).then(({version}) => version);
  }

  _fetchData(url) {
    return fetch(url).then(response => {
      if (response.ok) {
        return response.json();
      }
      throw new Error(`Failed to fetch '${url}': ${response.statusText}`);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.LifecycleRepository = class LifecycleRepository {
  static get CONFIG() {
    return {
      CHECK_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR * 3,
      CHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE * 5,
      UPDATE_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR * 6,
    };
  }

  constructor(lifecycleService, userRepository) {
    this.logger = new z.util.Logger('z.lifecycle.LifecycleRepository', z.config.LOGGER.OPTIONS);
    this.lifecycleService = lifecycleService;
    this.userRepository = userRepository;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
  }

  init() {
    if (this.isActivatedAccount()) {
      window.setInterval(() => this.checkVersion(), LifecycleRepository.CONFIG.CHECK_INTERVAL);
    }
  }

  checkVersion() {
    const shouldCheckVersion = this.isActivatedAccount() && navigator.onLine;
    if (shouldCheckVersion) {
      return this.lifecycleService.getVersion().then(serverVersion => {
        const currentVersion = z.util.Environment.version(false, true);
        this.logger.info(`Checking current webapp version. Server '${serverVersion}' vs. local '${currentVersion}'`);

        const isOutdatedVersion = serverVersion > currentVersion;
        if (isOutdatedVersion) {
          amplify.publish(z.event.WebApp.LIFECYCLE.UPDATE, z.lifecycle.UPDATE_SOURCE.WEBAPP);
        }
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.UPDATE_SOURCE = {
  WEBAPP: 'webapp',
};

// @todo Added for wrapper backwards compatibility. Remove after uptake of version > 3.1.
window.z.announce = z.announce || {};
z.announce.UPDATE_SOURCE = z.lifecycle.UPDATE_SOURCE;

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

const codeBlockRegex = /(`|```)[^]*?\1/gm;

z.links.LinkPreviewHelpers = {
  /**
   * Check if the text contains only one link
   * @param {string} text - Text to parse
   * @returns {boolean} Text contains only a link
   */
  containsOnlyLink(text) {
    const textWithoutCode = text.trim().replace(codeBlockRegex, '');
    const urls = linkify.find(textWithoutCode, 'url');
    return urls.length === 1 && urls[0].value === textWithoutCode;
  },

  /**
   * Get first link and link offset for given text.
   * @param {string} text - Text to parse
   * @returns {Object} Containing link and its offset
   */
  getFirstLinkWithOffset(text) {
    const textWithoutCode = text.trim().replace(codeBlockRegex, '');

    const [firstLink] = linkify.find(textWithoutCode, 'url');

    if (firstLink) {
      const linkOffset = textWithoutCode.indexOf(firstLink.value);
      return {
        offset: linkOffset,
        url: firstLink.value,
      };
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewMetaDataType = {
  TWEET: 'tweet',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewProtoBuilder = {
  /**
   * Create Protocol Buffers message for link previews.
   * Open Graph data can be validated through: https://developers.facebook.com/tools/debug/
   *
   * @param {Object} data - Open graph data
   * @param {string} url - Link entered by the user
   * @param {number} offset - Starting index of the link
   *
   * @returns {z.proto.LinkPreview} Link preview proto
   */
  buildFromOpenGraphData(data, url, offset = 0) {
    if (!_.isEmpty(data)) {
      data.url = data.url || url;

      if (data.title && data.url) {
        const protoArticle = new z.proto.Article(data.url, data.title, data.description); // deprecated format

        const {description, title, url: dataUrl} = data;
        const protoLinkPreview = new z.proto.LinkPreview(url, offset, protoArticle, dataUrl, title, description);

        if (data.site_name === 'Twitter' && z.util.ValidationUtil.urls.isTweet(data.url)) {
          const author = data.title.replace('on Twitter', '').trim();
          const username = data.url.match(/com\/([^/]*)\//)[1];
          const protoTweet = new z.proto.Tweet(author, username);

          protoLinkPreview.set(z.cryptography.PROTO_MESSAGE_TYPE.TWEET, protoTweet);
          protoLinkPreview.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_TITLE, data.description);
        }

        return protoLinkPreview;
      }
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewRepository = class LinkPreviewRepository {
  constructor(assetService, propertiesRepository) {
    this.getLinkPreviewFromString = this.getLinkPreviewFromString.bind(this);
    this.updatedSendPreference = this.updatedSendPreference.bind(this);

    this.assetService = assetService;
    this.logger = new z.util.Logger('z.links.LinkPreviewRepository', z.config.LOGGER.OPTIONS);

    this.shouldSendPreviews = propertiesRepository.getPreference(z.properties.PROPERTIES_TYPE.PREVIEWS.SEND);

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.PREVIEWS.SEND, this.updatedSendPreference);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, properties => {
      this.updatedSendPreference(properties.settings.previews.send);
    });
  }

  /**
   * Searches for url in given string and creates a link preview.
   *
   * @note This will already upload the associated image as asset
   * @param {string} string - Input text to generate preview for
   * @returns {Promise} Resolves with link preview proto message
   */
  getLinkPreviewFromString(string) {
    if (this.shouldSendPreviews && z.util.Environment.desktop) {
      return Promise.resolve().then(() => {
        const linkData = z.links.LinkPreviewHelpers.getFirstLinkWithOffset(string);

        if (linkData) {
          return this.getLinkPreview(linkData.url, linkData.offset).catch(error => {
            const isLinkPreviewError = error instanceof z.error.LinkPreviewError;
            if (!isLinkPreviewError) {
              throw error;
            }
          });
        }
      });
    }
    return Promise.resolve();
  }

  /**
   * Creates link preview for given link. This will upload associated image as asset and will
   * resolve with an z.proto.LinkPreview instance
   *
   * @param {string} url - URL found to generate link preview from
   * @param {number} [offset=0] - starting index of the link
   * @returns {Promise} Resolves with a link preview if generated
   */
  getLinkPreview(url, offset = 0) {
    let openGraphData;

    return Promise.resolve()
      .then(() => {
        if (z.links.LinkPreviewBlackList.isBlacklisted(url)) {
          throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.BLACKLISTED);
        }

        if (window.openGraph) {
          return this._fetchOpenGraphData(url);
        }

        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.NOT_SUPPORTED);
      })
      .then(fetchedData => {
        if (fetchedData) {
          openGraphData = fetchedData;
          return z.links.LinkPreviewProtoBuilder.buildFromOpenGraphData(openGraphData, url, offset);
        }
        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.NO_DATA_AVAILABLE);
      })
      .then(linkPreview => {
        if (linkPreview) {
          return this._fetchPreviewImage(linkPreview, openGraphData.image);
        }
        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.UNSUPPORTED_TYPE);
      });
  }

  /**
   * Update the send link preview preference
   * @param {boolean} sendPreviewsPreference - Updated preference
   * @returns {undefined} No return value
   */
  updatedSendPreference(sendPreviewsPreference) {
    this.shouldSendPreviews = sendPreviewsPreference;
  }

  /**
   * Fetch and upload open graph images.
   *
   * @private
   * @param {z.proto.LinkPreview} linkPreview - Link preview proto message
   * @param {Object} [openGraphImage={}] - Open graph image URL
   * @returns {Promise} Resolves with the link preview proto message
   */
  _fetchPreviewImage(linkPreview, openGraphImage = {}) {
    if (openGraphImage.data) {
      return this._uploadPreviewImage(openGraphImage.data)
        .then(asset => {
          linkPreview.article.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_IMAGE, asset); // deprecated
          linkPreview.image.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_IMAGE, asset);
          return linkPreview;
        })
        .catch(() => linkPreview);
    }

    return Promise.resolve(linkPreview);
  }

  /**
   * Fetch open graph data.
   *
   * @private
   * @param {string} link - Link to fetch open graph data from
   * @returns {Promise} Resolves with the retrieved open graph data
   */
  _fetchOpenGraphData(link) {
    return new Promise(resolve => {
      return window
        .openGraph(link, (error, data) => {
          if (error) {
            resolve();
          }

          if (data) {
            data = Object.entries(data).reduce((filteredData, [key, value]) => {
              filteredData[key] = Array.isArray(value) ? value[0] : value;
              return filteredData;
            }, {});
          }

          resolve(data);
        })
        .catch(resolve);
    });
  }

  /**
   * Upload open graph image as asset
   *
   * @private
   * @param {string} dataUri - image data as base64 encoded data URI
   * @returns {Promise} Resolves with the uploaded asset
   */
  _uploadPreviewImage(dataUri) {
    return Promise.resolve(z.util.base64ToBlob(dataUri)).then(blob =>
      this.assetService.uploadImageAsset(blob, {public: true})
    );
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewBlackList = (() => {
  const soundCloudStatic = [
    'about',
    'channels',
    'charts',
    'discover',
    'discussion',
    'featured',
    'home',
    'messages',
    'mobile',
    'pages',
    'playlists',
    'sets',
    'settings',
    'stream',
    'terms-of-use',
    'upload',
    'videos',
    'you',
  ];
  const BLACKLIST = [
    `soundcloud.com/(?!${soundCloudStatic.join('|')})`,
    'spotify.com/(?!\\w\\w/)',
    'youtu.be',
    'youtube(-nocookie)?.com/(watch|embed)',
    'vimeo.com/(channels/[^/]+/|video/)?[0-9]+',
  ];

  return {
    isBlacklisted: url => new RegExp(BLACKLIST.join('|')).test(url),
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.location = window.z.location || {};

z.location.LocationService = (() => {
  const GOOGLE_GEOCODE_PROXY_BASE_URL = '/proxy/googlemaps/maps/api/geocode/json';

  const _parseResults = ([{address_components: addressComponents, formatted_address: formattedAddress, geometry}]) => {
    const locationResult = {
      address: formattedAddress,
      lat: geometry.location.lat,
      lng: geometry.location.lng,
    };

    addressComponents.forEach(({long_name: longName, short_name: shortName, types}) => {
      const name = longName || shortName;

      types.forEach(type => {
        locationResult[type] = name;
        const isCountry = type === 'country';
        if (isCountry) {
          locationResult.countryCode = shortName || '';
        }
      });
    });

    const {
      administrative_area_level_1: areaLevel1,
      administrative_area_level_2: areaLevel2,
      administrative_area_level_3: areaLevel3,
      locality,
      natural_feature: naturalFeature,
    } = locationResult;

    locationResult.place = locality || naturalFeature || areaLevel3 || areaLevel2 || areaLevel1;

    delete locationResult.political;
    return z.util.ObjectUtil.escapeProperties(locationResult);
  };

  return class LocationService {
    constructor(backendClient) {
      this.backendClient = backendClient;
    }

    /**
     * Reverse loop up for geo location
     * @param {number} latitude - Latitude of location
     * @param {number} longitude - Longitude of location
     * @returns {Promise} Resolves with the location information
     */
    getLocation(latitude, longitude) {
      return new Promise((resolve, reject) => {
        if (latitude == null || longitude == null) {
          const errorMessage = 'You need to specify latitude and longitude in order to retrieve the location';
          return reject(new z.error.LocationError(z.error.BaseError.MISSING_PARAMETER, errorMessage));
        }

        const requestConfig = {
          data: {
            latlng: `${latitude},${longitude}`,
          },
          type: 'GET',
          url: GOOGLE_GEOCODE_PROXY_BASE_URL,
        };

        return this.backendClient
          .sendRequest(requestConfig)
          .then(response => {
            const isStatusOk = response.status === 'OK';
            return isStatusOk ? resolve(_parseResults(response.results)) : resolve();
          })
          .catch((jqXHR, textStatus, errorThrown) => {
            reject(new z.error.LocationError(z.error.LocationError.TYPE.REQUEST_FAILED, errorThrown));
          });
      });
    }
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.location = window.z.location || {};

z.location.LocationRepository = class LocationRepository {
  constructor(locationService) {
    this.locationService = locationService;
  }

  getLocation(latitude, longitude) {
    return this.locationService.getLocation(latitude, longitude);
  }

  /**
   * Return link to Google Maps.
   *
   * @param {number} latitude - Latitude of location
   * @param {number} longitude - Longitude of location
   * @param {string} name - Name of location
   * @param {string} zoom - Map zoom level
   * @returns {string} URL to location in Google Maps
   */
  getMapsUrl(latitude, longitude, name, zoom) {
    const baseUrl = 'https://google.com/maps/';

    const nameParam = name ? `place/${name}/` : '';
    const locationParam = `@${latitude},${longitude}`;
    const zoomParam = zoom ? `,${zoom}z` : '';

    return `${baseUrl}${nameParam}${locationParam}${zoomParam}`;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaConstraintsHandler = class MediaConstraintsHandler {
  static get CONFIG() {
    return {
      DEFAULT_DEVICE_ID: 'default',
      SCREEN_CONSTRAINTS: {
        CHROME: {
          mandatory: {
            chromeMediaSource: 'desktop',
            maxHeight: 1080,
            minHeight: 1080,
          },
        },
        FIREFOX: {
          frameRate: 30,
          height: {exact: 720},
          mediaSource: 'screen',
        },
      },
      VIDEO_CONSTRAINTS: {
        FULL_HD: {
          frameRate: 30,
          height: 1080,
          width: 1920,
        },
        GROUP: {
          frameRate: 30,
          height: 240,
          width: 320,
        },
        HD: {
          frameRate: 30,
          height: 720,
          width: 1280,
        },
        MOBILE: {
          frameRate: 30,
          height: 480,
          width: 640,
        },
        PREFERRED_FACING_MODE: 'user',
      },
    };
  }

  /**
   * Construct a new MediaConstraints handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository with with references to all other handlers
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaConstraintsHandler', z.config.LOGGER.OPTIONS);
  }

  //##############################################################################
  // MediaStream constraints
  //##############################################################################

  /**
   * Get the MediaStreamConstraints to be used for MediaStream creation.
   *
   * @private
   * @param {boolean} [requestAudio=false] - Request audio in the constraints
   * @param {boolean} [requestVideo=false] - Request video in the constraints
   * @param {boolean} [isGroup=false] - Get constraints for group
   * @returns {Promise} Resolves with MediaStreamConstraints
   */
  getMediaStreamConstraints(requestAudio = false, requestVideo = false, isGroup = false) {
    return Promise.resolve().then(() => {
      const currentDeviceId = this.mediaRepository.devicesHandler.currentDeviceId;
      const mode = isGroup ? z.media.VIDEO_QUALITY_MODE.GROUP : z.media.VIDEO_QUALITY_MODE.MOBILE;

      return {
        audio: requestAudio ? this._getAudioStreamConstraints(currentDeviceId.audioInput()) : undefined,
        video: requestVideo ? this._getVideoStreamConstraints(currentDeviceId.videoInput(), mode) : undefined,
      };
    });
  }

  /**
   * Get the video constraints to be used for MediaStream creation.
   * @private
   * @param {string} [mediaDeviceId=''] - ID of MediaDevice to be used
   * @returns {Object} Video stream constraints
   */
  _getAudioStreamConstraints(mediaDeviceId = '') {
    const requireExactMediaDevice = mediaDeviceId && mediaDeviceId !== MediaConstraintsHandler.CONFIG.DEFAULT_DEVICE_ID;
    return requireExactMediaDevice ? {deviceId: {exact: mediaDeviceId}} : true;
  }

  /**
   * Get the MediaStreamConstraints to be used for screen sharing.
   * @returns {Promise} Resolves with MediaStreamConstraints and their type
   */
  getScreenStreamConstraints() {
    if (window.desktopCapturer) {
      this.logger.info('Enabling screen sharing from Electron');

      const streamConstraints = {
        audio: false,
        video: MediaConstraintsHandler.CONFIG.SCREEN_CONSTRAINTS.CHROME,
      };

      const chromeMediaSourceId = this.mediaRepository.devicesHandler.currentDeviceId.screenInput();
      streamConstraints.video.mandatory = Object.assign(streamConstraints.video.mandatory, {chromeMediaSourceId});

      return Promise.resolve(streamConstraints);
    }

    if (z.util.Environment.browser.firefox) {
      this.logger.info('Enabling screen sharing from Firefox');

      const streamConstraints = {
        audio: false,
        video: MediaConstraintsHandler.CONFIG.SCREEN_CONSTRAINTS.FIREFOX,
      };

      return Promise.resolve(streamConstraints);
    }

    return Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.SCREEN_NOT_SUPPORTED));
  }

  /**
   * Get the video constraints to be used for MediaStream creation.
   *
   * @private
   * @param {string} mediaDeviceId - Optional ID of MediaDevice to be used
   * @param {z.media.VIDEO_QUALITY_MODE} [mode=z.media.VIDEO_QUALITY_MODE.MOBILE] - Quality of video stream requested
   * @returns {Object} Video stream constraints
   */
  _getVideoStreamConstraints(mediaDeviceId, mode = z.media.VIDEO_QUALITY_MODE.MOBILE) {
    let streamConstraints;
    switch (mode) {
      case z.media.VIDEO_QUALITY_MODE.FULL_HD: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.FULL_HD;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.GROUP: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.GROUP;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.HD: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.HD;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.MOBILE:
      default: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.MOBILE;
        break;
      }
    }

    if (_.isString(mediaDeviceId)) {
      streamConstraints.deviceId = {exact: mediaDeviceId};
    } else {
      streamConstraints.facingMode = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.PREFERRED_FACING_MODE;
    }

    return streamConstraints;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaDevicesHandler = class MediaDevicesHandler {
  static get CONFIG() {
    return {
      DEFAULT_DEVICE_ID: 'default',
      SCREEN_DEVICE_TYPE: 'screen',
    };
  }

  /**
   * Construct a new MediaDevices handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository referencing the other handlers
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaDevicesHandler', z.config.LOGGER.OPTIONS);

    this.availableDevices = {
      audioInput: ko.observableArray([]),
      audioOutput: ko.observableArray([]),
      screenInput: ko.observableArray([]),
      videoInput: ko.observableArray([]),
    };

    this.currentDeviceId = {
      audioInput: ko.observable(),
      audioOutput: ko.observable(),
      screenInput: ko.observable(),
      videoInput: ko.observable(),
    };

    this.currentDeviceIndex = {
      audioInput: ko.observable(0),
      audioOutput: ko.observable(0),
      screenInput: ko.observable(0),
      videoInput: ko.observable(0),
    };

    this.deviceSupport = {
      audioInput: ko.pureComputed(() => !!this.availableDevices.audioInput().length),
      audioOutput: ko.pureComputed(() => !!this.availableDevices.audioOutput().length),
      screenInput: ko.pureComputed(() => !!this.availableDevices.screenInput().length),
      videoInput: ko.pureComputed(() => !!this.availableDevices.videoInput().length),
    };

    this.initializeMediaDevices();
  }

  /**
   * Initialize the list of MediaDevices and subscriptions.
   * @returns {undefined} No return value
   */
  initializeMediaDevices() {
    if (z.media.MediaRepository.supportsMediaDevices()) {
      this.getMediaDevices().then(() => {
        this._setCurrentDevices();
        this._subscribeToObservables();
        this._subscribeToDevices();
      });
    }
  }

  /**
   * Set current media device IDs.
   * @returns {undefined} No return value
   */
  _setCurrentDevices() {
    const defaultDeviceId = MediaDevicesHandler.CONFIG.DEFAULT_DEVICE_ID;

    const audioInputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.AUDIO_INPUT) || defaultDeviceId;
    this.currentDeviceId.audioInput(audioInputId);

    const audioOutputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.AUDIO_OUTPUT) || defaultDeviceId;
    this.currentDeviceId.audioOutput(audioOutputId);

    const videoInputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.VIDEO_INPUT);
    this.currentDeviceId.videoInput(videoInputId);

    const setDefaultVideoId = !this.currentDeviceId.videoInput() && this.deviceSupport.videoInput();
    if (setDefaultVideoId) {
      const defaultDeviceIndex = this.availableDevices.videoInput().length - 1;
      const videoDeviceId = this.availableDevices.videoInput()[defaultDeviceIndex].deviceId;

      this.currentDeviceId.videoInput(videoDeviceId);
      this.currentDeviceIndex.videoInput(defaultDeviceIndex);
    }

    this.logger.info('Set selected MediaDevice IDs');
  }

  /**
   * Subscribe to MediaDevices updates if available.
   * @returns {undefined} No return value
   */
  _subscribeToDevices() {
    navigator.mediaDevices.ondevicechange = () => {
      this.logger.info('List of available MediaDevices has changed');
      this.getMediaDevices();
    };
  }

  /**
   * Subscribe to Knockout observables.
   * @returns {undefined} No return value
   */
  _subscribeToObservables() {
    this.availableDevices.audioInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.AUDIO_INPUT, mediaDevices);
      }
    });

    this.availableDevices.audioOutput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDevices);
      }
    });

    this.availableDevices.screenInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.SCREEN_INPUT, mediaDevices);
      }
    });

    this.availableDevices.videoInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.VIDEO_INPUT, mediaDevices);
      }
    });

    this.currentDeviceId.audioInput.subscribe(mediaDeviceId => {
      z.util.StorageUtil.setValue(z.media.MediaDeviceType.AUDIO_INPUT, mediaDeviceId);

      const updateStream = mediaDeviceId && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.AUDIO, z.media.MediaDeviceType.AUDIO_INPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.audioOutput.subscribe(mediaDeviceId => {
      z.util.StorageUtil.setValue(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDeviceId);

      if (mediaDeviceId) {
        this.mediaRepository.elementHandler.switchMediaElementOutput(mediaDeviceId);
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.screenInput.subscribe(mediaDeviceId => {
      if (mediaDeviceId) {
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.SCREEN_INPUT, mediaDeviceId);
      }

      const isMediaTypeScreen = this.mediaRepository.streamHandler.localMediaType() === z.media.MediaType.SCREEN;
      const updateStream = mediaDeviceId && isMediaTypeScreen && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.SCREEN, z.media.MediaDeviceType.SCREEN_INPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.videoInput.subscribe(mediaDeviceId => {
      if (mediaDeviceId) {
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);
      }

      z.util.StorageUtil.setValue(z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);

      const isMediaTypeVideo = this.mediaRepository.streamHandler.localMediaType() === z.media.MediaType.VIDEO;
      const updateStream = mediaDeviceId && isMediaTypeVideo && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.VIDEO, z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);
      }
    });
  }

  /**
   * Update list of available MediaDevices.
   * @returns {Promise} Resolves with all MediaDevices when the list has been updated
   */
  getMediaDevices() {
    return navigator.mediaDevices
      .enumerateDevices()
      .catch(error => {
        this.logger.error(`Failed to update MediaDevice list: ${error.message}`, error);
        throw error;
      })
      .then(mediaDevices => {
        this._removeAllDevices();

        if (mediaDevices) {
          const audioInputDevices = [];
          const audioOutputDevices = [];
          const videoInputDevices = [];

          mediaDevices.forEach(mediaDevice => {
            switch (mediaDevice.kind) {
              case z.media.MediaDeviceType.AUDIO_INPUT: {
                audioInputDevices.push(mediaDevice);
                break;
              }

              case z.media.MediaDeviceType.AUDIO_OUTPUT: {
                audioOutputDevices.push(mediaDevice);
                break;
              }

              case z.media.MediaDeviceType.VIDEO_INPUT: {
                videoInputDevices.push(mediaDevice);
                break;
              }

              default: {
                throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
              }
            }
          });

          z.util.koArrayPushAll(this.availableDevices.audioInput, audioInputDevices);
          z.util.koArrayPushAll(this.availableDevices.audioOutput, audioOutputDevices);
          z.util.koArrayPushAll(this.availableDevices.videoInput, videoInputDevices);

          this.logger.info('Updated MediaDevice list', mediaDevices);
          return mediaDevices;
        }
        throw new z.error.MediaError(z.error.MediaError.TYPE.NO_MEDIA_DEVICES_FOUND);
      });
  }

  /**
   * Update list of available Screens.
   * @returns {Promise} resolves with all screen sources when the list has been updated
   */
  getScreenSources() {
    return new Promise((resolve, reject) => {
      const options = {
        thumbnailSize: {
          height: 176,
          width: 312,
        },
        types: [MediaDevicesHandler.CONFIG.SCREEN_DEVICE_TYPE],
      };

      return window.desktopCapturer.getSources(options, (error, screenSources) => {
        if (error) {
          return reject(error);
        }

        this.logger.info(`Detected '${screenSources.length}' sources for screen sharing from Electron`, screenSources);
        this.availableDevices.screenInput(screenSources);

        if (screenSources.length === 1) {
          const [firstScreenSource] = screenSources;
          this.currentDeviceId.screenInput('');
          this.logger.info(`Selected '${firstScreenSource.name}' for screen sharing`, firstScreenSource);
          this.currentDeviceId.screenInput(firstScreenSource.id);
        }
        return resolve(screenSources);
      });
    });
  }

  /**
   * Replace input device of given type
   *
   * @private
   * @param {z.media.MediaType} mediaType - Media type to change device for
   * @param {z.media.MediaDeviceType} mediaDeviceType - Media device type to change
   * @param {string} mediaDeviceId - New media device Id
   * @returns {undefined} No return value
   */
  _replaceInputDevice(mediaType, mediaDeviceType, mediaDeviceId) {
    this.mediaRepository.streamHandler
      .replaceInputSource(mediaType)
      .then(() => this._updateCurrentIndexFromId(mediaDeviceType, mediaDeviceId))
      .catch(error => {
        this.logger.error(`Failed to replace input device of type '${mediaType}'`, error);
      });
  }

  /**
   * Toggle between the available cameras.
   * @returns {Promise} Resolves when camera has been toggled.
   */
  toggleNextCamera() {
    return this.getMediaDevices().then(() => {
      const availableDevices = this.availableDevices.videoInput();
      const currentDeviceId = this.currentDeviceId.videoInput;
      const currentDeviceIndex = this.currentDeviceIndex.videoInput();

      const {deviceName, nextDeviceId} = this._toggleNextDevice(availableDevices, currentDeviceId, currentDeviceIndex);
      this.logger.info(`Switching the active camera from '${deviceName}' to '${nextDeviceId}'`);
    });
  }

  /**
   * Toggle between the available screens.
   * @returns {Promise} Resolves when screen has been toggled.
   */
  toggleNextScreen() {
    return this.getScreenSources().then(() => {
      const availableDevices = this.availableDevices.screenInput();
      const currentDeviceId = this.currentDeviceId.screenInput;
      const currentDeviceIndex = this.currentDeviceIndex.screenInput();

      const {deviceName, nextDeviceId} = this._toggleNextDevice(availableDevices, currentDeviceId, currentDeviceIndex);
      this.logger.info(`Switching the active screen from '${deviceName}' to '${nextDeviceId}'`);
    });
  }

  _toggleNextDevice(availableDevices, currentDeviceIdObservable, currentDeviceIndex) {
    const {device} = this._getCurrentDevice(availableDevices, currentDeviceIdObservable());
    const nextIndex = z.util.ArrayUtil.iterateIndex(availableDevices, currentDeviceIndex);

    const nextDevice = availableDevices[nextIndex || 0];
    const deviceId = nextDevice.deviceId || nextDevice.id;
    const label = nextDevice.label || nextDevice.name;

    currentDeviceIdObservable(deviceId);

    const deviceName = device ? device.label || device.deviceId : undefined;
    const nextDeviceId = label || deviceId;

    return {deviceName, nextDeviceId};
  }

  /**
   * Check for availability of selected devices.
   * @param {boolean} videoSend - Also check for video devices
   * @returns {Promise} Resolves when the current device has been updated
   */
  updateCurrentDevices(videoSend) {
    return this.getMediaDevices().then(() => {
      const _checkDevice = (mediaType, deviceType) => {
        deviceType = this._typeConversion(deviceType);

        const deviceIdObservable = this.currentDeviceId[`${deviceType}`];
        const mediaDevices = this.availableDevices[`${deviceType}`]();
        const {device: mediaDevice} = this._getCurrentDevice(mediaDevices, deviceIdObservable());

        if (!mediaDevice) {
          const [updatedDevice] = this.availableDevices[`${deviceType}`]();

          if (updatedDevice) {
            const id = updatedDevice.label || updatedDevice.deviceId;
            const log = `Selected '${mediaType}' device '${deviceIdObservable()}' not found and replaced by '${id}'`;
            this.logger.warn(log, mediaDevices);
            return deviceIdObservable(updatedDevice.deviceId);
          }

          const logMessage = `Selected '${mediaType}' device '${deviceIdObservable()}' not found and reset'`;
          this.logger.warn(logMessage, mediaDevices);
          return deviceIdObservable('');
        }
      };

      _checkDevice(z.media.MediaType.AUDIO, z.media.MediaDeviceType.AUDIO_INPUT);
      if (videoSend) {
        _checkDevice(z.media.MediaType.VIDEO, z.media.MediaDeviceType.VIDEO_INPUT);
      }
    });
  }

  /**
   * Get the currently selected MediaDevice.
   *
   * @param {Array} mediaDevices - Array of MediaDevices
   * @param {string} currentDeviceId - ID of selected MediaDevice
   * @returns {Object} Selected MediaDevice and its array index
   */
  _getCurrentDevice(mediaDevices, currentDeviceId) {
    for (const [index, mediaDevice] of mediaDevices.entries()) {
      const isCurrentDevice = mediaDevice.deviceId === currentDeviceId || mediaDevice.id === currentDeviceId;
      if (isCurrentDevice) {
        return {device: mediaDevice, deviceIndex: index};
      }
    }

    return {deviceIndex: 0};
  }

  /**
   * Remove all known MediaDevices from the lists.
   * @private
   * @returns {undefined} No return value
   */
  _removeAllDevices() {
    this.availableDevices.audioInput.removeAll();
    this.availableDevices.audioOutput.removeAll();
    this.availableDevices.videoInput.removeAll();
  }

  /**
   * Add uppercase to MediaDevice types.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - Device type string to update
   * @returns {string} Updated device type
   */
  _typeConversion(deviceType) {
    return deviceType.replace('input', 'Input').replace('output', 'Output');
  }

  /**
   * Update the current index by searching for the current device.
   *
   * @private
   * @param {ko.observable} indexObservable - Observable containing the current index
   * @param {Array} availableDevices - Array of MediaDevices
   * @param {string} currentDeviceId - Current device ID to look for
   * @returns {undefined} No return value
   */
  _updateCurrentDeviceIndex(indexObservable, availableDevices, currentDeviceId) {
    const {deviceIndex} = this._getCurrentDevice(availableDevices, currentDeviceId);

    if (_.isNumber(deviceIndex)) {
      indexObservable(deviceIndex);
    }
  }

  /**
   * Update the index for current device after the list of devices changed.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - MediaDeviceType to be updates
   * @param {Array} availableDevices - Array of MediaDevices
   * @returns {undefined} No return value
   */
  _updateCurrentIndexFromDevices(deviceType, availableDevices) {
    deviceType = this._typeConversion(deviceType);
    const deviceIndexObservable = this.currentDeviceIndex[deviceType];
    const currentDeviceId = this.currentDeviceId[deviceType]();

    this._updateCurrentDeviceIndex(deviceIndexObservable, availableDevices, currentDeviceId);
  }

  /**
   * Update the index for current device after the current device changed.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - MediaDeviceType to be updates
   * @param {string} selectedInputDeviceId - ID of selected input device
   * @returns {undefined} No return value
   */
  _updateCurrentIndexFromId(deviceType, selectedInputDeviceId) {
    deviceType = this._typeConversion(deviceType);
    const deviceIndexObservable = this.currentDeviceIndex[deviceType];
    const availableDevices = this.availableDevices[deviceType]();

    this._updateCurrentDeviceIndex(deviceIndexObservable, availableDevices, selectedInputDeviceId);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaDeviceType = {
  AUDIO_INPUT: 'audioinput',
  AUDIO_OUTPUT: 'audiooutput',
  SCREEN_INPUT: 'screeninput',
  VIDEO_INPUT: 'videoinput',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaElementHandler = class MediaElementHandler {
  /**
   * Construct an new MediaElement handler.
   * @param {z.media.MediaRepository} mediaRepository - Repository for media interactions
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaElementHandler', z.config.LOGGER.OPTIONS);

    this.currentDeviceId = this.mediaRepository.devicesHandler.currentDeviceId;
    this.remoteMediaElements = ko.observableArray([]);
  }

  /**
   * Add MediaElement for new stream.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {undefined} No return value
   */
  addMediaElement(mediaStreamInfo) {
    const isVideoStream = mediaStreamInfo.getType() === z.media.MediaType.VIDEO;
    if (!isVideoStream) {
      const remoteMediaElement = this._createMediaElement(mediaStreamInfo);
      this.remoteMediaElements.push(remoteMediaElement);

      const elementType = remoteMediaElement.nodeName.toLowerCase();
      const message = `Created MediaElement of type '${elementType}' for flow '${mediaStreamInfo.flowId}'`;
      this.logger.info(message, remoteMediaElement);
    }
  }

  /**
   * Destroy the remote media element of a flow.
   * @private
   * @param {string} flowId - Flow ID for which to destroy the remote media element
   * @returns {undefined} No return value
   */
  removeMediaElement(flowId) {
    this._getMediaElements(flowId).forEach(mediaElement => {
      this._destroyMediaElement(mediaElement);
      this.remoteMediaElements.remove(mediaElement);
      const elementType = mediaElement.tagName.toLocaleLowerCase();
      this.logger.info(`Deleted MediaElement of type '${elementType}' for flow '${flowId}'`);
    });
  }

  /**
   * Switch the output device used for all MediaElements.
   * @param {string} mediaDeviceId - Media Device ID to be used for playback
   * @returns {undefined} No return value
   */
  switchMediaElementOutput(mediaDeviceId) {
    this.remoteMediaElements().forEach(mediaElement => this._setMediaElementOutput(mediaElement, mediaDeviceId));
  }

  /**
   * Create a new media element.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {Element} HTMLAudioElement that has the stream attached to it
   */
  _createMediaElement(mediaStreamInfo) {
    try {
      const mediaElement = document.createElement('audio');
      mediaElement.srcObject = mediaStreamInfo.stream;
      mediaElement.dataset.conversationId = mediaStreamInfo.conversationId;
      mediaElement.dataset.flowId = mediaStreamInfo.flowId;
      mediaElement.muted = false;
      mediaElement.setAttribute('autoplay', true);
      if (z.util.Environment.browser.supports.audioOutputSelection) {
        this._setMediaElementOutput(mediaElement, this.currentDeviceId.audioOutput());
      }
      return mediaElement;
    } catch (error) {
      this.logger.error(`Unable to create AudioElement for flow '${mediaStreamInfo.flowId}'`, error);
    }
  }

  /**
   * Stop the media element.
   *
   * @private
   * @param {HTMLMediaElement} mediaElement - A HTMLMediaElement that has the media stream attached to it
   * @returns {undefined} No return value
   */
  _destroyMediaElement(mediaElement) {
    if (mediaElement) {
      mediaElement.pause();
      mediaElement.srcObject = undefined;
    }
  }

  /**
   * Get all the MediaElements related to a given flow ID.
   *
   * @private
   * @param {string} flowId - ID of flow to search MediaElements for
   * @returns {Array<HTMLMediaElement>} Related MediaElements
   */
  _getMediaElements(flowId) {
    return this.remoteMediaElements().filter(mediaElement => mediaElement.dataset.flowId === flowId);
  }

  /**
   * Change the output device used for audio playback of a media element.
   *
   * @private
   * @param {Element} mediaElement - HTMLMediaElement to change playback device for
   * @param {string} sinkId - ID of MediaDevice to be used
   * @returns {undefined} No return value
   */
  _setMediaElementOutput(mediaElement, sinkId) {
    if (mediaElement.setSinkId) {
      const flowId = mediaElement.dataset.flowId;

      mediaElement
        .setSinkId(sinkId)
        .then(() => this.logger.info(`Audio output device '${sinkId}' attached to flow '${flowId}`, mediaElement))
        .catch(error => {
          const message = `Failed to attach audio output device '${sinkId}' to flow '${flowId}': ${error.message}`;
          this.logger.warn(message, error);
        });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaEmbeds = (function() {
  /**
   * Create and iframe.
   * @private
   * @param {Object} options - Settings to be used to create the iframe
   * @returns {string} HTML string
   */
  const _createIframeContainer = options => {
    const defaults = {
      allowfullscreen: ' allowfullscreen',
      class: 'iframe-container iframe-container-video',
      frameborder: '0',
      height: '100%',
      type: 'default',
      video: true,
      width: '100%',
    };

    options = _.extend(defaults, options);
    const iframeContainer = `<div class="{0}"><iframe class="${
      options.type
    }" width="{1}" height="{2}" src="{3}" frameborder="{4}"{5}></iframe></div>`;

    if (!options.video) {
      options.allowfullscreen = '';
      options.class = 'iframe-container';
    }

    if (z.util.Environment.desktop) {
      options.allowfullscreen = '';
    }

    return z.util.StringUtil.format(
      iframeContainer,
      options.class,
      options.width,
      options.height,
      options.src,
      options.frameborder,
      options.allowfullscreen
    );
  };

  // Enum of different regex for the supported services.
  const _regex = {
    // example: http://regexr.com/3ase5
    soundcloud: /(https?:\/\/(?:www\.|m\.)?)?soundcloud\.com(\/[\w-]+){2,3}/g,
    spotify: /https?:\/\/(?:play\.|open\.)*spotify\.com\/([^?]+)/g,
    vimeo: /https?:\/\/(?:(?:player\.)?vimeo\.com\/)(?:channels(?:\/[^/]+)?\/|video\/)?([0-9]+)/g,
    youtube: /(?:youtube(?:-nocookie)?\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\/?\?(?:\S*?&?v=))|youtu\.be\/)([a-zA-Z0-9_-]{6,11})/g,
  };

  /**
   * Appends an iFrame.
   *
   * @private
   * @param {HTMLAnchorElement} link - Link element
   * @param {string} message - Message containing the link
   * @param {string} iframe - HTML of iframe
   * @returns {string} Message content
   */
  const _appendIframe = (link, message, iframe) => {
    const linkString = link.outerHTML.replace(/&amp;/g, '&');
    return message.replace(/&amp;/g, '&').replace(linkString, `${linkString}${iframe}`);
  };

  /**
   * Find search parameters in a string
   *
   * @private
   * @param {string} params - String where we should find the parameters
   * @returns {string} Parameters
   */
  const _getParameters = params => params.substr(params.indexOf('?'), params.length).replace(/^\?/, '');

  /**
   * Generate embed URL to use as src in iframes
   *
   * @private
   * @param {string} url - Given youtube url
   * @returns {string} Youtube embed URL
   */
  const _generateYouTubeEmbedUrl = url => {
    if (url.match(_regex.youtube)) {
      const videoId = url.match(/(?:embed\/|v=|v\/|be\/)([a-zA-Z0-9_-]{11})/);
      if (!videoId) {
        return;
      }

      // Extract params from the URL
      const parser = document.createElement('a');
      parser.href = url;
      const searchParams = new URLSearchParams([_getParameters(parser.search), _getParameters(parser.hash)].join('&'));

      // Append HTML5 parameter to YouTube src to force HTML5 mode
      // This fixes the issue that FF displays black box in some cases
      searchParams.set('html5', 1);

      searchParams.set('enablejsapi', 0);
      searchParams.set('modestbranding', 1);

      // Do not get related videos at the end
      searchParams.set('rel', 0);

      // Convert the timestamp into an embed friendly format (start=seconds)
      if (searchParams.has('t')) {
        searchParams.set('start', _convertYouTubeTimestampToSeconds(searchParams.get('t')));
        searchParams.delete('t');
      }

      // Remove some parameters
      searchParams.delete('autoplay');
      searchParams.delete('v');
      searchParams.delete('widget_referrer');
      searchParams.delete('showinfo');

      return `https://www.youtube-nocookie.com/embed/${videoId[1]}?${searchParams.toString()}`;
    }
  };

  /**
   * Converts youtube timestamp into seconds
   *
   * @private
   * @param {string} timestamp - Youtube timestamp (1h8m55s)
   * @returns {number} Timestamp in seconds
   */
  const _convertYouTubeTimestampToSeconds = timestamp => {
    if (timestamp) {
      if (/^[0-9]*$/.test(timestamp)) {
        return window.parseInt(timestamp, 10);
      }

      const _extractUnit = unit => {
        return window.parseInt((timestamp.match(new RegExp(`([0-9]+)(?=${unit})`)) || [0])[0], 10);
      };

      return _extractUnit('h') * 3600 + _extractUnit('m') * 60 + _extractUnit('s');
    }
    return 0;
  };

  // Make public for testability.
  return {
    convertYouTubeTimestampToSeconds: _convertYouTubeTimestampToSeconds,
    generateYouTubeEmbedUrl: _generateYouTubeEmbedUrl,
    regex: _regex,

    /**
     * Appends SoundCloud iFrame if link is a valid SoundCloud source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    soundcloud(link, message) {
      let linkSrc = link.href;

      if (linkSrc.match(_regex.soundcloud)) {
        linkSrc = linkSrc.replace(/(m\.)/, '');
        let linkPathName = link.pathname;

        if (linkPathName.endsWith('/')) {
          linkPathName = linkPathName.substr(0, linkPathName.length - 1);
        }

        let isSingleTrack = false;
        const slashesInLink = linkPathName.split('/').length;

        if (slashesInLink === 3) {
          isSingleTrack = true;
        } else if (slashesInLink > 3 && linkPathName.indexOf('sets') === -1) {
          // Fix for WEBAPP-1137
          return message;
        }

        const height = isSingleTrack ? 164 : 465;

        const iframe = _createIframeContainer({
          height: height,
          src:
            'https://w.soundcloud.com/player/?url={1}&visual=false&show_comments=false&buying=false&show_playcount=false&liking=false&sharing=false&hide_related=true',
          type: 'soundcloud',
          video: false,
        });

        const embed = z.util.StringUtil.format(iframe, height, linkSrc);
        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends Spotify iFrame if link is a valid Spotify source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    spotify(link, message) {
      const linkSrc = link.href;

      if (linkSrc.match(_regex.spotify)) {
        const iframe = _createIframeContainer({
          height: '80px',
          src: 'https://embed.spotify.com/?uri=spotify$1',
          type: 'spotify',
          video: false,
        });

        // convert spotify uri: album/23... -> album:23... -> album%3A23...
        let embed = '';
        linkSrc.replace(_regex.spotify, (match, group1) => {
          const replaceSlashes = group1.replace(/\//g, ':');
          const encodedParams = window.encodeURIComponent(`:${replaceSlashes}`);
          return (embed = iframe.replace('$1', encodedParams));
        });

        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends Vimeo iFrame if link is a valid Vimeo source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @param {string} themeColor - User color
     * @returns {string} Message with appended iFrame
     */
    vimeo(link, message, themeColor) {
      const linkSrc = link.href;
      const vimeoColor = themeColor ? themeColor.replace('#', '') : undefined;

      if (linkSrc.match(_regex.vimeo)) {
        const iframe = _createIframeContainer({
          src: `https://player.vimeo.com/video/$1?portrait=0&color=${vimeoColor}&badge=0`,
          type: 'vimeo',
        });

        let embed = '';
        linkSrc.replace(_regex.vimeo, (match, group1) => (embed = iframe.replace('$1', group1)));

        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends YouTube iFrame if link is a valid YouTube source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    youtube(link, message) {
      const embedUrl = _generateYouTubeEmbedUrl(link.href);

      if (embedUrl) {
        const iframe = _createIframeContainer({
          src: embedUrl,
          type: 'youtube',
        });

        message = _appendIframe(link, message, iframe);
        return message;
      }

      return message;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

class MediaParser {
  constructor() {
    this.renderMediaEmbeds = this.renderMediaEmbeds.bind(this);

    this.embeds = [
      z.media.MediaEmbeds.soundcloud,
      z.media.MediaEmbeds.spotify,
      z.media.MediaEmbeds.vimeo,
      z.media.MediaEmbeds.youtube,
    ];
  }

  /**
   * Render media embeds.
   * @note Checks message for valid media links and appends an iFrame right after the link
   *
   * @param {string} message - Message text
   * @param {string} themeColor - Accent color to be applied to the embed
   * @returns {string} Message with rendered media embeds
   */
  renderMediaEmbeds(message, themeColor) {
    z.util.URLUtil.getLinksFromHtml(message).forEach(link => {
      this.embeds.forEach(embed => (message = embed(link, message, themeColor)));
    });

    return message;
  }
}

z.media.MediaParser = new MediaParser();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaRepository = class MediaRepository {
  // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/state
  static get AUDIO_CONTEXT_STATE() {
    return {
      CLOSED: 'closed',
      RUNNING: 'running',
      SUSPENDED: 'suspended',
    };
  }

  /**
   * Extended check for MediaDevices support of browser.
   * @returns {boolean} True if MediaDevices are supported
   */
  static supportsMediaDevices() {
    return z.util.Environment.browser.supports.mediaDevices;
  }

  /**
   * Construct a new Media repository.
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   */
  constructor(permissionRepository) {
    this.logger = new z.util.Logger('z.media.MediaRepository', z.config.LOGGER.OPTIONS);

    this.constraintsHandler = new z.media.MediaConstraintsHandler(this);
    this.devicesHandler = new z.media.MediaDevicesHandler(this);
    this.elementHandler = new z.media.MediaElementHandler(this);
    this.streamHandler = new z.media.MediaStreamHandler(this, permissionRepository);

    this.audioContext = undefined;
  }

  /**
   * Closing the AudioContext.
   * @returns {undefined} No return value
   */
  closeAudioContext() {
    const contextRunning = this.audioContext && this.audioContext.state === MediaRepository.AUDIO_CONTEXT_STATE.RUNNING;
    if (contextRunning) {
      this.audioContext.close().then(() => {
        this.logger.info('Closed existing AudioContext', this.audioContext);
        this.audioContext = undefined;
      });
    }
  }

  /**
   * Initialize the AudioContext.
   * @returns {AudioContext} AudioContext
   */
  getAudioContext() {
    const contextRunning = this.audioContext && this.audioContext.state === MediaRepository.AUDIO_CONTEXT_STATE.RUNNING;
    if (contextRunning) {
      this.logger.info('Reusing existing AudioContext', this.audioContext);
      return this.audioContext;
    }

    if (window.AudioContext && window.AudioContext.prototype.createMediaStreamSource) {
      this.audioContext = new window.AudioContext();
      this.logger.info('Initialized a new AudioContext', this.audioContext);
      return this.audioContext;
    }

    this.logger.error('The flow audio cannot use the Web Audio API as it is unavailable.');
    return undefined;
  }

  showNoCameraModal() {
    const modalOptions = {
      text: {
        htmlMessage: z.l10n.safeHtml(z.string.modalNoCameraMessage, {
          replaceDangerously: {
            '/faqLink': '</a>',
            br: '<br>',
            faqLink:
              '<a href="https://support.wire.com/hc/articles/202935412" data-uie-name="go-no-camera-faq" target="_blank" rel="noopener noreferrer">',
          },
        }),
        title: z.l10n.text(z.string.modalNoCameraTitle),
      },
    };
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Errors
z.media.MEDIA_STREAM_ERROR = {
  ABORT_ERROR: 'AbortError',
  NOT_ALLOWED_ERROR: 'NotAllowedError',
  NOT_FOUND_ERROR: 'NotFoundError',
  NOT_READABLE_ERROR: 'NotReadableError',
  NOT_SUPPORTED_ERROR: 'NotSupportedError',
  OVERCONSTRAINED_ERROR: 'OverConstrainedError',
  SECURITY_ERROR: 'SecurityError',
  TYPE_ERROR: 'TypeError',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Errors
z.media.MEDIA_STREAM_ERROR_TYPES = {
  DEVICE: [
    z.media.MEDIA_STREAM_ERROR.ABORT_ERROR,
    z.media.MEDIA_STREAM_ERROR.NOT_FOUND_ERROR,
    z.media.MEDIA_STREAM_ERROR.NOT_READABLE_ERROR,
  ],
  MISC: [
    z.media.MEDIA_STREAM_ERROR.NOT_SUPPORTED_ERROR,
    z.media.MEDIA_STREAM_ERROR.OVERCONSTRAINED_ERROR,
    z.media.MEDIA_STREAM_ERROR.TYPE_ERROR,
  ],
  PERMISSION: [z.media.MEDIA_STREAM_ERROR.NOT_ALLOWED_ERROR, z.media.MEDIA_STREAM_ERROR.SECURITY_ERROR],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamHandler = class MediaStreamHandler {
  /**
   * Detect whether a MediaStream has a video MediaStreamTrack attached
   * @param {MediaStream} mediaStream - MediaStream to detect the type off
   * @returns {MediaType} Media type information
   */
  static detectMediaStreamType(mediaStream) {
    const audioTracks = mediaStream.getAudioTracks();
    const videoTracks = mediaStream.getVideoTracks();

    const hasAudioTrack = audioTracks && audioTracks.length;
    const hasVideoTrack = videoTracks && videoTracks.length;
    if (hasVideoTrack) {
      return hasAudioTrack ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.VIDEO;
    }
    return hasAudioTrack ? z.media.MediaType.AUDIO : z.media.MediaType.NONE;
  }

  /**
   * Get MediaStreamTracks from a MediaStream.
   *
   * @param {MediaStream} mediaStream - MediaStream to get tracks from
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of requested tracks
   * @returns {Array} MediaStreamTracks
   */
  static getMediaTracks(mediaStream, mediaType = z.media.MediaType.AUDIO_VIDEO) {
    if (!mediaStream) {
      throw new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND);
    }

    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return mediaStream.getAudioTracks();
      }

      case z.media.MediaType.AUDIO_VIDEO: {
        return mediaStream.getTracks();
      }

      case z.media.MediaType.SCREEN:
      case z.media.MediaType.VIDEO: {
        return mediaStream.getVideoTracks();
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  static get CONFIG() {
    return {
      MEDIA_TYPE: {
        CONTAINS_AUDIO: [z.media.MediaType.AUDIO, z.media.MediaType.AUDIO_VIDEO],
        CONTAINS_VIDEO: [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO],
      },
      PERMISSION_HINT_DELAY: 200,
    };
  }

  /**
   * Construct a new MediaStream handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository with with references to all other handlers
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   */
  constructor(mediaRepository, permissionRepository) {
    this._toggleScreenSend = this._toggleScreenSend.bind(this);
    this._toggleVideoSend = this._toggleVideoSend.bind(this);

    this.mediaRepository = mediaRepository;
    this.permissionRepository = permissionRepository;
    this.logger = new z.util.Logger('z.media.MediaStreamHandler', z.config.LOGGER.OPTIONS);

    this.currentCalls = new Map();
    this.joinedCall = ko.observable();

    this.constraintsHandler = this.mediaRepository.constraintsHandler;
    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.elementHandler = this.mediaRepository.elementHandler;

    this.deviceSupport = this.devicesHandler.deviceSupport;

    this.localMediaStream = ko.observable();
    this.localMediaType = ko.observable(z.media.MediaType.AUDIO);

    this.remoteMediaStreamInfo = ko.observableArray([]);
    this.remoteMediaStreamInfoIndex = {
      audio: ko.pureComputed(() => {
        return this.remoteMediaStreamInfo().filter(mediaStreamInfo => {
          return mediaStreamInfo.getType() === z.media.MediaType.AUDIO;
        });
      }),
      video: ko.pureComputed(() => {
        const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
        return this.remoteMediaStreamInfo().filter(mediaStreamInfo => videoTypes.includes(mediaStreamInfo.getType()));
      }),
    };

    this.selfStreamState = {
      audioSend: ko.observable(true),
      screenSend: ko.observable(false),
      videoSend: ko.observable(false),
    };

    this.selfStreamState.audioSend.subscribe(audioSend => {
      this._toggleStreamEnabled(z.media.MediaType.AUDIO, audioSend);
    });
    this.selfStreamState.screenSend.subscribe(screenSend => {
      this._toggleStreamEnabled(z.media.MediaType.VIDEO, screenSend);
    });
    this.selfStreamState.videoSend.subscribe(videoSend => {
      this._toggleStreamEnabled(z.media.MediaType.VIDEO, videoSend);
    });

    this.hasActiveVideo = ko.pureComputed(() => this.selfStreamState.screenSend() || this.selfStreamState.videoSend());

    this.requestHintTimeout = undefined;

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.ADD_STREAM, this.addRemoteMediaStream.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.MEDIA.CONNECTION_CLOSED, this.removeRemoteMediaStreamTracks.bind(this));
  }

  //##############################################################################
  // Local MediaStream handling
  //##############################################################################

  /**
   * Initiate the MediaStream.
   *
   * @param {string} conversationId - Conversation ID of call
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @param {boolean} [isGroup=false] - Set constraints for group
   * @returns {Promise} Resolves when the MediaStream has been initiated
   */
  initiateMediaStream(conversationId, mediaType = z.media.MediaType.AUDIO, isGroup = false) {
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;

    return this.devicesHandler
      .updateCurrentDevices(videoSend)
      .then(() => this.constraintsHandler.getMediaStreamConstraints(true, videoSend, isGroup))
      .then(streamConstraints => this.requestMediaStream(mediaType, streamConstraints))
      .then(mediaStreamInfo => this._initiateMediaStreamSuccess(conversationId, mediaStreamInfo))
      .catch(error => {
        this._initiateMediaStreamFailure(error, conversationId);

        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CALLING.FAILED_REQUESTING_MEDIA, {
          cause: error.name || error.message,
          video: videoSend,
        });

        throw error;
      });
  }

  /**
   * Release the local MediaStream.
   * @returns {undefined} Not return value
   */
  releaseMediaStream() {
    if (this._releaseMediaStream(this.localMediaStream())) {
      this.localMediaStream(undefined);
    }
  }

  /**
   * Replace the MediaStream after a change of the selected input device.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Info about new MediaStream
   * @returns {undefined} No return value
   */
  changeMediaStream(mediaStreamInfo) {
    const mediaStream = mediaStreamInfo.stream;

    const logMessage = `Received new MediaStream containing '${mediaStream.getTracks().length}' track/s`;
    const logObject = {
      audioTracks: mediaStream.getAudioTracks(),
      stream: mediaStream,
      videoTracks: mediaStream.getVideoTracks(),
    };
    this.logger.debug(logMessage, logObject);

    const replacePromise = this.joinedCall()
      ? this._updateJoinedCall(mediaStreamInfo)
      : Promise.resolve({replacedTrack: false, streamInfo: mediaStreamInfo});

    replacePromise.then(this._handleReplacedMediaStream.bind(this));
  }

  _handleReplacedMediaStream({replacedTrack, streamInfo: mediaStreamInfo}) {
    const replaceMediaStreamLocally = newMediaStreamInfo => {
      const newMediaStream = newMediaStreamInfo.stream;
      const newMediaStreamType = newMediaStreamInfo.getType();

      this._releaseMediaStream(this.localMediaStream());
      this._setStreamState(newMediaStream, newMediaStreamType);
      this.localMediaStream(newMediaStream);
    };

    const replaceMediaTracksLocally = newMediaStreamInfo => {
      const mediaStream = newMediaStreamInfo.stream;
      const mediaType = newMediaStreamInfo.getType();
      const localMediaStream = this.localMediaStream();

      if (localMediaStream) {
        this._releaseTracksFromStream(localMediaStream, mediaType);
        this._addTracksToStream(mediaStream, localMediaStream, mediaType);
      } else {
        this.localMediaStream(mediaStream);
      }
    };

    return replacedTrack ? replaceMediaTracksLocally(mediaStreamInfo) : replaceMediaStreamLocally(mediaStreamInfo);
  }

  /**
   * Update the used MediaStream after a new input device was selected.
   * @param {z.media.MediaType} mediaType - Media type of device that was replaced
   * @returns {Promise} Resolves when the input source has been replaced
   */
  replaceInputSource(mediaType) {
    const isPreferenceChange = this.currentCalls.size === 0;

    let constraintsPromise;
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        constraintsPromise = this.constraintsHandler.getMediaStreamConstraints(true, isPreferenceChange);
        break;
      }

      case z.media.MediaType.SCREEN: {
        constraintsPromise = this.constraintsHandler.getScreenStreamConstraints();
        break;
      }

      case z.media.MediaType.VIDEO: {
        constraintsPromise = this.constraintsHandler.getMediaStreamConstraints(isPreferenceChange, true);
        break;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }

    return constraintsPromise
      .then(streamConstraints => this.requestMediaStream(mediaType, streamConstraints))
      .then(mediaStreamInfo => {
        // FIXME: the mediaStreamInUse should be more intelligent and handle all scenarios where the stream is actually needed
        if (!isPreferenceChange && !this.mediaStreamInUse()) {
          // in case the stream is returned after the call has actually ended, we need to release the stream right away
          this.logger.warn('Releasing obsolete MediaStream as there is no active call', mediaStreamInfo);
          return this._releaseMediaStream(mediaStreamInfo.stream);
        }

        this._setSelfStreamState(mediaType);
        this.changeMediaStream(mediaStreamInfo);
      })
      .catch(error => {
        const isMediaTypeScreen = mediaType === z.media.MediaType.SCREEN;
        const logMessage = isMediaTypeScreen
          ? `Could not enable screen sharing: ${error.message}`
          : `Could not replace '${mediaType}' input source: ${error.message}`;
        this.logger.warn(logMessage, error);

        throw error;
      });
  }

  /**
   * Request a MediaStream.
   *
   * @param {z.media.MediaType} mediaType - Type of MediaStream to be requested
   * @param {RTCMediaStreamConstraints} mediaStreamConstraints - Constraints for the MediaStream to be requested
   * @returns {Promise} Resolves with the stream and its type
   */
  requestMediaStream(mediaType, mediaStreamConstraints) {
    return this._checkDeviceAvailability(mediaType)
      .then(() => this._hasPermissionToAccess(mediaType))
      .then(hasPermission => this._requestMediaStream(mediaType, mediaStreamConstraints, hasPermission))
      .catch(error => {
        const isPermissionDenied = error.type === z.error.PermissionError.TYPE.DENIED;
        throw isPermissionDenied
          ? new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION, mediaType)
          : error;
      });
  }

  /**
   * Add tracks to a new stream.
   *
   * @private
   * @param {MediaStream} sourceStream - MediaStream to take tracks from
   * @param {MediaStream} targetStream - MediaStream to add tracks to
   * @param {z.media.MediaType} mediaType - Type of track to add
   * @returns {undefined} Not return value
   */
  _addTracksToStream(sourceStream, targetStream, mediaType) {
    const mediaStreamTracks = MediaStreamHandler.getMediaTracks(sourceStream, mediaType);
    mediaStreamTracks.forEach(mediaStreamTrack => targetStream.addTrack(mediaStreamTrack));
  }

  /**
   * Check for devices of requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Promise} Resolves when the device availability has been verified
   */
  _checkDeviceAvailability(mediaType) {
    const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
    const noVideoTypes = !this.deviceSupport.videoInput() && videoTypes.includes(mediaType);
    if (noVideoTypes) {
      const mediaError = new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, z.media.MediaType.VIDEO);
      return Promise.reject(mediaError);
    }

    const audioTypes = [z.media.MediaType.AUDIO, z.media.MediaType.AUDIO_VIDEO];
    const noAudioDevice = !this.deviceSupport.audioInput() && audioTypes.includes(mediaType);
    if (noAudioDevice) {
      const mediaError = new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, z.media.MediaType.AUDIO);
      return Promise.reject(mediaError);
    }

    return Promise.resolve();
  }

  /**
   * Check for permission for the requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Promise} Resolves true when permissions is granted
   */
  _hasPermissionToAccess(mediaType) {
    if (!z.util.Environment.browser.supports.mediaPermissions) {
      return Promise.resolve(false);
    }

    const checkPermissionStates = typesToCheck => {
      return this.permissionRepository.getPermissionStates(typesToCheck).then(permissions => {
        for (const permission of permissions) {
          const {permissionState, permissionType} = permission;
          const isPermissionPrompt = permissionState === z.permission.PermissionStatusState.PROMPT;
          if (isPermissionPrompt) {
            this.logger.info(`Need to prompt for '${permissionType}' permission`, permissions);
            return Promise.resolve(false);
          }

          const isPermissionDenied = permissionState === z.permission.PermissionStatusState.DENIED;
          if (isPermissionDenied) {
            this.logger.warn(`Permission for '${permissionType}' is denied`, permissions);
            return Promise.reject(new z.error.PermissionError(z.error.PermissionError.TYPE.DENIED));
          }
        }

        return Promise.resolve(true);
      });
    };

    const permissionTypes = this._getPermissionTypes(mediaType);
    const shouldCheckPermissions = permissionTypes && permissionTypes.length;
    return shouldCheckPermissions ? checkPermissionStates(permissionTypes) : Promise.resolve(true);
  }

  /**
   * Get permission types for the requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Array<z.permission.PermissionType>} Array containing the necessary permission types
   */
  _getPermissionTypes(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return [z.permission.PermissionType.MICROPHONE];
      }

      case z.media.MediaType.AUDIO_VIDEO: {
        return [z.permission.PermissionType.CAMERA, z.permission.PermissionType.MICROPHONE];
      }

      case z.media.MediaType.VIDEO: {
        return [z.permission.PermissionType.CAMERA];
      }
    }
  }

  /**
   * Clear the permission request hint timeout or hide the warning.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _clearPermissionRequestHint(mediaType) {
    if (this.requestHintTimeout) {
      return window.clearTimeout(this.requestHintTimeout);
    }
    this._hidePermissionRequestHint(mediaType);
  }

  /**
   * Hide the permission denied hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _hidePermissionFailedHint(mediaType) {
    const warningType = this._selectPermissionDeniedWarningType(mediaType);
    amplify.publish(z.event.WebApp.WARNING.DISMISS, warningType);
  }

  /**
   * Hide the permission request hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _hidePermissionRequestHint(mediaType) {
    if (!z.util.Environment.electron) {
      const warningType = this._selectPermissionRequestWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.DISMISS, warningType);
    }
  }

  /**
   * Initial request for local MediaStream was successful.
   *
   * @private
   * @param {string} conversationId - ID of conversation to initiate MediaStream for
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Type of requested MediaStream
   * @returns {undefined} No return value
   */
  _initiateMediaStreamSuccess(conversationId, mediaStreamInfo) {
    if (mediaStreamInfo) {
      const callEntity = this.currentCalls.get(conversationId);
      const callNeedsMediaStream = callEntity && callEntity.needsMediaStream();
      const mediaStream = mediaStreamInfo.stream;

      if (!callNeedsMediaStream) {
        this.logger.warn(`Releasing obsolete MediaStream as call '${conversationId}' is no longer active`, callEntity);
        return this._releaseMediaStream(mediaStream);
      }

      const mediaType = mediaStreamInfo.getType();
      const isVideoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;
      this.selfStreamState.videoSend(isVideoSend);
      if (isVideoSend) {
        this.localMediaType(z.media.MediaType.VIDEO);
      }

      const logMessage = `Received initial MediaStream containing '${mediaStream.getTracks().length}' tracks/s`;
      const logObject = {
        audioTracks: mediaStream.getAudioTracks(),
        stream: mediaStream,
        videoTracks: mediaStream.getVideoTracks(),
      };
      this.logger.debug(logMessage, logObject);

      this._setStreamState(mediaStream, mediaType);
      this.localMediaStream(mediaStream);
    }
  }

  /**
   * Local MediaStream creation failed.
   *
   * @private
   * @param {z.error.MediaError} error - MediaError
   * @param {string} conversationId - Conversation ID
   * @returns {undefined} No return value
   */
  _initiateMediaStreamFailure(error, conversationId) {
    const {type, mediaType} = error;

    if (mediaType) {
      const isStreamDeviceError = type === z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE;
      return isStreamDeviceError
        ? this._showDeviceNotFoundHint(mediaType, conversationId)
        : this._showPermissionDeniedHint(mediaType);
    }
  }

  /**
   * Release a MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to be released
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of MediaStreamTracks to be released
   * @returns {boolean} Have tracks been stopped
   */
  _releaseMediaStream(mediaStream, mediaType = z.media.MediaType.AUDIO_VIDEO) {
    return mediaStream ? this._releaseTracksFromStream(mediaStream, mediaType) : false;
  }

  /**
   * Release tracks from a MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to release tracks from
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of MediaStreamTracks to be released
   * @returns {boolean} Have tracks been stopped
   */
  _releaseTracksFromStream(mediaStream, mediaType) {
    const mediaStreamTracks = MediaStreamHandler.getMediaTracks(mediaStream, mediaType);

    if (mediaStreamTracks.length) {
      mediaStreamTracks.forEach(mediaStreamTrack => {
        mediaStream.removeTrack(mediaStreamTrack);
        mediaStreamTrack.stop();
        this.logger.info(`Stopping MediaStreamTrack of kind '${mediaStreamTrack.kind}' successful`, mediaStreamTrack);
      });

      return true;
    }

    this.logger.warn('No MediaStreamTrack found to stop', mediaStream);
    return false;
  }

  _schedulePermissionHint(mediaType) {
    this.requestHintTimeout = window.setTimeout(() => {
      this._hidePermissionFailedHint(mediaType);
      this._showPermissionRequestHint(mediaType);
      this.requestHintTimeout = undefined;
    }, MediaStreamHandler.CONFIG.PERMISSION_HINT_DELAY);
  }

  /**
   * Request a MediaStream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of MediaStream to be requested
   * @param {RTCMediaStreamConstraints} mediaStreamConstraints - Constraints for the MediaStream to be requested
   * @param {boolean} hasPermission - Has required media permissions
   * @returns {Promise} Resolves with the stream and its type
   */
  _requestMediaStream(mediaType, mediaStreamConstraints, hasPermission) {
    this.logger.info(`Requesting MediaStream access for '${mediaType}'`, mediaStreamConstraints);

    const willPromptForPermission = !hasPermission && !z.util.Environment.desktop;
    if (willPromptForPermission) {
      this._schedulePermissionHint(mediaType);
    }

    return navigator.mediaDevices
      .getUserMedia(mediaStreamConstraints)
      .then(mediaStream => {
        this._clearPermissionRequestHint(mediaType);
        return new z.media.MediaStreamInfo(z.media.MediaStreamSource.LOCAL, 'self', mediaStream);
      })
      .catch(error => {
        const {message, name} = error;
        this.logger.warn(`MediaStream request for '${mediaType}' failed: ${name} ${message}`, error);
        this._clearPermissionRequestHint(mediaType);

        if (z.media.MEDIA_STREAM_ERROR_TYPES.DEVICE.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, mediaType);
        }

        if (z.media.MEDIA_STREAM_ERROR_TYPES.MISC.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_MISC, mediaType);
        }

        if (z.media.MEDIA_STREAM_ERROR_TYPES.PERMISSION.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION, mediaType);
        }

        throw error;
      });
  }

  _selectPermissionDeniedWarningType(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_MICROPHONE;
      }

      case z.media.MediaType.SCREEN: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_SCREEN;
      }

      case z.media.MediaType.AUDIO_VIDEO:
      case z.media.MediaType.VIDEO: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_CAMERA;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  _selectPermissionRequestWarningType(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_MICROPHONE;
      }

      case z.media.MediaType.SCREEN: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_SCREEN;
      }

      case z.media.MediaType.AUDIO_VIDEO:
      case z.media.MediaType.VIDEO: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_CAMERA;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  /**
   * Show microphone not found hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of device not found
   * @param {string} conversationId - Optional conversation ID
   * @returns {undefined} No return value
   */
  _showDeviceNotFoundHint(mediaType, conversationId) {
    if (mediaType === z.media.MediaType.AUDIO) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NOT_FOUND_MICROPHONE);
    } else if (mediaType === z.media.MediaType.VIDEO) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NOT_FOUND_CAMERA);
    }

    if (conversationId) {
      amplify.publish(z.event.WebApp.CALL.STATE.REJECT, conversationId);
    }
  }

  /**
   * Show permission denied hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of media access request
   * @returns {undefined} No return value
   */
  _showPermissionDeniedHint(mediaType) {
    const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
    if (!videoTypes.includes(mediaType)) {
      const warningType = this._selectPermissionDeniedWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.SHOW, warningType);
    }
  }

  /**
   * Show permission request hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested MediaStream
   * @returns {undefined} No return value
   */
  _showPermissionRequestHint(mediaType) {
    if (!z.util.Environment.electron) {
      const warningType = this._selectPermissionRequestWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.SHOW, warningType);
    }
  }

  /**
   * Update MediaStream used in joined call.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - New MediaStream to use
   * @returns {Promise} Resolves when MediaStream was replaced
   */
  _updateJoinedCall(mediaStreamInfo) {
    this._setStreamState(mediaStreamInfo.stream, mediaStreamInfo.getType());
    const flowEntities = this.joinedCall().getFlows();
    const [firstFlowEntity] = flowEntities;

    const replaceMediaTrackInFlows = (streamInfo, flows) => {
      const replacementPromises = flows.map(flowEntity => flowEntity.replaceMediaTrack(streamInfo));
      return Promise.all(replacementPromises).then(() => ({replacedTrack: true, streamInfo}));
    };

    const replaceMediaStreamInFlows = (streamInfo, flows) => {
      return this._updateMediaStream(streamInfo).then(newMediaStreamInfo => {
        const upgradePromises = flows.map(flowEntity => {
          return flowEntity.replaceMediaStream(newMediaStreamInfo, this.localMediaStream());
        });
        return Promise.all(upgradePromises).then(() => ({replacedTrack: false, streamInfo: newMediaStreamInfo}));
      });
    };

    return firstFlowEntity
      .supportsTrackReplacement(mediaStreamInfo.getType())
      .then(canReplaceTracks => {
        return canReplaceTracks
          ? replaceMediaTrackInFlows(mediaStreamInfo, flowEntities)
          : replaceMediaStreamInFlows(mediaStreamInfo, flowEntities);
      })
      .catch(error => {
        const message = `Failed to update call with '${mediaStreamInfo.getType()}': ${error.name} - ${error.message}`;
        this.logger.error(message, error);
        throw error;
      });
  }

  /**
   * Upgrade the local MediaStream with new MediaStreamTracks.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStreamInfo containing new MediaStreamTracks
   * @returns {Promise<z.media.MediaStreamInfo>} Resolves with new MediaStream to be used
   */
  _updateMediaStream(mediaStreamInfo) {
    if (!this.localMediaStream()) {
      return Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND));
    }

    const newMediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    this._releaseTracksFromStream(this.localMediaStream(), mediaType);

    const clonedMediaStream = this.localMediaStream().clone();
    const clonedMediaStreamType = MediaStreamHandler.detectMediaStreamType(clonedMediaStream);
    // Reset MediaStreamTrack enabled states as older Chrome versions fail to copy these when cloning
    this._setStreamState(clonedMediaStream, clonedMediaStreamType);
    this._addTracksToStream(newMediaStream, clonedMediaStream, mediaType);

    this.logger.info(`Upgraded the MediaStream to update '${mediaType}'`, clonedMediaStream);
    return Promise.resolve(new z.media.MediaStreamInfo(z.media.MediaStreamSource.LOCAL, 'self', clonedMediaStream));
  }

  //##############################################################################
  // Remote MediaStream handling
  //##############################################################################

  /**
   * Add a remote MediaStream.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {undefined} No return value
   */
  addRemoteMediaStream(mediaStreamInfo) {
    const handledStreamTypes = [z.media.MediaType.AUDIO, z.media.MediaType.VIDEO, z.media.MediaType.AUDIO_VIDEO];
    if (!handledStreamTypes.includes(mediaStreamInfo.getType())) {
      throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
    }

    this.remoteMediaStreamInfo.push(mediaStreamInfo);
    this.elementHandler.addMediaElement(mediaStreamInfo);
  }

  /**
   * Removes the given tracks from the streams containing them.
   * If a stream ends up having no tracks, it gets filtered out from the array of streams
   * removeRemoteMediaStreamTracks
   *
   * @param {MediaStreamTrack[]} tracks - the tracks to remove
   * @returns {void} - void
   */
  removeRemoteMediaStreamTracks(tracks) {
    const filteredMediaStreamsInfo = this.remoteMediaStreamInfo()
      .map(mediaStreamInfo => {
        tracks.forEach(track => mediaStreamInfo.stream.removeTrack(track));
        return mediaStreamInfo;
      })
      .filter(mediaStreamInfo => mediaStreamInfo.stream.getTracks().length);

    this.remoteMediaStreamInfo(filteredMediaStreamsInfo);
  }

  //##############################################################################
  // Media handling
  //##############################################################################

  /**
   * Check for active calls that need a MediaStream.
   * @returns {boolean} Returns true if an active media stream is needed for at least one call
   */
  mediaStreamInUse() {
    for (const callEntity of this.currentCalls.values()) {
      const callNeedsMediaStream = callEntity.needsMediaStream();
      if (callNeedsMediaStream) {
        return true;
      }
    }

    return false;
  }

  // Toggle the mute state of the microphone.
  toggleAudioSend() {
    return this._toggleAudioSend();
  }

  // Toggle the screen.
  toggleScreenSend() {
    return this._toggleMediaSend(z.media.MediaType.SCREEN, this._toggleScreenSend);
  }

  // Toggle the camera.
  toggleVideoSend() {
    return this._toggleMediaSend(z.media.MediaType.VIDEO, this._toggleVideoSend);
  }

  // Reset the enabled states of media types.
  resetSelfStates() {
    this.selfStreamState.audioSend(true);
    this.selfStreamState.screenSend(false);
    this.selfStreamState.videoSend(false);
    this.localMediaType(z.media.MediaType.AUDIO);
  }

  // Reset the MediaStream and states.
  resetMediaStream() {
    if (!this.mediaStreamInUse()) {
      this.releaseMediaStream();
      this.resetSelfStates();
      this.mediaRepository.closeAudioContext();
    }
  }

  /**
   * Set the self stream state to reflect current media type.
   * @param {z.media.MediaType} mediaType - Type of state to enable
   * @returns {undefined} No return value
   */
  _setSelfStreamState(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        this.selfStreamState.audioSend(true);
        break;
      }

      case z.media.MediaType.SCREEN: {
        this.selfStreamState.videoSend(false);
        this.selfStreamState.screenSend(true);
        this.localMediaType(z.media.MediaType.SCREEN);
        break;
      }

      case z.media.MediaType.VIDEO: {
        this.selfStreamState.videoSend(true);
        this.selfStreamState.screenSend(false);
        this.localMediaType(z.media.MediaType.VIDEO);
        break;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  /**
   * Set the enabled state of a new MediaStream.
   * @private
   * @param {MediaStream} mediaStream - MediaStream to set state on
   * @param {z.media.MediaType} mediaType - Type to set state for
   * @returns {undefined} No return value
   */
  _setStreamState(mediaStream, mediaType) {
    const includesAudioTracks = MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_AUDIO.includes(mediaType);
    if (includesAudioTracks) {
      this._setTrackState(mediaStream, z.media.MediaType.AUDIO);
    }

    const includesVideoTracks = MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_VIDEO.includes(mediaType);
    if (includesVideoTracks) {
      this._setTrackState(mediaStream, z.media.MediaType.VIDEO);
    }
  }

  _setTrackState(mediaStream, mediaType) {
    const streamTracks = MediaStreamHandler.getMediaTracks(mediaStream, mediaType);

    if (streamTracks.length > 1) {
      this.logger.warn(`Media stream contains multiple '${mediaType}' tracks`, streamTracks);
    }

    const isVideo = mediaType === z.media.MediaType.VIDEO;
    const isEnabledState = isVideo ? this.hasActiveVideo() : this.selfStreamState.audioSend();

    streamTracks.forEach(streamTrack => (streamTrack.enabled = isEnabledState));
    const logMessage = `Set stream '${mediaType}' enabled to '${isEnabledState}' on '${streamTracks.length}' tracks`;
    this.logger.log(logMessage, streamTracks);
  }

  /**
   * Toggle the audio stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleAudioSend() {
    return this._toggleSendState(this.selfStreamState.audioSend, 'Microphone');
  }

  /**
   * Toggle the screen stream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of media to toggle
   * @param {Function} toggleFn - Function to toggle type of media
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleMediaSend(mediaType, toggleFn) {
    const hasActiveScreenStream = this.localMediaStream() && this.localMediaType() === mediaType;
    return hasActiveScreenStream ? toggleFn() : this.replaceInputSource(mediaType);
  }

  /**
   * Toggle the screen stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleScreenSend() {
    return this._toggleSendState(this.selfStreamState.screenSend, 'Screen');
  }

  /**
   * Toggle a given send state.
   *
   * @private
   * @param {ko.observable} stateObservable - State to toggle
   * @param {string} name - Name of state being toggled
   * @returns {Promise} Resolves when the state has been toggled
   */
  _toggleSendState(stateObservable, name) {
    return Promise.resolve().then(() => {
      stateObservable(!stateObservable());
      this.logger.info(`${name} enabled: ${stateObservable()}`);
      return stateObservable();
    });
  }

  /**
   * Toggle the video stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleVideoSend() {
    return this._toggleSendState(this.selfStreamState.videoSend, 'Camera');
  }

  /**
   * Toggle the enabled state of a MediaStream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Media type to toggle
   * @param {boolean} sendState - New call property send state
   * @returns {undefined} No return value
   */
  _toggleStreamEnabled(mediaType, sendState) {
    const isTypeAudio = mediaType === z.media.MediaType.AUDIO;
    if (isTypeAudio) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.MUTE_AUDIO, !sendState);
    }

    if (this.localMediaStream()) {
      const mediaStreamTracks = MediaStreamHandler.getMediaTracks(this.localMediaStream(), mediaType);
      mediaStreamTracks.forEach(mediaStreamTrack => (mediaStreamTrack.enabled = sendState));
    }
  }

  updateCurrentCalls(callEntities) {
    this.currentCalls.clear();
    callEntities.forEach(callEntity => this.currentCalls.set(callEntity.id, callEntity));
  }

  setJoinedCall(callEntity) {
    this.joinedCall(callEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamSource = {
  LOCAL: 'local',
  REMOTE: 'remote',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamInfo = class MediaStreamInfo {
  constructor(source, flowId, stream, callEntity) {
    this.source = source;
    this.flowId = flowId;
    this.stream = stream;
    this.callEntity = callEntity;

    this.conversationId = callEntity ? callEntity.id : undefined;
  }

  getType() {
    return z.media.MediaStreamHandler.detectMediaStreamType(this.stream);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaType = {
  AUDIO: 'audio',
  AUDIO_VIDEO: 'audio/video',
  NONE: 'none',
  SCREEN: 'screen',
  VIDEO: 'video',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.VIDEO_QUALITY_MODE = {
  FULL_HD: 'z.media.VIDEO_QUALITY_MODE.FULL_HD',
  GROUP: 'z.media.VIDEO_QUALITY_MODE.GROUP',
  HD: 'z.media.VIDEO_QUALITY_MODE.MOBILE.HD',
  MOBILE: 'z.media.VIDEO_QUALITY_MODE.MOBILE',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.motion = z.motion || {};

z.motion.MotionDuration = {
  LONG: 550,
  MEDIUM: 350,
  SHORT: 150,
  X_LONG: 700,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

// https://developer.mozilla.org/en-US/docs/Web/API/Notification/permission
z.notification.PermissionState = {
  DEFAULT: 'default',
  DENIED: 'denied',
  GRANTED: 'granted',
  IGNORED: 'ignored',
  UNSUPPORTED: 'unsupported',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

// Enum of notification preferences.
z.notification.NotificationPreference = {
  NONE: 'none',
  OBFUSCATE: 'obfuscate',
  OBFUSCATE_MESSAGE: 'obfuscate-message',
  ON: 'on',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

/**
 * Notification repository to trigger browser and audio notifications.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/notification
 * @see http://www.w3.org/TR/notifications
 */
z.notification.NotificationRepository = class NotificationRepository {
  static get CONFIG() {
    return {
      BODY_LENGTH: 80,
      ICON_URL: '/image/logo/notification.png',
      TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 5,
      TITLE_LENGTH: 38,
    };
  }

  static get EVENTS_TO_NOTIFY() {
    return [
      z.message.SuperType.CALL,
      z.message.SuperType.CONTENT,
      z.message.SuperType.MEMBER,
      z.message.SuperType.PING,
      z.message.SuperType.REACTION,
      z.message.SuperType.SYSTEM,
    ];
  }

  /**
   * Construct a new Notification Repository.
   * @param {z.calling.CallingRepository} callingRepository - Repository for all call interactions
   * @param {z.conversation.ConversationRepository} conversationRepository - Repository for all conversation interactions
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   * @param {z.user.UserRepository} userRepository - Repository for users
   */
  constructor(callingRepository, conversationRepository, permissionRepository, userRepository) {
    this.callingRepository = callingRepository;
    this.conversationRepository = conversationRepository;
    this.permissionRepository = permissionRepository;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.notification.NotificationRepository', z.config.LOGGER.OPTIONS);

    this.notifications = [];

    this.subscribeToEvents();
    this.notificationsPreference = ko.observable(z.notification.NotificationPreference.ON);
    this.notificationsPreference.subscribe(notificationsPreference => {
      const preferenceIsNone = notificationsPreference === z.notification.NotificationPreference.NONE;
      if (!preferenceIsNone) {
        this.checkPermission();
      }
    });

    this.permissionState = this.permissionRepository.permissionState[z.permission.PermissionType.NOTIFICATIONS];
    this.selfUser = this.userRepository.self;
  }

  subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.NOTIFICATION.NOTIFY, this.notify.bind(this));
    amplify.subscribe(z.event.WebApp.NOTIFICATION.PERMISSION_STATE, this.updatePermissionState.bind(this));
    amplify.subscribe(z.event.WebApp.NOTIFICATION.REMOVE_READ, this.removeReadNotifications.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updatedProperties.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.NOTIFICATIONS, this.updatedNotificationsProperty.bind(this));
  }

  /**
   * Check for browser permission if we have not yet asked.
   * @returns {Promise} Promise that resolves with the permission state
   */
  checkPermission() {
    return this._checkPermissionState().then(isPermitted => {
      if (_.isBoolean(isPermitted)) {
        return isPermitted;
      }

      if (!z.util.Environment.browser.supports.notifications) {
        return this.updatePermissionState(z.notification.PermissionState.UNSUPPORTED);
      }

      if (z.util.Environment.browser.supports.permissions) {
        return this.permissionRepository.getPermissionState(z.permission.PermissionType.NOTIFICATIONS).then(() => {
          const shouldRequestPermission = this.permissionState() === z.permission.PermissionStatusState.PROMPT;
          return shouldRequestPermission ? this._requestPermission() : this._checkPermissionState();
        });
      }

      const currentPermission = window.Notification.permission;
      const shouldRequestPermission = currentPermission === z.notification.PermissionState.DEFAULT;
      return shouldRequestPermission ? this._requestPermission() : this.updatePermissionState(currentPermission);
    });
  }

  /**
   * Close all notifications.
   * @returns {undefined} No return value
   */
  clearNotifications() {
    this.notifications.forEach(notification => {
      notification.close();
      if (notification.data) {
        const {conversationId, messageId} = notification.data;
        this.logger.info(`Notification for '${messageId}' in '${conversationId}' closed on unload.`, notification);
      }
    });
  }

  /**
   * Display browser notification and play sound notification.
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves when notification has been handled
   */
  notify(messageEntity, connectionEntity, conversationEntity) {
    const notifyInConversation = conversationEntity
      ? NotificationRepository.shouldNotifyInConversation(conversationEntity, messageEntity, this.selfUser().id)
      : true;

    return Promise.resolve(notifyInConversation).then(shouldNotifyInConversation => {
      if (shouldNotifyInConversation) {
        this._notifySound(messageEntity);
        return this._notifyBanner(messageEntity, connectionEntity, conversationEntity);
      }
    });
  }

  // Remove notifications from the queue that are no longer unread
  removeReadNotifications() {
    this.notifications.forEach(notification => {
      const {conversationId, messageId, messageType} = notification.data || {};

      if (messageId) {
        this.conversationRepository.is_message_read(conversationId, messageId).then(isRead => {
          if (isRead) {
            notification.close();
            const messageInfo = messageId
              ? `message '${messageId}' of type '${messageType}'`
              : `'${messageType}' message`;
            this.logger.info(`Removed read notification for ${messageInfo} in '${conversationId}'.`);
          }
        });
      }
    });
  }

  updatedProperties(properties) {
    const notificationPreference = properties.settings.notifications;
    return this.notificationsPreference(notificationPreference);
  }

  updatedNotificationsProperty(notificationPreference) {
    return this.notificationsPreference(notificationPreference);
  }

  /**
   * Set the permission state.
   * @param {z.permission.PermissionStatusState} permissionState - State of browser permission
   * @returns {Promise} Resolves with true if notifications are enabled
   */
  updatePermissionState(permissionState) {
    this.permissionState(permissionState);
    return this._checkPermissionState();
  }

  /**
   * Creates the notification body for calls.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {string} Notification message body
   */
  _createBodyCall(messageEntity) {
    if (messageEntity.is_activation()) {
      return z.l10n.text(z.string.notificationVoiceChannelActivate);
    }

    if (messageEntity.is_deactivation() && messageEntity.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED) {
      return z.l10n.text(z.string.notificationVoiceChannelDeactivate);
    }
  }

  /**
   * Creates the notification body for text messages and pictures.
   *
   * @private
   * @param {z.entity.ContentMessage} messageEntity - Normal message entity
   * @returns {string} Notification message body
   */
  _createBodyContent(messageEntity) {
    if (messageEntity.has_asset_text()) {
      for (const assetEntity of messageEntity.assets()) {
        if (assetEntity.is_text()) {
          let notificationText;

          if (assetEntity.isUserMentioned(this.selfUser().id)) {
            notificationText = z.l10n.text(z.string.notificationMention, assetEntity.text);
          } else if (messageEntity.isUserQuoted(this.selfUser().id)) {
            notificationText = z.l10n.text(z.string.notificationReply, assetEntity.text);
          } else {
            notificationText = assetEntity.text;
          }

          return z.util.StringUtil.truncate(notificationText, NotificationRepository.CONFIG.BODY_LENGTH);
        }
      }
    }

    if (messageEntity.has_asset_image()) {
      return z.l10n.text(z.string.notificationAssetAdd);
    }

    if (messageEntity.has_asset_location()) {
      return z.l10n.text(z.string.notificationSharedLocation);
    }

    if (messageEntity.has_asset()) {
      const assetEntity = messageEntity.get_first_asset();

      if (assetEntity.is_audio()) {
        return z.l10n.text(z.string.notificationSharedAudio);
      }

      if (assetEntity.is_video()) {
        return z.l10n.text(z.string.notificationSharedVideo);
      }

      if (assetEntity.is_file()) {
        return z.l10n.text(z.string.notificationSharedFile);
      }
    }
  }

  /**
   * Creates the notification body for people being added to a group conversation.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodyMemberJoin(messageEntity) {
    const updatedOneParticipant = messageEntity.userEntities().length === 1;
    if (updatedOneParticipant) {
      const [otherUserEntity] = messageEntity.userEntities();

      const declension = z.string.Declension.ACCUSATIVE;
      const nameOfJoinedUser = z.util.SanitizationUtil.getFirstName(otherUserEntity, declension);

      const senderJoined = messageEntity.user().id === otherUserEntity.id;
      if (senderJoined) {
        return z.l10n.text(z.string.notificationMemberJoinSelf, nameOfJoinedUser);
      }

      const substitutions = {user1: messageEntity.user().first_name(), user2: nameOfJoinedUser};
      return z.l10n.text(z.string.notificationMemberJoinOne, substitutions);
    }

    const substitutions = {number: messageEntity.userIds().length, user: messageEntity.user().first_name()};
    return z.l10n.text(z.string.notificationMemberJoinMany, substitutions);
  }

  /**
   * Creates the notification body for people being removed from or leaving a group conversation.
   * @note Only show a notification if self user was removed
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodyMemberLeave(messageEntity) {
    const updatedOneParticipant = messageEntity.userEntities().length === 1;
    if (updatedOneParticipant && !messageEntity.remoteUserEntities().length) {
      return z.l10n.text(z.string.notificationMemberLeaveRemovedYou, messageEntity.user().first_name());
    }
  }

  /**
   * Selects the type of system message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message body
   */
  _createBodyMemberUpdate(messageEntity, connectionEntity, conversationEntity) {
    const isGroup = conversationEntity && conversationEntity.isGroup();

    switch (messageEntity.memberMessageType) {
      case z.message.SystemMessageType.NORMAL:
        if (isGroup) {
          if (messageEntity.isMemberJoin()) {
            return this._createBodyMemberJoin(messageEntity);
          }
          if (messageEntity.isMemberLeave()) {
            return this._createBodyMemberLeave(messageEntity);
          }
        }
        break;
      case z.message.SystemMessageType.CONNECTION_ACCEPTED:
        return z.l10n.text(z.string.notificationConnectionAccepted);
      case z.message.SystemMessageType.CONNECTION_CONNECTED:
        return z.l10n.text(z.string.notificationConnectionConnected);
      case z.message.SystemMessageType.CONNECTION_REQUEST:
        return z.l10n.text(z.string.notificationConnectionRequest);
      case z.message.SystemMessageType.CONVERSATION_CREATE:
        return z.l10n.text(z.string.notificationConversationCreate, messageEntity.user().first_name());
      default:
        const conversationId = this._getConversationId(connectionEntity, conversationEntity);
        const message = `No notification for '${messageEntity.id} in '${conversationId}'.`;
        this.logger.log(this.logger.levels.OFF, message);
    }
  }

  /**
   * Creates the notification body for obfuscated messages.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message to obfuscate body for
   * @returns {string} Notification message body
   */
  _createBodyObfuscated(messageEntity) {
    if (messageEntity.is_content()) {
      const isSelfMentioned = messageEntity.isUserMentioned(this.selfUser().id);

      if (isSelfMentioned) {
        return z.l10n.text(z.string.notificationObfuscatedMention);
      }

      const isSelfQuoted = messageEntity.isUserQuoted(this.selfUser().id);

      if (isSelfQuoted) {
        return z.l10n.text(z.string.notificationObfuscatedReply);
      }
    }

    return z.l10n.text(z.string.notificationObfuscated);
  }

  /**
   * Creates the notification body for ping.
   * @private
   * @returns {string} Notification message body
   */
  _createBodyPing() {
    return z.l10n.text(z.string.notificationPing);
  }

  /**
   * Creates the notification body for reaction.
   * @private
   * @param {z.entity.Message} messageEntity - Fake reaction message entity
   * @returns {string} Notification message body
   */
  _createBodyReaction(messageEntity) {
    return z.l10n.text(z.string.notificationReaction, messageEntity.reaction);
  }

  /**
   * Selects the type of system message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodySystem(messageEntity) {
    const createBodyMessageTimerUpdate = () => {
      const messageTimer = z.conversation.ConversationEphemeralHandler.validateTimer(messageEntity.message_timer);

      if (messageTimer) {
        const timeString = z.util.TimeUtil.formatDuration(messageTimer).text;
        const substitutions = {time: timeString, user: messageEntity.user().first_name()};
        return z.l10n.text(z.string.notificationConversationMessageTimerUpdate, substitutions);
      }
      return z.l10n.text(z.string.notificationConversationMessageTimerReset, messageEntity.user().first_name());
    };

    const createBodyRename = () => {
      const substitutions = {name: messageEntity.name, user: messageEntity.user().first_name()};
      return z.l10n.text(z.string.notificationConversationRename, substitutions);
    };

    switch (messageEntity.system_message_type) {
      case z.message.SystemMessageType.CONVERSATION_RENAME: {
        return createBodyRename();
      }

      case z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE: {
        return createBodyMessageTimerUpdate(messageEntity);
      }
    }
  }

  /**
   * Create notification content.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves with the notification content
   */
  _createNotificationContent(messageEntity, connectionEntity, conversationEntity) {
    let optionsBody = undefined;

    return this._createOptionsBody(messageEntity, connectionEntity, conversationEntity)
      .then(body => {
        optionsBody = body;
        if (optionsBody) {
          return this._shouldObfuscateNotificationSender(messageEntity);
        }
        throw new z.error.NotificationError(z.error.NotificationError.TYPE.HIDE_NOTIFICATION);
      })
      .then(shouldObfuscateSender => {
        return this._createOptionsIcon(shouldObfuscateSender, messageEntity.user()).then(iconUrl => {
          const shouldObfuscateMessage = this._shouldObfuscateNotificationMessage(messageEntity);
          return {
            options: {
              body: shouldObfuscateMessage ? this._createBodyObfuscated(messageEntity) : optionsBody,
              data: this._createOptionsData(messageEntity, connectionEntity, conversationEntity),
              icon: iconUrl,
              silent: true, // @note When Firefox supports this we can remove the fix for WEBAPP-731
              tag: this._createOptionsTag(connectionEntity, conversationEntity),
            },
            timeout: NotificationRepository.CONFIG.TIMEOUT,
            title: shouldObfuscateSender
              ? this._createTitleObfuscated()
              : this._createTitle(messageEntity, conversationEntity),
            trigger: this._createTrigger(messageEntity, connectionEntity, conversationEntity),
          };
        });
      });
  }

  /**
   * Selects the type of message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @param {z.entity.Conversation} conversationEntity - Conversation entity
   * @returns {Promise} Resolves with the notification message body
   */
  _createOptionsBody(messageEntity, connectionEntity, conversationEntity) {
    return Promise.resolve().then(() => {
      switch (messageEntity.super_type) {
        case z.message.SuperType.CALL:
          return this._createBodyCall(messageEntity);
        case z.message.SuperType.CONTENT:
          return this._createBodyContent(messageEntity);
        case z.message.SuperType.MEMBER:
          return this._createBodyMemberUpdate(messageEntity, connectionEntity, conversationEntity);
        case z.message.SuperType.PING:
          return this._createBodyPing();
        case z.message.SuperType.REACTION:
          return this._createBodyReaction(messageEntity);
        case z.message.SuperType.SYSTEM:
          return this._createBodySystem(messageEntity);
        default:
          const conversationId = this._getConversationId(connectionEntity, conversationEntity);
          const message = `No notification for '${messageEntity.id} in '${conversationId}'.`;
          this.logger.log(this.logger.levels.OFF, message);
      }
    });
  }

  /**
   * Creates the notification data to help check its content.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Object} Notification message data
   */
  _createOptionsData(messageEntity, connectionEntity, conversationEntity) {
    const {id: messageId, type: messageType} = messageEntity;

    return {
      conversationId: this._getConversationId(connectionEntity, conversationEntity),
      messageId: messageId === '0' ? undefined : messageId,
      messageType: messageType,
    };
  }

  /**
   * Creates the notification icon.
   *
   * @private
   * @param {boolean} shouldObfuscateSender - Sender visible in notification
   * @param {z.entity.User} userEntity - Sender of message
   * @returns {Promise} Resolves with the icon URL
   */
  _createOptionsIcon(shouldObfuscateSender, userEntity) {
    const canShowUserImage = userEntity.previewPictureResource() && !shouldObfuscateSender;
    if (canShowUserImage) {
      return userEntity
        .previewPictureResource()
        .generateUrl()
        .catch(error => {
          if (error instanceof z.util.ValidationUtilError) {
            this.logger.error(`Failed to validate an asset URL: ${error.message}`);
          }
          return '';
        });
    }

    const isMacOsWrapper = z.util.Environment.electron && z.util.Environment.os.mac;
    return Promise.resolve(isMacOsWrapper ? '' : NotificationRepository.CONFIG.ICON_URL);
  }

  /**
   * Creates the notification tag.
   *
   * @private
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message tag
   */
  _createOptionsTag(connectionEntity, conversationEntity) {
    return this._getConversationId(connectionEntity, conversationEntity);
  }

  /**
   * Creates the notification title.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message title
   */
  _createTitle(messageEntity, conversationEntity) {
    const conversationName = conversationEntity && conversationEntity.display_name();
    const userEntity = messageEntity.user();

    let title;
    if (conversationName) {
      title = conversationEntity.isGroup()
        ? z.l10n.text(z.string.notificationTitleGroup, {conversation: conversationName, user: userEntity.first_name()})
        : conversationName;
    }

    return z.util.StringUtil.truncate(title || userEntity.name(), NotificationRepository.CONFIG.TITLE_LENGTH, false);
  }

  /**
   * Create obfuscated title.
   * @private
   * @returns {string} Obfuscated notification message title
   */
  _createTitleObfuscated() {
    const obfuscatedTitle = z.l10n.text(z.string.notificationObfuscatedTitle);
    return z.util.StringUtil.truncate(obfuscatedTitle, NotificationRepository.CONFIG.TITLE_LENGTH, false);
  }

  /**
   * Creates the notification trigger.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Function} Function to be called when notification is clicked
   */
  _createTrigger(messageEntity, connectionEntity, conversationEntity) {
    const conversationId = this._getConversationId(connectionEntity, conversationEntity);

    const containsSelfMention = messageEntity.is_content() && messageEntity.isUserMentioned(this.selfUser().id);
    if (containsSelfMention) {
      const showOptions = {exposeMessage: messageEntity, openFirstSelfMention: true};
      return () => amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity, showOptions);
    }

    const isConnectionRequest = messageEntity.is_member() && messageEntity.isConnectionRequest();
    if (isConnectionRequest) {
      return () => {
        amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
      };
    }

    return () => amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity || conversationId);
  }

  /**
   * Retrieve conversation ID from either conversation or connection.
   *
   * @private
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} ID of conversation
   */
  _getConversationId(connectionEntity, conversationEntity) {
    return connectionEntity ? connectionEntity.conversationId : conversationEntity.id;
  }

  /**
   * Evaluates the current permission state.
   * @private
   * @returns {Promise} Resolves with true if notifications are permitted
   */
  _checkPermissionState() {
    switch (this.permissionState()) {
      case z.permission.PermissionStatusState.GRANTED: {
        return Promise.resolve(true);
      }

      case z.notification.PermissionState.IGNORED:
      case z.notification.PermissionState.UNSUPPORTED:
      case z.permission.PermissionStatusState.DENIED: {
        return Promise.resolve(false);
      }

      default: {
        return Promise.resolve(undefined);
      }
    }
  }

  /**
   * Creates the browser notification and sends it.
   *
   * @private
   * @see https://developer.mozilla.org/en/docs/Web/API/notification#Parameters
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves when notification was handled
   */
  _notifyBanner(messageEntity, connectionEntity, conversationEntity) {
    return this._shouldShowNotification(messageEntity, conversationEntity)
      .then(() => this._createNotificationContent(messageEntity, connectionEntity, conversationEntity))
      .then(notificationContent => {
        return this.checkPermission().then(isPermitted => {
          return isPermitted ? this._showNotification(notificationContent) : undefined;
        });
      })
      .catch(error => {
        const hideNotification = error.type === z.error.NotificationError.TYPE.HIDE_NOTIFICATION;
        if (!hideNotification) {
          throw error;
        }
      });
  }

  /**
   * Plays the sound from the audio repository.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {undefined} No return value
   */
  _notifySound(messageEntity) {
    const muteSound = !document.hasFocus() && z.util.Environment.browser.firefox && z.util.Environment.os.mac;
    const isFromSelf = messageEntity.user().is_me;
    const shouldPlaySound = !muteSound && !isFromSelf;

    if (shouldPlaySound) {
      switch (messageEntity.super_type) {
        case z.message.SuperType.CONTENT: {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.NEW_MESSAGE);
          break;
        }

        case z.message.SuperType.PING: {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.INCOMING_PING);
          break;
        }

        default:
          this.logger.log(this.logger.levels.OFF, `No notification sound for message '${messageEntity.id}.`);
      }
    }
  }

  // Request browser permission for notifications.
  _requestPermission() {
    return new Promise(resolve => {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.REQUEST_NOTIFICATION);
      // Note: The callback will be only triggered in Chrome.
      // If you ignore a permission request on Firefox, then the callback will not be triggered.
      if (window.Notification.requestPermission) {
        window.Notification.requestPermission(permissionState => {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.REQUEST_NOTIFICATION);
          this.updatePermissionState(permissionState).then(resolve);
        });
      }
    });
  }

  /**
   * Should message in a notification be obfuscated.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {boolean} Obfuscate message in notification
   */
  _shouldObfuscateNotificationMessage(messageEntity) {
    const preferencesToObfuscateMessage = [
      z.notification.NotificationPreference.OBFUSCATE,
      z.notification.NotificationPreference.OBFUSCATE_MESSAGE,
    ];

    return preferencesToObfuscateMessage.includes(this.notificationsPreference()) || messageEntity.is_ephemeral();
  }

  /**
   * Should sender in a notification be obfuscated.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {boolean} Obfuscate sender in notification
   */
  _shouldObfuscateNotificationSender(messageEntity) {
    const isSetToObfuscate = this.notificationsPreference() === z.notification.NotificationPreference.OBFUSCATE;
    return isSetToObfuscate || messageEntity.is_ephemeral();
  }

  /**
   * Should hide notification.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves if the notification should be shown
   */
  _shouldShowNotification(messageEntity, conversationEntity) {
    const inActiveConversation = conversationEntity
      ? this.conversationRepository.is_active_conversation(conversationEntity)
      : false;
    const inConversationView = wire.app.view.content.state() === z.viewModel.ContentViewModel.STATE.CONVERSATION;
    const inMaximizedCall = this.callingRepository.joinedCall() && !wire.app.view.content.multitasking.isMinimized();

    const activeConversation = document.hasFocus() && inConversationView && inActiveConversation && !inMaximizedCall;
    const messageFromSelf = messageEntity.user().is_me;
    const permissionDenied = this.permissionState() === z.permission.PermissionStatusState.DENIED;
    const preferenceIsNone = this.notificationsPreference() === z.notification.NotificationPreference.NONE;
    const supportsNotification = z.util.Environment.browser.supports.notifications;

    const hideNotification =
      activeConversation || messageFromSelf || permissionDenied || preferenceIsNone || !supportsNotification;

    return hideNotification
      ? Promise.reject(new z.error.NotificationError(z.error.NotificationError.TYPE.HIDE_NOTIFICATION))
      : Promise.resolve();
  }

  /**
   * Sending the notification.
   *
   * @param {Object} notificationContent - Content of notification
   * @param {string} notificationContent.title - Title of notification
   * @param {Object} notificationContent.options - Notification options
   * @param {Function} notificationContent.trigger - Function to be called on notificiation click
   * @param {Integer} notificationContent.timeout - Timeout after which notification is closed
   * @returns {undefined} No return value
   */
  _showNotification(notificationContent) {
    amplify.publish(z.event.WebApp.NOTIFICATION.SHOW, notificationContent);
    this._showNotificationInBrowser(notificationContent);
  }

  /**
   * Sending the browser notification.
   *
   * @private
   * @param {Object} notificationContent - Content of notification
   * @param {string} notificationContent.title - Notification title
   * @param {Object} notificationContent.options - Notification options
   * @param {Function} notificationContent.trigger - Function to be triggered on click [Function] trigger
   * @param {number} notificationContent.timeout - Timeout for notification
   * @returns {undefined} No return value
   */
  _showNotificationInBrowser(notificationContent) {
    /*
    @note Notification.data is only supported on Chrome
    @see https://developer.mozilla.org/en-US/docs/Web/API/Notification/data
    */
    this.removeReadNotifications();
    const notification = new window.Notification(notificationContent.title, notificationContent.options);
    const {conversationId, messageId, messageType} = notificationContent.options.data;
    let timeoutTriggerId = undefined;

    const messageInfo = messageId ? `message '${messageId}' of type '${messageType}'` : `'${messageType}' message`;
    notification.onclick = () => {
      amplify.publish(z.event.WebApp.NOTIFICATION.CLICK);
      window.focus();
      wire.app.view.content.multitasking.isMinimized(true);
      notificationContent.trigger();

      this.logger.info(`Notification for ${messageInfo} in '${conversationId}' closed by click.`);
      notification.close();
    };

    notification.onclose = () => {
      window.clearTimeout(timeoutTriggerId);
      this.notifications.splice(this.notifications.indexOf(notification), 1);
      this.logger.info(`Removed notification for ${messageInfo} in '${conversationId}' locally.`);
    };

    notification.onerror = error => {
      this.logger.error(`Notification for ${messageInfo} in '${conversationId}' closed by error.`, error);
      notification.close();
    };

    notification.onshow = () => {
      timeoutTriggerId = window.setTimeout(() => {
        this.logger.info(`Notification for ${messageInfo} in '${conversationId}' closed by timeout.`);
        notification.close();
      }, notificationContent.timeout);
    };

    this.notifications.push(notification);
    this.logger.info(`Added notification for ${messageInfo} in '${conversationId}' to queue.`);
  }

  /**
   * Check whether conversation is in state to trigger notitication.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to notify in .
   * @param {z.entity.Message} messageEntity - The message to filter from.
   * @param {string} userId - The user id to check mentions for.
   * @returns {boolean} True if the conversation should show notification.
   */
  static shouldNotifyInConversation(conversationEntity, messageEntity, userId) {
    if (conversationEntity.showNotificationsNothing()) {
      return false;
    }

    const isEventTypeToNotify = NotificationRepository.EVENTS_TO_NOTIFY.includes(messageEntity.super_type);
    const isEventToNotify = isEventTypeToNotify && !messageEntity.isEdited() && !messageEntity.isLinkPreview();

    if (conversationEntity.showNotificationsEverything()) {
      return isEventToNotify;
    }

    const isSelfMentionOrReply = messageEntity.is_content() && messageEntity.isUserTargeted(userId);

    return isEventToNotify && isSelfMentionOrReply;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

/**
 * Permission repository to check browser permissions.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API
 */
z.permission.PermissionRepository = class PermissionRepository {
  static get CONFIG() {
    return {
      MEDIA_TYPES: [z.permission.PermissionType.CAMERA, z.permission.PermissionType.MICROPHONE],
    };
  }
  /**
   * Construct a new Permission Repository.
   * @param {z.calling.CallingRepository} callingRepository - Repository for all call interactions
   * @param {z.conversation.ConversationService} conversationRepository - Repository for all conversation interactions
   */
  constructor(callingRepository, conversationRepository) {
    this.logger = new z.util.Logger('z.permission.PermissionRepository', z.config.LOGGER.OPTIONS);

    this.permissionState = {
      [z.permission.PermissionType.CAMERA]: ko.observable(undefined),
      [z.permission.PermissionType.GEO_LOCATION]: ko.observable(undefined),
      [z.permission.PermissionType.MICROPHONE]: ko.observable(undefined),
      [z.permission.PermissionType.NOTIFICATIONS]: ko.observable(undefined),
    };
  }

  checkPermissionState(permissionType) {
    return Promise.resolve().then(() => {
      const setPermissionState = permissionState => this.permissionState[permissionType](permissionState);

      if (!z.util.Environment.browser.supports.permissions) {
        throw new z.error.PermissionError(z.error.PermissionError.TYPE.UNSUPPORTED);
      }

      const isMediaPermission = PermissionRepository.CONFIG.MEDIA_TYPES.includes(permissionType);
      if (isMediaPermission && !z.util.Environment.browser.supports.mediaPermissions) {
        throw new z.error.PermissionError(z.error.PermissionError.TYPE.UNSUPPORTED_TYPE);
      }

      return navigator.permissions.query({name: permissionType}).then(permissionStatus => {
        this.logger.log(`Permission state for '${permissionType}' is '${permissionStatus.state}'`, permissionStatus);
        setPermissionState(permissionStatus.state);

        permissionStatus.onchange = () => {
          const logMessage = `Permission  state for '${permissionType}' changed to '${permissionStatus.state}'`;
          this.logger.log(logMessage, permissionStatus);
          setPermissionState(permissionStatus.state);
        };

        return permissionStatus.state;
      });
    });
  }

  getPermissionState(permissionType) {
    const currentPermissionState = this.permissionState[permissionType]();
    return currentPermissionState ? Promise.resolve(currentPermissionState) : this.checkPermissionState(permissionType);
  }

  getPermissionStates(permissionTypes) {
    const permissionPromises = permissionTypes.map(permissionType => {
      return this.getPermissionState(permissionType)
        .then(permissionState => ({permissionState, permissionType}))
        .catch(() => ({permissionState: z.permission.PermissionStatusState.PROMPT, permissionType}));
    });

    return Promise.all(permissionPromises);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

// https://developer.mozilla.org/en-US/docs/Web/API/PermissionStatus/state
z.permission.PermissionStatusState = {
  DENIED: 'denied',
  GRANTED: 'granted',
  PROMPT: 'prompt',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

// https://developer.mozilla.org/en-US/docs/Web/API/Permissions/query
z.permission.PermissionType = {
  CAMERA: 'camera',
  GEO_LOCATION: 'geolocation',
  MICROPHONE: 'microphone',
  NOTIFICATIONS: 'notifications',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesEntity = class PropertiesEntity {
  constructor() {
    this[z.properties.PROPERTIES_TYPE.VERSION] = 1;
    this.settings = {
      emoji: {
        replace_inline: true,
      },
      notifications: z.notification.NotificationPreference.ON,
      previews: {
        send: true,
      },
      privacy: {
        improve_wire: undefined,
      },
      sound: {
        alerts: z.audio.AudioPreference.ALL,
      },
    };
    this.contact_import = {
      macos: undefined,
    };
    this[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING] = false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesRepository = class PropertiesRepository {
  static get CONFIG() {
    return {
      PROPERTIES_KEY: 'webapp',
    };
  }

  /**
   * Construct a new User properties repository.
   * @param {z.properties.PropertiesService} propertiesService - Backend REST API properties service implementation
   */
  constructor(propertiesService) {
    this.propertiesService = propertiesService;
    this.logger = new z.util.Logger('z.properties.PropertiesRepository', z.config.LOGGER.OPTIONS);

    this.properties = new z.properties.PropertiesEntity();
    this.selfUser = ko.observable();

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.propertiesUpdated.bind(this));
  }

  checkPrivacyPermission() {
    const isPrivacyPreferenceSet = this.getPreference(z.properties.PROPERTIES_TYPE.PRIVACY) !== undefined;

    return isPrivacyPreferenceSet
      ? Promise.resolve()
      : new Promise(resolve => {
          amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
            action: () => {
              this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, true);
              this._publishProperties();
              resolve();
            },
            preventClose: true,
            secondary: () => {
              this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, false);
              resolve();
            },
            text: {
              action: z.l10n.text(z.string.modalImproveWireAction),
              message: z.l10n.text(z.string.modalImproveWireMessage),
              secondary: z.l10n.text(z.string.modalImproveWireSecondary),
              title: z.l10n.text(z.string.modalImproveWireHeadline),
            },
            warning: false,
          });
        });
  }

  /**
   * Get the current preference for a property type.
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to get
   * @returns {*} Preference value
   */
  getPreference(propertiesType) {
    const typeParts = propertiesType.split('.');
    const [partOne, partTwo, partThree] = typeParts;

    switch (typeParts.length) {
      case 1:
        return this.properties[partOne];
      case 2:
        return this.properties[partOne][partTwo];
      case 3:
        return this.properties[partOne][partTwo][partThree];
      default:
        throw new Error(`Failed to get preference of type ${propertiesType}`);
    }
  }

  /**
   * Initialize properties on app startup.
   * @param {z.entity.User} selfUserEntity - Self user
   * @returns {Promise} Resolves when repository has been initialized
   */
  init(selfUserEntity) {
    this.selfUser(selfUserEntity);

    return this.selfUser().isTemporaryGuest() ? this._initTemporaryGuestAccount() : this._initActivatedAccount();
  }

  _initActivatedAccount() {
    return this.propertiesService
      .getProperties()
      .then(keys => {
        if (keys.includes(PropertiesRepository.CONFIG.PROPERTIES_KEY)) {
          return this.propertiesService
            .getPropertiesByKey(PropertiesRepository.CONFIG.PROPERTIES_KEY)
            .then(properties => {
              $.extend(true, this.properties, properties);
              this.logger.info('Loaded user properties', this.properties);
            });
        }

        this.logger.info('No properties found: Using default properties');
      })
      .then(() => this._publishProperties());
  }

  _initTemporaryGuestAccount() {
    this.logger.info('Temporary guest user: Using default properties');
    this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, false);
    return Promise.resolve(this._publishProperties());
  }

  _publishProperties() {
    amplify.publish(z.event.WebApp.PROPERTIES.UPDATED, this.properties);
    return this.properties;
  }

  /**
   * Updated properties handler.
   * @param {z.properties.Properties} properties - New properties
   * @returns {boolean} Always returns true to ensure other subscribers handling the event
   */
  propertiesUpdated(properties) {
    if (properties[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING]) {
      amplify.publish(z.util.Logger.prototype.LOG_ON_DEBUG, properties[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING]);
    }
    return true;
  }

  /**
   * Save property setting.
   *
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to update
   * @param {*} updatedPreference - New property setting
   * @returns {undefined} No return value
   */
  savePreference(propertiesType, updatedPreference) {
    if (updatedPreference === undefined) {
      switch (propertiesType) {
        case z.properties.PROPERTIES_TYPE.CONTACT_IMPORT.MACOS:
          updatedPreference = Date.now();
          break;
        default:
          updatedPreference = true;
      }
    }

    if (updatedPreference !== this.getPreference(propertiesType)) {
      this._setPreference(propertiesType, updatedPreference);

      const savePromise = this.selfUser().isTemporaryGuest()
        ? this._savePreferenceTemporaryGuestAccount(propertiesType, updatedPreference)
        : this._savePreferenceActivatedAccount(propertiesType, updatedPreference);

      savePromise.then(() => this._publishPropertyUpdate(propertiesType, updatedPreference));
    }
  }

  _savePreferenceActivatedAccount(propertiesType, updatedPreference) {
    return this.propertiesService
      .putPropertiesByKey(PropertiesRepository.CONFIG.PROPERTIES_KEY, this.properties)
      .then(() => this.logger.info(`Saved updated preference: '${propertiesType}' - '${updatedPreference}'`));
  }

  _savePreferenceTemporaryGuestAccount(propertiesType, updatedPreference) {
    this.logger.info(`Updated preference: '${propertiesType}' - '${updatedPreference}'`);
    return Promise.resolve();
  }

  _publishPropertyUpdate(propertiesType, updatedPreference) {
    switch (propertiesType) {
      case z.properties.PROPERTIES_TYPE.CONTACT_IMPORT.MACOS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.CONTACTS, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.EMOJI.REPLACE_INLINE, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING:
        amplify.publish(z.util.Logger.prototype.LOG_ON_DEBUG, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.NOTIFICATIONS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.NOTIFICATIONS, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.PREVIEWS.SEND:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.PREVIEWS.SEND, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.PRIVACY:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.PRIVACY, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.SOUND_ALERTS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.SOUND_ALERTS, updatedPreference);
        break;
      default:
        throw new Error(`Failed to update preference of unhandled type '${propertiesType}'`);
    }
  }

  /**
   * Set the preference of specified type
   *
   * @private
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to set
   * @param {*} changedPreference - New preference to set
   * @returns {undefined} No return value
   */
  _setPreference(propertiesType, changedPreference) {
    const typeParts = propertiesType.split('.');
    const [partOne, partTwo, partThree] = typeParts;

    switch (typeParts.length) {
      case 1:
        this.properties[partOne] = changedPreference;
        break;
      case 2:
        this.properties[partOne][partTwo] = changedPreference;
        break;
      case 3:
        this.properties[partOne][partTwo][partThree] = changedPreference;
        break;
      default:
        throw new Error(`Failed to set preference of type ${propertiesType}`);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesService = class PropertiesService {
  static get CONFIG() {
    return {
      URL_PROPERTIES: '/properties',
    };
  }

  /**
   * Construct a new Properties Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.properties.PropertiesService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Clear all properties store for the user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/clearProperties
   * @returns {Promise} Resolves when all properties for user have been cleared
   */
  deleteProperties() {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: PropertiesService.CONFIG.URL_PROPERTIES,
    });
  }

  /**
   * Delete a property.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/deleteProperty
   * @param {string} key - Key used to store user properties
   * @returns {Promise} Resolves when the requested property for user has been cleared
   */
  deletePropertiesByKey(key) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }

  /**
   * List all property keys stored for the user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/listPropertyKeys
   * @returns {Promise} Resolves with an array of the property keys stored for the user
   */
  getProperties() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: PropertiesService.CONFIG.URL_PROPERTIES,
    });
  }

  /**
   * Get a property value stored for a key.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getProperty
   *
   * @param {string} key - Key used to store user properties
   * @returns {Promise} Resolves with the property set for the given key
   */
  getPropertiesByKey(key) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }

  /**
   * Set a property value for a key.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/setProperty
   *
   * @param {string} key - Key used to store user properties
   * @param {Object} properties - Payload to be stored
   * @returns {Promise} Resolves when the property has been stored
   */
  putPropertiesByKey(key, properties) {
    return this.backendClient.sendJson({
      data: properties,
      type: 'PUT',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PROPERTIES_TYPE = {
  CONTACT_IMPORT: {
    MACOS: 'contact_import.macos',
  },
  EMOJI: {
    REPLACE_INLINE: 'settings.emoji.replace_inline',
  },
  ENABLE_DEBUGGING: 'enable_debugging',
  NOTIFICATIONS: 'settings.notifications',
  PREVIEWS: {
    SEND: 'settings.previews.send',
  },
  PRIVACY: 'settings.privacy.improve_wire',
  SOUND_ALERTS: 'settings.sound.alerts',
  VERSION: 'version',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.FullTextSearch = (() => {
  const _getSearchRegex = query => {
    const delimiter = ' ';
    const flags = 'gumi';
    const regex = query
      .trim()
      .split(delimiter)
      .map(word => `(${z.util.SanitizationUtil.escapeRegex(word)})`)
      .join('(?:.*)');

    return new RegExp(regex, flags);
  };

  const _search = (text, query = '') => {
    query = query.trim();

    if (query.length > 0) {
      return _getSearchRegex(query).test(text);
    }
    return false;
  };

  return {
    getSearchRegex: _getSearchRegex,
    search: _search,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.SearchService = class SearchService {
  /**
   * Construct a new Search Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.search.SearchService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Search for a user.
   *
   * @param {string} query - Query string (case insensitive)
   * @param {number} size - Number of requested user
   * @returns {Promise} Resolves with the search results
   */
  getContacts(query, size) {
    return this.backendClient.sendRequest({
      data: {
        // eslint-disable-next-line id-length
        q: query,
        size,
      },
      type: 'GET',
      url: '/search/contacts',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.SearchRepository = class SearchRepository {
  static get CONFIG() {
    return {
      MAX_DIRECTORY_RESULTS: 30,
      MAX_SEARCH_RESULTS: 10,
      SEARCHABLE_FIELDS: {
        NAME: 'name',
        USERNAME: 'username',
      },
    };
  }

  /**
   * Trim and remove @.
   * @param {string} query - Search string
   * @returns {string} Normalized search query
   */
  static normalizeQuery(query) {
    if (!_.isString(query)) {
      return '';
    }
    return query
      .trim()
      .replace(/^[@]/, '')
      .toLowerCase();
  }

  /**
   * Construct a new Conversation Repository.
   * @param {z.search.SearchService} searchService - Backend REST API search service implementation
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(searchService, userRepository) {
    this.searchService = searchService;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.search.SearchRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Search for a user in the given user list and given a search term.
   * Doesn't sort the results and keep the initial order of the given user list.
   *
   * @param {string} term - the search term
   * @param {Array<z.entity.User>} userEntities - entities to match the search term against
   * @param {Array<z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS>} properties=[z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS.NAME, z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS.USERNAME] - list of properties that will be matched against the search term
   *    the order of the properties in the array indicates the priorities by which results will be sorted
   * @returns {Array<z.entity.User>} the filtered list of users
   */
  searchUserInSet(term, userEntities, properties) {
    if (term === '') {
      return userEntities;
    }
    properties = properties || [
      SearchRepository.CONFIG.SEARCHABLE_FIELDS.NAME,
      SearchRepository.CONFIG.SEARCHABLE_FIELDS.USERNAME,
    ];

    const weightedResults = userEntities.reduce((results, userEntity) => {
      const matchWeight = properties
        .slice()
        .reverse()
        .reduce((weight, property, index) => {
          const propertyWeight = 10 * index + 1;
          const propertyMatchWeight = this._matches(term, property, userEntity);
          return weight + propertyMatchWeight * propertyWeight;
        }, 0);

      return matchWeight === 0 ? results : results.concat({user: userEntity, weight: matchWeight});
    }, []);

    return weightedResults
      .slice()
      .sort((result1, result2) => {
        if (result2.weight === result1.weight) {
          return result2.user.name() > result1.user.name() ? -1 : 1;
        }
        return result2.weight - result1.weight;
      })
      .map(result => result.user);
  }

  _matches(term, property, userEntity) {
    const excludedEmojis = Array.from(term).reduce((emojis, char) => {
      const isEmoji = z.util.EmojiUtil.UNICODE_RANGES.includes(char);
      return isEmoji ? Object.assign({}, emojis, {[char]: char}) : emojis;
    }, {});
    const value = ko.unwrap(userEntity[property]) || '';

    const isStrictMatch = value.toLowerCase().startsWith(term.toLowerCase());
    if (isStrictMatch) {
      // if the pattern matches the raw text, give the maximum value to the match
      return 100;
    }
    const isStrictTransliteratedMatch = z.util.StringUtil.compareTransliteration(value, term, excludedEmojis, true);
    if (isStrictTransliteratedMatch) {
      // give a little less points if the pattern strictly matches the transliterated string
      return 50;
    }
    const isLoosyMatch = z.util.StringUtil.compareTransliteration(value, term, excludedEmojis, false);
    if (!isLoosyMatch) {
      // if the pattern doesn't match loosely, then it's not a match at all
      return 0;
    }

    const tokens = z.util.StringUtil.computeTransliteration(value).split(/-/g);
    // computing the match value by testing all components of the property
    return tokens.reverse().reduce((weight, token, index) => {
      const indexWeight = index + 1;
      let tokenWeight = 0;

      if (z.util.StringUtil.compareTransliteration(token, term, excludedEmojis, true)) {
        tokenWeight = indexWeight * 10;
      } else if (z.util.StringUtil.compareTransliteration(token, term, excludedEmojis, false)) {
        tokenWeight = indexWeight;
      }

      return weight + tokenWeight;
    }, 0);
  }

  /**
   * Search for users on the backend by name.
   * @note We skip a few results as connection changes need a while to reflect on the backend.
   *
   * @param {string} name - Search query
   * @param {boolean} isHandle - Is query a user handle
   * @param {number} [maxResults=SearchRepository.CONFIG.MAX_SEARCH_RESULTS] - Maximum number of results
   * @returns {Promise} Resolves with the search results
   */
  search_by_name(name, isHandle, maxResults = SearchRepository.CONFIG.MAX_SEARCH_RESULTS) {
    const directorySearch = this.searchService
      .getContacts(name, SearchRepository.CONFIG.MAX_DIRECTORY_RESULTS)
      .then(({documents}) => documents.map(match => match.id));

    const searchPromises = [directorySearch];

    if (z.user.UserHandleGenerator.validate_handle(name)) {
      searchPromises.push(this.userRepository.get_user_id_by_handle(name));
    }

    return Promise.all(searchPromises)
      .then(([directoryResults, usernameResult]) => {
        if (usernameResult && !directoryResults.includes(usernameResult)) {
          directoryResults.push(usernameResult);
        }

        return directoryResults;
      })
      .then(userIds => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => {
        return userEntities.filter(userEntity => {
          return !userEntity.is_me && !userEntity.isConnected() && !userEntity.isTeamMember();
        });
      })
      .then(userEntities => {
        if (isHandle) {
          userEntities = userEntities.filter(userEntity => z.util.StringUtil.startsWith(userEntity.username(), name));
        }

        return userEntities
          .sort((userA, userB) => {
            return isHandle
              ? z.util.StringUtil.sortByPriority(userA.username(), userB.username(), name)
              : z.util.StringUtil.sortByPriority(userA.name(), userB.name(), name);
          })
          .slice(0, maxResults);
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.self = z.self || {};

z.self.SelfService = class SelfService {
  static get URL() {
    return {
      SELF: '/self',
    };
  }

  /**
   * Construct a new Self Service.
   * @class z.self.SelfService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.self.SelfService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Delete self user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//deleteUser
   *
   * @param {string} [password] - Self user password to authorize immediate account deletion
   * @returns {Promise} Promise that resolves when account deletion has been initiated
   */
  deleteSelf(password) {
    return this.backendClient.sendJson({
      data: {
        password: password,
      },
      type: 'DELETE',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Get your own user profile.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//self
   * @returns {Promise} Promise that will resolve with the self user
   */
  getSelf() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Get your consents.
   * @returns {Promise} Promise that will resolve with the consents user has given
   */
  getSelfConsent() {
    return this.backendClient
      .sendRequest({
        type: 'GET',
        url: `${SelfService.URL.SELF}/consent`,
      })
      .then(data => data.results);
  }

  /**
   * Update your own user profile.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//updateSelf
   *
   * @param {Object} selfData - Updated user profile information
   * @returns {Promise} Resolves with backend response.
   */
  putSelf(selfData) {
    return this.backendClient.sendJson({
      data: selfData,
      type: 'PUT',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Set a consent value .
   *
   * @param {number} consentType - Type of consent given
   * @param {number} value - Value of consent
   * @param {string} source - Identifier of app from consent
   * @returns {Promise} Promise that will resolve with the self user
   */
  putSelfConsent(consentType, value, source) {
    return this.backendClient.sendJson({
      data: {
        source: source,
        type: consentType,
        value: value,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/consent`,
    });
  }

  /**
   * Change your own user email.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeEmail
   *
   * @param {string} email - New email address for the user
   * @returns {Promise} Promise that resolves when email changing process has been started on backend
   */
  putSelfEmail(email) {
    return this.backendClient.sendJson({
      data: {
        email: email,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/email`,
    });
  }

  /**
   * Change username.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeHandle
   *
   * @param {string} username - New username for the user
   * @returns {Promise} Promise that resolves when username changing process has been started on backend
   */
  putSelfHandle(username) {
    return this.backendClient.sendJson({
      data: {
        handle: username,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/handle`,
    });
  }

  /**
   * Change your locale.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeLocale
   *
   * @param {string} newLocale - Locale to be set
   * @returns {Promise} Promise that resolves when locale has been changed on backend
   */
  putSelfLocale(newLocale) {
    return this.backendClient.sendJson({
      data: {
        locale: newLocale,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/locale`,
    });
  }

  /**
   * Change own user password.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changePassword
   *
   * @param {string} newPassword - New user password
   * @param {string} [oldPassword] - Old password of the user
   * @returns {Promise} Promise that resolves when password has been changed on backend
   */
  putSelfPassword(newPassword, oldPassword) {
    return this.backendClient.sendJson({
      data: {
        new_password: newPassword,
        old_password: oldPassword,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/password`,
    });
  }

  /**
   * Change your phone number.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changePhone
   *
   * @param {string} phoneNumber - Phone number in E.164 format
   * @returns {Promise} Promise that resolves when phone number change process has been started on backend
   */
  putSelfPhone(phoneNumber) {
    return this.backendClient.sendJson({
      data: {
        phone: phoneNumber,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/phone`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.time = z.time || {};

z.time.ServerTimeRepository = class ServerTimeRepository {
  constructor() {
    this.logger = new z.util.Logger('z.time.ServerTimeRepository', z.config.LOGGER.OPTIONS);
    this._timeOffset = undefined;
  }

  computeTimeOffset(serverTimeString) {
    this._timeOffset = new Date() - new Date(serverTimeString);
    this.logger.info(`Current backend time is '${serverTimeString}'. Time offset updated to '${this._timeOffset}' ms`);
  }

  getTimeOffset() {
    if (this._timeOffset === undefined) {
      this.logger.warn('Trying to get server/client time offset, but no server time has been set.');
      return 0;
    }
    return this._timeOffset;
  }

  /**
   * Converts a local timestamp to a server timestamp.
   * @param {number} [localTimestamp = Date.now()] - the local timestamp to convert
   * @returns {number} serverTimestamp - the timestamp adjusted with the client/server time shift
   */
  toServerTimestamp(localTimestamp = Date.now()) {
    return localTimestamp - this.getTimeOffset();
  }

  /**
   * Converts a server timestamp to a local timestamp.
   * @param {number} [serverTimestamp = Date.now()] - the server timestamp to convert
   * @returns {number} localTimestamp - the timestamp adjusted with the client/server time shift
   */
  toLocalTimestamp(serverTimestamp = Date.now()) {
    return serverTimestamp + this.getTimeOffset();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamEntity = class TeamEntity {
  constructor(id) {
    this.creator = undefined;
    this.icon = '';
    this.iconKey = undefined;
    this.members = ko.observableArray([]);
    this.id = id;
    this.name = ko.observable('');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamMapper = class TeamMapper {
  constructor() {
    this.logger = new z.util.Logger('z.team.TeamMapper', z.config.LOGGER.OPTIONS);
  }

  mapTeamFromObject(data) {
    return this.updateTeamFromObject(data);
  }

  updateTeamFromObject(teamData, teamEntity = new z.team.TeamEntity()) {
    if (teamData) {
      const {creator, icon, icon_key: iconKey, id, name} = teamData;

      if (creator) {
        teamEntity.creator = creator;
      }

      if (icon) {
        teamEntity.icon = icon;
      }

      if (iconKey) {
        teamEntity.iconKey = iconKey;
      }

      if (id) {
        teamEntity.id = id;
      }

      if (name) {
        teamEntity.name(name);
      }

      return teamEntity;
    }
  }

  mapMemberFromArray(membersData) {
    return membersData.map(data => this.updateMemberFromObject(data));
  }

  mapMemberFromObject(data) {
    return this.updateMemberFromObject(data);
  }

  mapRole(userEntity, permissions) {
    if (permissions) {
      const teamRole = z.team.TeamRole.checkRole(permissions);
      this.logger.info(`Identified user '${userEntity.id}' as '${teamRole}'`, permissions);
      userEntity.teamRole(teamRole);
    }
  }

  updateMemberFromObject(memberData, memberEntity = new z.team.TeamMemberEntity()) {
    if (memberData) {
      const {permissions, user} = memberData;
      if (permissions) {
        memberEntity.permissions = permissions;
      }

      if (user) {
        memberEntity.userId = user;
      }

      return memberEntity;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamMemberEntity = class TeamMemberEntity {
  constructor() {
    this.permissions = undefined;
    this.userId = undefined;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamPermission = (() => {
  const _permissionsForRole = teamRole => {
    switch (teamRole) {
      case z.team.TeamRole.ROLE.OWNER: {
        return _combinePermissions([
          _permissionsForRole(z.team.TeamRole.ROLE.ADMIN),
          PERMISSION.DELETE_TEAM,
          PERMISSION.GET_BILLING,
          PERMISSION.SET_BILLING,
        ]);
      }
      case z.team.TeamRole.ROLE.ADMIN: {
        return _combinePermissions([
          _permissionsForRole(z.team.TeamRole.ROLE.MEMBER),
          PERMISSION.ADD_TEAM_MEMBER,
          PERMISSION.REMOVE_TEAM_MEMBER,
          PERMISSION.SET_MEMBER_PERMISSIONS,
          PERMISSION.SET_TEAM_DATA,
        ]);
      }
      case z.team.TeamRole.ROLE.MEMBER: {
        return _combinePermissions([
          PERMISSION.ADD_CONVERSATION_MEMBER,
          PERMISSION.CREATE_CONVERSATION,
          PERMISSION.DELETE_CONVERSATION,
          PERMISSION.GET_MEMBER_PERMISSIONS,
          PERMISSION.GET_TEAM_CONVERSATIONS,
          PERMISSION.REMOVE_CONVERSATION_MEMBER,
        ]);
      }
      default: {
        return 0;
      }
    }
  };

  const _combinePermissions = permissions => {
    let result = 0;
    for (const permission of permissions) {
      result = result | permission;
    }
    return result;
  };

  const _hasPermissionForRole = (memberPermissions, role) => {
    const rolePermissions = _permissionsForRole(role);
    return _hasPermission(memberPermissions, rolePermissions);
  };

  const _hasPermission = (memberPermissions, expectedPermissions) => {
    if (Number.isSafeInteger(memberPermissions) && memberPermissions > 0) {
      return (memberPermissions & expectedPermissions) === expectedPermissions;
    }
    return false;
  };

  /**
   * Enum for different team permissions.
   * @returns {z.team.TeamPermission.PERMISSION} Enum of team permissions
   */
  const PERMISSION = {
    ADD_CONVERSATION_MEMBER: 1 << 4,
    ADD_TEAM_MEMBER: 1 << 2,
    CREATE_CONVERSATION: 1 << 0,
    DELETE_CONVERSATION: 1 << 1,
    DELETE_TEAM: 1 << 11,
    GET_BILLING: 1 << 6,
    GET_MEMBER_PERMISSIONS: 1 << 9,
    GET_TEAM_CONVERSATIONS: 1 << 10,
    NONE: 0,
    REMOVE_CONVERSATION_MEMBER: 1 << 5,
    REMOVE_TEAM_MEMBER: 1 << 3,
    SET_BILLING: 1 << 7,
    SET_MEMBER_PERMISSIONS: 1 << 12,
    SET_TEAM_DATA: 1 << 8,
  };

  return {
    PERMISSION: PERMISSION,
    hasPermission: _hasPermission,
    hasPermissionForRole: _hasPermissionForRole,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamRepository = class TeamRepository {
  /**
   * Construct a new Team Repository.
   * @class z.team.TeamRepository
   *
   * @param {z.team.TeamService} teamService - Backend REST API team service implementation
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(teamService, userRepository) {
    this.logger = new z.util.Logger('z.team.TeamRepository', z.config.LOGGER.OPTIONS);

    this.teamMapper = new z.team.TeamMapper();
    this.teamService = teamService;
    this.userRepository = userRepository;

    this.selfUser = this.userRepository.self;

    this.team = ko.observable();

    this.isTeam = ko.pureComputed(() => (this.team() ? !!this.team().id : false));

    this.teamMembers = ko.pureComputed(() => (this.isTeam() ? this.team().members() : []));
    this.teamName = ko.pureComputed(() => (this.isTeam() ? this.team().name() : this.selfUser().name()));
    this.teamSize = ko.pureComputed(() => (this.isTeam() ? this.teamMembers().length + 1 : 0));
    this.teamUsers = ko.pureComputed(() => {
      return this.teamMembers()
        .concat(this.userRepository.connected_users())
        .filter((item, index, array) => array.indexOf(item) === index)
        .sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
    });

    this.teamMembers.subscribe(() => this.userRepository.mapGuestStatus());
    this.teamSize.subscribe(teamSize => {
      amplify.publish(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, z.tracking.SuperProperty.TEAM.SIZE, teamSize);
    });

    this.userRepository.isTeam = this.isTeam;
    this.userRepository.teamMembers = this.teamMembers;
    this.userRepository.teamUsers = this.teamUsers;

    amplify.subscribe(z.event.WebApp.TEAM.EVENT_FROM_BACKEND, this.onTeamEvent.bind(this));
    amplify.subscribe(z.event.WebApp.TEAM.UPDATE_INFO, this.sendAccountInfo.bind(this));
  }

  getTeam() {
    const teamPromise = this.selfUser().teamId ? this._getTeamById() : this._getBindingTeam();
    return teamPromise
      .then(teamData => {
        if (teamData) {
          const teamEntity = this.teamMapper.mapTeamFromObject(teamData);
          this.team(teamEntity);
          return this.updateTeamMembers(teamEntity);
        }

        this.team(new z.team.TeamEntity());
      })
      .then(() => this.sendAccountInfo())
      .then(() => this.team());
  }

  getTeamMember(teamId, userId) {
    return this.teamService
      .getTeamMember(teamId, userId)
      .then(memberResponse => this.teamMapper.mapMemberFromObject(memberResponse));
  }

  getTeamMembers(teamId) {
    return this.teamService.getTeamMembers(teamId).then(({members}) => {
      if (members.length) {
        return this.teamMapper.mapMemberFromArray(members);
      }
    });
  }

  getWhitelistedServices(teamId, size, prefix) {
    return this.teamService.getWhitelistedServices(teamId, size, prefix).then(({services: servicesData}) => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  /**
   * Listener for incoming team events.
   *
   * @param {Object} eventJson - JSON data for team event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  onTeamEvent(eventJson, source) {
    const type = eventJson.type;

    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
    this.logger.info(` Team Event: '${type}' (Source: ${source})`, logObject);

    switch (type) {
      case z.event.Backend.TEAM.CONVERSATION_CREATE:
      case z.event.Backend.TEAM.CONVERSATION_DELETE: {
        this._onUnhandled(eventJson);
        break;
      }
      case z.event.Backend.TEAM.DELETE: {
        this._onDelete(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_JOIN: {
        this._onMemberJoin(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_LEAVE: {
        this._onMemberLeave(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_UPDATE: {
        this._onMemberUpdate(eventJson);
        break;
      }
      case z.event.Backend.TEAM.UPDATE: {
        this._onUpdate(eventJson);
        break;
      }
      default: {
        this._onUnhandled(eventJson);
      }
    }
  }

  sendAccountInfo() {
    if (z.util.Environment.desktop) {
      const imageResource = this.isTeam() ? undefined : this.selfUser().previewPictureResource();
      const imagePromise = imageResource ? imageResource.load() : Promise.resolve();

      imagePromise
        .then(imageBlob => {
          if (imageBlob) {
            return z.util.loadDataUrl(imageBlob);
          }
        })
        .then(imageDataUrl => {
          const accountInfo = {
            accentID: this.selfUser().accent_id(),
            name: this.teamName(),
            picture: imageDataUrl,
            teamID: this.team().id,
            teamRole: this.selfUser().teamRole(),
            userID: this.selfUser().id,
          };

          this.logger.info('Publishing account info', accountInfo);
          amplify.publish(z.event.WebApp.TEAM.INFO, accountInfo);
        });
    }
  }

  updateTeamMembers(teamEntity) {
    return this.getTeamMembers(teamEntity.id)
      .then(teamMembers => {
        const memberIds = teamMembers
          .filter(memberEntity => {
            const isSelfUser = memberEntity.userId === this.selfUser().id;

            if (isSelfUser) {
              this.teamMapper.mapRole(this.selfUser(), memberEntity.permissions);
            }

            return !isSelfUser;
          })
          .map(memberEntity => memberEntity.userId);

        return this.userRepository.get_users_by_id(memberIds);
      })
      .then(userEntities => teamEntity.members(userEntities));
  }

  _addUserToTeam(userEntity) {
    const members = this.team().members;

    if (!members().find(member => member.id === userEntity.id)) {
      members.push(userEntity);
    }
  }

  _getTeamById() {
    return this.teamService.getTeamById(this.selfUser().teamId);
  }

  _getBindingTeam() {
    return this.teamService.getTeams().then(({teams}) => {
      const [team] = teams;
      if (team && team.binding) {
        return team;
      }
    });
  }

  _onDelete({team: teamId}) {
    if (this.isTeam() && this.team().id === teamId) {
      window.setTimeout(() => {
        amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED, true);
      }, 50);
    }
  }

  _onMemberJoin(eventJson) {
    const {
      data: {user: userId},
      team: teamId,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;
    const isOtherUser = this.selfUser().id !== userId;

    if (isLocalTeam && isOtherUser) {
      this.userRepository.get_user_by_id(userId).then(userEntity => this._addUserToTeam(userEntity));
    }
  }

  _onMemberLeave(eventJson) {
    const {
      data: {user: userId},
      team: teamId,
      time,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;

    if (isLocalTeam) {
      const isSelfUser = this.selfUser().id === userId;
      if (isSelfUser) {
        return this._onDelete(eventJson);
      }

      this.team().members.remove(member => member.id === userId);
      amplify.publish(z.event.WebApp.TEAM.MEMBER_LEAVE, teamId, userId, new Date(time).toISOString());
    }
  }

  _onMemberUpdate(eventJson) {
    const {
      data: {user: userId},
      permissions,
      team: teamId,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;
    const isSelfUser = this.selfUser().id === userId;

    if (isLocalTeam && isSelfUser) {
      const memberPromise = permissions ? Promise.resolve({permissions}) : this.getTeamMember(teamId, userId);

      memberPromise
        .then(memberEntity => this.teamMapper.mapRole(this.selfUser(), memberEntity.permissions))
        .then(() => this.sendAccountInfo());
    }
  }

  _onUnhandled(eventJson) {
    this.logger.log(`Received '${eventJson.type}' event from backend which is not yet handled`, eventJson);
  }

  _onUpdate(eventJson) {
    const {data: teamData, team: teamId} = eventJson;

    if (this.team().id === teamId) {
      this.teamMapper.updateTeamFromObject(teamData, this.team());
      this.sendAccountInfo();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamRole = (() => {
  const ROLE = {
    ADMIN: 'z.team.TeamRole.ROLE.ADMIN',
    INVALID: 'z.team.TeamRole.ROLE.INVALID',
    MEMBER: 'z.team.TeamRole.ROLE.MEMBER',
    NONE: 'z.team.TeamRole.ROLE.NONE',
    OWNER: 'z.team.TeamRole.ROLE.OWNER',
  };

  const _checkRole = permissions => {
    if (!permissions) {
      throw new z.error.TeamError(z.error.TeamError.TYPE.NO_PERMISSIONS);
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.OWNER)) {
      return ROLE.OWNER;
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.ADMIN)) {
      return ROLE.ADMIN;
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.MEMBER)) {
      return ROLE.MEMBER;
    }

    return ROLE.INVALID;
  };

  return {
    ROLE: ROLE,
    checkRole: _checkRole,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamService = class TeamService {
  static get URL() {
    return {
      TEAMS: '/teams',
    };
  }

  /**
   * Construct a new Team Service.
   * @class z.user.TeamService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.team.TeamService', z.config.LOGGER.OPTIONS);
  }

  getTeamById(teamId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}`,
    });
  }

  getTeamMember(teamId, userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/members/${userId}`,
    });
  }

  getTeamMembers(teamId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/members`,
    });
  }

  getTeams(limit = 100, teamIds) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: teamIds,
      },
      type: 'GET',
      url: TeamService.URL.TEAMS,
    });
  }

  getWhitelistedServices(teamId, size = 100, prefix) {
    return this.backendClient.sendRequest({
      data: {
        prefix,
        size,
      },
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/services/whitelisted`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitStatistics = class AppInitStatistics {
  static get CONFIG() {
    return {
      LOG_LENGTH_KEY: 17,
      LOG_LENGTH_VALUE: 11,
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.telemetry.app_init.AppInitStatistics', z.config.LOGGER.OPTIONS);

    amplify.subscribe(z.event.WebApp.TELEMETRY.BACKEND_REQUESTS, this.update_backend_requests.bind(this));
  }

  add(statistic, value, bucket_size) {
    if (bucket_size && _.isNumber(value)) {
      const buckets = Math.floor(value / bucket_size) + (value % bucket_size ? 1 : 0);

      return (this[statistic] = value === 0 ? 0 : bucket_size * buckets);
    }

    return (this[statistic] = value);
  }

  get() {
    const statistics = {};

    Object.entries(this).forEach(([key, value]) => {
      if (_.isNumber(value) || _.isString(value)) {
        statistics[key] = value;
      }
    });

    return statistics;
  }

  log() {
    this.logger.debug('App initialization statistics');

    Object.entries(this).forEach(([key, value]) => {
      if (_.isNumber(value) || _.isString(value)) {
        const placeholderKeyLength = Math.max(AppInitStatistics.CONFIG.LOG_LENGTH_KEY - key.length, 1);
        const placeholderKey = new Array(placeholderKeyLength).join(' ');
        const placeholderValueLength = Math.max(AppInitStatistics.CONFIG.LOG_LENGTH_VALUE - value.toString().length, 1);
        const placeholderValue = new Array(placeholderValueLength).join(' ');

        this.logger.info(`${placeholderKey}'${key}':${placeholderValue}${value}`);
      }
    });
  }

  update_backend_requests(number_of_requests) {
    this[z.telemetry.app_init.AppInitStatisticsValue.BACKEND_REQUESTS] = number_of_requests;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitStatisticsValue = {
  BACKEND_REQUESTS: 'backend_requests',
  CLIENT_TYPE: 'client_type',
  CLIENTS: 'clients',
  CONNECTIONS: 'connections',
  CONVERSATIONS: 'conversations',
  NOTIFICATIONS: 'notifications',
  SESSIONS: 'sessions',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitTelemetry = class AppInitTelemetry {
  constructor() {
    this.logger = new z.util.Logger('z.telemetry.app_init.AppInitTelemetry', z.config.LOGGER.OPTIONS);
    this.timings = new z.telemetry.app_init.AppInitTimings();
    this.statistics = new z.telemetry.app_init.AppInitStatistics();
  }

  add_statistic(statistic, value, bucket_size) {
    return this.statistics.add(statistic, value, bucket_size);
  }

  get_statistics() {
    return this.statistics.get();
  }

  get_timings() {
    return this.timings.get();
  }

  log_statistics() {
    return this.statistics.log();
  }

  log_timings() {
    return this.timings.log();
  }

  report() {
    const statistics = this.get_statistics();

    statistics.loading_time = this.timings.get_app_load();
    statistics.app_version = z.util.Environment.version(false);
    this.logger.debug('App initialization telemetry');
    this.logger.info(`App version '${statistics.app_version}' initialized within ${statistics.loading_time}s`);
    this.log_statistics();
    this.log_timings();

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.TELEMETRY.APP_INITIALIZATION, statistics);
  }

  time_step(step) {
    return this.timings.time_step(step);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitTimings = class AppInitTimings {
  static get CONFIG() {
    return {
      BUCKET_SIZE: 10,
      LOG_LENGTH_KEY: 27,
      LOG_LENGTH_VALUE: 6,
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.telemetry.AppInitTimings', z.config.LOGGER.OPTIONS);
    this.init = window.performance.now();
  }

  get() {
    const timings = {};

    Object.entries(this).forEach(([key, value]) => {
      if (key.toString() !== 'init' && _.isNumber(value)) {
        timings[key] = value;
      }
    });

    return timings;
  }

  get_app_load() {
    const CONFIG = AppInitTimings.CONFIG;
    const appLoaded = this[z.telemetry.app_init.AppInitTimingsStep.APP_LOADED];
    const appLoadedInSeconds = appLoaded / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;

    return (Math.floor(appLoadedInSeconds / CONFIG.BUCKET_SIZE) + 1) * CONFIG.BUCKET_SIZE;
  }

  log() {
    this.logger.debug('App initialization step durations');

    Object.entries(this).forEach(([key, value]) => {
      if (key.toString() !== 'init' && _.isNumber(value)) {
        const placeholderKeyLength = Math.max(AppInitTimings.CONFIG.LOG_LENGTH_KEY - key.length, 1);
        const placeholderKey = new Array(placeholderKeyLength).join(' ');
        const placeholderValueLength = Math.max(AppInitTimings.CONFIG.LOG_LENGTH_VALUE - value.toString().length, 1);
        const placeholderValue = new Array(placeholderValueLength).join(' ');

        this.logger.info(`${placeholderKey}'${key}':${placeholderValue}${value}ms`);
      }
    });
  }

  time_step(step) {
    if (!this[step]) {
      return (this[step] = window.parseInt(window.performance.now() - this.init));
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

/* eslint-disable sort-keys */

z.telemetry.app_init.AppInitTimingsStep = {
  RECEIVED_ACCESS_TOKEN: 'received_access_token',
  RECEIVED_SELF_USER: 'received_self_user',
  INITIALIZED_CRYPTOGRAPHY: 'initialized_cryptography',
  VALIDATED_CLIENT: 'validated_client',
  RECEIVED_USER_DATA: 'received_user_data',
  UPDATED_FROM_NOTIFICATIONS: 'updated_from_notifications',
  APP_PRE_LOADED: 'app_pre_loaded',
  APP_LOADED: 'app_loaded',
  UPDATED_CONVERSATIONS: 'updated_conversations',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupSteps = {
  ICE_CONNECTION_CONNECTED: 'ice_connection_connected',
  ICE_GATHERING_COMPLETED: 'ice_gathering_completed',
  LOCAL_SDP_SEND: 'local_sdp_send',
  LOCAL_SDP_SET: 'local_sdp_set',
  PEER_CONNECTION_CREATED: 'peer_connection_created',
  REMOTE_SDP_SET: 'remote_sdp_set',
  STARTED: 'started',
  STREAM_RECEIVED: 'stream_received',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupStepsOrder = {
  ANSWER: [
    z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED,
    z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED,
    z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND,
    z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED,
  ],
  OFFER: [
    z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED,
    z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND,
    z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupTimings = class CallSetupTimings {
  constructor(call_id) {
    this.get = this.get.bind(this);
    this.log = this.log.bind(this);
    this.call_id = call_id;

    this.logger = new z.util.Logger('z.telemetry.calling.CallSetupTimings', z.config.LOGGER.OPTIONS);

    this.is_answer = false;
    this.flowId = undefined;

    this.started = window.performance.now();
    this.stream_requested = 0;
    this.stream_received = 0;
    this.state_put = 0;
    this.flow_received = 0;
    this.peer_connection_created = 0;
    this.remote_sdp_received = 0;
    this.remote_sdp_set = 0;
    this.local_sdp_created = 0;
    this.local_sdp_send = 0;
    this.local_sdp_set = 0;
    this.ice_gathering_started = 0;
    this.ice_gathering_completed = 0;
    this.ice_connection_checking = 0;
    this.ice_connection_connected = 0;
    this.ice_connection_completed = 0;
  }

  get() {
    const timings = {};

    this._steps_order().forEach(step => {
      timings[step] = this[step];
    });

    return timings;
  }

  time_step(step) {
    if (this[step] === 0) {
      this[step] = window.parseInt(window.performance.now() - this.started);
    }
  }

  log() {
    this.logger.info(`Call setup duration for flow ID '${this.flowId}' of call ID '${this.call_id}'`);

    this._steps_order().forEach(step => {
      if (this.hasOwnProperty(step)) {
        const placeholder_key = Array.from(Math.max(26 - step.length, 1)).join(' ');
        const placeholder_value = Array.from(Math.max(6 - this[step].toString().length, 1)).join(' ');

        this.logger.info(`Step${placeholder_key}'${step}':${placeholder_value}${this[step]}ms`);
      }
    });
  }

  _steps_order() {
    return this.is_answer
      ? z.telemetry.calling.CallSetupStepsOrder.ANSWER
      : z.telemetry.calling.CallSetupStepsOrder.OFFER;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.FlowTelemetry = class FlowTelemetry {
  /**
   * Construct new flow telemetry entity.
   *
   * @param {string} id - Flow ID
   * @param {string} remote_user_id - Remote user ID
   * @param {z.calling.entities.CallEntity} call_et - Call entity
   * @param {CallSetupTimings} timings - Timings of call setup steps
   */
  constructor(id, remote_user_id, call_et, timings) {
    this.id = id;
    this.remote_user_id = remote_user_id;
    this.call_et = call_et;

    const loggerId = this.id.substr(0, 8);
    const loggerTimestamp = new Date().getMilliseconds();
    const loggerName = `z.telemetry.calling.FlowTelemetry - ${loggerId} (${loggerTimestamp})`;
    this.logger = new z.util.Logger(loggerName, z.config.LOGGER.OPTIONS);
    this.is_answer = false;
    this.peer_connection = undefined;

    this.timings = $.extend(new z.telemetry.calling.CallSetupTimings(this.id), timings ? timings.get() : {});
  }

  //##############################################################################
  // External misc
  //##############################################################################

  /**
   * Create flow status report for automation.
   * @returns {Object} Report
   */
  create_automation_report() {
    const report = this.create_report();
    report.meta.remote_user_id = this.remote_user_id;
    return report;
  }

  /**
   * Create flow status report.
   * @param {Error} [passed_error] - Optional error to be added to report
   * @returns {Object} Report
   */
  create_report(passed_error) {
    const report = {
      meta: {
        browser_name: z.util.Environment.browser.name,
        browser_version: z.util.Environment.browser.version,
        flow_id: this.id,
        id: this.call_et.id,
        is_answer: this.is_answer,
        session_id: this.call_et.sessionId,
      },
      telemetry: {
        timings: this.get_timings(),
      },
    };

    if (this.peer_connection) {
      report.rtc_peer_connection = {
        ice_connection_state: this.peer_connection.iceConnectionState,
        ice_gathering_state: this.peer_connection.iceGatheringState,
        signaling_state: this.peer_connection.signalingState,
      };

      const isSignalingStateClosed = this.peer_connection.signalingState === z.calling.rtc.SIGNALING_STATE.CLOSED;
      if (!isSignalingStateClosed) {
        if (this.peer_connection.localDescription) {
          $.extend(report.rtc_peer_connection, {
            local_SDP: this.peer_connection.localDescription.sdp,
            local_SDP_type: this.peer_connection.localDescription.type,
          });
        }

        if (this.peer_connection.remoteDescription) {
          $.extend(report.rtc_peer_connection, {
            remote_SDP: this.peer_connection.remoteDescription.sdp,
            remote_SDP_type: this.peer_connection.remoteDescription.type,
          });
        }
      }
    }

    if (passed_error) {
      report.error = passed_error;
    }

    return report;
  }

  /**
   * Publish call report.
   * @returns {undefined} No return value
   */
  disconnected() {
    amplify.publish(z.event.WebApp.DEBUG.UPDATE_LAST_CALL_STATUS, this.create_report());
  }

  /**
   * Set the PeerConnection on the telemetry.
   * @param {RTCPeerConnection} peer_connection - PeerConnection to be used for telemetry
   * @returns {undefined} No return value
   */
  set_peer_connection(peer_connection) {
    this.peer_connection = peer_connection;
    this.logger.debug('Set or updated PeerConnection for telemetry checks', this.peer_connection);
  }

  /**
   * Update 'is_answer' status of flow.
   * @param {boolean} is_answer - Is the flow an answer
   * @returns {undefined} No return value
   */
  update_is_answer(is_answer) {
    this.is_answer = is_answer;
    this.timings.is_answer = is_answer;
  }

  //##############################################################################
  // Timings
  //##############################################################################

  /**
   * Return the step timings object.
   * @returns {CallSetupTimings} Flow statistics
   */
  get_timings() {
    return this.timings.get();
  }

  /**
   * Time a call setup step.
   * @param {CallSetupSteps} step - Step to time
   * @returns {undefined} No return value
   */
  time_step(step) {
    this.timings.time_step(step);
  }

  //##############################################################################
  // Reporting & Logging
  //##############################################################################

  /**
   * Get full report.
   * @returns {Object} Full automation report
   */
  get_automation_report() {
    return {
      report: this.create_automation_report(),
    };
  }

  /**
   * Log the flow to the browser console.
   * @param {z.calling.entities.ParticipantEntity} participant_et - Call participant
   * @returns {undefined} No return value
   */
  log_status(participant_et) {
    this.logger.force_log(`-- ID: ${this.id}`);

    if (this.remote_user !== undefined) {
      this.logger.force_log(`-- Remote user: ${participant_et.user.name()} (${participant_et.user.id})`);
    }

    this.logger.force_log(`-- User is connected: ${participant_et.isConnected()}`);
    this.logger.force_log(`-- Flow is answer: ${this.is_answer}`);

    if (this.peer_connection) {
      this.logger.force_log(`-- ICE connection: ${this.peer_connection.iceConnectionState}`);
      this.logger.force_log(`-- ICE gathering: ${this.peer_connection.iceGatheringState}`);
    }
  }

  /**
   * Log call timings.
   * @returns {undefined} No return value
   */
  log_timings() {
    this.timings.log();
  }

  /**
   * Report an error to Raygun.
   *
   * @param {string} description - Error description
   * @param {Object} passed_error - Error passed into the report
   * @param {Object} payload - Additional payload for the custom data
   * @returns {undefined} No return value
   */
  report_error(description, passed_error, payload) {
    const custom_data = this.create_report();
    const raygun_error = new Error(description);

    if (passed_error) {
      custom_data.error = passed_error;
      raygun_error.stack = passed_error.stack;
    }

    if (payload) {
      custom_data.payload = payload;
    }

    this.logger.error(description, custom_data);
    Raygun.send(raygun_error, custom_data);
  }

  report_status() {
    const custom_data = this.create_report();
    this.logger.info('Created flow status for call failure report', custom_data);
    return custom_data;
  }

  report_timings() {
    const custom_data = this.timings.log();
    Raygun.send(new Error('Call setup step timings'), custom_data);
    this.logger.info(`Reported setup step timings of flow id '${this.id}' for call analysis`, custom_data);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

// Call traces entity.
z.telemetry.calling.CallTelemetry = class CallTelemetry {
  constructor() {
    this.logger = new z.util.Logger('z.telemetry.calling.CallTelemetry', z.config.LOGGER.OPTIONS);

    this.sessions = {};
    this.remote_version = undefined;
    this.hasToggledAV = false;
    this.maxNumberOfParticipants = 0;
    this.direction = undefined;

    this.mediaType = z.media.MediaType.AUDIO;
  }

  //##############################################################################
  // Sessions
  //##############################################################################

  /**
   * Force log last call session IDs.
   * @returns {Object} Containing all the sessions
   */
  log_sessions() {
    const sortedSessions = z.util.sortObjectByKeys(this.sessions, true);

    this.logger.force_log('Your last session IDs:');
    Object.values(sortedSessions).forEach(trackingInfo => this.logger.force_log(trackingInfo.to_string()));

    return sortedSessions;
  }

  //##############################################################################
  // Error reporting
  //##############################################################################

  /**
   * Report an error to Raygun.
   * @param {string} description - Error description
   * @param {Error} passed_error - Error to be attached to the report
   * @returns {undefined} No return value
   */
  report_error(description, passed_error) {
    let custom_data;
    const raygun_error = new Error(description);

    if (passed_error) {
      custom_data = {error: passed_error};
      raygun_error.stack = passed_error.stack;
    }

    Raygun.send(raygun_error, custom_data);
  }

  //##############################################################################
  // Analytics
  //##############################################################################

  /**
   * Prepare the call telemetry for a new call (resets to initial values)
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @returns {undefined} No return value
   */
  initiateNewCall(direction, mediaType = z.media.MediaType.AUDIO) {
    this.mediaType = mediaType;
    this.hasToggledAV = false;
    this.maxNumberOfParticipants = 0;
    this.direction = direction;
    this.logger.info(`Initiate new '${direction}' call of type '${this.mediaType}'`);
  }

  setAVToggled() {
    this.hasToggledAV = true;
  }

  /**
   * Sets the remove version of the call.
   * @param {string} remote_version - Remove version string
   * @returns {undefined} No return value
   */
  set_remote_version(remote_version) {
    if (this.remote_version !== remote_version) {
      this.remote_version = remote_version;
      this.logger.info(`Identified remote call version as '${remote_version}'`);
    }
  }

  /**
   * Reports call events for call tracking to Localytics.
   * @param {z.tracking.EventName} eventName - String for call event
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {Object} [attributes={}] - Attributes for the event
   * @returns {undefined} No return value
   */
  track_event(eventName, callEntity, attributes = {}) {
    if (callEntity) {
      const {conversationEntity, isGroup} = callEntity;

      const videoTypes = [z.media.MediaType.VIDEO, z.media.MediaType.AUDIO_VIDEO];

      attributes = Object.assign(
        {
          conversation_participants: conversationEntity.getNumberOfParticipants(),
          conversation_participants_in_call_max: this.maxNumberOfParticipants
            ? this.maxNumberOfParticipants
            : undefined,
          conversation_type: isGroup
            ? z.tracking.attribute.ConversationType.GROUP
            : z.tracking.attribute.ConversationType.ONE_TO_ONE,
          direction: this.direction,
          remote_version: [
            z.tracking.EventName.CALLING.ESTABLISHED_CALL,
            z.tracking.EventName.CALLING.JOINED_CALL,
          ].includes(eventName)
            ? this.remote_version
            : undefined,
          started_as_video: videoTypes.includes(this.mediaType),
          with_service: conversationEntity.hasService(),
        },
        z.tracking.helpers.getGuestAttributes(conversationEntity),
        attributes
      );
    }

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, eventName, attributes);
  }

  /**
   * Track the call duration.
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @returns {undefined} No return value
   */
  track_duration(callEntity) {
    const {terminationReason, timerStart, durationTime} = callEntity;

    const duration = Math.floor((Date.now() - timerStart) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    if (!window.isNaN(duration)) {
      this.logger.info(`Call duration: ${duration} seconds.`, durationTime());

      const attributes = {
        AV_switch_toggled: this.hasToggledAV,
        duration: duration,
        reason: terminationReason,
        remote_version: this.remote_version,
      };

      this.track_event(z.tracking.EventName.CALLING.ENDED_CALL, callEntity, attributes);
    }
  }

  numberOfParticipantsChanged(newNumberOfParticipants) {
    this.maxNumberOfParticipants = Math.max(this.maxNumberOfParticipants, newNumberOfParticipants);
  }
};

z.telemetry.calling.CallLogger = class CallLogger {
  static get CONFIG() {
    return {
      MESSAGE_LOG_LENGTH: 10000,
      OBFUSCATION_TRUNCATE_TO: 4,
    };
  }

  static get LOG_LEVEL() {
    return {
      DEBUG: 700,
      ERROR: 1000,
      INFO: 800,
      LEVEL_1: 300,
      LEVEL_2: 400,
      LEVEL_3: 500,
      OFF: 0,
      WARNING: 900,
    };
  }

  static get OBFUSCATED() {
    return {
      FINGERPRINT: 'XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX',
      ICE_PASSWORD: 'XXXXXXXXXXXXXXXXXXXXXXXX',
      IPV4: 'XXX',
      IPV6: 'XXXX:XXXX:XXXX:XXXX',
      KASE_PUBLIC_KEY: 'x-KASEv1:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    };
  }

  static get OBFUSCATION_MODE() {
    return {
      HARD: 'CallLogger.OBFUSCATION_MODE.HARD',
      SOFT: 'CallLogger.OBFUSCATION_MODE.SOFT',
    };
  }

  static get REGEXES() {
    return {
      // From https://github.com/sindresorhus/ip-regex/blob/master/index.js
      IPV4: /(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}/gm,
      IPV6: /((?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(:[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(:[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(:[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(:[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,6}|:)|(?::((?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(%[0-9a-zA-Z]{1,})?/gm,
      UUID: /([0-9a-f]{8})-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gm,
    };
  }

  constructor(name, id, options, messageLog) {
    name = id ? this._createName(name, id) : name;

    this.logger = new z.util.Logger(name, options);
    this.levels = this.logger.levels;

    this.messageLog = messageLog;
    this.name = name;
    this.options = options;

    this.obfuscationMode = CallLogger.OBFUSCATION_MODE.SOFT;
  }

  obfuscate(string) {
    if (string) {
      if (this._isHardObfuscationMode()) {
        return CryptoJS.SHA256(string)
          .toString()
          .substr(0, CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
      }

      return string.substr(0, CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
    }
  }

  obfuscateSdp(sdpMessage) {
    if (!sdpMessage || !window.sdpTransform) {
      return '[Unknown]';
    }

    const decodedSdpMessage = window.sdpTransform.parse(sdpMessage);

    decodedSdpMessage.media.forEach(({fingerprint, icePwd, invalid}, index) => {
      // Remove fingerprints
      const hasFingerprintHash = fingerprint && fingerprint.hash;
      if (hasFingerprintHash) {
        decodedSdpMessage.media[index].fingerprint.hash = CallLogger.OBFUSCATED.FINGERPRINT;
      }

      // Remove ice password
      const hasIcePassword = !!icePwd;
      if (hasIcePassword) {
        decodedSdpMessage.media[index].icePwd = CallLogger.OBFUSCATED.ICE_PASSWORD;
      }

      // Remove KASE public key (for receiving side)
      const hasInvalid = !!invalid;
      if (hasInvalid) {
        invalid.forEach(({value}, invalidIndex) => {
          if (value.startsWith('x-KASEv1')) {
            decodedSdpMessage.media[index].invalid[invalidIndex].value = CallLogger.OBFUSCATED.KASE_PUBLIC_KEY;
          }
        });
      }
    });

    return window.sdpTransform.write(decodedSdpMessage);
  }

  getDebugType(number) {
    switch (number) {
      case CallLogger.LOG_LEVEL.LEVEL_1:
      case CallLogger.LOG_LEVEL.LEVEL_2:
      case CallLogger.LOG_LEVEL.LEVEL_3: {
        return 'VERBOSE';
      }

      case CallLogger.LOG_LEVEL.DEBUG: {
        return 'DEBUG';
      }

      case CallLogger.LOG_LEVEL.INFO: {
        return 'INFO';
      }

      case CallLogger.LOG_LEVEL.WARNING: {
        return 'INFO';
      }

      case CallLogger.LOG_LEVEL.ERROR: {
        return 'ERROR';
      }
    }
  }

  logToMemory(logLevel, obfuscatedMessage) {
    while (this.messageLog.length >= CallLogger.CONFIG.MESSAGE_LOG_LENGTH) {
      this.messageLog.shift();
    }

    const shouldLogToMemory = logLevel !== CallLogger.LOG_LEVEL.OFF;
    if (shouldLogToMemory) {
      const logType = this.getDebugType(logLevel);
      let logMessage = `[${new Date().toISOString()}] [${this.name}] (${logType}) ${obfuscatedMessage}`;
      logMessage = this.safeGuard(logMessage);
      this.messageLog.push(logMessage);
    }
  }

  _createName(name, id) {
    return `${name} - ${this.obfuscate(id)} (${new Date().getMilliseconds()})`;
  }

  _isHardObfuscationMode() {
    return this.obfuscationMode === CallLogger.OBFUSCATION_MODE.HARD;
  }

  debug() {
    this._log([this.logger.levels.DEBUG].concat(...arguments));
  }

  error() {
    this._log([this.logger.levels.ERROR].concat(...arguments));
  }

  info() {
    this._log([this.logger.levels.INFO].concat(...arguments));
  }

  warn() {
    this._log([this.logger.levels.WARN].concat(...arguments));
  }

  log(logLevel) {
    if (typeof logLevel === 'function') {
      return this._log(arguments);
    }
    this._log([this.logger.levels.INFO].concat(...arguments));
  }

  _log(args) {
    // Use obfuscated format for call logs if possible
    const [firstArgument, secondArgument] = args;
    const isLogMessageObject = typeof secondArgument === 'object';
    if (isLogMessageObject) {
      const {message, data} = secondArgument;

      const isExpectedObjectStructure = typeof message === 'string' && typeof data === 'object';
      if (isExpectedObjectStructure) {
        const defaultMessage = z.util.StringUtil.format(message, ...data.default);
        const obfuscatedMessage = z.util.StringUtil.format(message, ...data.obfuscated);
        args[1] = defaultMessage;

        this.logToMemory(firstArgument(), obfuscatedMessage);
        return this.logger.log(...args);
      }
    }

    const hasMultipleArgs = args.length > 1;
    const logLevel = hasMultipleArgs ? firstArgument() : CallLogger.LOG_LEVEL.INFO;
    const logMessage = hasMultipleArgs ? secondArgument : firstArgument;
    this.logToMemory(logLevel, logMessage);
    this.logger.log(...args);
  }

  safeGuard(message) {
    // Ensure UUID are properly obfuscated
    message = message.replace(CallLogger.REGEXES.UUID, match => this.obfuscate(match));

    // Obfuscate IP addresses
    message = message.replace(CallLogger.REGEXES.IPV4, ip => {
      ip = ip.split('.');
      ip[ip.length - 1] = CallLogger.OBFUSCATED.IPV4;
      ip[ip.length - 2] = CallLogger.OBFUSCATED.IPV4;
      return ip.join('.');
    });
    message = message.replace(CallLogger.REGEXES.IPV6, ip => {
      ip = ip.split(':').slice(0, 3);
      return [...ip, CallLogger.OBFUSCATED.IPV6].join(':');
    });

    return message;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.AvailabilityMapper = (() => {
  const AVAILABILITY_VALUES = {
    AVAILABLE: 'available',
    AWAY: 'away',
    BUSY: 'busy',
    NONE: 'none',
  };

  const valueFromType = availabilityType => {
    const TYPE_VALUES = {
      [z.user.AvailabilityType.AVAILABLE]: AVAILABILITY_VALUES.AVAILABLE,
      [z.user.AvailabilityType.AWAY]: AVAILABILITY_VALUES.AWAY,
      [z.user.AvailabilityType.BUSY]: AVAILABILITY_VALUES.BUSY,
      [z.user.AvailabilityType.NONE]: AVAILABILITY_VALUES.NONE,
    };

    const value = TYPE_VALUES[availabilityType];
    if (value) {
      return value;
    }
    throw new z.error.UserError(z.error.BaseError.TYPE.INVALID_PARAMETER);
  };

  return {
    nameFromType: availabilityType => {
      const TYPE_STRING_IDS = {
        [z.user.AvailabilityType.AVAILABLE]: z.string.userAvailabilityAvailable,
        [z.user.AvailabilityType.AWAY]: z.string.userAvailabilityAway,
        [z.user.AvailabilityType.BUSY]: z.string.userAvailabilityBusy,
        [z.user.AvailabilityType.NONE]: z.string.userAvailabilityNone,
      };

      const stringId = TYPE_STRING_IDS[availabilityType];
      if (stringId) {
        return z.l10n.text(stringId);
      }
      throw new z.error.UserError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    },
    protoFromType: availabilityType => {
      const typeValue = valueFromType(availabilityType).toUpperCase();
      return z.proto.Availability.Type[typeValue];
    },
    valueFromType,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

/**
 * Enum for different user availability types.
 * @type {z.user.AvailabilityType} Enum of availability types
 */
z.user.AvailabilityType = {
  AVAILABLE: 1,
  AWAY: 2,
  BUSY: 3,
  NONE: 0,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.ConsentType = {
  MARKETING: 2,
  TERMS_OF_USE: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.ConsentValue = {
  GIVEN: 1,
  NOT_GIVEN: 0,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserService = class UserService {
  static get URL() {
    return {
      PASSWORD_RESET: '/password-reset',
      USERS: '/users',
    };
  }

  /**
   * Construct a new User Service.
   * @class z.user.UserService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.user.UserService', z.config.LOGGER.OPTIONS);
    this.storageService = storageService;

    this.USER_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.USERS;
  }

  //##############################################################################
  // Database interactions
  //##############################################################################

  /**
   * Loads user states from the local database.
   * @returns {Promise} Resolves with all the stored user states
   */
  loadUserFromDb() {
    return this.storageService.getAll(this.USER_STORE_NAME);
  }

  /**
   * Saves a user entity in the local database.
   * @param {User} userEntity - User entity
   * @returns {Promise} Resolves with the conversation entity
   */
  saveUserInDb(userEntity) {
    const userData = userEntity.serialize();

    return this.storageService.save(this.USER_STORE_NAME, userEntity.id, userData).then(primaryKey => {
      this.logger.info(`State of user '${primaryKey}' was stored`, userData);
      return userEntity;
    });
  }

  //##############################################################################
  // Backend interactions
  //##############################################################################

  /**
   * Check if a username exists.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/checkUserHandle
   *
   * @param {string} username - Username
   * @returns {Promise} Resolves with backend response.
   */
  checkUserHandle(username) {
    return this.backendClient.sendRequest({
      type: 'HEAD',
      url: `${UserService.URL.USERS}/handles/${username}`,
    });
  }

  getUserByHandle(username) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${UserService.URL.USERS}/handles/${username}`,
    });
  }

  /**
   * Get a set of users for the given usernames.
   *
   * @example ['0bb84213-8cc2-4bb1-9e0b-b8dd522396d5', '15ede065-72b3-433a-9917-252f076ed031']
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/checkUserHandles
   *
   * @param {array} usernames - List of usernames
   * @param {number} amount - amount of usernames to return
   * @returns {Promise} Resolves with backend response.
   */
  checkUserHandles(usernames, amount = 1) {
    return this.backendClient.sendJson({
      data: {
        handles: usernames,
        return: amount,
      },
      type: 'POST',
      url: `${UserService.URL.USERS}/handles`,
    });
  }

  /**
   * Get a set of users.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/users
   * @example ['0bb84213-8cc2-4bb1-9e0b-b8dd522396d5', '15ede065-72b3-433a-9917-252f076ed031']
   *
   * @param {Array<string>} userIds - ID of users to be fetched
   * @returns {Promise} Resolves with backend response.
   */
  getUsers(userIds) {
    return this.backendClient.sendRequest({
      data: {
        ids: userIds.join(','),
      },
      type: 'GET',
      url: UserService.URL.USERS,
    });
  }

  /**
   * Get a user by ID.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/user
   *
   * @param {string} userId - User ID
   * @returns {Promise} Resolves with backend response.
   */
  getUser(userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${UserService.URL.USERS}/${userId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserMapper = class UserMapper {
  /**
   * Construct a new User Mapper.
   * @class z.user.UserMapper
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   */
  constructor(serverTimeRepository) {
    this.logger = new z.util.Logger('z.user.UserMapper', z.config.LOGGER.OPTIONS);
    this.serverTimeRepository = serverTimeRepository;
  }

  /**
   * Converts JSON user into user entity.
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  mapUserFromJson(userData) {
    return this.updateUserFromObject(new z.entity.User(), userData);
  }

  /**
   * Converts JSON self user into user entity.
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  mapSelfUserFromJson(userData) {
    const userEntity = this.updateUserFromObject(new z.entity.User(), userData);
    userEntity.is_me = true;

    if (userData.locale) {
      userEntity.locale = userData.locale;
    }

    return userEntity;
  }

  /**
   * Convert multiple JSON users into user entities.
   * @note Return an empty array in any case to prevent crashes.
   *
   * @param {Array<Object>} usersData - Users data
   * @returns {Array<z.entity.User>} Mapped user entities
   */
  mapUsersFromJson(usersData) {
    if (usersData && usersData.length) {
      return usersData.filter(userData => userData).map(userData => this.mapUserFromJson(userData));
    }
    this.logger.warn('We got no user data from the backend');
    return [];
  }

  /**
   * Maps JSON user into a blank user entity or updates an existing one.
   * @note Mapping of single properties to an existing user happens when the user changes his name or accent color.
   * @param {z.entity.User} userEntity - User entity that the info shall be mapped to
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  updateUserFromObject(userEntity, userData) {
    if (!userData) {
      return;
    }

    // We are trying to update non-matching users
    const isUnexpectedId = userEntity.id !== '' && userData.id !== userEntity.id;
    if (isUnexpectedId) {
      throw new Error(`Updating wrong user entity. User '${userEntity.id}' does not match data '${userData.id}'.`);
    }

    const isNewUser = userEntity.id === '' && userData.id !== '';
    if (isNewUser) {
      userEntity.id = userData.id;
      userEntity.joaatHash = z.util.Crypto.Hashing.joaatHash(userData.id);
    }

    const {
      accent_id: accentId,
      assets,
      email,
      expires_at: expirationDate,
      handle,
      name,
      phone,
      picture,
      service,
      sso_id: ssoId,
      team,
    } = userData;

    if (accentId) {
      userEntity.accent_id(accentId);
    }

    const hasAsset = assets && assets.length;
    const hasPicture = picture && picture.length;
    let mappedAssets;
    if (hasAsset) {
      mappedAssets = z.assets.AssetMapper.mapProfileAssets(userEntity.id, userData.assets);
    } else if (hasPicture) {
      mappedAssets = z.assets.AssetMapper.mapProfileAssetsV1(userEntity.id, userData.picture);
    }
    z.assets.AssetMapper.updateUserEntityAssets(userEntity, mappedAssets);

    if (email) {
      userEntity.email(email);
    }

    if (expirationDate) {
      userEntity.isTemporaryGuest(true);
      const adjustedTimestamp = this.serverTimeRepository.toLocalTimestamp(new Date(expirationDate).getTime());
      userEntity.setGuestExpiration(adjustedTimestamp);
    }

    if (handle) {
      userEntity.username(handle);
    }

    if (name) {
      userEntity.name(name.trim());
    }

    if (phone) {
      userEntity.phone(phone);
    }

    if (service) {
      userEntity.isService = true;
      userEntity.providerId = service.provider;
      userEntity.providerName = ko.observable('');
      userEntity.serviceId = service.id;
    }

    if (ssoId && Object.keys(ssoId).length) {
      userEntity.isSingleSignOn = true;
    }

    if (team) {
      userEntity.inTeam(true);
      userEntity.teamId = team;
    }

    return userEntity;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserRepository = class UserRepository {
  static get CONFIG() {
    return {
      MINIMUM_NAME_LENGTH: 2,
      MINIMUM_PICTURE_SIZE: {
        HEIGHT: 320,
        WIDTH: 320,
      },
      MINIMUM_USERNAME_LENGTH: 2,
    };
  }

  /**
   * Construct a new User repository.
   * @class z.user.UserRepository
   * @param {z.user.UserService} user_service - Backend REST API user service implementation
   * @param {z.assets.AssetService} asset_service - Backend REST API asset service implementation
   * @param {z.self.SelfService} selfService - Backend REST API self service implementation
   * @param {z.client.ClientRepository} client_repository - Repository for all client interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   */
  constructor(user_service, asset_service, selfService, client_repository, serverTimeRepository) {
    this.user_service = user_service;
    this.asset_service = asset_service;
    this.selfService = selfService;
    this.client_repository = client_repository;
    this.logger = new z.util.Logger('z.user.UserRepository', z.config.LOGGER.OPTIONS);

    this.user_mapper = new z.user.UserMapper(serverTimeRepository);
    this.should_set_username = false;

    this.self = ko.observable();
    this.users = ko.observableArray([]);

    this.connect_requests = ko
      .pureComputed(() => {
        return this.users().filter(user_et => user_et.isIncomingRequest());
      })
      .extend({rateLimit: 50});

    this.connected_users = ko
      .pureComputed(() => {
        return this.users()
          .filter(user_et => user_et.isConnected())
          .sort((user_a, user_b) => z.util.StringUtil.sortByPriority(user_a.first_name(), user_b.first_name()));
      })
      .extend({rateLimit: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND});

    this.isActivatedAccount = ko.pureComputed(() => this.self() && !this.self().isTemporaryGuest());
    this.isTemporaryGuest = ko.pureComputed(() => this.self() && this.self().isTemporaryGuest());

    this.isTeam = ko.observable();
    this.teamMembers = undefined;
    this.teamUsers = undefined;

    this.number_of_contacts = ko.pureComputed(() => {
      const contacts = this.isTeam() ? this.teamUsers() : this.connected_users();
      return contacts.filter(user_et => !user_et.isService).length;
    });
    this.number_of_contacts.subscribe(number_of_contacts => {
      amplify.publish(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, z.tracking.SuperProperty.CONTACTS, number_of_contacts);
    });

    this.marketingConsent = ko.observable(false);

    amplify.subscribe(z.event.WebApp.CLIENT.ADD, this.addClientToUser.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.REMOVE, this.remove_client_from_user.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.UPDATE, this.update_clients_from_user.bind(this));
    amplify.subscribe(z.event.WebApp.USER.SET_AVAILABILITY, this.setAvailability.bind(this));
    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.on_user_event.bind(this));
    amplify.subscribe(z.event.WebApp.USER.PERSIST, this.saveUserInDb.bind(this));
    amplify.subscribe(z.event.WebApp.USER.UPDATE, this.updateUserById.bind(this));
  }

  /**
   * Listener for incoming user events.
   *
   * @param {Object} event_json - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  on_user_event(event_json, source) {
    const type = event_json.type;

    const logObject = {eventJson: JSON.stringify(event_json), eventObject: event_json};
    this.logger.info(` User Event: '${type}' (Source: ${source})`, logObject);

    switch (type) {
      case z.event.Backend.USER.DELETE:
        this.user_delete(event_json);
        break;
      case z.event.Backend.USER.UPDATE:
        this.user_update(event_json);
        break;
      case z.event.Client.USER.AVAILABILITY:
        this.onUserAvailability(event_json);
        break;
      default:
    }
  }

  loadUsers() {
    if (this.isTeam()) {
      return this.user_service
        .loadUserFromDb()
        .then(users => {
          if (users.length) {
            this.logger.log(`Loaded state of '${users.length}' users from database`, users);

            const mappingPromises = users.map(user => {
              return this.get_user_by_id(user.id).then(userEntity => userEntity.availability(user.availability));
            });

            return Promise.all(mappingPromises);
          }
        })
        .then(() => this.users().forEach(userEntity => userEntity.subscribeToChanges()));
    }
  }

  /**
   * Persists a conversation state in the database.
   * @param {User} userEntity - User which should be persisted
   * @returns {Promise} Resolves when user was saved
   */
  saveUserInDb(userEntity) {
    return this.user_service.saveUserInDb(userEntity);
  }

  /**
   * Event to delete the matching user.
   * @param {string} id - User ID of deleted user
   * @returns {undefined} No return value
   */
  user_delete({id}) {
    // @todo Add user deletion cases for other users
    const is_self_user = id === this.self().id;
    if (is_self_user) {
      window.setTimeout(() => {
        amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED, true);
      }, 50);
    }
  }

  /**
   * Event to update availability of user.
   * @param {Object} event - Event data
   * @returns {undefined} No return value
   */
  onUserAvailability(event) {
    if (this.isTeam()) {
      const {
        from: userId,
        data: {availability},
      } = event;
      this.get_user_by_id(userId).then(userEntity => userEntity.availability(availability));
    }
  }

  /**
   * Event to update the matching user.
   * @param {Object} user - Update user info
   * @returns {Promise} Resolves wit the updated user entity
   */
  user_update({user}) {
    const is_self_user = user.id === this.self().id;
    const user_promise = is_self_user ? Promise.resolve(this.self()) : this.get_user_by_id(user.id);
    return user_promise.then(user_et => {
      this.user_mapper.updateUserFromObject(user_et, user);

      if (is_self_user) {
        amplify.publish(z.event.WebApp.TEAM.UPDATE_INFO);
      }

      return user_et;
    });
  }

  /**
   * Update users matching the given connections.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connection entities
   * @returns {Promise<Array<z.connection.ConnectionEntity>>} Promise that resolves when all connections have been updated
   */
  updateUsersFromConnections(connectionEntities) {
    const userIds = connectionEntities.map(connectionEntity => connectionEntity.userId);
    return this.get_users_by_id(userIds).then(userEntities => {
      userEntities.forEach(userEntity => {
        const connectionEntity = connectionEntities.find(({userId}) => userId === userEntity.id);
        userEntity.connection(connectionEntity);
      });
      return this._assignAllClients();
    });
  }

  /**
   * Assign all locally stored clients to the users.
   * @private
   * @returns {Promise} Promise that resolves with all user entities where client entities have been assigned to.
   */
  _assignAllClients() {
    return this.client_repository.getAllClientsFromDb().then(recipients => {
      const userIds = Object.keys(recipients);
      this.logger.info(`Found locally stored clients for '${userIds.length}' users`, recipients);

      return this.get_users_by_id(userIds).then(userEntities => {
        userEntities.forEach(userEntity => {
          const clientEntities = recipients[userEntity.id];
          const tooManyClients = clientEntities > 8;
          if (tooManyClients) {
            this.logger.warn(`Found '${clientEntities.length}' clients for '${userEntity.name()}'`, clientEntities);
          }
          userEntity.devices(clientEntities);
        });

        return userEntities;
      });
    });
  }

  /**
   * Saves a new client for the first time to the database and adds it to a user's entity.
   *
   * @param {string} userId - ID of user
   * @param {Object} clientPayload - Payload of client which should be added to user
   * @param {boolean} publishClient - Publish new client
   * @returns {Promise} Promise that resolves when a client and its session have been deleted
   */
  addClientToUser(userId, clientPayload, publishClient = false) {
    return this.get_user_by_id(userId).then(userEntity => {
      const clientEntity = this.client_repository.clientMapper.mapClient(clientPayload, userEntity.is_me);
      const wasClientAdded = userEntity.add_client(clientEntity);

      if (wasClientAdded) {
        return this.client_repository.saveClientInDb(userId, clientEntity.toJson()).then(() => {
          if (publishClient) {
            amplify.publish(z.event.WebApp.USER.CLIENT_ADDED, userId, clientEntity);
          }
        });
      }
    });
  }

  /**
   * Removes a stored client and the session connected with it.
   * @param {string} user_id - ID of user
   * @param {string} client_id - ID of client to be deleted
   * @returns {Promise} Promise that resolves when a client and its session have been deleted
   */
  remove_client_from_user(user_id, client_id) {
    return this.client_repository
      .removeClient(user_id, client_id)
      .then(() => this.get_user_by_id(user_id))
      .then(user_et => {
        user_et.remove_client(client_id);
        amplify.publish(z.event.WebApp.USER.CLIENT_REMOVED, user_id, client_id);
      });
  }

  /**
   * Update clients for given user.
   * @param {string} user_id - ID of user
   * @param {Array<z.client.ClientEntity>} client_ets - Clients which should get updated
   * @returns {undefined} No return value
   */
  update_clients_from_user(user_id, client_ets) {
    this.get_user_by_id(user_id).then(user_et => {
      user_et.devices(client_ets);
      amplify.publish(z.event.WebApp.USER.CLIENTS_UPDATED, user_id, client_ets);
    });
  }

  setAvailability(availability, method) {
    const hasAvailabilityChanged = availability !== this.self().availability();
    const newAvailabilityValue = z.user.AvailabilityMapper.valueFromType(availability);
    if (hasAvailabilityChanged) {
      const oldAvailabilityValue = z.user.AvailabilityMapper.valueFromType(this.self().availability());
      this.logger.log(`Availability was changed from '${oldAvailabilityValue}' to '${newAvailabilityValue}'`);
      this.self().availability(availability);
      this._trackAvailability(availability, method);
    } else {
      this.logger.log(`Availability was again set to '${newAvailabilityValue}'`);
    }

    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoAvailability = new z.proto.Availability(z.user.AvailabilityMapper.protoFromType(availability));
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.AVAILABILITY, protoAvailability);

    amplify.publish(z.event.WebApp.BROADCAST.SEND_MESSAGE, genericMessage);
  }

  /**
   * Track availability action.
   *
   * @param {z.user.AvailabilityType} availability - Type of availability
   * @param {string} method - Method used for availability change
   * @returns {undefined} No return value
   */
  _trackAvailability(availability, method) {
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.CHANGED_STATUS, {
      method: method,
      status: z.user.AvailabilityMapper.valueFromType(availability),
    });
  }

  /**
   * Request account deletion.
   * @returns {Promise} Promise that resolves when account deletion process has been initiated
   */
  delete_me() {
    return this.selfService
      .deleteSelf()
      .then(() => this.logger.info('Account deletion initiated'))
      .catch(error => this.logger.error(`Unable to delete self: ${error}`));
  }

  /**
   * Get a user from the backend.
   * @param {string} userId - User ID
   * @returns {Promise<z.entity.User>} Promise that resolves with the user entity
   */
  _fetchUserById(userId) {
    return this.fetchUsersById([userId]).then(([userEntity]) => userEntity);
  }

  /**
   * Get users from the backend.
   * @param {Array<string>} userIds - User IDs
   * @returns {Promise<Array<z.entity.User>>} Promise that resolves with an array of user entities
   */
  fetchUsersById(userIds = []) {
    userIds = userIds.filter(userId => !!userId);

    if (!userIds.length) {
      return Promise.resolve([]);
    }

    const _getUsers = chunkOfUserIds => {
      return this.user_service
        .getUsers(chunkOfUserIds)
        .then(response => (response ? this.user_mapper.mapUsersFromJson(response) : []))
        .catch(error => {
          const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (isNotFound) {
            return [];
          }
          throw error;
        });
    };

    const chunksOfUserIds = z.util.ArrayUtil.chunk(userIds, z.config.MAXIMUM_USERS_PER_REQUEST);
    return Promise.all(chunksOfUserIds.map(chunkOfUserIds => _getUsers(chunkOfUserIds)))
      .then(resolveArray => {
        const newUserEntities = _.flatten(resolveArray);

        if (this.isTeam()) {
          this.mapGuestStatus(newUserEntities);
        }

        return this.save_users(newUserEntities);
      })
      .then(fetchedUserEntities => {
        // If there is a difference then we most likely have a case with a suspended user
        const isAllUserIds = userIds.length === fetchedUserEntities.length;
        if (!isAllUserIds) {
          fetchedUserEntities = this._add_suspended_users(userIds, fetchedUserEntities);
        }

        return fetchedUserEntities;
      });
  }

  /**
   * Find a local user.
   * @param {string} userId - User ID
   * @returns {Promise<z.entity.User>} Resolves with the matching user entity
   */
  findUserById(userId) {
    if (!userId) {
      return Promise.reject(new z.error.UserError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const matchingUserEntity = this.users().find(userEntity => userEntity.id === userId);
    return matchingUserEntity
      ? Promise.resolve(matchingUserEntity)
      : Promise.reject(new z.error.UserError(z.error.UserError.TYPE.USER_NOT_FOUND));
  }

  /**
   * Get self user from backend.
   * @returns {Promise} Promise that will resolve with the self user entity
   */
  getSelf() {
    return this.selfService
      .getSelf()
      .then(userData => this._upgradePictureAsset(userData))
      .then(response => this.user_mapper.mapSelfUserFromJson(response))
      .then(userEntity => {
        const promises = [this.save_user(userEntity, true), this.getMarketingConsent()];
        return Promise.all(promises).then(() => userEntity);
      })
      .catch(error => {
        this.logger.error(`Unable to load self user: ${error.message || error}`, [error]);
        throw error;
      });
  }

  /**
   * Detects if the user has a profile picture that uses the outdated picture API.
   * Will migrate the picture to the newer assets API if so.
   *
   * @param {Object} userData - user data from the backend
   * @returns {void}
   */
  _upgradePictureAsset(userData) {
    const hasPicture = userData.picture.length;
    const hasAsset = userData.assets.length;

    if (hasPicture) {
      if (!hasAsset) {
        // if there are no assets, just upload the old picture to the new api
        const {medium} = z.assets.AssetMapper.mapProfileAssetsV1(userData.id, userData.picture);
        medium.load().then(imageBlob => this.change_picture(imageBlob));
      } else {
        // if an asset is already there, remove the pointer to the old picture
        this.selfService.putSelf({picture: []});
      }
    }
    return userData;
  }

  /**
   * Check for user locally and fetch it from the server otherwise.
   * @param {string} user_id - User ID
   * @returns {Promise<z.entity.User>} Promise that resolves with the matching user entity
   */
  get_user_by_id(user_id) {
    return this.findUserById(user_id)
      .catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (isNotFound) {
          return this._fetchUserById(user_id);
        }
        throw error;
      })
      .catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (!isNotFound) {
          this.logger.error(`Failed to get user '${user_id}': ${error.message}`, error);
        }
        throw error;
      });
  }

  get_user_id_by_handle(handle) {
    return this.user_service
      .getUserByHandle(handle.toLowerCase())
      .then(({user: user_id}) => user_id)
      .catch(error => {
        if (error.code !== z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          throw error;
        }
      });
  }

  /**
   * Check for users locally and fetch them from the server otherwise.
   * @param {Array<string>} user_ids - User IDs
   * @param {boolean} offline - Should we only look for cached contacts
   * @returns {Promise<Array<z.entity.User>>} Resolves with an array of users
   */
  get_users_by_id(user_ids = [], offline = false) {
    if (!user_ids.length) {
      return Promise.resolve([]);
    }

    const _find_user = user_id => {
      return this.findUserById(user_id).catch(error => {
        if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
          throw error;
        }
        return user_id;
      });
    };

    const find_users = user_ids.map(user_id => _find_user(user_id));

    return Promise.all(find_users).then(resolve_array => {
      const known_user_ets = resolve_array.filter(array_item => array_item instanceof z.entity.User);
      const unknown_user_ids = resolve_array.filter(array_item => _.isString(array_item));

      if (offline || !unknown_user_ids.length) {
        return known_user_ets;
      }

      return this.fetchUsersById(unknown_user_ids).then(user_ets => known_user_ets.concat(user_ets));
    });
  }

  /**
   * Is the user the logged in user.
   * @param {z.entity.User|string} user_id - User entity or user ID
   * @returns {boolean} Is the user the logged in user
   */
  is_me(user_id) {
    if (!_.isString(user_id)) {
      user_id = user_id.id;
    }
    return this.self().id === user_id;
  }

  /**
   * Is the user the logged in user.
   * @param {z.entity.User|string} user_et - User entity or user ID
   * @param {boolean} is_me - True, if self user
   * @returns {Promise} Resolves with the user entity
   */
  save_user(user_et, is_me = false) {
    return this.findUserById(user_et.id).catch(error => {
      if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
        throw error;
      }

      if (is_me) {
        user_et.is_me = true;
        this.self(user_et);
      }
      this.users.push(user_et);
      return user_et;
    });
  }

  /**
   * Save multiple users at once.
   * @param {Array<z.entity.User>} user_ets - Array of user entities to be stored
   * @returns {Promise} Resolves with users passed as parameter
   */
  save_users(user_ets) {
    const _find_users = user_et => {
      return this.findUserById(user_et.id)
        .then(() => undefined)
        .catch(error => {
          if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
            throw error;
          }
          return user_et;
        });
    };

    const find_users = user_ets.map(user_et => _find_users(user_et));

    return Promise.all(find_users).then(resolve_array => {
      z.util.koArrayPushAll(this.users, resolve_array.filter(user_et => user_et));
      return user_ets;
    });
  }

  /**
   * Update a local user from the backend by ID.
   * @param {string} userId - User ID
   * @returns {Promise} Resolves when user was updated
   */
  updateUserById(userId) {
    const getLocalUser = () =>
      this.findUserById(userId).catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (isNotFound) {
          return new z.entity.User();
        }
        throw error;
      });

    return Promise.all([getLocalUser(userId), this.user_service.getUser(userId)])
      .then(([localUserEntity, updatedUserData]) =>
        this.user_mapper.updateUserFromObject(localUserEntity, updatedUserData)
      )
      .then(userEntity => {
        if (this.isTeam()) {
          this.mapGuestStatus([userEntity]);
        }
      });
  }

  /**
   * Add user entities for suspended users.
   * @param {Array<string>} user_ids - Requested user IDs
   * @param {Array<z.entity.User>} user_ets - User entities returned by backend
   * @returns {Array<z.entity.User>} User entities to be returned
   */
  _add_suspended_users(user_ids, user_ets) {
    for (const user_id of user_ids) {
      const matching_user_ids = user_ets.find(user_et => user_et.id === user_id);

      if (!matching_user_ids) {
        const user_et = new z.entity.User(user_id);
        user_et.name(z.l10n.text(z.string.nonexistentUser));
        user_ets.push(user_et);
      }
    }
    return user_ets;
  }

  /**
   * Change the accent color.
   * @param {number} accent_id - New accent color
   * @returns {Promise} Resolves when accent color was changed
   */
  change_accent_color(accent_id) {
    return this.selfService
      .putSelf({accent_id})
      .then(() => this.user_update({user: {accent_id: accent_id, id: this.self().id}}));
  }

  /**
   * Change name.
   * @param {string} name - New name
   * @returns {Promise} Resolves when the name was changed
   */
  change_name(name) {
    if (name.length >= UserRepository.CONFIG.MINIMUM_NAME_LENGTH) {
      return this.selfService.putSelf({name}).then(() => this.user_update({user: {id: this.self().id, name: name}}));
    }

    return Promise.reject(new z.error.UserError(z.userUserError.TYPE.INVALID_UPDATE));
  }

  /**
   * Whether the user needs to set a username.
   * @returns {boolean} True, if username should be changed.
   */
  shouldChangeUsername() {
    return this.should_set_username;
  }

  /**
   * Tries to generate a username suggestion.
   * @returns {Promise} Resolves with the username suggestions
   */
  get_username_suggestion() {
    let suggestions = null;

    return Promise.resolve()
      .then(() => {
        suggestions = z.user.UserHandleGenerator.create_suggestions(this.self().name());
        return this.verify_usernames(suggestions);
      })
      .then(valid_suggestions => {
        this.should_set_username = true;
        this.self().username(valid_suggestions[0]);
      })
      .catch(error => {
        if (error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          this.should_set_username = false;
        }

        throw error;
      });
  }

  /**
   * Change username.
   * @param {string} username - New username
   * @returns {Promise} Resolves when the username was changed
   */
  change_username(username) {
    if (username.length >= UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH) {
      return this.selfService
        .putSelfHandle(username)
        .then(() => {
          this.should_set_username = false;
          return this.user_update({user: {handle: username, id: this.self().id}});
        })
        .catch(({code: error_code}) => {
          if (
            [
              z.error.BackendClientError.STATUS_CODE.CONFLICT,
              z.error.BackendClientError.STATUS_CODE.BAD_REQUEST,
            ].includes(error_code)
          ) {
            throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
          }
          throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
        });
    }

    return Promise.reject(new z.error.UserError(z.userUserError.TYPE.INVALID_UPDATE));
  }

  /**
   * Verify usernames against the backend.
   * @param {Array} usernames - Username suggestions
   * @returns {Promise<string>} A list with usernames that are not taken.
   */
  verify_usernames(usernames) {
    return this.user_service.checkUserHandles(usernames);
  }

  /**
   * Verify a username against the backend.
   * @param {string} username - New user name
   * @returns {string} Username which is not taken.
   */
  verify_username(username) {
    return this.user_service
      .checkUserHandle(username)
      .catch(({code: error_code}) => {
        if (error_code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          return username;
        }
        if (error_code === z.error.BackendClientError.STATUS_CODE.BAD_REQUEST) {
          throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
        }
        throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
      })
      .then(verified_username => {
        if (verified_username) {
          return verified_username;
        }
        throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
      });
  }

  /**
   * Change the profile image.
   * @param {string|Object} picture - New user picture
   * @returns {Promise} Resolves when the picture was updated
   */
  change_picture(picture) {
    return this.asset_service
      .uploadProfileImage(picture)
      .then(({previewImageKey, mediumImageKey}) => {
        const assets = [
          {key: previewImageKey, size: 'preview', type: 'image'},
          {key: mediumImageKey, size: 'complete', type: 'image'},
        ];
        return this.selfService
          .putSelf({assets, picture: []})
          .then(() => this.user_update({user: {assets: assets, id: this.self().id}}));
      })
      .catch(error => {
        throw new Error(`Error during profile image upload: ${error.message || error.code || error}`);
      });
  }

  /**
   * Set users default profile image.
   * @returns {undefined} No return value
   */
  set_default_picture() {
    return z.util.loadUrlBlob(z.config.UNSPLASH_URL).then(blob => this.change_picture(blob));
  }

  mapGuestStatus(userEntities = this.users()) {
    userEntities.forEach(userEntity => {
      if (!userEntity.is_me) {
        const isTeamMember = this.teamMembers().some(teamMember => teamMember.id === userEntity.id);
        const isGuest = !userEntity.isService && !isTeamMember;
        userEntity.isGuest(isGuest);
        userEntity.isTeamMember(isTeamMember);
      }
    });
  }

  getMarketingConsent() {
    if (!window.wire.env.FEATURE.CHECK_CONSENT) {
      this.logger.warn(`Consent check feature is disabled. Defaulting to '${this.marketingConsent()}'`);
      return Promise.resolve();
    }
    return this.selfService
      .getSelfConsent()
      .then(consents => {
        for (const {type: consentType, value: consentValue} of consents) {
          const isMarketingConsent = consentType === z.user.ConsentType.MARKETING;
          if (isMarketingConsent) {
            const hasGivenConsent = consentValue === z.user.ConsentValue.GIVEN;
            this.marketingConsent(hasGivenConsent);
            this.marketingConsent.subscribe(changedConsentValue => this.changeMarketingConsent(changedConsentValue));

            this.logger.log(`Marketing consent retrieved as '${consentValue}'`);
            return;
          }
        }

        this.logger.log(`Marketing consent not set. Defaulting to '${this.marketingConsent()}'`);
      })
      .catch(error => {
        this.logger.warn(`Failed to retrieve marketing consent: ${error.message || error.code}`, error);
      });
  }

  setConsent(consentType, consentValue) {
    return this.selfService.putSelfConsent(consentType, consentValue, `Webapp ${z.util.Environment.version(false)}`);
  }

  changeMarketingConsent(consentGiven) {
    const consentValue = consentGiven ? z.user.ConsentValue.GIVEN : z.user.ConsentValue.NOT_GIVEN;
    return this.setConsent(z.user.ConsentType.MARKETING, consentValue).then(() => {
      this.logger.log(`Marketing consent updated to ${consentValue}`);
      this.marketingConsent(consentGiven);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

(function() {
  const MIN_HANDLE_LENGTH = 2;
  const MAX_HANDLE_LENGTH = 21;

  const RANDOM_WORDS_1 = [
    'acid',
    'agate',
    'agile',
    'amber',
    'aqua',
    'arid',
    'avid',
    'azure',
    'baby',
    'basic',
    'beige',
    'best',
    'black',
    'blond',
    'blue',
    'brass',
    'brave',
    'brown',
    'busy',
    'chief',
    'chill',
    'clear',
    'cold',
    'cool',
    'coral',
    'cosy',
    'cozy',
    'cream',
    'curly',
    'cyan',
    'dear',
    'dry',
    'early',
    'even',
    'fancy',
    'fast',
    'fit',
    'folk',
    'gold',
    'green',
    'grey',
    'happy',
    'hazy',
    'icy',
    'iron',
    'kind',
    'large',
    'lazy',
    'lemon',
    'light',
    'lilac',
    'lime',
    'lord',
    'lucid',
    'mauve',
    'melt',
    'merry',
    'mint',
    'nice',
    'noir',
    'ochre',
    'odd',
    'olive',
    'opal',
    'peach',
    'pearl',
    'pink',
    'plain',
    'purple',
    'quiet',
    'rapid',
    'red',
    'rock',
    'rose',
    'ruby',
    'rust',
    'sand',
    'sassy',
    'shiny',
    'shy',
    'silly',
    'slow',
    'small',
    'stone',
    'sweet',
    'swift',
    'talc',
    'tame',
    'tiny',
    'topaz',
    'torn',
    'total',
    'vinyl',
    'violet',
    'warm',
    'white',
    'wise',
    'witty',
    'yellow',
    'young',
    'zinc',
  ];
  const RANDOM_WORDS_2 = [
    'alligator',
    'alpaca',
    'ant',
    'antelope',
    'asp',
    'badger',
    'bat',
    'bear',
    'bee',
    'beetle',
    'bird',
    'bison',
    'bobcat',
    'buffalo',
    'buzzard',
    'camel',
    'caribou',
    'carp',
    'cat',
    'catfish',
    'cheetah',
    'clam',
    'cobra',
    'cod',
    'condor',
    'cow',
    'coyote',
    'crane',
    'crayfish',
    'cricket',
    'crow',
    'deer',
    'dog',
    'dolphin',
    'donkey',
    'dove',
    'duck',
    'eagle',
    'eel',
    'elk',
    'falcon',
    'ferret',
    'finch',
    'fly',
    'fox',
    'frog',
    'gazelle',
    'giraffe',
    'gnu',
    'goat',
    'goose',
    'gopher',
    'grouse',
    'gull',
    'halibut',
    'hamster',
    'hare',
    'hawk',
    'heron',
    'herring',
    'horse',
    'husky',
    'impala',
    'jackal',
    'jaguar',
    'kangaroo',
    'koala',
    'lemur',
    'lion',
    'lizard',
    'llama',
    'lobster',
    'mackerel',
    'mole',
    'moose',
    'moth',
    'mouse',
    'mule',
    'mussel',
    'newt',
    'octopus',
    'orca',
    'ostrich',
    'otter',
    'owl',
    'ox',
    'oyster',
    'panda',
    'panther',
    'parrot',
    'pelican',
    'penguin',
    'pigeon',
    'pike',
    'pony',
    'quail',
    'rabbit',
    'racoon',
    'ram',
    'raven',
    'salmon',
    'sardine',
    'seal',
    'shark',
    'sheep',
    'sloth',
    'snail',
    'snake',
    'squid',
    'sturgeon',
    'swan',
    'tiger',
    'tilapia',
    'toad',
    'trout',
    'tuna',
    'turkey',
    'turtle',
    'walrus',
    'wapiti',
    'wasp',
    'weasel',
    'whale',
    'wolf',
    'wombat',
    'yak',
    'zebra',
  ];

  /**
   * Create a set of suggestions based on the name.
   * @param {string} name - Name to create suggestions for
   * @returns {Array<string>} Username suggestions
   */
  function create_suggestions(name) {
    const normalized_name = normalize_name(name);
    const random_name = get_random_word_combination();
    let suggestions = [];

    if (normalized_name) {
      suggestions.push(normalized_name);
      const normalized_name_variations = generate_handle_variations(normalized_name);
      suggestions = suggestions.concat(normalized_name_variations);
    }

    suggestions.push(append_random_digits(random_name));
    const random_name_variations = generate_handle_variations(random_name);
    return suggestions.concat(random_name_variations);
  }

  function get_random_word_combination() {
    return `${z.util.ArrayUtil.randomElement(RANDOM_WORDS_1)}${z.util.ArrayUtil.randomElement(RANDOM_WORDS_2)}`;
  }

  /**
   * Creates variations of the given handle by appending random digits.
   * @param {string} handle - Input
   * @param {number} [number_of_variations=5] - Number of variants that should be generated
   * @returns {Array<string>} Handle variations
   */
  function generate_handle_variations(handle, number_of_variations = 5) {
    return _.range(1, number_of_variations + 1).map(value => {
      return append_random_digits(handle.slice(0, MAX_HANDLE_LENGTH - value), value);
    });
  }

  /**
   * Appends random digits from 1 to 9 to the end of the string.
   * @param {string} handle - Input
   * @param {number} additional_numbers - number of digits to append
   * @returns {string} String appended with random digits.
   */
  function append_random_digits(handle, additional_numbers) {
    const random_digits = _.range(additional_numbers).map(() => z.util.NumberUtil.getRandomNumber(1, 8));
    return `${handle}${random_digits.join('')}`;
  }

  /**
   * Creates a handle based on the users name.
   * @param {string} name - User name
   * @returns {string} User handle
   */
  function normalize_name(name) {
    return window
      .getSlug(name)
      .toLowerCase()
      .replace(new RegExp(/[^a-z0-9_]/, 'g'), '')
      .substring(0, MAX_HANDLE_LENGTH);
  }

  /**
   * Validates that a character can be used for a handle.
   * @param {string} character - Character candidate
   * @returns {boolean} True, if character can be used for a handle.
   */
  function validate_character(character) {
    const isAlphaNumeric = /[a-z0-9_]/.test(character);
    const isString = _.isString(character) && character.length === 1;
    return isAlphaNumeric && isString;
  }

  /**
   * Validates that an input is a valid handle.
   * @param {string} handle - Character candidate
   * @returns {boolean} True, if handle is valid.
   */
  function validate_handle(handle = '') {
    if (!handle.length || handle.length < MIN_HANDLE_LENGTH || handle.length > MAX_HANDLE_LENGTH) {
      return false;
    }

    for (const character of handle) {
      if (!validate_character(character)) {
        return false;
      }
    }

    return true;
  }

  z.user.UserHandleGenerator = {
    append_random_digits: append_random_digits,
    create_suggestions: create_suggestions,
    generate_handle_variations: generate_handle_variations,
    normalize_name: normalize_name,
    validate_character: validate_character,
    validate_handle: validate_handle,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ActionsViewModel = class ActionsViewModel {
  constructor(mainViewModel, repositories) {
    this.clientRepository = repositories.client;
    this.connectionRepository = repositories.connection;
    this.conversationRepository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.ListViewModel', z.config.LOGGER.OPTIONS);
  }

  acceptConnectionRequest(userEntity, showConversation) {
    if (userEntity) {
      return this.connectionRepository.acceptRequest(userEntity, showConversation);
    }
  }

  archiveConversation(conversationEntity) {
    if (conversationEntity) {
      return this.conversationRepository.archiveConversation(conversationEntity);
    }
  }

  blockUser(userEntity, hideConversation, nextConversationEntity) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.connectionRepository.blockUser(userEntity, hideConversation, nextConversationEntity),
        text: {
          action: z.l10n.text(z.string.modalUserBlockAction),
          message: z.l10n.text(z.string.modalUserBlockMessage, userEntity.first_name()),
          title: z.l10n.text(z.string.modalUserBlockHeadline, userEntity.first_name()),
        },
      });
    }
  }

  cancelConnectionRequest(userEntity, hideConversation, nextConversationEntity) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.connectionRepository.cancelRequest(userEntity, hideConversation, nextConversationEntity),
        text: {
          action: z.l10n.text(z.string.modalConnectCancelAction),
          message: z.l10n.text(z.string.modalConnectCancelMessage, userEntity.first_name()),
          secondary: z.l10n.text(z.string.modalConnectCancelSecondary),
          title: z.l10n.text(z.string.modalConnectCancelHeadline),
        },
      });
    }
  }

  clearConversation(conversationEntity) {
    if (conversationEntity) {
      const modalType = conversationEntity.isLeavable()
        ? z.viewModel.ModalsViewModel.TYPE.OPTION
        : z.viewModel.ModalsViewModel.TYPE.CONFIRM;

      amplify.publish(z.event.WebApp.WARNING.MODAL, modalType, {
        action: (leaveConversation = false) => {
          this.conversationRepository.clear_conversation(conversationEntity, leaveConversation);
        },
        text: {
          action: z.l10n.text(z.string.modalConversationClearAction),
          message: z.l10n.text(z.string.modalConversationClearMessage),
          option: z.l10n.text(z.string.modalConversationClearOption),
          title: z.l10n.text(z.string.modalConversationClearHeadline),
        },
      });
    }
  }

  deleteClient(clientEntity) {
    // @todo Add failure case ux WEBAPP-3570
    if (this.userRepository.self().isSingleSignOn) {
      // SSO users can remove their clients without the need of entering a password
      return this.clientRepository.deleteClient(clientEntity.id);
    }

    return new Promise((resolve, reject) => {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.INPUT, {
        action: password => {
          this.clientRepository
            .deleteClient(clientEntity.id, password)
            .then(resolve)
            .catch(error => {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
              reject(error);
            });
        },
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalAccountRemoveDeviceAction),
          input: z.l10n.text(z.string.modalAccountRemoveDevicePlaceholder),
          message: z.l10n.text(z.string.modalAccountRemoveDeviceMessage),
          title: z.l10n.text(z.string.modalAccountRemoveDeviceHeadline, clientEntity.model),
        },
        warning: false,
      });
    });
  }

  deleteMessage(conversationEntity, messageEntity) {
    if (conversationEntity && messageEntity) {
      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.deleteMessage(conversationEntity, messageEntity);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationDeleteMessageAction),
            message: z.l10n.text(z.string.modalConversationDeleteMessageMessage),
            title: z.l10n.text(z.string.modalConversationDeleteMessageHeadline),
          },
        });
      });
    }
  }

  deleteMessageEveryone(conversationEntity, messageEntity) {
    if (conversationEntity && messageEntity) {
      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.deleteMessageForEveryone(conversationEntity, messageEntity);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneAction),
            message: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneMessage),
            title: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneHeadline),
          },
        });
      });
    }
  }

  ignoreConnectionRequest(userEntity) {
    if (userEntity) {
      return this.connectionRepository.ignoreRequest(userEntity);
    }
  }

  leaveConversation(conversationEntity) {
    if (conversationEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.conversationRepository.removeMember(conversationEntity, this.userRepository.self().id),
        text: {
          action: z.l10n.text(z.string.modalConversationLeaveAction),
          message: z.l10n.text(z.string.modalConversationLeaveMessage),
          title: z.l10n.text(z.string.modalConversationLeaveHeadline, conversationEntity.display_name()),
        },
      });
    }
  }

  open1to1Conversation(userEntity) {
    if (userEntity) {
      return this.conversationRepository
        .get1To1Conversation(userEntity)
        .then(conversationEntity => this._openConversation(conversationEntity));
    }
  }

  open1to1ConversationWithService(serviceEntity) {
    if (serviceEntity) {
      return this.integrationRepository
        .get1To1ConversationWithService(serviceEntity)
        .then(conversationEntity => this._openConversation(conversationEntity));
    }
  }

  openGroupConversation(conversationEntity) {
    if (conversationEntity) {
      return Promise.resolve().then(() => this._openConversation(conversationEntity));
    }
  }

  _openConversation(conversationEntity) {
    if (conversationEntity) {
      if (conversationEntity.is_archived()) {
        this.conversationRepository.unarchiveConversation(conversationEntity, true);
      }

      if (conversationEntity.is_cleared()) {
        conversationEntity.cleared_timestamp(0);
      }

      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
    }
  }

  removeFromConversation(conversationEntity, userEntity) {
    if (conversationEntity && userEntity) {
      if (userEntity.isService) {
        return this.integrationRepository.removeService(conversationEntity, userEntity);
      }

      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.removeMember(conversationEntity, userEntity.id);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationRemoveAction),
            message: z.l10n.text(z.string.modalConversationRemoveMessage, userEntity.first_name()),
            title: z.l10n.text(z.string.modalConversationRemoveHeadline),
          },
        });
      });
    }
  }

  sendConnectionRequest(userEntity, showConversation) {
    if (userEntity) {
      return this.connectionRepository.createConnection(userEntity, showConversation);
    }
  }

  toggleMuteConversation(conversationEntity) {
    if (conversationEntity) {
      const notificationState = conversationEntity.showNotificationsEverything()
        ? z.conversation.NotificationSetting.STATE.NOTHING
        : z.conversation.NotificationSetting.STATE.EVERYTHING;
      this.conversationRepository.setNotificationState(conversationEntity, notificationState);
    }
  }

  unblockUser(userEntity, showConversation) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => {
          this.connectionRepository
            .unblockUser(userEntity, showConversation)
            .then(() => this.conversationRepository.get1To1Conversation(userEntity))
            .then(conversationEntity => {
              return this.conversationRepository.updateParticipatingUserEntities(conversationEntity);
            });
        },
        text: {
          action: z.l10n.text(z.string.modalUserUnblockAction),
          message: z.l10n.text(z.string.modalUserUnblockMessage, userEntity.first_name()),
          title: z.l10n.text(z.string.modalUserUnblockHeadline),
        },
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

/**
 * The FaviconViewModel is responsible for updating the favicon according to unread messages.
 * To do so, it will listen for the UNREAD_COUNT that the app dispatches through the given dispatcher.
 */
z.viewModel.FaviconViewModel = class FaviconViewModel {
  /**
   * Construct a new FaviconViewModel.
   *
   * @param {Dispatcher} dispatcher - event dispatcher
   */
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this.unreadCount = ko.observable(0);

    this.unreadCountSubscription = this.unreadCount.subscribe(this._updateFavicon.bind(this));
    this.dispatcher.subscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, this, this._updateUnreadCount);
  }

  _updateUnreadCount(unreadCount) {
    this.unreadCount(unreadCount);
  }

  _updateFavicon(unreadCount) {
    const iconBadge = unreadCount ? '-badge' : '';
    const link = document.querySelector("link[rel*='shortcut icon']") || document.createElement('link');
    link.type = 'image/x-icon';
    link.rel = 'shortcut icon';
    link.href = `/image/favicon${iconBadge}.ico`;
    document.getElementsByTagName('head')[0].appendChild(link);
  }

  dispose() {
    this.dispatcher.unsubscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, this, this._updateUnreadCount);
    this.unreadCountSubscription.dispose();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ImageDetailViewViewModel = class ImageDetailViewViewModel {
  constructor(mainViewModel, repositories) {
    this.beforeHideCallback = this.beforeHideCallback.bind(this);
    this.hideCallback = this.hideCallback.bind(this);
    this.messageAdded = this.messageAdded.bind(this);
    this.messageExpired = this.messageExpired.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);

    this.elementId = 'detail-view';
    this.mainViewModel = mainViewModel;
    this.conversationRepository = repositories.conversation;

    this.actionsViewModel = this.mainViewModel.actions;
    this.source = undefined;

    this.imageModal = undefined;
    this.imageSrc = ko.observable();
    this.imageVisible = ko.observable(false);

    this.conversationEntity = ko.observable();
    this.items = ko.observableArray();
    this.messageEntity = ko.observable();
    this.messageEntity.subscribe(messageEntity => {
      if (messageEntity) {
        const conversationId = messageEntity.conversation_id;
        const isExpectedId = this.conversationEntity() ? conversationId === this.conversationEntity().id : false;
        if (!isExpectedId) {
          this.conversationRepository
            .get_conversation_by_id(conversationId)
            .then(conversationEntity => this.conversationEntity(conversationEntity));
        }
      }
    });

    amplify.subscribe(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, this.show.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  beforeHideCallback() {
    this.imageVisible(false);
  }

  hideCallback() {
    $(document).off('keydown.lightbox');
    window.URL.revokeObjectURL(this.imageSrc());

    this.imageSrc(undefined);
    this.items.removeAll();
    this.messageEntity(undefined);
    this.source = undefined;

    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageExpired);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.messageAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.messageRemoved);
  }

  show(messageEntity, messageEntities, source) {
    this.items(messageEntities);
    this.messageEntity(messageEntity);
    this.source = source;

    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageExpired);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.messageAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.messageRemoved);

    if (!this.imageModal) {
      this.imageModal = new z.ui.Modal('#detail-view', this.hideCallback, this.beforeHideCallback);
    }

    this.imageModal.show();

    this._loadImage();
    $(document).on('keydown.lightbox', keyboardEvent => {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ESC: {
          this.clickOnClose();
          break;
        }

        case z.util.KeyboardUtil.KEY.ARROW_DOWN:
        case z.util.KeyboardUtil.KEY.ARROW_RIGHT: {
          this.clickOnShowNext(this, keyboardEvent);
          break;
        }

        case z.util.KeyboardUtil.KEY.ARROW_LEFT:
        case z.util.KeyboardUtil.KEY.ARROW_UP: {
          this.clickOnShowPrevious(this, keyboardEvent);
          break;
        }

        default:
          break;
      }
    });
  }

  messageAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation;
    if (isCurrentConversation) {
      this.items.push(messageEntity);
    }
  }

  messageExpired(messageEntity) {
    this.messageRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  messageRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      const isVisibleMessage = this.messageEntity().id === messageId;
      if (isVisibleMessage) {
        return this.imageModal.hide();
      }

      this.items.remove(messageEntity => messageEntity.id === messageId);
    }
  }

  _loadImage() {
    this.imageVisible(false);
    this.messageEntity()
      .get_first_asset()
      .resource()
      .load()
      .then(blob => {
        if (blob) {
          this.imageSrc(window.URL.createObjectURL(blob));
          this.imageVisible(true);
        }
      });
  }

  clickOnClose() {
    this.imageModal.hide();
  }

  clickOnDownload() {
    this.messageEntity().download();
  }

  clickOnLike() {
    this.conversationRepository.toggle_like(this.conversationEntity(), this.messageEntity());
  }

  clickOnReply() {
    amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, this.messageEntity());
    this.imageModal.hide();
  }

  clickOnShowNext(imageDetailViewViewModel, event) {
    event.stopPropagation();
    this._iterateImage(true);
  }

  clickOnShowPrevious(imageDetailViewViewModel, event) {
    event.stopPropagation();
    this._iterateImage(false);
  }

  _iterateImage(reverse) {
    const messageEntity = z.util.ArrayUtil.iterateItem(this.items(), this.messageEntity(), reverse);

    if (messageEntity) {
      this.messageEntity(messageEntity);
      this._loadImage();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.LoadingViewModel = class LoadingViewModel {
  constructor(mainViewModel, repositories) {
    this.elementId = 'loading-screen';
    this.userRepository = repositories.user;
    this.loadingMessage = ko.observable('');
    this.loadingProgress = ko.observable(0);
    amplify.subscribe(z.event.WebApp.APP.UPDATE_PROGRESS, this.updateProgress.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  removeFromView() {
    $(`#${this.elementId}`).remove();
    amplify.unsubscribeAll(z.event.WebApp.APP.UPDATE_PROGRESS);
  }

  updateProgress(progress = 0, messageLocator, replaceContent) {
    const hasProgressIncreased = progress > this.loadingProgress();
    progress = hasProgressIncreased ? progress : this.loadingProgress() + 0.01;
    this.loadingProgress(progress);

    if (messageLocator) {
      let updatedLoadingMessage;

      switch (messageLocator) {
        case z.string.initReceivedSelfUser: {
          updatedLoadingMessage = z.l10n.text(messageLocator, this.userRepository.self().first_name());
          break;
        }

        case z.string.initDecryption:
        case z.string.initEvents: {
          if (z.util.Environment.frontend.isProduction()) {
            updatedLoadingMessage = z.l10n.text(messageLocator);
            break;
          }

          const substitutes = {
            number1: replaceContent.handled,
            number2: replaceContent.total,
          };

          const handlingProgress = z.l10n.text(z.string.initProgress, substitutes);
          updatedLoadingMessage = `${z.l10n.text(messageLocator)}${handlingProgress}`;
          break;
        }

        default:
          updatedLoadingMessage = z.l10n.text(messageLocator);
      }

      this.loadingMessage(updatedLoadingMessage);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.MainViewModel = class MainViewModel {
  static get CONFIG() {
    return {
      PANEL: {
        BREAKPOINT: 1000,
        WIDTH: 304,
      },
    };
  }

  static get PANEL_STATE() {
    return {
      CLOSED: 'MainViewModel.PANEL_STATE.CLOSED',
      OPEN: 'MainViewModel.PANEL_STATE.OPEN',
    };
  }

  static get PANEL_STYLE() {
    return {
      CLOSED: {
        position: 'absolute',
        right: '0',
        transform: `translateX(${MainViewModel.CONFIG.PANEL.WIDTH}px)`,
        width: `${MainViewModel.CONFIG.PANEL.WIDTH}px`,
      },
      OPEN: {
        position: 'absolute',
        right: '0',
        transform: `translateX(0px)`,
        width: `${MainViewModel.CONFIG.PANEL.WIDTH}px`,
      },
    };
  }

  constructor(repositories) {
    this.closePanel = this.closePanel.bind(this);
    this.closePanelImmediatly = this.closePanelImmediatly.bind(this);
    this.closePanelOnClick = this.closePanelOnClick.bind(this);
    this.openPanel = this.openPanel.bind(this);
    this.togglePanel = this.togglePanel.bind(this);

    this.elementId = 'wire-main';
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.MainViewModel', z.config.LOGGER.OPTIONS);

    this.selfUser = this.userRepository.self;

    this.isPanelOpen = ko.observable(false);

    this.actions = new z.viewModel.ActionsViewModel(this, repositories);

    this.panel = new z.viewModel.PanelViewModel(this, repositories);
    this.content = new z.viewModel.ContentViewModel(this, repositories);
    this.list = new z.viewModel.ListViewModel(this, repositories);

    this.modals = new z.viewModel.ModalsViewModel();
    this.lightbox = new z.viewModel.ImageDetailViewViewModel(this, repositories);
    this.loading = new z.viewModel.LoadingViewModel(this, repositories);
    this.shortcuts = new z.viewModel.ShortcutsViewModel(this, repositories);
    this.title = new z.viewModel.WindowTitleViewModel(this, repositories);
    this.favicon = new z.viewModel.FaviconViewModel(window.amplify);
    this.videoCalling = new z.viewModel.VideoCallingViewModel(this, repositories);
    this.warnings = new z.viewModel.WarningsViewModel();

    this.mainClasses = ko.pureComputed(() => {
      if (this.selfUser()) {
        // deprecated - still used on input control hover
        return `main-accent-color-${this.selfUser().accent_id()} ${this.selfUser().accent_theme()} show`;
      }
    });

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  openPanel() {
    return this.togglePanel(MainViewModel.PANEL_STATE.OPEN);
  }

  closePanel() {
    return this.togglePanel(MainViewModel.PANEL_STATE.CLOSED);
  }

  closePanelImmediatly() {
    document.querySelector('.center-column__overlay').removeEventListener('click', this.togglePanel);
    document.querySelector('#app').classList.remove('app--panel-open');
    this.isPanelOpen(false);
  }

  togglePanel(forceState) {
    const app = document.querySelector('#app');
    const panel = document.querySelector('.right-column');

    const isPanelOpen = app.classList.contains('app--panel-open');
    const isAlreadyClosed = forceState === MainViewModel.PANEL_STATE.CLOSED && !isPanelOpen;
    const isAlreadyOpen = forceState === MainViewModel.PANEL_STATE.OPEN && isPanelOpen;

    const isInForcedState = isAlreadyClosed || isAlreadyOpen;
    if (isInForcedState) {
      return Promise.resolve();
    }

    const titleBar = document.querySelector('#conversation-title-bar');
    const input = document.querySelector('#conversation-input-bar');

    const isNarrowScreen = app.offsetWidth < MainViewModel.CONFIG.PANEL.BREAKPOINT;

    const centerWidthClose = app.offsetWidth - MainViewModel.CONFIG.PANEL.WIDTH;
    const centerWidthOpen = centerWidthClose - MainViewModel.CONFIG.PANEL.WIDTH;

    return new Promise(resolve => {
      const transitionEndHandler = event => {
        if (event.target === panel) {
          panel.removeEventListener('transitionend', transitionEndHandler);
          this._clearStyles(panel, ['width', 'transform', 'position', 'right', 'transition']);
          this._clearStyles(titleBar, ['width', 'transition']);
          this._clearStyles(input, ['width', 'transition']);

          const overlay = document.querySelector('.center-column__overlay');
          if (isPanelOpen) {
            app.classList.remove('app--panel-open');
            this.isPanelOpen(false);
            overlay.removeEventListener('click', this.closePanelOnClick);
          } else {
            app.classList.add('app--panel-open');
            this.isPanelOpen(true);
            overlay.addEventListener('click', this.closePanelOnClick);
          }

          if (!isNarrowScreen) {
            // In case we are not on a narrow screen, opening a panel will resize a bunch of elements
            // we need to warn them by triggering a window resize event.
            // When the screen is narrow, the panel just goes on top, no elements are resized
            window.dispatchEvent(new Event('resize'));
          }

          resolve();
        }
      };

      panel.addEventListener('transitionend', transitionEndHandler);

      if (isPanelOpen) {
        this._applyStyle(panel, MainViewModel.PANEL_STYLE.OPEN);
        if (!isNarrowScreen) {
          this._applyStyle(titleBar, {width: `${centerWidthOpen}px`});
          this._applyStyle(input, {width: `${centerWidthOpen}px`});
        }
      } else {
        this._applyStyle(panel, MainViewModel.PANEL_STYLE.CLOSED);
        if (!isNarrowScreen) {
          this._applyStyle(titleBar, {width: `${centerWidthClose}px`});
          this._applyStyle(input, {width: `${centerWidthClose}px`});
        }
      }

      z.util.afterRender(() => {
        const widthTransition = 'width .35s cubic-bezier(0.19, 1, 0.22, 1)';
        this._applyStyle(panel, {transition: 'transform .35s cubic-bezier(0.19, 1, 0.22, 1)'});
        this._applyStyle(titleBar, {transition: widthTransition});
        this._applyStyle(input, {transition: widthTransition});

        if (isPanelOpen) {
          this._applyStyle(panel, MainViewModel.PANEL_STYLE.CLOSED);
          if (!isNarrowScreen) {
            this._applyStyle(titleBar, {width: `${centerWidthClose}px`});
            this._applyStyle(input, {width: `${centerWidthClose}px`});
          }
        } else {
          this._applyStyle(panel, MainViewModel.PANEL_STYLE.OPEN);
          if (!isNarrowScreen) {
            this._applyStyle(titleBar, {width: `${centerWidthOpen}px`});
            this._applyStyle(input, {width: `${centerWidthOpen}px`});
          }
        }
      });
    });
  }

  _applyStyle(element, style) {
    if (element) {
      Object.entries(style).forEach(([key, styleValue]) => (element.style[key] = styleValue));
    }
  }

  _clearStyles(element, styles) {
    if (element) {
      styles.forEach(key => (element.style[key] = ''));
    }
  }

  closePanelOnClick() {
    this.panel.closePanel();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ModalsViewModel = class ModalsViewModel {
  static get TYPE() {
    return {
      ACCOUNT_NEW_DEVICES: '.modal-account-new-devices',
      ACKNOWLEDGE: '.modal-template-acknowledge',
      CONFIRM: '.modal-template-confirm',
      INPUT: '.modal-template-input',
      OPTION: '.modal-template-option',
      SESSION_RESET: '.modal-session-reset',
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.viewModel.ModalsViewModel', z.config.LOGGER.OPTIONS);
    this.elementId = 'modals';

    this.modals = {};

    amplify.subscribe(z.event.WebApp.WARNING.MODAL, this.showModal.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Show modal
   *
   * @param {ModalsViewModel.TYPE} type - Indicates which modal to show
   * @param {Object} [options={}] - Information to configure modal
   * @param {Object} options.data - Content needed for visualization on modal
   * @param {Function} options.action - Called when action in modal is triggered
   * @param {boolean} [options.preventClose] - Set to true to disable autoclose behavior
   * @param {Function} options.secondary - Called when secondary action in modal is triggered
   * @returns {undefined} No return value
   */
  showModal(type, options = {}) {
    const actionElement = $(type).find('.modal-action');
    const messageElement = $(type).find('.modal-text');
    const titleElement = $(type).find('.modal-title');

    switch (type) {
      case ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES:
        this._showModalAccountNewDevices(options.data);
        break;
      case ModalsViewModel.TYPE.ACKNOWLEDGE:
        this._showModalAcknowledge(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.CONFIRM:
        this._showModalConfirm(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.INPUT:
        this._showModalInput(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.OPTION:
        this._showModalOption(options, titleElement, messageElement, actionElement);
        break;
      default:
        this.logger.warn(`Modal of type '${type}' is not supported`);
    }

    const {preventClose = false, action: actionFn, close: closeFn, secondary: secondaryFn} = options;
    const modal = new z.ui.Modal(type, null, () => {
      $(type)
        .find('.modal-close')
        .off('click');

      $(type)
        .find('.modal-action')
        .off('click');

      $(type)
        .find('.modal-secondary')
        .off('click');

      modal.destroy();

      if (typeof closeFn === 'function') {
        closeFn();
      }
    });

    $(type)
      .find('.modal-close')
      .click(() => modal.hide());

    $(type)
      .find('.modal-secondary')
      .click(() => {
        modal.hide(() => {
          if (typeof secondaryFn === 'function') {
            secondaryFn();
          }
        });
      });

    $(type)
      .find('.modal-action')
      .click(() => {
        if (typeof actionFn === 'function') {
          const checkbox = $(type).find('.modal-checkbox');
          const input = $(type).find('.modal-input');

          let parameter;
          if (checkbox.length) {
            parameter = checkbox.is(':checked');
            checkbox.prop('checked', false);
          } else if (input.length) {
            parameter = input.val();
            input.val('');
          }

          actionFn(parameter);
        }

        modal.hide();
      });

    if (!modal.isShown()) {
      this.logger.info(`Show modal of type '${type}'`);
    }

    modal.setAutoclose(!preventClose);
    modal.toggle();
  }

  _showModalAcknowledge(options, titleElement, messageElement, actionElement) {
    const {action: actionText, htmlMessage, message: messageText, title: titleText} = options.text;

    actionElement.text(actionText || z.l10n.text(z.string.modalAcknowledgeAction));
    if (htmlMessage) {
      messageElement.html(htmlMessage);
    } else {
      messageElement.text(messageText || '');
    }
    titleElement.text(titleText || z.l10n.text(z.string.modalAcknowledgeHeadline));

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalConfirm(options, titleElement, messageElement, actionElement) {
    const secondaryElement = $(ModalsViewModel.TYPE.CONFIRM).find('.modal-secondary');
    const {action: actionText, message: messageText, secondary, title: titleText} = options.text;

    const secondaryText = secondary || z.l10n.text(z.string.modalConfirmSecondary);

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    secondaryElement.text(secondaryText);
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalAccountNewDevices(devices) {
    const devicesElement = $(ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES).find('.modal-new-devices-list');

    devicesElement.empty();

    devices.map(device => {
      $('<div>')
        .text(`${moment(device.time).format('MMMM Do YYYY, HH:mm')} - UTC`)
        .appendTo(devicesElement);

      $('<div>')
        .text(`${z.l10n.text(z.string.modalAccountNewDevicesFrom)} ${device.model}`)
        .appendTo(devicesElement);
    });
  }

  _showModalOption(options, titleElement, messageElement, actionElement) {
    const secondaryElement = $(ModalsViewModel.TYPE.OPTION).find('.modal-secondary');
    const optionElement = $(ModalsViewModel.TYPE.OPTION).find('.modal-option-text');
    const {action: actionText, message: messageText, option: optionText, secondary, title: titleText} = options.text;

    const secondaryText = secondary || z.l10n.text(z.string.modalOptionSecondary);

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    optionElement.text(optionText || '');
    secondaryElement.text(secondaryText);
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalInput(options, titleElement, messageElement, actionElement) {
    const inputElement = $(ModalsViewModel.TYPE.INPUT).find('.modal-input');
    const {action: actionText, input: inputText, message: messageText, title: titleText} = options.text;

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    inputElement.attr('placeholder', inputText || '');
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ShortcutsViewModel = class ShortcutsViewModel {
  constructor(mainViewModel, repositories) {
    this.onMuteCall = this.onMuteCall.bind(this);
    this.onRejectCall = this.onRejectCall.bind(this);

    this.callingRepository = repositories.calling;
    this.logger = new z.util.Logger('z.viewModel.ShortcutsViewModel', z.config.LOGGER.OPTIONS);

    this.joinedCall = this.callingRepository.joinedCall;
    this.joinedCall.subscribe(callEntity => this._updateShortcutSubscription(callEntity));
  }

  _updateShortcutSubscription(callEntity) {
    this._unsubscribeShortcuts();

    if (callEntity) {
      switch (callEntity.state()) {
        case z.calling.enum.CALL_STATE.ONGOING:
        case z.calling.enum.CALL_STATE.OUTGOING:
          this._subscribeOutgoingOrOngoingCall();
          break;
        case z.calling.enum.CALL_STATE.INCOMING:
          this._subscribeIncomingCall();
          break;
        default:
          break;
      }
    }
  }

  _subscribeIncomingCall() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.CALL_REJECT, this.onRejectCall);
  }

  _subscribeOutgoingOrOngoingCall() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.CALL_MUTE, this.onMuteCall);
  }

  _unsubscribeShortcuts() {
    amplify.unsubscribe(z.event.WebApp.SHORTCUT.CALL_MUTE, this.onMuteCall);
    amplify.unsubscribe(z.event.WebApp.SHORTCUT.CALL_REJECT, this.onRejectCall);
  }

  onMuteCall() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.AUDIO);
    }
  }

  onRejectCall() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.STATE.REJECT, this.joinedCall().id);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.WarningsViewModel = class WarningsViewModel {
  static get CONFIG() {
    return {
      DIMMED_MODES: [
        WarningsViewModel.TYPE.REQUEST_CAMERA,
        WarningsViewModel.TYPE.REQUEST_MICROPHONE,
        WarningsViewModel.TYPE.REQUEST_NOTIFICATION,
        WarningsViewModel.TYPE.REQUEST_SCREEN,
      ],
      MINI_MODES: [
        WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT,
        WarningsViewModel.TYPE.LIFECYCLE_UPDATE,
        WarningsViewModel.TYPE.NO_INTERNET,
      ],
    };
  }

  static get TYPE() {
    return {
      CONNECTIVITY_RECONNECT: 'connectivity_reconnect',
      CONNECTIVITY_RECOVERY: 'connectivity_recovery',
      DENIED_CAMERA: 'camera_access_denied',
      DENIED_MICROPHONE: 'mic_access_denied',
      DENIED_SCREEN: 'screen_access_denied',
      LIFECYCLE_UPDATE: 'lifecycle_update',
      NO_INTERNET: 'no_internet',
      NOT_FOUND_CAMERA: 'not_found_camera',
      NOT_FOUND_MICROPHONE: 'not_found_microphone',
      REQUEST_CAMERA: 'request_camera',
      REQUEST_MICROPHONE: 'request_microphone',
      REQUEST_NOTIFICATION: 'request_notification',
      REQUEST_SCREEN: 'request_screen',
      UNSUPPORTED_INCOMING_CALL: 'unsupported_incoming_call',
      UNSUPPORTED_OUTGOING_CALL: 'unsupported_outgoing_call',
    };
  }

  constructor() {
    this.elementId = 'warnings';
    this.logger = new z.util.Logger('z.viewModel.WarningsViewModel', z.config.LOGGER.OPTIONS);

    // Array of warning banners
    this.warnings = ko.observableArray();
    this.visibleWarning = ko.pureComputed(() => this.warnings()[this.warnings().length - 1]);

    this.warnings.subscribe(warnings => {
      let topMargin;

      const visibleWarning = warnings[warnings.length - 1];
      const isConnectivityRecovery = visibleWarning === WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY;
      const noMargin = !warnings.length || isConnectivityRecovery;
      if (noMargin) {
        topMargin = '0';
      } else {
        const isMiniMode = WarningsViewModel.CONFIG.MINI_MODES.includes(visibleWarning);
        topMargin = isMiniMode ? '32px' : '64px';
      }

      $('#app').css({top: topMargin});
      window.requestAnimationFrame(() => $(window).trigger('resize'));
    });

    this.name = ko.observable();

    this.warningDimmed = ko
      .pureComputed(() => {
        for (const warning of this.warnings()) {
          const isDimmedMode = WarningsViewModel.CONFIG.DIMMED_MODES.includes(warning);
          if (isDimmedMode) {
            return true;
          }
        }
        return false;
      })
      .extend({rateLimit: 200});

    amplify.subscribe(z.event.WebApp.WARNING.SHOW, this.showWarning.bind(this));
    amplify.subscribe(z.event.WebApp.WARNING.DISMISS, this.dismissWarning.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Close warning.
   * @note Used to close a warning banner by clicking the close button
   * @returns {undefined} No return value
   */
  closeWarning() {
    const warningToClose = this.visibleWarning();
    this.dismissWarning(warningToClose);

    switch (warningToClose) {
      case WarningsViewModel.TYPE.REQUEST_MICROPHONE: {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
          action: () => {
            const url = z.util.URLUtil.buildSupportUrl(z.config.SUPPORT.ID.MICROPHONE_ACCESS_DENIED);
            z.util.SanitizationUtil.safeWindowOpen(url);
          },
          text: {
            action: z.l10n.text(z.string.modalCallNoMicrophoneAction),
            message: z.l10n.text(z.string.modalCallNoMicrophoneMessage),
            title: z.l10n.text(z.string.modalCallNoMicrophoneHeadline),
          },
        });
        break;
      }

      case WarningsViewModel.TYPE.REQUEST_NOTIFICATION: {
        // We block subsequent permission requests for notifications when the user ignores the request.
        amplify.publish(z.event.WebApp.NOTIFICATION.PERMISSION_STATE, z.notification.PermissionState.IGNORED);
        break;
      }

      default:
        break;
    }
  }

  dismissWarning(type = this.visibleWarning()) {
    const dismissedWarnings = this.warnings.remove(type);
    if (dismissedWarnings.length) {
      this.logger.info(`Dismissed warning of type '${type}'`);
    }
  }

  showWarning(type, info) {
    const connectivityTypes = [WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT, WarningsViewModel.TYPE.NO_INTERNET];
    const isConnectivityWarning = connectivityTypes.includes(type);
    const visibleWarningIsLifecycleUpdate = this.visibleWarning() === WarningsViewModel.TYPE.LIFECYCLE_UPDATE;
    if (isConnectivityWarning && !visibleWarningIsLifecycleUpdate) {
      this.dismissWarning(this.visibleWarning());
    }

    this.logger.warn(`Showing warning of type '${type}'`);
    if (info) {
      this.name(info.name);
    }
    this.warnings.push(type);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.VideoCallingViewModel = class VideoCallingViewModel {
  static get CONFIG() {
    return {
      AUTO_MINIMIZE_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 4,
      HIDE_CONTROLS_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 4,
    };
  }

  constructor(mainViewModel, repositories) {
    this.clickedOnCancelScreen = this.clickedOnCancelScreen.bind(this);
    this.clickedOnChooseScreen = this.clickedOnChooseScreen.bind(this);
    this.chooseSharedScreen = this.chooseSharedScreen.bind(this);

    this.elementId = 'video-calling';

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.mediaRepository = repositories.media;
    this.userRepository = repositories.user;
    this.videoGridRepository = repositories.videoGrid;

    this.contentViewModel = mainViewModel.content;
    this.multitasking = this.contentViewModel.multitasking;
    this.logger = new z.util.Logger('z.viewModel.VideoCallingViewModel', z.config.LOGGER.OPTIONS);

    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.streamHandler = this.mediaRepository.streamHandler;

    this.availableDevices = this.devicesHandler.availableDevices;
    this.currentDeviceId = this.devicesHandler.currentDeviceId;
    this.currentDeviceIndex = this.devicesHandler.currentDeviceIndex;

    this.hasSelfVideo = this.streamHandler.hasActiveVideo;
    this.selfStreamState = this.streamHandler.selfStreamState;
    this.localVideoStream = this.streamHandler.localMediaStream;
    this.remoteVideoStreamsInfo = this.streamHandler.remoteMediaStreamInfoIndex.video;

    this.isChoosingScreen = ko.observable(false);

    this.minimizeTimeout = undefined;

    this.calls = this.callingRepository.calls;
    this.joinedCall = this.callingRepository.joinedCall;

    this.videodCall = ko.pureComputed(() => {
      for (const callEntity of this.calls()) {
        const selfScreenSend = callEntity.selfClientJoined() && this.selfStreamState.screenSend();
        const selfVideoSend = selfScreenSend || this.selfStreamState.videoSend();
        const remoteVideoSend = callEntity.isRemoteVideoCall() && !callEntity.isOngoingOnAnotherClient();
        const isVideoCall = selfVideoSend || remoteVideoSend || this.isChoosingScreen();

        if (callEntity.isActiveState() && isVideoCall) {
          return callEntity;
        }
      }
    });

    this.isCallOngoing = ko.pureComputed(() => {
      if (this.joinedCall()) {
        const isSendingVideo = this.localVideoStream() && this.hasSelfVideo();
        const isVideoCall = isSendingVideo || this.joinedCall().isRemoteVideoCall();
        return this.joinedCall().isOngoing() && isVideoCall;
      }
    });

    this.showFullscreen = ko.pureComputed(() => {
      const isFullScreenState = this.isCallOngoing() || this.isChoosingScreen();
      return isFullScreenState && !this.multitasking.isMinimized() && !!this.videodCall();
    });

    this.remoteUser = ko.pureComputed(() => {
      const [participantEntity] = this.joinedCall() ? this.joinedCall().participants() : [];

      if (participantEntity) {
        return participantEntity.user;
      }
    });

    this.showRemoteParticipant = ko.pureComputed(() => {
      const showRemoteParticipant = this.remoteUser() && !this.multitasking.isMinimized() && !this.isChoosingScreen();
      return showRemoteParticipant && this.isCallOngoing() && !this.showRemoteVideo();
    });

    this.showRemoteVideo = ko.pureComputed(() => {
      if (this.isCallOngoing()) {
        const remoteVideoState = this.joinedCall() && this.joinedCall().isRemoteVideoCall();
        return remoteVideoState && this.remoteVideoStreamsInfo().length;
      }
    });

    this.showSwitchCamera = ko.pureComputed(() => {
      const hasMultipleCameras = this.availableDevices.videoInput().length > 1;
      const isVisible = hasMultipleCameras && this.localVideoStream() && this.selfStreamState.videoSend();
      return this.isCallOngoing() && isVisible;
    });
    this.showSwitchScreen = ko.pureComputed(() => {
      const hasMultipleScreens = this.availableDevices.screenInput().length > 1;
      const isVisible = hasMultipleScreens && this.localVideoStream() && this.selfStreamState.screenSend();
      return this.isCallOngoing() && isVisible;
    });

    this.showControls = ko.pureComputed(() => {
      const isFullscreenEnabled = this.showRemoteParticipant() && !this.multitasking.isMinimized();
      const isVisible = this.showRemoteVideo() || isFullscreenEnabled;
      return this.isCallOngoing() && isVisible;
    });
    this.showToggleVideo = ko.pureComputed(() => {
      return this.joinedCall() ? this.joinedCall().conversationEntity.supportsVideoCall(false) : false;
    });
    this.disableToggleScreen = ko.pureComputed(() => !z.calling.CallingRepository.supportsScreenSharing);

    this.visibleCallId = undefined;
    this.joinedCall.subscribe(callEntity => {
      if (callEntity) {
        const isVisibleId = this.visibleCallId === callEntity.id;
        if (!isVisibleId) {
          this.visibleCallId = callEntity.id;

          // FIXME find a better condition to actually minimize/maximize the call
          // we should do this when we check that everything is alright with audio calls also
          if (this.showRemoteVideo()) {
            this.multitasking.isMinimized(false);
            return this.logger.info(`Maximizing video call '${callEntity.id}' to full-screen`, callEntity);
          }

          //this.multitasking.isMinimized(true);
          this.logger.info(`Minimizing audio call '${callEntity.id}' from full-screen`, callEntity);
        }
      } else {
        this.visibleCallId = undefined;
        this.multitasking.autoMinimize(true);
        this.multitasking.isMinimized(false);
        this.logger.info('Resetting full-screen calling to maximize');
      }
    });

    this.showRemoteParticipant.subscribe(showRemoteParticipant => {
      if (this.minimizeTimeout) {
        window.clearTimeout(this.minimizeTimeout);
        this.minimizeTimeout = undefined;
      }

      const isVideoCall = showRemoteParticipant && this.videodCall();
      const shouldAutoMinimize = isVideoCall && this.multitasking.autoMinimize() && !this.isChoosingScreen();
      if (shouldAutoMinimize) {
        const remoteUserName = this.remoteUser() ? this.remoteUser().name() : '';

        const callId = this.videodCall().id;
        const logMessage = `Scheduled minimizing call '${callId}' as remote user '${remoteUserName}' is not videod`;
        this.logger.info(logMessage);
        this.minimizeTimeout = window.setTimeout(() => {
          if (!this.isChoosingScreen()) {
            this.multitasking.isMinimized(true);
          }
          const message = `Minimizing call '${callId}' on timeout as remote user '${remoteUserName}' is not videod`;
          this.logger.info(message);
        }, VideoCallingViewModel.CONFIG.AUTO_MINIMIZE_TIMEOUT);
      }
    });

    this.hasUnreadMessages = ko.observable(false);

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.CHOOSE_SCREEN, this.chooseSharedScreen);
    amplify.subscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, unreadCount => this.hasUnreadMessages(unreadCount > 0));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  chooseSharedScreen(conversationId) {
    if (!this.disableToggleScreen()) {
      const skipScreenSelection = this.selfStreamState.screenSend() || z.util.Environment.browser.firefox;
      if (skipScreenSelection) {
        amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, conversationId, z.media.MediaType.SCREEN);
        return;
      }

      if (z.util.Environment.desktop) {
        this.mediaRepository.devicesHandler
          .getScreenSources()
          .then(screenSources => {
            const conversationEntity = this.joinedCall().conversationEntity;

            const attributes = {
              conversation_type: z.tracking.helpers.getConversationType(conversationEntity),
              kind_of_call_when_sharing: this.joinedCall().isRemoteVideoSend() ? 'video' : 'audio',
              num_screens: screenSources.length,
            };

            const isTeamConversation = !!conversationEntity.team_id;
            if (isTeamConversation) {
              Object.assign(attributes, z.tracking.helpers.getGuestAttributes(conversationEntity));
            }

            amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CALLING.SHARED_SCREEN, attributes);

            const hasMultipleScreens = screenSources.length > 1;
            if (hasMultipleScreens) {
              this.isChoosingScreen(true);
              if (this.multitasking.isMinimized()) {
                this.multitasking.resetMinimize(true);
                this.multitasking.isMinimized(false);
              }
            } else {
              amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, conversationId, z.media.MediaType.SCREEN);
            }
          })
          .catch(error => {
            this.logger.error('Unable to get screens sources for sharing', error);
          });
      }
    }
  }

  clickedOnCancelScreen() {
    this.isChoosingScreen(false);
  }

  clickedOnLeaveCall() {
    if (this.joinedCall()) {
      const reason = z.calling.enum.TERMINATION_REASON.SELF_USER;
      amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.joinedCall().id, reason);
    }
  }

  clickedOnMuteAudio() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.AUDIO);
    }
  }

  clickedOnShareScreen() {
    if (!this.disableToggleScreen() && this.joinedCall()) {
      this.chooseSharedScreen(this.joinedCall().id);
    }
  }

  clickedOnChooseScreen(screenSource) {
    this.currentDeviceId.screenInput('');

    this.logger.info(`Selected '${screenSource.name}' for screen sharing`, screenSource);
    this.isChoosingScreen(false);
    this.currentDeviceId.screenInput(screenSource.id);
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.SCREEN);

    if (this.multitasking.resetMinimize()) {
      this.multitasking.isMinimized(true);
      this.multitasking.resetMinimize(false);
      this.logger.info(`Minimizing call '${this.joinedCall().id}' on screen selection to return to previous state`);
    }
  }

  clickedOnStopVideo() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.VIDEO);
    }
  }

  clickedOnToggleCamera() {
    this.mediaRepository.devicesHandler.toggleNextCamera();
  }

  clickedOnToggleScreen() {
    this.mediaRepository.devicesHandler.toggleNextScreen();
  }

  clickedOnMinimize() {
    this.multitasking.isMinimized(true);
    this.logger.info(`Minimizing call '${this.videodCall().id}' on user click`);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.WindowTitleViewModel = class WindowTitleViewModel {
  static get TITLE_DEBOUNCE() {
    return 250;
  }

  constructor(mainViewModel, repositories) {
    this.initiateTitleUpdates = this.initiateTitleUpdates.bind(this);

    this.contentState = mainViewModel.content.state;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.WindowTitleViewModel', z.config.LOGGER.OPTIONS);

    this.updateWindowTitle = ko.observable(false);

    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setUpdateState.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.initiateTitleUpdates);
  }

  initiateTitleUpdates() {
    amplify.unsubscribe(z.event.WebApp.LIFECYCLE.LOADED, this.initiateTitleUpdates);

    this.logger.info('Starting to update window title');
    this.updateWindowTitle(true);

    ko.computed(() => {
      if (this.updateWindowTitle()) {
        const connectionRequests = this.userRepository.connect_requests().length;

        const unreadConversations = this.conversationRepository
          .conversations_unarchived()
          .filter(conversationEntity => {
            const {
              allMessages: unreadMessages,
              selfMentions: unreadSelfMentions,
              selfReplies: unreadSelfReplies,
            } = conversationEntity.unreadState();

            const isIgnored = conversationEntity.isRequest() || conversationEntity.showNotificationsNothing();

            if (isIgnored) {
              return false;
            }

            return conversationEntity.showNotificationsMentionsAndReplies()
              ? unreadSelfMentions.length || unreadSelfReplies.length
              : unreadMessages.length > 0 || conversationEntity.hasJoinableCall();
          }).length;

        const unreadCount = connectionRequests + unreadConversations;

        let specificTitle = unreadCount > 0 ? `(${unreadCount}) ` : '';

        amplify.publish(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, unreadCount);

        switch (this.contentState()) {
          case z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS: {
            const multipleRequests = connectionRequests > 1;
            const stringId = multipleRequests
              ? z.string.conversationsConnectionRequestMany
              : z.string.conversationsConnectionRequestOne;
            specificTitle += z.l10n.text(stringId, connectionRequests);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.CONVERSATION: {
            if (this.conversationRepository.active_conversation()) {
              specificTitle += this.conversationRepository.active_conversation().display_name();
            }
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT: {
            specificTitle += z.l10n.text(z.string.preferencesAbout);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT: {
            specificTitle += z.l10n.text(z.string.preferencesAccount);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_AV: {
            specificTitle += z.l10n.text(z.string.preferencesAV);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS: {
            specificTitle += z.l10n.text(z.string.preferencesDeviceDetails);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES: {
            specificTitle += z.l10n.text(z.string.preferencesDevices);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS: {
            specificTitle += z.l10n.text(z.string.preferencesOptions);
            break;
          }

          default:
            break;
        }

        const isTitleSet = specificTitle !== '' && !specificTitle.endsWith(' ');
        window.document.title = `${specificTitle}${isTitleSet ? '  ' : ''}${z.l10n.text(z.string.wire)}`;
      }
    }).extend({rateLimit: WindowTitleViewModel.TITLE_DEBOUNCE});
  }

  setUpdateState(handlingNotifications) {
    const updateWindowTitle = handlingNotifications === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.updateWindowTitle() !== updateWindowTitle;
    if (isStateChange) {
      this.updateWindowTitle(updateWindowTitle);
      this.logger.debug(`Set window title update state to '${this.updateWindowTitle()}'`);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

/**
 * Use it on the drop area.
 */
ko.bindingHandlers.drop_file = {
  init(element, valueAccessor, allBindings, data, context) {
    const onDragLeave = (_data, event) => event.currentTarget.classList.remove('drag-hover');

    const onDragOver = (_data, event) => {
      event.preventDefault();
      event.originalEvent.dataTransfer.dropEffect = 'copy';
      event.currentTarget.classList.add('drag-hover');
    };

    const onDrop = (_data, event) => {
      event.preventDefault();
      event.currentTarget.classList.remove('drag-hover');

      const {dataTransfer, originalEvent} = event;
      const eventDataTransfer = dataTransfer || (originalEvent && originalEvent.dataTransfer) || {};
      const files = eventDataTransfer.files || [];

      if (files.length > 0) {
        valueAccessor()(files);
      }
    };

    ko.applyBindingsToNode(
      element,
      {
        event: {
          dragleave: onDragLeave,
          dragover: onDragOver,
          drop: onDrop,
        },
      },
      context
    );
  },
};

/**
 * Capture pasted files.
 */
ko.bindingHandlers.paste_file = {
  init(element, valueAccessor, allBindings, data, context) {
    const onPaste = (_data, event) => {
      const clipboardData = event.originalEvent.clipboardData;
      const items = [].slice.call(clipboardData.items || clipboardData.files);

      const files = items
        .filter(item => item.kind === 'file')
        .map(item => new Blob([item.getAsFile()], {type: item.type}))
        .filter(item => item && item.size !== 4); // Pasted files result in 4 byte blob (OSX)

      if (files.length > 0) {
        valueAccessor()(files);
        return false;
      }
      return true;
    };

    ko.applyBindingsToNode(
      window,
      {
        event: {
          paste: onPaste,
        },
      },
      context
    );
  },
};

/**
 * Blocks the default behavior when dropping a file on the element.
 * @note If a child element is listening to drag events, than this will be triggered after
 */
ko.bindingHandlers.ignore_drop_file = {
  init(element, valueAccessor, allBindings, data, context) {
    ko.applyBindingsToNode(
      element,
      {
        event: {
          dragover: (_data, event) => event.preventDefault(),
          drop: (_data, event) => event.preventDefault(),
        },
      },
      context
    );
  },
};

/**
 * Indicate that the current binding loop should not try to bind this elements children.
 * @see http://www.knockmeout.net/2012/05/quick-tip-skip-binding.html
 */
ko.bindingHandlers.stopBinding = {
  init() {
    return {controlsDescendantBindings: true};
  },
};

ko.virtualElements.allowedBindings.stopBinding = true;

/**
 * Resize textarea according to the containing text.
 */
ko.bindingHandlers.resize = {
  init(element, valueAccessor, allBindings, data, context) {
    const params = ko.unwrap(valueAccessor()) || {};

    let lastHeight = element.scrollHeight;

    const resizeTextarea = (textareaElement => {
      textareaElement.style.height = 0;
      const newStyleHeight = `${textareaElement.scrollHeight}px`;
      textareaElement.style.height = newStyleHeight;

      const currentHeight = textareaElement.clientHeight;

      if (lastHeight !== currentHeight) {
        lastHeight = currentHeight;
        const maxHeight = window.parseInt(getComputedStyle(textareaElement).maxHeight, 10);

        const isMaximumHeight = currentHeight >= maxHeight;
        const newStyleOverflowY = isMaximumHeight ? 'scroll' : 'hidden';
        textareaElement.style.overflowY = newStyleOverflowY;
      }
    }).bind(null, element);
    const throttledResizeTextarea = _.throttle(resizeTextarea, 100, {leading: !params.delayedResize});

    resizeTextarea();
    return ko.applyBindingsToNode(
      element,
      {
        event: {
          focus: throttledResizeTextarea,
          input: throttledResizeTextarea,
        },
      },
      context
    );
  },
};

ko.bindingHandlers.heightSync = {
  init(element, valueAccessor, allBindings, data, context) {
    const params = ko.unwrap(valueAccessor()) || {};

    const resizeCallback = params.callback;
    const targetElement = document.querySelector(params.target);
    const triggerValue = params.trigger;

    const resizeTarget = () => {
      const sourceHeight = element.scrollHeight;
      const targetHeight = targetElement.offsetHeight;
      if (sourceHeight !== targetHeight) {
        targetElement.style.overflowY = 'hidden';
        targetElement.style.height = `${element.scrollHeight}px`;
        z.util.afterRender(() => (targetElement.style.overflowY = ''));
        if (typeof resizeCallback === 'function') {
          resizeCallback(sourceHeight, targetHeight);
        }
      }
    };

    // initial resize
    resizeTarget();
    const valueSubscription = triggerValue.subscribe(() => window.requestAnimationFrame(resizeTarget));
    ko.utils.domNodeDisposal.addDisposeCallback(element, () => valueSubscription.dispose());
  },
};

/**
 * Syncs scrolling to another element.
 */
ko.bindingHandlers.scrollSync = {
  init(element, valueAccessor) {
    const selector = valueAccessor();
    const anchorElement = document.querySelector(selector);
    if (anchorElement) {
      anchorElement.addEventListener('scroll', () => {
        element.scrollTop = anchorElement.scrollTop;
      });
    }
  },
};

/**
 * Register on enter key pressed.
 */
ko.bindingHandlers.enter = {
  init(element, valueAccessor, allBindings, data, context) {
    const wrapper = function(_data, jquery_event) {
      const keyboard_event = jquery_event.originalEvent || jquery_event;

      if (z.util.KeyboardUtil.isEnterKey(keyboard_event) && !keyboard_event.shiftKey && !keyboard_event.altKey) {
        const callback = valueAccessor();
        if (typeof callback === 'function') {
          callback.call(this, data, keyboard_event);
          return false;
        }
      }
      return true;
    };

    return ko.applyBindingsToNode(
      element,
      {
        event: {
          keypress: wrapper,
        },
      },
      context
    );
  },
};

/**
 * Binding for <input type="file" data-bind="fileSelect: on_file_select">.
 */
ko.bindingHandlers.file_select = {
  init(element, valueAccessor, allBindings, data, context) {
    const wrapper = function(_data, event) {
      if (event.target.files.length > 0) {
        valueAccessor().call(this, event.target.files);

        // http://stackoverflow.com/a/12102992/4453133
        // wait before clearing to fix autotests
        window.setTimeout(() => {
          $(event.target).val(null);
        }, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      }
    };

    return ko.applyBindingsToNode(
      element,
      {
        event: {
          change: wrapper,
          focus(_data, event) {
            return $(event.target).blur();
          },
        },
      },
      context
    );
  },
};

/**
 * Wait for image to be loaded before applying as background image.
 */
ko.bindingHandlers.loadImage = {
  init(element, valueAccessor) {
    const image_src = z.util.stripUrlWrapper(ko.unwrap(valueAccessor()));
    const image = new Image();
    image.onload = () => (element.style.backgroundImage = `url(${image_src})`);
    image.src = image_src;
  },
};

/**
 * Load image when hovering over element.
 */
ko.bindingHandlers.load_image_on_hover = {
  init(element) {
    const hoverable_item = $(element);
    const static_image = hoverable_item.data('src');
    const animated_gif = hoverable_item.data('hover');

    if (animated_gif) {
      let image = undefined;
      hoverable_item
        .on('mouseover', function() {
          const item = $(this);
          image = new Image();
          image.onload = () => item.css({backgroundImage: `url(${animated_gif})`});
          image.src = animated_gif;
        })
        .on('mouseout', function() {
          image.onload = undefined;
          $(this).css({backgroundImage: `url(${static_image})`});
        });
    }
  },
};

/**
 * This execution trims the underlying value.
 * @returns {ko.computed} Computed
 */
ko.subscribable.fn.trimmed = function() {
  return ko.computed({
    owner: this,
    read() {
      return this().trim();
    },
    write(value) {
      this(value.trim());
      this.valueHasMutated();
    },
  });
};

/**
 * Will only fire once when the value has changed.
 * @param {*} handler - Handler
 * @param {ko.observable} owner - Subscription owner
 * @param {string} event_name - Event name
 * @returns {undefined} No return value
 */
ko.subscribable.fn.subscribe_once = function(handler, owner, event_name) {
  const subscription = this.subscribe(
    new_value => {
      subscription.dispose();
      handler(new_value);
    },
    owner,
    event_name
  );
};

/**
 * Subscribe to changes and receive the new and the old value
 * https://github.com/knockout/knockout/issues/914#issuecomment-66697321
 * @param {function} handler - Handler
 * @returns {ko.subscription} knockout subscription
 */

ko.subscribable.fn.subscribeChanged = function(handler) {
  let savedValue = this.peek();
  return this.subscribe(latestValue => {
    const oldValue = savedValue;
    savedValue = latestValue;
    handler(latestValue, oldValue);
  });
};

/**
 * Render antiscroll scrollbar.
 */
ko.bindingHandlers.antiscroll = {
  init(element, valueAccessor) {
    let trigger_subscription;
    $(element).antiscroll({
      autoHide: true,
      autoWrap: true,
      debug: false,
      notHorizontal: true,
    });

    const parent_element = $(element).parent();
    const antiscroll = parent_element.data('antiscroll');

    if (antiscroll) {
      const trigger_value = valueAccessor();
      if (ko.isObservable(trigger_value)) {
        trigger_subscription = trigger_value.subscribe(() => {
          antiscroll.rebuild();
        });
      }

      const resize_event = `resize.${Date.now()}`;
      $(window).on(
        resize_event,
        _.throttle(() => {
          antiscroll.rebuild();
        }, 100)
      );

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        antiscroll.destroy();
        $(window).off(resize_event);
        if (trigger_subscription) {
          trigger_subscription.dispose();
        }
      });
    }
  },
};

ko.bindingHandlers.simplebar = {
  init(element, valueAccessor) {
    const {trigger = valueAccessor(), onInit} = valueAccessor();
    const simpleBar = new window.SimpleBar(element, {autoHide: false});
    if (ko.isObservable(trigger)) {
      const triggerSubscription = trigger.subscribe(() => simpleBar.recalculate());
      ko.utils.domNodeDisposal.addDisposeCallback(element, () => triggerSubscription.dispose());
    }
    if (onInit) {
      onInit(simpleBar);
    }
  },
};

ko.bindingHandlers.electron_remove = {
  init(element) {
    if (z.util.Environment.electron) {
      $(element).remove();
    }
  },
};

ko.bindingHandlers.visibility = (function() {
  const setVisibility = function(element, valueAccessor) {
    const hidden = ko.unwrap(valueAccessor());
    return $(element).css('visibility', hidden ? 'visible' : 'hidden');
  };
  return {
    init: setVisibility,
    update: setVisibility,
  };
})();

ko.bindingHandlers.relative_timestamp = (function() {
  const timestamps = [];

  // should be fine to fire all 60 sec
  window.setInterval(() => timestamps.map(timestamp_func => timestamp_func()), z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

  const calculate = function(element, timestamp) {
    timestamp = window.parseInt(timestamp);
    const date = moment.unix(timestamp / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    const now = moment().local();
    const today = now.format('YYMMDD');
    const yesterday = now.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return $(element).text(z.l10n.text(z.string.conversationJustNow));
    }

    if (moment().diff(date, 'minutes') < 60) {
      return $(element).text(date.fromNow());
    }

    if (current_day === today) {
      return $(element).text(date.local().format('HH:mm'));
    }

    if (current_day === yesterday) {
      return $(element).text(`${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`);
    }

    if (moment().diff(date, 'days') < 7) {
      return $(element).text(date.local().format('dddd HH:mm'));
    }

    return $(element).text(date.local().format('dddd, MMMM D, HH:mm'));
  };

  return {
    init(element, valueAccessor) {
      const timestamp_func = () => calculate(element, valueAccessor());
      timestamp_func();
      timestamps.push(timestamp_func);

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        const timestamp_index = timestamps.indexOf(timestamp_func);
        timestamps.splice(timestamp_index, 1);
      });
    },
  };
})();

/**
 * Add 'hide-controls' when the mouse leave the element or stops moving.
 */
ko.bindingHandlers.hide_controls = {
  init(element, valueAccessor) {
    const {timeout = valueAccessor(), skipClass} = valueAccessor();
    let hide_timeout = undefined;

    element.onmouseenter = function() {
      element.classList.remove('hide-controls');
    };

    element.onmouseleave = function() {
      if (document.hasFocus()) {
        return element.classList.add('hide-controls');
      }
    };

    element.onmousemove = function({target}) {
      if (hide_timeout) {
        window.clearTimeout(hide_timeout);
      }

      element.classList.remove('hide-controls');

      let node = target;
      while (node && node !== element) {
        if (node.classList.contains(skipClass)) {
          return;
        }
        node = node.parentNode;
      }

      hide_timeout = window.setTimeout(() => {
        element.classList.add('hide-controls');
      }, timeout);
    };
  },
};

/**
 * Element is added to view.
 */
ko.bindingHandlers.added_to_view = {
  init(element, valueAccessor) {
    const callback = valueAccessor();
    callback();
  },
};

/**
 * Element is removed fomr view
 */
ko.bindingHandlers.removed_from_view = {
  init(element, valueAccessor) {
    const callback = valueAccessor();
    ko.utils.domNodeDisposal.addDisposeCallback(element, () => callback());
  },
};

/**
 * Adds a callback called whenever an element is in viewport and not overlayed by another element.
 */
ko.bindingHandlers.in_viewport = {
  init(element, valueAccessor) {
    const onElementVisible = valueAccessor();
    if (!onElementVisible) {
      return;
    }
    z.ui.ViewportObserver.addElement(element, () => {
      return z.ui.OverlayedObserver.onElementVisible(element, onElementVisible);
    });

    ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
      z.ui.OverlayedObserver.removeElement(element);
      z.ui.ViewportObserver.removeElement(element);
    });
  },
};

ko.bindingHandlers.tooltip = {
  update(element, valueAccessor) {
    const {text = valueAccessor(), position, disabled} = valueAccessor();
    if (!disabled) {
      const {id = text, substitute} = text;
      element.classList.add('with-tooltip', `with-tooltip--${position === 'bottom' ? 'bottom' : 'top'}`);
      element.setAttribute('data-tooltip', z.l10n.text(id, substitute));
    }
  },
};

/**
 * Suppresses the click event if we are in the macOs wrapper and are dragging the window
 */
ko.bindingHandlers.clickOrDrag = {
  init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    const isMacDesktop = z.util.Environment.electron && z.util.Environment.os.mac;
    const context = bindingContext.$data;
    const callback = valueAccessor().bind(context, context);
    if (!isMacDesktop) {
      return element.addEventListener('click', callback);
    }

    let isMoved = false;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    element.addEventListener('mousedown', ({screenX, screenY}) => {
      isDragging = true;
      isMoved = false;
      startX = screenX;
      startY = screenY;
    });

    element.addEventListener('mousemove', ({screenX, screenY}) => {
      if (isDragging && !isMoved) {
        const diffX = Math.abs(startX - screenX);
        const diffY = Math.abs(startY - screenY);
        if (diffX > 1 || diffY > 1) {
          isMoved = true;
        }
      }
    });

    element.addEventListener('mouseup', event => {
      if (!isMoved) {
        callback(event);
      }
      isDragging = false;
    });
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

// show scroll borders
ko.bindingHandlers.bordered_list = (function() {
  const calculate_borders = _.throttle($element => {
    if ($element) {
      window.requestAnimationFrame(() => {
        const list_column = $($element).parent();
        if ($element.height() <= 0 || !$element.isScrollable()) {
          return list_column.removeClass('left-list-center-border-bottom conversations-center-border-top');
        }

        list_column.toggleClass('left-list-center-border-top', !$element.isScrolledTop());
        list_column.toggleClass('left-list-center-border-bottom', !$element.isScrolledBottom());
      });
    }
  }, 100);

  return {
    init(element) {
      const $element = $(element);
      $element.on('scroll', () => calculate_borders($element));
      $('.left').on('click', () => calculate_borders($element));
      $(window).on('resize', () => calculate_borders($element));
      amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, () => calculate_borders($element));
    },

    update(element, valueAccessor) {
      ko.unwrap(valueAccessor());
      calculate_borders($(element));
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.bindingHandlers.switchBackground = (() => {
  return {
    update(element, valueAccessor) {
      const imageResource = ko.unwrap(valueAccessor());

      if (imageResource) {
        const backgroundImages = $(element).find('.background');
        const backgroundLast = backgroundImages.last();
        const backgroundNext = backgroundLast.clone();
        backgroundNext.css({opacity: '0'});
        backgroundNext.insertAfter(backgroundLast);

        imageResource
          .load()
          .then(blob => {
            if (blob) {
              backgroundNext
                .find('.background-image')
                .css({'background-image': `url(${window.URL.createObjectURL(blob)})`});
            }
          })
          .then(() => backgroundNext.css({opacity: '1'}).one(z.util.alias.animationend, backgroundLast.remove));
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.bindingHandlers.l10n_href = {
  update(element, valueAccessor) {
    const {support, type, path} = valueAccessor();
    const href = support ? z.util.URLUtil.buildSupportUrl(support) : z.util.URLUtil.buildUrl(type, z.l10n.text(path));
    element.setAttribute('href', href);
  },
};

ko.bindingHandlers.l10n_input = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('value', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_placeholder = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('placeholder', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_text = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    ko.utils.setTextContent(element, z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10nSafeHtml = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitutions} = valueAccessor();
    ko.utils.setHtml(element, z.l10n.safeHtml(id, substitutions));
  },
};

ko.bindingHandlers.l10n_tooltip = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('title', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_aria_label = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('aria-label', z.l10n.text(id, substitute));
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

/**
 * Focus input field when user starts typing if no other input field or textarea is selected.
 */
ko.bindingHandlers.focus_on_keydown = {
  init(element, valueAccessor, allBindings, data, context) {
    return ko.applyBindingsToNode(
      window,
      {
        event: {
          keydown(_data, jquery_event) {
            if ($('.detail-view').hasClass('modal-show')) {
              return false;
            }

            const keyboard_event = jquery_event.originalEvent || jquery_event;
            // check for activeElement needed, cause in IE11 i could be undefined under some circumstances
            const active_element_is_input =
              document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
            const is_arrow_key = z.util.KeyboardUtil.isArrowKey(keyboard_event);

            if (!active_element_is_input && !is_arrow_key) {
              const is_meta_key_pressed = z.util.KeyboardUtil.isMetaKey(keyboard_event);
              const is_paste_action = z.util.KeyboardUtil.isPasteAction(keyboard_event);

              if (!is_meta_key_pressed || is_paste_action) {
                element.focus();
              }
            }

            return true;
          },
        },
      },
      context
    );
  },
};

/**
 * Show timestamp when hovering over the element.
 */
ko.bindingHandlers.show_all_timestamps = {
  init(element) {
    const $element = $(element);

    $element.on('mousemove mouseout', function(event) {
      const rect = $(this)
        .find('.messages')[0]
        .getBoundingClientRect();
      const show_timestamps = event.clientX > rect.right - 64 && event.clientX < rect.right;
      $('.time').toggleClass('show-timestamp', show_timestamps);
    });
  },
};

/**
 * Start loading image once they are in the viewport.
 */
ko.bindingHandlers.background_image = {
  init(element, valueAccessor, allBindingsAccessor) {
    const assetLoader = valueAccessor();

    if (!assetLoader) {
      return;
    }

    const imageElement = $(element).find('img');
    let objectUrl;

    const loadImage = () => {
      assetLoader()
        .load()
        .then(blob => {
          $(element).removeClass('image-loading');
          objectUrl = window.URL.createObjectURL(blob);
          imageElement[0].src = objectUrl;
        })
        .catch(() => {});
    };

    z.ui.ViewportObserver.addElement(element, loadImage);

    ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
      z.ui.ViewportObserver.removeElement(element);
      if (objectUrl) {
        window.URL.revokeObjectURL(objectUrl);
      }
    });
  },
};

/**
 * Generate message timestamp.
 */
ko.bindingHandlers.relative_timestamp = (function() {
  // timestamp that should be updated
  const timestamps = [];

  const calculate_timestamp = function(date) {
    const current_time = moment().local();
    const today = current_time.format('YYMMDD');
    const yesterday = current_time.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return z.l10n.text(z.string.conversationJustNow);
    }

    if (moment().diff(date, 'minutes') < 60) {
      return date.fromNow();
    }

    if (current_day === today) {
      return date.local().format('HH:mm');
    }

    if (current_day === yesterday) {
      return `${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`;
    }

    if (moment().diff(date, 'days') < 7) {
      return date.local().format('dddd HH:mm');
    }

    return date.local().format('MMMM D, HH:mm');
  };

  const calculate_timestamp_day = function(date) {
    const now = moment().local();
    const today = now.format('YYMMDD');
    const yesterday = now.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return z.l10n.text(z.string.conversationJustNow);
    }

    if (moment().diff(date, 'minutes') < 60) {
      return date.fromNow();
    }

    if (current_day === today) {
      return `${z.l10n.text(z.string.conversationToday)} ${date.local().format('HH:mm')}`;
    }

    if (current_day === yesterday) {
      return `${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`;
    }

    if (moment().diff(date, 'days') < 7) {
      return date.local().format('dddd HH:mm');
    }

    return date.local().format('dddd, MMMM D, HH:mm');
  };

  // should be fine to update every minute
  window.setInterval(() => timestamps.map(timestamp_func => timestamp_func()), z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

  const calculate = function(element, timestamp, is_day) {
    timestamp = window.parseInt(timestamp);
    const date = moment.unix(timestamp / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    if (is_day) {
      return $(element).text(calculate_timestamp_day(date));
    }

    return $(element).text(calculate_timestamp(date));
  };

  return {
    init(element, valueAccessor, allBindings) {
      const timestamp_func = function() {
        calculate(element, valueAccessor(), allBindings.get('relative_timestamp_day'));
      };

      timestamp_func();
      timestamps.push(timestamp_func);

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        const timestamp_index = timestamps.indexOf(timestamp_func);
        timestamps.splice(timestamp_index, 1);
      });
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

// http://stackoverflow.com/questions/28762211/unable-to-mute-html5-video-tag-in-firefox
ko.bindingHandlers.muteMediaElement = {
  update(element, valueAccessor) {
    if (valueAccessor()) {
      element.muted = true;
    }
  },
};

ko.bindingHandlers.sourceStream = {
  update(element, valueAccessor) {
    element.srcObject = valueAccessor();
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ContentViewModel = class ContentViewModel {
  static get STATE() {
    return {
      COLLECTION: 'ContentViewModel.STATE.COLLECTION',
      COLLECTION_DETAILS: 'ContentViewModel.STATE.COLLECTION_DETAILS',
      CONNECTION_REQUESTS: 'ContentViewModel.STATE.CONNECTION_REQUESTS',
      CONVERSATION: 'ContentViewModel.STATE.CONVERSATION',
      HISTORY_EXPORT: 'ContentViewModel.STATE.HISTORY_EXPORT',
      HISTORY_IMPORT: 'ContentViewModel.STATE.HISTORY_IMPORT',
      PREFERENCES_ABOUT: 'ContentViewModel.STATE.PREFERENCES_ABOUT',
      PREFERENCES_ACCOUNT: 'ContentViewModel.STATE.PREFERENCES_ACCOUNT',
      PREFERENCES_AV: 'ContentViewModel.STATE.PREFERENCES_AV',
      PREFERENCES_DEVICE_DETAILS: 'ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS',
      PREFERENCES_DEVICES: 'ContentViewModel.STATE.PREFERENCES_DEVICES',
      PREFERENCES_OPTIONS: 'ContentViewModel.STATE.PREFERENCES_OPTIONS',
      WATERMARK: 'ContentViewModel.STATE.WATERMARK',
    };
  }

  constructor(mainViewModel, repositories) {
    this.showConversation = this.showConversation.bind(this);
    this.switchContent = this.switchContent.bind(this);
    this.switchPreviousContent = this.switchPreviousContent.bind(this);

    this.elementId = 'center-column';
    this.mainViewModel = mainViewModel;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.ContentViewModel', z.config.LOGGER.OPTIONS);

    // State
    this.state = ko.observable(ContentViewModel.STATE.WATERMARK);
    this.multitasking = {
      autoMinimize: ko.observable(true),
      isMinimized: ko.observable(false),
      resetMinimize: ko.observable(false),
    };

    // Nested view models
    this.collectionDetails = new z.viewModel.content.CollectionDetailsViewModel();
    this.collection = new z.viewModel.content.CollectionViewModel(mainViewModel, this, repositories);
    this.connectRequests = new z.viewModel.content.ConnectRequestsViewModel(mainViewModel, this, repositories);
    this.emojiInput = new z.viewModel.content.EmojiInputViewModel(mainViewModel, this, repositories);
    this.giphy = new z.viewModel.content.GiphyViewModel(mainViewModel, this, repositories);
    this.inputBar = new z.viewModel.content.InputBarViewModel(
      mainViewModel,
      this,
      repositories,
      z.message.MessageHasher
    );
    this.groupCreation = new z.viewModel.content.GroupCreationViewModel(mainViewModel, this, repositories);
    this.messageList = new z.viewModel.content.MessageListViewModel(mainViewModel, this, repositories);
    this.titleBar = new z.viewModel.content.TitleBarViewModel(mainViewModel, this, repositories);

    this.preferencesAbout = new z.viewModel.content.PreferencesAboutViewModel(mainViewModel, this, repositories);
    this.preferencesAccount = new z.viewModel.content.PreferencesAccountViewModel(mainViewModel, this, repositories);
    this.preferencesAV = new z.viewModel.content.PreferencesAVViewModel(mainViewModel, this, repositories);
    this.preferencesDeviceDetails = new z.viewModel.content.PreferencesDeviceDetailsViewModel(
      mainViewModel,
      this,
      repositories
    );
    this.preferencesDevices = new z.viewModel.content.PreferencesDevicesViewModel(mainViewModel, this, repositories);
    this.preferencesOptions = new z.viewModel.content.PreferencesOptionsViewModel(mainViewModel, this, repositories);

    this.historyExport = new z.viewModel.content.HistoryExportViewModel(mainViewModel, this, repositories);
    this.historyImport = new z.viewModel.content.HistoryImportViewModel(mainViewModel, this, repositories);

    this.previousState = undefined;
    this.previousConversation = undefined;

    this.state.subscribe(state => {
      switch (state) {
        case ContentViewModel.STATE.CONVERSATION:
          this.inputBar.addedToView();
          this.titleBar.addedToView();
          break;
        case ContentViewModel.STATE.PREFERENCES_ACCOUNT:
          this.preferencesAccount.checkNewClients();
          break;
        case ContentViewModel.STATE.PREFERENCES_AV:
          this.preferencesAV.initiateDevices();
          break;
        case ContentViewModel.STATE.PREFERENCES_DEVICES:
          this.preferencesDevices.updateDeviceInfo();
          break;
        case ContentViewModel.STATE.COLLECTION:
          this.collection.setConversation(this.previousConversation);
          break;
        default:
          this.inputBar.removedFromView();
          this.titleBar.removedFromView();
      }
    });

    this.userRepository.connect_requests.subscribe(requests => {
      const isStateRequests = this.state() === ContentViewModel.STATE.CONNECTION_REQUESTS;
      if (isStateRequests && !requests.length) {
        this.showConversation(this.conversationRepository.getMostRecentConversation());
      }
    });

    this._initSubscriptions();

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this.switchContent.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.SHOW, this.showConversation.bind(this));
  }

  /**
   * Slide in specified content.
   * @param {string} contentSelector - DOM element to apply slide in animation
   * @returns {undefined} No return value
   */
  _shiftContent(contentSelector) {
    const incomingCssClass = 'content-animation-incoming-horizontal-left';

    $(contentSelector)
      .removeClass(incomingCssClass)
      .off(z.util.alias.animationend)
      .addClass(incomingCssClass)
      .one(z.util.alias.animationend, function() {
        $(this)
          .removeClass(incomingCssClass)
          .off(z.util.alias.animationend);
      });
  }

  /**
   * Opens the specified conversation.
   *
   * @note If the conversation_et is not defined, it will open the incoming connection requests instead
   *  Conversation_et can also just be the conversation ID
   *
   * @param {z.entity.Conversation|string} conversation - Conversation entity or conversation ID
   * @param {Object} options - State to open conversation in
   * @param {z.entity.Message} [options.exposeMessage] - Scroll to message and highlight it
   * @param {boolean} [options.openFirstSelfMention=false] - Open first self mention instead of passed message
   * @param {boolean} [options.openNotificationSettings=false] - Open notification settings of conversation
   * @returns {undefined} No return value
   */
  showConversation(conversation, options = {}) {
    const {
      exposeMessage: exposeMessageEntity,
      openFirstSelfMention = false,
      openNotificationSettings = false,
    } = options;

    if (!conversation) {
      return this.switchContent(ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    const isConversation = typeof conversation === 'object' && conversation.id;
    const isConversationId = typeof conversation === 'string';
    if (!isConversation && !isConversationId) {
      throw new Error(`Wrong input for conversation: ${typeof conversation}`);
    }

    const conversationPromise = isConversation
      ? Promise.resolve(conversation)
      : this.conversationRepository.get_conversation_by_id(conversation);

    conversationPromise.then(conversationEntity => {
      const isActiveConversation = conversationEntity === this.conversationRepository.active_conversation();
      const isConversationState = this.state() === ContentViewModel.STATE.CONVERSATION;
      const isOpenedConversation = conversationEntity && isActiveConversation && isConversationState;

      if (isOpenedConversation) {
        if (openNotificationSettings) {
          this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
        }
        return;
      }

      this._releaseContent(this.state());

      this.state(ContentViewModel.STATE.CONVERSATION);

      if (!isActiveConversation) {
        this.conversationRepository.active_conversation(conversationEntity);
      }

      const messageEntity = openFirstSelfMention ? conversationEntity.getFirstUnreadSelfMention() : exposeMessageEntity;
      this.messageList.changeConversation(conversationEntity, messageEntity).then(() => {
        this._showContent(ContentViewModel.STATE.CONVERSATION);
        this.previousConversation = this.conversationRepository.active_conversation();
        if (openNotificationSettings) {
          this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
        }
      });
    });
  }

  switchContent(newContentState) {
    const isStateChange = newContentState !== this.state();
    if (isStateChange) {
      this._releaseContent(newContentState);
      this._showContent(this._checkContentAvailability(newContentState));
    }
  }

  switchPreviousContent() {
    const isStateChange = this.previousState !== this.state();
    if (isStateChange) {
      const isStateRequests = this.previousState === ContentViewModel.STATE.CONNECTION_REQUESTS;
      if (isStateRequests) {
        this.switchContent(ContentViewModel.STATE.CONNECTION_REQUESTS);
      }

      if (this.previousConversation && !this.previousConversation.is_archived()) {
        return this.showConversation(this.previousConversation);
      }

      return this.switchContent(ContentViewModel.STATE.WATERMARK);
    }
  }

  _checkContentAvailability(state) {
    const isStateRequests = state === ContentViewModel.STATE.CONNECTION_REQUESTS;
    if (isStateRequests) {
      const hasConnectRequests = !!this.userRepository.connect_requests().length;
      if (!hasConnectRequests) {
        return ContentViewModel.STATE.WATERMARK;
      }
    }
    return state;
  }

  _getElementOfContent(state) {
    switch (state) {
      case ContentViewModel.STATE.COLLECTION:
        return '.collection';
      case ContentViewModel.STATE.COLLECTION_DETAILS:
        return '.collection-details';
      case ContentViewModel.STATE.CONVERSATION:
        return '.conversation';
      case ContentViewModel.STATE.CONNECTION_REQUESTS:
        return '.connect-requests';
      case ContentViewModel.STATE.PREFERENCES_ABOUT:
        return '.preferences-about';
      case ContentViewModel.STATE.PREFERENCES_ACCOUNT:
        return '.preferences-account';
      case ContentViewModel.STATE.PREFERENCES_AV:
        return '.preferences-av';
      case ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS:
        return '.preferences-device-details';
      case ContentViewModel.STATE.PREFERENCES_DEVICES:
        return '.preferences-devices';
      case ContentViewModel.STATE.PREFERENCES_OPTIONS:
        return '.preferences-options';
      default:
        return '.watermark';
    }
  }

  _releaseContent(newContentState) {
    this.previousState = this.state();

    const isStateConversation = this.previousState === ContentViewModel.STATE.CONVERSATION;
    if (isStateConversation) {
      const collectionStates = [ContentViewModel.STATE.COLLECTION, ContentViewModel.STATE.COLLECTION_DETAILS];
      const isCollectionState = collectionStates.includes(newContentState);
      if (!isCollectionState) {
        this.conversationRepository.active_conversation(null);
      }

      return this.messageList.release_conversation();
    }

    const isStatePreferencesAv = this.previousState === ContentViewModel.STATE.PREFERENCES_AV;
    if (isStatePreferencesAv) {
      this.preferencesAV.releaseDevices();
    }
  }

  _showContent(newContentState) {
    this.state(newContentState);
    return this._shiftContent(this._getElementOfContent(newContentState));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.CollectionDetailsViewModel = class CollectionDetailsViewModel {
  constructor() {
    this.itemAdded = this.itemAdded.bind(this);
    this.itemRemoved = this.itemRemoved.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);
    this.removedFromView = this.removedFromView.bind(this);
    this.setConversation = this.setConversation.bind(this);

    this.logger = new z.util.Logger('z.viewModel.CollectionDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.template = ko.observable();
    this.conversationEntity = ko.observable();

    this.items = ko.observableArray();

    this.lastMessageTimestamp = undefined;
  }

  setConversation(conversationEntity, category, items) {
    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    this.template(category);
    this.conversationEntity(conversationEntity);
    z.util.koPushDeferred(this.items, items);
  }

  itemAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation_id;
    if (isCurrentConversation) {
      switch (this.template()) {
        case 'images': {
          const isImage = messageEntity.category & z.message.MessageCategory.IMAGE;
          const isGif = messageEntity.category & z.message.MessageCategory.GIF;
          if (isImage && !isGif) {
            this.items.push(messageEntity);
          }
          break;
        }

        case 'files': {
          const isFile = messageEntity.category & z.message.MessageCategory.FILE;
          if (isFile) {
            this.items.push(messageEntity);
          }
          break;
        }

        case 'links':
          const isLinkPreview = messageEntity.category & z.message.MessageCategory.LINK_PREVIEW;
          if (isLinkPreview) {
            this.items.push(messageEntity);
          }
          break;

        default:
          break;
      }
    }
  }

  itemRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      this.items.remove(messageEntity => messageEntity.id === messageId);
      if (!this.items().length) {
        this.clickOnBackButton();
      }
    }
  }

  messageRemoved(messageEntity) {
    this.itemRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  removedFromView() {
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    this.lastMessageTimestamp = undefined;
    this.conversationEntity(null);
    this.items.removeAll();
  }

  clickOnBackButton() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION);
  }

  clickOnImage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, messageEntity, this.items(), 'collection');
  }

  shouldShowHeader(messageEntity) {
    if (!this.lastMessageTimestamp) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }

    // We passed today
    const isSameDay = moment(messageEntity.timestamp()).isSameDay(this.lastMessageTimestamp);
    const wasToday = moment(this.lastMessageTimestamp).isToday();
    if (!isSameDay && wasToday) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }

    // We passed the month
    const isSameMonth = moment(messageEntity.timestamp()).isSameMonth(this.lastMessageTimestamp);
    if (!isSameMonth) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }
  }

  getTitleForHeader(messageEntity) {
    const messageDate = moment(messageEntity.timestamp());
    if (messageDate.isToday()) {
      return z.l10n.text(z.string.conversationToday);
    }

    return messageDate.isCurrentYear() ? messageDate.format('MMMM') : messageDate.format('MMMM Y');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.CollectionViewModel = class CollectionViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.addedToView = this.addedToView.bind(this);
    this.clickOnMessage = this.clickOnMessage.bind(this);
    this.itemAdded = this.itemAdded.bind(this);
    this.itemRemoved = this.itemRemoved.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);
    this.onInputChange = this.onInputChange.bind(this);
    this.removedFromView = this.removedFromView.bind(this);
    this.searchInConversation = this.searchInConversation.bind(this);
    this.setConversation = this.setConversation.bind(this);

    this.collectionDetails = contentViewModel.collectionDetails;
    this.conversation_repository = repositories.conversation;
    this.logger = new z.util.Logger('z.viewModel.CollectionViewModel', z.config.LOGGER.OPTIONS);

    this.conversationEntity = ko.observable();

    this.audio = ko.observableArray().extend({rateLimit: 1});
    this.files = ko.observableArray().extend({rateLimit: 1});
    this.images = ko.observableArray().extend({rateLimit: 1});
    this.links = ko.observableArray().extend({rateLimit: 1});

    this.searchInput = ko.observable('');
  }

  addedToView() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    $(document).on('keydown.collection', keyboardEvent => {
      if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity());
      }
    });
  }

  searchInConversation(query) {
    return this.conversation_repository.searchInConversation(this.conversationEntity(), query);
  }

  onInputChange(input) {
    this.searchInput(input || '');
  }

  itemAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation_id;
    if (isCurrentConversation) {
      this._populateItems([messageEntity]);
    }
  }

  itemRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      const _removeItem = messageEntity => messageEntity.id === messageId;
      [this.audio, this.files, this.images, this.links].forEach(array => array.remove(_removeItem));
    }
  }

  messageRemoved(messageEntity) {
    this.itemRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  removedFromView() {
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    $(document).off('keydown.collection');
    this.conversationEntity(null);
    this.searchInput('');
    [this.images, this.files, this.links, this.audio].forEach(array => array.removeAll());
  }

  setConversation(conversationEntity = this.conversation_repository.active_conversation()) {
    if (conversationEntity) {
      this.conversationEntity(conversationEntity);

      this.conversation_repository
        .get_events_for_category(conversationEntity, z.message.MessageCategory.LINK_PREVIEW)
        .then(messageEntities => this._populateItems(messageEntities));
    }
  }

  _populateItems(messageEntities) {
    messageEntities.forEach(messageEntity => {
      if (!messageEntity.is_expired()) {
        // TODO: create binary map helper
        const isImage = messageEntity.category & z.message.MessageCategory.IMAGE;
        const isGif = messageEntity.category & z.message.MessageCategory.GIF;
        if (isImage && !isGif) {
          return this.images.push(messageEntity);
        }

        const isFile = messageEntity.category & z.message.MessageCategory.FILE;
        if (isFile) {
          const isAudio = messageEntity.get_first_asset().is_audio();
          return isAudio ? this.audio.push(messageEntity) : this.files.push(messageEntity);
        }

        const isLinkPreview = messageEntity.category & z.message.MessageCategory.LINK_PREVIEW;
        if (isLinkPreview) {
          this.links.push(messageEntity);
        }
      }
    });
  }

  clickOnMessage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity(), {exposeMessage: messageEntity});
  }

  clickOnBackButton() {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity());
  }

  clickOnSection(category, items) {
    this.collectionDetails.setConversation(this.conversationEntity(), category, [].concat(items));
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION_DETAILS);
  }

  clickOnImage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, messageEntity, this.images(), 'collection');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.ConnectRequestsViewModel = class ConnectRequestsViewModel {
  /**
   * View model for connection requests.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ContentViewModel} contentViewModel - Content view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, contentViewModel, repositories) {
    this.afterRender = this.afterRender.bind(this);
    this.clickOnAccept = this.clickOnAccept.bind(this);
    this.clickOnIgnore = this.clickOnIgnore.bind(this);

    this.mainViewModel = mainViewModel;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.ConnectRequestsViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;
    this.connectRequests = this.userRepository.connect_requests;

    this.shouldUpdateScrollbar = ko.computed(() => this.connectRequests()).extend({notify: 'always', rateLimit: 500});
  }

  /**
   * Called after each connection request is rendered.
   * @param {Object} elements - rendered objects
   * @param {z.entity.User} request - Rendered connection request
   * @returns {undefined} No return value
   */
  afterRender(elements, request) {
    if (z.util.ArrayUtil.isLastItem(this.connectRequests(), request)) {
      window.requestAnimationFrame(() => $('.connect-requests').scrollToBottom());
    }
  }

  /**
   * Click on accept.
   * @param {z.entity.User} userEntity - User to accept connection request from
   * @returns {undefined} No return value
   */
  clickOnAccept(userEntity) {
    const showConversation = this.connectRequests().length === 1;
    this.actionsViewModel.acceptConnectionRequest(userEntity, showConversation);
  }

  /**
   * Click on ignore.
   * @param {z.entity.User} userEntity - User to ignore connection request from
   * @returns {undefined} No return value
   */
  clickOnIgnore(userEntity) {
    this.actionsViewModel.ignoreConnectionRequest(userEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.EmojiInputViewModel = class EmojiInputViewModel {
  static get CONFIG() {
    return {
      LIST: {
        LENGTH: 5,
        OFFSET_LEFT: 8,
        OFFSET_TOP: 8,
      },
    };
  }

  // DO NOT USE COLON WITH LOWERCASE LETTERS IN THE SHORTCUTS, or you will prevent searching emojis.
  // For example, while :D should be replaced with unicode symbol, :d should allow searching for :dancer:
  /* eslint-disable sort-keys, no-multi-spaces */
  static get INLINE_REPLACEMENT() {
    return [
      {shortcut: ':)', name: 'slight smile'},
      {shortcut: ':-)', name: 'slight smile'},
      {shortcut: ':D', name: 'smile'},
      {shortcut: ':-D', name: 'smile'},
      {shortcut: ':-d', name: 'grinning'},
      {shortcut: 'B-)', name: 'sunglasses'},
      {shortcut: 'b-)', name: 'sunglasses'},
      {shortcut: '8-)', name: 'sunglasses'},
      {shortcut: ':(', name: 'disappointed'},
      {shortcut: ':-(', name: 'disappointed'},
      {shortcut: ';)', name: 'wink'},
      {shortcut: ';-)', name: 'wink'},
      {shortcut: ';-]', name: 'wink'},
      {shortcut: ';]', name: 'wink'},
      {shortcut: ':/', name: 'confused'},
      {shortcut: ':-/', name: 'confused'},
      {shortcut: ':P', name: 'stuck out tongue'},
      {shortcut: ':-P', name: 'stuck out tongue'},
      {shortcut: ':-p', name: 'stuck out tongue'},
      {shortcut: ';P', name: 'stuck out tongue winking eye'},
      {shortcut: ';-P', name: 'stuck out tongue winking eye'},
      {shortcut: ';-p', name: 'stuck out tongue winking eye'},
      {shortcut: ':O', name: 'open mouth'},
      {shortcut: ':-o', name: 'open mouth'},
      {shortcut: 'O:)', name: 'innocent'},
      {shortcut: 'O:-)', name: 'innocent'},
      {shortcut: 'o:)', name: 'innocent'},
      {shortcut: 'o:-)', name: 'innocent'},
      {shortcut: ';^)', name: 'smirk'},
      {shortcut: ':@', name: 'angry'},
      {shortcut: '>:(', name: 'rage'},
      {shortcut: '}:-)', name: 'smiling imp'},
      {shortcut: '}:)', name: 'smiling imp'},
      {shortcut: '3:-)', name: 'smiling imp'},
      {shortcut: '3:)', name: 'smiling imp'},
      {shortcut: ":'-(", name: 'cry'},
      {shortcut: ":'(", name: 'cry'},
      {shortcut: ';(', name: 'cry'},
      {shortcut: ":'-)", name: 'joy'},
      {shortcut: ":')", name: 'joy'},
      {shortcut: ':*', name: 'kissing heart'},
      {shortcut: ':^*', name: 'kissing heart'},
      {shortcut: ':-*', name: 'kissing heart'},
      {shortcut: ':-|', name: 'neutral face'},
      {shortcut: ':|', name: 'neutral face'},
      {shortcut: ':$', name: 'flushed'},
      {shortcut: ':-X', name: 'no mouth'},
      {shortcut: ':X', name: 'no mouth'},
      {shortcut: ':-#', name: 'no mouth'},
      {shortcut: ':#', name: 'no mouth'},
      {shortcut: '\\o/', name: 'raised hands'},
      {shortcut: '<3', name: 'heart'},
      {shortcut: '</3', name: 'broken heart'},
    ].sort((first, second) => {
      const isUnequalLength = first.shortcut.length !== second.shortcut.length;

      return isUnequalLength
        ? second.shortcut.length - first.shortcut.length
        : first.shortcut.localeCompare(second.shortcut);
    });
  }
  /* eslint-enable sort-keys, no-multi-spaces */

  constructor(mainViewModel, contentViewModel, repositories) {
    this.removeEmojiPopup = this.removeEmojiPopup.bind(this);
    this.updatedReplaceEmojiPreference = this.updatedReplaceEmojiPreference.bind(this);

    const EMOJI_DIV_CLASS = 'conversation-input-bar-emoji-list';
    this.INLINE_MAX_LENGTH = EmojiInputViewModel.INLINE_REPLACEMENT.reduce((accumulator, currentItem) => {
      return accumulator.length > currentItem.length ? accumulator : currentItem;
    }).length;

    this.isVisible = false;

    this.emojiList = [];
    this.emojiDict = {};

    this.emojiDiv = $(`<div class='${EMOJI_DIV_CLASS}' />`);
    this.emojiStartPosition = -1;
    this.emojiUsageCount = z.util.StorageUtil.getValue(z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT) || {};

    this.shouldReplaceEmoji = repositories.properties.getPreference(z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE);

    $(document).on('click', `.${EMOJI_DIV_CLASS}`, event => {
      const clicked = $(event.target);
      const emojiLine = clicked.hasClass('emoji') ? clicked : clicked.closest('.emoji');
      const [input] = $('#conversation-input-bar-text');
      this._enterEmojiPopupLine(input, emojiLine);
      return false;
    });

    $(document).on('mouseenter', `.${EMOJI_DIV_CLASS} .emoji`, event => {
      $(`.${EMOJI_DIV_CLASS} .emoji`).removeClass('selected');
      $(event.currentTarget).addClass('selected');
    });

    fetch('/image/emoji.json')
      .then(response => response.json())
      .then(json => {
        for (const code in json) {
          const details = json[code];

          // Ignore 'tone' emojis for now, they clutter suggestions too much.
          if (details.alpha_code.match(/_tone\d/)) {
            continue;
          }

          const icon = String.fromCodePoint.apply(null, details.output.split('-').map(char => `0x${char}`));
          const alphaCodes = [details.alpha_code, ...details.aliases.split('|')];
          alphaCodes.forEach(alphaCode => {
            if (alphaCode) {
              const name = alphaCode
                .slice(1, -1)
                .replace(/_/g, ' ')
                .toLowerCase();
              this.emojiList.push({icon, name});
              this.emojiDict[name] = icon;
            }
          });
        }
      });

    this._initSubscriptions();
  }

  onInputKeyDown(data, keyboardEvent) {
    const input = keyboardEvent.target;

    // Handling just entered inline emoji
    switch (keyboardEvent.key) {
      case z.util.KeyboardUtil.KEY.SPACE: {
        if (this._tryReplaceInlineEmoji(input)) {
          return false;
        }
        break;
      }

      case z.util.KeyboardUtil.KEY.TAB: {
        if (this._tryReplaceInlineEmoji(input)) {
          keyboardEvent.preventDefault();
          return true;
        }
        break;
      }

      default:
        break;
    }

    // Handling emoji popup
    if (this.isVisible) {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ESC: {
          this.removeEmojiPopup();
          keyboardEvent.preventDefault();
          return true;
        }

        case z.util.KeyboardUtil.KEY.ARROW_UP:
        case z.util.KeyboardUtil.KEY.ARROW_DOWN: {
          this._rotateEmojiPopup(z.util.KeyboardUtil.isKey(keyboardEvent, z.util.KeyboardUtil.KEY.ARROW_UP));
          this.suppressKeyUp = true;
          keyboardEvent.preventDefault();
          return true;
        }

        case z.util.KeyboardUtil.KEY.ENTER:
        case z.util.KeyboardUtil.KEY.TAB: {
          if (keyboardEvent.shiftKey && z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
            break;
          }

          this._enterEmojiPopupLine(input, this.emojiDiv.find('.emoji.selected'));
          keyboardEvent.preventDefault();
          return true;
        }

        default:
          break;
      }
    }

    // Handling inline emoji in the whole text
    if (z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
      this._replaceAllInlineEmoji(input);
    }

    return false;
  }

  onInputKeyUp(data, keyboardEvent) {
    if (this.suppressKeyUp) {
      this.suppressKeyUp = false;
      return true;
    }

    const input = keyboardEvent.target;
    const {selectionStart: selection, value: text} = input;

    if (text) {
      const popupTrigger = text.slice(Math.max(selection - 2, 0), selection);
      const containsPopupTrigger = /\B:$/.test(popupTrigger);
      if (containsPopupTrigger) {
        this.emojiStartPosition = selection;
        this._updateEmojiPopup(input);
      } else if (this.emojiStartPosition !== -1) {
        if (selection < this.emojiStartPosition || text[this.emojiStartPosition - 1] !== ':') {
          this.removeEmojiPopup();
        } else {
          this._updateEmojiPopup(input);
        }
      }
    }

    return true;
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this.removeEmojiPopup);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.EMOJI.REPLACE_INLINE, this.updatedReplaceEmojiPreference);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, properties => {
      this.updatedReplaceEmojiPreference(properties.settings.emoji.replace_inline);
    });
  }

  updatedReplaceEmojiPreference(preference) {
    this.shouldReplaceEmoji = preference;
  }

  _tryReplaceInlineEmoji(input) {
    const {selectionStart: selection, value: text} = input;

    if (this.shouldReplaceEmoji && text) {
      const textUntilCursor = text.substring(Math.max(0, selection - this.INLINE_MAX_LENGTH - 1), selection);

      for (const replacement of EmojiInputViewModel.INLINE_REPLACEMENT) {
        const icon = this.emojiDict[replacement.name];
        if (icon) {
          const validInlineEmojiRegEx = new RegExp(`(^|\\s)${this._escapeRegexp(replacement.shortcut)}$`);

          if (validInlineEmojiRegEx.test(textUntilCursor)) {
            this.emojiStartPosition = selection - replacement.shortcut.length + 1;
            this._enterEmoji(input, icon);

            return true;
          }
        }
      }
    }

    return false;
  }

  _replaceAllInlineEmoji(input) {
    if (!this.shouldReplaceEmoji) {
      return false;
    }

    const {selectionStart: selection, value: text} = input;
    let textBeforeCursor = text.substr(0, selection);
    let textAfterCursor = text.substr(selection);

    for (const replacement of EmojiInputViewModel.INLINE_REPLACEMENT) {
      const icon = this.emojiDict[replacement.name];

      if (icon) {
        const validIInlineEmojiRegex = new RegExp(`(^|\\s)${this._escapeRegexp(replacement.shortcut)}(?=\\s|$)`, 'g');
        textBeforeCursor = textBeforeCursor.replace(validIInlineEmojiRegex, `$1${icon}`);
        textAfterCursor = textAfterCursor.replace(validIInlineEmojiRegex, `$1${icon}`);
      }
    }

    input.value = `${textBeforeCursor}${textAfterCursor}`;
    input.setSelectionRange(textBeforeCursor.length, textBeforeCursor.length);
    $(input).change();
    $(input).focus();
  }

  _updateEmojiPopup(input) {
    const {selectionStart: selection, value: text} = input;
    if (!text) {
      return;
    }

    const query = text.substr(this.emojiStartPosition, selection - this.emojiStartPosition);
    if (!query.length) {
      return this._closeEmojiPopup();
    }

    const shouldRemovePopup = !this.emojiList.length || query.startsWith(' ') || /\s{2,}/.test(query);
    if (shouldRemovePopup) {
      return this.removeEmojiPopup();
    }

    const queryWords = query.split(' ');
    const expectedWords = (query.match(/\s/g) || []).length + 1;

    const emojiMatched = this.emojiList
      .filter(emoji => {
        const emojiNameWords = emoji.name.split(' ');

        if (emojiNameWords.length < expectedWords) {
          return false;
        }

        return queryWords.every(queryWord => {
          return emojiNameWords.some(emojiNameWord => emojiNameWord.startsWith(queryWord));
        });
      })
      .reduce((accumulator, emoji) => {
        const iconNotFound = !accumulator.find(item => item.icon === emoji.icon);
        if (iconNotFound) {
          accumulator.push(emoji);
        }
        return accumulator;
      }, [])
      .sort((emojiA, emojiB) => {
        const usageCountA = this._getUsageCount(emojiA.name);
        const usageCountB = this._getUsageCount(emojiB.name);

        const sameUsageCount = usageCountA === usageCountB;
        return sameUsageCount
          ? z.util.StringUtil.sortByPriority(emojiA.name, emojiB.name, query)
          : usageCountB - usageCountA;
      })
      .slice(0, EmojiInputViewModel.CONFIG.LIST.LENGTH)
      .map(emoji => {
        return `
          <div class='emoji'>
            <span class='symbol'>${emoji.icon}</span><span class='name'>${emoji.name}</span>
          </div>`;
      })
      .join('');

    if (emojiMatched === '') {
      return this._closeEmojiPopup();
    }

    window.addEventListener('click', this.removeEmojiPopup);
    this.isVisible = true;
    this.emojiDiv
      .html(emojiMatched)
      .appendTo('body')
      .show();
    this.emojiDiv.find('.emoji:nth(0)').addClass('selected');

    const position = z.util.popup.getCursorPixelPosition(input);
    const top = position.top - this.emojiDiv.height() - EmojiInputViewModel.CONFIG.LIST.OFFSET_TOP;
    const left = position.left - EmojiInputViewModel.CONFIG.LIST.OFFSET_LEFT;

    this.emojiDiv.css('left', left);
    this.emojiDiv.css('top', top);
  }

  _rotateEmojiPopup(backward) {
    const previous = this.emojiDiv.find('.emoji.selected');
    const newSelection = (previous.index() + (backward ? -1 : 1)) % this.emojiDiv.find('.emoji').length;
    previous.removeClass('selected');
    this.emojiDiv.find(`.emoji:nth(${newSelection})`).addClass('selected');
  }

  _enterEmojiPopupLine(input, emojiLine) {
    const emojiIcon = emojiLine.find('.symbol').text();
    const emojiName = emojiLine
      .find('.name')
      .text()
      .toLowerCase();

    this._enterEmoji(input, emojiIcon);
    this._increaseUsageCount(emojiName); // only emojis selected from the list should affect the count
  }

  _enterEmoji(input, emojiIcon) {
    const {selectionStart: selection, value: text} = input;

    const textBeforeEmoji = text.substr(0, this.emojiStartPosition - 1);
    const textAfterEmoji = text.substr(selection);
    const newCursorPosition = textBeforeEmoji.length + emojiIcon.length;
    input.value = `${textBeforeEmoji}${emojiIcon}${textAfterEmoji}`;
    input.setSelectionRange(newCursorPosition, newCursorPosition);
    this.removeEmojiPopup();
    $(input).change();
    $(input).focus();
  }

  _closeEmojiPopup() {
    this.isVisible = false;
    window.removeEventListener('click', this.removeEmojiPopup);
    this.emojiDiv.remove();
  }

  removeEmojiPopup() {
    this._closeEmojiPopup();
    this.emojiStartPosition = -1;
  }

  _getUsageCount(emojiName) {
    return this.emojiUsageCount[emojiName] || 0;
  }

  _increaseUsageCount(emojiName) {
    this.emojiUsageCount[emojiName] = this._getUsageCount(emojiName) + 1;
    z.util.StorageUtil.setValue(z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT, this.emojiUsageCount);
  }

  _escapeRegexp(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.GiphyViewModel = class GiphyViewModel {
  static get CONFIG() {
    return {
      NUMBER_OF_GIFS: 6,
    };
  }

  static get STATE() {
    return {
      DEFAULT: '',
      ERROR: 'GiphyViewModel.STATE.ERROR',
      LOADING: 'GiphyViewModel.STATE.LOADING',
      RESULT: 'GiphyViewModel.STATE.RESULT',
      RESULTS: 'GiphyViewModel.STATE.RESULTS',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.clickToSelectGif = this.clickToSelectGif.bind(this);

    this.conversationRepository = repositories.conversation;
    this.giphyRepository = repositories.giphy;
    this.logger = new z.util.Logger('z.viewModel.content.GiphyViewModel', z.config.LOGGER.OPTIONS);

    this.modal = undefined;
    this.state = ko.observable(GiphyViewModel.STATE.DEFAULT);
    this.query = ko.observable('');
    this.sendingGiphyMessage = false;

    // GIF presented in the single GIF view
    this.gif = ko.observable();

    // GIFs rendered in the modal
    this.gifs = ko.observableArray();

    // GIF selected by user or single GIF when in single GIF view
    this.selectedGif = ko.observable();

    this.isStateError = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.ERROR);
    this.isStateLoading = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.LOADING);
    this.isStateResult = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.RESULT);
    this.isStateResults = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.RESULTS);

    this.isResultState = ko.pureComputed(() => {
      return [GiphyViewModel.STATE.RESULT, GiphyViewModel.STATE.RESULTS].includes(this.state());
    });

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.EXTENSIONS.GIPHY.SHOW, this.showGiphy.bind(this));
  }

  clickOnBack() {
    this.gifs([this.gif()]);
    this.selectedGif(this.gif());
    this.state(GiphyViewModel.STATE.RESULT);
  }

  clickOnClose() {
    this.modal.hide();
  }

  clickOnTryAnother() {
    this._getRandomGif();
  }

  clickOnGrid() {
    this._getRandomGifs();
  }

  clickToSelectGif(clickedGif, event) {
    const hasMultipleGifs = this.gifs().length !== 1;
    if (hasMultipleGifs) {
      const gifItem = $(event.currentTarget);
      const gifItems = gifItem.parent().children();

      const remove_unselected = function() {
        $(this).removeClass('gif-container-item-unselected');
      };

      const add_unselected = function() {
        $(this).addClass('gif-container-item-unselected');
      };

      if (this.selectedGif() === clickedGif) {
        gifItems.each(remove_unselected);
        this.selectedGif(undefined);
      } else {
        gifItems.each(add_unselected);
        remove_unselected.apply(gifItem);
        this.selectedGif(clickedGif);
      }
    }
  }

  clickToSend() {
    if (this.selectedGif() && !this.sendingGiphyMessage) {
      const conversationEntity = this.conversationRepository.active_conversation();
      this.sendingGiphyMessage = true;

      this.conversationRepository.sendGif(conversationEntity, this.selectedGif().animated, this.query()).then(() => {
        this.sendingGiphyMessage = false;
        amplify.publish(z.event.WebApp.EXTENSIONS.GIPHY.SEND);
      });

      this.modal.hide();
    }
  }

  showGiphy(query) {
    this.sendingGiphyMessage = false;
    this.query(query);
    this.state(GiphyViewModel.STATE.DEFAULT);
    this._getRandomGif();

    if (!this.modal) {
      this.modal = new z.ui.Modal('#giphy-modal');
    }

    this.modal.show();
  }

  _clearGifs() {
    this.gifs.removeAll();
    this.selectedGif(undefined);
    this.state(GiphyViewModel.STATE.LOADING);
  }

  _getRandomGif() {
    const isStateError = this.state() === GiphyViewModel.STATE.ERROR;
    if (!isStateError) {
      this._clearGifs();

      this.giphyRepository
        .getRandomGif({tag: this.query()})
        .then(gif => {
          this.gif(gif);
          this.gifs([this.gif()]);
          this.selectedGif(this.gif());
          this.state(GiphyViewModel.STATE.RESULT);
        })
        .catch(error => {
          this.logger.error(`No gif found for query: ${this.query()}`, error);
          this.state(GiphyViewModel.STATE.ERROR);
        });
    }
  }

  _getRandomGifs() {
    const isStateError = this.state() === GiphyViewModel.STATE.ERROR;
    if (!isStateError) {
      this._clearGifs();

      this.giphyRepository
        .getGifs({
          number: GiphyViewModel.CONFIG.NUMBER_OF_GIFS,
          query: this.query(),
        })
        .then(gifs => {
          this.gifs(gifs);

          if (gifs.length === 1) {
            this.selectedGif(gifs[0]);
          }

          this.state(GiphyViewModel.STATE.RESULTS);
        })
        .catch(error => {
          this.logger.error(`No gifs found for query: ${this.query()}`, error);
          this.state(GiphyViewModel.STATE.ERROR);
        });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.GroupCreationViewModel = class GroupCreationViewModel {
  static get STATE() {
    return {
      DEFAULT: 'GroupCreationViewModel.STATE.DEFAULT',
      PARTICIPANTS: 'GroupCreationViewModel.STATE.PARTICIPANTS',
      PREFERENCES: 'GroupCreationViewModel.STATE.PREFERENCES',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.GroupCreationViewModel', z.config.LOGGER.OPTIONS);

    this.clickOnCreate = this.clickOnCreate.bind(this);
    this.clickOnToggleGuestMode = this.clickOnToggleGuestMode.bind(this);

    this.conversationRepository = repositories.conversation;
    this.searchRepository = repositories.search;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.isTeam = this.teamRepository.isTeam;

    this.modal = undefined;
    this.state = ko.observable(GroupCreationViewModel.STATE.DEFAULT);

    this.isCreatingConversation = false;
    this.method = undefined;
    this.nameError = ko.observable('');
    this.nameInput = ko.observable('');
    this.selectedContacts = ko.observableArray([]);
    this.showContacts = ko.observable(false);
    this.participantsInput = ko.observable('');

    this.accessState = ko.observable(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isGuestRoom = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isGuestRoom.subscribe(isGuestRoom => {
      if (!isGuestRoom) {
        this.selectedContacts.remove(userEntity => !userEntity.isTeamMember());
      }
    });

    this.activateNext = ko.pureComputed(() => this.nameInput().length);
    this.contacts = ko.pureComputed(() => {
      if (this.showContacts()) {
        if (!this.isTeam()) {
          return this.userRepository.connected_users();
        }

        if (this.isGuestRoom()) {
          return this.userRepository.teamUsers();
        }

        return this.teamRepository
          .teamMembers()
          .sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
      }
      return [];
    });
    this.participantsActionText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.groupCreationParticipantsActionCreate
        : z.string.groupCreationParticipantsActionSkip;
      return z.l10n.text(stringSelector);
    });
    this.participantsHeaderText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.groupCreationParticipantsHeaderWithCounter
        : z.string.groupCreationParticipantsHeader;
      return z.l10n.text(stringSelector, {number: this.selectedContacts().length});
    });
    this.stateIsPreferences = ko.pureComputed(() => this.state() === GroupCreationViewModel.STATE.PREFERENCES);
    this.stateIsParticipants = ko.pureComputed(() => this.state() === GroupCreationViewModel.STATE.PARTICIPANTS);

    this.nameInput.subscribe(() => this.nameError(''));
    this.stateIsPreferences.subscribe(stateIsPreference => {
      if (stateIsPreference) {
        return $(document).on('keydown.groupCreation', keyboardEvent => {
          if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
            this._hideModal();
          }
        });
      }
      return $(document).off('keydown.groupCreation');
    });
    this.stateIsParticipants.subscribe(stateIsParticipants => {
      if (stateIsParticipants) {
        return window.setTimeout(() => this.showContacts(true));
      }
      this.showContacts(false);
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedContacts() && this.stateIsPreferences() && this.contacts())
      .extend({notify: 'always', rateLimit: 500});

    amplify.subscribe(z.event.WebApp.CONVERSATION.CREATE_GROUP, this.showCreateGroup.bind(this));
  }

  showCreateGroup(method, userEntity) {
    this.method = method;

    if (!this.modal) {
      this.modal = new z.ui.Modal('#group-creation-modal', this._afterHideModal.bind(this));
      this.modal.setAutoclose(false);
    }

    this.state(GroupCreationViewModel.STATE.PREFERENCES);
    if (userEntity) {
      this.selectedContacts.push(userEntity);
    }

    this.modal.show();
    $('.group-creation-modal-teamname-input').focus();

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.OPENED_GROUP_CREATION, {
      method: this.method,
    });
  }

  clickOnBack() {
    this.state(GroupCreationViewModel.STATE.PREFERENCES);
  }

  clickOnClose() {
    this._hideModal();
  }

  clickOnToggleGuestMode() {
    const accessState = this.isGuestRoom()
      ? z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY
      : z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM;

    this.accessState(accessState);
  }

  clickOnCreate() {
    if (!this.isCreatingConversation) {
      this.isCreatingConversation = true;

      const accessState = this.isTeam() ? this.accessState() : undefined;

      this.conversationRepository
        .createGroupConversation(this.selectedContacts(), this.nameInput(), accessState)
        .then(conversationEntity => {
          this._hideModal();

          amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);

          this._trackGroupCreation(conversationEntity);
        })
        .catch(error => {
          this.isCreatingConversation = false;
          throw error;
        });
    }
  }

  clickOnNext() {
    if (this.nameInput().length) {
      const trimmedNameInput = this.nameInput().trim();
      const nameTooLong = trimmedNameInput.length > z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH;
      const nameTooShort = !trimmedNameInput.length;

      this.nameInput(trimmedNameInput.slice(0, z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH));
      if (nameTooLong) {
        return this.nameError(z.l10n.text(z.string.groupCreationPreferencesErrorNameLong));
      }

      if (nameTooShort) {
        return this.nameError(z.l10n.text(z.string.groupCreationPreferencesErrorNameShort));
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.OPENED_SELECT_PARTICIPANTS, {
        method: this.method,
      });

      this.state(GroupCreationViewModel.STATE.PARTICIPANTS);
    }
  }

  _afterHideModal() {
    this.isCreatingConversation = false;
    this.method = undefined;
    this.nameError('');
    this.nameInput('');
    this.participantsInput('');
    this.selectedContacts([]);
    this.state(GroupCreationViewModel.STATE.DEFAULT);
    this.accessState(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
  }

  _hideModal() {
    if (this.modal) {
      this.modal.hide();
    }
  }

  _trackGroupCreation(conversationEntity) {
    this._trackGroupCreationSucceeded(conversationEntity);
    this._trackAddParticipants(conversationEntity);
  }

  _trackGroupCreationSucceeded(conversationEntity) {
    const attributes = {
      method: this.method,
      with_participants: !!this.selectedContacts().length,
    };

    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      attributes.is_allow_guests = !conversationEntity.isTeamOnly();
    }

    const eventName = z.tracking.EventName.CONVERSATION.GROUP_CREATION_SUCCEEDED;
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, eventName, attributes);
  }

  _trackAddParticipants(conversationEntity) {
    const attributes = {
      method: 'create',
      user_num: conversationEntity.getNumberOfParticipants(),
    };

    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      const participants = z.tracking.helpers.getParticipantTypes(conversationEntity.participating_user_ets(), true);

      Object.assign(attributes, {
        guest_num: participants.guests,
        is_allow_guests: conversationEntity.isGuestRoom(),
        temporary_guest_num: participants.temporaryGuests,
        user_num: participants.users,
      });
    }

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.ADD_PARTICIPANTS, attributes);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.HistoryExportViewModel = class HistoryExportViewModel {
  static get STATE() {
    return {
      COMPRESSING: 'HistoryExportViewModel.STATE.COMPRESSING',
      DONE: 'HistoryExportViewModel.STATE.DONE',
      EXPORTING: 'HistoryExportViewModel.STATE.EXPORTING',
      PREPARING: 'HistoryExportViewModel.STATE.PREPARING',
    };
  }

  static get CONFIG() {
    return {
      FILE_EXTENSION: 'desktop_wbu',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.backupRepository = repositories.backup;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.HistoryExportViewModel', z.config.LOGGER.OPTIONS);

    this.hasError = ko.observable(false);
    this.state = ko.observable(HistoryExportViewModel.STATE.PREPARING);
    this.isPreparing = ko.pureComputed(() => {
      return !this.hasError() && this.state() === HistoryExportViewModel.STATE.PREPARING;
    });
    this.isExporting = ko.pureComputed(() => {
      const exportingStates = [HistoryExportViewModel.STATE.EXPORTING, HistoryExportViewModel.STATE.COMPRESSING];
      return !this.hasError() && exportingStates.includes(this.state());
    });
    this.isDone = ko.pureComputed(() => !this.hasError() && this.state() === HistoryExportViewModel.STATE.DONE);

    this.numberOfRecords = ko.observable(0);
    this.numberOfProcessedRecords = ko.observable(0);
    this.loadingProgress = ko.pureComputed(() => {
      return Math.floor((this.numberOfProcessedRecords() / this.numberOfRecords()) * 100);
    });

    this.archiveBlob = ko.observable(null);

    this.loadingMessage = ko.pureComputed(() => {
      switch (this.state()) {
        case HistoryExportViewModel.STATE.PREPARING: {
          return z.l10n.text(z.string.backupExportProgressHeadline);
        }
        case HistoryExportViewModel.STATE.EXPORTING: {
          const replacements = {
            processed: this.numberOfProcessedRecords(),
            progress: this.loadingProgress(),
            total: this.numberOfRecords(),
          };
          return z.l10n.text(z.string.backupExportProgressSecondary, replacements);
        }
        case HistoryExportViewModel.STATE.COMPRESSING: {
          return z.l10n.text(z.string.backupExportProgressCompressing);
        }
        default:
          return '';
      }
    });

    amplify.subscribe(z.event.WebApp.BACKUP.EXPORT.START, this.exportHistory.bind(this));
  }

  exportHistory() {
    this.state(HistoryExportViewModel.STATE.PREPARING);
    this.hasError(false);
    this.backupRepository.getBackupInitData().then(numberOfRecords => {
      this.logger.log(`Exporting '${numberOfRecords}' records from history`);

      this.numberOfRecords(numberOfRecords);
      this.numberOfProcessedRecords(0);

      this.backupRepository
        .generateHistory(this.onProgress.bind(this))
        .then(archive => {
          this.state(HistoryExportViewModel.STATE.COMPRESSING);
          return archive.generateAsync({compression: 'DEFLATE', type: 'blob'});
        })
        .then(archiveBlob => {
          this.onSuccess(archiveBlob);
          this.logger.log(`Completed export of '${numberOfRecords}' records from history`);
        })
        .catch(this.onError.bind(this));
    });
  }

  downloadArchiveFile() {
    const userName = this.userRepository.self().username();
    const fileExtension = HistoryExportViewModel.CONFIG.FILE_EXTENSION;
    const filename = `Wire-${userName}-Backup_${z.util.TimeUtil.getCurrentDate()}.${fileExtension}`;

    this.dismissExport();
    z.util.downloadBlob(this.archiveBlob(), filename, 'application/octet-stream');
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.BACKUP_SUCCEEDED);
  }

  onCancel() {
    this.backupRepository.cancelAction();
  }

  onProgress(processedNumber) {
    this.state(HistoryExportViewModel.STATE.EXPORTING);
    this.numberOfProcessedRecords(this.numberOfProcessedRecords() + processedNumber);
  }

  onError(error) {
    if (error instanceof z.backup.CancelError) {
      this.logger.log(`History export was cancelled`);
      return this.dismissExport();
    }
    this.hasError(true);
    this.logger.error(`Failed to export history: ${error.message}`, error);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.BACKUP_FAILED);
  }

  onSuccess(archiveBlob) {
    this.state(HistoryExportViewModel.STATE.DONE);
    this.hasError(false);
    this.archiveBlob(archiveBlob);
  }

  onTryAgain() {
    this.exportHistory();
  }

  dismissExport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.HistoryImportViewModel = class HistoryImportViewModel {
  static get STATE() {
    return {
      DONE: 'HistoryImportViewModel.STATE.DONE',
      IMPORTING: 'HistoryImportViewModel.STATE.IMPORTING',
      PREPARING: 'HistoryImportViewModel.STATE.PREPARING',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.backupRepository = repositories.backup;

    this.logger = new z.util.Logger('z.viewModel.content.HistoryExportViewModel', z.config.LOGGER.OPTIONS);

    this.error = ko.observable(null);
    this.errorHeadline = ko.observable('');
    this.errorSecondary = ko.observable('');

    this.state = ko.observable(HistoryImportViewModel.STATE.PREPARING);
    this.isPreparing = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.PREPARING);
    this.isImporting = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.IMPORTING);
    this.isDone = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.DONE);

    this.numberOfRecords = ko.observable(0);
    this.numberOfProcessedRecords = ko.observable(0);
    this.loadingProgress = ko.pureComputed(() => {
      return Math.floor((this.numberOfProcessedRecords() / this.numberOfRecords()) * 100);
    });

    this.loadingMessage = ko.pureComputed(() => {
      switch (this.state()) {
        case HistoryImportViewModel.STATE.PREPARING: {
          return z.l10n.text(z.string.backupImportProgressHeadline);
        }
        case HistoryImportViewModel.STATE.IMPORTING: {
          const replacements = {
            processed: this.numberOfProcessedRecords(),
            progress: this.loadingProgress(),
            total: this.numberOfRecords(),
          };
          return z.l10n.text(z.string.backupImportProgressSecondary, replacements);
        }
        default:
          return '';
      }
    });

    this.error.subscribe(error => {
      if (!error) {
        this.errorHeadline('');
        this.errorSecondary('');
      } else if (error instanceof z.backup.DifferentAccountError) {
        this.errorHeadline(z.l10n.text(z.string.backupImportAccountErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportAccountErrorSecondary));
      } else if (error instanceof z.backup.IncompatibleBackupError) {
        this.errorHeadline(z.l10n.text(z.string.backupImportVersionErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportVersionErrorSecondary));
      } else {
        this.errorHeadline(z.l10n.text(z.string.backupImportGenericErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportGenericErrorSecondary));
      }
    });

    amplify.subscribe(z.event.WebApp.BACKUP.IMPORT.START, this.importHistory.bind(this));
  }

  importHistory(file) {
    this.state(HistoryImportViewModel.STATE.PREPARING);
    this.error(null);
    JSZip.loadAsync(file)
      .then(archive => this.backupRepository.importHistory(archive, this.onInit.bind(this), this.onProgress.bind(this)))
      .then(this.onSuccess.bind(this))
      .catch(this.onError.bind(this));
  }

  onInit(numberOfRecords) {
    this.state(HistoryImportViewModel.STATE.IMPORTING);
    this.numberOfRecords(numberOfRecords);
    this.numberOfProcessedRecords(0);
  }

  onProgress(numberProcessed) {
    this.numberOfProcessedRecords(this.numberOfProcessedRecords() + numberProcessed);
  }

  onSuccess() {
    this.error(null);
    this.state(HistoryImportViewModel.STATE.DONE);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.RESTORE_SUCCEEDED);
    window.setTimeout(this.dismissImport.bind(this), z.motion.MotionDuration.X_LONG * 2);
  }

  onCancel() {
    this.backupRepository.cancelAction();
  }

  dismissImport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  onError(error) {
    if (error instanceof z.backup.CancelError) {
      this.logger.log(`History import was cancelled`);
      return this.dismissImport();
    }
    this.error(error);
    this.logger.error(`Failed to import history: ${error.message}`, error);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.RESTORE_FAILED);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.InputBarViewModel = class InputBarViewModel {
  static get CONFIG() {
    return {
      ASSETS: {
        CONCURRENT_UPLOAD_LIMIT: 10,
      },
      GIPHY_TEXT_LENGTH: 256,
      IMAGE: {
        FILE_TYPES: ['image/bmp', 'image/gif', 'image/jpeg', 'image/jpg', 'image/png', '.jpg-large'],
      },
      PING_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
    };
  }

  constructor(mainViewModel, contentViewModel, repositories, messageHasher) {
    this.addedToView = this.addedToView.bind(this);
    this.addMention = this.addMention.bind(this);
    this.clickToPing = this.clickToPing.bind(this);
    this.endMentionFlow = this.endMentionFlow.bind(this);
    this.onDropFiles = this.onDropFiles.bind(this);
    this.onPasteFiles = this.onPasteFiles.bind(this);
    this.onWindowClick = this.onWindowClick.bind(this);
    this.setElements = this.setElements.bind(this);
    this.updateSelectionState = this.updateSelectionState.bind(this);

    this.messageHasher = messageHasher;

    this.shadowInput = null;
    this.textarea = null;

    this.selectionStart = ko.observable(0);
    this.selectionEnd = ko.observable(0);

    this.emojiInput = contentViewModel.emojiInput;

    this.eventRepository = repositories.event;
    this.conversationRepository = repositories.conversation;
    this.searchRepository = repositories.search;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.InputBarViewModel', z.config.LOGGER.OPTIONS);

    this.conversationEntity = this.conversationRepository.active_conversation;
    this.selfUser = this.userRepository.self;

    this.conversationHasFocus = ko.observable(true).extend({notify: 'always'});

    this.editMessageEntity = ko.observable();
    this.replyMessageEntity = ko.observable();

    const handleRepliedMessageDeleted = messageId => {
      if (this.replyMessageEntity() && this.replyMessageEntity().id === messageId) {
        this.replyMessageEntity(undefined);
      }
    };

    const handleRepliedMessageUpdated = (originalMessageId, messageEntity) => {
      if (this.replyMessageEntity() && this.replyMessageEntity().id === originalMessageId) {
        this.replyMessageEntity(messageEntity);
      }
    };

    ko.pureComputed(() => !!this.replyMessageEntity())
      .extend({notify: 'always', rateLimit: 100})
      .subscribeChanged((isReplyingToMessage, wasReplyingToMessage) => {
        if (isReplyingToMessage !== wasReplyingToMessage) {
          this.triggerInputChangeEvent();
          if (isReplyingToMessage) {
            amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleRepliedMessageDeleted);
            amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleRepliedMessageUpdated);
          } else {
            amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleRepliedMessageDeleted);
            amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleRepliedMessageUpdated);
          }
        }
      });

    this.replyAsset = ko.pureComputed(() => {
      return this.replyMessageEntity() && this.replyMessageEntity().assets() && this.replyMessageEntity().assets()[0];
    });

    this.isEditing = ko.pureComputed(() => !!this.editMessageEntity());
    this.isReplying = ko.pureComputed(() => !!this.replyMessageEntity());
    this.replyMessageId = ko.pureComputed(() => (this.replyMessageEntity() ? this.replyMessageEntity().id : undefined));

    this.pastedFile = ko.observable();
    this.pastedFilePreviewUrl = ko.observable();
    this.pastedFileName = ko.observable();

    this.pingDisabled = ko.observable(false);

    this.editedMention = ko.observable(undefined);
    this.currentMentions = ko.observableArray();

    this.hasFocus = ko.pureComputed(() => this.isEditing() || this.conversationHasFocus()).extend({notify: 'always'});
    this.hasTextInput = ko.pureComputed(() => this.input().length);

    this.input = ko.observable('');

    this.input.subscribeChanged((newValue, oldValue) => {
      const difference = newValue.length - oldValue.length;
      const updatedMentions = this.updateMentionRanges(
        this.currentMentions(),
        this.selectionStart(),
        this.selectionEnd(),
        difference
      );
      this.currentMentions(updatedMentions);
      this.updateSelectionState();
    });

    this.draftMessage = ko
      .pureComputed(() => {
        const text = this.input();
        const mentions = this.currentMentions();
        const reply = this.replyMessageEntity();
        return {mentions, reply, text};
      })
      .extend({rateLimit: {method: 'notifyWhenChangesStop', timeout: 1}});

    this.mentionSuggestions = ko.pureComputed(() => {
      if (!this.editedMention() || !this.conversationEntity()) {
        return [];
      }

      const candidates = this.conversationEntity()
        .participating_user_ets()
        .filter(userEntity => !userEntity.isService);
      return this.searchRepository.searchUserInSet(this.editedMention().term, candidates);
    });

    this.richTextInput = ko.pureComputed(() => {
      const mentionAttributes = ' class="input-mention" data-uie-name="item-input-mention"';
      const pieces = this.currentMentions()
        .slice()
        .reverse()
        .reduce(
          (currentPieces, mentionEntity) => {
            const currentPiece = currentPieces.shift();
            currentPieces.unshift(currentPiece.substr(mentionEntity.endIndex));
            currentPieces.unshift(currentPiece.substr(mentionEntity.startIndex, mentionEntity.length));
            currentPieces.unshift(currentPiece.substr(0, mentionEntity.startIndex));
            return currentPieces;
          },
          [this.input()]
        );

      return pieces
        .map((piece, index) => {
          const textPiece = z.util.SanitizationUtil.escapeString(piece).replace(/[\r\n]/g, '<br>');
          return `<span${index % 2 ? mentionAttributes : ''}>${textPiece}</span>`;
        })
        .join('')
        .replace(/<br><\/span>$/, '<br>&nbsp;</span>');
    });

    this.richTextInput.subscribe(() => {
      if (this.textarea && this.shadowInput) {
        z.util.afterRender(() => {
          if (this.shadowInput.scrollTop !== this.textarea.scrollTop) {
            this.shadowInput.scrollTop = this.textarea.scrollTop;
          }
        });
      }
    });

    this.inputPlaceholder = ko.pureComputed(() => {
      if (this.showAvailabilityTooltip()) {
        const userEntity = this.conversationEntity().firstUserEntity();
        const availabilityStrings = {
          [z.user.AvailabilityType.AVAILABLE]: z.string.tooltipConversationInputPlaceholderAvailable,
          [z.user.AvailabilityType.AWAY]: z.string.tooltipConversationInputPlaceholderAway,
          [z.user.AvailabilityType.BUSY]: z.string.tooltipConversationInputPlaceholderBusy,
        };

        return z.l10n.text(availabilityStrings[userEntity.availability()], userEntity.first_name());
      }

      const stringId = this.conversationEntity().messageTimer()
        ? z.string.tooltipConversationEphemeral
        : z.string.tooltipConversationInputPlaceholder;

      return z.l10n.text(stringId);
    });

    this.showAvailabilityTooltip = ko.pureComputed(() => {
      if (this.conversationEntity() && this.conversationEntity().firstUserEntity()) {
        const isOne2OneConversation = this.conversationEntity().is1to1();
        const firstUserEntity = this.conversationEntity().firstUserEntity();
        const availabilityIsNone = firstUserEntity.availability() === z.user.AvailabilityType.NONE;
        return this.selfUser().inTeam() && isOne2OneConversation && !availabilityIsNone;
      }

      return false;
    });

    this.showGiphyButton = ko.pureComputed(() => {
      return this.hasTextInput() && this.input().length <= InputBarViewModel.CONFIG.GIPHY_TEXT_LENGTH;
    });

    const pingShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.PING);
    this.pingTooltip = z.l10n.text(z.string.tooltipConversationPing, pingShortcut);

    this.isEditing.subscribe(isEditing => {
      if (isEditing) {
        return window.addEventListener('click', this.onWindowClick);
      }

      window.removeEventListener('click', this.onWindowClick);
    });

    this.pastedFile.subscribe(blob => {
      if (blob) {
        const isSupportedFileType = InputBarViewModel.CONFIG.IMAGE.FILE_TYPES.includes(blob.type);
        if (isSupportedFileType) {
          this.pastedFilePreviewUrl(URL.createObjectURL(blob));
        }

        const date = moment(blob.lastModifiedDate).format('MMMM Do YYYY, h:mm:ss a');
        return this.pastedFileName(z.l10n.text(z.string.conversationSendPastedFile, date));
      }

      this.pastedFilePreviewUrl(null);
      this.pastedFileName(null);
    });

    this.hasLocalEphemeralTimer = ko.pureComputed(() => {
      const conversationEntity = this.conversationEntity();
      return conversationEntity.localMessageTimer() && !conversationEntity.hasGlobalMessageTimer();
    });

    this.conversationEntity.subscribe(this.loadInitialStateForConversation.bind(this));
    this.draftMessage.subscribe(message => {
      if (this.conversationEntity()) {
        this._saveDraftState(this.conversationEntity(), message.text, message.mentions, message.reply);
      }
    });

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.IMAGE.SEND, this.uploadImages.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.EDIT, this.editMessage.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, this.replyMessage.bind(this));
    amplify.subscribe(z.event.WebApp.EXTENSIONS.GIPHY.SEND, this.sendGiphy.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.SHOW, () => this.conversationHasFocus(false));
    amplify.subscribe(z.event.WebApp.SEARCH.HIDE, () => {
      window.requestAnimationFrame(() => this.conversationHasFocus(true));
    });
  }

  setElements(nodes) {
    this.textarea = nodes.find(node => node.id === 'conversation-input-bar-text');
    this.shadowInput = nodes.find(node => node.classList && node.classList.contains('shadow-input'));
    this.updateSelectionState();
  }

  loadInitialStateForConversation(conversationEntity) {
    this.conversationHasFocus(true);
    this.pastedFile(null);
    this.cancelMessageEditing();
    this.cancelMessageReply();
    this.endMentionFlow();

    if (conversationEntity) {
      const previousSessionData = this._loadDraftState(conversationEntity);
      this.input(previousSessionData.text);
      this.currentMentions(previousSessionData.mentions);

      if (previousSessionData.replyEntityPromise) {
        previousSessionData.replyEntityPromise.then(replyEntity => {
          if (replyEntity && replyEntity.isReplyable()) {
            this.replyMessageEntity(replyEntity);
          }
        });
      }
    }
  }

  _saveDraftState(conversationEntity, text, mentions, reply) {
    if (!this.isEditing()) {
      // we only save state for newly written messages
      reply = reply && reply.id ? {messageId: reply.id} : {};
      const storageKey = this._generateStorageKey(conversationEntity);
      z.util.StorageUtil.setValue(storageKey, {mentions, reply, text});
    }
  }

  _generateStorageKey(conversationEntity) {
    return `${z.storage.StorageKey.CONVERSATION.INPUT}|${conversationEntity.id}`;
  }

  _loadDraftState(conversationEntity) {
    const storageKey = this._generateStorageKey(conversationEntity);
    const storageValue = z.util.StorageUtil.getValue(storageKey);

    if (typeof storageValue === 'undefined') {
      return {mentions: [], reply: {}, text: ''};
    }

    if (typeof storageValue === 'string') {
      return {mentions: [], reply: {}, text: storageValue};
    }

    storageValue.mentions = storageValue.mentions.map(mention => {
      return new z.message.MentionEntity(mention.startIndex, mention.length, mention.userId);
    });

    const replyMessageId = storageValue.reply ? storageValue.reply.messageId : undefined;

    if (replyMessageId) {
      storageValue.replyEntityPromise = this.conversationRepository.get_message_in_conversation_by_id(
        conversationEntity,
        replyMessageId,
        false,
        true
      );
    }

    return storageValue;
  }

  _resetDraftState() {
    this.currentMentions.removeAll();
    this.input('');
  }

  _createMentionEntity(userEntity) {
    const mentionLength = userEntity.name().length + 1;
    return new z.message.MentionEntity(this.editedMention().startIndex, mentionLength, userEntity.id);
  }

  addMention(userEntity, inputElement) {
    const mentionEntity = this._createMentionEntity(userEntity);

    // keep track of what is before and after the mention being edited
    const beforeMentionPartial = this.input().slice(0, mentionEntity.startIndex);
    const afterMentionPartial = this.input()
      .slice(mentionEntity.startIndex + this.editedMention().term.length + 1)
      .replace(/^ /, '');

    // insert the mention in between
    this.input(`${beforeMentionPartial}@${userEntity.name()} ${afterMentionPartial}`);

    this.currentMentions.push(mentionEntity);
    this.currentMentions.sort((mentionA, mentionB) => mentionA.startIndex - mentionB.startIndex);

    const caretPosition = mentionEntity.endIndex + 1;
    inputElement.selectionStart = caretPosition;
    inputElement.selectionEnd = caretPosition;
    this.endMentionFlow();
  }

  endMentionFlow() {
    this.editedMention(undefined);
    this.updateSelectionState();
  }

  addedToView() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.PING, this.clickToPing);
  }

  cancelMessageEditing(resetDraft = true) {
    this.editMessageEntity(undefined);
    this.replyMessageEntity(undefined);
    if (resetDraft) {
      this._resetDraftState();
    }
  }

  cancelMessageReply(resetDraft = true) {
    this.replyMessageEntity(undefined);
    if (resetDraft) {
      this._resetDraftState();
    }
  }

  handleCancelReply() {
    if (!this.mentionSuggestions().length) {
      this.cancelMessageReply(false);
    }
    this.textarea.focus();
  }

  clickToCancelPastedFile() {
    this.pastedFile(null);
  }

  clickToShowGiphy() {
    amplify.publish(z.event.WebApp.EXTENSIONS.GIPHY.SHOW, this.input());
  }

  clickToPing() {
    if (this.conversationEntity() && !this.pingDisabled()) {
      this.pingDisabled(true);
      this.conversationRepository.sendKnock(this.conversationEntity()).then(() => {
        window.setTimeout(() => this.pingDisabled(false), InputBarViewModel.CONFIG.PING_TIMEOUT);
      });
    }
  }

  editMessage(messageEntity) {
    if (messageEntity && messageEntity.is_editable() && messageEntity !== this.editMessageEntity()) {
      this.cancelMessageReply();
      this.cancelMessageEditing();
      this.editMessageEntity(messageEntity);

      this.input(messageEntity.get_first_asset().text);
      const newMentions = messageEntity
        .get_first_asset()
        .mentions()
        .slice();
      this.currentMentions(newMentions);

      if (messageEntity.quote()) {
        this.conversationRepository
          .get_message_in_conversation_by_id(this.conversationEntity(), messageEntity.quote().messageId)
          .then(quotedMessage => this.replyMessageEntity(quotedMessage));
      }

      this._moveCursorToEnd();
    }
  }

  replyMessage(messageEntity) {
    if (messageEntity && messageEntity.isReplyable() && messageEntity !== this.replyMessageEntity()) {
      this.cancelMessageReply(false);
      this.cancelMessageEditing(!!this.editMessageEntity());
      this.replyMessageEntity(messageEntity);
      this.textarea.focus();
    }
  }

  onDropFiles(droppedFiles) {
    const images = [];
    const files = [];

    const tooManyConcurrentUploads = this._isHittingUploadLimit(droppedFiles);
    if (!tooManyConcurrentUploads) {
      Array.from(droppedFiles).forEach(file => {
        const isSupportedImage = InputBarViewModel.CONFIG.IMAGE.FILE_TYPES.includes(file.type);
        if (isSupportedImage) {
          return images.push(file);
        }
        files.push(file);
      });

      this.uploadImages(images);
      this.uploadFiles(files);
    }
  }

  onPasteFiles(pastedFiles) {
    const [pastedFile] = pastedFiles;
    this.pastedFile(pastedFile);
  }

  onWindowClick(event) {
    if (!$(event.target).closest('.conversation-input-bar, .conversation-input-bar-mention-suggestion').length) {
      this.cancelMessageEditing();
      this.cancelMessageReply();
    }
  }

  onInputEnter(data, event) {
    if (this.pastedFile()) {
      return this.sendPastedFile();
    }

    const beforeLength = this.input().length;
    const messageTrimmedStart = z.util.StringUtil.trimStart(this.input());
    const afterLength = messageTrimmedStart.length;

    const updatedMentions = this.updateMentionRanges(this.currentMentions(), 0, 0, afterLength - beforeLength);
    this.currentMentions(updatedMentions);

    const messageText = z.util.StringUtil.trimEnd(messageTrimmedStart);

    const isMessageTextTooLong = messageText.length > z.config.MAXIMUM_MESSAGE_LENGTH;
    if (isMessageTextTooLong) {
      return amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
        text: {
          message: z.l10n.text(z.string.modalConversationMessageTooLongMessage, z.config.MAXIMUM_MESSAGE_LENGTH),
          title: z.l10n.text(z.string.modalConversationMessageTooLongHeadline),
        },
      });
    }

    if (this.isEditing()) {
      this.sendMessageEdit(messageText, this.editMessageEntity(), this.replyMessageEntity());
    } else {
      this.sendMessage(messageText, this.replyMessageEntity());
    }

    this._resetDraftState();
    $(event.target).focus();
  }

  onInputKeyDown(data, keyboardEvent) {
    const inputHandledByEmoji = !this.editedMention() && this.emojiInput.onInputKeyDown(data, keyboardEvent);

    if (!inputHandledByEmoji) {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ARROW_UP: {
          if (!z.util.KeyboardUtil.isFunctionKey(keyboardEvent) && !this.input().length) {
            this.editMessage(this.conversationEntity().get_last_editable_message());
            this.updateMentions(data, keyboardEvent);
          }
          break;
        }

        case z.util.KeyboardUtil.KEY.ESC: {
          if (this.mentionSuggestions().length) {
            this.endMentionFlow();
          } else if (this.pastedFile()) {
            this.pastedFile(null);
          } else if (this.isEditing()) {
            this.cancelMessageEditing();
          } else if (this.isReplying()) {
            this.cancelMessageReply(false);
          }
          break;
        }

        case z.util.KeyboardUtil.KEY.ENTER: {
          if (keyboardEvent.altKey || keyboardEvent.metaKey) {
            z.util.KeyboardUtil.insertAtCaret(keyboardEvent.target, '\n');
            $(keyboardEvent.target).change();
            keyboardEvent.preventDefault();
          }
          break;
        }

        default:
          break;
      }

      return true;
    }
  }

  /**
   * Returns a term which is a mention match together with its starting position.
   * If nothing could be matched, it returns `undefined`.
   *
   * @param {number} selectionStart - Current caret position or start of selection  (if text is marked)
   * @param {number} selectionEnd - Current caret position or end of selection (if text is marked)
   * @param {string} value - Text input
   * @returns {undefined|{startIndex: number, term: string}} Matched mention info
   */
  getMentionCandidate(selectionStart, selectionEnd, value) {
    const textInSelection = value.substring(selectionStart, selectionEnd);
    const wordBeforeSelection = value.substring(0, selectionStart).replace(/[^]*\s/, '');
    const isSpaceSelected = /\s/.test(textInSelection);

    const startOffset = wordBeforeSelection.length ? wordBeforeSelection.length - 1 : 1;
    const isSelectionStartMention = this.findMentionAtPosition(selectionStart - startOffset, this.currentMentions());
    const isSelectionEndMention = this.findMentionAtPosition(selectionEnd, this.currentMentions());
    const isOverMention = isSelectionStartMention || isSelectionEndMention;
    const isOverValidMentionString = /^@\S*$/.test(wordBeforeSelection);

    if (!isSpaceSelected && !isOverMention && isOverValidMentionString) {
      const wordAfterSelection = value.substring(selectionEnd).replace(/\s[^]*/, '');

      const term = `${wordBeforeSelection.replace(/^@/, '')}${textInSelection}${wordAfterSelection}`;
      const startIndex = selectionStart - wordBeforeSelection.length;
      return {startIndex, term};
    }

    return undefined;
  }

  handleMentionFlow() {
    const {selectionStart, selectionEnd, value} = this.textarea;
    const mentionCandidate = this.getMentionCandidate(selectionStart, selectionEnd, value);
    this.editedMention(mentionCandidate);
    this.updateSelectionState();
  }

  updateSelectionState() {
    if (!this.textarea) {
      return;
    }
    const {selectionStart, selectionEnd} = this.textarea;
    const defaultRange = {endIndex: 0, startIndex: Infinity};

    const firstMention = this.findMentionAtPosition(selectionStart, this.currentMentions()) || defaultRange;
    const lastMention = this.findMentionAtPosition(selectionEnd, this.currentMentions()) || defaultRange;

    const mentionStart = Math.min(firstMention.startIndex, lastMention.startIndex);
    const mentionEnd = Math.max(firstMention.endIndex, lastMention.endIndex);

    const newStart = Math.min(mentionStart, selectionStart);
    const newEnd = Math.max(mentionEnd, selectionEnd);
    if (newStart !== selectionStart || newEnd !== selectionEnd) {
      this.textarea.selectionStart = newStart;
      this.textarea.selectionEnd = newEnd;
    }
    this.selectionStart(newStart);
    this.selectionEnd(newEnd);
  }

  updateMentions(data, event) {
    const textarea = event.target;
    const value = textarea.value;
    const previousValue = this.input();

    const lengthDifference = value.length - previousValue.length;
    const edgeMention = this.detectMentionEdgeDeletion(textarea, lengthDifference);
    if (edgeMention) {
      textarea.value = this.input();
      textarea.selectionStart = edgeMention.startIndex;
      textarea.selectionEnd = edgeMention.endIndex;
    }
  }

  detectMentionEdgeDeletion(textarea, lengthDifference) {
    const hadSelection = this.selectionStart() !== this.selectionEnd();
    if (hadSelection) {
      return null;
    }
    if (lengthDifference >= 0) {
      return null;
    }
    const currentSelectionStart = textarea.selectionStart;
    const forwardDeleted = currentSelectionStart === this.selectionStart();
    const checkPosition = forwardDeleted ? currentSelectionStart + 1 : currentSelectionStart;
    return this.findMentionAtPosition(checkPosition, this.currentMentions());
  }

  updateMentionRanges(mentions, start, end, difference) {
    const remainingMentions = mentions.filter(({startIndex, endIndex}) => endIndex <= start || startIndex >= end);

    remainingMentions.forEach(mention => {
      if (mention.startIndex >= end) {
        mention.startIndex += difference;
      }
    });

    return remainingMentions;
  }

  findMentionAtPosition(position, mentions) {
    return mentions.find(({startIndex, endIndex}) => position > startIndex && position < endIndex);
  }

  onInputKeyUp(data, keyboardEvent) {
    if (!this.editedMention()) {
      this.emojiInput.onInputKeyUp(data, keyboardEvent);
    }
    if (keyboardEvent.key !== z.util.KeyboardUtil.KEY.ESC) {
      this.handleMentionFlow();
    }
  }

  removedFromView() {
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.PING);
  }

  triggerInputChangeEvent(newInputHeight = 0, previousInputHeight = 0) {
    amplify.publish(z.event.WebApp.INPUT.RESIZE, newInputHeight - previousInputHeight);
  }

  sendGiphy() {
    this._resetDraftState();
  }

  _generateQuote(replyMessageEntity) {
    return !replyMessageEntity
      ? Promise.resolve()
      : this.eventRepository
          .loadEvent(replyMessageEntity.conversation_id, replyMessageEntity.id)
          .then(this.messageHasher.hashEvent)
          .then(messageHash => {
            return new z.message.QuoteEntity({
              hash: messageHash,
              messageId: replyMessageEntity.id,
              userId: replyMessageEntity.from,
            });
          });
  }

  sendMessage(messageText, replyMessageEntity) {
    if (messageText.length) {
      const mentionEntities = this.currentMentions.slice();

      this._generateQuote(replyMessageEntity).then(quoteEntity => {
        this.conversationRepository.sendTextWithLinkPreview(
          this.conversationEntity(),
          messageText,
          mentionEntities,
          quoteEntity
        );
        this.cancelMessageReply();
      });
    }
  }

  sendMessageEdit(messageText, messageEntity, replyMessageEntity) {
    const mentionEntities = this.currentMentions.slice();
    this.cancelMessageEditing();

    if (!messageText.length) {
      return this.conversationRepository.deleteMessageForEveryone(this.conversationEntity(), messageEntity);
    }

    this.conversationRepository
      .sendMessageEdit(this.conversationEntity(), messageText, messageEntity, mentionEntities)
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.NO_MESSAGE_CHANGES) {
          throw error;
        }
      });
    this.cancelMessageReply();
  }

  sendPastedFile() {
    this.onDropFiles([this.pastedFile()]);
    this.pastedFile(null);
  }

  /**
   * Post images to a conversation.
   * @param {Array|FileList} images - Images
   * @returns {undefined} No return value
   */
  uploadImages(images) {
    if (!this._isHittingUploadLimit(images)) {
      for (const image of Array.from(images)) {
        const isTooLarge = image.size > z.config.MAXIMUM_IMAGE_FILE_SIZE;
        if (isTooLarge) {
          return this._showUploadWarning(image);
        }
      }

      this.conversationRepository.upload_images(this.conversationEntity(), images);
    }
  }

  /**
   * Post files to a conversation.
   * @param {Array|FileList} files - Images
   * @returns {undefined} No return value
   */
  uploadFiles(files) {
    const uploadLimit = this.selfUser().inTeam()
      ? z.config.MAXIMUM_ASSET_FILE_SIZE_TEAM
      : z.config.MAXIMUM_ASSET_FILE_SIZE_PERSONAL;
    if (!this._isHittingUploadLimit(files)) {
      for (const file of Array.from(files)) {
        const isTooLarge = file.size > uploadLimit;
        if (isTooLarge) {
          const fileSize = z.util.formatBytes(uploadLimit);
          const options = {
            text: {
              message: z.l10n.text(z.string.modalAssetTooLargeMessage, fileSize),
              title: z.l10n.text(z.string.modalAssetTooLargeHeadline),
            },
          };

          return amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, options);
        }
      }

      this.conversationRepository.upload_files(this.conversationEntity(), files);
    }
  }

  _isHittingUploadLimit(files) {
    const concurrentUploadLimit = InputBarViewModel.CONFIG.ASSETS.CONCURRENT_UPLOAD_LIMIT;
    const concurrentUploads = files.length + this.conversationRepository.get_number_of_pending_uploads();
    const isHittingUploadLimit = concurrentUploads > InputBarViewModel.CONFIG.ASSETS.CONCURRENT_UPLOAD_LIMIT;

    if (isHittingUploadLimit) {
      const modalOptions = {
        text: {
          message: z.l10n.text(z.string.modalAssetParallelUploadsMessage, concurrentUploadLimit),
          title: z.l10n.text(z.string.modalAssetParallelUploadsHeadline),
        },
      };

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
    }

    return isHittingUploadLimit;
  }

  _moveCursorToEnd() {
    z.util.afterRender(() => {
      if (this.textarea) {
        const endPosition = this.textarea.value.length;
        this.textarea.setSelectionRange(endPosition, endPosition);
        this.updateSelectionState();
      }
    });
  }

  _showUploadWarning(image) {
    const isGif = image.type === 'image/gif';
    const messageStringId = isGif ? z.string.modalGifTooLargeMessage : z.string.modalPictureTooLargeMessage;
    const titleStringId = isGif ? z.string.modalGifTooLargeHeadline : z.string.modalPictureTooLargeHeadline;

    const modalOptions = {
      text: {
        message: z.l10n.text(messageStringId, z.config.MAXIMUM_IMAGE_FILE_SIZE / 1024 / 1024),
        title: z.l10n.text(titleStringId),
      },
    };

    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

/**
 * Message list rendering view model.
 *
 * @todo Get rid of the participants dependencies whenever bubble implementation has changed
 * @todo Remove all jquery selectors
 */
z.viewModel.content.MessageListViewModel = class MessageListViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this._scrollAddedMessagesIntoView = this._scrollAddedMessagesIntoView.bind(this);
    this.click_on_cancel_request = this.click_on_cancel_request.bind(this);
    this.click_on_like = this.click_on_like.bind(this);
    this.clickOnInvitePeople = this.clickOnInvitePeople.bind(this);
    this.get_timestamp_class = this.get_timestamp_class.bind(this);
    this.handleClickOnMessage = this.handleClickOnMessage.bind(this);
    this.is_last_delivered_message = this.is_last_delivered_message.bind(this);
    this.on_session_reset_click = this.on_session_reset_click.bind(this);
    this.should_hide_user_avatar = this.should_hide_user_avatar.bind(this);
    this.showUserDetails = this.showUserDetails.bind(this);
    this._handleWindowResize = this._handleWindowResize.bind(this);
    this.focusMessage = this.focusMessage.bind(this);
    this.showParticipants = this.showParticipants.bind(this);
    this.show_detail = this.show_detail.bind(this);

    this.mainViewModel = mainViewModel;
    this.conversation_repository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.locationRepository = repositories.location;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.MessageListViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;
    this.selfUser = this.userRepository.self;

    this.conversation = ko.observable(new z.entity.Conversation());
    this.verticallyCenterMessage = ko.pureComputed(() => {
      if (this.conversation().messages_visible().length === 1) {
        const [messageEntity] = this.conversation().messages_visible();
        return messageEntity.is_member() && messageEntity.isConnection();
      }
    });

    amplify.subscribe(z.event.WebApp.INPUT.RESIZE, this._handleInputResize.bind(this));

    this.conversationLoaded = ko.observable(false);
    // Store last read to show until user switches conversation
    this.conversation_last_read_timestamp = ko.observable(undefined);

    // Store conversation to mark as read when browser gets focus
    this.mark_as_read_on_focus = undefined;

    // Can be used to prevent scroll handler from being executed (e.g. when using scrollTop())
    this.capture_scrolling_event = false;

    // Store message subscription id
    this.messagesChangeSubscription = undefined;
    this.messagesBeforeChangeSubscription = undefined;

    this.onMouseWheel = _.throttle((data, event) => {
      const element = $(event.currentTarget);
      if (element.isScrollable()) {
        // if the element is scrollable, the scroll event will take the relay
        return true;
      }
      const isScrollingUp = event.deltaY > 0;
      const loadExtraMessagePromise = isScrollingUp ? this._loadPrecedingMessages() : this._loadFollowingMessages();

      loadExtraMessagePromise.then(() => {
        const antiscroll = $('.message-list').data('antiscroll');
        if (antiscroll) {
          antiscroll.rebuild();
        }
      });

      return true;
    }, 50);

    this.onScroll = _.throttle((data, event) => {
      if (!this.capture_scrolling_event) {
        return;
      }
      const element = $(event.currentTarget);

      // On some HDPI screen scrollTop returns a floating point number instead of an integer
      // https://github.com/jquery/api.jquery.com/issues/608
      const scrollPosition = Math.ceil(element.scrollTop());
      const scrollEnd = element.scrollEnd();
      const hitTop = scrollPosition <= 0;
      const hitBottom = scrollPosition >= scrollEnd;

      if (hitTop) {
        return this._loadPrecedingMessages();
      }

      if (hitBottom) {
        this._loadFollowingMessages().then(() => {
          this._mark_conversation_as_read_on_focus(this.conversation());
        });
      }
    }, 100);

    this.messagesContainer = undefined;

    $(window).on('focus', () => {
      if (this.mark_as_read_on_focus) {
        window.setTimeout(() => {
          this.conversation_repository.markAsRead(this.mark_as_read_on_focus);
          this.mark_as_read_on_focus = undefined;
        }, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      }
    });

    this.showInvitePeople = ko.pureComputed(() => {
      return (
        this.conversation().isActiveParticipant() && this.conversation().inTeam() && this.conversation().isGuestRoom()
      );
    });
  }

  /**
   * Mark conversation as read if window has focus
   * @param {z.entity.Conversation} conversation_et - Conversation entity to mark as read
   * @returns {undefined} No return value
   */
  _mark_conversation_as_read_on_focus(conversation_et) {
    if (document.hasFocus()) {
      return this.conversation_repository.markAsRead(conversation_et);
    }
    this.mark_as_read_on_focus = conversation_et;
  }

  /**
   * Remove all subscriptions and reset states.
   * @param {z.entity.Conversation} [conversation_et] - Conversation entity to change to
   * @returns {undefined} No return value
   */
  release_conversation(conversation_et) {
    if (conversation_et) {
      conversation_et.release();
    }
    if (this.messagesBeforeChangeSubscription) {
      this.messagesBeforeChangeSubscription.dispose();
    }
    if (this.messagesChangeSubscription) {
      this.messagesChangeSubscription.dispose();
    }
    this.capture_scrolling_event = false;
    this.conversation_last_read_timestamp(false);
    this.messagesContainer = undefined;
    window.removeEventListener('resize', this._handleWindowResize);
  }

  _shouldStickToBottom() {
    const messagesContainer = this._getMessagesContainer();
    const scrollPosition = Math.ceil(messagesContainer.scrollTop());
    const scrollEnd = Math.ceil(messagesContainer.scrollEnd());
    return scrollPosition > scrollEnd - z.config.SCROLL_TO_LAST_MESSAGE_THRESHOLD;
  }

  _handleWindowResize() {
    if (this._shouldStickToBottom()) {
      this._getMessagesContainer().scrollToBottom();
    }
  }

  _handleInputResize(inputSizeDiff) {
    const antiscroll = $('.message-list').data('antiscroll');
    if (antiscroll) {
      antiscroll.rebuild();
    }

    if (inputSizeDiff) {
      this._getMessagesContainer().scrollBy(inputSizeDiff);
    } else if (this._shouldStickToBottom()) {
      this._getMessagesContainer().scrollToBottom();
    }
  }

  /**
   * Change conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to change to
   * @param {z.entity.Message} messageEntity - message to be focused
   * @returns {Promise} Resolves when conversation was changed
   */
  changeConversation(conversationEntity, messageEntity) {
    // Clean up old conversation
    this.conversationLoaded(false);
    if (this.conversation()) {
      this.release_conversation(this.conversation());
    }

    // Update new conversation
    this.conversation(conversationEntity);

    // Keep last read timestamp to render unread when entering conversation
    if (this.conversation().unreadState().allEvents.length) {
      this.conversation_last_read_timestamp(this.conversation().last_read_timestamp());
    }

    conversationEntity.is_loaded(false);
    return this._loadConversation(conversationEntity, messageEntity)
      .then(() => this._renderConversation(conversationEntity, messageEntity))
      .then(() => {
        conversationEntity.is_loaded(true);
        this.conversationLoaded(true);
      });
  }

  _loadConversation(conversationEntity, messageEntity) {
    return this.conversation_repository
      .updateParticipatingUserEntities(conversationEntity, false, true)
      .then(_conversationEntity => {
        return messageEntity
          ? this.conversation_repository.getMessagesWithOffset(_conversationEntity, messageEntity)
          : this.conversation_repository.getPrecedingMessages(_conversationEntity);
      });
  }

  _conversationHasExtraMessages(conversationEntity) {
    const lastMessageEntity = conversationEntity.getLastMessage();
    if (!lastMessageEntity) {
      return false;
    }

    const isLastConversationEvent = lastMessageEntity.timestamp() >= this.conversation().last_event_timestamp();
    return !isLastConversationEvent && lastMessageEntity.timestamp();
  }

  _getMessagesContainer() {
    if (!this.messagesContainer) {
      this.messagesContainer = $('.messages-wrap');
    }
    return this.messagesContainer;
  }

  /**
   * Sets the conversation and waits for further processing until knockout has rendered the messages.
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to set
   * @param {z.entity.Message} messageEntity - Message that should be in focus when the conversation loads
   * @returns {Promise} Resolves when conversation was rendered
   */
  _renderConversation(conversationEntity, messageEntity) {
    const messages_container = this._getMessagesContainer();

    const is_current_conversation = conversationEntity === this.conversation();
    if (!is_current_conversation) {
      this.logger.info(`Skipped re-loading current conversation '${conversationEntity.display_name()}'`);
      return Promise.resolve();
    }

    return new Promise(resolve => {
      window.setTimeout(() => {
        // Reset scroll position
        messages_container.scrollTop(0);

        if (messageEntity) {
          this.focusMessage(messageEntity.id);
        } else {
          const unread_message = $('.message-timestamp-unread');
          if (unread_message.length) {
            const unreadMarkerPosition = unread_message.parents('.message').position();

            messages_container.scrollBy(unreadMarkerPosition.top);
          } else {
            messages_container.scrollToBottom();
          }
        }

        if (!messages_container.isScrollable() && !this._conversationHasExtraMessages(this.conversation())) {
          this._mark_conversation_as_read_on_focus(this.conversation());
        }

        this.capture_scrolling_event = true;
        window.addEventListener('resize', this._handleWindowResize);

        let shouldStickToBottomOnMessageAdd;

        this.messagesBeforeChangeSubscription = conversationEntity.messages_visible.subscribe(
          () => {
            // we need to keep track of the scroll position before the message array has changed
            shouldStickToBottomOnMessageAdd = this._shouldStickToBottom();
          },
          null,
          'beforeChange'
        );

        // Subscribe for incoming messages
        this.messagesChangeSubscription = conversationEntity.messages_visible.subscribe(
          changedMessages => {
            this._scrollAddedMessagesIntoView(changedMessages, shouldStickToBottomOnMessageAdd);
            shouldStickToBottomOnMessageAdd = undefined;
          },
          null,
          'arrayChange'
        );
        resolve();
      }, 100);
    });
  }

  /**
   * Checks how to scroll message list and if conversation should be marked as unread.
   * @param {Array} changedMessages - List of the messages that were added or removed from the list
   * @param {boolean} shouldStickToBottom - should the list stick to the bottom
   * @returns {undefined} No return value
   */
  _scrollAddedMessagesIntoView(changedMessages, shouldStickToBottom) {
    const messages_container = this._getMessagesContainer();
    const lastAddedItem = changedMessages
      .slice()
      .reverse()
      .find(changedMessage => changedMessage.status === 'added');

    // We are only interested in items that were added
    if (!lastAddedItem) {
      return;
    }

    const lastMessage = lastAddedItem.value;

    if (lastMessage) {
      // Message was prepended
      if (lastMessage.timestamp() < this.conversation().last_event_timestamp()) {
        return;
      }

      // Scroll to bottom if self user send the message
      if (lastMessage.from === this.selfUser().id) {
        window.requestAnimationFrame(() => messages_container.scrollToBottom());
        return;
      }
    }

    // Scroll to the end of the list if we are under a certain threshold
    if (shouldStickToBottom) {
      window.requestAnimationFrame(() => messages_container.scrollToBottom());

      if (document.hasFocus()) {
        this.conversation_repository.markAsRead(this.conversation());
      }
    }

    // Mark as read when conversation is not scrollable
    if (!messages_container.isScrollable()) {
      this._mark_conversation_as_read_on_focus(this.conversation());
    }
  }

  /**
   * Fetch older messages beginning from the oldest message in view
   * @returns {Promise<any>} A promise that resolves when the loading is done
   */
  _loadPrecedingMessages() {
    const shouldPullMessages = !this.conversation().is_pending() && this.conversation().hasAdditionalMessages();
    const [messagesContainer] = this._getMessagesContainer().children();

    if (shouldPullMessages && messagesContainer) {
      const initialListHeight = messagesContainer.scrollHeight;

      this.capture_scrolling_event = false;
      return this.conversation_repository.getPrecedingMessages(this.conversation()).then(() => {
        if (messagesContainer) {
          const newListHeight = messagesContainer.scrollHeight;
          this._getMessagesContainer().scrollTop(newListHeight - initialListHeight);
          this.capture_scrolling_event = true;
        }
      });
    }
    return Promise.resolve();
  }

  /**
   * Fetch newer messages beginning from the newest message in view
   * @returns {Promise<any>} A promise that resolves when the loading is done
   */
  _loadFollowingMessages() {
    const last_message = this.conversation().getLastMessage();

    if (last_message && this._conversationHasExtraMessages(this.conversation())) {
      this.capture_scrolling_event = false;
      return this.conversation_repository
        .getSubsequentMessages(this.conversation(), last_message, false)
        .then(message_ets => {
          this.capture_scrolling_event = true;
        });
    }
    return Promise.resolve();
  }

  /**
   * Scroll to given message in the list.
   *
   * @note Ideally message is centered horizontally
   * @param {string} messageId - Target message's id
   * @returns {undefined} No return value
   */
  focusMessage(messageId) {
    const messageIsLoaded = !!this.conversation().getMessage(messageId);
    const conversationEntity = this.conversation();

    const loadMessagePromise = messageIsLoaded
      ? Promise.resolve()
      : this.conversation_repository
          .get_message_in_conversation_by_id(conversationEntity, messageId)
          .then(messageEntity => {
            conversationEntity.remove_messages();
            return this.conversation_repository.getMessagesWithOffset(conversationEntity, messageEntity);
          });

    loadMessagePromise.then(() => {
      z.util.afterRender(() => {
        const messagesContainer = this._getMessagesContainer();
        const messageElement = messagesContainer.find(`.message[data-uie-uid="${messageId}"]`);

        if (messageElement.length) {
          messageElement.removeClass('message-marked');
          messagesContainer.scrollBy(messageElement.offset().top - messagesContainer.height() / 2);
          messageElement.addClass('message-marked');
        }
      });
    });
  }

  /**
   * Triggered when user clicks on an avatar in the message list.
   * @param {z.entity.User} userEntity - User entity of the selected user
   * @returns {undefined} No return value
   */
  showUserDetails(userEntity) {
    userEntity = ko.unwrap(userEntity);
    const conversationEntity = this.conversation_repository.active_conversation();
    const isSingleModeConversation = conversationEntity.is1to1() || conversationEntity.isRequest();

    if (isSingleModeConversation && !userEntity.is_me) {
      return this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.CONVERSATION_DETAILS);
    }

    const params = {entity: userEntity};
    const panelId = userEntity.isService
      ? z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE
      : z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER;

    this.mainViewModel.panel.togglePanel(panelId, params);
  }

  /**
   * Triggered when user clicks on the session reset link in a decrypt error message.
   * @param {z.entity.DecryptErrorMessage} message_et - Decrypt error message
   * @returns {undefined} No return value
   */
  on_session_reset_click(message_et) {
    const reset_progress = () =>
      window.setTimeout(() => {
        message_et.is_resetting_session(false);
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.SESSION_RESET);
      }, z.motion.MotionDuration.LONG);

    message_et.is_resetting_session(true);
    this.conversation_repository
      .reset_session(message_et.from, message_et.client_id, this.conversation().id)
      .then(() => reset_progress())
      .catch(() => reset_progress());
  }

  /**
   * Shows detail image view.
   *
   * @param {z.entity.Message} message_et - Message with asset to be displayed
   * @param {UIEvent} event - Actual scroll event
   * @returns {undefined} No return value
   */
  show_detail(message_et, event) {
    if (message_et.is_expired() || $(event.currentTarget).hasClass('image-loading')) {
      return;
    }

    this.conversation_repository
      .get_events_for_category(this.conversation(), z.message.MessageCategory.IMAGE)
      .then(items => {
        const message_ets = items.filter(
          item => item.category & z.message.MessageCategory.IMAGE && !(item.category & z.message.MessageCategory.GIF)
        );
        const [image_message_et] = message_ets.filter(item => item.id === message_et.id);

        amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, image_message_et || message_et, message_ets);
      });
  }

  get_timestamp_class(message_et) {
    const last_message = this.conversation().get_previous_message(message_et);
    if (last_message) {
      if (message_et.is_call()) {
        return '';
      }

      if (last_message.timestamp() === this.conversation_last_read_timestamp()) {
        return 'message-timestamp-visible message-timestamp-unread';
      }

      const last = moment(last_message.timestamp());
      const current = moment(message_et.timestamp());

      if (!last.isSame(current, 'day')) {
        return 'message-timestamp-visible message-timestamp-day';
      }

      if (current.diff(last, 'minutes') > 60) {
        return 'message-timestamp-visible';
      }
    }
  }

  /**
   * Checks its older neighbor in order to see if the avatar should be rendered or not
   * @param {z.entity.Message} message_et - Message to check
   * @returns {boolean} Should user avatar be hidden
   */
  should_hide_user_avatar(message_et) {
    // @todo avoid double check
    if (this.get_timestamp_class(message_et)) {
      return false;
    }

    if (message_et.is_content() && message_et.replacing_message_id) {
      return false;
    }

    const last_message = this.conversation().get_previous_message(message_et);
    return last_message && last_message.is_content() && last_message.user().id === message_et.user().id;
  }

  /**
   * Checks if the given message is the last delivered one
   * @param {z.entity.Message} message_et - Message to check
   * @returns {boolean} Message is last delivered one
   */
  is_last_delivered_message(message_et) {
    return this.conversation().getLastDeliveredMessage() === message_et;
  }

  click_on_cancel_request(messageEntity) {
    const conversationEntity = this.conversation_repository.active_conversation();
    const nextConversationEntity = this.conversation_repository.get_next_conversation(conversationEntity);
    this.actionsViewModel.cancelConnectionRequest(messageEntity.otherUser(), true, nextConversationEntity);
  }

  click_on_like(message_et, button = true) {
    this.conversation_repository.toggle_like(this.conversation(), message_et, button);
  }

  clickOnInvitePeople() {
    this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.GUEST_OPTIONS);
  }

  /**
   * Message appeared in viewport.
   * @param {z.entity.Message} messageEntity - Message to check
   * @returns {boolean} Message is in viewport
   */
  getInViewportCallback(messageEntity) {
    if (!messageEntity.is_ephemeral()) {
      const isCreationMessage = messageEntity.is_member() && messageEntity.isCreation();
      if (this.conversation().is1to1() && isCreationMessage) {
        this.integrationRepository.addProviderNameToParticipant(messageEntity.otherUser());
      }
      return null;
    }

    return () => {
      const startTimer = () => {
        if (messageEntity.conversation_id === this.conversation().id) {
          this.conversation_repository.checkMessageTimer(messageEntity);
        }
      };
      return document.hasFocus() ? startTimer() : $(window).one('focus', startTimer);
    };
  }

  handleClickOnMessage(messageEntity, event) {
    const hasMentions = messageEntity.mentions().length;
    const mentionElement = hasMentions && event.target.closest('.message-mention');
    const userId = mentionElement && mentionElement.dataset.userId;

    if (userId) {
      this.userRepository
        .get_user_by_id(userId)
        .then(userEntity => this.showUserDetails(userEntity))
        .catch(error => {
          if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
            throw error;
          }
        });
    }

    // need to return `true` because knockout will prevent default if we return anything else (including undefined)
    return true;
  }

  showParticipants(participants) {
    this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.CONVERSATION_PARTICIPANTS, participants);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAboutViewModel = class PreferencesAboutViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAboutViewModel', z.config.LOGGER.OPTIONS);

    this.userRepository = repositories.user;
    this.selfUser = this.userRepository.self;
  }

  clickOnToU() {
    const path = `${z.config.URL_PATH.TERMS_OF_USE}${this.selfUser().inTeam() ? 'teams' : 'personal'}/`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAccountViewModel = class PreferencesAccountViewModel {
  static get CONFIG() {
    return {
      PROFILE_IMAGE: {
        FILE_TYPES: ['image/bmp', 'image/jpeg', 'image/jpg', 'image/png', '.jpg-large'],
      },
      SAVE_ANIMATION_TIMEOUT: z.motion.MotionDuration.X_LONG * 2,
    };
  }

  static get USERNAME_STATE() {
    return {
      AVAILABLE: 'PreferencesAccountViewModel.USERNAME_STATE.AVAILABLE',
      TAKEN: 'PreferencesAccountViewModel.USERNAME_STATE.TAKEN',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.changeAccentColor = this.changeAccentColor.bind(this);
    this.checkNewClients = this.checkNewClients.bind(this);
    this.removedFromView = this.removedFromView.bind(this);

    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAccountViewModel', z.config.LOGGER.OPTIONS);

    this.mainViewModel = mainViewModel;
    this.backupRepository = repositories.backup;
    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.propertiesRepository = repositories.properties;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.selfUser = this.userRepository.self;

    this.newClients = ko.observableArray([]);
    this.name = ko.pureComputed(() => this.selfUser().name());
    this.availability = ko.pureComputed(() => this.selfUser().availability());

    this.availabilityLabel = ko.pureComputed(() => {
      let label = z.user.AvailabilityMapper.nameFromType(this.availability());

      const noStatusSet = this.availability() === z.user.AvailabilityType.NONE;
      if (noStatusSet) {
        label = z.l10n.text(z.string.preferencesAccountAvaibilityUnset);
      }

      return label;
    });

    this.username = ko.pureComputed(() => this.selfUser().username());
    this.enteredUsername = ko.observable();
    this.submittedUsername = ko.observable();
    this.usernameState = ko.observable();

    this.nameSaved = ko.observable();
    this.usernameSaved = ko.observable();

    this.isTeam = this.teamRepository.isTeam;
    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());
    this.team = this.teamRepository.team;
    this.teamName = ko.pureComputed(() => z.l10n.text(z.string.preferencesAccountTeam, this.teamRepository.teamName()));

    this.optionPrivacy = ko.observable();
    this.optionPrivacy.subscribe(privacyPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, privacyPreference);
    });

    this.optionMarketingConsent = this.userRepository.marketingConsent;
    this.isMacOsWrapper = z.util.Environment.electron && z.util.Environment.os.mac;

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updateProperties.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_ADDED, this.onClientAdd.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_REMOVED, this.onClientRemove.bind(this));
  }

  changeAccentColor(id) {
    this.userRepository.change_accent_color(id);
  }

  changeName(viewModel, event) {
    const newName = event.target.value.trim();

    const isUnchanged = newName === this.selfUser().name();
    if (isUnchanged) {
      return event.target.blur();
    }

    const isValidName = newName.length >= z.user.UserRepository.CONFIG.MINIMUM_NAME_LENGTH;
    if (isValidName) {
      this.userRepository.change_name(newName).then(() => {
        this.nameSaved(true);
        event.target.blur();
        window.setTimeout(() => this.nameSaved(false), PreferencesAccountViewModel.CONFIG.SAVE_ANIMATION_TIMEOUT);
      });
    }
  }

  changeUsername(username, event) {
    const enteredUsername = event.target.value;
    const normalizedUsername = enteredUsername.toLowerCase().replace(/[^a-z0-9_]/g, '');

    const wasNormalized = enteredUsername !== normalizedUsername;
    if (wasNormalized) {
      event.target.value = normalizedUsername;
    }

    const isUnchanged = normalizedUsername === this.selfUser().username();
    if (isUnchanged) {
      return event.target.blur();
    }

    const isInvalidName = normalizedUsername.length < z.user.UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH;
    if (isInvalidName) {
      return this.usernameState(null);
    }

    this.submittedUsername(normalizedUsername);
    this.userRepository
      .change_username(normalizedUsername)
      .then(() => {
        const isCurrentRequest = this.enteredUsername() === this.submittedUsername();
        if (isCurrentRequest) {
          this.usernameState(null);
          this.usernameSaved(true);

          event.target.blur();
          window.setTimeout(() => this.usernameSaved(false), PreferencesAccountViewModel.CONFIG.SAVE_ANIMATION_TIMEOUT);
        }
      })
      .catch(error => {
        const isUsernameTaken = error.type === z.error.UserError.TYPE.USERNAME_TAKEN;
        const isCurrentRequest = this.enteredUsername() === this.submittedUsername();
        if (isUsernameTaken && isCurrentRequest) {
          this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.TAKEN);
        }
      });
  }

  checkUsernameInput(username, keyboardEvent) {
    if (z.util.KeyboardUtil.isKey(keyboardEvent, z.util.KeyboardUtil.KEY.BACKSPACE)) {
      return true;
    }

    // Automation: KeyboardEvent triggered during tests is missing key property
    const inputChar = keyboardEvent.key || String.fromCharCode(event.charCode);
    return z.user.UserHandleGenerator.validate_character(inputChar.toLowerCase());
  }

  checkNewClients() {
    if (this.newClients().length) {
      amplify.publish(z.event.WebApp.SEARCH.BADGE.HIDE);

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES, {
        close: () => this.newClients.removeAll(),
        data: this.newClients(),
        preventClose: true,
        secondary: () => {
          amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
        },
      });
    }
  }

  clickOnChangePicture(files) {
    const [newUserPicture] = Array.from(files);

    this.setPicture(newUserPicture).catch(error => {
      const isInvalidUpdate = error.type === z.error.UserError.TYPE.INVALID_UPDATE;
      if (!isInvalidUpdate) {
        throw error;
      }
    });
  }

  clickOnAvailability(viewModel, event) {
    z.ui.AvailabilityContextMenu.show(event, 'settings', 'preferences-account-availability-menu');
  }

  clickOnBackupExport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.HISTORY_EXPORT);
    amplify.publish(z.event.WebApp.BACKUP.EXPORT.START);
  }

  onImportFileChange(viewModel, event) {
    const file = event.target.files[0];
    if (file) {
      amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.HISTORY_IMPORT);
      amplify.publish(z.event.WebApp.BACKUP.IMPORT.START, file);
    }
  }

  clickOpenCreateTeam() {
    const path = `${z.l10n.text(z.string.urlWebsiteCreateTeam)}?pk_campaign=client&pk_kwd=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path));
  }

  clickOnDeleteAccount() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => this.userRepository.delete_me(),
      text: {
        action: z.l10n.text(z.string.modalAccountDeletionAction),
        message: z.l10n.text(z.string.modalAccountDeletionMessage),
        title: z.l10n.text(z.string.modalAccountDeletionHeadline),
      },
    });
  }

  clickOnLeaveGuestRoom() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => this.conversationRepository.leaveGuestRoom().then(() => this.clientRepository.logoutClient()),
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalAccountLeaveGuestRoomAction),
        message: z.l10n.text(z.string.modalAccountLeaveGuestRoomMessage),
        title: z.l10n.text(z.string.modalAccountLeaveGuestRoomHeadline),
      },
      warning: false,
    });
  }

  clickOnLogout() {
    this.clientRepository.logoutClient();
  }

  clickOpenManageTeam() {
    const path = `${z.config.URL_PATH.MANAGE_TEAM}?utm_source=client_settings&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  clickOnResetPassword() {
    const url = z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.ACCOUNT, z.config.URL_PATH.PASSWORD_RESET);
    z.util.SanitizationUtil.safeWindowOpen(url);
  }

  onClientAdd(userId, clientEntity) {
    const isSelfUser = userId === this.selfUser().id;
    if (isSelfUser) {
      amplify.publish(z.event.WebApp.SEARCH.BADGE.SHOW);
      this.newClients.push(clientEntity);
    }
  }

  onClientRemove(userId, clientId) {
    const isSelfUser = userId === this.selfUser().id;
    if (isSelfUser) {
      this.newClients.remove(clientEntity => {
        const isExpectedId = clientEntity.id === clientId;
        return isExpectedId && clientEntity.isPermanent();
      });

      if (!this.newClients().length) {
        amplify.publish(z.event.WebApp.SEARCH.BADGE.HIDE);
      }
    }
    return true;
  }

  removedFromView() {
    this._resetUsernameInput();
  }

  resetNameInput() {
    if (!this.nameSaved()) {
      this.name.notifySubscribers();
    }
  }

  resetUsernameInput() {
    if (!this.usernameSaved()) {
      this._resetUsernameInput();
      this.username.notifySubscribers();
    }
  }

  setPicture(newUserPicture) {
    const isTooLarge = newUserPicture.size > z.config.MAXIMUM_IMAGE_FILE_SIZE;
    if (isTooLarge) {
      const maximumSizeInMB = z.config.MAXIMUM_IMAGE_FILE_SIZE / 1024 / 1024;
      const messageString = z.l10n.text(z.string.modalPictureTooLargeMessage, maximumSizeInMB);
      const titleString = z.l10n.text(z.string.modalPictureTooLargeHeadline);

      return this._showUploadWarning(titleString, messageString);
    }

    const isWrongFormat = !PreferencesAccountViewModel.CONFIG.PROFILE_IMAGE.FILE_TYPES.includes(newUserPicture.type);
    if (isWrongFormat) {
      const titleString = z.l10n.text(z.string.modalPictureFileFormatHeadline);
      const messageString = z.l10n.text(z.string.modalPictureFileFormatMessage);

      return this._showUploadWarning(titleString, messageString);
    }

    const minHeight = z.user.UserRepository.CONFIG.MINIMUM_PICTURE_SIZE.HEIGHT;
    const minWidth = z.user.UserRepository.CONFIG.MINIMUM_PICTURE_SIZE.WIDTH;

    return z.util.validateProfileImageResolution(newUserPicture, minWidth, minHeight).then(isValid => {
      if (isValid) {
        return this.userRepository.change_picture(newUserPicture);
      }

      const messageString = z.l10n.text(z.string.modalPictureTooSmallMessage);
      const titleString = z.l10n.text(z.string.modalPictureTooSmallHeadline);
      return this._showUploadWarning(titleString, messageString);
    });
  }

  shouldFocusUsername() {
    return this.userRepository.should_set_username;
  }

  verifyUsername(username, event) {
    const enteredUsername = event.target.value.toLowerCase().replace(/[^a-z0-9_]/g, '');

    const usernameTooShort = enteredUsername.length < z.user.UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH;
    const usernameUnchanged = enteredUsername === this.selfUser().username();
    if (usernameTooShort || usernameUnchanged) {
      return this.usernameState(null);
    }

    this.enteredUsername(enteredUsername);

    if (z.user.UserHandleGenerator.validate_handle(enteredUsername)) {
      this.userRepository
        .verify_username(enteredUsername)
        .then(() => {
          const isCurrentRequest = this.enteredUsername() === enteredUsername;
          if (isCurrentRequest) {
            this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.AVAILABLE);
          }
        })
        .catch(error => {
          const isUsernameTaken = error.type === z.error.UserError.TYPE.USERNAME_TAKEN;
          const isCurrentRequest = this.enteredUsername() === enteredUsername;
          if (isUsernameTaken && isCurrentRequest) {
            this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.TAKEN);
          }
        });
    }
  }

  _showUploadWarning(title, message) {
    const modalOptions = {text: {message, title}};
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);

    return Promise.reject(new z.error.UserError(z.error.UserError.TYPE.INVALID_UPDATE));
  }

  _resetUsernameInput() {
    this.usernameState(null);
    this.enteredUsername(null);
    this.submittedUsername(null);
  }

  updateProperties(properties) {
    this.optionPrivacy(properties.settings.privacy.improve_wire);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAVViewModel = class PreferencesAVViewModel {
  static get CONFIG() {
    return {
      AUDIO_METER: {
        FFT_SIZE: 1024,
        INTERVAL: 100,
        LEVEL_ADJUSTMENT: 0.075,
        SMOOTHING_TIME_CONSTANT: 0.2,
      },
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.initiateDevices = this.initiateDevices.bind(this);
    this.releaseDevices = this.releaseDevices.bind(this);

    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAVViewModel', z.config.LOGGER.OPTIONS);

    this.mediaRepository = repositories.media;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.availableDevices = this.devicesHandler.availableDevices;
    this.currentDeviceId = this.devicesHandler.currentDeviceId;
    this.deviceSupport = this.devicesHandler.deviceSupport;

    this.constraintsHandler = this.mediaRepository.constraintsHandler;
    this.streamHandler = this.mediaRepository.streamHandler;
    this.mediaStream = this.streamHandler.localMediaStream;

    this.isVisible = false;

    const selfUser = this.userRepository.self;
    this.isTemporaryGuest = ko.pureComputed(() => selfUser() && selfUser().isTemporaryGuest());

    this.mediaStream.subscribe(mediaStream => {
      if (this.audioInterval) {
        this._releaseAudioMeter();
      }

      if (this.isVisible && mediaStream) {
        this._initiateAudioMeter(mediaStream);
      }
    });

    this.audioContext = undefined;
    this.audioInterval = undefined;
    this.audioLevel = ko.observable(0);
    this.audioSource = undefined;

    this.permissionDenied = ko.observable(false);

    this.supportsAudioOutput = ko.pureComputed(() => {
      return this.deviceSupport.audioOutput() && z.util.Environment.browser.supports.audioOutputSelection;
    });
  }

  /**
   * Initiate media devices.
   * @returns {undefined} No return value
   */
  initiateDevices() {
    this.isVisible = true;

    this._getMediaStream().then(mediaStream => {
      if (mediaStream && !this.audioInterval) {
        this._initiateAudioMeter(mediaStream);
      }
    });
  }

  tryAgain() {
    this.releaseDevices();
    this.initiateDevices();
  }

  /**
   * Release media devices.
   * @returns {undefined} No return value.
   */
  releaseDevices() {
    this.isVisible = false;
    this._releaseAudioMeter();
    this._releaseMediaStream();
  }

  /**
   * Check supported media type.
   * @private
   * @returns {Promise} Resolves with a MediaType or false
   */
  _checkMediaSupport() {
    let mediaType;
    if (this.deviceSupport.audioInput()) {
      mediaType = this.deviceSupport.videoInput() ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
    } else {
      mediaType = this.deviceSupport.videoInput() ? z.media.MediaType.VIDEO : undefined;
    }

    return mediaType
      ? Promise.resolve(mediaType)
      : Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE));
  }

  /**
   * Get current MediaStream or initiate it.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _getCurrentMediaStream() {
    const hasActiveStream = this.deviceSupport.videoInput()
      ? !!this.mediaStream() && this.streamHandler.localMediaType() === z.media.MediaType.VIDEO
      : !!this.mediaStream();

    return Promise.resolve(hasActiveStream ? this.mediaStream() : undefined);
  }

  /**
   * Get current MediaStream or initiate it.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _getMediaStream() {
    return this._getCurrentMediaStream().then(mediaStream => (mediaStream ? mediaStream : this._initiateMediaStream()));
  }

  /**
   * Initiate MediaStream.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _initiateMediaStream() {
    return this._checkMediaSupport()
      .then(mediaType => {
        return this.constraintsHandler
          .getMediaStreamConstraints(this.deviceSupport.audioInput(), this.deviceSupport.videoInput())
          .then(streamConstraints => this.streamHandler.requestMediaStream(mediaType, streamConstraints));
      })
      .then(mediaStreamInfo => {
        if (this.deviceSupport.videoInput()) {
          this.streamHandler.localMediaType(z.media.MediaType.VIDEO);
        }

        this.streamHandler.localMediaStream(mediaStreamInfo.stream);
        return this.streamHandler.localMediaStream();
      })
      .catch(error => {
        this.logger.error(`Requesting MediaStream failed: ${error.message}`, error);

        const expectedErrors = [
          z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE,
          z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION,
        ];

        const isExpectedError = expectedErrors.includes(error.type);
        if (isExpectedError) {
          this.permissionDenied(true);
          return false;
        }

        throw error;
      });
  }

  /**
   * Initiate audio meter.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to measure audio levels on
   * @returns {undefined} No return value
   */
  _initiateAudioMeter(mediaStream) {
    this.logger.info('Initiating new audio meter', mediaStream);
    this.audioContext = this.mediaRepository.getAudioContext();

    const audioAnalyser = this.audioContext.createAnalyser();
    audioAnalyser.fftSize = PreferencesAVViewModel.CONFIG.AUDIO_METER.FFT_SIZE;
    audioAnalyser.smoothingTimeConstant = PreferencesAVViewModel.CONFIG.AUDIO_METER.SMOOTHING_TIME_CONSTANT;

    const audioDataArray = new Float32Array(audioAnalyser.frequencyBinCount);

    this.audioInterval = window.setInterval(() => {
      audioAnalyser.getFloatFrequencyData(audioDataArray);
      let volume = 0;

      // Data is in the db range of -100 to -30, but can also be -Infinity. We normalize the value up to -50 to the range of 0, 1.
      for (const dataPoint of audioDataArray) {
        volume += Math.abs(Math.max(dataPoint, -100) + 100) / 50;
      }

      const averageVolume = volume / audioDataArray.length;

      this.audioLevel(averageVolume - PreferencesAVViewModel.CONFIG.AUDIO_METER.LEVEL_ADJUSTMENT);
    }, PreferencesAVViewModel.CONFIG.AUDIO_METER.INTERVAL);

    this.audioSource = this.audioContext.createMediaStreamSource(mediaStream);
    this.audioSource.connect(audioAnalyser);
  }

  _releaseAudioMeter() {
    window.clearInterval(this.audioInterval);
    this.audioInterval = undefined;
    if (this.audioSource) {
      this.audioSource.disconnect();
    }
  }

  _releaseMediaStream() {
    this.streamHandler.resetMediaStream();
    this.permissionDenied(false);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesDeviceDetailsViewModel = class PreferencesDeviceDetailsViewModel {
  static get SESSION_RESET_STATE() {
    return {
      CONFIRMATION: 'confirmation',
      ONGOING: 'ongoing',
      RESET: 'reset',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.cryptographyRepository = repositories.cryptography;
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesDeviceDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = mainViewModel.actions;
    this.selfUser = this.clientRepository.selfUser;

    this.activationDate = ko.observableArray([]);
    this.device = ko.observable();
    this.fingerprint = ko.observableArray([]);
    this.sessionResetState = ko.observable(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);

    this.device.subscribe(clientEntity => {
      if (clientEntity) {
        this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        this._updateFingerprint();
        this._updateActivationTime(clientEntity.time);
      }
    });
  }

  _updateActivationTime(time) {
    const formattedTime = z.util.TimeUtil.formatTimestamp(time);
    const stringTemplate = z.string.preferencesDevicesActivatedOn;
    const sanitizedText = z.util.StringUtil.splitAtPivotElement(stringTemplate, '{{date}}', formattedTime);
    this.activationDate(sanitizedText);
  }

  _updateFingerprint() {
    this.fingerprint([]);

    this.cryptographyRepository
      .getRemoteFingerprint(this.selfUser().id, this.device().id)
      .then(fingerprint => this.fingerprint(fingerprint));
  }

  clickOnDetailsClose() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
    this.device(null);
  }

  clickOnResetSession() {
    this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.ONGOING);

    const selfConversationId = this.conversationRepository.self_conversation().id;
    this.conversationRepository
      .reset_session(this.selfUser().id, this.device().id, selfConversationId)
      .then(() => {
        window.setTimeout(() => {
          this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.CONFIRMATION);
        }, z.motion.MotionDuration.LONG);

        window.setTimeout(() => {
          this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        }, 5000);
      })
      .catch(error => {
        this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        throw error;
      });
  }

  clickOnRemoveDevice() {
    this.actionsViewModel.deleteClient(this.device()).then(() => this.clickOnDetailsClose());
  }

  toggleDeviceVerification() {
    const toggleVerified = !this.device().meta.isVerified();
    this.clientRepository.verifyClient(this.selfUser().id, this.device(), toggleVerified);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesDevicesViewModel = class PreferencesDevicesViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.clickOnRemoveDevice = this.clickOnRemoveDevice.bind(this);
    this.clickOnShowDevice = this.clickOnShowDevice.bind(this);
    this.updateDeviceInfo = this.updateDeviceInfo.bind(this);

    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.cryptographyRepository = repositories.cryptography;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesDevicesViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = mainViewModel.actions;
    this.preferencesDeviceDetails = contentViewModel.preferencesDeviceDetails;
    this.currentClient = this.clientRepository.currentClient;
    this.displayClientId = ko.pureComputed(() => (this.currentClient() ? this.currentClient().formatId() : []));

    this.activationDate = ko.observable([]);
    this.devices = ko.observableArray();
    this.localFingerprint = ko.observableArray([]);
    this.selfUser = this.userRepository.self;
    this.isSSO = ko.pureComputed(() => this.selfUser() && this.selfUser().isSingleSignOn);

    this.shouldUpdateScrollbar = ko.computed(() => this.devices()).extend({notify: 'always', rateLimit: 500});

    // All clients except the current client
    this.clientRepository.clients.subscribe(clientEntities => {
      const devices = clientEntities.filter(clientEntity => clientEntity.id !== this.currentClient().id);
      this.devices(devices);
    });
  }

  _updateActivationDate(time, template = z.string.preferencesDevicesActivatedOn) {
    const formattedTime = z.util.TimeUtil.formatTimestamp(time);
    const sanitizedText = z.util.StringUtil.splitAtPivotElement(template, '{{date}}', formattedTime);
    this.activationDate(sanitizedText);
  }

  clickOnShowDevice(clientEntity) {
    this.preferencesDeviceDetails.device(clientEntity);
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS);
  }

  clickOnRemoveDevice(clientEntity, event) {
    this.actionsViewModel.deleteClient(clientEntity);
    event.stopPropagation();
  }

  updateDeviceInfo() {
    if (this.currentClient() && !this.localFingerprint().length) {
      this._updateActivationDate(this.currentClient().time);
      this.localFingerprint(this.cryptographyRepository.getLocalFingerprint());
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesOptionsViewModel = class PreferencesOptionsViewModel {
  static get CONFIG() {
    return {
      MINIMUM_CALL_LOG_LENGTH: 10,
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesOptionsViewModel', z.config.LOGGER.OPTIONS);

    this.callingRepository = repositories.calling;
    this.propertiesRepository = repositories.properties;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isTeam = this.teamRepository.isTeam;

    this.optionAudio = ko.observable();
    this.optionAudio.subscribe(audioPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.SOUND_ALERTS, audioPreference);
    });

    this.optionReplaceInlineEmoji = ko.observable();
    this.optionReplaceInlineEmoji.subscribe(emojiPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE, emojiPreference);
    });

    this.optionNotifications = ko.observable();
    this.optionNotifications.subscribe(notificationsPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.NOTIFICATIONS, notificationsPreference);
    });

    this.optionSendPreviews = ko.observable();
    this.optionSendPreviews.subscribe(sendPreviewsPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.PREVIEWS.SEND, sendPreviewsPreference);
    });

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updateProperties.bind(this));
  }

  connectMacOSContacts() {
    amplify.publish(z.event.WebApp.CONNECT.IMPORT_CONTACTS, z.connect.ConnectSource.ICLOUD);
  }

  saveCallLogs() {
    const messageLog = this.callingRepository.messageLog;
    // Very short logs will not contain useful information
    const logExceedsMinimumLength = messageLog.length > PreferencesOptionsViewModel.CONFIG.MINIMUM_CALL_LOG_LENGTH;
    if (logExceedsMinimumLength) {
      const callLog = [messageLog.join('\r\n')];
      const blob = new Blob(callLog, {type: 'text/plain;charset=utf-8'});

      const selfUserId = this.userRepository.self().id;
      const truncatedId = selfUserId.substr(0, z.telemetry.calling.CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
      const filename = `Wire-${truncatedId}-Calling_${z.util.TimeUtil.getCurrentDate()}.log`;

      return z.util.downloadBlob(blob, filename);
    }

    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: z.l10n.text(z.string.modalCallEmptyLogMessage),
        title: z.l10n.text(z.string.modalCallEmptyLogHeadline),
      },
    });
  }

  updateProperties(properties) {
    this.optionAudio(properties.settings.sound.alerts);
    this.optionReplaceInlineEmoji(properties.settings.emoji.replace_inline);
    this.optionSendPreviews(properties.settings.previews.send);
    this.optionNotifications(properties.settings.notifications);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.TitleBarViewModel = class TitleBarViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.addedToView = this.addedToView.bind(this);

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.multitasking = contentViewModel.multitasking;
    this.logger = new z.util.Logger('z.viewModel.content.TitleBarViewModel', z.config.LOGGER.OPTIONS);

    this.panelViewModel = mainViewModel.panel;

    this.panelIsVisible = this.panelViewModel.isVisible;

    // TODO remove the titlebar for now to ensure that buttons are clickable in macOS wrappers
    window.setTimeout(() => $('.titlebar').remove(), z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    this.conversationEntity = this.conversationRepository.active_conversation;

    this.joinedCall = this.callingRepository.joinedCall;
    this.selfStreamState = this.callingRepository.selfStreamState;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.hasCall = ko.pureComputed(() => {
      const hasEntities = this.conversationEntity() && this.joinedCall();
      return hasEntities ? this.conversationEntity().id === this.joinedCall().id : false;
    });

    this.badgeLabelCopy = ko.pureComputed(() => {
      let stringId;

      if (this.conversationEntity().hasGuest()) {
        stringId = this.conversationEntity().hasService()
          ? z.string.guestRoomConversationBadgeGuestAndService
          : z.string.guestRoomConversationBadge;
      } else if (this.conversationEntity().hasService()) {
        stringId = z.string.guestRoomConversationBadgeService;
      }

      return stringId ? z.l10n.text(stringId) : '';
    });

    this.hasOngoingCall = ko.computed(() => {
      return this.hasCall() && this.joinedCall() ? this.joinedCall().isOngoing() : false;
    });

    this.showCallControls = ko.pureComputed(() => {
      if (!this.conversationEntity()) {
        return false;
      }

      const isSupportedConversation = this.conversationEntity().isGroup() || this.conversationEntity().is1to1();
      const hasParticipants = !!this.conversationEntity().participating_user_ids().length;
      const isActiveConversation = hasParticipants && !this.conversationEntity().removed_from_conversation();
      return !this.hasCall() && isSupportedConversation && isActiveConversation;
    });

    this.supportsVideoCall = ko.pureComputed(() => {
      return this.conversationEntity() && this.conversationEntity().supportsVideoCall(true);
    });

    const shortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.PEOPLE);
    this.peopleTooltip = z.l10n.text(z.string.tooltipConversationPeople, shortcut);
  }

  addedToView() {
    window.setTimeout(() => {
      amplify.subscribe(z.event.WebApp.SHORTCUT.PEOPLE, () => this.showDetails());
      amplify.subscribe(z.event.WebApp.SHORTCUT.ADD_PEOPLE, () => {
        if (this.isActivatedAccount()) {
          this.showAddParticipant();
        }
      });
    }, 50);
  }

  removedFromView() {
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.PEOPLE);
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.ADD_PEOPLE);
  }

  clickOnCallButton() {
    amplify.publish(z.event.WebApp.CALL.STATE.TOGGLE, z.media.MediaType.AUDIO);
  }

  clickOnDetails() {
    this.showDetails();
  }

  clickOnVideoButton() {
    amplify.publish(z.event.WebApp.CALL.STATE.TOGGLE, z.media.MediaType.AUDIO_VIDEO);
  }

  clickOnCollectionButton() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION);
  }

  showAddParticipant() {
    const canAddPeople = this.conversationEntity() && this.conversationEntity().isActiveParticipant();

    if (!canAddPeople) {
      return this.showDetails();
    }

    return this.conversationEntity().isGroup()
      ? this.showDetails(true)
      : amplify.publish(
          z.event.WebApp.CONVERSATION.CREATE_GROUP,
          'conversation_details',
          this.conversationEntity().firstUserEntity()
        );
  }

  showDetails(addParticipants) {
    const panelId = addParticipants
      ? z.viewModel.PanelViewModel.STATE.ADD_PARTICIPANTS
      : z.viewModel.PanelViewModel.STATE.CONVERSATION_DETAILS;

    this.panelViewModel.togglePanel(panelId);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.PanelViewModel = class PanelViewModel {
  static get STATE() {
    return {
      ADD_PARTICIPANTS: 'PanelViewModel.STATE.ADD_PARTICIPANTS',
      CONVERSATION_DETAILS: 'PanelViewModel.STATE.CONVERSATION_DETAILS',
      CONVERSATION_PARTICIPANTS: 'PanelViewModel.STATE.CONVERSATION_PARTICIPANTS',
      GROUP_PARTICIPANT_SERVICE: 'PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE',
      GROUP_PARTICIPANT_USER: 'PanelViewModel.STATE.GROUP_PARTICIPANT_USER',
      GUEST_OPTIONS: 'PanelViewModel.STATE.GUEST_OPTIONS',
      NOTIFICATIONS: 'PanelViewModel.STATE.NOTIFICATIONS',
      PARTICIPANT_DEVICES: 'PanelViewModel.STATE.DEVICES',
      TIMED_MESSAGES: 'PanelViewModel.STATE.TIMED_MESSAGES',
    };
  }

  buildSubViews() {
    const viewModels = {
      [PanelViewModel.STATE.ADD_PARTICIPANTS]: z.viewModel.panel.AddParticipantsViewModel,
      [PanelViewModel.STATE.CONVERSATION_DETAILS]: z.viewModel.panel.ConversationDetailsViewModel,
      [PanelViewModel.STATE.CONVERSATION_PARTICIPANTS]: z.viewModel.panel.ConversationParticipantsViewModel,
      [PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE]: z.viewModel.panel.GroupParticipantServiceViewModel,
      [PanelViewModel.STATE.GROUP_PARTICIPANT_USER]: z.viewModel.panel.GroupParticipantUserViewModel,
      [PanelViewModel.STATE.GUEST_OPTIONS]: z.viewModel.panel.GuestsAndServicesViewModel,
      [PanelViewModel.STATE.NOTIFICATIONS]: z.viewModel.panel.NotificationsViewModel,
      [PanelViewModel.STATE.PARTICIPANT_DEVICES]: z.viewModel.panel.ParticipantDevicesViewModel,
      [PanelViewModel.STATE.TIMED_MESSAGES]: z.viewModel.panel.TimedMessagesViewModel,
    };

    return Object.entries(viewModels).reduce((subViews, [state, viewModel]) => {
      subViews[state] = new viewModel({
        isVisible: ko.pureComputed(this._isStateVisible.bind(this, state)),
        mainViewModel: this.mainViewModel,
        navigateTo: this._navigateTo.bind(this),
        onClose: this.closePanel.bind(this),
        onGoBack: this._goBack.bind(this),
        onGoToRoot: this._goToRoot.bind(this),
        repositories: this.repositories,
      });
      return subViews;
    }, {});
  }

  /**
   * View model for the details column.
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, repositories) {
    this.elementId = 'right-column';
    this.repositories = repositories;
    this.conversationRepository = repositories.conversation;
    this.mainViewModel = mainViewModel;

    this.conversationEntity = this.conversationRepository.active_conversation;
    this.stateHistory = [];

    this.isAnimating = ko.observable(false);
    this.isVisible = ko.pureComputed(() => this.state() !== null);
    this.exitingState = ko.observable(undefined);
    this.state = ko.observable(null);

    this.conversationEntity.subscribe(this._forceClosePanel.bind(this), null, 'beforeChange');
    this.subViews = this.buildSubViews();

    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this._switchContent.bind(this));
    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Toggles (open/close) a panel.
   * If the state given is the one visible (and the parameters are the same), the panel closes.
   * Else the panels opens on the given state.
   *
   * Note: panels that are toggled are not counted in the state history.
   *
   * @param {string} state - the new state to navigate to.
   * @param {Object} params - params to give to the new view.
   * @returns {void} nothing returned
   */
  togglePanel(state, params) {
    const isStateChange = this.state() !== state;
    if (!isStateChange) {
      const currentInstance = this.subViews[state];
      const isNewParams = params && params.entity && params.entity.id !== currentInstance.getEntityId();
      if (!isNewParams) {
        return this.closePanel();
      }
    }
    this._openPanel(state, params);
  }

  /**
   * Graciously closes the current opened panel.
   *
   * @returns {void} nothing returned
   */
  closePanel() {
    if (this.isAnimating()) {
      return Promise.resolve(false);
    }

    this.isAnimating(true);
    return this.mainViewModel.closePanel().then(() => {
      this._resetState();
      return true;
    });
  }

  /**
   * Will navigate from the current state to the new state.
   *
   * @param {string} newState - the new state to navigate to.
   * @param {Object} params - params to give to the new view.
   * @returns {void} nothing returned.
   */
  _navigateTo(newState, params) {
    this._switchState(newState, this.state(), params);
    this.stateHistory.push({params, state: newState});
  }

  _forceClosePanel() {
    if (this.isVisible()) {
      this.mainViewModel.closePanelImmediatly();
      this._resetState();
    }
  }

  _resetState() {
    this.isAnimating(false);
    this._hidePanel(this.state());
    this.state(null);
    this.stateHistory = [];
  }

  _isStateVisible(state) {
    const isStateActive = this.state() === state;
    const isStateExiting = this.exitingState() === state;
    return (isStateExiting || isStateActive) && this.isVisible();
  }

  _goBack() {
    this.stateHistory.pop();
    const toHistory = this.stateHistory[this.stateHistory.length - 1];
    const {state, params} = toHistory;
    this._switchState(state, this.state(), params, true);
  }

  _goToRoot() {
    this._openPanel(PanelViewModel.STATE.CONVERSATION_DETAILS);
  }

  _switchContent(newContentState) {
    const stateIsCollection = newContentState === z.viewModel.ContentViewModel.STATE.COLLECTION;
    if (stateIsCollection) {
      this._forceClosePanel();
    }
  }

  _switchState(toState, fromState, params, fromLeft = false) {
    const toViewModel = this.subViews[toState];
    const fromViewModel = this.subViews[fromState];
    toViewModel.initView(params);

    const isSameState = fromState === toState;
    if (isSameState) {
      return;
    }

    if (!fromViewModel) {
      return this._showPanel(toState);
    }

    const skipTransition = fromViewModel.shouldSkipTransition() || toViewModel.shouldSkipTransition();

    if (skipTransition) {
      this._hidePanel(fromState);
      this._showPanel(toState);
      return;
    }

    this.exitingState(fromState);

    const fromPanel = $(`#${fromViewModel.getElementId()}`);
    const toPanel = this._showPanel(toState);

    toPanel.addClass(`panel__page--move-in${fromLeft ? '--left' : '--right'}`);
    fromPanel.addClass(`panel__page--move-out${fromLeft ? '--left' : '--right'}`);

    window.setTimeout(() => {
      toPanel.removeClass('panel__page--move-in--left panel__page--move-in--right');
      this._hidePanel(fromState);
    }, z.motion.MotionDuration.MEDIUM);
  }

  _hidePanel(state) {
    if (!this.subViews[state]) {
      return;
    }
    this.exitingState(undefined);

    const panelStateElementId = this.subViews[state].getElementId();
    const exitPanel = $(`#${panelStateElementId}`);
    exitPanel.removeClass('panel__page--visible panel__page--move-out--left panel__page--move-out--right');
  }

  _openPanel(newState, params) {
    if (!this.isAnimating()) {
      this._hidePanel(this.state());
      const rootState = PanelViewModel.STATE.CONVERSATION_DETAILS;
      this.stateHistory = [{state: rootState}, {params, state: newState}];
      this.isAnimating(true);
      this.exitingState(undefined);
      this._switchState(newState, null, params, true);
      this.mainViewModel.openPanel().then(() => this.isAnimating(false));
    }
  }

  _showPanel(newPanelState) {
    this.state(newPanelState);

    const panelStateElementId = this.subViews[newPanelState].getElementId();
    if (panelStateElementId) {
      return $(`#${panelStateElementId}`).addClass('panel__page--visible');
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.BasePanelViewModel = class BasePanelViewModel {
  constructor({isVisible, navigateTo, onClose, onGoBack, onGoToRoot, repositories}) {
    this.onClose = onClose;
    this.onGoBack = onGoBack;
    this.onGoToRoot = onGoToRoot;
    this.navigateTo = navigateTo;

    this.isVisible = isVisible;

    this.activeConversation = repositories.conversation.active_conversation;
  }

  initView() {}

  getElementId() {
    return 'conversation-details';
  }

  getEntityId() {
    return this.activeConversation() ? this.activeConversation().id : false;
  }

  shouldSkipTransition() {
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.AddParticipantsViewModel = class AddParticipantsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get STATE() {
    return {
      ADD_PEOPLE: 'AddParticipantsViewModel.STATE.ADD_PEOPLE',
      ADD_SERVICE: 'AddParticipantsViewModel.STATE.ADD_SERVICE',
    };
  }

  constructor(params) {
    super(params);

    const {conversation, integration, search, team, user} = params.repositories;
    this.conversationRepository = conversation;
    this.integrationRepository = integration;
    this.searchRepository = search;
    this.teamRepository = team;
    this.userRepository = user;

    this.logger = new z.util.Logger('z.viewModel.panel.AddParticipantsViewModel', z.config.LOGGER.OPTIONS);

    this.isTeam = this.teamRepository.isTeam;
    this.selfUser = this.userRepository.self;
    this.services = this.integrationRepository.services;
    this.teamUsers = this.teamRepository.teamUsers;
    this.teamMembers = this.teamRepository.teamMembers;

    this.isInitialServiceSearch = ko.observable(true);
    this.searchInput = ko.observable('');
    this.selectedContacts = ko.observableArray([]);
    this.selectedService = ko.observable();
    this.state = ko.observable(AddParticipantsViewModel.STATE.ADD_PEOPLE);

    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());

    this.showIntegrations = ko.pureComputed(() => {
      if (this.activeConversation()) {
        const firstUserEntity = this.activeConversation().firstUserEntity();
        const hasBotUser = firstUserEntity && firstUserEntity.isService;
        const allowIntegrations = this.activeConversation().isGroup() || hasBotUser;
        return this.isTeam() && allowIntegrations && this.activeConversation().inTeam() && !this.isTeamOnly();
      }
    });
    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());

    this.enableAddAction = ko.pureComputed(() => this.selectedContacts().length > 0);

    this.isStateAddPeople = ko.pureComputed(() => this.state() === AddParticipantsViewModel.STATE.ADD_PEOPLE);
    this.isStateAddService = ko.pureComputed(() => this.state() === AddParticipantsViewModel.STATE.ADD_SERVICE);

    this.contacts = ko.pureComputed(() => {
      const activeConversation = this.activeConversation();
      let userEntities = [];

      if (!activeConversation) {
        return userEntities;
      }

      if (this.isTeam()) {
        userEntities = this.isTeamOnly()
          ? this.teamMembers().sort((userA, userB) => {
              return z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name());
            })
          : this.teamUsers();
      } else {
        userEntities = this.userRepository.connected_users();
      }

      return userEntities.filter(userEntity => {
        return !activeConversation.participating_user_ids().find(id => userEntity.id === id);
      });
    });

    this.isSearching = ko.pureComputed(() => this.searchInput().length);
    this.headerText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.addParticipantsHeaderWithCounter
        : z.string.addParticipantsHeader;
      return z.l10n.text(stringSelector, {number: this.selectedContacts().length});
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => (this.contacts() || this.searchInput()) && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});

    this.searchInput.subscribe(searchInput => this.searchServices(searchInput));
    this.clickOnSelectService = this.clickOnSelectService.bind(this);
  }

  getElementId() {
    return 'add-participants';
  }

  clickOnAddPeople() {
    this.state(AddParticipantsViewModel.STATE.ADD_PEOPLE);
  }

  clickOnAddService() {
    this.state(AddParticipantsViewModel.STATE.ADD_SERVICE);
    this.searchServices(this.searchInput());
  }

  clickOnSelectService(serviceEntity) {
    this.selectedService(serviceEntity);
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE, {
      addMode: true,
      entity: serviceEntity,
    });
  }

  clickToAddParticipants() {
    this._addMembers();
    this.onGoBack();
  }

  clickOpenManageServices() {
    const path = `${z.config.URL_PATH.MANAGE_SERVICES}?utm_source=client_landing&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  initView() {
    this.state(AddParticipantsViewModel.STATE.ADD_PEOPLE);
    this.selectedContacts.removeAll();
    this.selectedService(undefined);
    this.searchInput('');
    this.isInitialServiceSearch(true);
  }

  searchServices(query) {
    if (this.isStateAddService()) {
      this.integrationRepository
        .searchForServices(this.searchInput(), this.searchInput)
        .then(() => this.isInitialServiceSearch(false));
    }
  }

  _addMembers() {
    const activeConversation = this.activeConversation();
    const userEntities = this.selectedContacts().slice();

    this.conversationRepository.addMembers(activeConversation, userEntities).then(() => {
      const attributes = {
        method: 'add',
        user_num: userEntities.length,
      };

      const isTeamConversation = !!this.activeConversation().team_id;
      if (isTeamConversation) {
        const participants = z.tracking.helpers.getParticipantTypes(userEntities, false);

        Object.assign(attributes, {
          guest_num: participants.guests,
          is_allow_guests: activeConversation.isGuestRoom(),
          temporary_guest_num: participants.temporaryGuests,
          user_num: participants.users,
        });
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.ADD_PARTICIPANTS, attributes);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ConversationDetailsViewModel = class ConversationDetailsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get CONFIG() {
    return {
      MAX_USERS_VISIBLE: 7,
      REDUCED_USERS_COUNT: 5,
    };
  }

  constructor(params) {
    super(params);
    this.clickOnShowService = this.clickOnShowService.bind(this);
    this.clickOnShowUser = this.clickOnShowUser.bind(this);

    const {mainViewModel, repositories} = params;

    const {conversation, integration, search, team, user} = repositories;
    this.conversationRepository = conversation;
    this.integrationRepository = integration;
    this.searchRepository = search;
    this.teamRepository = team;
    this.userRepository = user;

    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.ConversationDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isTeam = this.teamRepository.isTeam;

    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());

    this.serviceParticipants = ko.observableArray();
    this.userParticipants = ko.observableArray();
    this.showAllUsersCount = ko.observable(0);
    this.selectedService = ko.observable();

    ko.computed(() => {
      if (this.activeConversation()) {
        this.serviceParticipants.removeAll();
        this.userParticipants.removeAll();

        this.activeConversation()
          .participating_user_ets()
          .map(userEntity => {
            if (userEntity.isService) {
              return this.serviceParticipants.push(userEntity);
            }
            this.userParticipants.push(userEntity);
          });

        const userCount = this.userParticipants().length;
        const exceedsMaxUserCount = userCount > ConversationDetailsViewModel.CONFIG.MAX_USERS_VISIBLE;
        if (exceedsMaxUserCount) {
          this.userParticipants.splice(ConversationDetailsViewModel.CONFIG.REDUCED_USERS_COUNT);
        }
        this.showAllUsersCount(exceedsMaxUserCount ? userCount : 0);
      }
    });

    this.firstParticipant = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().firstUserEntity();
    });

    this.isSingleUserMode = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().is1to1() || this.activeConversation().isRequest()
        : false;
    });

    this.isActiveGroupParticipant = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().isGroup() && this.activeConversation().isActiveParticipant()
        : false;
    });

    this.isVerified = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().verification_state() === z.conversation.ConversationVerificationState.VERIFIED
        : false;
    });

    this.isEditingName = ko.observable(false);

    this.isEditingName.subscribe(isEditing => {
      if (isEditing) {
        return window.setTimeout(() => $('.conversation-details__name--input').focus(), 0);
      }
      const name = $('.conversation-details__name--input');
      $('.conversation-details__name').css('height', `${name.height()}px`);
    });

    this.isServiceMode = ko.pureComputed(() => {
      return this.isSingleUserMode() && this.firstParticipant() && this.firstParticipant().isService;
    });

    this.showTopActions = ko.pureComputed(() => this.isActiveGroupParticipant() || this.showSectionOptions());

    this.showActionAddParticipants = this.isActiveGroupParticipant;

    this.showActionBlock = ko.pureComputed(() => {
      if (this.isSingleUserMode() && this.firstParticipant()) {
        return this.firstParticipant().isConnected() || this.firstParticipant().isRequest();
      }
    });

    this.showActionCreateGroup = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().is1to1() && !this.isServiceMode();
    });

    this.showActionCancelRequest = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isRequest();
    });

    this.showActionClear = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isClearable());

    this.showActionLeave = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isLeavable());

    this.showActionMute = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isMutable() && !this.isTeam();
    });

    this.showOptionGuests = ko.pureComputed(() => {
      return this.isActiveGroupParticipant() && this.activeConversation().inTeam();
    });

    this.hasAdvancedNotifications = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isMutable() && this.isTeam();
    });

    this.showOptionNotificationsGroup = ko.pureComputed(() => {
      return this.hasAdvancedNotifications() && this.activeConversation().isGroup();
    });

    this.showOptionNotifications1To1 = ko.pureComputed(() => {
      return this.hasAdvancedNotifications() && !this.activeConversation().isGroup();
    });

    this.showOptionTimedMessages = this.isActiveGroupParticipant;

    this.showSectionOptions = ko.pureComputed(() => {
      return this.showOptionGuests() || this.showOptionNotificationsGroup() || this.showOptionTimedMessages();
    });

    this.participantsUserText = ko.pureComputed(() => {
      const hasMultipleParticipants = this.userParticipants().length > 1;
      return hasMultipleParticipants
        ? z.string.conversationDetailsParticipantsUsersMany
        : z.string.conversationDetailsParticipantsUsersOne;
    });

    this.participantsServiceText = ko.pureComputed(() => {
      const hasMultipleParticipants = this.serviceParticipants().length > 1;
      return hasMultipleParticipants
        ? z.string.conversationDetailsParticipantsServicesMany
        : z.string.conversationDetailsParticipantsServicesOne;
    });

    this.guestOptionsText = ko.pureComputed(() => {
      return this.isTeamOnly() ? z.string.conversationDetailsGuestsOff : z.string.conversationDetailsGuestsOn;
    });

    this.notificationStatusText = ko.pureComputed(() => {
      return this.activeConversation()
        ? z.conversation.NotificationSetting.getText(this.activeConversation().notificationState())
        : '';
    });

    this.timedMessagesText = ko.pureComputed(() => {
      if (this.activeConversation()) {
        const hasTimer = this.activeConversation().messageTimer() && this.activeConversation().hasGlobalMessageTimer();
        if (hasTimer) {
          return z.util.TimeUtil.formatDuration(this.activeConversation().messageTimer()).text;
        }
      }
      return z.l10n.text(z.string.ephemeralUnitsNone);
    });

    const addPeopleShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.ADD_PEOPLE);
    this.addPeopleTooltip = ko.pureComputed(() => {
      return z.l10n.text(z.string.tooltipConversationDetailsAddPeople, addPeopleShortcut);
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.serviceParticipants() && this.userParticipants() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});

    this.isServiceMode.subscribe(isService => {
      if (isService) {
        const entity = this.firstParticipant();
        this.integrationRepository.getServiceFromUser(entity).then(serviceEntity => {
          this.selectedService(serviceEntity);
          this.integrationRepository.addProviderNameToParticipant(serviceEntity);
        });
      }
    });
  }

  getElementId() {
    return 'conversation-details';
  }

  clickOnAddParticipants() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.ADD_PARTICIPANTS);
  }

  clickOnShowAll() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.CONVERSATION_PARTICIPANTS);
  }

  clickOnCreateGroup() {
    amplify.publish(z.event.WebApp.CONVERSATION.CREATE_GROUP, 'conversation_details', this.firstParticipant());
  }

  clickOnDevices() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.PARTICIPANT_DEVICES, {entity: this.firstParticipant()});
  }

  clickOnGuestOptions() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GUEST_OPTIONS);
  }

  clickOnTimedMessages() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.TIMED_MESSAGES);
  }

  clickOnNotifications() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
  }

  clickOnShowUser(userEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER, {entity: userEntity});
  }

  clickOnShowService(serviceEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE, {entity: serviceEntity});
  }

  clickToArchive() {
    this.actionsViewModel.archiveConversation(this.activeConversation());
  }

  clickToBlock() {
    if (this.activeConversation()) {
      const userEntity = this.activeConversation().firstUserEntity();
      const nextConversationEntity = this.conversationRepository.get_next_conversation(this.activeConversation());

      this.actionsViewModel.blockUser(userEntity, true, nextConversationEntity);
    }
  }

  clickToCancelRequest() {
    if (this.activeConversation()) {
      const userEntity = this.activeConversation().firstUserEntity();
      const nextConversationEntity = this.conversationRepository.get_next_conversation(this.activeConversation());

      this.actionsViewModel.cancelConnectionRequest(userEntity, true, nextConversationEntity);
    }
  }

  clickToClear() {
    this.actionsViewModel.clearConversation(this.activeConversation());
  }

  clickToEditGroupName() {
    if (this.isActiveGroupParticipant()) {
      this.isEditingName(true);
    }
  }

  clickToLeave() {
    this.actionsViewModel.leaveConversation(this.activeConversation());
  }

  clickToToggleMute() {
    this.actionsViewModel.toggleMuteConversation(this.activeConversation());
  }

  renameConversation(data, event) {
    if (this.activeConversation()) {
      const currentConversationName = this.activeConversation()
        .display_name()
        .trim();

      const newConversationName = z.util.StringUtil.removeLineBreaks(event.target.value.trim());

      this.isEditingName(false);
      const hasNameChanged = newConversationName.length && newConversationName !== currentConversationName;
      if (hasNameChanged) {
        event.target.value = currentConversationName;
        this.conversationRepository.renameConversation(this.activeConversation(), newConversationName);
      }
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ConversationParticipantsViewModel = class ConversationParticipantsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);
    this.clickOnShowUser = this.clickOnShowUser.bind(this);

    const repositories = params.repositories;
    this.searchRepository = repositories.search;

    this.participants = ko.pureComputed(() => {
      if (this.activeConversation()) {
        return this.activeConversation()
          .participating_user_ets()
          .filter(userEntity => !userEntity.isService);
      }
      return [];
    });

    this.highlightedUsers = ko.observable([]);

    this.searchInput = ko.observable('');

    this.shouldUpdateScrollbar = ko
      .computed(() => (this.participants() || this.searchInput()) && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});
  }

  getElementId() {
    return 'conversation-participants';
  }

  clickOnShowUser(userEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER, {entity: userEntity});
  }

  initView(highlightedUsers = []) {
    this.searchInput('');
    this.highlightedUsers(highlightedUsers);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GroupParticipantUserViewModel = class GroupParticipantUserViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);

    const {mainViewModel, repositories} = params;

    this.userRepository = repositories.user;
    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.GroupParticipantUserViewModel', z.config.LOGGER.OPTIONS);

    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selectedParticipant = ko.observable(undefined);

    this.selectedIsConnected = ko.pureComputed(() => {
      return this.selectedParticipant().isConnected() || this.selectedParticipant().isTeamMember();
    });
    this.selectedIsInConversation = ko.pureComputed(() => {
      if (this.isVisible()) {
        const participatingUserIds = this.activeConversation().participating_user_ids();
        return participatingUserIds.some(id => this.selectedParticipant().id === id);
      }
    });

    this.selfIsActiveParticipant = ko.pureComputed(() => {
      return this.isVisible() ? this.activeConversation().isActiveParticipant() : false;
    });

    this.showActionsIncomingRequest = ko.pureComputed(() => this.selectedParticipant().isIncomingRequest());
    this.showActionsOutgoingRequest = ko.pureComputed(() => this.selectedParticipant().isOutgoingRequest());

    this.showActionBlock = ko.pureComputed(() => {
      return this.selectedParticipant().isConnected() || this.selectedParticipant().isRequest();
    });
    this.showActionDevices = ko.pureComputed(() => !this.selectedParticipant().is_me);
    this.showActionOpenConversation = ko.pureComputed(() => {
      return this.selectedIsConnected() && !this.selectedParticipant().is_me;
    });
    this.showActionRemove = ko.pureComputed(() => this.selfIsActiveParticipant() && this.selectedIsInConversation());
    this.showActionSelfProfile = ko.pureComputed(() => this.selectedParticipant().is_me);
    this.showActionSendRequest = ko.pureComputed(() => {
      const isNotConnectedUser = this.selectedParticipant().isCanceled() || this.selectedParticipant().isUnknown();
      const canConnect = !this.selectedParticipant().isTeamMember() && !this.selectedParticipant().isTemporaryGuest();
      return isNotConnectedUser && canConnect;
    });
    this.showActionLeave = ko.pureComputed(() => {
      const isActiveParticipant = this.activeConversation() && !this.activeConversation().removed_from_conversation();
      return this.selectedParticipant().is_me && isActiveParticipant;
    });
    this.showActionUnblock = ko.pureComputed(() => this.selectedParticipant().isBlocked());

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedParticipant() && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});
  }

  getElementId() {
    return 'group-participant-user';
  }

  getEntityId() {
    return this.selectedParticipant().id;
  }

  clickOnDevices() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.PARTICIPANT_DEVICES, {entity: this.selectedParticipant()});
  }

  clickOnShowProfile() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickOnOpenConversation() {
    this.actionsViewModel.open1to1Conversation(this.selectedParticipant());
  }

  clickToAcceptRequest() {
    this.actionsViewModel.acceptConnectionRequest(this.selectedParticipant(), true);
  }

  clickToBlock() {
    this.actionsViewModel.blockUser(this.selectedParticipant());
  }

  clickToCancelRequest() {
    this.actionsViewModel.cancelConnectionRequest(this.selectedParticipant());
  }

  clickToIgnoreRequest() {
    this.actionsViewModel.ignoreConnectionRequest(this.selectedParticipant());
  }

  clickToLeave() {
    this.actionsViewModel.leaveConversation(this.activeConversation());
  }

  clickToRemove() {
    this.actionsViewModel
      .removeFromConversation(this.activeConversation(), this.selectedParticipant())
      .then(this.onGoBack);
  }

  clickToSendRequest() {
    this.actionsViewModel.sendConnectionRequest(this.selectedParticipant());
  }

  clickToUnblock() {
    this.actionsViewModel.unblockUser(this.selectedParticipant(), false);
  }

  initView({entity: user}) {
    const userEntity = user;
    this.selectedParticipant(userEntity);

    if (userEntity.isTemporaryGuest()) {
      userEntity.checkGuestExpiration();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GroupParticipantServiceViewModel = class GroupParticipantServiceViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);

    const {mainViewModel, repositories} = params;

    this.integrationRepository = repositories.integration;
    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.GroupParticipantServiceViewModel', z.config.LOGGER.OPTIONS);

    this.selectedParticipant = ko.observable(undefined);
    this.selectedService = ko.observable(undefined);

    this.isAddMode = ko.observable(false);

    this.conversationInTeam = ko.pureComputed(() => this.activeConversation() && this.activeConversation().inTeam());

    this.selectedInConversation = ko.pureComputed(() => {
      if (this.isVisible() && this.activeConversation()) {
        const participatingUserIds = this.activeConversation().participating_user_ids();
        return participatingUserIds.some(id => this.selectedParticipant().id === id);
      }
    });

    this.selfIsActiveParticipant = ko.pureComputed(() => {
      return this.isVisible() ? this.activeConversation().isActiveParticipant() : false;
    });

    this.showActions = ko.pureComputed(() => {
      return this.selfIsActiveParticipant() && this.selectedInConversation() && this.conversationInTeam();
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedService() && this.selectedService().providerName() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'group-participant-service';
  }

  getEntityId() {
    return this.selectedParticipant().id;
  }

  clickOnAdd() {
    this.integrationRepository.addService(this.activeConversation(), this.selectedService(), 'conversation_details');
    this.onGoToRoot();
  }

  clickToOpen() {
    this.actionsViewModel.open1to1ConversationWithService(this.selectedService());
  }

  clickToRemove() {
    this.actionsViewModel
      .removeFromConversation(this.activeConversation(), this.selectedParticipant())
      .then(this.onGoBack);
  }

  initView({entity: service, addMode = false}) {
    const serviceEntity = ko.unwrap(service);
    this.selectedParticipant(serviceEntity);
    this.selectedService(undefined);
    this.isAddMode(addMode);
    this._showService(this.selectedParticipant());
  }

  _showService(entity) {
    this.integrationRepository.getServiceFromUser(entity).then(serviceEntity => {
      this.selectedService(serviceEntity);
      this.integrationRepository.addProviderNameToParticipant(serviceEntity);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GuestsAndServicesViewModel = class GuestsAndServicesViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get CONFIG() {
    return {
      CONFIRM_DURATION: 1500,
    };
  }

  constructor(params) {
    super(params);

    this.copyLink = this.copyLink.bind(this);
    this.toggleAccessState = this.toggleAccessState.bind(this);
    this.requestAccessCode = this.requestAccessCode.bind(this);
    this.revokeAccessCode = this.revokeAccessCode.bind(this);

    const repositories = params.repositories;
    const conversationRepository = repositories.conversation;
    this.stateHandler = conversationRepository.stateHandler;

    this.logger = new z.util.Logger('z.viewModel.panel.GuestsAndServicesViewModel', z.config.LOGGER.OPTIONS);

    this.isLinkCopied = ko.observable(false);
    this.requestOngoing = ko.observable(false);

    this.isGuestRoom = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isGuestRoom());
    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());
    this.hasAccessCode = ko.pureComputed(() => (this.isGuestRoom() ? !!this.activeConversation().accessCode() : false));
    this.isGuestEnabled = ko.pureComputed(() => !this.isTeamOnly());
    this.showLinkOptions = ko.pureComputed(() => this.isGuestEnabled());

    this.activeConversation.subscribe(conversationEntity => this._updateCode(this.isVisible(), conversationEntity));
    this.isVisible.subscribe(isVisible => this._updateCode(isVisible, this.activeConversation()));

    this.shouldUpdateScrollbar = ko
      .computed(() => this.isGuestEnabled() && this.hasAccessCode() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'guest-options';
  }

  copyLink() {
    if (!this.isLinkCopied() && this.activeConversation()) {
      z.util.ClipboardUtil.copyText(this.activeConversation().accessCode()).then(() => {
        this.isLinkCopied(true);
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_COPIED);
        window.setTimeout(() => this.isLinkCopied(false), GuestsAndServicesViewModel.CONFIG.CONFIRM_DURATION);
      });
    }
  }

  requestAccessCode() {
    // Handle conversations in legacy state
    const accessStatePromise = this.isGuestRoom()
      ? Promise.resolve()
      : this.stateHandler.changeAccessState(this.activeConversation(), z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);

    accessStatePromise.then(() => {
      if (!this.requestOngoing()) {
        this.requestOngoing(true);

        this.stateHandler.requestAccessCode(this.activeConversation()).then(() => this.requestOngoing(false));
      }
    });
  }

  revokeAccessCode() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => {
        if (!this.requestOngoing()) {
          this.requestOngoing(true);

          this.stateHandler.revokeAccessCode(this.activeConversation()).then(() => this.requestOngoing(false));
        }
      },
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalConversationRevokeLinkAction),
        message: z.l10n.text(z.string.modalConversationRevokeLinkMessage),
        title: z.l10n.text(z.string.modalConversationRevokeLinkHeadline),
      },
    });
  }

  toggleAccessState() {
    const conversationEntity = this.activeConversation();
    if (conversationEntity.inTeam()) {
      const newAccessState = this.isTeamOnly()
        ? z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM
        : z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY;

      const _changeAccessState = () => {
        if (!this.requestOngoing()) {
          this.requestOngoing(true);

          this.stateHandler
            .changeAccessState(conversationEntity, newAccessState)
            .then(() => this.requestOngoing(false));
        }
      };

      const hasGuestOrService = conversationEntity.hasGuest() || conversationEntity.hasService();

      if (this.isTeamOnly() || !hasGuestOrService) {
        return _changeAccessState();
      }

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => _changeAccessState(),
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalConversationRemoveGuestsAction),
          message: z.l10n.text(z.string.modalConversationRemoveGuestsMessage),
          title: z.l10n.text(z.string.modalConversationRemoveGuestsHeadline),
        },
      });
    }
  }

  _updateCode(isVisible, conversationEntity) {
    const updateCode = conversationEntity && conversationEntity.isGuestRoom() && !conversationEntity.accessCode();
    if (isVisible && updateCode) {
      this.requestOngoing(true);
      this.stateHandler.getAccessCode(conversationEntity).then(() => this.requestOngoing(false));
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.NotificationsViewModel = class NotificationsViewModel extends z.viewModel.panel.BasePanelViewModel {
  constructor(params) {
    super(params);
    this.clickOnNotificationSetting = this.clickOnNotificationSetting.bind(this);

    const conversation = params.repositories.conversation;
    this.conversationRepository = conversation;

    this.logger = new z.util.Logger('z.viewModel.panel.NotificationsViewModel', z.config.LOGGER.OPTIONS);

    this.settings = Object.values(z.conversation.NotificationSetting.STATE).map(status => ({
      text: z.conversation.NotificationSetting.getText(status),
      value: status,
    }));

    this.isRendered = ko.observable(false).extend({notify: 'always'});

    this.currentNotificationSetting = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().notificationState();
    });

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.isRendered())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'notification-settings';
  }

  clickOnNotificationSetting({value}) {
    if (this.activeConversation()) {
      this.conversationRepository.setNotificationState(this.activeConversation(), value);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.TimedMessagesViewModel = class TimedMessagesViewModel extends z.viewModel.panel.BasePanelViewModel {
  constructor(params) {
    super(params);

    this.clickOnMessageTime = this.clickOnMessageTime.bind(this);
    this.clickOnMessageTimeOff = this.clickOnMessageTime.bind(this, {value: null});

    const conversation = params.repositories.conversation;
    this.conversationRepository = conversation;

    this.logger = new z.util.Logger('z.viewModel.panel.TimedMessagesViewModel', z.config.LOGGER.OPTIONS);

    this.messageTimes = ko.pureComputed(() => {
      const times = z.ephemeral.timings.VALUES;
      const currentTime = this.currentMessageTimer();

      times.sort((timeA, timeB) => timeA - timeB);

      const mappedTimes = times.map(time => ({
        text: z.util.TimeUtil.formatDuration(time).text,
        value: time,
      }));

      if (currentTime && !times.includes(currentTime)) {
        mappedTimes.push({
          isCustom: true,
          text: z.util.TimeUtil.formatDuration(currentTime).text,
          value: currentTime,
        });
      }

      return mappedTimes;
    });

    this.isRendered = ko.observable(false).extend({notify: 'always'});

    this.currentMessageTimer = ko.pureComputed(() => {
      return this.activeConversation().hasGlobalMessageTimer() ? this.activeConversation().messageTimer() : 0;
    });

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.isRendered())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'timed-messages';
  }

  clickOnMessageTime({value}) {
    const activeConversation = this.activeConversation();
    activeConversation.globalMessageTimer(value);
    this.conversationRepository.updateConversationMessageTimer(activeConversation, value);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ParticipantDevicesViewModel = class ParticipantDevicesViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get MODE() {
    return {
      FOUND: 'ParticipantDevicesViewModel.MODE.FOUND',
      NOT_FOUND: 'ParticipantDevicesViewModel.MODE.NOT_FOUND',
      REQUESTING: 'ParticipantDevicesViewModel.MODE.REQUESTING',
    };
  }

  constructor(params) {
    super(params);
    this.clickOnDevice = this.clickOnDevice.bind(this);

    const {client, conversation, cryptography} = params.repositories;
    this.clientRepository = client;
    this.conversationRepository = conversation;
    this.cryptographyRepository = cryptography;

    this.logger = new z.util.Logger('z.viewModel.panel.ParticipantDevicesViewModel', z.config.LOGGER.OPTIONS);

    this.selfClient = this.clientRepository.currentClient;

    this.deviceMode = ko.observable(ParticipantDevicesViewModel.MODE.REQUESTING);
    this.fingerprintLocal = ko.observableArray([]);
    this.fingerprintRemote = ko.observableArray([]);
    this.isResettingSession = ko.observable(false);
    this.showSelfFingerprint = ko.observable(false);
    this.selectedClient = ko.observable();
    this.selectedClientSubscription = undefined;
    this.userEntity = ko.observable();

    this.clientEntities = ko.pureComputed(() => this.userEntity() && this.userEntity().devices());

    this.showDeviceDetails = ko.pureComputed(() => this.selectedClient() && !this.showSelfFingerprint());
    this.showDevicesFound = ko.pureComputed(() => {
      const modeIsFound = this.deviceMode() === ParticipantDevicesViewModel.MODE.FOUND;
      return !this.selectedClient() && !this.showSelfFingerprint() && modeIsFound;
    });
    this.showDevicesNotFound = ko.pureComputed(() => {
      const modeIsNotFound = this.deviceMode() === ParticipantDevicesViewModel.MODE.NOT_FOUND;
      return !this.selectedClient() && !this.showSelfFingerprint() && modeIsNotFound;
    });

    this.detailMessage = ko.pureComputed(() => {
      if (!this.userEntity()) {
        return '';
      }

      const text = z.l10n.text(z.string.participantDevicesDetailHeadline, {user: this.userEntity().first_name()});

      const textWithHtmlTags = /\{\{[^\}]+\}\}[^\{]+\{\{[^\}]+\}\}/;
      const textWithinHtmlTags = /\{\{[^\}]+\}\}/gm;

      const [pivot] = text.match(textWithHtmlTags) || [];
      const sanitizedText = z.util.StringUtil.splitAtPivotElement(text, pivot, pivot);

      return sanitizedText.map(element => {
        if (element.isStyled) {
          element.text = element.text.replace(textWithinHtmlTags, '');
        }
        return element;
      });
    });

    this.devicesHeadlineText = ko.pureComputed(() => {
      return this.userEntity() ? z.l10n.text(z.string.participantDevicesHeadline, this.userEntity().first_name()) : '';
    });

    this.noDevicesHeadlineText = ko.pureComputed(() => {
      return this.userEntity()
        ? z.l10n.text(z.string.participantDevicesOutdatedClientMessage, this.userEntity().first_name())
        : '';
    });

    this.isVisible.subscribe(isVisible => {
      if (isVisible && this.userEntity()) {
        const userId = this.userEntity().id;

        this.clientRepository
          .getClientsByUserId(userId)
          .then(clientEntities => {
            const hasDevices = clientEntities.length > 0;
            const deviceMode = hasDevices
              ? ParticipantDevicesViewModel.MODE.FOUND
              : ParticipantDevicesViewModel.MODE.NOT_FOUND;
            this.deviceMode(deviceMode);
          })
          .catch(error => {
            this.logger.error(`Unable to retrieve clients for user '${userId}': ${error.message || error}`);
          });
      }

      this.selectedClientSubscription = this.selectedClient.subscribe(() => {
        this.fingerprintRemote([]);

        if (this.selectedClient()) {
          this.cryptographyRepository
            .getRemoteFingerprint(this.userEntity().id, this.selectedClient().id)
            .then(remoteFingerprint => this.fingerprintRemote(remoteFingerprint));
        }
      });
    });
    this.shouldUpdateScrollbar = ko
      .computed(() => this.clientEntities() && this.showDeviceDetails() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'participant-devices';
  }

  clickOnBack() {
    if (this.showSelfFingerprint()) {
      return this.showSelfFingerprint(false);
    }

    if (this.selectedClient()) {
      return this.selectedClient(undefined);
    }

    this.onGoBack();
  }

  clickOnDevice(clientEntity) {
    this.selectedClient(clientEntity);
  }

  clickToResetSession() {
    const _resetProgress = () => window.setTimeout(() => this.isResettingSession(false), z.motion.MotionDuration.LONG);

    this.isResettingSession(true);
    this.conversationRepository
      .reset_session(this.userEntity().id, this.selectedClient().id, this.activeConversation().id)
      .then(() => _resetProgress())
      .catch(() => _resetProgress());
  }

  clickOnShowSelfDevices() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_DEVICES);
  }

  clickToShowSelfFingerprint() {
    if (!this.fingerprintLocal().length) {
      this.fingerprintLocal(this.cryptographyRepository.getLocalFingerprint());
    }
    this.showSelfFingerprint(true);
  }

  clickToToggleDeviceVerification() {
    const toggleVerified = !this.selectedClient().meta.isVerified();

    this.clientRepository
      .verifyClient(this.userEntity().id, this.selectedClient(), toggleVerified)
      .catch(error => this.logger.warn(`Failed to toggle client verification: ${error.message}`));
  }

  initView({entity: userEntity}) {
    this.showSelfFingerprint(false);
    this.selectedClient(undefined);
    this.deviceMode(ParticipantDevicesViewModel.MODE.REQUESTING);

    if (this.selectedClientSubscription) {
      this.selectedClientSubscription.dispose();
    }
    this.userEntity(userEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ListViewModel = class ListViewModel {
  static get MODAL_TYPE() {
    return {
      TAKEOVER: 'ListViewModel.MODAL_TYPE.TAKEOVER',
      TEMPORARY_GUEST: 'ListViewModal.MODAL_TYPE.TEMPORARY_GUEST',
    };
  }

  static get STATE() {
    return {
      ARCHIVE: 'ListViewModel.STATE.ARCHIVE',
      CONVERSATIONS: 'ListViewModel.STATE.CONVERSATIONS',
      PREFERENCES: 'ListViewModel.STATE.PREFERENCES',
      START_UI: 'ListViewModel.STATE.START_UI',
      TEMPORARY_GUEST: 'ListViewModel.STATE.TEMPORARY_GUEST',
    };
  }
  /**
   * View model for the list column.
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {Object} repositories - Object containing all the repositories
   */
  constructor(mainViewModel, repositories) {
    this.changeNotificationSetting = this.changeNotificationSetting.bind(this);
    this.switchList = this.switchList.bind(this);
    this.onContextMenu = this.onContextMenu.bind(this);

    this.elementId = 'left-column';
    this.conversationRepository = repositories.conversation;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.actionsViewModel = mainViewModel.actions;
    this.contentViewModel = mainViewModel.content;
    this.panelViewModel = mainViewModel.panel;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isProAccount = this.teamRepository.isTeam;
    this.selfUser = this.userRepository.self;

    this.logger = new z.util.Logger('z.viewModel.ListViewModel', z.config.LOGGER.OPTIONS);

    // State
    this.state = ko.observable(ListViewModel.STATE.CONVERSATIONS);
    this.lastUpdate = ko.observable();
    this.modal = ko.observable();
    this.webappLoaded = ko.observable(false);

    this.selfUserPicture = ko.pureComputed(() => {
      if (this.webappLoaded() && this.selfUser()) {
        return this.selfUser().mediumPictureResource();
      }
    });

    this.visibleListItems = ko.pureComputed(() => {
      const isStatePreferences = this.state() === ListViewModel.STATE.PREFERENCES;
      if (isStatePreferences) {
        const preferenceItems = [
          z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_AV,
        ];

        if (!z.util.Environment.desktop) {
          preferenceItems.push(z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT);
        }

        return preferenceItems;
      }

      const hasConnectRequests = !!this.userRepository.connect_requests().length;
      const states = hasConnectRequests ? z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS : [];
      return this.conversationRepository
        .conversations_calls()
        .concat(states, this.conversationRepository.conversations_unarchived());
    });

    // Nested view models
    this.archive = new z.viewModel.list.ArchiveViewModel(mainViewModel, this, repositories);
    this.conversations = new z.viewModel.list.ConversationListViewModel(mainViewModel, this, repositories);
    this.preferences = new z.viewModel.list.PreferencesListViewModel(mainViewModel, this, repositories);
    this.start = new z.viewModel.list.StartUIViewModel(mainViewModel, this, repositories);
    this.takeover = new z.viewModel.list.TakeoverViewModel(mainViewModel, this, repositories);
    this.temporaryGuest = new z.viewModel.list.TemporaryGuestViewModel(mainViewModel, this, repositories);

    this._initSubscriptions();

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.SHOW, this.openConversations.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, () => this.webappLoaded(true));
    amplify.subscribe(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT, this.openPreferencesAccount.bind(this));
    amplify.subscribe(z.event.WebApp.PREFERENCES.MANAGE_DEVICES, this.openPreferencesDevices.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.SHOW, this.openStartUI.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.NEXT, this.goToNext.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.PREV, this.goToPrevious.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.ARCHIVE, this.clickToArchive.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.DELETE, this.clickToClear.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.NOTIFICATIONS, this.changeNotificationSetting);
    amplify.subscribe(z.event.WebApp.SHORTCUT.SILENCE, this.changeNotificationSetting); // todo: deprecated - remove when user base of wrappers version >= 3.4 is large enough
  }

  changeNotificationSetting() {
    if (this.isProAccount()) {
      this.panelViewModel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
    } else {
      this.clickToToggleMute();
    }
  }

  goToNext() {
    this._iterateActiveItem(true);
  }

  goToPrevious() {
    this._iterateActiveItem(false);
  }

  _iterateActiveItem(reverse = false) {
    const isStatePreferences = this.state() === ListViewModel.STATE.PREFERENCES;
    return isStatePreferences ? this._iterateActivePreference(reverse) : this._iterateActiveConversation(reverse);
  }

  _iterateActiveConversation(reverse) {
    const isStateRequests = this.contentViewModel.state() === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    const activeConversationItem = isStateRequests
      ? z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS
      : this.conversationRepository.active_conversation();

    const nextItem = z.util.ArrayUtil.iterateItem(this.visibleListItems(), activeConversationItem, reverse);

    const isConnectionRequestItem = nextItem === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    if (isConnectionRequestItem) {
      return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    if (nextItem) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextItem);
    }
  }

  _iterateActivePreference(reverse) {
    let activePreference = this.contentViewModel.state();

    const isDeviceDetails = activePreference === z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS;
    if (isDeviceDetails) {
      activePreference = z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES;
    }

    const nextPreference = z.util.ArrayUtil.iterateItem(this.visibleListItems(), activePreference, reverse);
    if (nextPreference) {
      this.contentViewModel.switchContent(nextPreference);
    }
  }

  openPreferencesAccount() {
    if (this.isActivatedAccount()) {
      this.dismissModal();
    }

    this.switchList(ListViewModel.STATE.PREFERENCES);
    this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  openPreferencesDevices(deviceEntity) {
    this.switchList(ListViewModel.STATE.PREFERENCES);

    if (deviceEntity) {
      this.contentViewModel.preferencesDeviceDetails.device(deviceEntity);
      return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS);
    }

    return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
  }

  openStartUI() {
    this.switchList(ListViewModel.STATE.START_UI);
  }

  switchList(newListState, respectLastState = true) {
    const isStateChange = this.state() !== newListState;
    if (isStateChange) {
      this._hideList();
      this._updateList(newListState, respectLastState);
      this._showList(newListState);
    }
  }

  openConversations() {
    const newState = this.isActivatedAccount()
      ? ListViewModel.STATE.CONVERSATIONS
      : ListViewModel.STATE.TEMPORARY_GUEST;
    this.switchList(newState, false);
  }

  _hideList() {
    const stateIsStartUI = this.state() === ListViewModel.STATE.START_UI;
    if (stateIsStartUI) {
      this.start.resetView();
    }

    const listStateElementId = this._getElementIdOfList(this.state());
    $(`#${listStateElementId}`).removeClass('left-list-is-visible');
    $(document).off('keydown.listView');
  }

  _showList(newListState) {
    const listStateElementId = this._getElementIdOfList(newListState);
    $(`#${listStateElementId}`).addClass('left-list-is-visible');

    this.state(newListState);
    this.lastUpdate(Date.now());

    $(document).on('keydown.listView', keyboardEvent => {
      if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
        const newState = this.isActivatedAccount()
          ? ListViewModel.STATE.CONVERSATIONS
          : ListViewModel.STATE.TEMPORARY_GUEST;
        this.switchList(newState);
      }
    });
  }

  _updateList(newListState, respectLastState) {
    switch (newListState) {
      case ListViewModel.STATE.ARCHIVE:
        this.archive.updateList();
        break;
      case ListViewModel.STATE.START_UI:
        this.start.updateList();
        break;
      case ListViewModel.STATE.PREFERENCES:
        amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
        break;
      default:
        if (respectLastState) {
          this.contentViewModel.switchPreviousContent();
        }
    }
  }

  _getElementIdOfList(listState) {
    switch (listState) {
      case ListViewModel.STATE.ARCHIVE:
        return 'archive';
      case ListViewModel.STATE.PREFERENCES:
        return 'preferences';
      case ListViewModel.STATE.START_UI:
        return 'start-ui';
      case ListViewModel.STATE.TEMPORARY_GUEST:
        return 'temporary-guest';
      default:
        return 'conversations';
    }
  }

  dismissModal() {
    this.modal(undefined);
  }

  showTakeover() {
    this.modal(ListViewModel.MODAL_TYPE.TAKEOVER);
  }

  showTemporaryGuest() {
    this.switchList(ListViewModel.STATE.TEMPORARY_GUEST);
    this.modal(ListViewModel.MODAL_TYPE.TEMPORARY_GUEST);
    const conversationEntity = this.conversationRepository.getMostRecentConversation();
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
  }

  //##############################################################################
  // Context menu
  //##############################################################################

  onContextMenu(conversationEntity, event) {
    const entries = [];

    if (conversationEntity.isMutable()) {
      const notificationsShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.NOTIFICATIONS);

      if (this.isProAccount()) {
        entries.push({
          click: () => this.clickToOpenNotificationSettings(conversationEntity),
          label: z.l10n.text(z.string.conversationsPopoverNotificationSettings),
          title: z.l10n.text(z.string.tooltipConversationsNotifications, notificationsShortcut),
        });
      } else {
        const labelStringId = conversationEntity.showNotificationsNothing()
          ? z.string.conversationsPopoverNotify
          : z.string.conversationsPopoverSilence;
        const titleStringId = conversationEntity.showNotificationsNothing()
          ? z.string.tooltipConversationsNotify
          : z.string.tooltipConversationsSilence;

        entries.push({
          click: () => this.clickToToggleMute(conversationEntity),
          label: z.l10n.text(labelStringId),
          title: z.l10n.text(titleStringId, notificationsShortcut),
        });
      }
    }

    if (conversationEntity.is_archived()) {
      entries.push({
        click: () => this.clickToUnarchive(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverUnarchive),
      });
    } else {
      const shortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.ARCHIVE);

      entries.push({
        click: () => this.clickToArchive(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverArchive),
        title: z.l10n.text(z.string.tooltipConversationsArchive, shortcut),
      });
    }

    if (conversationEntity.isRequest()) {
      entries.push({
        click: () => this.clickToCancelRequest(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverCancel),
      });
    }

    if (conversationEntity.isClearable()) {
      entries.push({
        click: () => this.clickToClear(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverClear),
      });
    }

    if (!conversationEntity.isGroup()) {
      const userEntity = conversationEntity.firstUserEntity();
      const canBlock = userEntity && (userEntity.isConnected() || userEntity.isRequest());

      if (canBlock) {
        entries.push({
          click: () => this.clickToBlock(conversationEntity),
          label: z.l10n.text(z.string.conversationsPopoverBlock),
        });
      }
    }

    if (conversationEntity.isLeavable()) {
      entries.push({
        click: () => this.clickToLeave(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverLeave),
      });
    }

    z.ui.Context.from(event, entries, 'conversation-list-options-menu');
  }

  clickToArchive(conversationEntity = this.conversationRepository.active_conversation()) {
    if (this.isActivatedAccount()) {
      this.actionsViewModel.archiveConversation(conversationEntity);
    }
  }

  clickToBlock(conversationEntity) {
    const userEntity = conversationEntity.firstUserEntity();
    const hideConversation = this._shouldHideConversation(conversationEntity);
    const nextConversationEntity = this.conversationRepository.get_next_conversation(conversationEntity);

    this.actionsViewModel.blockUser(userEntity, hideConversation, nextConversationEntity);
  }

  clickToCancelRequest(conversationEntity) {
    const userEntity = conversationEntity.firstUserEntity();
    const hideConversation = this._shouldHideConversation(conversationEntity);
    const nextConversationEntity = this.conversationRepository.get_next_conversation(conversationEntity);

    this.actionsViewModel.cancelConnectionRequest(userEntity, hideConversation, nextConversationEntity);
  }

  clickToClear(conversationEntity = this.conversationRepository.active_conversation()) {
    this.actionsViewModel.clearConversation(conversationEntity);
  }

  clickToLeave(conversationEntity) {
    this.actionsViewModel.leaveConversation(conversationEntity);
  }

  clickToToggleMute(conversationEntity = this.conversationRepository.active_conversation()) {
    this.actionsViewModel.toggleMuteConversation(conversationEntity);
  }

  clickToOpenNotificationSettings(conversationEntity = this.conversationRepository.active_conversation()) {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity, {openNotificationSettings: true});
  }

  clickToUnarchive(conversationEntity) {
    this.conversationRepository.unarchiveConversation(conversationEntity, true, 'manual un-archive').then(() => {
      if (!this.conversationRepository.conversations_archived().length) {
        this.switchList(ListViewModel.STATE.CONVERSATIONS);
      }
    });
  }

  _shouldHideConversation(conversationEntity) {
    const isStateConversations = this.state() === ListViewModel.STATE.CONVERSATIONS;
    const isActiveConversation = this.conversationRepository.is_active_conversation(conversationEntity);

    return isStateConversations && isActiveConversation;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.ArchiveViewModel = class ArchiveViewModel {
  /**
   * View model for the archive.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.clickOnClose = this.clickOnClose.bind(this);
    this.updateList = this.updateList.bind(this);

    this.listViewModel = listViewModel;
    this.conversationRepository = repositories.conversation;
    this.logger = new z.util.Logger('z.viewModel.list.ArchiveViewModel', z.config.LOGGER.OPTIONS);

    this.archivedConversations = this.conversationRepository.conversations_archived;

    this.shouldUpdateScrollbar = ko
      .computed(() => this.listViewModel.lastUpdate())
      .extend({notify: 'always', rateLimit: 500});
  }

  clickOnConversation(conversationEntity) {
    this.conversationRepository.unarchiveConversation(conversationEntity, 'opened conversation from archive');
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
  }

  clickOnClose() {
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
  }

  updateList() {
    this.conversationRepository.updateArchivedConversations();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.ConversationListViewModel = class ConversationListViewModel {
  /**
   * View model for conversation list.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.isSelectedConversation = this.isSelectedConversation.bind(this);

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.permissionRepository = repositories.permission;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.videoGridRepository = repositories.videoGrid;

    this.contentViewModel = mainViewModel.content;
    this.listViewModel = listViewModel;

    this.logger = new z.util.Logger('z.viewModel.list.ConversationListViewModel', z.config.LOGGER.OPTIONS);
    this.multitasking = this.contentViewModel.multitasking;

    this.showCalls = ko.observable(false);

    this.contentState = this.contentViewModel.state;
    this.selectedConversation = ko.observable();

    this.isTeam = this.teamRepository.isTeam;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selfUser = ko.pureComputed(() => this.userRepository.self && this.userRepository.self());
    this.selfAvailability = ko.pureComputed(() => this.selfUser() && this.selfUser().availability());
    this.selfUserName = ko.pureComputed(() => this.selfUser() && this.selfUser().name());

    this.connectRequests = this.userRepository.connect_requests;
    this.connectRequestsText = ko.pureComputed(() => {
      const hasMultipleRequests = this.connectRequests().length > 1;
      const stringId = hasMultipleRequests
        ? z.string.conversationsConnectionRequestMany
        : z.string.conversationsConnectionRequestOne;

      return z.l10n.text(stringId, this.connectRequests().length);
    });
    this.stateIsRequests = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    });

    this.callConversations = this.conversationRepository.conversations_calls;
    this.archivedConversations = this.conversationRepository.conversations_archived;
    this.unarchivedConversations = this.conversationRepository.conversations_unarchived;

    this.noConversations = ko.pureComputed(() => {
      const noConversations = !this.unarchivedConversations().length && !this.callConversations().length;
      return noConversations && !this.connectRequests().length;
    });

    this.webappIsLoaded = ko.observable(false);

    this.shouldUpdateScrollbar = ko
      .computed(() => {
        const numberOfConversations = this.unarchivedConversations().length + this.callConversations().length;
        return this.webappIsLoaded() || numberOfConversations || this.connectRequests().length;
      })
      .extend({notify: 'always', rateLimit: 500});

    this.activeConversationId = ko.pureComputed(() => {
      if (this.conversationRepository.active_conversation()) {
        return this.conversationRepository.active_conversation().id;
      }
    });

    this.archiveTooltip = ko.pureComputed(() => {
      return z.l10n.text(z.string.tooltipConversationsArchived, this.archivedConversations().length);
    });

    const startShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.START);
    this.startTooltip = z.l10n.text(z.string.tooltipConversationsStart, startShortcut);

    this.showConnectRequests = ko.pureComputed(() => this.connectRequests().length);

    this.showBadge = ko.observable(false);

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setShowCallsState.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.onWebappLoaded.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.START, this.clickOnPeopleButton.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.BADGE.SHOW, () => this.showBadge(true));
    amplify.subscribe(z.event.WebApp.SEARCH.BADGE.HIDE, () => this.showBadge(false));
  }

  clickOnAvailability(viewModel, event) {
    z.ui.AvailabilityContextMenu.show(event, 'list_header', 'left-list-availability-menu');
  }

  clickOnConnectRequests() {
    this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
  }

  clickOnConversation(conversationEntity) {
    if (!this.isSelectedConversation(conversationEntity)) {
      this.contentViewModel.showConversation(conversationEntity);
    }
  }

  setShowCallsState(handlingNotifications) {
    const shouldShowCalls = handlingNotifications === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.showCalls() !== shouldShowCalls;
    if (isStateChange) {
      this.showCalls(shouldShowCalls);
      this.logger.debug(`Set show calls state to: ${this.showCalls()}`);
    }
  }

  isSelectedConversation(conversationEntity) {
    const expectedStates = [
      z.viewModel.ContentViewModel.STATE.COLLECTION,
      z.viewModel.ContentViewModel.STATE.COLLECTION_DETAILS,
      z.viewModel.ContentViewModel.STATE.CONVERSATION,
    ];

    const isSelectedConversation = this.conversationRepository.is_active_conversation(conversationEntity);
    const isExpectedState = expectedStates.includes(this.contentState());

    return isSelectedConversation && isExpectedState;
  }

  onWebappLoaded() {
    this.webappIsLoaded(true);
  }

  //##############################################################################
  // Footer actions
  //##############################################################################

  clickOnArchivedButton() {
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.ARCHIVE);
  }

  clickOnPreferencesButton() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickOnPeopleButton() {
    if (this.isActivatedAccount()) {
      this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.START_UI);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.PreferencesListViewModel = class PreferencesListViewModel {
  /**
   * View model for the preferences list.
   * @param {z.viewModel.ListViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all the repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.mainViewModel = mainViewModel;
    this.listViewModel = listViewModel;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.PreferencesListViewModel', z.config.LOGGER.OPTIONS);

    this.contentViewModel = this.mainViewModel.content;
    this.contentState = this.contentViewModel.state;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selectedAbout = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT;
    });
    this.selectedAccount = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT;
    });
    this.selectedAV = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_AV;
    });
    this.selectedDevices = ko.pureComputed(() => {
      const devicesState = [
        z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS,
        z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES,
      ];
      return devicesState.includes(this.contentState());
    });
    this.selectedOptions = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS;
    });
  }

  clickOnClosePreferences() {
    const preventingContentViewStates = [
      z.viewModel.ContentViewModel.STATE.HISTORY_EXPORT,
      z.viewModel.ContentViewModel.STATE.HISTORY_IMPORT,
    ];

    if (!preventingContentViewStates.includes(this.contentState())) {
      if (!this.isActivatedAccount()) {
        return this.listViewModel.showTemporaryGuest();
      }
      this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
    }
  }

  clickOnAbout() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT);
  }

  clickOnAccount() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  clickOnAV() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_AV);
  }

  clickOnDevices() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
  }

  clickOnOptions() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS);
  }

  _switchContent(newContentState) {
    this.contentViewModel.switchContent(newContentState);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.StartUIViewModel = class StartUIViewModel {
  static get STATE() {
    return {
      ADD_PEOPLE: 'StartUIViewModel.STATE.ADD_PEOPLE',
      ADD_SERVICE: 'StartUIViewModel.STATE.ADD_SERVICE',
    };
  }

  /**
   * View model for the start UI.
   * @class z.viewModel.list.StartUIViewModel
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnClose = this.clickOnClose.bind(this);
    this.clickOnContact = this.clickOnContact.bind(this);
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.clickOnOther = this.clickOnOther.bind(this);
    this.clickToOpenService = this.clickToOpenService.bind(this);

    this.clickToAcceptInvite = this.clickToAcceptInvite.bind(this);
    this.clickToIgnoreInvite = this.clickToIgnoreInvite.bind(this);
    this.clickToSendRequest = this.clickToSendRequest.bind(this);
    this.clickToUnblock = this.clickToUnblock.bind(this);

    this.handleSearchInput = this.handleSearchInput.bind(this);

    this.mainViewModel = mainViewModel;
    this.listViewModel = listViewModel;
    this.connectRepository = repositories.connect;
    this.conversationRepository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.propertiesRepository = repositories.properties;
    this.searchRepository = repositories.search;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.StartUIViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;

    this.selfUser = this.userRepository.self;

    this.isTeam = this.teamRepository.isTeam;
    this.teamName = this.teamRepository.teamName;
    this.teamSize = this.teamRepository.teamSize;

    this.state = ko.observable(StartUIViewModel.STATE.ADD_PEOPLE);

    this.peopleTabActive = ko.pureComputed(() => this.state() === StartUIViewModel.STATE.ADD_PEOPLE);

    this.submittedSearch = false;

    this.search = _.debounce(query => {
      this._clearSearchResults();
      if (this.peopleTabActive()) {
        return this._searchPeople(query);
      }

      this.integrationRepository.searchForServices(query, this.searchInput);
    }, 300);

    this.searchInput = ko.observable('');
    this.searchInput.subscribe(this.search);
    this.isSearching = ko.pureComputed(() => this.searchInput().length);

    // User lists
    this.contacts = ko.pureComputed(() => {
      if (this.showMatches()) {
        return this.matchedUsers();
      }

      return this.isTeam() ? this.teamRepository.teamUsers() : this.userRepository.connected_users();
    });

    this.matchedUsers = ko.observableArray([]);
    this.services = this.integrationRepository.services;
    this.topUsers = ko.observableArray([]);

    this.searchResults = {
      contacts: ko.observableArray([]),
      groups: ko.observableArray([]),
      others: ko.observableArray([]),
    };

    // View states
    this.hasSearchResults = ko.pureComputed(() => {
      const {contacts, groups, others} = this.searchResults;
      return contacts().length || groups().length || others().length;
    });

    this.showContent = ko.pureComputed(() => this.showContacts() || this.showMatches() || this.showSearchResults());
    this.showContacts = ko.pureComputed(() => this.contacts().length);
    this.showCreateGuestRoom = ko.pureComputed(() => this.isTeam());
    this.showInvitePeople = ko.pureComputed(() => !this.isTeam());
    this.showMatches = ko.observable(false);

    this.showNoContacts = ko.pureComputed(() => !this.isTeam() && !this.showContent());
    this.showInviteMember = ko.pureComputed(() => this.selfUser().isTeamOwner() && this.teamSize() === 1);
    this.showNoMatches = ko.pureComputed(() => {
      const isTeamOrMatch = this.isTeam() || this.showMatches();
      return isTeamOrMatch && !this.showInviteMember() && !this.showContacts() && !this.showSearchResults();
    });
    this.showNoSearchResults = ko.pureComputed(() => {
      return !this.showMatches() && this.showSearchResults() && !this.hasSearchResults() && this.isSearching();
    });

    this.showSearchResults = ko.pureComputed(() => {
      const shouldShowResults = this.hasSearchResults() || this.isSearching();
      if (!shouldShowResults) {
        this._clearSearchResults();
      }
      return shouldShowResults;
    });
    this.showSpinner = ko.observable(false);
    this.showTopPeople = ko.pureComputed(() => !this.isTeam() && this.topUsers().length && !this.showMatches());

    // Invite bubble states
    this.showInviteForm = ko.observable(true);

    // Invite bubble
    this.inviteBubble = null;

    this.inviteHint = ko.pureComputed(() => {
      const metaKey = z.util.Environment.os.mac
        ? z.l10n.text(z.string.inviteMetaKeyMac)
        : z.l10n.text(z.string.inviteMetaKeyPc);

      const stringId = this.inviteMessageSelected() ? z.string.inviteHintSelected : z.string.inviteHintUnselected;
      return z.l10n.text(stringId, metaKey);
    });
    this.inviteMessage = ko.pureComputed(() => {
      if (this.selfUser()) {
        const username = this.selfUser().username();
        return username
          ? z.l10n.text(z.string.inviteMessage, `@${username}`)
          : z.l10n.text(z.string.inviteMessageNoEmail);
      }
      return '';
    });
    this.inviteMessageSelected = ko.observable(true);

    // Selected user bubble
    this.userProfile = ko.observable(null);
    this.userProfileIsService = ko.pureComputed(() => this.userProfile() instanceof z.integration.ServiceEntity);

    this.additionalBubbleClasses = ko.pureComputed(() => {
      return this.userProfileIsService() ? 'start-ui-service-bubble' : '';
    });

    this.renderAvatar = ko.observable(false);
    this.renderAvatarComputed = ko.computed(() => {
      const hasUserId = !!this.userProfile();

      // swap value to re-render avatar
      this.renderAvatar(false);
      window.setTimeout(() => this.renderAvatar(hasUserId), 0);
    });

    this.serviceConversations = ko.observable([]);

    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());
    this.isInitialServiceSearch = ko.observable(true);

    this.userBubble = undefined;
    this.userBubbleLastId = undefined;

    this.shouldUpdateScrollbar = ko
      .computed(() => this.listViewModel.lastUpdate())
      .extend({notify: 'always', rateLimit: 500});

    this.shouldUpdateServiceScrollbar = ko
      .computed(() => this.serviceConversations())
      .extend({notify: 'always', rateLimit: 500});

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONNECT.IMPORT_CONTACTS, this.importContacts.bind(this));
  }

  clickOnClose() {
    this._closeList();
  }

  clickOnContact(userEntity) {
    return this.actionsViewModel.open1to1Conversation(userEntity).then(() => this._closeList());
  }

  clickOnConversation(conversationEntity) {
    return this.actionsViewModel.openGroupConversation(conversationEntity).then(() => this._closeList());
  }

  clickOnCreateGroup() {
    amplify.publish(z.event.WebApp.CONVERSATION.CREATE_GROUP, 'start_ui');
  }

  clickOnCreateGuestRoom() {
    this.conversationRepository.createGuestRoom().then(conversationEntity => {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.GUEST_ROOM_CREATION);
    });
  }

  clickOpenManageTeam() {
    this._openTeamSettings(z.config.URL_PATH.MANAGE_TEAM);
  }

  clickOpenManageServices() {
    this._openTeamSettings(z.config.URL_PATH.MANAGE_SERVICES);
  }

  _openTeamSettings(pagePath) {
    const path = `${pagePath}?utm_source=client_landing&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  clickOnOther(participantEntity, event) {
    const isUser = participantEntity instanceof z.entity.User;
    if (isUser && participantEntity.isOutgoingRequest()) {
      return this.clickOnContact(participantEntity);
    }

    const createBubble = elementId => {
      this.userProfile(participantEntity);
      this.userBubbleLastId = elementId;
      this.userBubble = new zeta.webapp.module.Bubble({
        host_selector: `#${element.attr('id')}`,
        on_hide: () => {
          this.userBubble = undefined;
          return (this.userBubbleLastId = undefined);
        },
        on_show: () => $('.start-ui-user-bubble .user-profile-connect-message').focus(),
        scroll_selector: '.start-ui-list',
      });

      if (this.userProfileIsService()) {
        this.integrationRepository.addProviderNameToParticipant(this.userProfile());
      }

      this.userBubble.toggle();
    };

    // We clicked on the same bubble
    const isCurrentBubble = this.userBubbleLastId === event.currentTarget.id;
    if (this.userBubble && isCurrentBubble) {
      return this.userBubble.toggle();
    }

    const element = $(event.currentTarget).attr({
      'data-bubble': '#start-ui-user-bubble',
      'data-placement': 'right-flex',
      id: Date.now(),
    });

    // Dismiss old bubble and wait with creating the new one when another bubble is open
    const timeout = this.userBubble ? z.motion.MotionDuration.LONG : 0;
    if (this.userBubble) {
      this.userBubble.hide();
    }
    window.setTimeout(() => createBubble(element[0].id), timeout);
  }

  clickOnShowPeople() {
    this.updateList(StartUIViewModel.STATE.ADD_PEOPLE);
  }

  clickOnShowServices() {
    this.updateList(StartUIViewModel.STATE.ADD_SERVICE);
  }

  clickToOpenService() {
    if (this.userBubble) {
      this.userBubble.hide();
    }

    this.actionsViewModel.open1to1ConversationWithService(this.userProfile());
  }

  handleSearchInput() {
    if (!this.submittedSearch && this.isSearching()) {
      const [matchingContact] = this.searchResults.contacts();
      if (matchingContact) {
        this.submittedSearch = true;
        return this.clickOnContact(matchingContact).then(() => (this.submittedSearch = false));
      }

      const [matchingGroup] = this.searchResults.groups();
      if (matchingGroup) {
        return this.clickOnConversation(matchingGroup);
      }
    }
  }

  resetView() {
    if (this.userBubble) {
      this.userBubble.hide();
    }

    if (this.inviteBubble) {
      this.inviteBubble.hide();
    }

    this.showMatches(false);
    this.showSpinner(false);

    this.state(StartUIViewModel.STATE.ADD_PEOPLE);
    this.searchInput('');
  }

  updateList(state = StartUIViewModel.STATE.ADD_PEOPLE) {
    this.showSpinner(false);

    // Clean up
    this._clearSearchResults();
    this.userProfile(null);
    $('user-input input').focus();

    this.state(state);
    const isAddingPeople = state === StartUIViewModel.STATE.ADD_PEOPLE;
    if (isAddingPeople) {
      return this._updatePeopleList();
    }
    this._updateServicesList();
  }

  _closeList() {
    $('user-input input').blur();

    amplify.publish(z.event.WebApp.SEARCH.HIDE);
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);

    this.resetView();
  }

  _updatePeopleList() {
    if (!this.isTeam()) {
      this.getTopPeople().then(userEntities => this.topUsers(userEntities));
    }
    this._searchPeople(this.searchInput());
  }

  _updateServicesList() {
    this.isInitialServiceSearch(true);
    this.integrationRepository
      .searchForServices(this.searchInput(), this.searchInput)
      .then(() => this.isInitialServiceSearch(false));
  }

  //##############################################################################
  // Data sources
  //##############################################################################

  getTopPeople() {
    return this.conversationRepository
      .get_most_active_conversations()
      .then(conversationEntities => {
        return conversationEntities
          .filter(conversationEntity => conversationEntity.is1to1())
          .slice(0, 6)
          .map(conversationEntity => conversationEntity.participating_user_ids()[0]);
      })
      .then(userIds => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => userEntities.filter(userEntity => !userEntity.isBlocked()));
  }

  //##############################################################################
  // User bubble
  //##############################################################################

  clickToAcceptInvite(userEntity) {
    this._closeList();
    this.actionsViewModel.acceptConnectionRequest(userEntity, true);
  }

  clickToIgnoreInvite(userEntity) {
    this.actionsViewModel.ignoreConnectionRequest(userEntity).then(() => {
      if (this.userBubble) {
        this.userBubble.hide();
      }
    });
  }

  clickToSendRequest(userEntity) {
    this._closeList();
    this.actionsViewModel.sendConnectionRequest(userEntity, true);
  }

  clickToUnblock(userEntity) {
    this._closeList();
    this.actionsViewModel.unblockUser(userEntity, true);
  }

  //##############################################################################
  // Invite bubble
  //##############################################################################

  clickOnImportContacts() {
    this._importContacts(z.connect.ConnectSource.ICLOUD);
  }

  clickToCloseGenericInvite() {
    this.showInviteForm(false);
  }

  clickToShowGenericInvite() {
    this.showInviteForm(true);
    this._focusInviteForm();
  }

  clickToShowInviteBubble() {
    if (!this.inviteBubble) {
      this.inviteBubble = new zeta.webapp.module.Bubble({
        host_selector: '#invite-button',
        on_hide: () => {
          $('.invite-link-box .bg').removeClass('bg-animation');
          $('.invite-link-box .message').off('copy blur focus');
          this.inviteBubble = null;
          this.showInviteForm(true);
        },
        on_show: () => {
          if (this.showInviteForm()) {
            this._focusInviteForm();
          }
        },
        scroll_selector: '.start-ui-list',
      });

      this.inviteBubble.show();
    }
  }

  _importContacts(type) {
    if (this.inviteBubble) {
      this.inviteBubble.hide();
    }
    this.importContacts(type);
  }

  _focusInviteForm() {
    $('.invite-link-box .message')
      .on('copy', event => {
        $(event.currentTarget)
          .parent()
          .find('.bg')
          .addClass('bg-animation')
          .on(z.util.alias.animationend, _event => {
            if (_event.originalEvent.animationName === 'message-bg-fadeout') {
              $(this).off(z.util.alias.animationend);

              if (this.inviteBubble) {
                this.inviteBubble.hide();
              }
            }
          });
      })
      .on('blur', () => this.inviteMessageSelected(false))
      .on('click', event => {
        this.inviteMessageSelected(true);
        $(event.target).select();
      })
      .trigger('click');
  }

  //##############################################################################
  // Contacts import
  //##############################################################################

  /**
   * Connect with contacts.
   * @param {z.connect.ConnectSource} source - Source for the contacts import
   * @returns {undefined} No return value
   */
  importContacts(source) {
    this.connectRepository
      .getContacts(source)
      .then((userIds = []) => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => {
        this.matchedUsers(userEntities);
        this.showMatches(true);
      })
      .catch(error => {
        const isNoContacts = error.type === z.error.ConnectError.TYPE.NO_CONTACTS;
        if (!isNoContacts) {
          this.logger.error(`Importing contacts from '${source}' failed: ${error.message}`, error);

          amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
            action: () => this.importContacts(source),
            text: {
              action: z.l10n.text(z.string.modalUploadContactsAction),
              message: z.l10n.text(z.string.modalUploadContactsMessage),
            },
          });
        }
      })
      .then(error => {
        this.showSpinner(false);
      });
  }

  //##############################################################################
  // Search
  //##############################################################################

  _clearSearchResults() {
    this.searchResults.groups.removeAll();
    this.searchResults.contacts.removeAll();
    this.searchResults.others.removeAll();
    this.services.removeAll();
  }

  _searchPeople(query) {
    const normalizedQuery = z.search.SearchRepository.normalizeQuery(query);
    if (normalizedQuery) {
      this.showMatches(false);

      // Contacts, groups and others
      const trimmedQuery = query.trim();
      const isHandle = trimmedQuery.startsWith('@') && z.user.UserHandleGenerator.validate_handle(normalizedQuery);

      this.searchRepository
        .search_by_name(normalizedQuery, isHandle)
        .then(userEntities => {
          const isCurrentQuery = normalizedQuery === z.search.SearchRepository.normalizeQuery(this.searchInput());
          if (isCurrentQuery) {
            this.searchResults.others(userEntities);
          }
        })
        .catch(error => this.logger.error(`Error searching for contacts: ${error.message}`, error));

      const localSearchSources = this.isTeam()
        ? this.teamRepository.teamUsers()
        : this.userRepository.connected_users();

      const SEARCHABLE_FIELDS = z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS;
      const searchFields = isHandle ? [SEARCHABLE_FIELDS.USERNAME] : undefined;

      const contactResults = this.searchRepository.searchUserInSet(normalizedQuery, localSearchSources, searchFields);

      this.searchResults.contacts(contactResults);
      this.searchResults.groups(this.conversationRepository.getGroupsByName(normalizedQuery, isHandle));
    }
  }

  dispose() {
    this.renderAvatarComputed.dispose();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.TakeoverViewModel = class TakeoverViewModel {
  /**
   * View model for the username takeover screen.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.listViewModel = listViewModel;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.TakeoverViewModel', z.config.LOGGER.OPTIONS);

    this.selfUser = this.userRepository.self;

    this.name = ko.pureComputed(() => (this.selfUser() ? this.selfUser().name() : ''));
    this.username = ko.pureComputed(() => (this.selfUser() ? this.selfUser().username() : ''));
  }

  chooseUsername() {
    this.listViewModel.dismissModal();
    window.requestAnimationFrame(() => amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT));
  }

  keepUsername() {
    this.userRepository
      .change_username(this.username())
      .then(() => {
        const conversationEntity = this.conversationRepository.getMostRecentConversation();
        if (conversationEntity) {
          return amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
        }

        if (this.userRepository.connect_requests().length) {
          amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
        }
      })
      .catch(() => amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT))
      .then(() => this.listViewModel.dismissModal());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.TemporaryGuestViewModel = class TemporaryGuestViewModel {
  /**
   * View model for the temporary guest experience.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.callingRepository = repositories.calling;
    this.multitasking = mainViewModel.content.multitasking;
    this.permissionRepository = repositories.permission;
    this.videoGridRepository = repositories.videoGrid;

    this.logger = new z.util.Logger('z.viewModel.list.TemporaryGuestViewModel', z.config.LOGGER.OPTIONS);

    this.callConversations = this.conversationRepository.conversations_calls;
    this.selfUser = this.userRepository.self;
  }

  clickOnPreferencesButton() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickToCreateAccount() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => window.location.replace(`/auth/${location.search}`),
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalAccountCreateAction),
        message: z.l10n.text(z.string.modalAccountCreateMessage),
        title: z.l10n.text(z.string.modalAccountCreateHeadline),
      },
      warning: false,
    });
  }

  isSelectedConversation() {
    return true;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AccentColorPicker = class AccentColorPicker {
  /**
   * Construct a audio seek bar that renders audio levels.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.User} params.user - User entity
   * @param {z.entity.File} params.asset - Asset file
   * @param {ko.observable} params.selected - Selected accent collor
   */
  constructor(params) {
    this.user = ko.unwrap(params.user);

    this.accent_color_ids = [1, 2, 4, 5, 6, 7];

    this.on_select = function(id) {
      params.selected(id);
      return true;
    };
  }
};

// Knockout registration of the accent color picker component.
ko.components.register('accent-color-picker', {
  template: `
    <!-- ko foreach: accent_color_ids -->
      <input type="radio" name="accent"
             data-bind="attr: {'id': 'accent' + $data, 'checked': $parent.user.accent_id() === $data}, click: $parent.on_select">
      <label data-bind="attr: {'for': 'accent' + $data},css: 'accent-color-' + $data"></label>
    <!-- /ko -->
  `,
  viewModel: z.components.AccentColorPicker,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AvailabilityState = class AvailabilityState {
  constructor(params) {
    this.availability = params.availability;
    this.label = params.label;
    this.showArrow = params.showArrow || false;
    this.theme = params.theme || false;
  }
};

ko.components.register('availability-state', {
  template: `
      <!-- ko if: $data.availability() === z.user.AvailabilityType.AVAILABLE -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="available">
          <circle cx="5" cy="5" r="5" stroke="none"></circle>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.availability() === z.user.AvailabilityType.AWAY -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="away">
          <circle cx="5" cy="5" r="4" stroke-width="2" fill="none"></circle>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.availability() === z.user.AvailabilityType.BUSY -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="busy">
          <path stroke="none" d="M5 10A5 5 0 1 1 5 0a5 5 0 0 1 0 10zM3 4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2H3z"></path>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.label -->
        <div class="availability-state-label" data-bind="css: {'text-theme': theme}, text: $data.label" data-uie-name="status-label"></div>
      <!-- /ko -->
      <!-- ko if: $data.showArrow -->
        <span class="availability-state-arrow"></span>
      <!-- /ko -->
        `,
  viewModel: z.components.AvailabilityState,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.CopyToClipboard = class CopyToClipboard {
  constructor(params) {
    this.text = params.text;
  }

  onClick(viewModel, event) {
    if (window.getSelection) {
      const selectionRange = document.createRange();
      selectionRange.selectNode(event.currentTarget);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(selectionRange);
    }
  }
};

ko.components.register('copy-to-clipboard', {
  template: `
    <div class="copy-to-clipboard" data-bind="click: onClick, text: text()"></div>
  `,
  viewModel: z.components.CopyToClipboard,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceCard = class DeviceCard {
  constructor(params, componentInfo) {
    this.device = ko.unwrap(params.device) || {};

    const {class: deviceClass, id, label, model} = this.device;
    this.class = deviceClass || '?';
    this.formattedId = id ? this.device.formatId() : [];
    this.id = id || '';
    this.label = label || '?';
    this.model = model || deviceClass || '?'; // devices for other users will only provide the device class

    this.isCurrentClient = params.current || false;
    this.detailed = params.detailed || false;
    this.click = params.click;

    this.dataUieName = `device-card-info${this.isCurrentClient ? '-current' : ''}`;

    if (this.detailed || !this.click) {
      $(componentInfo.element).addClass('device-card-no-hover');
    }
    if (this.detailed) {
      $(componentInfo.element).addClass('device-card-detailed');
    }
  }

  clickOnDevice() {
    if (typeof this.click === 'function') {
      this.click(this.device);
    }
  }
};

ko.components.register('device-card', {
  template: `
    <div class="device-info" data-bind="click: clickOnDevice,
      attr: {'data-uie-uid': id, 'data-uie-value': label, 'data-uie-name': dataUieName}">
      <!-- ko if: detailed -->
        <div class="label-xs device-label" data-bind="text: label"></div>
        <div class="label-xs">
          <span data-bind="l10n_text: z.string.preferencesDevicesId"></span>
          <span data-bind="foreach: formattedId" data-uie-name="device-id"><span class="device-id-part" data-bind="text: $data"></span></span>
        </div>
        <div class="label-xs" data-bind="text: z.util.TimeUtil.formatTimestamp(device.time)"></div>
      <!-- /ko -->
      <!-- ko ifnot: detailed -->
        <div class="label-xs">
          <span class="device-model" data-bind="text: model"></span>
          <span class="text-graphite-dark" data-bind="visible: isCurrentClient, l10n_text: z.string.authLimitDevicesCurrent"></span>
        </div>
        <div class="text-graphite-dark label-xs">
          <span data-bind="l10n_text: z.string.preferencesDevicesId"></span>
          <span data-bind="foreach: formattedId" data-uie-name="device-id"><span class="device-id-part" data-bind="text: $data"></span></span>
        </div>
      <!-- /ko -->
    </div>
    <!-- ko ifnot: detailed || !click-->
      <disclose-icon></disclose-icon>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.DeviceCard(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceRemove = class DeviceRemove {
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);

    this.device = ko.unwrap(params.device);
    this.device_remove_error = params.error || ko.observable(false);
    this.model = this.device.model;

    this.remove_form_visible = ko.observable(false);

    this.password = ko.observable('');
    this.password_subscription = this.password.subscribe(value => {
      if (value.length > 0) {
        return this.device_remove_error(false);
      }
    });

    this.click_on_submit = function() {
      if (typeof params.remove === 'function') {
        params.remove(this.password(), this.device);
      }
    };

    this.click_on_cancel = () => {
      this.remove_form_visible(false);
      if (typeof params.cancel === 'function') {
        params.cancel();
      }
    };

    this.click_on_remove_device = () => {
      this.remove_form_visible(true);
    };
  }

  dispose() {
    this.password_subscription.dispose();
  }
};

ko.components.register('device-remove', {
  template: `
    <!-- ko ifnot: remove_form_visible() -->
      <span class="device-remove-button text-red"
          data-bind="attr: {'data-uie-value': model}, click: click_on_remove_device, l10n_text: z.string.preferencesDevicesRemove"
          data-uie-name="go-remove-device"></span>
    <!-- /ko -->
    <!-- ko if: remove_form_visible() -->
      <form class="device-remove-form" data-bind="submit: click_on_submit, attr: {'data-uie-value': model}" data-ui-name="device-remove-form">
        <input  class="device-remove-input"
                type="password"
                data-bind="hasfocus: true, textInput: password, l10n_placeholder: z.string.authPlaceholderPasswordPut, css: {'device-remove-input-error': device_remove_error}"
                data-uie-name="remove-device-password" />
        <button class="device-remove-button-remove button button-medium button-fluid"
                data-bind="attr: {'data-uie-value': model}, l10n_text: z.string.preferencesDevicesRemove"
                data-uie-name="do-remove-device"
                type="submit"></button>
        <button class="device-remove-button text-graphite text-underline"
                data-bind="click: click_on_cancel, l10n_text: z.string.preferencesDevicesRemoveCancel"
                data-uie-name="remove-device-cancel"></button>
      </form>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.DeviceRemove(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.EphemeralTimer = class EphemeralTimer {
  constructor({message: messageEntity}) {
    this.started = messageEntity.ephemeral_started();
    this.duration = (messageEntity.ephemeral_expires() - this.started) / 1000;
  }

  setAnimationDelay(data, event) {
    // every time the component gets rendered, the animation delay gets set
    // to accomodate for the passed lifetime of the timed message
    event.target.style.animationDelay = `${(this.started - Date.now()) / 1000}s`;
  }
};

ko.components.register('ephemeral-timer', {
  template: `
    <svg class="ephemeral-timer" viewBox="0 0 8 8" width="8" height="8">
      <circle class="ephemeral-timer__background" cx="4" cy="4" r="3.5"></circle>
      <circle class="ephemeral-timer__dial" cx="4" cy="4" r="2" transform="rotate(-90 4 4)" data-bind="style: {'animation-duration': duration + 's'}, event: {animationstart: setAnimationDelay}">
      </circle>
    </svg>
  `,
  viewModel: z.components.EphemeralTimer,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.FullSearch = class FullSearch {
  static get CONFIG() {
    return {
      MAX_OFFSET_INDEX: 30,
      MAX_TEXT_LENGTH: 60,
      MAX_VISIBLE_MESSAGES: 30,
      PRE_MARKED_OFFSET: 20,
    };
  }

  constructor(params) {
    this.searchProvider = params.search_provider;

    this.onInputChange = query => {
      if (typeof params.change === 'function') {
        params.change(query);
      }
    };

    this.clickOnMessage = messageEntity => {
      if (typeof params.click === 'function') {
        params.click(messageEntity);
      }
    };

    this.messageEntities = [];
    this.visibleMessageEntities = ko.observableArray();

    this.showNoResultsText = ko.observable(false);

    this.input = ko.observable();
    this.input.subscribe(
      _.debounce(searchQuery => {
        searchQuery = searchQuery.trim();

        this.onInputChange(searchQuery);

        const isQueryToShort = searchQuery.length < 2;
        if (isQueryToShort) {
          this.messageEntities = [];
          this.visibleMessageEntities([]);
          return this.showNoResultsText(false);
        }

        this.searchProvider(searchQuery).then(({messageEntities, query}) => {
          const isMatchingQuery = query === this.input().trim();
          if (isMatchingQuery) {
            this.showNoResultsText(messageEntities.length === 0);
            this.messageEntities = messageEntities;
            this.visibleMessageEntities(this.messageEntities.splice(0, FullSearch.CONFIG.MAX_VISIBLE_MESSAGES));
          }
        });
      }, 100)
    );

    // binding?
    $('.collection-list').on('scroll', event => {
      const showAdditionalMessages = $(event.currentTarget).isScrolledBottom() && this.messageEntities.length;
      if (showAdditionalMessages) {
        const additionalMessageEntities = this.messageEntities.splice(0, FullSearch.CONFIG.MAX_VISIBLE_MESSAGES);
        z.util.koArrayPushAll(this.visibleMessageEntities, additionalMessageEntities);
      }
    });
  }

  htmlFormatResult(messageEntity) {
    const text = z.util.SanitizationUtil.escapeString(messageEntity.get_first_asset().text);
    const input = z.util.SanitizationUtil.escapeString(this.input());

    messageEntity.matchesCount = 0;

    const replaceRegex = z.search.FullTextSearch.getSearchRegex(input);
    const replaceFunction = match => {
      messageEntity.matchesCount += 1;
      return `<mark class='full-search-marked' data-uie-name='full-search-item-mark'>${match}</mark>`;
    };

    let transformedText = text.replace(replaceRegex, replaceFunction);

    const markOffset = transformedText.indexOf('<mark') - 1;
    let sliceOffset = markOffset;

    for (const index of _.range(markOffset).reverse()) {
      if (index < markOffset - FullSearch.CONFIG.PRE_MARKED_OFFSET) {
        break;
      }

      const char = transformedText[index];
      const isWhitespace = char === ' ';
      if (isWhitespace) {
        sliceOffset = index + 1;
      }
    }

    const textTooLong = text.length > FullSearch.CONFIG.MAX_TEXT_LENGTH;
    const offsetTooBig = markOffset > FullSearch.CONFIG.MAX_OFFSET_INDEX;
    if (textTooLong && offsetTooBig) {
      transformedText = `${transformedText.slice(sliceOffset)}`;
    }

    return transformedText;
  }

  clickOnDismiss() {
    this.input('');
  }

  dispose() {
    $('.collection-list').off('scroll');
  }
};

ko.components.register('full-search', {
  template: `
    <header class="full-search-header">
      <span class="full-search-header-icon icon-search"></span>
      <div class="full-search-header-input">
        <input type="text" data-bind="hasFocus: true, l10n_placeholder: z.string.fullsearchPlaceholder, textInput: input" data-uie-name="full-search-header-input"/>
        <span class="button-icon icon-dismiss" data-bind="click: clickOnDismiss, visible: input()" data-uie-name="full-search-dismiss"></span>
      </div>
    </header>
    <!-- ko if: showNoResultsText() -->
      <div class="full-search-no-result" data-bind="l10n_text: z.string.fullsearchNoResults" data-uie-name="full-search-no-results"></div>
    <!-- /ko -->
    <div class="full-search-list" data-bind="foreach: {data: visibleMessageEntities}" data-uie-name="full-search-list">
      <div class="full-search-item" data-bind="click: $parent.clickOnMessage" data-uie-name="full-search-item">
        <div class="full-search-item-avatar">
          <participant-avatar params="participant: user, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
        </div>
        <div class="full-search-item-content">
          <div class="full-search-item-content-text ellipsis" data-bind="html: $parent.htmlFormatResult($data)" data-uie-name="full-search-item-text"></div>
          <div class="full-search-item-content-info">
            <span class="font-weight-bold" data-bind="text: user().first_name()" data-uie-name="full-search-item-sender"></span>
            <span data-bind="text: moment($data.timestamp()).format('MMMM D, YYYY')" data-uie-name="full-search-item-timestamp"></span>
          </div>
        </div>
        <div class="badge" data-bind="text: matchesCount, visible: matchesCount > 1" data-uie-name="full-search-item-badge"></div>
      </div>
    </div>
  `,
  viewModel: z.components.FullSearch,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupListViewModel = class GroupListViewModel {
  /**
   * Construct a new group list view model.
   *
   * @param {Object} params - Component parameters
   * @param {ko.observableArray} params.groups - Data source
   * @param {Function} params.click - Function called when a list item is clicked
   */
  constructor(params) {
    this.groups = params.groups;
    this.on_select = params.click;
  }
};

// Knockout registration of the group list component.
ko.components.register('group-list', {
  template: `
    <div class="search-list search-list-lg" data-bind="foreach: {data: groups, as: 'group'}">
      <div class="search-list-item" data-bind="click: $parent.on_select, attr: {'data-uie-uid': group.id, 'data-uie-value': group.display_name" data-uie-name="item-group">
        <div class="search-list-item-image">
          <group-avatar params="users: group.participating_user_ets()"></group-avatar>
        </div>
        <div class="search-list-item-header" data-bind="text: group.display_name"></div>
      </div>
    </div>
  `,
  viewModel: z.components.GroupListViewModel,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupVideoGrid = class GroupVideoGrid {
  static get CONFIG() {
    return {
      CONTAIN_CLASS: 'group-video-grid__element-video--contain',
      RATIO_THRESHOLD: 0.4,
      VIDEO_ELEMENT_SIZE: {
        FULL_SCREEN: 'full_screen',
        HALF_SCREEN: 'half_screen',
        HIDDEN: 'hidden',
        QUARTER_SCREEN: 'quarter_screen',
      },
    };
  }

  constructor({minimized, videoGridRepository}, rootElement) {
    this.scaleVideos = this.scaleVideos.bind(this, rootElement);
    this.doubleClickedOnVideo = this.doubleClickedOnVideo.bind(this);

    this.grid = videoGridRepository.grid;
    this.thumbnailStream = videoGridRepository.thumbnailStream;
    this.streams = videoGridRepository.streams;

    this.getStreamInfo = id => this.streams().find(stream => stream.id === id);
    this.gridInfo = ko.pureComputed(() => this.grid().map(this.getStreamInfo));

    this.minimized = minimized;

    this.hasBlackBackground = ko.pureComputed(() => {
      const gridElementsCount = this.grid().filter(id => id !== 0).length;
      return this.minimized && gridElementsCount > 1;
    });

    // scale videos when the grid is updated (on the next rendering cycle)
    this.grid.subscribe(() => z.util.afterRender(this.scaleVideos));
  }

  scaleVideos(rootElement) {
    const elements = Array.from(rootElement.querySelectorAll('.group-video-grid__element'));
    const setScale = (videoElement, wrapper) => {
      const streamId = wrapper.dataset.streamId;
      const streamInfo = this.getStreamInfo(streamId);
      if (streamInfo) {
        const isScreenSend = streamInfo.screenSend();
        updateContainClass(videoElement, wrapper, isScreenSend, streamInfo);
        streamInfo.screenSend.subscribe(screenSend => {
          delete streamInfo.fitContain;
          updateContainClass(videoElement, wrapper, screenSend, streamInfo);
        });
      }
    };

    const updateContainClass = (videoElement, wrapper, isScreenSend, streamInfo) => {
      const hasFitSet = streamInfo.hasOwnProperty('fitContain');
      const wrapperRatio = wrapper.clientWidth / wrapper.clientHeight;
      const videoRatio = videoElement.videoWidth / videoElement.videoHeight;
      const isVeryDifferent = Math.abs(wrapperRatio - videoRatio) > GroupVideoGrid.CONFIG.RATIO_THRESHOLD;
      const shouldBeContain = isVeryDifferent || isScreenSend === z.calling.enum.PROPERTY_STATE.TRUE;
      const forceClass = hasFitSet ? streamInfo.fitContain : shouldBeContain;
      videoElement.classList.toggle(GroupVideoGrid.CONFIG.CONTAIN_CLASS, forceClass);
    };

    elements.forEach(element => {
      const videoElement = element.querySelector('video');
      if (videoElement.videoWidth > 0) {
        z.util.afterRender(() => setScale(videoElement, element));
      } else {
        videoElement.addEventListener('loadedmetadata', () => setScale(videoElement, element), {once: true});
      }
    });
  }

  doubleClickedOnVideo(viewModel, {currentTarget}) {
    const childVideo = currentTarget.querySelector('video');
    const streamId = currentTarget.dataset.streamId;
    const streamInfo = this.getStreamInfo(streamId);

    const hasFitProperty = streamInfo.hasOwnProperty('fitContain');
    const hasFitClass = childVideo.classList.contains(GroupVideoGrid.CONFIG.CONTAIN_CLASS);
    streamInfo.fitContain = hasFitProperty ? !streamInfo.fitContain : !hasFitClass;

    childVideo.classList.toggle(GroupVideoGrid.CONFIG.CONTAIN_CLASS, streamInfo.fitContain);
  }

  getSizeForVideo(index) {
    const grid = this.grid();
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    if (grid[index] === 0) {
      return SIZES.EMPTY;
    }

    const isAlone = grid.every((value, i) => i === index || value === 0);
    const hasVerticalNeighbor = index % 2 === 0 ? grid[index + 1] !== 0 : grid[index - 1] !== 0;

    if (isAlone) {
      return SIZES.FULL_SCREEN;
    } else if (!hasVerticalNeighbor) {
      return SIZES.HALF_SCREEN;
    }
    return SIZES.QUARTER_SCREEN;
  }

  getClassNameForVideo(index, isMirrored) {
    const size = this.getSizeForVideo(index);
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    const extraClasses = {
      [SIZES.EMPTY]: 'group-video-grid__element--empty',
      [SIZES.FULL_SCREEN]: 'group-video-grid__element--full-size',
      [SIZES.HALF_SCREEN]: 'group-video-grid__element--full-height',
      [SIZES.QUARTER_SCREEN]: '',
    };

    const roundedClass = this.streams().length === 1 && this.minimized ? ' group-video-grid__element--rounded' : '';
    const mirrorClass = isMirrored ? ' mirror' : '';
    return `group-video-grid__element${index} ${extraClasses[size]}${mirrorClass}${roundedClass}`;
  }

  getUIEValueForVideo(index) {
    const size = this.getSizeForVideo(index);
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    const extraClasses = {
      [SIZES.EMPTY]: '',
      [SIZES.FULL_SCREEN]: 'full',
      [SIZES.HALF_SCREEN]: 'half',
      [SIZES.QUARTER_SCREEN]: 'quarter',
    };
    return extraClasses[size];
  }
};

ko.components.register('group-video-grid', {
  template: `
      <div class="group-video">
        <div class="group-video-grid" data-bind="foreach: {data: gridInfo, as: 'streamInfo', afterRender: scaleVideos}, css: {'group-video-grid--black-background': hasBlackBackground()}">
          <!-- ko if: streamInfo -->
            <div class="group-video-grid__element" data-bind="css: $parent.getClassNameForVideo($index(), streamInfo.isSelf && streamInfo.videoSend()), attr: {'data-uie-name': 'item-grid', 'data-uie-value': $parent.getUIEValueForVideo($index()), 'data-stream-id': streamInfo.id}, event: {dblclick: $parent.doubleClickedOnVideo}">
              <video class="group-video-grid__element-video" autoplay playsinline data-bind="sourceStream: streamInfo.stream, muteMediaElement: streamInfo.stream">
              </video>
              <!-- ko if: streamInfo.isSelf && !streamInfo.audioSend() && !$parent.minimized -->
                <div class="group-video-grid__mute-overlay" data-uie-name="status-call-audio-muted">
                  <micoff-icon></micoff-icon>
                </div>
              <!-- /ko -->
              <!-- ko if: streamInfo.videoSend() === z.calling.enum.PROPERTY_STATE.PAUSED -->
                <div class="group-video-grid__pause-overlay" data-bind="switchBackground: streamInfo.picture()">
                  <div class="background">
                    <div class="background-image"></div>
                    <div class="background-darken"></div>
                  </div>
                  <div class="group-video-grid__pause-overlay__label" data-bind="l10n_text: z.string.videoCallPaused, css: {'group-video-grid__pause-overlay__label--minimized': $parent.minimized}" data-uie-name="status-video-paused"></div>
                </div>
              <!-- /ko -->
            </div>
          <!-- /ko -->
        </div>
        <!-- ko if: thumbnailStream() && thumbnailStream().stream -->
          <div class="group-video__thumbnail" data-bind="css: {'group-video__thumbnail--minimized': minimized}">
            <video class="mirror group-video__thumbnail-video" autoplay playsinline data-uie-name="self-video-thumbnail" data-bind="css: {'group-video__thumbnail--minimized': minimized, 'mirror': thumbnailStream().videoSend()}, sourceStream: thumbnailStream().stream, muteMediaElement: thumbnailStream().stream">
            </video>
            <!-- ko if: !thumbnailStream().audioSend() && !minimized -->
              <div class="group-video-grid__mute-overlay" data-uie-name="status-call-audio-muted">
                <micoff-icon></micoff-icon>
              </div>
            <!-- /ko -->
          </div>
        <!-- /ko -->
      </div>
    `,
  viewModel: {
    createViewModel: (params, componentInfo) => new z.components.GroupVideoGrid(params, componentInfo.element),
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.Image = class Image {
  constructor(params, componentInfo) {
    this.asset = ko.unwrap(params.asset);
    this.assetSrc = ko.observable();
    this.assetIsLoading = ko.observable(false);
    this.element = componentInfo.element;

    this.onClick = () => {
      if (!this.assetIsLoading() && typeof params.click === 'function') {
        params.click(this.asset);
      }
    };

    const _onInViewport = () => {
      this.assetIsLoading(true);
      this.asset.load().then(blob => {
        if (blob) {
          this.assetSrc(window.URL.createObjectURL(blob));
        }
        this.assetIsLoading(false);
      });
    };

    z.ui.ViewportObserver.addElement(this.element, _onInViewport);
  }

  dispose() {
    z.ui.ViewportObserver.removeElement(this.element);
    if (this.assetSrc()) {
      window.URL.revokeObjectURL(this.assetSrc());
    }
  }
};

ko.components.register('image-component', {
  template: `
    <!-- ko if: assetSrc() -->
      <img data-bind="attr:{src: assetSrc}, click: onClick"/>
    <!-- /ko -->
    <!-- ko ifnot: assetSrc() -->
      <div data-bind="css: {'three-dots': assetIsLoading()}">
        <span></span><span></span><span></span>
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.Image(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.InputElement = class InputElement {
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.value = params.value;

    this.change = (data, event) => {
      const new_name = z.util.StringUtil.removeLineBreaks(event.target.value.trim());
      const old_name = this.value().trim();
      event.target.value = old_name;
      this.editing(false);

      if (new_name !== old_name && typeof params.change === 'function') {
        params.change(new_name);
      }
    };

    this.edit = () => this.editing(true);

    this.editing = ko.observable(false);
    this.editing_subscription = this.editing.subscribe(value => {
      if (value) {
        $(component_info.element)
          .find('textarea')
          .one('keydown', event => {
            if (event.keyCode === z.util.KEYCODE.ESC) {
              this.editing(false);
            }
          });
      } else {
        $(component_info.element)
          .find('textarea')
          .off('keydown', 'esc', this.abort);
      }
    });

    this.placeholder = params.placeholder;
  }

  dispose() {
    this.editing_subscription.dispose();
  }
};

// Knockout registration of the input element component.
ko.components.register('input-element', {
  template: `
    <span data-bind="visible: !editing(), text: value(), click: edit" data-uie-name="status-name"></span>
    <textarea data-bind="visible: editing, value: value(), enter: change, event: {blur: change}, hasFocus: editing, resize, l10n_placeholder: placeholder" maxlength="64" data-uie-name="enter-name"></textarea>
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.InputElement(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.InputLevel = class InputLevel {
  constructor(params) {
    this.input_level = params.level;
    this.disabled = params.disabled;

    this.level_in_view = ko.pureComputed(() => this.input_level()).extend({rateLimit: 100});

    this.bullet_count = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
  }

  is_bullet_active(index) {
    if (this.disabled()) {
      return 'input-level-bullet-disabled';
    }
    const threshold_passed = this.level_in_view() > (index + 1) / this.bullet_count.length;
    if (threshold_passed) {
      return 'input-level-bullet-active';
    }
  }
};

ko.components.register('input-level', {
  template: `\
    <ul class="input-level" data-bind="foreach: bullet_count">
     <li class="input-level-bullet" data-bind="css: $parent.is_bullet_active($data)"></li>
    </ul>\
  `,
  viewModel: z.components.InputLevel,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

(() => {
  class Message {
    constructor({
      message,
      conversation,
      selfId,
      isSelfTemporaryGuest,
      isLastDeliveredMessage,
      shouldShowAvatar,
      shouldShowInvitePeople,
      onClickAvatar,
      onClickImage,
      onClickInvitePeople,
      onClickMessage,
      onClickTimestamp,
      onClickParticipants,
      onClickResetSession,
      onClickCancelRequest,
      onLike,
      conversationRepository,
      locationRepository,
      actionsViewModel,
    }) {
      this.message = message;
      this.conversation = conversation;

      this.shouldShowAvatar = shouldShowAvatar;
      this.shouldShowInvitePeople = shouldShowInvitePeople;
      this.selfId = selfId;
      this.isSelfTemporaryGuest = isSelfTemporaryGuest;
      this.isLastDeliveredMessage = isLastDeliveredMessage;

      this.onClickImage = onClickImage;
      this.onClickInvitePeople = onClickInvitePeople;
      this.onClickAvatar = onClickAvatar;
      this.onClickMessage = onClickMessage;
      this.onClickTimestamp = onClickTimestamp;
      this.onClickParticipants = onClickParticipants;
      this.onClickResetSession = onClickResetSession;
      this.onClickCancelRequest = onClickCancelRequest;
      this.onLike = onLike;

      this.conversationRepository = conversationRepository;
      this.locationRepository = locationRepository;

      this.actionsViewModel = actionsViewModel;

      this.showLikes = ko.observable(false);

      this.bindShowMore = this.bindShowMore.bind(this);
    }

    getSystemMessageIconComponent(message) {
      const iconComponents = {
        [z.message.SystemMessageType.CONVERSATION_RENAME]: 'edit-icon',
        [z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE]: 'timer-icon',
      };
      return iconComponents[message.system_message_type];
    }

    showDevice(messageEntity) {
      const topic = messageEntity.isSelfClient()
        ? z.event.WebApp.PREFERENCES.MANAGE_DEVICES
        : z.event.WebApp.SHORTCUT.PEOPLE;
      amplify.publish(topic);
    }

    showContextMenu(messageEntity, event) {
      const entries = [];

      if (messageEntity.is_downloadable()) {
        entries.push({
          click: () => messageEntity.download(),
          label: z.l10n.text(z.string.conversationContextMenuDownload),
        });
      }

      if (messageEntity.isReactable() && !this.conversation().removed_from_conversation()) {
        const stringId = messageEntity.is_liked()
          ? z.string.conversationContextMenuUnlike
          : z.string.conversationContextMenuLike;

        entries.push({
          click: () => this.onLike(messageEntity, false),
          label: z.l10n.text(stringId),
        });
      }

      if (messageEntity.is_editable() && !this.conversation().removed_from_conversation()) {
        entries.push({
          click: () => amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.EDIT, messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuEdit),
        });
      }

      if (messageEntity.isReplyable() && !this.conversation().removed_from_conversation()) {
        entries.push({
          click: () => amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuReply),
        });
      }

      if (messageEntity.isCopyable()) {
        entries.push({
          click: () => messageEntity.copy(),
          label: z.l10n.text(z.string.conversationContextMenuCopy),
        });
      }

      if (messageEntity.is_deletable()) {
        entries.push({
          click: () => this.actionsViewModel.deleteMessage(this.conversation(), messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuDelete),
        });
      }

      const isSendingMessage = messageEntity.status() === z.message.StatusType.SENDING;
      const canDelete =
        messageEntity.user().is_me && !this.conversation().removed_from_conversation() && !isSendingMessage;
      if (canDelete) {
        entries.push({
          click: () => this.actionsViewModel.deleteMessageEveryone(this.conversation(), messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuDeleteEveryone),
        });
      }

      z.ui.Context.from(event, entries, 'message-options-menu');
    }

    bindShowMore(elements, scope) {
      const label = elements.find(element => element.className === 'message-header-label');
      if (!label) {
        return;
      }
      const link = label.querySelector('.message-header-show-more');
      if (link) {
        link.addEventListener('click', () => this.onClickParticipants(scope.message.highlightedUsers()));
      }
    }
  }

  const normalTemplate = `
  <!-- ko if: shouldShowAvatar -->
    <div class="message-header">
      <div class="message-header-icon">
        <participant-avatar class="sender-avatar" params="participant: message.user, click: onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
      </div>
      <div class="message-header-label">
        <span class="message-header-label-sender" data-bind='css: message.accent_color(), text: message.headerSenderName()' data-uie-name="sender-name"></span>
        <!-- ko if: message.user().isService -->
          <service-icon class="message-header-icon-service"></service-icon>
        <!-- /ko -->
        <!-- ko if: message.was_edited() -->
          <span class="message-header-label-icon icon-edit" data-bind="attr: {title: message.display_edited_timestamp()}"></span>
        <!-- /ko -->
      </div>
    </div>
  <!-- /ko -->
  <!-- ko if: message.quote() -->
    <message-quote params="
        conversation: conversation,
        quote: message.quote(),
        selfId: selfId,
        conversationRepository: conversationRepository,
        locationRepository: locationRepository,
        showDetail: onClickImage,
        focusMessage: onClickTimestamp,
        handleClickOnMessage: onClickMessage,
        showUserDetails: onClickAvatar,
      "></message-quote>
  <!-- /ko -->

  <div class="message-body" data-bind="attr: {'title': message.ephemeral_caption()}">
    <!-- ko if: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
      <ephemeral-timer class="message-ephemeral-timer" params="message: message"></ephemeral-timer>
    <!-- /ko -->

    <!-- ko foreach: {data: message.assets, as: 'asset'} -->
      <!-- ko if: asset.is_image() -->
        <div class="message-asset-image">
          <div class="image image-loading" data-bind="
            attr: {'data-uie-visible': message.visible() && !message.isObfuscated()},
            background_image: asset.resource,
            click: (data, event) => $parent.onClickImage(message, event),
            css: {'bg-color-ephemeral': message.isObfuscated()},
            " data-uie-name="go-image-detail">
            <!-- ko if: message.isObfuscated() -->
              <div class="icon-library flex-center full-screen text-white"></div>
            <!-- /ko -->
            <img class="image-element" data-bind="attr: {src: asset.dummy_url}, css: {'image-ephemeral': message.isObfuscated()}"/>
            <!-- ko ifnot: message.isObfuscated() -->
              <span class="image-placeholder-icon">
                <div class="three-dots">
                  <span></span>
                  <span></span>
                  <span></span>
                </div>
              </span>
            <!-- /ko -->
          </div>
        </div>
      <!-- /ko -->
      <!-- ko if: asset.is_text() -->
        <!-- ko if: asset.should_render_text -->
          <div class="text" data-bind="html: asset.render($parent.selfId()), event: {click: $parent.onClickMessage}, css: {'text-large': z.util.EmojiUtil.includesOnlyEmojies(asset.text), 'text-graphite': message.status() === z.message.StatusType.SENDING, 'ephemeral-message-obfuscated': message.isObfuscated()}" dir="auto"></div>
        <!-- /ko -->
        <!-- ko foreach: asset.previews() -->
          <link-preview-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired': message.isObfuscated()}" params="message: message"></link-preview-asset>
        <!-- /ko -->
      <!-- /ko -->
      <!-- ko if: asset.is_video() -->
        <video-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-movie': message.isObfuscated()}" params="message: message"></video-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_audio() -->
        <audio-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-microphone': message.isObfuscated()}" params="message: message"></audio-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_file() -->
        <file-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-file': message.isObfuscated()}" params="message: message"></file-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_location() -->
        <location-asset params="asset: asset, locationRepository: $parent.locationRepository"></location-asset>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: !message.other_likes().length && message.isReactable() -->
      <div class="message-body-like">
        <span class="message-body-like-icon like-button message-show-on-hover" data-bind="attr: {'data-ui-value': message.is_liked()}, css: {'like-button-liked': message.is_liked()}, style: {opacity: message.is_liked() ? 1 : ''}, click: () => onLike(message)">
          <span class="icon-like-small"></span>
          <span class="icon-liked-small"></span>
        </span>
      </div>
    <!-- /ko -->

    <div class="message-body-actions">
      <span class="context-menu icon-more font-size-xs" data-bind="click: (data, event) => showContextMenu(message, event)"></span>
      <!-- ko if: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
        <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp, 'data-uie-uid': message.id, 'title': message.ephemeral_caption()}"></time>
      <!-- /ko -->
      <!-- ko ifnot: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
        <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp, 'data-uie-uid': message.id}"></time>
      <!-- /ko -->
      <!-- ko if: isLastDeliveredMessage -->
        <span class="message-status" data-bind="l10n_text: z.string.conversationMessageDelivered"></span>
      <!-- /ko -->
    </div>

  </div>
  <!-- ko if: message.other_likes().length -->
    <div class="message-footer">
      <div class="message-footer-icon">
        <span class="like-button" data-bind="attr: {'data-ui-value': message.is_liked()}, css: {'like-button-liked': message.is_liked()}, style: {opacity: message.is_liked() ? 1 : ''}, click: () => onLike(message)">
          <span class="icon-like-small"></span>
          <span class="icon-liked-small"></span>
        </span>
      </div>
      <div class="message-footer-label cursor-pointer" data-bind="click: () => showLikes(true)">
        <span class="font-size-xs text-graphite" data-bind="text: message.like_caption(), attr: {'data-uie-value': message.reactions_user_ids()}"  data-uie-name="message-liked-names"></span>
        <!-- ko if: !showLikes() && message.other_likes().length > 5 -->
          <span class="icon-more font-size-xs"></span>
        <!-- /ko -->
      </div>
      <!-- ko if: showLikes() -->
        <div class="message-footer-bottom" data-uie-name="message-liked-avatars">
          <!-- ko foreach: message.reactions_user_ets() -->
            <participant-avatar params="participant: $data, click: $parent.onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
          <!-- /ko -->
          <span class="message-footer-close-button icon-close" data-bind="click: () => showLikes(false)"></span>
        </div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  `;

  const missedTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <span class="icon-sysmsg-error text-red"></span>
    </div>
    <div class="message-header-label" data-bind="l10n_text: z.string.conversationMissedMessages"></div>
  </div>
  `;

  const unableToDecryptTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <span class="icon-sysmsg-error text-red"></span>
    </div>
    <div class="message-header-label ellipsis">
      <span data-bind="html: message.htmlCaption()"></span>
      <span>&nbsp;</span>
      <a class="text-theme" data-bind="l10n_text: z.string.conversationUnableToDecryptLink, attr: {'href': message.link}" rel="nofollow noopener noreferrer" target="_blank"></a>
      <hr class="message-header-line" />
    </div>
  </div>
  <div class="message-body message-body-decrypt-error">
    <div class="message-header-decrypt-error-label" data-bind="html: message.htmlErrorMessage()"></div>
    <!-- ko if: message.is_recoverable -->
      <div class="message-header-decrypt-reset-session">
        <svg class="message-header-decrypt-reset-session-spinner svg-theme spin"
             data-bind="style : {visibility : message.is_resetting_session() ? 'visible' : 'hidden'}"
             width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" data-uie-name="status-loading">
          <path class="fill-theme" d="M12.416 12.417c-2.374 2.375-6.28 2.33-8.72-.112-2.444-2.442-2.488-6.347-.113-8.72 1.658-1.66 4.12-2.18 6.343-1.394.477.17 1-.08 1.17-.557.167-.477-.083-1-.56-1.17C7.658-.552 4.453.124 2.286 2.29-.808 5.384-.75 10.448 2.4 13.6c3.15 3.152 8.216 3.21 11.312.113 2.165-2.166 2.84-5.37 1.824-8.25-.168-.476-.692-.726-1.17-.558-.476.17-.726.692-.557 1.17.784 2.222.265 4.684-1.394 6.342z"></path>
        </svg>
        <span class="message-header-decrypt-reset-session-action button-label text-theme"
              data-bind="click: () => onClickResetSession(message), l10n_text: z.string.conversationUnableToDecryptResetSession, style : {visibility : !message.is_resetting_session() ? 'visible' : 'hidden'}"></span>
      </div>
      <!-- /ko -->
    </div>
  </div>
  `;

  const systemTemplate = `
  <div class="message-header">
    <div class="message-header-icon message-header-icon--svg text-graphite">
      <span data-bind="component: getSystemMessageIconComponent(message)"></span>
    </div>
    <div class="message-header-label">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption()"></span>
      <hr class="message-header-line" />
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  <div class="message-body font-weight-bold" data-bind="text: message.name"></div>
  `;

  const pingTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <div class="icon-ping" data-bind="css: message.get_icon_classes"></div>
    </div>
    <div class="message-header-label" data-bind="attr: {title: message.ephemeral_caption()}, css: {'ephemeral-message-obfuscated': message.isObfuscated()}">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption"></span>
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  `;

  const deleteTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <participant-avatar class="sender-avatar" params="participant: message.user, click: onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
    </div>
    <div class="message-header-label">
      <span class="message-header-label-sender" data-bind='text: message.unsafeSenderName()'></span>
      <span class="message-header-label-icon icon-trash" data-bind="attr: {title: message.display_deleted_timestamp()}"></span>
    </div>
    <div class="message-body-actions message-body-actions-large">
      <time class="time" data-bind="text: message.display_deleted_timestamp(), attr: {'data-timestamp': message.deleted_timestamp, 'data-uie-uid': message.id}" data-uie-name="item-message-delete-timestamp"></time>
    </div>
  </div>
  `;

  const verificationTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <!-- ko if: message.isTypeVerified() -->
        <verified-icon></verified-icon>
      <!-- /ko -->
      <!-- ko ifnot: message.isTypeVerified() -->
        <svg width="16" height="16">
          <use xlink:href="#icon-not-verified"></use>
        </svg>
      <!-- /ko -->
    </div>
    <div class="message-header-label">
      <!-- ko if: message.isTypeVerified() -->
        <span data-bind="l10n_text: z.string.tooltipConversationAllVerified"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeUnverified() -->
        <span class="message-header-sender-name" data-bind="text: message.unsafeSenderName()"></span>
        <span class="ellipsis" data-bind="l10n_text: z.string.conversationDeviceUnverified"></span>
        <span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), text: message.captionUnverifiedDevice" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeNewDevice() -->
        <span class="message-header-plain-sender-name" data-bind='text: message.captionUser'></span>
        <span class="ellipsis" data-bind="text: message.captionStartedUsing"></span>
        <span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), text: message.captionNewDevice" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeNewMember() -->
        <span class="ellipsis" data-bind="l10n_text: z.string.conversationDeviceNewPeopleJoined"></span>&nbsp;<span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), l10n_text: z.string.conversationDeviceNewPeopleJoinedVerify" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <hr class="message-header-line" />
    </div>
  </div>
  `;

  const callTemplate = `
  <div class="message-header">
    <div class="message-header-icon message-header-icon--svg">
      <!-- ko if: message.was_completed() -->
        <div class="svg-green"><pickup-icon></pickup-icon></div>
      <!-- /ko -->
      <!-- ko if: message.was_missed() -->
        <div class="svg-red"><hangup-icon></hangup-icon></div>
      <!-- /ko -->
    </div>
    <div class="message-header-label">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption()"></span>
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  `;

  const memberTemplate = `
  <!-- ko if: message.showLargeAvatar() -->
    <div class="message-connected">
      <span class="message-connected-header" data-bind='text: message.otherUser().name()'></span>
      <!-- ko if: message.otherUser().isService -->
        <span class="message-connected-provider-name" data-bind='text: message.otherUser().providerName()'></span>
      <!-- /ko -->
      <!-- ko ifnot: message.otherUser().isService -->
        <span class="message-connected-username label-username" data-bind='text: message.otherUser().username()'></span>
      <!-- /ko -->
      <participant-avatar class="message-connected-avatar avatar-no-badge cursor-default"
                   data-bind="css: {'avatar-no-badge': message.otherUser().isOutgoingRequest()}"
                   params="participant: message.otherUser, size: z.components.ParticipantAvatar.SIZE.X_LARGE"></participant-avatar>
      <!-- ko if: message.otherUser().isOutgoingRequest() -->
        <div class="message-connected-cancel text-theme"
             data-bind="click: () => onClickCancelRequest(message),
                        l10n_text: z.string.conversationConnectionCancelRequest"
             data-uie-name="do-cancel-request"></div>
      <!-- /ko -->
      <!-- ko if: message.showServicesWarning -->
        <div class="message-services-warning" data-bind="l10n_text: z.string.conversationServicesWarning" data-uie-name="label-services-warning"></div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  <!-- ko ifnot: message.showLargeAvatar() -->
    <!-- ko if: message.showNamedCreation() -->
      <div class="message-group-creation-header">
        <div class="message-group-creation-header-text" data-bind="html: message.htmlGroupCreationHeader()"></div>
        <div class="message-group-creation-header-name" data-bind="text: message.name()"></div>
      </div>
    <!-- /ko -->

    <!-- ko if: message.hasUsers() -->
      <div class="message-header" data-bind="template: {afterRender: bindShowMore}">
        <div class="message-header-icon message-header-icon--svg text-graphite">
          <message-icon data-bind="visible: message.isGroupCreation()"></message-icon>
          <span class="icon-minus" data-bind="visible: message.isMemberRemoval()"></span>
          <span class="icon-plus" data-bind="visible: message.isMemberJoin()"></span>
        </div>
        <div class="message-header-label">
          <span class="message-header-caption" data-bind="html: message.htmlCaption()"></span>
          <hr class="message-header-line" />
        </div>
        <!-- ko if: message.isMemberChange() -->
          <div class="message-body-actions">
            <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
          </div>
        <!-- /ko -->
      </div>
      <!-- ko if: message.showServicesWarning -->
        <div class="message-services-warning" data-bind="l10n_text: z.string.conversationServicesWarning" data-uie-name="label-services-warning"></div>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: message.isGroupCreation() -->
      <!-- ko if: shouldShowInvitePeople -->
        <div class="message-member-footer">
          <div data-bind="l10n_text: z.string.guestRoomConversationHead"></div>
          <div class="message-member-footer-button" data-bind="click: onClickInvitePeople, l10n_text: z.string.guestRoomConversationButton" data-uie-name="do-invite-people"></div>
        </div>
      <!-- /ko -->
      <!-- ko if: isSelfTemporaryGuest -->
        <div class="message-member-footer">
          <div class="message-member-footer-message" data-bind="l10n_text: z.string.temporaryGuestJoinMessage"></div>
          <div class="message-member-footer-description" data-bind="l10n_text: z.string.temporaryGuestJoinDescription"></div>
        </div>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: message.isMemberLeave() && message.user().is_me && isSelfTemporaryGuest -->
      <div class="message-member-footer">
        <div class="message-member-footer-description" data-bind="l10n_text: z.string.temporaryGuestLeaveDescription"></div>
      </div>
    <!-- /ko -->
  <!-- /ko -->  `;

  ko.components.register('message', {
    template: `
    <!-- ko if: message.super_type === 'normal' -->
      ${normalTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'missed' -->
      ${missedTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'unable-to-decrypt' -->
      ${unableToDecryptTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'verification' -->
      ${verificationTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'delete' -->
      ${deleteTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'call' -->
      ${callTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'system' -->
      ${systemTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'member' -->
      ${memberTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'ping' -->
      ${pingTemplate}
    <!-- /ko -->
    `,
    viewModel: Message,
  });
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MessageQuote = class MessageQuote {
  constructor({
    conversation,
    conversationRepository,
    focusMessage,
    handleClickOnMessage,
    locationRepository,
    quote,
    selfId,
    showDetail,
    showUserDetails,
  }) {
    this.updateCanShowMore = this.updateCanShowMore.bind(this);
    this.toggleShowMore = this.toggleShowMore.bind(this);

    this.showDetail = showDetail;
    this.handleClickOnMessage = handleClickOnMessage;
    this.showUserDetails = showUserDetails;

    this.focusMessage = () => {
      if (this.quotedMessage()) {
        focusMessage(this.quotedMessage().id);
      }
    };

    this.locationRepository = locationRepository;
    this.selfId = selfId;

    this.canShowMore = ko.observable(false);
    this.showFullText = ko.observable(false);

    this.quotedMessage = ko.observable();
    this.quotedMessageId = ko.observable();
    this.error = ko.observable(quote().error);

    this.quotedMessage.subscribe(() => this.showFullText(false));

    this.quotedMessageIsBeforeToday = ko.pureComputed(() => {
      if (!this.quotedMessage()) {
        return false;
      }
      const quoteDate = moment(this.quotedMessage().timestamp());
      const today = moment().startOf('day');
      return quoteDate.isBefore(today);
    });

    if (!this.error() && quote().messageId) {
      conversationRepository
        .get_message_in_conversation_by_id(conversation(), quote().messageId, true, true)
        .then(message => {
          this.quotedMessage(message);
          this.quotedMessageId(message.id);
        })
        .catch(() => this.error(z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND));
    }

    const handleQuoteDeleted = messageId => {
      if (this.quotedMessageId() === messageId) {
        this.error(z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND);
        this.quotedMessage(undefined);
      }
    };

    const handleQuoteUpdated = (originalMessageId, messageEntity) => {
      if (this.quotedMessageId() === originalMessageId) {
        this.quotedMessage(messageEntity);
        this.quotedMessageId(messageEntity.id);
      }
    };

    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleQuoteDeleted);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleQuoteUpdated);

    this.removedFromView = () => {
      amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleQuoteDeleted);
      amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleQuoteUpdated);
    };
  }

  updateCanShowMore(elements) {
    const textQuote = elements.find(element => element.classList && element.classList.contains('message-quote__text'));
    if (textQuote) {
      const preNode = textQuote.querySelector('pre');
      const width = Math.max(textQuote.scrollWidth, preNode ? preNode.scrollWidth : 0);
      const height = Math.max(textQuote.scrollHeight, preNode ? preNode.scrollHeight : 0);
      const isWider = width > textQuote.clientWidth;
      const isHigher = height > textQuote.clientHeight;
      this.canShowMore(isWider || isHigher);
    }
  }

  toggleShowMore() {
    this.showFullText(!this.showFullText());
  }
};

ko.components.register('message-quote', {
  template: `
  <!-- ko if: quotedMessage() || error() -->
    <div class="message-quote" data-uie-name="quote-item">
      <!-- ko if: error() -->
        <div class="message-quote__error" data-bind="l10n_text: z.string.replyQuoteError" data-uie-name="label-error-quote"></div>
      <!-- /ko -->
      <!-- ko ifnot: error() -->
        <div class="message-quote__sender">
          <span data-bind="text: quotedMessage().headerSenderName(), click: () => showUserDetails(quotedMessage().user)" data-uie-name="label-name-quote"></span>
          <!-- ko if: quotedMessage().was_edited() -->
            <edit-icon data-uie-name="message-edited-quote"></edit-icon>
          <!-- /ko -->
        </div>
        <!-- ko foreach: {data: quotedMessage().assets, as: 'asset', afterRender: updateCanShowMore} -->
          <!-- ko if: asset.is_image() -->
              <div class="message-quote__image" data-bind="background_image: asset.resource, click: (data, event) => $parent.showDetail($parent.quotedMessage(), event)" data-uie-name="media-picture-quote">
                <img data-bind="attr: {src: asset.dummy_url}"/>
              </div>
          <!-- /ko -->

          <!-- ko if: asset.is_text() -->
            <div class="message-quote__text" data-bind="html: asset.render($parent.selfId()), 
                                                        event: {click: $parent.handleClickOnMessage}, 
                                                        css: {'message-quote__text--full': $parent.showFullText(), 
                                                              'message-quote__text--large': z.util.EmojiUtil.includesOnlyEmojies(asset.text)}" 
              dir="auto" data-uie-name="media-text-quote"></div>
            <!-- ko if: $parent.canShowMore -->
              <div class="message-quote__text__show-more" data-bind="click: $parent.toggleShowMore" data-uie-name="do-show-more-quote">
                <span data-bind="l10n_text: $parent.showFullText() ? z.string.replyQuoteShowLess : z.string.replyQuoteShowMore"></span>
                <disclose-icon data-bind="css: {'upside-down': $parent.showFullText()}"></disclose-icon>
              </div>
            <!-- /ko -->
          <!-- /ko -->

          <!-- ko if: asset.is_video() -->
            <video-asset class="message-quote__video" params="message: $parent.quotedMessage, isQuote: true" data-uie-name="media-video-quote"></video-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_audio() -->
            <audio-asset class="message-quote__audio" params="message: $parent.quotedMessage" data-uie-name="media-audio-quote"></audio-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_file() -->
            <file-asset class="message-quote__file" params="message: $parent.quotedMessage" data-uie-name="media-file-quote"></file-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_location() -->
            <location-asset params="asset: asset, locationRepository: $parent.locationRepository" data-uie-name="media-location-quote"></location-asset>
          <!-- /ko -->
        <!-- /ko -->
        <div class="message-quote__timestamp" 
          data-bind="l10n_text: {
              id: quotedMessageIsBeforeToday() ? z.string.replyQuoteTimeStampDate : z.string.replyQuoteTimeStampTime, 
              substitute: moment(quotedMessage().timestamp()).format(quotedMessageIsBeforeToday() ? 'DD.MM.YYYY' : 'HH:mm')
            },
            click: focusMessage" 
          data-uie-name="label-timestamp-quote">
        </div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  `,
  viewModel: z.components.MessageQuote,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MessageTimerButton = class MessageTimerButton {
  constructor(params) {
    this.conversationEntity = params.conversation;
    this.hasMessageTimer = ko.pureComputed(() => {
      return this.conversationEntity() ? this.conversationEntity().messageTimer() : false;
    });
    this.isTimerDisabled = ko.pureComputed(() => this.conversationEntity().hasGlobalMessageTimer());
    this.duration = ko.pureComputed(() => {
      return this.hasMessageTimer() ? z.util.TimeUtil.formatDuration(this.conversationEntity().messageTimer()) : {};
    });
  }

  /**
   * Click on ephemeral button
   * @param {Object} data - Object
   * @param {DOMEvent} event - Triggered event
   * @returns {undefined} No return value
   */
  onClick(data, event) {
    if (this.isTimerDisabled()) {
      return event.preventDefault();
    }

    const entries = [
      {
        click: () => this.conversationEntity().localMessageTimer(0),
        label: z.l10n.text(z.string.ephemeralUnitsNone),
      },
    ].concat(
      z.ephemeral.timings.VALUES.map(milliseconds => {
        const {text} = z.util.TimeUtil.formatDuration(milliseconds);

        return {
          click: () => this.conversationEntity().localMessageTimer(milliseconds),
          label: text,
        };
      })
    );

    z.ui.Context.from(event, entries, 'message-timer-menu');
  }
};

ko.components.register('message-timer-button', {
  template: `
    <span id="conversation-input-bar-message-timer"
      class="controls-right-button conversation-input-bar-message-timer"
      data-bind="click: onClick, l10n_tooltip: z.string.tooltipConversationEphemeral, attr: {'data-uie-value': isTimerDisabled() ? 'disabled' : 'enabled'}"
      data-uie-name="do-set-ephemeral-timer"
      data-uie-value>
      <!-- ko if: hasMessageTimer() && conversationEntity()-->
        <div class="message-timer-button" data-bind="css: isTimerDisabled() ? 'message-timer-button--disabled' : 'message-timer-button--enabled'">
          <span class="message-timer-button-unit" data-bind="text: duration().symbol"></span>
          <span class="full-screen" data-bind="text: duration().value"></span>
        </div>
      <!-- /ko -->

      <!-- ko ifnot: hasMessageTimer() -->
        <timer-icon class="button-icon-large"></timer-icon>
      <!-- /ko -->
    </span>
    `,
  viewModel: z.components.MessageTimerButton,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MentionSuggestions = class MentionSuggestions {
  constructor(params) {
    this.onInput = this.onInput.bind(this);
    this.onSuggestionClick = this.onSuggestionClick.bind(this);
    this.onInitSimpleBar = this.onInitSimpleBar.bind(this);

    this.isVisible = ko.observable(false);
    this.onSelectionValidated = params.onSelectionValidated || z.util.noop;
    this.onEnd = params.onEnd || z.util.noop;
    this.suggestions = params.suggestions;
    this.targetInputSelector = params.targetInputSelector;
    this.targetInput = undefined;

    this.position = ko.observable({});

    this.selectedSuggestionIndex = ko.observable(0);
    this.selectedSuggestionIndex.subscribe(this.updateScrollPosition);
    this.selectedSuggestion = ko.pureComputed(() => this.suggestions()[this.selectedSuggestionIndex()]);

    this.suggestionSubscription = this.suggestions.subscribe(suggestions => {
      const shouldBeVisible = suggestions.length > 0;
      if (shouldBeVisible && !this.isVisible()) {
        this.initList();
        this.updatePosition();
      } else if (!shouldBeVisible && this.isVisible()) {
        this.teardownList();
      } else if (this.isVisible()) {
        this.updateSelectedIndexBoundaries(suggestions);
        this.updatePosition();
      }
      this.isVisible(shouldBeVisible);
      this.updateScrollPosition(this.selectedSuggestionIndex());
    });

    this.shouldUpdateScrollbar = ko.pureComputed(this.suggestions).extend({notify: 'always', rateLimit: 100});
  }

  setWrapperSize(size = '') {
    const wrapper = document.querySelector('.conversation-input-bar-mention-suggestion');
    if (wrapper) {
      wrapper.style.width = size;
    }
  }

  onInitSimpleBar(simpleBar) {
    this.scrollElement = simpleBar.getScrollElement();
  }

  onInput(keyboardEvent) {
    const actions = {
      [z.util.KeyboardUtil.KEY.ARROW_UP]: this.moveSelection.bind(this, 1),
      [z.util.KeyboardUtil.KEY.ARROW_DOWN]: this.moveSelection.bind(this, -1),
      [z.util.KeyboardUtil.KEY.ENTER]: this.validateSelection.bind(this, keyboardEvent),
      [z.util.KeyboardUtil.KEY.TAB]: this.validateSelection.bind(this, keyboardEvent),
    };

    const action = actions[keyboardEvent.key];
    if (action) {
      const wasHandled = action();
      if (wasHandled) {
        keyboardEvent.preventDefault();
        keyboardEvent.stopPropagation();
      }
    }
  }

  moveSelection(delta) {
    const currentIndex = this.selectedSuggestionIndex();
    const newIndex = z.util.NumberUtil.clamp(currentIndex + delta, 0, this.suggestions().length - 1);
    this.selectedSuggestionIndex(newIndex);
    return true;
  }

  onSuggestionClick(data, event) {
    event.preventDefault();
    $(this.targetInput).focus();
    this.onSelectionValidated(data, this.targetInput);
  }

  validateSelection(keyboardEvent) {
    const isShiftEnter = z.util.KeyboardUtil.isEnterKey(keyboardEvent) && keyboardEvent.shiftKey;
    if (isShiftEnter) {
      return false;
    }

    this.onSelectionValidated(this.selectedSuggestion(), this.targetInput);
    return true;
  }

  updateScrollPosition(selectedNumber) {
    if (!this.scrollElement) {
      return;
    }
    const listItems = this.scrollElement.querySelectorAll('.mention-suggestion-list__item');
    const selectedItem = listItems[listItems.length - 1 - selectedNumber];
    if (!selectedItem) {
      return;
    }
    const scrollRect = this.scrollElement.getBoundingClientRect();
    const itemRect = selectedItem.getBoundingClientRect();
    const topDiff = scrollRect.top - itemRect.top;
    if (topDiff > 0) {
      return (this.scrollElement.scrollTop -= topDiff + 4);
    }
    const bottomDiff = itemRect.bottom - scrollRect.bottom + 20;
    if (bottomDiff > 0) {
      return (this.scrollElement.scrollTop += bottomDiff + 4);
    }
  }

  initList() {
    this.targetInput = this.initTargetInput();
    this.selectedSuggestionIndex(0);
  }

  updatePosition() {
    const inputBoundingRect = this.targetInput.getBoundingClientRect();
    const bottom = window.innerHeight - inputBoundingRect.top + 24;

    this.position({bottom: `${bottom}px`});
  }

  updateSelectedIndexBoundaries(suggestions) {
    const currentIndex = this.selectedSuggestionIndex();
    this.selectedSuggestionIndex(z.util.NumberUtil.clamp(currentIndex, 0, suggestions.length - 1));
  }

  teardownList() {
    this.targetInput.removeEventListener('keydown', this.onInput, true);
  }

  initTargetInput() {
    const input = this.targetInput || document.querySelector(this.targetInputSelector);
    input.addEventListener('keydown', this.onInput, true);
    this.targetInput = input;
    return input;
  }

  dispose() {
    this.suggestionSubscription.dispose();
  }
};

ko.components.register('mention-suggestions', {
  template: `
  <!-- ko if: isVisible() -->
    <div class="conversation-input-bar-mention-suggestion" data-uie-name="list-mention-suggestions" data-bind="style: position(), simplebar: {trigger: shouldUpdateScrollbar, onInit: onInitSimpleBar}">
      <div class="mention-suggestion-list" data-bind="foreach: {data: suggestions().slice().reverse(), as: 'suggestion'}">
        <div class="mention-suggestion-list__item" data-bind="click: $parent.onSuggestionClick, css: {'mention-suggestion-list__item--highlighted': suggestion === $parent.selectedSuggestion()}, attr: {'data-uie-value': suggestion.id, 'data-uie-selected': suggestion === $parent.selectedSuggestion()}" data-uie-name="item-mention-suggestion">
          <participant-avatar params="participant: suggestion, size: z.components.ParticipantAvatar.SIZE.XXX_SMALL"></participant-avatar>
          <div class="mention-suggestion-list__item__name" data-bind="text: suggestion.name()" data-uie-name="status-name"></div>
          <!-- ko if: suggestion.isTemporaryGuest() -->
            <div class="mention-suggestion-list__item__remaining"  data-bind="text: suggestion.expirationRemainingText()" data-uie-name="status-remaining"></div>
          <!-- /ko -->
          <!-- ko ifnot: suggestion.isTemporaryGuest() -->
            <div class="mention-suggestion-list__item__username" data-bind="text: suggestion.username()" data-uie-name="status-username"></div>
          <!-- /ko -->
          <!-- ko if: suggestion.isGuest() -->
            <guest-icon class="mention-suggestion-list__item__guest-badge" data-uie-name="status-guest"></guest-icon>
          <!-- /ko -->
        </div>
      </div>
    </div>
  <!-- /ko -->`,

  viewModel: z.components.MentionSuggestions,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ServiceList = class ServiceList {
  static get MODE() {
    return {
      COMPACT: 'ServiceList.MODE.COMPACT',
      DEFAULT: 'ServiceList.MODE.DEFAULT',
    };
  }

  constructor(params) {
    this.isSearching = params.isSearching || z.util.noop;
    this.mode = params.mode || ServiceList.MODE.DEFAULT;
    this.onClick = params.click;
    this.services = params.services;
    this.altStyle = params.altStyle;

    this.isCompactMode = this.mode === ServiceList.MODE.COMPACT;
    this.isDefaultMode = this.mode === ServiceList.MODE.DEFAULT;

    this.avatarSize = this.isCompactMode
      ? z.components.ParticipantAvatar.SIZE.LARGE
      : z.components.ParticipantAvatar.SIZE.SMALL;

    this.cssClasses = ko.pureComputed(() => (this.isCompactMode ? 'search-list-sm' : 'search-list-lg'));
  }
};

ko.components.register('service-list', {
  template: `
    <div class="search-list" data-bind="css: cssClasses(), foreach: services">
      <participant-item params="participant: $data" data-bind="click: $parent.onClick, css: {'no-underline': $parent.altStyle, 'show-arrow': $parent.altStyle}"></participant-item>
    </div>
    <!-- ko if: isSearching() && !services().length -->
      <div class="no-results" data-bind="l10n_text: z.string.searchListNoMatches"></div>
    <!-- /ko -->
  `,
  viewModel: z.components.ServiceList,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.TopPeople = class TopPeople {
  constructor(params) {
    this.click = params.click;
    this.maxUsers = params.max || 9;
    this.userEntities = params.users;

    this.displayedUsers = ko.pureComputed(() => this.userEntities().slice(0, this.maxUsers));

    this.onUserClick = (userEntity, event) => {
      if (typeof this.click === 'function') {
        return this.click(userEntity, event);
      }
    };
  }
};

ko.components.register('top-people', {
  template: `
    <div class="search-list search-list-sm" data-bind="foreach: {data: displayedUsers}">
      <div class="search-list-item" data-bind="click: $parent.onUserClick, attr: {'data-uie-uid': $data.id, 'data-uie-value': $data.name(), 'data-uie-status': $data.connection().status()}" data-uie-name="item-user">
        <participant-avatar class="search-list-item-image" params="participant: $data, delay: 300, size: z.components.ParticipantAvatar.SIZE.LARGE"></participant-avatar>
        <div class="search-list-item-content">
          <div class="search-list-item-content-name" data-bind="text: first_name"></div>
        </div>
      </div>
    </div>
  `,
  viewModel: z.components.TopPeople,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ParticipantAvatar = class ParticipantAvatar {
  static get SIZE() {
    return {
      LARGE: 'avatar-l',
      MEDIUM: 'avatar-m',
      SMALL: 'avatar-s',
      X_LARGE: 'avatar-xl',
      X_SMALL: 'avatar-xs',
      XX_SMALL: 'avatar-xxs',
      XXX_SMALL: 'avatar-xxxs',
    };
  }

  static get DIAMETER() {
    return {
      [ParticipantAvatar.SIZE.LARGE]: 72,
      [ParticipantAvatar.SIZE.MEDIUM]: 40,
      [ParticipantAvatar.SIZE.SMALL]: 28,
      [ParticipantAvatar.SIZE.X_LARGE]: 200,
      [ParticipantAvatar.SIZE.X_SMALL]: 24,
      [ParticipantAvatar.SIZE.XX_SMALL]: 20,
      [ParticipantAvatar.SIZE.XXX_SMALL]: 16,
    };
  }

  constructor(params, componentInfo) {
    const isParticipantObservable = typeof params.participant === 'function';
    this.participant = isParticipantObservable ? params.participant : ko.observable(params.participant);

    this.isService = ko.pureComputed(() => {
      return this.participant() instanceof z.integration.ServiceEntity || this.participant().isService;
    });

    this.isUser = ko.pureComputed(() => {
      return this.participant() instanceof z.entity.User && !this.participant().isService;
    });

    this.isTemporaryGuest = ko.pureComputed(() => this.isUser() && this.participant().isTemporaryGuest());

    this.remainingTimer = undefined;

    this.avatarType = ko.pureComputed(() => `${this.isUser() ? 'user' : 'service'}-avatar`);
    this.delay = params.delay;
    this.size = params.size || ParticipantAvatar.SIZE.LARGE;
    this.element = $(componentInfo.element);
    this.element.addClass(`${this.avatarType()} ${this.size}`);

    const borderScale = 0.9916;
    const finalBorderWidth = this.size === ParticipantAvatar.SIZE.X_LARGE ? 4 : 1;
    this.borderWidth = (finalBorderWidth / ParticipantAvatar.DIAMETER[this.size]) * 32;
    this.borderRadius = (16 - this.borderWidth / 2) * borderScale;
    this.timerLength = this.borderRadius * Math.PI * 2;
    this.timerOffset = ko.observable();

    this.timerOffset = ko.pureComputed(() => {
      if (this.isTemporaryGuest()) {
        const remainingTime = this.participant().expirationRemaining();
        const normalizedRemainingTime = remainingTime / z.entity.User.CONFIG.TEMPORARY_GUEST.LIFETIME;
        return this.timerLength * (normalizedRemainingTime - 1);
      }
      return 0;
    });

    this.avatarLoadingBlocked = false;
    this.avatarEnteredViewport = false;

    this.dispose = this.dispose.bind(this);

    this.element.attr({
      id: z.util.createRandomUuid(),
      'user-id': this.participant().id,
    });

    this.initials = ko.pureComputed(() => {
      if (this.isService()) {
        return '';
      }

      return this.element.hasClass('avatar-xs')
        ? z.util.StringUtil.getFirstChar(this.participant().initials())
        : this.participant().initials();
    });

    this.state = ko.pureComputed(() => {
      switch (true) {
        case this.isService():
          return '';
        case this.participant().is_me:
          return 'self';
        case typeof params.selected === 'function' && params.selected():
          return 'selected';
        case this.participant().isTeamMember():
          return '';
        case this.participant().isBlocked():
          return 'blocked';
        case this.participant().isRequest():
          return 'pending';
        case this.participant().isIgnored():
          return 'ignored';
        case this.participant().isCanceled() || this.participant().isUnknown():
          return 'unknown';
        default:
          return '';
      }
    });

    this.cssClasses = ko.pureComputed(() => {
      if (this.isService()) {
        return 'accent-color-service';
      }

      return this.isTemporaryGuest()
        ? 'accent-color-temporary'
        : `accent-color-${this.participant().accent_id()} ${this.state()}`;
    });

    this.onClick = (data, event) => {
      if (typeof params.click === 'function') {
        params.click(data.participant, event.currentTarget.parentNode);
      }
    };

    const _loadAvatarPicture = () => {
      this.element.find('.avatar-image').html('');
      this.element.removeClass('avatar-image-loaded avatar-loading-transition');
      if (!this.avatarLoadingBlocked) {
        this.avatarLoadingBlocked = true;

        const isSmall = this.size !== ParticipantAvatar.SIZE.LARGE && this.size !== ParticipantAvatar.SIZE.X_LARGE;
        const loadHiRes = !isSmall && window.devicePixelRatio > 1;
        const pictureResource = loadHiRes
          ? this.participant().mediumPictureResource()
          : this.participant().previewPictureResource();

        if (pictureResource) {
          const isCached = pictureResource.downloadProgress() === 100;

          pictureResource.getObjectUrl().then(url => {
            if (url) {
              const image = new Image();
              image.src = url;
              this.element.find('.avatar-image').html(image);
              this.element.addClass(`avatar-image-loaded ${isCached && isSmall ? '' : 'avatar-loading-transition'}`);
            }
            this.avatarLoadingBlocked = false;
          });
        } else {
          this.avatarLoadingBlocked = false;
        }
      }
    };

    const _onInViewport = () => {
      this.avatarEnteredViewport = true;
      _loadAvatarPicture();
    };

    const _loadAvatarPictureIfVisible = () => {
      if (this.avatarEnteredViewport) {
        _loadAvatarPicture();
      }
    };

    z.ui.ViewportObserver.addElement(componentInfo.element, _onInViewport);

    this.pictureSubscription = this.participant().mediumPictureResource.subscribe(_loadAvatarPictureIfVisible);
    this.participantSubscription = this.participant.subscribe(_loadAvatarPictureIfVisible);
  }

  dispose() {
    z.ui.ViewportObserver.removeElement(this.element[0]);
    this.participantSubscription.dispose();
    this.pictureSubscription.dispose();
  }
};

ko.components.register('participant-avatar', {
  template: `
    <div class="participant-avatar" data-bind="attr: {title: participant().name, 'data-uie-name': avatarType()}, css: cssClasses(), click: onClick, delay: delay">
      <div class="avatar-background"></div>
      <!-- ko if: isUser -->
        <div class="avatar-initials" data-bind="text: initials()"></div>
      <!-- /ko -->
      <!-- ko if: isService -->
        <div class="avatar-service-placeholder">
            <svg width="32" height="32" viewBox="0 0 32 32">
              <path d="M10.5 12A6.5 6.5 0 0 0 4 18.5V24a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-5.5a6.5 6.5 0 0 0-6.5-6.5h-11zm-7.12-1.22L.24 4.95a2 2 0 1 1 3.52-1.9L6.8 8.68C7.94 8.24 9.19 8 10.5 8h11C27.3 8 32 12.7 32 18.5V24a5 5 0 0 1-5 5H5a5 5 0 0 1-5-5v-5.5c0-3.05 1.3-5.8 3.38-7.72zM11 19a2 2 0 1 1-4 0 2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0m5 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm5.26-9.55a2 2 0 0 1-3.52-1.9l3.5-6.5a2 2 0 0 1 3.52 1.9l-3.5 6.5z"></path>
            </svg>
        </div>
      <!-- /ko -->
      <div class="avatar-image"></div>
      <!-- ko if: isUser -->
        <div class="avatar-badge"></div>
      <!-- /ko -->
      <div class="avatar-border"></div>
      <!-- ko if: isTemporaryGuest() -->
        <svg class="avatar-temporary-guest-border" viewBox="0 0 32 32" data-bind="attr: {stroke: participant().accent_color()}">
          <circle cx="16" cy="16" transform="rotate(-90 16 16)" fill="none"
             data-bind="attr: {'stroke-dasharray': timerLength, 'stroke-dashoffset': timerOffset, 'r': borderRadius, 'stroke-width': borderWidth}">
          </circle>
        </svg>
      <!-- /ko -->
    </div>
    `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.ParticipantAvatar(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ParticipantItem = class ParticipantItem {
  constructor(params) {
    this.participant = ko.unwrap(params.participant);
    this.isService = this.participant instanceof z.integration.ServiceEntity || this.participant.isService;
    this.isUser = this.participant instanceof z.entity.User && !this.participant.isService;
    this.selfUser = window.wire.app.repository.user.self;
    this.isTemporaryGuest = this.isUser && this.participant.isTemporaryGuest();

    this.mode = params.mode || z.components.UserList.MODE.DEFAULT;
    this.isDefaultMode = this.mode === z.components.UserList.MODE.DEFAULT;
    this.isOthersMode = this.mode === z.components.UserList.MODE.OTHERS;

    this.canSelect = params.canSelect;
    this.isSelected = params.isSelected;
    this.showCamera = params.showCamera;

    if (params.hideInfo) {
      this.contentInfo = null;
    } else if (this.isService) {
      this.contentInfo = this.participant.summary;
    } else if (this.isTemporaryGuest) {
      this.contentInfo = this.participant.expirationText;
    } else {
      this.contentInfo = this.participant.username();
    }
  }
};

ko.components.register('participant-item', {
  template: `
    <div class="participant-item" data-bind="attr: {'data-uie-name': isUser ? 'item-user' : 'item-service', 'data-uie-value': participant.name}">
      <div class="participant-item-image">
        <participant-avatar params="participant: participant, size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
      </div>

      <div class="participant-item-content">
        <!-- ko if: isUser && selfUser().inTeam() -->
          <availability-state class="participant-item-content-availability participant-item-content-name"
            data-uie-name="status-name"
            params="availability: participant.availability, label: participant.name"></availability-state>
        <!-- /ko -->

        <!-- ko if: isService || !selfUser().inTeam() -->
          <div class="participant-item-content-name" data-bind="text: participant.name" data-uie-name="status-name"></div>
        <!-- /ko -->
        <div class="participant-item-content-info">
          <!-- ko if: contentInfo -->
            <span class="participant-item-content-username label-username-notext" data-bind="text: contentInfo, css: {'label-username': isUser && !isTemporaryGuest}" data-uie-name="status-username"></span>
          <!-- /ko -->
        </div>
      </div>

      <!-- ko if: isUser && participant.is_verified() -->
        <verified-icon data-uie-name="status-verified"></verified-icon>
      <!-- /ko -->

      <!-- ko if: isUser && !isOthersMode && participant.isGuest() -->
        <guest-icon class="participant-item-guest-indicator" data-uie-name="status-guest"></guest-icon>
      <!-- /ko -->

      <!-- ko if: showCamera -->
        <camera-icon data-uie-name="status-video"></camera-icon>
      <!-- /ko -->

      <!-- ko if: canSelect -->
        <div class="search-list-item-select icon-check" data-bind="css: {'selected': isSelected}" data-uie-name="status-selected"></div>
      <!-- /ko -->

      <disclose-icon></disclose-icon>
    </div>
  `,
  viewModel: z.components.ParticipantItem,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserProfile = class UserProfile {
  constructor(params) {
    this.dispose = this.dispose.bind(this);

    this.logger = new z.util.Logger('z.components.UserProfile', z.config.LOGGER.OPTIONS);

    this.userEntity = params.user;

    this.hasUser = ko.pureComputed(() => typeof this.userEntity === 'function' && !!this.userEntity());

    // Actions
    this.clickOnClose = () => {
      if (typeof params.close === 'function') {
        this.renderAvatar(false);
        params.close();
      }
    };

    this.clickOnPending = () => {
      if (this.hasUser()) {
        const isPendingRequest = this.userEntity().isIgnored() || this.userEntity().isIncomingRequest();
        if (isPendingRequest && typeof params.pending === 'function') {
          return params.pending(this.userEntity());
        }
      }
    };

    this.clickToAcceptInvite = () => {
      if (this.hasUser() && typeof params.accept === 'function') {
        params.accept(this.userEntity());
      }
    };

    this.clickToIgnoreInvite = () => {
      if (this.hasUser() && typeof params.ignore === 'function') {
        params.ignore(this.userEntity());
      }
    };

    this.clickToSendRequest = () => {
      if (this.hasUser() && typeof params.connect === 'function') {
        params.connect(this.userEntity());
      }
    };

    this.clickToUnblock = () => {
      if (this.hasUser() && typeof params.unblock === 'function') {
        params.unblock(this.userEntity());
      }
    };

    this.renderAvatar = ko.observable(false);
    this.renderAvatarComputed = ko.computed(() => {
      const hasUserId = this.hasUser();

      // swap value to re-render avatar
      if (hasUserId) {
        this.renderAvatar(false);
        window.setTimeout(() => this.renderAvatar(hasUserId), 0);
      }
    });

    // footer
    this.getFooterTemplate = ko.pureComputed(() => {
      if (this.hasUser()) {
        const userEntity = this.userEntity();

        if (userEntity.isBlocked()) {
          return 'user-profile-footer-unblock';
        }

        if (userEntity.isIgnored() || userEntity.isIncomingRequest()) {
          return 'user-profile-footer-ignore-accept';
        }

        if (userEntity.isUnknown()) {
          return 'user-profile-footer-add';
        }
      }

      return 'user-profile-footer-empty';
    });
  }

  dispose() {
    this.renderAvatarComputed.dispose();
  }
};

ko.components.register('user-profile', {
  template: `
    <div class="user-profile-transition">
      <!-- ko if: hasUser() -->
        <div class="user-profile-default">
          <div class="user-profile-header">
            <div class="name popover-title ellipsis" data-bind="text: userEntity().name(), attr: {'data-uie-uid': userEntity().id, 'data-uie-value': userEntity().name()}" data-uie-name="status-user"></div>
            <div class="username popover-meta label-username" data-bind="text: userEntity().username(), attr: {'data-uie-value': userEntity().name()}" data-uie-name="status-username"></div>
          </div>

          <div class="user-profile-details">
            <!-- ko if: renderAvatar() -->
              <div class="user-profile-details-avatar">
                <participant-avatar class="cursor-default" params="participant: userEntity, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>
              </div>
            <!-- /ko -->
          </div>
          <div class="user-profile-footer">
            <!-- ko template: {name: getFooterTemplate} --><!-- /ko -->
          </div>
        </div>
      <!-- /ko -->
    </div>
  `,
  viewModel: z.components.UserProfile,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserInput = class UserInput {
  constructor(params, componentInfo) {
    this.dispose = this.dispose.bind(this);

    this.input = params.input;
    this.onEnter = params.enter;
    this.placeholderText = params.placeholder;
    this.selectedUsers = params.selected;

    this.element = componentInfo.element;
    this.innerElement = $(this.element).find('.search-inner');
    this.inputElement = $(this.element).find('.search-input');

    this.hasFocus = ko.observable(false);
    if (params.focusDelay) {
      window.setTimeout(() => this.hasFocus(true), params.focusDelay);
    } else {
      this.hasFocus(true);
    }

    this.noSelectedUsers = ko.pureComputed(() => {
      return typeof this.selectedUsers !== 'function' || !this.selectedUsers().length;
    });

    if (typeof this.selectedUsers === 'function') {
      this.selectedSubscription = this.selectedUsers.subscribe(() => {
        if (typeof this.input === 'function') {
          this.input('');
        }

        this.inputElement.focus();
        window.setTimeout(() => this.innerElement.scrollTop(this.innerElement[0].scrollHeight));
      });
    }

    this.placeholder = ko.pureComputed(() => {
      const emptyInput = typeof this.input !== 'function' || !this.input().length;
      if (emptyInput && this.noSelectedUsers()) {
        return z.l10n.text(this.placeholderText);
      }

      return '';
    });
  }

  onKeyDown(data, keyboardEvent) {
    if (typeof this.selectedUsers === 'function') {
      if (z.util.KeyboardUtil.isRemovalAction(keyboardEvent) && !this.input().length) {
        this.selectedUsers.pop();
      }
    }
    return true;
  }

  dispose() {
    if (this.selectedSubscription) {
      this.selectedSubscription.dispose();
    }
  }
};

ko.components.register('user-input', {
  template: `
    <div class="search-outer">
      <div class="search-inner-wrap">
        <div class="search-inner"">
          <div class="search-icon icon-search"></div>
          <!-- ko ifnot: noSelectedUsers-->
            <!-- ko foreach: selectedUsers -->
              <span data-bind="text: first_name()" data-uie-name="item-selected"></span>
            <!-- /ko -->
          <!-- /ko -->
          <input type="text" style="display:none" /> <!-- prevent chrome from autocomplete -->
          <input autocomplete="off" maxlength="128" required spellcheck="false" class="search-input" type="text" data-bind="textInput: input, hasFocus: hasFocus, attr: {placeholder: placeholder}, css: {'search-input-show-placeholder': placeholder}, event: {keydown: onKeyDown}, enter: onEnter" data-uie-name="enter-users">
        </div>
      </div>
    </div>
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.UserInput(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserList = class UserList {
  static get MODE() {
    return {
      COMPACT: 'UserList.MODE.COMPACT',
      DEFAULT: 'UserList.MODE.DEFAULT',
      OTHERS: 'UserList.MODE.OTHERS',
    };
  }

  /**
   * Displays a list of user_ets
   *
   * @param {Object} params - Component parameters
   * @param {ko.observableArray} params.user - User data source
   * @param {ko.observable} params.filter - Filter list items
   * @param {Function} params.click - Called when a list item is selected
   * @param {ko.observableArray} params.selected - Populated will all the selected items
   * @param {Array} params.highlightedUsers - List of highlighted items
   */
  constructor(params) {
    this.click = params.click;
    this.filter = params.filter;
    this.selectedUsers = params.selected;
    this.mode = params.mode || UserList.MODE.DEFAULT;
    this.searchRepository = params.searchRepository;
    this.userEntities = params.user;
    const highlightedUsers = params.highlightedUsers ? params.highlightedUsers() : [];
    this.highlightedUserIds = highlightedUsers.map(user => user.id);
    this.isSelectEnabled = typeof params.selected === 'function';
    this.altStyle = params.altStyle;

    this.isCompactMode = this.mode === UserList.MODE.COMPACT;
    this.isDefaultMode = this.mode === UserList.MODE.DEFAULT;
    this.isOthersMode = this.mode === UserList.MODE.OTHERS;

    this.cssClasses = ko.pureComputed(() => (this.isCompactMode ? 'search-list-sm' : 'search-list-lg'));

    this.onUserClick = (userEntity, event) => {
      if (this.isSelectEnabled) {
        if (this.isSelected(userEntity)) {
          this.selectedUsers.remove(userEntity);
        } else {
          this.selectedUsers.push(userEntity);
        }
      }
      if (typeof this.click === 'function') {
        this.click(userEntity, event);
      }
    };

    // Filter all list items if a filter is provided
    this.filteredUserEntities = ko.pureComputed(() => {
      if (typeof this.filter === 'function') {
        const normalizedQuery = z.search.SearchRepository.normalizeQuery(this.filter());
        if (normalizedQuery) {
          const SEARCHABLE_FIELDS = z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS;
          const trimmedQuery = this.filter().trim();
          const isHandle = trimmedQuery.startsWith('@') && z.user.UserHandleGenerator.validate_handle(normalizedQuery);
          const properties = isHandle ? [SEARCHABLE_FIELDS.USERNAME] : undefined;
          return this.searchRepository.searchUserInSet(normalizedQuery, this.userEntities(), properties);
        }
      }
      return this.userEntities();
    });

    this.isSelected = userEntity => {
      if (this.isSelectEnabled) {
        return this.selectedUsers().includes(userEntity);
      }
    };

    this.selfUser = window.wire.app.repository.user.self;
  }
};

ko.components.register('user-list', {
  template: `
    <div class="search-list" data-bind="css: cssClasses(), foreach: {data: filteredUserEntities}">
      <participant-item params="participant: $data, canSelect: $parent.isSelectEnabled, isSelected: $parent.isSelected($data), mode: $parent.mode" data-bind="click: $parent.onUserClick, css: {'no-underline': $parent.altStyle, 'show-arrow': $parent.altStyle, 'highlighted': $parent.highlightedUserIds.includes($data.id)}"></participant-item>
    </div>

    <!-- ko if: typeof filter === 'function' -->
      <!-- ko if: userEntities().length === 0 -->
        <div class="no-results" data-bind="l10n_text: z.string.searchListEveryoneParticipates"></div>
      <!-- /ko -->

      <!-- ko if: userEntities().length > 0 && filteredUserEntities().length === 0 -->
        <div class="no-results" data-bind="l10n_text: z.string.searchListNoMatches" data-uie-name="status-no-matches"></div>
      <!-- /ko -->
    <!-- /ko -->
  `,
  viewModel: z.components.UserList,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GuestModeToggle = class GuestModeToggle {
  constructor(params) {
    this.isChecked = params.isChecked;
    this.onToggle = params.onToggle;
    this.isDisabled = params.isDisabled;
    this.infoText = params.extendedInfo ? z.string.guestRoomToggleInfoExtended : z.string.guestRoomToggleInfo;
  }
};

ko.components.register('guest-mode-toggle', {
  template: `
    <div class="guest-mode-toggle-row">
      <div data-bind="text: z.string.guestRoomToggleName"></div>
      <div class="slider" data-bind="css: {'disabled': isDisabled}">
        <input class="slider-input" type="checkbox" name="toggle" id="toggle" data-bind="checked: isChecked">
        <label class="button-label" for="toggle" data-bind="click: onToggle, attr: {'data-uie-value': isChecked() ? 'checked': 'unchecked'}" data-uie-name="do-allow-guests" ></label>
      </div>
    </div>
    <div class="panel__info-text guest-mode-toggle-info" data-bind="text: infoText" data-uie-name="status-guest-toggle"></div>
  `,
  viewModel: z.components.GuestModeToggle,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('add-participants-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12 2V0h2v2h2v2h-2v2h-2V4h-2V2h2zm-2.57 8.57A2.57 2.57 0 0 1 12 13.14v1.1a12.8 12.8 0 0 1-12 0v-1.1a2.57 2.57 0 0 1 2.57-2.57h.34a5.97 5.97 0 0 0 6.18 0h.34zM6 8.86A3.43 3.43 0 1 1 6 2a3.43 3.43 0 0 1 0 6.86z"></path>
  </svg>
  `,
});

ko.components.register('archive-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M1 7h14v7a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7zm6 2a1 1 0 1 0 0 2h2a1 1 0 0 0 0-2H7zM2.5 0h11c.8 0 1.2 0 1.5.3.3.1.6.4.7.7.2.3.3.7.3 1.5V4c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V2.5C0 1.7 0 1.3.3 1 .4.7.7.4 1 .3c.3-.2.7-.3 1.5-.3z"></path>
  </svg>
  `,
});

ko.components.register('arrow-left-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
      <path d="M4.83 9l5.24 5.24-1.41 1.41L1 8 8.66.34l1.41 1.41L4.83 7H15v2z"></path>
  </svg>
  `,
});

ko.components.register('attachment-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M1.63 7.7l4.74-4.78a3.33 3.33 0 0 1 4.73 0 3.4 3.4 0 0 1 0 4.78L9.75 9.07l-4.4 4.43a1.9 1.9 0 0 1-2.7 0 1.94 1.94 0 0 1 0-2.73L4 9.41l4.4-4.45a.47.47 0 0 1 .68 0c.18.2.19.5 0 .69l-4.75 4.79a.97.97 0 0 0 0 1.36c.38.38.98.38 1.36 0l4.74-4.79c.94-.94.93-2.46 0-3.4a2.37 2.37 0 0 0-3.38-.01l-4.4 4.44-1.36 1.37a3.89 3.89 0 0 0 0 5.46 3.8 3.8 0 0 0 5.42 0l4.4-4.44 1.35-1.37a5.34 5.34 0 0 0 0-7.5 5.23 5.23 0 0 0-7.44 0L.28 6.32a.97.97 0 0 0 0 1.37c.37.38.98.38 1.35 0z"></path>
  </svg>
  `,
});

ko.components.register('audio-icon', {
  template: `
  <svg width="12" height="16" viewBox="0 0 12 16">
    <path d="M10.5 12l1.4 1.4a8 8 0 0 1-11.9 0L1.4 12a6 6 0 0 0 9.1 0zM6 12a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4 4 4 0 0 1 4 4v4a4 4 0 0 1-4 4z"></path>
  </svg>
  `,
});

ko.components.register('block-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm4.9-11.48l-.2.19-8.18 8.18a6 6 0 0 0 8.37-8.37zm-1.42-1.41a6 6 0 0 0-8.37 8.37l8.18-8.19.19-.18z"></path>
  </svg>
  `,
});

ko.components.register('camera-icon', {
  template: `
  <svg width="16" height="12" viewBox="0 0 16 12">
    <path id="a" d="M2.6 0h4.8c1 0 1.3 0 1.6.3.3.1.6.4.7.7.2.3.3.7.3 1.6v6.8c0 1 0 1.3-.3 1.6-.1.3-.4.6-.7.7-.3.2-.7.3-1.6.3H2.6c-1 0-1.3 0-1.6-.3-.3-.1-.6-.4-.7-.7-.2-.3-.3-.7-.3-1.6V2.6c0-1 0-1.3.3-1.6C.4.7.7.4 1 .3c.3-.2.7-.3 1.6-.3zm8.7 5.3l3-3A1 1 0 0 1 16 3v6a1 1 0 0 1-1.7.7l-3-3a1 1 0 0 1 0-1.4z"></path>
  </svg>
  `,
});

ko.components.register('check-icon', {
  template: `
  <svg width="16" height="12" viewBox="0 0 16 12">
    <path d="M5.7 11.9L16 1.4 14.6 0 5.7 9 1.4 4.8 0 6.2z"></path>
  </svg>
  `,
});

ko.components.register('chevron-icon', {
  template: `
  <svg width="7" height="4" viewBox="0 0 7 4">
    <path d="M3.65 3.65L6.44.85A.5.5 0 0 0 6.09 0H.5a.5.5 0 0 0-.35.85l2.79 2.8c.2.2.51.2.7 0z"></path>
  </svg>
  `,
});

ko.components.register('close-icon', {
  template: `
  <svg width="14" height="14" viewBox="0 0 14 14">
    <path d="M1.41 13.31l5.25-5.24 5.24 5.24 1.41-1.41-5.24-5.24 5.24-5.25L11.9 0 6.66 5.24 1.41 0 0 1.41l5.24 5.25L0 11.9z"></path>
  </svg>
  `,
});

ko.components.register('copy-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M6 10h8V2H6v8zM5 0h10a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1zM2 4v10h10v1a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h1z"></path>
  </svg>
  `,
});

ko.components.register('delete-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M5 2a2 2 0 1 1 4 0h4a1 1 0 0 1 1 1v1H0V3a1 1 0 0 1 1-1h4zM1 6h12l-.8 8c-.11 1.1-1.09 2-2.2 2H4c-1.1 0-2.09-.89-2.2-2L1 6zm5.5 2v5.54h1V8h-1z"></path>
  </svg>
  `,
});

ko.components.register('devices-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M11 4h2.4c1 0 1.2.1 1.6.3.3.1.6.4.7.7.2.3.3.7.3 1.6v6.8c0 1-.1 1.2-.3 1.6-.1.3-.4.6-.7.7-.3.2-.7.3-1.6.3H2.6c-1 0-1.2-.1-1.6-.3a1.8 1.8 0 0 1-.7-.7c-.2-.3-.3-.7-.3-1.6V2.6C0 1.6.1 1.4.3 1 .4.7.7.4 1 .3c.4-.2.7-.3 1.6-.3h5.8c1 0 1.2.1 1.6.3.3.1.6.4.7.7.2.4.3.7.3 1.6V4zM9 4V3a1 1 0 0 0-1-1h-.5a.5.5 0 0 0-.5.5.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5.5.5 0 0 0-.5-.5H3a1 1 0 0 0-1 1v9.7l.1.8.4.4.8.1H7a8.2 8.2 0 0 1 0-.6V6.6c0-1 .1-1.3.3-1.6.1-.3.4-.6.7-.7.3-.2.5-.3 1-.3zm1.3 2l-.8.1a.9.9 0 0 0-.4.4l-.1.8v5.4l.1.8.4.4.8.1h2.4l.8-.1a.9.9 0 0 0 .4-.4l.1-.8V7.3l-.1-.8a.9.9 0 0 0-.4-.4l-.8-.1h-2.4z"></path>
  </svg>
  `,
});

ko.components.register('disclose-icon', {
  template: `
  <svg width="5" height="8" viewBox="0 0 5 8">
    <path d="M0 .92L.94 0 5 4 .94 8 0 7.08 3.13 4z"></path>
  </svg>
  `,
});

ko.components.register('edit-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M14.55 4.85l.75-.75A2.4 2.4 0 0 0 11.9.7l-.75.75 3.4 3.4zm-.7.7l-9.6 9.6L0 16l.85-4.25 9.6-9.6 3.4 3.4zM4 13.6L2 14l.4-2L4 13.6z"></path>
  </svg>
  `,
});

ko.components.register('file-icon', {
  template: `
  <svg  width="12" height="16" viewBox="0 0 12 16">
    <path d="M1 0a1 1 0 0 0-1 1v14c0 .6.5 1 1 1h10c.6 0 1-.5 1-1V6H8a2 2 0 0 1-2-2V0H1zm11 5H8.4C7.7 5 7 4.4 7 3.7V0l5 5z"></path>
  </svg>
  `,
});

ko.components.register('fullscreen-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M16 7V0H9v2h3.6L8 6.6 9.4 8 14 3.4V7h2zM0 9v7h7v-2H3.4L8 9.4 6.6 8 2 12.6V9H0z"></path>
  </svg>
  `,
});

ko.components.register('gif-icon', {
  template: `
  <svg width="16" height="13" viewBox="0 0 16 13">
    <path d="M12 7.2v5h-2V.2h6v2h-4v3h3v2h-3zm-5-7h2v12H7V.2zm-2 5h1v4.2a3 3 0 0 1-6 0V3a3 3 0 0 1 6 0v.2H4V3a1 1 0 0 0-1-1 1 1 0 0 0-1 1v6.4a1 1 0 0 0 1 1 1 1 0 0 0 1-1V7.2H3v-2h2z"></path>
  </svg>
  `,
});

ko.components.register('group-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 4a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zM2 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm12 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('guest-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M5 1a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3c0-1.1.9-2 2-2h3zm.5 1a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zM7 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm-2 1a2 2 0 0 0-2 2v1h8v-1a2 2 0 0 0-2-2H5z"></path>
  </svg>
  `,
});

ko.components.register('hangup-icon', {
  template: `
  <svg width="20" height="8" viewBox="0 0 20 8">
    <path d="M.6 2.7C2.2 1.2 6 0 9.7 0c3.8 0 7.6 1.2 9 2.7 1 .9.9 2.9 0 4.6l-.3.3H18A216 216 0 0 0 14 6c-.4-.1-.3-.1-.3-.5V3.4l-1-.2a13 13 0 0 0-6.2 0l-.9.2V6l-.4.2a155.4 155.4 0 0 0-3.8 1.5c-.4.1-.4.1-.6-.3-1-1.7-1-3.7-.2-4.6z"></path>
  </svg>
  `,
});

ko.components.register('image-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 1c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v14c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V1zm14 1H2v9l4-2 8 3.5V2zm-4 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('info-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path id="a" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm0-2A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm0-7c.6 0 1 .4 1 1v3a1 1 0 0 1-2 0V8c0-.6.4-1 1-1zm0-1a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"></path>
  </svg>
  `,
});

ko.components.register('link-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5 3.25A5.79 5.79 0 0 1 10.213 0C13.409 0 16 2.574 16 5.75s-2.591 5.75-5.787 5.75A5.79 5.79 0 0 1 5 8.25h2.4a3.775 3.775 0 0 0 2.813 1.25c2.084 0 3.774-1.679 3.774-3.75 0-2.071-1.69-3.75-3.774-3.75A3.775 3.775 0 0 0 7.4 3.25H5zm6 4.5H8.6A3.775 3.775 0 0 0 5.787 6.5c-2.084 0-3.774 1.679-3.774 3.75 0 2.071 1.69 3.75 3.774 3.75A3.775 3.775 0 0 0 8.6 12.75H11A5.79 5.79 0 0 1 5.787 16C2.591 16 0 13.426 0 10.25S2.591 4.5 5.787 4.5A5.79 5.79 0 0 1 11 7.75z"></path>
  </svg>
  `,
});

ko.components.register('leave-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2 14h7v2H0V0h9v2H2v12zm3-7v2h7v4l4-5-4-5v4H5z"></path>
  </svg>
  `,
});

ko.components.register('location-icon', {
  template: `
  <svg width="12" height="16" viewBox="0 0 12 16">
    <path d="M12 6c0 6-6 10-6 10S0 12 0 6a6 6 0 1 1 12 0zM6 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
  </svg>
  `,
});

ko.components.register('markdown-icon', {
  template: `
  <svg width="15" height="14" viewBox="0 0 15 14">
    <path d="M3.1 0h1.66l3.1 13.88h-2l-.58-2.98h-2.7l-.6 2.98H0L3.1 0zm9.38 12.87h-.04c-.26.36-.52.64-.79.84-.27.2-.64.29-1.12.29-.23 0-.48-.04-.72-.1a1.8 1.8 0 0 1-.7-.4 2.04 2.04 0 0 1-.52-.8c-.14-.34-.2-.79-.2-1.33 0-.56.04-1.05.13-1.47.1-.43.26-.78.5-1.06s.56-.48.96-.62a4.88 4.88 0 0 1 1.97-.19l.53.04V7.04c0-.34-.07-.62-.22-.84-.14-.22-.4-.33-.78-.33-.26 0-.5.08-.7.25a1.2 1.2 0 0 0-.43.74H8.42c.07-.9.37-1.6.9-2.14.26-.26.57-.47.94-.62a3.45 3.45 0 0 1 2.4-.03 2.58 2.58 0 0 1 1.57 1.57c.16.39.24.84.24 1.36v6.88h-2v-1.01zm0-3.24c-.22-.04-.4-.06-.55-.06-.43 0-.8.1-1.1.3-.3.2-.46.57-.46 1.1 0 .38.1.69.28.92a.9.9 0 0 0 .76.36c.33 0 .6-.12.79-.34.18-.22.28-.53.28-.93V9.63zM3.94 4H3.9l-.98 5.03h2L3.93 4z"></path>
  </svg>
  `,
});

ko.components.register('mention-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 6.2c-.8 0-1.4.8-1.4 2 0 1.3.6 2 1.4 2 1 0 1.5-.7 1.5-2 0-1.2-.6-2-1.5-2zM8.4 0C13 0 16 3 16 7.3c0 3-1.2 5-3.7 5-1.2 0-2.1-.6-2.4-1.5h-.2c-.4 1-1.1 1.5-2.3 1.5-2 0-3.3-1.7-3.3-4.1 0-2.4 1.3-4 3.2-4a2.4 2.4 0 0 1 2.2 1.3h.2c0-.6.5-1 1-1h.3c.6 0 1 .4 1 1v3.9c0 .7.3 1 .8 1 .9 0 1.3-1 1.3-2.9 0-3.5-2.2-5.8-5.8-5.8C4.6 1.7 2 4.4 2 8.2c0 3.9 2.6 6 6.8 6a11.3 11.3 0 0 0 1.5-.1.7.7 0 0 1 .8.7c0 .5-.4 1-.9 1H10l-1.4.2C3.5 16 0 13 0 8c0-4.7 3.4-8 8.4-8z"></path>
  </svg>
  `,
});

ko.components.register('message-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M3 0h10a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H6a3 3 0 0 0-1.8.7l-2.6 2.1A1 1 0 0 1 0 15V3a3 3 0 0 1 3-3z"></path>
  </svg>
  `,
});

ko.components.register('message-unread-icon', {
  template: `
  <svg width="18" height="18" viewBox="0 0 18 18">
    <path d="M12 2a4 4 0 0 0 4 4v6a3 3 0 0 1-3 3H6a3 3 0 0 0-1.8.7l-2.6 2A1 1 0 0 1 0 17V5a3 3 0 0 1 3-3h9zm4 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('micoff-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M3.2 14.5a8 8 0 0 0 10.7-1.1L12.4 12A6 6 0 0 1 5 13.2l-1.8 1.3zm8.7-6a4 4 0 0 1-5 3.4l5-3.4zm0-4.5a4 4 0 0 0-4-4 4 4 0 0 0-4 4v4c0 .5 0 1 .2 1.4L.8 11.7l-.8.5L1.1 14l.9-.6 13-9 .8-.5L14.6 2l-.8.6-2 1.3z"></path>
  </svg>
  `,
});

ko.components.register('minus-icon', {
  template: `
  <svg width="16" height="2" viewBox="0 0 16 2">
    <path d="M0 0h16v2H0z"></path>
  </svg>
  `,
});

ko.components.register('mute-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12 3.2l2-1.4a1 1 0 0 1 1.2 1.6L1.6 13a1 1 0 0 1-1.1-1.6l1.3-.9v-.2S2.7 8.5 3 7.5c.4-1.2 1-4.3 1-4.3C4.3 1.4 6 0 8 0a4 4 0 0 1 4 3.2zm1 4.2v.1l1.2 2.7c.4 1-.1 1.8-1.2 1.8H6.4L13 7.4zM10 14a2 2 0 1 1-4 0h4z"></path>
  </svg>
  `,
});

ko.components.register('notification-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M7 0C5 0 3.3 1.4 3 3.2c0 0-.5 3-1 4.3L.8 10.2C.4 11.2 1 12 2 12h10c1.1 0 1.6-.8 1.2-1.8L12 7.5c-.4-1.2-1-4.3-1-4.3A4 4 0 0 0 7 0zm2 14a2 2 0 1 1-4 0h4z"></path>
  </svg>
  `,
});

ko.components.register('pending-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm0 2A8 8 0 1 1 8 0a8 8 0 0 1 0 16zM7 7h5v2H7V7zm0-4h2v6H7V3z"></path>
  </svg>
  `,
});

ko.components.register('people-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M10.6 10h.4a3 3 0 0 1 3 3v1.27a14.93 14.93 0 0 1-14 0V13a3 3 0 0 1 3-3h.4a6.97 6.97 0 0 0 7.2 0zM7 8a4 4 0 1 1 0-8 4 4 0 0 1 0 8z"></path>
  </svg>
  `,
});

ko.components.register('pickup-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12.7 16c-2 0-5.6-1.8-8.2-4.5C1.8 9 0 5.3 0 3.3 0 2 1.4.6 3.4.1l.3-.1.3.3a216 216 0 0 0 1.7 3.8c.1.4.1.4-.1.6l-1 1-.5.6.4.7A13 13 0 0 0 9 11.5l.7.4 1.6-1.5.1-.1.1-.1.4.1a155.4 155.4 0 0 0 3.8 1.7c.4.2.3.2.2.6-.5 2-1.9 3.4-3.2 3.4z"></path>
  </svg>
  `,
});

ko.components.register('ping-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5.95 4.273a1.016 1.016 0 0 0 1.963-.527L7.11.754a1.016 1.016 0 1 0-1.964.526l.802 2.993zm4.101 7.455a1.016 1.016 0 0 0-1.963.526l.802 2.993a1.016 1.016 0 1 0 1.963-.526l-.802-2.993zM3.746 7.913a1.016 1.016 0 0 0 .527-1.964L1.28 5.147a1.016 1.016 0 1 0-.526 1.964l2.992.802zm8.508.175a1.016 1.016 0 1 0-.526 1.963l2.992.802a1.016 1.016 0 0 0 .527-1.963l-2.993-.802zM5.798 11.64a1.016 1.016 0 1 0-1.438-1.437l-2.19 2.19a1.016 1.016 0 1 0 1.436 1.438l2.192-2.19zm4.405-7.28a1.016 1.016 0 1 0 1.437 1.438l2.191-2.191a1.016 1.016 0 0 0-1.437-1.438L10.203 4.36z"></path>
  </svg>
  `,
});

ko.components.register('plus-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 7v2h7v7h2V9h7V7H9V0H7v7z"></path>
  </svg>
  `,
});

ko.components.register('profile-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zM2 8c0 1.5.56 2.88 1.47 3.94l.08-.46c.15-.82.93-1.48 1.76-1.48h5.38c.83 0 1.61.67 1.76 1.48l.08.46A6 6 0 1 0 2 8zm6 1a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5z"></path>
  </svg>
  `,
});

ko.components.register('reply-icon', {
  template: `
  <svg width="16" height="15" viewBox="0 0 16 15">
    <path d="M3.3 4h7.1C13.5 4 16 6.6 16 9.6c0 3-2.5 5.4-5.6 5.4H7a1 1 0 0 1 0-2h3.4c2 0 3.6-1.4 3.6-3.4S12.5 6 10.4 6h-7l2.4 2.4a1 1 0 0 1 0 1.3 1 1 0 0 1-1.4 0l-4.1-4a1 1 0 0 1-.2-.3 1 1 0 0 1 .2-1l4-4.1a1 1 0 0 1 1.5 0 1 1 0 0 1 0 1.3L3.3 4z"></path>
  </svg>
  `,
});

ko.components.register('screenshare-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5 14h6v2H5v-2zM0 1c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v11c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V1zm7 10h2V7h4L8 3 3 7h4v4z"></path>
  </svg>
  `,
});

ko.components.register('send-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 14.3c0 1.5 1 2.1 2.3 1.4L15 9.2c1.3-.7 1.3-1.7 0-2.4L2.3.3C1.1-.4 0 .3 0 1.7V8h12L0 10v4.3z"></path>
  </svg>
  `,
});

ko.components.register('service-icon', {
  template: `
  <svg width="32" height="32" viewBox="0 0 32 32">
    <path d="M10.5 12A6.5 6.5 0 0 0 4 18.5V24a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-5.5a6.5 6.5 0 0 0-6.5-6.5h-11zm-7.12-1.22L.24 4.95a2 2 0 1 1 3.52-1.9L6.8 8.68C7.94 8.24 9.19 8 10.5 8h11C27.3 8 32 12.7 32 18.5V24a5 5 0 0 1-5 5H5a5 5 0 0 1-5-5v-5.5c0-3.05 1.3-5.8 3.38-7.72zM11 19a2 2 0 1 1-4 0 2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0m5 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm5.26-9.55a2 2 0 0 1-3.52-1.9l3.5-6.5a2 2 0 0 1 3.52 1.9l-3.5 6.5z"></path>
  </svg>
`,
});

ko.components.register('settings-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2.8 11a6 6 0 0 1-.6-1.5H0v-3h2.2c.1-.6.3-1 .6-1.5L1.3 3.4l2.1-2.1L5 2.8a6 6 0 0 1 1.5-.6V0h3v2.2c.6.1 1 .3 1.5.6l1.6-1.5 2.1 2.1L13.2 5c.3.4.5 1 .6 1.5H16v3h-2.2a6 6 0 0 1-.6 1.5l1.5 1.6-2.1 2.1-1.6-1.5a6 6 0 0 1-1.5.6V16h-3v-2.2a6 6 0 0 1-1.5-.6l-1.6 1.5-2.1-2.1L2.8 11zM8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"></path>
  </svg>
  `,
});

ko.components.register('timer-icon', {
  template: `
  <svg width="15" height="16" viewBox="0 0 15 16">
    <path d="M7.44 2v1.08a6.48 6.48 0 0 1 5.45 6.42c0 3.59-2.89 6.5-6.45 6.5A6.47 6.47 0 0 1 0 9.5a6.48 6.48 0 0 1 5.45-6.42V2h-.5a1 1 0 0 1-.98-1 1 1 0 0 1 .99-1h2.97a1 1 0 0 1 1 1 1 1 0 0 1-1 1h-.5zm-1 12a4.48 4.48 0 0 0 4.47-4.5c0-2.49-2-4.5-4.47-4.5a4.48 4.48 0 0 0-4.46 4.5c0 2.49 2 4.5 4.46 4.5zm0-1a3.49 3.49 0 0 1-3.47-3.5C2.97 7.57 4.53 6 6.44 6v3.5l2.47 2.47A3.44 3.44 0 0 1 6.44 13zm6.57-10.3l.7.71a1 1 0 0 1 0 1.42.99.99 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.42.99.99 0 0 1 1.4 0z"></path>
  </svg>
  `,
});

ko.components.register('undo-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2.3 2.3a8.3 8.3 0 0 1 4-2.1 8.2 8.2 0 0 1 7.4 2.1A8 8 0 1 1 .3 10h2a6.1 6.1 0 0 0 2.2 2.9A6 6 0 0 0 14 8a6 6 0 0 0-8.3-5.5c-.8.3-1.4.7-2 1.3L7 7H0V0l2.3 2.3z"></path>
  </svg>
  `,
});

ko.components.register('verified-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path fill="#0097F8" d="M14 1.9L7 0 0 2v6c0 4 3 7.1 7 8 4-.9 7-4 7-8V1.9z"></path>
    <path fill="#0079B6" d="M14 1.9L7 0v16c4-.9 7-4 7-8V1.9z"></path>
  </svg>
  `,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

ko.components.register('wire-logo', {
  template: `
  <svg width="73" height="23" viewBox="0 0 73 23">
    <path d="M13.92 18.76a6.85 6.85 0 0 1-1.64-4.42V3.24a1.64 1.64 0 1 1 3.29 0V14.3a6.8 6.8 0 0 1-1.65 4.43v.04zm12.33-4.42a6.94 6.94 0 0 1-11.1 5.56 8.62 8.62 0 0 0 2.06-5.56V3.24A3.26 3.26 0 0 0 13.92 0a3.22 3.22 0 0 0-3.24 3.24V14.3c0 2.1.82 4.06 2.1 5.52A6.98 6.98 0 0 1 1.64 14.3V.87H0v13.47a8.63 8.63 0 0 0 13.97 6.7 8.78 8.78 0 0 0 5.34 1.83 8.52 8.52 0 0 0 8.54-8.53V.87H26.2v13.47h.04zm6.53 8.08h1.64V.82h-1.64v21.64-.04zm15.98-22A9.45 9.45 0 0 0 41 4.51V.82h-1.65v21.64H41V9.82a7.76 7.76 0 0 1 7.76-7.77V.41zm3.1 17.34a9.59 9.59 0 0 1 .55-12.92 9.68 9.68 0 0 1 13.01-.55L51.86 17.85v-.1zM67.75 4.29a11.32 11.32 0 0 0-16.48-.6 11.19 11.19 0 0 0 0 15.85 11.32 11.32 0 0 0 15.98 0l-1.19-1.14a9.68 9.68 0 0 1-13.01.55l6.76-6.71 7.94-7.9v-.05zm2.56-2.87V1.1h-1.74v.36h.69v1.78h.36V1.42h.73-.04zM73 3.24V1.1h-.55l-.6 1.68-.63-1.68h-.55v2.14h.37V1.51l.64 1.73H72l.63-1.73v1.73H73z"></path>
  </svg>
  `,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

class LoadingBar {
  constructor({progress, message}) {
    this.loadingMessage = message;
    this.loadingPercentage = ko.pureComputed(() => `${progress()}%`);
  }
}

ko.components.register('loading-bar', {
  template: `
    <div class="text-center">
      <div class="progress-console" data-bind="text: loadingMessage"></div>
      <div class="progress-bar"><div data-bind="style: {width: loadingPercentage}"></div></div>
    </div>
`,
  viewModel: LoadingBar,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AssetHeader = class AssetHeader {
  /**
   * Construct a new asset header.
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   */
  constructor(params) {
    this.message_et = params.message;
  }
};

ko.components.register('asset-header', {
  template: `
    <span class="asset-header-name" data-bind="text: message_et.user().first_name(), css: message_et.accent_color"></span>
    <span class="asset-header-time" data-bind="text: moment(message_et.timestamp()).format('D.M H:mm')"></span>
  `,
  viewModel: z.components.AssetHeader,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.VideoAssetComponent = class VideoAssetComponent {
  /**
   * Construct a new video asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.logger = new z.util.Logger('VideoAssetComponent', z.config.LOGGER.OPTIONS);

    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();

    this.preview_subscription = undefined;

    this.video_element = $(component_info.element).find('video')[0];
    this.video_src = ko.observable();
    this.video_time = ko.observable();

    this.video_playback_error = ko.observable(false);
    this.show_bottom_controls = ko.observable(false);

    this.video_time_rest = ko.pureComputed(() => this.video_element.duration - this.video_time());

    if (this.asset.preview_resource()) {
      this._load_video_preview();
    } else {
      this.preview_subscription = this.asset.preview_resource.subscribe(this._load_video_preview.bind(this));
    }

    this.onPlayButtonClicked = this.onPlayButtonClicked.bind(this);
    this.on_pause_button_clicked = this.on_pause_button_clicked.bind(this);
    this.displaySmall = ko.observable(!!params.isQuote);
  }

  _load_video_preview() {
    this.asset.load_preview().then(blob => {
      if (blob) {
        this.video_element.setAttribute('poster', window.URL.createObjectURL(blob));
        this.video_element.style.backgroundColor = '#000';
      }
    });
  }

  on_loadedmetadata() {
    this.video_time(this.video_element.duration);
  }

  on_timeupdate() {
    this.video_time(this.video_element.currentTime);
  }

  on_error(component, jquery_event) {
    this.video_playback_error(true);
    this.logger.error('Video cannot be played', jquery_event);
  }

  onPlayButtonClicked() {
    this.displaySmall(false);
    if (this.video_src()) {
      if (this.video_element) {
        this.video_element.play();
      }
    } else {
      this.asset
        .load()
        .then(blob => {
          this.video_src(window.URL.createObjectURL(blob));
          if (this.video_element) {
            this.video_element.play();
          }
          this.show_bottom_controls(true);
        })
        .catch(error => this.logger.error('Failed to load video asset ', error));
    }
  }

  on_pause_button_clicked() {
    if (this.video_element) {
      this.video_element.pause();
    }
  }

  on_video_playing() {
    this.video_element.style.backgroundColor = '#000';
  }

  dispose() {
    if (this.preview_subscription) {
      this.preview_subscription.dispose();
    }
    window.URL.revokeObjectURL(this.video_src());
  }
};

ko.components.register('video-asset', {
  template: `
    <!-- ko ifnot: message.isObfuscated() -->
      <div class="video-asset-container"
        data-bind="hide_controls: 2000,
                   attr: {'data-uie-value': asset.file_name},
                   css: {'video-asset-container--small': displaySmall()}"
        data-uie-name="video-asset">
        <video playsinline
               data-bind="attr: {src: video_src},
                          css: {hidden: asset.status() === z.assets.AssetTransferState.UPLOADING},
                          event: {loadedmetadata: on_loadedmetadata,
                                  timeupdate: on_timeupdate,
                                  error: on_error,
                                  playing: on_video_playing}">
        </video>
        <!-- ko if: video_playback_error -->
          <div class="video-playback-error label-xs" data-bind="l10n_text: z.string.conversationPlaybackError"></div>
        <!-- /ko -->
        <!-- ko ifnot: video_playback_error -->
          <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="asset-placeholder">
              <div class="three-dots">
                <span></span><span></span><span></span>
              </div>
            </div>
          <!-- /ko -->

          <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="video-controls-center">
              <!-- ko if: displaySmall() -->
                <media-button params="src: video_element,
                                      large: false,
                                      asset: asset,
                                      play: onPlayButtonClicked">
                </media-button>
              <!-- /ko -->
              <!-- ko ifnot: displaySmall() -->
                <media-button params="src: video_element,
                                      large: true,
                                      asset: asset,
                                      play: onPlayButtonClicked,
                                      pause: on_pause_button_clicked,
                                      cancel: () => asset.cancel(message)">
                </media-button>
              <!-- /ko -->
            </div>
            <div class='video-controls-bottom' data-bind='visible: show_bottom_controls()'>
              <seek-bar data-ui-name="status-video-seekbar" class="video-controls-seekbar" params="src: video_element"></seek-bar>
              <span class="video-controls-time label-xs" data-bind="text: z.util.TimeUtil.formatSeconds(video_time_rest())" data-uie-name="status-video-time"></span>
            </div>
          <!-- /ko -->
        <!-- /ko -->
      </div>
      <div class="video-asset-container__sizer"></div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.VideoAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AudioAssetComponent = class AudioAssetComponent {
  /**
   * Construct a new link preview asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.logger = new z.util.Logger('AudioAssetComponent', z.config.LOGGER.OPTIONS);

    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();
    this.header = params.header || false;

    this.audio_src = ko.observable();
    this.audio_element = $(component_info.element).find('audio')[0];
    this.audio_time = ko.observable(0);
    this.audio_is_loaded = ko.observable(false);

    this.show_loudness_preview = ko.pureComputed(() => {
      if (this.asset.meta && this.asset.meta.loudness) {
        return this.asset.meta.loudness.length > 0;
      }
    });

    if (this.asset.meta) {
      this.audio_time(this.asset.meta.duration);
    }

    $(component_info.element).attr({
      'data-uie-name': 'audio-asset',
      'data-uie-value': this.asset.file_name,
    });

    this.on_play_button_clicked = this.on_play_button_clicked.bind(this);
    this.on_pause_button_clicked = this.on_pause_button_clicked.bind(this);
  }

  on_timeupdate() {
    this.audio_time(this.audio_element.currentTime);
  }

  on_play_button_clicked() {
    Promise.resolve()
      .then(() => {
        if (!this.audio_src()) {
          return this.asset.load().then(blob => this.audio_src(window.URL.createObjectURL(blob)));
        }
      })
      .then(() => this.audio_element.play())
      .catch(error => this.logger.error('Failed to load audio asset ', error));
  }

  on_pause_button_clicked() {
    if (this.audio_element) {
      this.audio_element.pause();
    }
  }

  dispose() {
    window.URL.revokeObjectURL(this.audio_src());
  }
};

ko.components.register('audio-asset', {
  template: `
    <audio data-bind="attr: {src: audio_src}, event: {timeupdate: on_timeupdate}"></audio>
    <!-- ko ifnot: message.isObfuscated() -->
      <!-- ko if: header -->
        <asset-header params="message: message"></asset-header>
      <!-- /ko -->
      <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
        <div class="asset-placeholder">
          <div class="three-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      <!-- /ko -->
      <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
        <div class="audio-controls">
          <media-button params="src: audio_element,
                                asset: asset,
                                play: on_play_button_clicked,
                                pause: on_pause_button_clicked,
                                cancel: function() {asset.cancel(message)}">
          </media-button>
          <!-- ko if: asset.status() !== z.assets.AssetTransferState.UPLOADING -->
            <span class="audio-controls-time label-xs"
                  data-uie-name="status-audio-time"
                  data-bind="text: z.util.TimeUtil.formatSeconds(audio_time())">
            </span>
            <!-- ko if: show_loudness_preview -->
              <audio-seek-bar data-uie-name="status-audio-seekbar"
                              params="src: audio_element, asset: asset, disabled: !audio_src()"></audio-seek-bar>
            <!-- /ko -->
            <!-- ko ifnot: show_loudness_preview -->
              <seek-bar data-uie-name="status-audio-seekbar"
                        params="src: audio_element, dark: true, disabled: !audio_src()"></seek-bar>
            <!-- /ko -->
          <!-- /ko -->
        </div>
      <!-- /ko -->
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.AudioAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.FileAssetComponent = class FileAssetComponent {
  /**
   * Construct a new file asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   */
  constructor(params) {
    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();
    this.header = params.header || false;

    this.circle_upload_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.upload_progress() * 2} ${size}`;
    });

    this.circle_download_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.downloadProgress() * 2} ${size}`;
    });

    this.file_extension = ko.pureComputed(() => {
      const ext = z.util.getFileExtension(this.asset.file_name);
      return ext.length <= 3 ? ext : '';
    });
  }
};

ko.components.register('file-asset', {
  template: `\
    <!-- ko ifnot: message.isObfuscated() -->
      <!-- ko if: header -->
        <asset-header params="message: message"></asset-header>
      <!-- /ko -->
      <div class="file"
         data-uie-name="file"
         data-bind="attr: {'data-uie-value': asset.file_name},
                    click: asset.status() === z.assets.AssetTransferState.UPLOADED ? asset.download : null,
                    css: {'cursor-pointer': asset.status() === z.assets.AssetTransferState.UPLOADED}">
        <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
          <div class="asset-placeholder">
            <div class="three-dots">
              <span></span><span></span><span></span>
            </div>
          </div>
        <!-- /ko -->
        <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADED -->
            <div class="file-icon icon-file" data-bind="click: asset.download, clickBubble: false" data-uie-name="file-icon">
              <span class="file-icon-ext icon-view"></span>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
            <div class="media-button icon-close" data-bind="click: asset.cancel_download, clickBubble: false">
              <div class='media-button-border-file-fill'></div>
              <div class='media-button-border-fill'></div>
              <svg class="svg-theme" viewBox="0 0 32 32">
                <circle data-bind="style: {'stroke-dasharray': circle_download_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
              </svg>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="media-button icon-close" data-bind="click: function() {asset.cancel(message)}, clickBubble: false">
              <div class='media-button-border-file-fill'></div>
              <div class='media-button-border-fill'></div>
              <svg class="svg-theme" viewBox="0 0 32 32">
                <circle data-bind="style: {'stroke-dasharray': circle_upload_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
              </svg>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOAD_FAILED -->
            <div class="media-button media-button-error"></div>
          <!-- /ko -->
          <div class="file-desc">
            <div data-uie-name="file-name"
                 data-bind="text: z.util.trimFileExtension(asset.file_name)"
                 class="label-bold-xs ellipsis"></div>
            <ul class="file-desc-meta label-xs text-graphite">
              <li data-bind="text: z.util.formatBytes(asset.file_size)" data-uie-name="file-size"></li>
              <!-- ko if: z.util.getFileExtension(asset.file_name) -->
                <li data-bind="text: z.util.getFileExtension(asset.file_name)" data-uie-name="file-type"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADING -->
                <li data-bind="l10n_text: z.string.conversationAssetUploading" data-uie-name="file-status"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOAD_FAILED -->
                <li data-bind="l10n_text: z.string.conversationAssetUploadFailed" class="text-red"  data-uie-name="file-status"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
                <li data-bind="l10n_text: z.string.conversationAssetDownloading" data-uie-name="file-status"></li>
              <!-- /ko -->
            </ul>
          </div>
        <!-- /ko -->
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.FileAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.LinkPreviewAssetComponent = class LinkPreviewAssetComponent {
  /**
   * Construct a new link preview asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} componentInfo - Component information
   */
  constructor(params, componentInfo) {
    this.dispose = this.dispose.bind(this);
    this.onClick = this.onClick.bind(this);

    this.messageEntity = ko.unwrap(params.message);
    this.header = params.header || false;

    const [firstPreview] = this.messageEntity.get_first_asset().previews();
    this.preview = firstPreview;
    this.element = componentInfo.element;

    const isTypeTweet = this.preview && this.preview.meta_data_type === z.links.LinkPreviewMetaDataType.TWEET;
    this.isTweet = isTypeTweet && z.util.ValidationUtil.urls.isTweet(this.preview.url);
    this.author = this.isTweet ? this.preview.meta_data.author.substring(0, 20) : '';

    if (!this.messageEntity.is_expired()) {
      this.element.addEventListener('click', this.onClick);
    }
  }

  onClick() {
    if (!this.messageEntity.is_expired()) {
      z.util.SanitizationUtil.safeWindowOpen(this.preview.url);
    }
  }

  dispose() {
    this.element.removeEventListener('click', this.onClick);
  }
};

ko.components.register('link-preview-asset', {
  template: `
    <!-- ko ifnot: messageEntity.isObfuscated() -->
      <div class="link-preview-image-container">
        <!-- ko if: !preview || !preview.image_resource() -->
          <div class="link-preview-image-placeholder icon-link"></div>
        <!-- /ko -->
        <!-- ko if: preview.image_resource() -->
          <image-component class="link-preview-image" params="asset: preview.image_resource" data-uie-name="link-preview-image"></image-component>
        <!-- /ko -->
      </div>

      <div class="link-preview-info">
        <!-- ko if: header -->
          <asset-header class="link-preview-info-header" params="message: messageEntity"></asset-header>
        <!-- /ko -->
        <!-- ko if: preview -->
          <!-- ko if: isTweet -->
            <div class="link-preview-info-title" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'" data-uie-name="link-preview-title"></div>
            <div class="link-preview-info-link text-graphite" data-bind="attr: {title: preview.url}" data-uie-name="link-preview-tweet-author">
              <span class="font-weight-bold link-preview-info-title-singleline" data-bind="text: author"></span>
              <span data-bind="l10n_text: z.string.conversationTweetAuthor"></span>
            </div>
          <!-- /ko -->
          <!-- ko ifnot: isTweet -->
            <div class="link-preview-info-title" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'" data-uie-name="link-preview-title"></div>
            <div class="link-preview-info-link text-graphite ellipsis" data-bind="text: z.util.URLUtil.getDomainName(preview.url), attr: {title: preview.url}" data-uie-name="link-preview-url"></div>
          <!-- /ko -->
        <!-- /ko -->
      </div>
    <!-- /ko -->

    <!-- ko if: messageEntity.isObfuscated() -->
      <div class="link-preview-image-container">
        <div class="link-preview-image-placeholder icon-link bg-color-ephemeral text-white"></div>
      </div>
      <div class="link-preview-info">
        <div class="link-preview-info-title ephemeral-message-obfuscated" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'"></div>
        <div class="link-preview-info-link ephemeral-message-obfuscated ellipsis" data-bind="text: preview.url"></div>
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.LinkPreviewAssetComponent(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.LocationAssetComponent = class LocationAssetComponent {
  /**
   * Construct a new audio asset.
   * @param {Object} params - Component parameters
   * @param {z.entity.Location} params.asset - Location asset
   */
  constructor(params) {
    this.asset = params.asset;
    this.locationRepository = params.locationRepository;
  }

  getMapsUrl(assetEntity) {
    const {latitude, longitude, name, zoom} = assetEntity;
    return this.locationRepository.getMapsUrl(latitude, longitude, name, zoom);
  }
};

ko.components.register('location-asset', {
  template: `
    <div class="location-asset-icon icon-location"></div>
    <div class="location-asset-title" data-bind="text: asset.name" data-uie-name="location-name"></div>
    <a target="_blank" rel="nofollow noopener noreferrer" class="label-xs text-theme" data-bind="attr: {href: getMapsUrl(asset)}, l10n_text: z.string.conversationLocationLink"></a>
  `,
  viewModel: z.components.LocationAssetComponent,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AudioSeekBarComponent = class AudioSeekBarComponent {
  /**
   * Construct a audio seek bar that renders audio levels.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {z.entity.File} params.asset - Asset file
   * @param {boolean} params.disabled - Disabled seek bar
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.audio_element = params.src;
    this.asset = params.asset;

    this.element = component_info.element;
    this.loudness = [];

    this.disabled = ko.computed(() => {
      if (typeof params.disabled === 'function') {
        $(this.element).toggleClass('element-disabled', params.disabled());
      }
    });

    if (this.asset.meta !== null && this.asset.meta.loudness !== null) {
      this.loudness = this._normalize_loudness(this.asset.meta.loudness, component_info.element.clientHeight);
    }

    this._on_resize_fired = _.debounce(() => {
      this._render_levels();
      this._on_time_update();
    }, 500);

    this._render_levels();

    this._on_level_click = this._on_level_click.bind(this);
    this._on_time_update = this._on_time_update.bind(this);
    this._on_audio_ended = this._on_audio_ended.bind(this);
    this.audio_element.addEventListener('ended', this._on_audio_ended);
    this.audio_element.addEventListener('timeupdate', this._on_time_update);
    component_info.element.addEventListener('click', this._on_level_click);
    window.addEventListener('resize', this._on_resize_fired);
  }

  _render_levels() {
    const number_of_levels_fit_on_screen = Math.floor(this.element.clientWidth / 3); // 2px + 1px
    const scaled_loudness = z.util.ArrayUtil.interpolate(this.loudness, number_of_levels_fit_on_screen);

    // eslint-disable-next-line no-unsanitized/property
    this.element.innerHTML = scaled_loudness.map(level => `<span style="height: ${level}px"></span>`).join('');
  }

  _normalize_loudness(loudness, max) {
    const peak = Math.max(...loudness);
    const scale = max / peak;
    return peak > max ? loudness.map(level => level * scale) : loudness;
  }

  _on_level_click(event) {
    const mouse_x = event.pageX - $(event.currentTarget).offset().left;
    const calculatedTime = (this.audio_element.duration * mouse_x) / event.currentTarget.clientWidth;
    const currentTime = window.isNaN(calculatedTime) ? 0 : calculatedTime;

    this.audio_element.currentTime = z.util.NumberUtil.clamp(currentTime, 0, this.audio_element.duration);
    this._on_time_update();
  }

  _on_time_update() {
    const $levels = this._clear_theme();
    const index = Math.floor((this.audio_element.currentTime / this.audio_element.duration) * $levels.length);
    this._add_theme(index);
  }

  _on_audio_ended() {
    this._clear_theme();
  }

  _clear_theme() {
    return $(this.element)
      .children()
      .removeClass('bg-theme');
  }

  _add_theme(index) {
    $(this.element)
      .children()
      .eq(index)
      .prevAll()
      .addClass('bg-theme');
  }

  dispose() {
    this.disabled.dispose();
    this.audio_element.removeEventListener('ended', this._on_audio_ended);
    this.audio_element.removeEventListener('timeupdate', this._on_time_update);
    this.element.removeEventListener('click', this._on_level_click);
    window.removeEventListener('resize', this._on_resize_fired);
  }
};

ko.components.register('audio-seek-bar', {
  template: '<!-- content is generated -->',
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.AudioSeekBarComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.SeekBarComponent = class SeekBarComponent {
  /**
   * Construct a seek bar.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.media_element = params.src;
    this.dark_mode = params.dark;
    this.disabled = ko.pureComputed(() => {
      if (typeof params.disabled === 'function') {
        params.disabled();
      }
    });

    this.seek_bar = $(component_info.element).find('input')[0];
    this.seek_bar_mouse_over = ko.observable(false);
    this.seek_bar_thumb_dragged = ko.observable(false);
    this.show_seek_bar_thumb = ko.pureComputed(() => this.seek_bar_thumb_dragged() || this.seek_bar_mouse_over());

    this.on_mouse_down = this.on_mouse_down.bind(this);
    this.on_mouse_up = this.on_mouse_up.bind(this);
    this.on_mouse_enter = this.on_mouse_enter.bind(this);
    this.on_mouse_leave = this.on_mouse_leave.bind(this);
    this.on_change = this.on_change.bind(this);
    this.on_timeupdate = this.on_timeupdate.bind(this);
    this.on_ended = this.on_ended.bind(this);
    this.seek_bar.addEventListener('mousedown', this.on_mouse_down);
    this.seek_bar.addEventListener('mouseup', this.on_mouse_up);
    this.seek_bar.addEventListener('mouseenter', this.on_mouse_enter);
    this.seek_bar.addEventListener('mouseleave', this.on_mouse_leave);
    this.seek_bar.addEventListener('change', this.on_change);
    this.media_element.addEventListener('timeupdate', this.on_timeupdate);
    this.media_element.addEventListener('ended', this.on_ended);
    this._update_seek_bar_style(0);
  }

  on_mouse_down() {
    this.media_element.pause();
    this.seek_bar_thumb_dragged(true);
  }

  on_mouse_up() {
    this.media_element.play();
    this.seek_bar_thumb_dragged(false);
  }

  on_mouse_enter() {
    this.seek_bar_mouse_over(true);
  }

  on_mouse_leave() {
    this.seek_bar_mouse_over(false);
  }

  on_change() {
    const currentTime = this.media_element.duration * (this.seek_bar.value / 100);
    this.media_element.currentTime = z.util.NumberUtil.clamp(currentTime, 0, this.media_element.duration);
  }

  on_timeupdate() {
    const value = (100 / this.media_element.duration) * this.media_element.currentTime;
    this._update_seek_bar(value);
  }

  on_ended() {
    this._update_seek_bar(100);
  }

  _update_seek_bar(progress) {
    if (this.media_element.paused && progress < 100) {
      return;
    }

    this.seek_bar.value = progress;
    this._update_seek_bar_style(progress);
  }

  _update_seek_bar_style(progress) {
    // TODO check if we can find a css solution
    const color = this.dark_mode ? 'rgba(141,152,159,0.24)' : 'rgba(255,255,255,0.4)';
    this.seek_bar.style.backgroundImage = `linear-gradient(to right, currentColor ${progress}%, ${color} ${progress}%)`;
  }

  dispose() {
    this.seek_bar.removeEventListener('mousedown', this.on_mouse_down);
    this.seek_bar.removeEventListener('mouseup', this.on_mouse_up);
    this.seek_bar.removeEventListener('mouseenter', this.on_mouse_enter);
    this.seek_bar.removeEventListener('mouseleave', this.on_mouse_leave);
    this.seek_bar.removeEventListener('change', this.on_change);
    this.media_element.removeEventListener('timeupdate', this.on_timeupdate);
    this.media_element.removeEventListener('ended', this.on_ended);
  }
};

ko.components.register('seek-bar', {
  template: `
    <input type="range" value="0" max="100" data-bind="css: {'show-seek-bar-thumb': show_seek_bar_thumb, 'element-disabled': disabled}">
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.SeekBarComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MediaButtonComponent = class MediaButtonComponent {
  /**
   * Construct a media button.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {boolean} params.large - Display large button
   * @param {z.entity.File} params.asset - Asset file
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.media_element = params.src;
    this.large = params.large;
    this.asset = params.asset;

    if (this.large) {
      component_info.element.classList.add('media-button-lg');
    }

    this.media_is_playing = ko.observable(false);

    this.svg_view_box = ko.pureComputed(() => {
      const size = this.large ? 64 : 32;
      return `0 0 ${size} ${size}`;
    });

    this.circle_upload_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.upload_progress() * 2} ${size}`;
    });

    this.circle_download_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.downloadProgress() * 2} ${size}`;
    });

    this.on_play_button_clicked = function() {
      if (typeof params.play === 'function') {
        params.play();
      }
    };
    this.on_pause_button_clicked = function() {
      if (typeof params.pause === 'function') {
        params.pause();
      }
    };
    this.on_cancel_button_clicked = function() {
      if (typeof params.cancel === 'function') {
        params.cancel();
      }
    };

    this.on_play = this.on_play.bind(this);
    this.on_pause = this.on_pause.bind(this);
    this.media_element.addEventListener('playing', this.on_play);
    this.media_element.addEventListener('pause', this.on_pause);
  }

  on_play() {
    this.media_is_playing(true);
  }

  on_pause() {
    this.media_is_playing(false);
  }

  dispose() {
    this.media_element.removeEventListener('playing', this.on_play);
    this.media_element.removeEventListener('pause', this.on_pause);
  }
};

ko.components.register('media-button', {
  template: `
    <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADED -->
      <div class='media-button media-button-play icon-play' data-bind="click: on_play_button_clicked, visible: !media_is_playing()" data-uie-name="do-play-media"></div>
      <div class='media-button media-button-pause icon-pause' data-bind="click: on_pause_button_clicked, visible: media_is_playing()" data-uie-name="do-pause-media"></div>
    <!-- /ko -->
    <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
      <div class="media-button icon-close" data-bind="click: asset.cancel_download" data-uie-name="status-loading-media">
        <div class='media-button-border-fill'></div>
        <svg class="svg-theme" data-bind="attr: {viewBox: svg_view_box}">
          <circle data-bind="style: {'stroke-dasharray': circle_download_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
        </svg>
      </div>
    <!-- /ko -->
    <!-- ko if: asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
      <div class="media-button icon-close" data-bind="click: on_cancel_button_clicked" data-uie-name="do-cancel-media">
        <div class='media-button-border-fill'></div>
        <svg class="svg-theme" data-bind="attr: {viewBox: svg_view_box}">
          <circle data-bind="style: {'stroke-dasharray': circle_upload_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
        </svg>
      </div>
    <!-- /ko -->
`,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.MediaButtonComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ChooseScreen = class ChooseScreen {
  constructor(params) {
    this.on_cancel = params.cancel;
    this.on_choose = params.choose;
    this.screens = params.screens || [];
  }
};

ko.components.register('choose-screen', {
  template: `
    <div class="choose-screen-list" data-bind="foreach: screens">
      <div  class="choose-screen-list-item" data-bind="click: $parent.on_choose">
        <image class="choose-screen-list-image" data-bind="attr: {src: $data.thumbnail.toDataURL()}">
      </div>
    </div>
    <div class="label-xs text-white" data-bind="l10n_text: z.string.callChooseSharedScreen"></div>
    <div id="choose-screen-controls" class="choose-screen-controls">
      <div class="choose-screen-controls-button button-round button-round-dark button-round-md icon-close"
           data-uie-name="do-choose-screen-cancel"
           data-bind="click: on_cancel"></div>
    </div>
  `,
  viewModel: z.components.ChooseScreen,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceToggleButton = class DeviceToggleButton {
  constructor(params) {
    this.availableDevices = params.devices;
    this.currentDeviceIndex = params.index;
    this.numberOfDevices = ko.pureComputed(() => {
      return _.isArray(this.availableDevices()) ? this.availableDevices().length : 0;
    });
  }
};

ko.components.register('device-toggle-button', {
  template: `
    <div class="device-toggle-button-indicator" data-bind="foreach: ko.utils.range(0, numberOfDevices() - 1)">
      <span class="device-toggle-button-indicator-dot" data-bind="css: {'device-toggle-button-indicator-dot-active': $data == $parent.currentDeviceIndex()}"></span>
    </div>
  `,
  viewModel: z.components.DeviceToggleButton,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ConversationListCallingCell = class ConversationListCallingCell {
  constructor(params) {
    this.conversation = params.conversation;

    const callingRepository = params.callingRepository;
    const permissionRepository = params.permissionRepository;

    this.multitasking = params.multitasking;
    this.temporaryUserStyle = params.temporaryUserStyle;
    this.videoGridRepository = params.videoGridRepository;

    this.calls = callingRepository.calls;
    this.call = this.conversation.call;
    this.conversationParticipants = this.conversation.participating_user_ets;
    this.joinedCall = callingRepository.joinedCall;
    this.selfStreamState = callingRepository.selfStreamState;
    this.selfUser = this.conversation.selfUser();

    this.isConnected = this.call().isConnected;

    this.isConnecting = this.call().isConnecting;
    this.isDeclined = this.call().isDeclined;
    this.isIncoming = this.call().isIncoming;
    this.isOngoing = this.call().isOngoing;
    this.isOutgoing = this.call().isOutgoing;

    this.showParticipants = ko.observable(false);

    this.callParticipants = ko.pureComputed(() => {
      const callParticipants = this.call().participants();
      return callParticipants.slice().reverse();
    });

    this.isVideoCall = ko.pureComputed(() => this.call().isLocalVideoCall() || this.call().isRemoteVideoCall());

    this.canJoin = ko.pureComputed(() => {
      if (this.selfUser.isTemporaryGuest()) {
        const isOngoingCall = !this.call().selfUserJoined() && this.isOngoing();
        return this.call().isDeclined() || isOngoingCall;
      }
      return false;
    });
    this.showParticipantsButton = ko.pureComputed(() => this.isConnected() && this.conversation.isGroup());
    this.showVideoButton = ko.pureComputed(() => this.isVideoCall() || this.isConnected());

    this.disableVideoButton = ko.pureComputed(() => {
      const isOutgoingVideoCall = this.isOutgoing() && this.selfStreamState.videoSend();
      const isVideoUnsupported = !this.selfStreamState.videoSend() && !this.conversation.supportsVideoCall();
      return isOutgoingVideoCall || isVideoUnsupported;
    });
    this.disableScreenButton = ko.pureComputed(() => !z.calling.CallingRepository.supportsScreenSharing);

    this.participantsButtonLabel = ko.pureComputed(() => {
      return z.l10n.text(z.string.callParticipants, this.callParticipants().length);
    });

    this.showVideoPreview = ko.pureComputed(() => {
      const hasOtherOngoingCalls = this.calls().some(callEntity => {
        return callEntity.id !== this.call().id && callEntity.isOngoing();
      });

      const isInMinimizedState = this.multitasking.isMinimized() || !this.isConnected();
      const hasPreJoinVideo = !this.isConnected() && this.call().selfState.videoSend();
      const isOngoingVideoCall = this.isConnected() && this.isVideoCall() && !this.isDeclined();

      return !hasOtherOngoingCalls && isInMinimizedState && (hasPreJoinVideo || isOngoingVideoCall);
    });

    this.showNoCameraPreview = ko.computed(() => {
      const isNotGranted = permissionRepository.permissionState.camera() !== z.notification.PermissionState.GRANTED;
      return this.call().isRemoteVideoCall() && !this.showVideoPreview() && !this.isConnected() && isNotGranted;
    });

    this.showMaximize = ko.pureComputed(() => this.multitasking.isMinimized() && this.isConnected());

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.callParticipants() && this.showParticipants())
      .extend({notify: 'always', rateLimit: 100});
  }

  onEndCall() {
    return this.isIncoming() ? this.onRejectCall() : this.onLeaveCall();
  }

  onJoinCall() {
    const isVideoCall = this.call().isRemoteVideoSend() && this.selfStreamState.videoSend();
    const mediaType = isVideoCall ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
    amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, mediaType);
  }

  onJoinDeclinedCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, z.media.MediaType.AUDIO);
  }

  onLeaveCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.conversation.id, z.calling.enum.TERMINATION_REASON.SELF_USER);
  }

  onMaximizeVideoGrid() {
    this.multitasking.autoMinimize(false);
    this.multitasking.isMinimized(false);
  }

  onParticipantsClick() {
    this.showParticipants(!this.showParticipants());

    // TODO: this is a very hacky way to get antiscroll to recalculate the height of the conversationlist.
    // Once there is a new solution to this, this needs to go.
    z.util.afterRender(() => window.dispatchEvent(new Event('resize')));
  }

  onRejectCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.REJECT, this.conversation.id);
  }

  onToggleAudio() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.conversation.id, z.media.MediaType.AUDIO);
  }

  onToggleScreen() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.CHOOSE_SCREEN, this.conversation.id);
  }

  onToggleVideo() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.conversation.id, z.media.MediaType.VIDEO);
  }
};

ko.components.register('conversation-list-calling-cell', {
  template: `
    <div class="conversation-list-calling-cell conversation-list-cell">

      <!-- ko ifnot: temporaryUserStyle -->
        <div class="conversation-list-cell-left">
          <!-- ko if: conversation.isGroup() -->
            <group-avatar class="conversation-list-cell-avatar-arrow call-ui__avatar" params="users: conversationParticipants(), conversation: conversation"></group-avatar>
          <!-- /ko -->
          <!-- ko if: !conversation.isGroup() && conversationParticipants().length -->
            <participant-avatar params="participant: conversationParticipants()[0], size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
          <!-- /ko -->
        </div>
      <!-- /ko -->

      <div class="conversation-list-cell-center" data-bind="css: {'conversation-list-cell-center-no-left': temporaryUserStyle}">
        <span class="conversation-list-cell-name" data-bind="text: conversation.display_name()"></span>
        <!-- ko if: isIncoming() -->
          <!-- ko if: call().isGroup -->
            <span class="conversation-list-cell-description" data-bind="l10n_text: {id: z.string.callStateIncomingGroup, substitute: call().creatingUser.first_name()}" data-uie-name="call-label-incoming"></span>
          <!-- /ko -->
          <!-- ko ifnot: call().isGroup -->
            <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateIncoming" data-uie-name="call-label-incoming"></span>
          <!-- /ko -->
        <!-- /ko -->
        <!-- ko if: isOutgoing() -->
          <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateOutgoing" data-uie-name="call-label-outgoing"></span>
        <!-- /ko -->
        <!-- ko if: isConnecting() -->
          <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateConnecting" data-uie-name="call-label-connecting"></span>
        <!-- /ko -->
        <!-- ko if: isConnected() -->
          <span class="conversation-list-cell-description" data-bind="text: z.util.TimeUtil.formatSeconds(call().durationTime())" data-uie-name="call-duration"></span>
        <!-- /ko -->
      </div>

      <div class="conversation-list-cell-right">
        <!-- ko if: isConnecting() || isConnected() -->
          <div class="call-ui__button call-ui__button--red" data-bind="click: onLeaveCall" data-uie-name="do-call-controls-call-leave">
            <hangup-icon class="small-icon"></hangup-icon>
          </div>
        <!-- /ko -->
        <!-- ko if: canJoin() -->
          <div class="call-ui__button call-ui__button--join call-ui__button--green" data-bind="click: onJoinDeclinedCall, l10n_text: z.string.callJoin" data-uie-name="do-call-controls-call-join"></div>
        <!-- /ko -->
      </div>

    </div>

    <!-- ko if: showVideoPreview() -->
      <div class="group-video__minimized-wrapper" data-bind="click: onMaximizeVideoGrid">
        <group-video-grid params="minimized: true, videoGridRepository: videoGridRepository"></group-video-grid>
        <!-- ko if: showMaximize() -->
          <div class="group-video__minimized-wrapper__overlay" data-uie-name="do-maximize-call">
            <fullscreen-icon></fullscreen-icon>
          </div>
        <!-- /ko -->
      </div>
    <!-- /ko -->
    <!-- ko if: showNoCameraPreview() -->
      <div class="group-video__minimized-wrapper group-video__minimized-wrapper--no-camera-access" data-bind="l10n_text: z.string.callNoCameraAccess" data-uie-name="label-no-camera-access-preview"></div>
    <!-- /ko -->

    <!-- ko ifnot: canJoin() -->
      <div class="conversation-list-calling-cell-controls">
        <div class="conversation-list-calling-cell-controls-left">
          <div class="call-ui__button" data-bind="click: onToggleAudio, css: {'call-ui__button--active': !selfStreamState.audioSend()}, attr: {'data-uie-value': selfStreamState.audioSend() ? 'inactive' : 'active'}" data-uie-name="do-toggle-mute">
            <micoff-icon class="small-icon"></micoff-icon>
          </div>
          <!-- ko if: showVideoButton() -->
            <div class="call-ui__button" data-bind="click: onToggleVideo, css: {'call-ui__button--active': selfStreamState.videoSend(), 'call-ui__button--disabled': disableVideoButton()}, attr: {'data-uie-value': selfStreamState.videoSend() ? 'active' : 'inactive'}" data-uie-name="do-toggle-video">
              <camera-icon class="small-icon"></camera-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isConnected() -->
            <div class="call-ui__button" data-bind="tooltip: {text: z.string.videoCallScreenShareNotSupported, disabled: !disableScreenButton(), position: 'bottom'}, click: onToggleScreen, css: {'call-ui__button--active': selfStreamState.screenSend(), 'call-ui__button--disabled': disableScreenButton()}, attr: {'data-uie-value': selfStreamState.screenSend() ? 'active' : 'inactive', 'data-uie-enabled': disableScreenButton() ? 'false' : 'true'}" data-uie-name="do-call-controls-toggle-screenshare">
              <screenshare-icon class="small-icon"></screenshare-icon>
            </div>
          <!-- /ko -->
        </div>

        <div class="conversation-list-calling-cell-controls-right">
          <!-- ko if: showParticipantsButton() -->
            <div class="call-ui__button call-ui__button--participants" data-bind="click: onParticipantsClick, css: {'call-ui__button--active': showParticipants()}" data-uie-name="do-toggle-participants">
              <span data-bind="text: participantsButtonLabel"></span><chevron-icon></chevron-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isIncoming() || isOutgoing() -->
            <div class="call-ui__button call-ui__button--red call-ui__button--large" data-bind="click: onEndCall" data-uie-name="do-call-controls-call-decline">
              <hangup-icon class="small-icon"></hangup-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isIncoming() -->
            <div class="call-ui__button call-ui__button--green call-ui__button--large" data-bind="click: onJoinCall" data-uie-name="do-call-controls-call-accept">
              <pickup-icon class="small-icon"></pickup-icon>
            </div>
          <!-- /ko -->
        </div>

      </div>
      <div class="call-ui__participant-list__wrapper" data-bind="css: {'call-ui__participant-list__wrapper--active': showParticipants}">
        <div class="call-ui__participant-list" data-bind="foreach: callParticipants, antiscroll: shouldUpdateScrollbar" data-uie-name="list-call-ui-participants">
          <participant-item params="participant: $data.user, hideInfo: true, showCamera: $data.activeState.videoSend()" data-bind="css: {'no-underline': true}"></participant-item>
        </div>
      </div>
    <!-- /ko -->
 `,
  viewModel: z.components.ConversationListCallingCell,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ConversationListCell = class ConversationListCell {
  constructor({conversation, is_selected = z.util.noop, click = z.util.noop}) {
    this.conversation = conversation;
    this.is_selected = is_selected;
    this.on_click = click;

    this.users = ko.pureComputed(() => this.conversation.participating_user_ets());

    this.cell_state = ko.observable('');
    this.cell_state_observable = ko
      .computed(() => this.cell_state(z.conversation.ConversationCellState.generate(this.conversation)))
      .extend({rateLimit: 500});

    this.showJoinButton = this.conversation.hasJoinableCall;

    this.onJoinCall = () => {
      amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, z.media.MediaType.AUDIO);
    };
  }

  destroy() {
    this.cell_state_observable.dispose();
  }
};

ko.components.register('conversation-list-cell', {
  template: `
    <div class="conversation-list-cell" data-bind="attr: {'data-uie-uid': conversation.id, 'data-uie-value': conversation.display_name}, css: {'conversation-list-cell-active': is_selected(conversation)}">
      <div class="conversation-list-cell-left" data-bind="css: {'conversation-list-cell-left-opaque': conversation.removed_from_conversation() || conversation.participating_user_ids().length === 0}">
        <!-- ko if: conversation.isGroup() -->
          <group-avatar class="conversation-list-cell-avatar-arrow" params="users: users(), conversation: conversation"></group-avatar>
        <!-- /ko -->
        <!-- ko if: !conversation.isGroup() && users().length -->
          <div class="avatar-halo">
            <participant-avatar params="participant: users()[0], size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
          </div>
        <!-- /ko -->
      </div>
      <div class="conversation-list-cell-center">
        <!-- ko if: conversation.is1to1() && conversation.selfUser().inTeam() -->
          <availability-state class="conversation-list-cell-availability"
                              data-uie-name="status-availability-item"
                              params="availability: conversation.availabilityOfUser, label: conversation.display_name(), theme: is_selected(conversation)">
          </availability-state>
        <!-- /ko -->
        <!-- ko ifnot: conversation.is1to1() && conversation.selfUser().inTeam() -->
          <span class="conversation-list-cell-name" data-bind="text: conversation.display_name(), css: {'text-theme': is_selected(conversation)}"></span>
        <!-- /ko -->
        <span class="conversation-list-cell-description" data-bind="text: cell_state().description" data-uie-name="secondary-line"></span>
      </div>
      <div class="conversation-list-cell-right">
        <span class="conversation-list-cell-context-menu" data-bind="click: function(data, event) {on_click(conversation, event)}" data-uie-name="go-options"></span>
        <!-- ko ifnot: showJoinButton -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.PENDING_CONNECTION -->
            <span class="conversation-list-cell-badge cell-badge-dark" data-uie-name="status-pending"><pending-icon class="svg-icon"></pending-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_MENTION -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-mention"><mention-icon class="svg-icon"></mention-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_REPLY -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-reply"><reply-icon class="svg-icon"></reply-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_PING -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-ping"><ping-icon class="svg-icon"></ping-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.MISSED_CALL -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-missed-call"><hangup-icon class="svg-icon"></hangup-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.MUTED -->
            <span class="conversation-list-cell-badge cell-badge-dark conversation-muted" data-uie-name="status-silence"><mute-icon class="svg-icon"></mute-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_MESSAGES && conversation.unreadState().allMessages.length > 0 -->
            <span class="conversation-list-cell-badge cell-badge-light" data-bind="text: conversation.unreadState().allMessages.length" data-uie-name="status-unread"></span>
          <!-- /ko -->
        <!-- /ko -->
        <!-- ko if: showJoinButton -->
          <div class="call-ui__button call-ui__button--green call-ui__button--join" data-bind="click: onJoinCall, l10n_text: z.string.callJoin" data-uie-name="do-call-controls-call-join"></div>
        <!-- /ko -->
      </div>
    </div>
  `,
  viewModel: z.components.ConversationListCell,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupAvatar = class GroupAvatar {
  constructor({users}) {
    this.users = ko.pureComputed(() => users().slice(0, 4));
  }
};

ko.components.register('group-avatar', {
  template: `
    <div class="group-avatar-box-wrapper" data-bind="foreach: users">
      <div class="group-avatar-box" data-bind="text: Array.from($data.initials())[0], style: {color: $data.accent_color()}"></div>
    </div>
  `,
  viewModel: z.components.GroupAvatar,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('panel-user-details', {
  template: `
    <div class="panel-participant">

      <!-- ko if: isVerified() -->
        <verified-icon class="panel-participant__verified-icon" data-uie-name="status-verified-participant"></verified-icon>
      <!-- /ko -->

      <div class="panel-participant__name" data-bind="text: participant().name()" data-uie-name="status-name"></div>


      <!-- ko if: participant().username() -->
        <div class="panel-participant__user-name" data-bind="text: participant().username()" data-uie-name="status-username"></div>
      <!-- /ko -->

      <participant-avatar params="participant: participant, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>
      
      <!-- ko if: participant().isGuest() -->
        <div class="panel-participant__guest-label" data-uie-name="status-guest">
          <guest-icon></guest-icon>
          <span data-bind="l10n_text: z.string.conversationGuestIndicator"></span>
        </div>
      <!-- /ko -->
          
      <!-- ko if: participant().isTemporaryGuest () -->
        <div class="panel-participant__guest-expiration" data-bind="text: participant().expirationText" data-uie-name="status-expiration-text"></div>
      <!-- /ko -->
      
      <!-- ko if: participant().inTeam() -->
        <availability-state
          class="panel-participant__availability"
          data-uie-name="status-availability"
          params="availability: participant().availability(), label: availabilityLabel()">
        </availability-state>
      <!-- /ko -->
    </div>
  `,
  viewModel: class {
    constructor(params) {
      this.participant = params.participant;
      this.isVerified = params.hasOwnProperty('isVerified') ? params.isVerified : this.participant().is_verified;
      this.availabilityLabel = ko.pureComputed(() => {
        const availabilitySetToNone = this.participant().availability() === z.user.AvailabilityType.NONE;
        if (!availabilitySetToNone) {
          return z.user.AvailabilityMapper.nameFromType(this.participant().availability());
        }
      });
    }
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('panel-service-details', {
  template: `
    <div class="panel-participant">
      <div class="panel-participant__name" data-bind="text: service().name" data-uie-name="status-service-name"></div>
      <div class="panel-participant__provider-name" data-bind="text: service().providerName()" data-uie-name="status-service-provider"></div>
      <participant-avatar params="participant: service, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>    
      <div class="panel-participant__service-description" data-bind="text: service().description" data-uie-name="status-service-description"></div>
    </div>
  `,
  viewModel: class {
    constructor(params) {
      this.service = params.service;
    }
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different call message types.
 * @returns {z.message.CALL_MESSAGE_TYPE} Enum of call message types
 */
z.message.CALL_MESSAGE_TYPE = {
  ACTIVATED: 'activated',
  DEACTIVATED: 'deactivated',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different message categories.
 * @returns {z.message.MessageCategory} Enum of message categories
 */
z.message.MessageCategory = {
  AUDIO: 1 << 10,
  EXCLUDED: 1 << 1,
  FILE: 1 << 9,
  GIF: 1 << 8,
  IMAGE: 1 << 7,
  KNOCK: 1 << 2,
  LIKED: 1 << 13,
  LINK: 1 << 5,
  LINK_PREVIEW: 1 << 6,
  LOCATION: 1 << 12,
  NONE: 0,
  SYSTEM: 1 << 3,
  TEXT: 1 << 4,
  UNDEFINED: 1 << 0,
  VIDEO: 1 << 11,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MessageCategorization = (() => {
  const _checkAsset = event => {
    const {data: eventData, type: eventType} = event;

    const isAssetAdd = eventType === z.event.Client.CONVERSATION.ASSET_ADD;
    if (isAssetAdd) {
      const isTagUndefined = eventData.info.tag === undefined;
      if (isTagUndefined) {
        return z.message.MessageCategory.FILE;
      }

      let category = z.message.MessageCategory.IMAGE;
      if (eventData.content_type === 'image/gif') {
        category = category | z.message.MessageCategory.GIF;
      }

      return category;
    }
  };

  const _checkLocation = event => {
    const isLocation = event.type === z.event.Client.CONVERSATION.LOCATION;
    if (isLocation) {
      return z.message.MessageCategory.LOCATION;
    }
  };

  const _checkPing = event => {
    const isPing = event.type === z.event.Client.CONVERSATION.KNOCK;
    if (isPing) {
      return z.message.MessageCategory.KNOCK;
    }
  };

  const _checkText = event => {
    const {data: eventData, type: eventType} = event;

    const isMessageAdd = eventType === z.event.Client.CONVERSATION.MESSAGE_ADD;
    if (isMessageAdd) {
      let category = z.message.MessageCategory.TEXT;

      const isLinkPreview = eventData.previews && !!eventData.previews.length;
      if (isLinkPreview) {
        category = category | z.message.MessageCategory.LINK | z.message.MessageCategory.LINK_PREVIEW;
      }

      return category;
    }
  };

  return {
    categoryFromEvent: event => {
      try {
        const eventReactions = event.reactions;
        let category = z.message.MessageCategory.NONE;

        const categoryChecks = [_checkText, _checkAsset, _checkPing, _checkLocation];
        for (const check of categoryChecks) {
          const matchedCategory = check(event);
          if (matchedCategory) {
            category = matchedCategory;
            break;
          }
        }

        const isReaction = _.isObject(eventReactions) && !!Object.keys(eventReactions).length;
        if (isReaction) {
          category = category | z.message.MessageCategory.LIKED;
        }

        return category;
      } catch (error) {
        return z.message.MessageCategory.UNDEFINED;
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

const Long = window.dcodeIO.Long;
const crypto = window.crypto;

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MessageHasher = (() => {
  /**
   * @param {number[]} bytes - The array of bytes to hash
   * @returns {Promise<ArrayBuffer>} Promise with hashed string bytes
   * @private
   */
  const createSha256Hash = bytes => {
    const buffer = new Uint8Array(bytes).buffer;
    return crypto.subtle.digest('SHA-256', buffer);
  };

  /**
   * @param {Event} event - The event
   * @returns {number[]} Array of assetId bytes
   * @private
   */
  const getAssetBytes = event => z.util.StringUtil.utf8ToUtf16BE(event.data.key);

  /**
   * @param {Event} event - The event
   * @returns {number[]} Array of longitude bytes
   * @private
   */
  const getLocationBytes = event => {
    const {longitude, latitude} = event.data.location;
    const latitudeApproximate = Math.round(latitude * 1000);
    const longitudeApproximate = Math.round(longitude * 1000);

    const latitudeLong = Long.fromInt(latitudeApproximate).toBytesBE();
    const longitudeLong = Long.fromInt(longitudeApproximate).toBytesBE();

    return latitudeLong.concat(longitudeLong);
  };

  /**
   * @param {Event} event - The event
   * @returns {number[]} the timestamp as long endian bytes
   * @private
   */
  const getTimestampBytes = event => {
    const unixTimestamp = new Date(event.time).getTime();
    const timestampSeconds = Math.floor(unixTimestamp / 1e3);
    return Long.fromInt(timestampSeconds).toBytesBE();
  };

  const getTextBytes = event => z.util.StringUtil.utf8ToUtf16BE(event.data.content);

  /**
   * Creates a hash of the given event.
   *
   * @param {Event} event - the event to hash
   * @returns {ArrayBuffer} hashBuffer - buffer containing the bytes of the hash
   */
  const hashEvent = event => {
    const EventTypes = z.event.Client.CONVERSATION;
    const specificBytesGenerators = {
      [EventTypes.MESSAGE_ADD]: getTextBytes,
      [EventTypes.LOCATION]: getLocationBytes,
      [EventTypes.ASSET_ADD]: getAssetBytes,
    };

    const generator = specificBytesGenerators[event.type];
    if (!generator) {
      throw new Error(`Cannot generate hash for event of type "${event.type}"`);
    }

    const specificBytes = generator(event);
    const timeBytes = getTimestampBytes(event);
    const allBytes = specificBytes.concat(timeBytes);

    return createSha256Hash(allBytes);
  };

  /**
   * Validates that the quoteHash correspond to the given event.
   *
   * @param {Event} event - The event to match against the hash
   * @param {ArrayBuffer} hash - The hash
   * @returns {boolean} isValid - true if the event hash is equal to the given hash
   */
  const validateHash = (event, hash) => {
    return hashEvent(event).then(generatedHash => {
      if (hash.byteLength !== generatedHash.byteLength) {
        return false;
      }
      const generatedHashBytes = new Uint8Array(generatedHash);
      const hashBytes = new Uint8Array(hash);
      for (let i = 0; i !== generatedHash.byteLength; i++) {
        if (generatedHashBytes[i] !== hashBytes[i]) {
          return false;
        }
      }
      return true;
    });
  };

  return {
    hashEvent,
    validateHash,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum of different ephemeral status types.
 * @type {z.message.EphemeralStatusType} Enum of ephemeral status types
 */
z.message.EphemeralStatusType = {
  ACTIVE: 1,
  INACTIVE: 2,
  NONE: 0,
  TIMED_OUT: 3,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MentionEntity = class MentionEntity {
  static get ERROR() {
    return {
      INVALID_LENGTH: 'Invalid mention: Invalid length',
      INVALID_START_CHAR: 'Invalid mention: Mention does not start with @',
      INVALID_START_INDEX: 'Invalid mention: Invalid startIndex',
      INVALID_USER_ID: 'Invalid mention: User ID is not a valid UUID',
      MISSING_LENGTH: 'Invalid mention: Missing length',
      MISSING_START_INDEX: 'Invalid mention: Missing startIndex',
      MISSING_USER_ID: 'Invalid mention: Missing user ID',
      OUT_OF_BOUNDS: 'Invalid mention: Length out of string boundary',
    };
  }

  constructor(startIndex, length, userId) {
    this.startIndex = startIndex;
    this.length = length;
    this.type = z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;

    this.userId = userId;
  }

  targetsUser(userId) {
    const isTypeUserId = this.type === z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;
    return isTypeUserId && this.userId === userId;
  }

  // Index of first char outside of mention
  get endIndex() {
    return this.startIndex + this.length;
  }

  validate(messageText = '') {
    const startIndexIsNumber = typeof this.startIndex === 'number';
    if (!startIndexIsNumber) {
      throw new Error(MentionEntity.ERROR.MISSING_START_INDEX);
    }

    const lengthIsNumber = typeof this.length === 'number';
    if (!lengthIsNumber) {
      throw new Error(MentionEntity.ERROR.MISSING_LENGTH);
    }

    const userIdIsString = typeof this.userId === 'string';
    if (!userIdIsString) {
      throw new Error(MentionEntity.ERROR.MISSING_USER_ID);
    }

    const isValidStartIndex = this.startIndex >= 0;
    if (!isValidStartIndex) {
      throw new Error(MentionEntity.ERROR.INVALID_START_INDEX);
    }

    const isValidLength = this.length >= 1;
    if (!isValidLength) {
      throw new Error(MentionEntity.ERROR.INVALID_LENGTH);
    }

    const isValidEnd = messageText.length && this.endIndex <= messageText.length;
    if (!isValidEnd) {
      throw new Error(MentionEntity.ERROR.OUT_OF_BOUNDS);
    }

    const isValidUserId = z.util.ValidationUtil.isUUID(this.userId);
    if (!isValidUserId) {
      throw new Error(MentionEntity.ERROR.INVALID_USER_ID);
    }

    const isValidMention = messageText.substr(this.startIndex, 1) === '@';
    if (!isValidMention) {
      throw new Error(MentionEntity.ERROR.INVALID_START_CHAR);
    }

    return true;
  }

  toJSON() {
    return {
      length: this.length,
      startIndex: this.startIndex,
      userId: this.userId,
    };
  }

  toProto() {
    const protoMention = new z.proto.Mention(this.startIndex, this.length);
    const isUserIdMention = this.type === z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;
    if (isUserIdMention) {
      protoMention.set(z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID, this.userId);
    }
    return protoMention;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.QuoteEntity = class QuoteEntity {
  static get ERROR() {
    return {
      INVALID_HASH: 'INVALID_HASH',
      MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',
    };
  }

  constructor({error, hash, messageId, userId}) {
    this.messageId = messageId;
    this.hash = hash;
    this.userId = userId;
    this.error = error;
  }

  isQuoteFromUser(userId) {
    return this.userId === userId;
  }

  toJSON() {
    return {
      messageId: this.messageId,
      userId: this.userId,
    };
  }

  toProto() {
    return new z.proto.Quote(this.messageId, new Uint8Array(this.hash));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different confirmation types.
 * @type {z.message.StatusType} Enum of status types
 */
z.message.StatusType = {
  DELIVERED: 3,
  FAILED: 0,
  SEEN: 4,
  SENDING: 1,
  SENT: 2,
  UNSPECIFIED: -1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different reactions.
 * @returns {z.message.ReactionType} Enum of reactions
 */
z.message.ReactionType = {
  LIKE: '',
  NONE: '',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different message super types.
 * @type {z.message.SuperType} Enum of super types
 */
z.message.SuperType = {
  CALL: 'call',
  CONTENT: 'normal',
  DELETE: 'delete',
  DEVICE: 'device',
  LOCATION: 'location',
  MEMBER: 'member',
  MISSED: 'missed',
  PING: 'ping',
  REACTION: 'reaction',
  SPECIAL: 'special',
  SYSTEM: 'system',
  UNABLE_TO_DECRYPT: 'unable-to-decrypt',
  VERIFICATION: 'verification',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different system message types.
 * @todo Refactor to use member-join and member-leave instead of normal. It duplicates "z.message.SuperType".
 * @type {z.message.SystemMessageType} Enum of system message types
 */
z.message.SystemMessageType = {
  CONNECTION_ACCEPTED: 'created-one-to-one',
  CONNECTION_CONNECTED: 'connected',
  CONNECTION_REQUEST: 'connecting',
  CONVERSATION_CREATE: 'created-group',
  CONVERSATION_MESSAGE_TIMER_UPDATE: 'message-timer-update',
  CONVERSATION_RENAME: 'rename',
  CONVERSATION_RESUME: 'resume',
  MEMBER_JOIN: 'join',
  MEMBER_LEAVE: 'leave',
  NORMAL: 'normal',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different verification message types.
 * @type {z.message.VerificationMessageType} Enum of verification message types
 */
z.message.VerificationMessageType = {
  NEW_DEVICE: 'new-device',
  NEW_MEMBER: 'new-member',
  UNVERIFIED: 'unverified',
  VERIFIED: 'verified',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Asset = class Asset {
  constructor(id) {
    this.id = id;
    this.key = '';
    this.type = '';
  }

  /**
   * Check if asset is a medium image.
   * @returns {boolean} Is asset of type medium image
   */
  is_image() {
    return this.type === z.assets.AssetType.IMAGE;
  }

  /**
   * Check if asset is a text.
   * @returns {boolean} Is asset of type text
   */
  is_text() {
    return this.type === z.assets.AssetType.TEXT;
  }

  /**
   * Check if asset is a file.
   * @returns {boolean} Is asset of type file
   */
  is_file() {
    return this.type === z.assets.AssetType.FILE && !this.is_video() && !this.is_audio();
  }

  /**
   * Check if asset is a location.
   * @returns {boolean} Is asset of type location
   */
  is_location() {
    return this.type === z.assets.AssetType.LOCATION;
  }

  /**
   * Check if asset is a video.
   * @returns {boolean} Is asset of type video
   */
  is_video() {
    const is_video_asset =
      this.type === z.assets.AssetType.FILE && this.file_type && this.file_type.startsWith('video');
    if (is_video_asset) {
      const can_play = document.createElement('video').canPlayType(this.file_type);
      if (can_play !== '') {
        return true;
      }
    }
    return false;
  }

  /**
   * Check if asset is a audio.
   * @returns {boolean} Is asset of type audio
   */
  is_audio() {
    const is_audio_asset =
      this.type === z.assets.AssetType.FILE && this.file_type && this.file_type.startsWith('audio');
    if (is_audio_asset) {
      const can_play = document.createElement('audio').canPlayType(this.file_type);
      if (can_play !== '') {
        return true;
      }
    }
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Text = class Text extends z.entity.Asset {
  constructor(id, text = '') {
    super(id);
    this.type = z.assets.AssetType.TEXT;

    // Raw message text
    this.text = text;

    // Can be used to theme media embeds
    this.theme_color = undefined;

    // Array of z.message.MentionEntity instances
    this.mentions = ko.observableArray();

    // Array of z.entity.LinkPreview instances
    this.previews = ko.observableArray();

    this.should_render_text = ko.pureComputed(() => {
      if (this.text === null || this.text.length === 0) {
        return false;
      }
      const has_link_previews = this.previews().length > 0;
      return !has_link_previews || (has_link_previews && !z.links.LinkPreviewHelpers.containsOnlyLink(this.text));
    });
  }

  // Process text before rendering it
  render(selfId) {
    const message = z.util.renderMessage(this.text, selfId, this.mentions());
    return !this.previews().length ? z.media.MediaParser.renderMediaEmbeds(message, this.theme_color) : message;
  }

  isUserMentioned(userId) {
    return this.mentions().some(mentionEntity => mentionEntity.targetsUser(userId));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.LinkPreview = class LinkPreview {
  constructor(title, url) {
    this.title = title || '';
    this.url = url || '';

    this.image_resource = ko.observable();
    this.meta_data = undefined;
    this.meta_data_type = undefined;
  }

  obfuscate() {
    this.title = z.util.StringUtil.obfuscate(this.title);
    this.url = z.util.StringUtil.obfuscate(this.url);

    this.image_resource(undefined);
    this.meta_data = undefined;
    this.meta_data_type = undefined;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.File = class File extends z.entity.Asset {
  constructor(id) {
    super(id);
    this.cancel_download = this.cancel_download.bind(this);

    this.type = z.assets.AssetType.FILE;
    this.logger = new z.util.Logger('z.entity.File', z.config.LOGGER.OPTIONS);

    // z.assets.AssetTransferState
    this.status = ko.observable();

    this.file_name = '';
    this.file_size = '';
    this.file_type = '';

    // contains asset meta data as object
    this.meta = {};

    // asset url, instance of an otr asset this has to be decrypted
    this.original_resource = ko.observable();
    this.preview_resource = ko.observable();

    this.download = this.download.bind(this);
    this.downloadProgress = ko.pureComputed(() => {
      if (this.original_resource()) {
        return this.original_resource().downloadProgress();
      }

      return undefined;
    });

    this.upload_id = ko.observable();
    this.upload_progress = ko.observable();
    this.uploaded_on_this_client = ko.observable(false);
    this.upload_failed_reason = ko.observable();
    this.upload_cancel = undefined;
    this.pending_upload = ko.pureComputed(() => {
      return this.status() === z.assets.AssetTransferState.UPLOADING && this.uploaded_on_this_client();
    });

    // update progress
    this.upload_id.subscribe(upload_id => {
      if (upload_id) {
        return amplify.subscribe(`upload${upload_id}`, this.on_progress);
      }
    });

    this.status.subscribe(status => {
      if (status === z.assets.AssetTransferState.UPLOADED) {
        return amplify.unsubscribe(`upload${this.upload_id}`, this.on_progress);
      }
    });
  }

  on_progress(progress) {
    return this.upload_progress(progress);
  }

  /**
   * Loads and decrypts otr asset preview
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  load_preview() {
    return this.preview_resource().load();
  }

  /**
   * Loads and decrypts otr asset
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  load() {
    this.status(z.assets.AssetTransferState.DOWNLOADING);

    return this.original_resource()
      .load()
      .then(blob => {
        this.status(z.assets.AssetTransferState.UPLOADED);
        return blob;
      })
      .catch(error => {
        this.status(z.assets.AssetTransferState.UPLOADED);
        throw error;
      });
  }

  /**
   * Loads and decrypts otr asset as initiates download
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  download() {
    if (this.status() !== z.assets.AssetTransferState.UPLOADED) {
      return Promise.resolve(undefined);
    }

    const download_started = Date.now();

    return this.load()
      .then(blob => z.util.downloadBlob(blob, this.file_name))
      .then(() => {
        const download_duration = (Date.now() - download_started) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        this.logger.info(`Downloaded asset in ${download_duration} seconds`);
      })
      .catch(error => this.logger.error('Failed to download asset', error));
  }

  cancel_download() {
    this.status(z.assets.AssetTransferState.UPLOADED);
    return this.original_resource().cancelDownload();
  }

  cancel(message_et) {
    if (typeof this.upload_cancel === 'function') {
      this.upload_cancel();
    }
    amplify.publish(z.event.WebApp.CONVERSATION.ASSET.CANCEL, message_et);
  }

  reload() {
    this.logger.info('Restart upload');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Location = class Location extends z.entity.Asset {
  constructor() {
    super();

    this.latitude = '';
    this.longitude = '';
    this.name = '';
    this.type = z.assets.AssetType.LOCATION;
    this.zoom = '';
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MediumImage = class MediumImage extends z.entity.Asset {
  constructor(id) {
    super(id);

    this.correlation_id = '';
    this.type = z.assets.AssetType.IMAGE;

    this.width = '0px';
    this.height = '0px';

    this.file_name = '';
    this.file_size = '';
    this.file_type = '';

    // z.assets.AssetRemoteData
    this.resource = ko.observable();
  }

  /**
   * Loads and decrypts otr asset as initiates download
   * @param {string} filename - Filename
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  download(filename) {
    return this.resource()
      .load()
      .then(blob => z.util.downloadBlob(blob, filename))
      .catch(error => this.logger.error('Failed to download image', error));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Message = class Message {
  /**
   * Sort messages by timestamp
   * @param {Array<z.entity.Message>} message_ets - Message entities
   * @returns {boolean} Sorted message entities
   */
  static sort_by_timestamp(message_ets) {
    return message_ets.sort((m1, m2) => m1.timestamp() > m2.timestamp());
  }

  constructor(id = '0', super_type = '') {
    this.equals = this.equals.bind(this);
    this.is_expired = this.is_expired.bind(this);
    this.startMessageTimer = this.startMessageTimer.bind(this);
    this.id = id;
    this.super_type = super_type;
    this.ephemeral_caption = ko.pureComputed(() => {
      const remainingTime = this.ephemeral_remaining();
      return remainingTime ? z.util.TimeUtil.formatDurationCaption(remainingTime) : '';
    });
    this.ephemeral_duration = ko.observable(0);
    this.ephemeral_remaining = ko.observable(0);
    this.ephemeral_expires = ko.observable(false);
    this.ephemeral_started = ko.observable('0');
    this.ephemeral_status = ko.computed(() => {
      const isExpired = this.ephemeral_expires() === true;
      if (isExpired) {
        return z.message.EphemeralStatusType.TIMED_OUT;
      }

      if (_.isNumber(this.ephemeral_expires())) {
        return z.message.EphemeralStatusType.INACTIVE;
      }

      if (_.isString(this.ephemeral_expires())) {
        const isExpiring = Date.now() >= this.ephemeral_expires();
        return isExpiring ? z.message.EphemeralStatusType.TIMED_OUT : z.message.EphemeralStatusType.ACTIVE;
      }

      return z.message.EphemeralStatusType.NONE;
    });

    this.isObfuscated = ko.pureComputed(() => {
      const messageIsAtLeastSent = this.status() > z.message.StatusType.SENDING;
      const isEphemeralInactive = this.ephemeral_status() === z.message.EphemeralStatusType.INACTIVE;
      return messageIsAtLeastSent && (isEphemeralInactive || this.is_expired());
    });

    this.conversation_id = '';
    this.from = '';
    this.primary_key = undefined;
    this.status = ko.observable(z.message.StatusType.UNSPECIFIED);
    this.type = '';
    this.user = ko.observable(new z.entity.User());
    this.visible = ko.observable(true);
    this.version = 1;

    this.affect_order = ko.observable(true);
    this.timestamp = ko.observable(Date.now());
    this.timestamp_affects_order = ko.pureComputed(() => this.visible() && this.affect_order());

    // z.message.MessageCategory
    this.category = undefined;

    this.display_timestamp_short = () => {
      const date = moment.unix(this.timestamp() / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      return date.local().format('HH:mm');
    };

    this.unsafeSenderName = ko.pureComputed(() => z.util.SanitizationUtil.getFirstName(this.user(), undefined, true));
    this.headerSenderName = ko.pureComputed(() => {
      return this.user().isService ? this.user().name() : this.user().first_name();
    });

    this.accent_color = ko.pureComputed(() => `accent-color-${this.user().accent_id()}`);
  }

  equals(messageEntity) {
    return messageEntity && this.id ? this.id === messageEntity.id : false;
  }

  /**
   * Check if message contains an asset of type file.
   * @returns {boolean} Message contains any file type asset
   */
  has_asset() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.type === z.assets.AssetType.FILE) : false;
  }

  /**
   * Check if message contains a file asset.
   * @returns {boolean} Message contains a file
   */
  has_asset_file() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_file()) : false;
  }

  /**
   * Check if message contains any image asset.
   * @returns {boolean} Message contains any image
   */
  has_asset_image() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_image()) : false;
  }

  /**
   * Check if message contains a location asset.
   * @returns {boolean} Message contains a location
   */
  has_asset_location() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_location()) : false;
  }

  /**
   * Check if message contains a text asset.
   * @returns {boolean} Message contains text
   */
  has_asset_text() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_text()) : false;
  }

  /**
   * Check if message is a call message.
   * @returns {boolean} Is message of type call
   */
  is_call() {
    return this.super_type === z.message.SuperType.CALL;
  }

  /**
   * Check if message is a content message.
   * @returns {boolean} Is message of type content
   */
  is_content() {
    return this.super_type === z.message.SuperType.CONTENT;
  }

  /**
   * Check if message can be deleted.
   * @returns {boolean} True, if message is deletable.
   */
  is_deletable() {
    return this.status() !== z.message.StatusType.SENDING;
  }

  /**
   * Check if the message content can be downloaded.
   * @returns {boolean} True, if the message has downloadable content.
   */
  is_downloadable() {
    const isExpiredEphemeral = this.ephemeral_status() === z.message.EphemeralStatusType.TIMED_OUT;
    if (isExpiredEphemeral) {
      return false;
    }

    if (this.hasUnavailableAsset()) {
      return false;
    }

    if (this.is_content()) {
      const assetEntity = this.get_first_asset();

      if (assetEntity && typeof assetEntity.download === 'function') {
        return true;
      }
    }
    return false;
  }

  isEdited() {
    return this.is_content() && this.was_edited();
  }

  isLinkPreview() {
    return (
      this.has_asset_text() && this.assets().some(assetEntity => assetEntity.is_text() && assetEntity.previews().length)
    );
  }

  /**
   * Check if message is a member message.
   * @returns {boolean} Is message of type member
   */
  is_member() {
    return this.super_type === z.message.SuperType.MEMBER;
  }

  /**
   * Check if message is a ping message.
   * @returns {boolean} Is message of type ping
   */
  is_ping() {
    return this.super_type === z.message.SuperType.PING;
  }

  /**
   * Check if message is a system message.
   * @returns {boolean} Is message of type system
   */
  is_system() {
    return this.super_type === z.message.SuperType.SYSTEM;
  }

  /**
   * Check if message is a e2ee message.
   * @returns {boolean} Is message of type system
   */
  is_unable_to_decrypt() {
    return this.super_type === z.message.SuperType.UNABLE_TO_DECRYPT;
  }

  /**
   * Check if message is a e2ee message.
   * @returns {boolean} Is message of type system
   */
  is_verification() {
    return this.super_type === z.message.SuperType.VERIFICATION;
  }

  /**
   * Check if message can be copied.
   * @returns {boolean} True, if message can be copied.
   */

  isCopyable() {
    return this.has_asset_text();
  }

  /**
   * Check if message can be edited.
   * @returns {boolean} True, if message can be edited.
   */
  is_editable() {
    return this.has_asset_text() && this.user().is_me && !this.is_ephemeral();
  }

  /**
   * Check if message is ephemeral.
   * @returns {boolean} True, if message is ephemeral.
   */
  is_ephemeral() {
    return this.ephemeral_expires() !== false;
  }

  /**
   * Check if ephemeral message is expired.
   * @returns {boolean} True, if message expired.
   */
  is_expired() {
    return this.ephemeral_expires() === true;
  }

  /**
   * Check if message has an unavailable (uploading or failed) asset.
   * @returns {boolean} True, if an asset is unavailable.
   */
  hasUnavailableAsset() {
    if (this.has_asset()) {
      return this.assets().some(asset => {
        const assetStatus = asset.status();
        return (
          assetStatus === z.assets.AssetTransferState.UPLOADING ||
          assetStatus === z.assets.AssetTransferState.UPLOAD_FAILED
        );
      });
    }
    return false;
  }

  /**
   * Check if message can be reacted to.
   * @returns {boolean} True, if message type supports reactions.
   */
  isReactable() {
    return (
      this.is_content() &&
      !this.is_ephemeral() &&
      this.status() !== z.message.StatusType.SENDING &&
      !this.hasUnavailableAsset()
    );
  }

  /**
   * Check if message can be replied to.
   * @returns {boolean} True, if message type supports replies.
   */
  isReplyable() {
    return (
      this.is_content() &&
      !this.is_ephemeral() &&
      this.status() !== z.message.StatusType.SENDING &&
      !this.hasUnavailableAsset()
    );
  }

  // Start the ephemeral timer for the message.
  startMessageTimer(timeOffset) {
    if (this.messageTimerStarted) {
      return;
    }

    if (this.ephemeral_status() === z.message.EphemeralStatusType.INACTIVE) {
      const startingTimestamp = this.user().is_me ? Math.min(this.timestamp() + timeOffset, Date.now()) : Date.now();
      const expirationTimestamp = `${startingTimestamp + this.ephemeral_expires()}`;
      this.ephemeral_expires(expirationTimestamp);
      this.ephemeral_started(`${startingTimestamp}`);
    }

    const remainingTime = this.ephemeral_expires() - this.ephemeral_started();
    this.ephemeral_remaining(remainingTime);
    this.messageTimerStarted = true;
  }

  /**
   * Update the status of a message.
   * @param {z.message.StatusType} updated_status - New status of message
   * @returns {z.message.StatusType|boolean} Returns the new status on a successful update, otherwise "false"
   */
  update_status(updated_status) {
    if (this.status() >= z.message.StatusType.SENT) {
      if (updated_status > this.status()) {
        return this.status(updated_status);
      }
    } else if (this.status() !== updated_status) {
      return this.status(updated_status);
    }
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.DeleteMessage = class DeleteMessage extends z.entity.Message {
  constructor() {
    super();

    this.super_type = z.message.SuperType.DELETE;
    this.deleted_timestamp = null;

    this.display_deleted_timestamp = () => {
      return z.l10n.text(z.string.conversationDeleteTimestamp, moment(this.deleted_timestamp).format('HH:mm'));
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.SystemMessage = class SystemMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.SYSTEM;
    this.system_message_type = z.message.SystemMessageType.NORMAL;
  }

  is_conversation_rename() {
    return this.system_message_type === z.message.SystemMessageType.CONVERSATION_RENAME;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MemberMessage = class MemberMessage extends z.entity.SystemMessage {
  static get CONFIG() {
    return {
      MAX_USERS_VISIBLE: 17,
      MAX_WHOLE_TEAM_USERS_VISIBLE: 10,
      REDUCED_USERS_COUNT: 15,
    };
  }

  constructor() {
    super();

    this.super_type = z.message.SuperType.MEMBER;
    this.memberMessageType = z.message.SystemMessageType.NORMAL;

    this.userEntities = ko.observableArray();
    this.userIds = ko.observableArray();
    this.name = ko.observable('');

    this.exceedsMaxVisibleUsers = ko.pureComputed(() => {
      return this.joinedUserEntities().length > MemberMessage.CONFIG.MAX_USERS_VISIBLE;
    });
    this.visibleUsers = ko.observable([]);
    this.hiddenUserCount = ko.pureComputed(() => this.joinedUserEntities().length - this.visibleUsers().length);
    this.highlightedUsers = ko.pureComputed(() => {
      return this.type === z.event.Backend.CONVERSATION.MEMBER_JOIN ? this.joinedUserEntities() : [];
    });

    this.hasUsers = ko.pureComputed(() => this.userEntities().length);
    this.allTeamMembers = undefined;
    this.showServicesWarning = false;

    // Users joined the conversation without sender
    this.joinedUserEntities = ko.pureComputed(() => {
      return this.userEntities()
        .filter(userEntity => !this.user() || this.user().id !== userEntity.id)
        .map(userEntity => userEntity);
    });

    this.joinedUserEntities.subscribe(joinedUserEntities => {
      const selfUser = joinedUserEntities.find(userEntity => userEntity.is_me);
      const visibleUsers = joinedUserEntities.filter(userEntity => !userEntity.is_me);
      if (this.exceedsMaxVisibleUsers()) {
        const spliceCount = MemberMessage.CONFIG.REDUCED_USERS_COUNT;
        visibleUsers.splice(selfUser ? spliceCount - 1 : spliceCount);
      }
      if (selfUser) {
        visibleUsers.push(selfUser);
      }
      this.visibleUsers(visibleUsers);
    });

    // Users joined the conversation without self
    this.remoteUserEntities = ko.pureComputed(() => {
      return this.userEntities()
        .filter(userEntity => !userEntity.is_me)
        .map(userEntity => userEntity);
    });

    this.senderName = ko.pureComputed(() => {
      const isTeamMemberLeave = this.type === z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE;
      return isTeamMemberLeave
        ? this.name()
        : z.util.SanitizationUtil.getFirstName(this.user(), z.string.Declension.NOMINATIVE, true);
    });

    this.showNamedCreation = ko.pureComputed(() => this.isConversationCreate() && this.name().length);

    this.otherUser = ko.pureComputed(() => (this.hasUsers() ? this.userEntities()[0] : new z.entity.User()));

    this.htmlCaption = ko.pureComputed(() => {
      if (!this.hasUsers()) {
        return '';
      }

      let substitutions;
      const replaceDangerously = {
        '/showmore': '</a>',
        showmore: '<a class="message-header-show-more" data-uie-name="do-show-more">',
      };

      switch (this.memberMessageType) {
        case z.message.SystemMessageType.CONNECTION_ACCEPTED:
        case z.message.SystemMessageType.CONNECTION_REQUEST: {
          if (this.otherUser()) {
            if (this.otherUser().isBlocked()) {
              return z.l10n.safeHtml(z.string.conversationConnectionBlocked);
            }

            if (this.otherUser().isOutgoingRequest()) {
              return '';
            }
          }

          return z.l10n.safeHtml(z.string.conversationConnectionAccepted);
        }

        case z.message.SystemMessageType.CONVERSATION_CREATE: {
          if (this.name().length) {
            const exceedsMaxTeam = this.joinedUserEntities().length > MemberMessage.CONFIG.MAX_WHOLE_TEAM_USERS_VISIBLE;
            if (this.allTeamMembers && exceedsMaxTeam) {
              const guestCount = this.joinedUserEntities().filter(userEntity => userEntity.isGuest()).length;
              substitutions = {replace: {count: guestCount}, replaceDangerously};
              if (!guestCount) {
                return z.l10n.safeHtml(z.string.conversationCreateTeam, substitutions);
              }

              const hasSingleGuest = guestCount === 1;
              const teamStringId = hasSingleGuest
                ? z.string.conversationCreateTeamGuest
                : z.string.conversationCreateTeamGuests;

              return z.l10n.safeHtml(teamStringId, substitutions);
            }

            const createStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationCreateWithMore
              : z.string.conversationCreateWith;

            substitutions = {
              replace: {
                count: this.hiddenUserCount(),
                users: this._generateNameString(this.exceedsMaxVisibleUsers(), z.string.Declension.DATIVE),
              },
              replaceDangerously,
            };

            return z.l10n.safeHtml(createStringId, substitutions);
          }

          if (this.user().is_me) {
            const createStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationCreatedYouMore
              : z.string.conversationCreatedYou;

            substitutions = {
              replace: {
                count: this.hiddenUserCount(),
                users: this._generateNameString(this.exceedsMaxVisibleUsers()),
              },
              replaceDangerously,
            };

            return z.l10n.safeHtml(createStringId, substitutions);
          }

          const createStringId = this.exceedsMaxVisibleUsers()
            ? z.string.conversationCreatedMore
            : z.string.conversationCreated;

          substitutions = {
            replace: {
              count: this.hiddenUserCount(),
              name: this.senderName(),
              users: this._generateNameString(this.exceedsMaxVisibleUsers(), z.string.Declension.DATIVE),
            },
            replaceDangerously,
          };

          return z.l10n.safeHtml(createStringId, substitutions);
        }

        case z.message.SystemMessageType.CONVERSATION_RESUME: {
          substitutions = {
            replace: {
              users: this._generateNameString(false, z.string.Declension.DATIVE),
            },
          };

          return z.l10n.safeHtml(z.string.conversationResume, substitutions);
        }

        default:
          break;
      }

      switch (this.type) {
        case z.event.Backend.CONVERSATION.MEMBER_JOIN: {
          const senderJoined = this.otherUser().id === this.user().id;
          if (senderJoined) {
            const userJoinedStringId = this.user().is_me
              ? z.string.conversationMemberJoinedSelfYou
              : z.string.conversationMemberJoinedSelf;
            return z.l10n.safeHtml(userJoinedStringId, this.senderName());
          }

          let userJoinedStringId = '';

          if (this.user().is_me) {
            userJoinedStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationMemberJoinedYouMore
              : z.string.conversationMemberJoinedYou;
          } else {
            userJoinedStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationMemberJoinedMore
              : z.string.conversationMemberJoined;
          }

          substitutions = {
            replace: {
              count: this.hiddenUserCount(),
              name: this.senderName(),
              users: this._generateNameString(this.exceedsMaxVisibleUsers()),
            },
            replaceDangerously,
          };

          return z.l10n.safeHtml(userJoinedStringId, substitutions);
        }

        case z.event.Backend.CONVERSATION.MEMBER_LEAVE: {
          const temporaryGuestRemoval = this.otherUser().is_me && this.otherUser().isTemporaryGuest();
          if (temporaryGuestRemoval) {
            return z.l10n.safeHtml(z.string.temporaryGuestLeaveMessage);
          }

          const senderLeft = this.otherUser().id === this.user().id;
          if (senderLeft) {
            const userLeftStringId = this.user().is_me
              ? z.string.conversationMemberLeftYou
              : z.string.conversationMemberLeft;
            return z.l10n.safeHtml(userLeftStringId, this.senderName());
          }

          const userRemovedStringId = this.user().is_me
            ? z.string.conversationMemberRemovedYou
            : z.string.conversationMemberRemoved;

          substitutions = {replace: {name: this.senderName(), users: this._generateNameString()}};
          return z.l10n.safeHtml(userRemovedStringId, substitutions);
        }

        case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE: {
          return z.l10n.safeHtml(z.string.conversationTeamLeft, this.senderName());
        }

        default:
          break;
      }
      return '';
    });

    this.htmlGroupCreationHeader = ko.pureComputed(() => {
      if (this.showNamedCreation()) {
        if (this.user().isTemporaryGuest()) {
          return z.l10n.safeHtml(z.string.conversationCreateTemporary);
        }

        const groupCreationStringId = this.user().is_me
          ? z.string.conversationCreatedNameYou
          : z.string.conversationCreatedName;
        return z.util.StringUtil.capitalizeFirstChar(z.l10n.safeHtml(groupCreationStringId, this.senderName()));
      }
      return '';
    });

    this.showLargeAvatar = () => {
      const largeAvatarTypes = [
        z.message.SystemMessageType.CONNECTION_ACCEPTED,
        z.message.SystemMessageType.CONNECTION_REQUEST,
      ];
      return largeAvatarTypes.includes(this.memberMessageType);
    };
  }

  _generateNameString(skipAnd = false, declension = z.string.Declension.ACCUSATIVE) {
    return z.util.LocalizerUtil.joinNames(this.visibleUsers(), declension, skipAnd, true);
  }

  isConnection() {
    const connectionMessageTypes = [
      z.message.SystemMessageType.CONNECTION_ACCEPTED,
      z.message.SystemMessageType.CONNECTION_REQUEST,
    ];

    return connectionMessageTypes.includes(this.memberMessageType);
  }

  isConnectionRequest() {
    return this.memberMessageType === z.message.SystemMessageType.CONNECTION_REQUEST;
  }

  isCreation() {
    return [
      z.message.SystemMessageType.CONNECTION_ACCEPTED,
      z.message.SystemMessageType.CONNECTION_REQUEST,
      z.message.SystemMessageType.CONVERSATION_CREATE,
      z.message.SystemMessageType.CONVERSATION_RESUME,
    ].includes(this.memberMessageType);
  }

  isConversationCreate() {
    return this.memberMessageType === z.message.SystemMessageType.CONVERSATION_CREATE;
  }

  isConversationResume() {
    return this.memberMessageType === z.message.SystemMessageType.CONVERSATION_RESUME;
  }

  isGroupCreation() {
    return this.isConversationCreate() || this.isConversationResume();
  }

  isMemberChange() {
    return this.isMemberJoin() || this.isMemberLeave() || this.isTeamMemberLeave();
  }

  isMemberJoin() {
    return this.type === z.event.Backend.CONVERSATION.MEMBER_JOIN;
  }

  isMemberLeave() {
    return this.type === z.event.Backend.CONVERSATION.MEMBER_LEAVE;
  }

  isTeamMemberLeave() {
    return this.type === z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE;
  }

  isMemberRemoval() {
    return this.isMemberLeave() || this.isTeamMemberLeave();
  }

  isUserAffected(userId) {
    return this.userIds().includes(userId);
  }

  guestCount() {
    return this.joinedUserEntities().filter(user => user.isGuest()).length;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MissedMessage = class MissedMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.MISSED;
    this.affect_order(false);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.ContentMessage = class ContentMessage extends z.entity.Message {
  constructor(id) {
    super(id);

    this.assets = ko.observableArray([]);
    this.super_type = z.message.SuperType.CONTENT;
    this.replacing_message_id = null;
    this.edited_timestamp = null;

    this.reactions = ko.observable({});
    this.reactions_user_ets = ko.observableArray();
    this.reactions_user_ids = ko.pureComputed(() => {
      this.reactions_user_ets()
        .map(user_et => user_et.first_name())
        .join(', ');
    });

    this.quote = ko.observable();

    this.display_edited_timestamp = () => {
      return z.l10n.text(z.string.conversationEditTimestamp, moment(this.edited_timestamp).format('HH:mm'));
    };

    this.is_liked_provisional = ko.observable();
    this.is_liked = ko.pureComputed({
      read: () => {
        if (this.is_liked_provisional() != null) {
          const is_liked_provisional = this.is_liked_provisional();
          this.is_liked_provisional(null);
          return is_liked_provisional;
        }
        const likes = this.reactions_user_ets().filter(user_et => user_et.is_me);
        return likes.length === 1;
      },
      write: value => {
        return this.is_liked_provisional(value);
      },
    });
    this.other_likes = ko.pureComputed(() => this.reactions_user_ets().filter(user_et => !user_et.is_me));

    this.like_caption = ko.pureComputed(() => {
      if (this.reactions_user_ets().length <= 5) {
        return this.reactions_user_ets()
          .map(user_et => user_et.first_name())
          .join(', ');
      }
      return z.l10n.text(z.string.conversationLikesCaption, this.reactions_user_ets().length);
    });
  }

  /**
   * Add another content asset to the message.
   * @param {z.entity.Asset} asset_et - New content asset
   * @returns {undefined} No return value
   */
  add_asset(asset_et) {
    this.assets.push(asset_et);
  }

  copy() {
    z.util.ClipboardUtil.copyText(this.get_first_asset().text);
  }

  /**
   * Get the first asset attached to the message.
   * @returns {z.entity.Asset} The first asset attached to the message
   */
  get_first_asset() {
    return this.assets()[0];
  }

  update_reactions({data: event_data, from}) {
    const reactions = this.reactions();

    if (event_data.reaction) {
      reactions[from] = event_data.reaction;
    } else {
      delete reactions[from];
    }

    if (reactions !== this.reactions) {
      this.reactions(reactions);
      this.version += 1;
      return {reactions: this.reactions(), version: this.version};
    }
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the message mentions the user.
   */
  isUserMentioned(userId) {
    return this.has_asset_text()
      ? this.assets().some(assetEntity => assetEntity.is_text() && assetEntity.isUserMentioned(userId))
      : false;
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the message quotes the user.
   */
  isUserQuoted(userId) {
    return this.quote() ? this.quote().isQuoteFromUser(userId) : false;
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the user was mentioned or quoted.
   */
  isUserTargeted(userId) {
    return this.isUserMentioned(userId) || this.isUserQuoted(userId);
  }

  /**
   * Check whether the message was edited.
   * @returns {boolean} True, if message has been edited.
   */
  was_edited() {
    return this.replacing_message_id != null;
  }

  /**
   * Download message content.
   * @returns {undefined} No return value
   */
  download() {
    const asset_et = this.get_first_asset();
    const file_name = this.get_content_name();
    asset_et.download(file_name);
  }

  /**
   * Get content name.
   * @returns {string} The content/file name.
   */
  get_content_name() {
    const asset_et = this.get_first_asset();
    let {file_name} = asset_et;

    if (!file_name) {
      const date = moment(this.timestamp());
      file_name = `Wire ${date.format('YYYY-MM-DD')} at ${date.format('H.mm.ss')}`;
    }

    if (asset_et.file_type) {
      const file_extension = asset_et.file_type.split('/').pop();
      file_name = `${file_name}.${file_extension}`;
    }

    return file_name;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MessageTimerUpdateMessage = class MessageTimerUpdateMessage extends z.entity.SystemMessage {
  constructor(messageTimer) {
    super();

    this.type = z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE;
    this.system_message_type = z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE;

    this.message_timer = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    this.caption = ko.pureComputed(() => {
      if (this.message_timer) {
        const timeString = z.util.TimeUtil.formatDuration(this.message_timer).text;
        const stringId = this.user().is_me ? z.string.conversationUpdatedTimerYou : z.string.conversationUpdatedTimer;
        return z.l10n.text(stringId, {time: timeString});
      }

      const stringId = this.user().is_me ? z.string.conversationResetTimerYou : z.string.conversationResetTimer;
      return z.l10n.text(stringId);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.RenameMessage = class RenameMessage extends z.entity.SystemMessage {
  constructor() {
    super();

    this.type = z.event.Backend.CONVERSATION.RENAME;
    this.system_message_type = z.message.SystemMessageType.CONVERSATION_RENAME;

    this.caption = ko.pureComputed(() => {
      const identifier = this.user().is_me ? z.string.conversationRenameYou : z.string.conversationRename;
      return z.l10n.text(identifier);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.PingMessage = class PingMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.PING;

    this.caption = ko.pureComputed(() => {
      const stringId = this.user().is_me ? z.string.conversationPingYou : z.string.conversationPing;
      return z.l10n.text(stringId);
    });

    this.get_icon_classes = ko.pureComputed(() => {
      const show_ping_animation = Date.now() - this.timestamp() < 2000;
      let css_classes = this.accent_color();
      if (show_ping_animation) {
        css_classes += ' ping-animation ping-animation-soft';
      }
      return css_classes;
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.CallMessage = class CallMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.CALL;
    this.call_message_type = '';
    this.finished_reason = '';

    this.caption = ko.pureComputed(() => {
      const stringId = this.user().is_me
        ? z.string.conversationVoiceChannelDeactivateYou
        : z.string.conversationVoiceChannelDeactivate;

      return z.l10n.text(stringId);
    });
  }

  /**
   * Check if call message is call activation.
   * @returns {boolean} Is message of type activate
   */
  is_activation() {
    return this.call_message_type === z.message.CALL_MESSAGE_TYPE.ACTIVATED;
  }

  /**
   * Check if call message is call deactivation.
   * @returns {boolean} Is message of type deactivate
   */
  is_deactivation() {
    return this.call_message_type === z.message.CALL_MESSAGE_TYPE.DEACTIVATED;
  }

  was_completed() {
    return this.finished_reason === z.calling.enum.TERMINATION_REASON.COMPLETED;
  }

  was_missed() {
    return this.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.DecryptErrorMessage = class DecryptErrorMessage extends z.entity.Message {
  static get REMOTE_IDENTITY_CHANGED_ERROR() {
    return Proteus.errors.DecryptError.CODE.CASE_204.toString();
  }

  constructor() {
    super();
    this.super_type = z.message.SuperType.UNABLE_TO_DECRYPT;

    this.error_code = '';
    this.client_id = '';

    this.htmlCaption = ko.pureComputed(() => {
      const stringId = this.is_remote_identity_changed()
        ? z.string.conversationUnableToDecrypt2
        : z.string.conversationUnableToDecrypt1;

      const substitutions = {
        replace: {
          user: this.user().first_name(),
        },
        replaceDangerously: {
          '/highlight': '</span>',
          highlight: '<span class="label-bold-xs">',
        },
      };

      return z.l10n.safeHtml(stringId, substitutions);
    });

    this.link = ko.pureComputed(() => {
      const path = this.is_remote_identity_changed()
        ? z.config.URL_PATH.DECRYPT_ERROR_2
        : z.config.URL_PATH.DECRYPT_ERROR_1;
      return z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path);
    });

    this.is_recoverable = ko.pureComputed(() => {
      return this.error_code.toString().startsWith('2') && !this.is_remote_identity_changed();
    });
    this.is_remote_identity_changed = ko.pureComputed(() => {
      return this.error_code.toString() === DecryptErrorMessage.REMOTE_IDENTITY_CHANGED_ERROR;
    });
    this.is_resetting_session = ko.observable(false);

    this.error_message = ko.pureComputed(() => {
      const parts = [];

      if (this.error_code) {
        const error_text = z.l10n.text(z.string.conversationUnableToDecryptErrorMessage);
        parts.push(`${error_text}: <span class='label-bold-xs'>${this.error_code}</span> `);
      }

      if (this.client_id) {
        parts.push(`ID: ${z.util.printDevicesId(this.client_id)}`);
      }

      if (parts.length) {
        return `(${parts.join('')})`;
      }
    });

    this.htmlErrorMessage = this.error_message;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.VerificationMessage = class VerificationMessage extends z.entity.Message {
  constructor() {
    super();

    this.super_type = z.message.SuperType.VERIFICATION;
    this.affect_order(false);
    this.verificationMessageType = ko.observable();

    this.userEntities = ko.observableArray();
    this.userIds = ko.observableArray();

    this.isSelfClient = ko.pureComputed(() => {
      return this.userIds().length === 1 && this.userIds()[0] === this.user().id;
    });

    this.isTypeNewDevice = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.NEW_DEVICE;
    });
    this.isTypeNewMember = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.NEW_MEMBER;
    });
    this.isTypeUnverified = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.UNVERIFIED;
    });
    this.isTypeVerified = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.VERIFIED;
    });

    this.captionUser = ko.pureComputed(() => {
      const namesString = z.util.LocalizerUtil.joinNames(this.userEntities(), z.string.Declension.NOMINATIVE);
      return z.util.StringUtil.capitalizeFirstChar(namesString);
    });

    this.captionStartedUsing = ko.pureComputed(() => {
      const hasMultipleUsers = this.userIds().length > 1;
      const stringId = hasMultipleUsers
        ? z.string.conversationDeviceStartedUsingMany
        : z.string.conversationDeviceStartedUsingOne;

      return z.l10n.text(stringId);
    });

    this.captionNewDevice = ko.pureComputed(() => {
      const hasMultipleUsers = this.userIds().length > 1;
      const stringId = hasMultipleUsers
        ? z.string.conversationDeviceNewDeviceMany
        : z.string.conversationDeviceNewDeviceOne;

      return z.l10n.text(stringId);
    });

    this.captionUnverifiedDevice = ko.pureComputed(() => {
      const [firstUserEntity] = this.userEntities();
      const stringId = this.isSelfClient()
        ? z.string.conversationDeviceYourDevices
        : z.string.conversationDeviceUserDevices;

      return z.l10n.text(stringId, firstUserEntity.first_name());
    });
  }

  clickOnDevice() {
    const topic = this.isSelfClient() ? z.event.WebApp.PREFERENCES.MANAGE_DEVICES : z.event.WebApp.SHORTCUT.PEOPLE;
    amplify.publish(topic);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

// Please note: The own user has a "locale"
z.entity.User = class User {
  static get ACCENT_COLOR() {
    return {
      BLUE: '#2391d3',
      GREEN: '#00c800',
      ORANGE: '#ff8900',
      PINK: '#fe5ebd',
      PURPLE: '#9c00fe',
      RED: '#fb0807',
      YELLOW: '#febf02',
    };
  }

  static get CONFIG() {
    return {
      TEMPORARY_GUEST: {
        EXPIRATION_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
        EXPIRATION_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
        LIFETIME: z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      },
    };
  }

  static get THEME() {
    return {
      BLUE: 'theme-blue',
      GREEN: 'theme-green',
      ORANGE: 'theme-orange',
      PINK: 'theme-pink',
      PURPLE: 'theme-purple',
      RED: 'theme-red',
      YELLOW: 'theme-yellow',
    };
  }

  constructor(id = '') {
    this.id = id;
    this.is_me = false;
    this.isService = false;
    this.isSingleSignOn = false;

    this.joaatHash = -1;

    this.accent_id = ko.observable(z.config.ACCENT_ID.BLUE);
    this.accent_theme = ko.pureComputed(
      () => {
        switch (this.accent_id()) {
          case z.config.ACCENT_ID.BLUE:
            return z.entity.User.THEME.BLUE;
          case z.config.ACCENT_ID.GREEN:
            return z.entity.User.THEME.GREEN;
          case z.config.ACCENT_ID.ORANGE:
            return z.entity.User.THEME.ORANGE;
          case z.config.ACCENT_ID.PINK:
            return z.entity.User.THEME.PINK;
          case z.config.ACCENT_ID.PURPLE:
            return z.entity.User.THEME.PURPLE;
          case z.config.ACCENT_ID.RED:
            return z.entity.User.THEME.RED;
          case z.config.ACCENT_ID.YELLOW:
            return z.entity.User.THEME.YELLOW;
          default:
            return z.entity.User.THEME.BLUE;
        }
      },
      this,
      {deferEvaluation: true}
    );

    this.accent_color = ko.pureComputed(
      () => {
        switch (this.accent_id()) {
          case z.config.ACCENT_ID.BLUE:
            return z.entity.User.ACCENT_COLOR.BLUE;
          case z.config.ACCENT_ID.GREEN:
            return z.entity.User.ACCENT_COLOR.GREEN;
          case z.config.ACCENT_ID.ORANGE:
            return z.entity.User.ACCENT_COLOR.ORANGE;
          case z.config.ACCENT_ID.PINK:
            return z.entity.User.ACCENT_COLOR.PINK;
          case z.config.ACCENT_ID.PURPLE:
            return z.entity.User.ACCENT_COLOR.PURPLE;
          case z.config.ACCENT_ID.RED:
            return z.entity.User.ACCENT_COLOR.RED;
          case z.config.ACCENT_ID.YELLOW:
            return z.entity.User.ACCENT_COLOR.YELLOW;
          default:
            return z.entity.User.ACCENT_COLOR.BLUE;
        }
      },
      this,
      {deferEvaluation: true}
    );

    this.email = ko.observable();
    this.phone = ko.observable();

    this.name = ko.observable('');
    this.first_name = ko.pureComputed(() => {
      const [firstName] = this.name().split(' ');
      return firstName || '';
    });

    this.last_name = ko.pureComputed(() => {
      const nameParts = this.name().split(' ');
      if (nameParts.length > 1) {
        return nameParts.pop();
      }
    });

    this.initials = ko.pureComputed(() => {
      let initials = '';
      if (this.first_name() && this.last_name()) {
        const first = z.util.StringUtil.getFirstChar(this.first_name());
        const last = z.util.StringUtil.getFirstChar(this.last_name());
        initials = `${first}${last}`;
      } else {
        initials = this.first_name().slice(0, 2);
      }
      return initials.toUpperCase();
    });

    this.username = ko.observable('');

    this.previewPictureResource = ko.observable();
    this.mediumPictureResource = ko.observable();

    this.connection = ko.observable(new z.connection.ConnectionEntity());

    this.isBlocked = ko.pureComputed(() => this.connection().isBlocked());
    this.isCanceled = ko.pureComputed(() => this.connection().isCanceled());
    this.isConnected = ko.pureComputed(() => this.connection().isConnected());
    this.isIgnored = ko.pureComputed(() => this.connection().isIgnored());
    this.isIncomingRequest = ko.pureComputed(() => this.connection().isIncomingRequest());
    this.isOutgoingRequest = ko.pureComputed(() => this.connection().isOutgoingRequest());
    this.isUnknown = ko.pureComputed(() => this.connection().isUnknown());

    this.inTeam = ko.observable(false);
    this.isGuest = ko.observable(false);
    this.isTemporaryGuest = ko.observable(false);
    this.isTeamMember = ko.observable(false);
    this.teamRole = ko.observable(z.team.TeamRole.ROLE.NONE);
    this.isTeamManager = ko.pureComputed(() => {
      return [z.team.TeamRole.ROLE.ADMIN, z.team.TeamRole.ROLE.OWNER].includes(this.teamRole());
    });
    this.isTeamOwner = ko.pureComputed(() => z.team.TeamRole.ROLE.OWNER === this.teamRole());
    this.teamId = undefined;

    this.isRequest = ko.pureComputed(() => this.connection().isRequest());

    this.devices = ko.observableArray(); // does not include current client/device
    this.is_verified = ko.pureComputed(() => {
      if (this.devices().length === 0 && !this.is_me) {
        return false;
      }
      return this.devices().every(client_et => client_et.meta.isVerified());
    });

    this.availability = ko.observable(z.user.AvailabilityType.NONE);

    this.expirationRemaining = ko.observable(0);
    this.expirationText = ko.observable('');
    this.expirationIsUrgent = ko.observable(false);
    this.expirationRemainingText = ko.observable('');
    this.expirationIntervalId = undefined;
    this.expirationTimeoutId = undefined;
    this.isExpired = ko.observable(false);
  }

  subscribeToChanges() {
    this.availability.subscribe(() => amplify.publish(z.event.WebApp.USER.PERSIST, this));
  }

  add_client(new_client_et) {
    for (const client_et of this.devices()) {
      if (client_et.id === new_client_et.id) {
        return false;
      }
    }

    this.devices.push(new_client_et);

    if (this.is_me) {
      this.devices.sort((client_a, client_b) => new Date(client_b.time) - new Date(client_a.time));
    }

    return true;
  }

  hasActivatedIdentity() {
    return this.email() || this.phone() || this.isSingleSignOn;
  }

  remove_client(client_id) {
    return this.devices.remove(client_et => client_et.id === client_id);
  }

  /**
   * Check whether handle or name matches the given query
   * @param {string} query - Query
   * @param {boolean} is_handle - Query string is handle
   * @param {array} excludedChars - list of chars to exclude from getSlug
   * @returns {undefined} No return value
   */
  matches(query, is_handle, excludedChars = []) {
    if (is_handle) {
      return z.util.StringUtil.startsWith(this.username(), query);
    }
    return z.util.StringUtil.compareTransliteration(this.name(), query, excludedChars) || this.username() === query;
  }

  serialize() {
    return {
      availability: this.availability(),
      id: this.id,
    };
  }

  setGuestExpiration(timestamp) {
    if (this.expirationIntervalId) {
      window.clearInterval(this.expirationIntervalId);
      this.expirationIntervalId = undefined;
    }

    this._setRemainingExpirationTime(timestamp);

    const expirationInterval = User.CONFIG.TEMPORARY_GUEST.EXPIRATION_INTERVAL;
    this.expirationIntervalId = window.setInterval(
      () => this._setRemainingExpirationTime(timestamp),
      expirationInterval
    );

    window.setTimeout(() => {
      this.isExpired(true);
      window.clearInterval(this.expirationIntervalId);
    }, this.expirationRemaining());
  }

  clearExpirationTimeout() {
    if (this.expirationTimeoutId) {
      window.clearTimeout(this.expirationTimeoutId);
      this.expirationTimeoutId = undefined;
    }
  }

  checkGuestExpiration() {
    const checkExpiration = this.isTemporaryGuest() && !this.expirationTimeoutId;
    if (checkExpiration) {
      if (this.isExpired()) {
        return amplify.publish(z.event.WebApp.USER.UPDATE, this.id);
      }

      const timeout = this.expirationRemaining() + User.CONFIG.TEMPORARY_GUEST.EXPIRATION_THRESHOLD;
      this.expirationTimeoutId = window.setTimeout(() => amplify.publish(z.event.WebApp.USER.UPDATE, this.id), timeout);
    }
  }

  _setRemainingExpirationTime(expirationTime) {
    const remainingTime = z.util.NumberUtil.clamp(expirationTime - Date.now(), 0, User.CONFIG.TEMPORARY_GUEST.LIFETIME);
    const remainingMinutes = Math.ceil(remainingTime / z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

    let timeLeftText = z.string.userRemainingTimeHours;
    let timeValue = 0;

    if (remainingMinutes <= 45) {
      timeLeftText = z.string.userRemainingTimeMinutes;
      const remainingQuarters = Math.max(1, Math.ceil(remainingMinutes / 15));
      timeValue = remainingQuarters * 15;
      this.expirationRemaining(timeValue * z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);
      this.expirationRemainingText(`${timeValue}m`);
    } else {
      const showOneAndAHalf = remainingMinutes > 60 && remainingMinutes <= 90;
      timeValue = showOneAndAHalf ? 1.5 : Math.ceil(remainingMinutes / 60);
      this.expirationRemaining(timeValue * z.util.TimeUtil.UNITS_IN_MILLIS.HOUR);
      this.expirationRemainingText(`${timeValue}h`);
    }

    this.expirationIsUrgent(remainingMinutes < 120);
    this.expirationText(z.l10n.text(timeLeftText, timeValue));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Conversation = class Conversation {
  static get TIMESTAMP_TYPE() {
    return {
      ARCHIVED: 'archivedTimestamp',
      CLEARED: 'cleared_timestamp',
      LAST_EVENT: 'last_event_timestamp',
      LAST_READ: 'last_read_timestamp',
      LAST_SERVER: 'last_server_timestamp',
      MUTED: 'mutedTimestamp',
    };
  }

  /**
   * Constructs a new conversation entity.
   * @class z.entity.Conversation
   * @param {string} conversation_id - Conversation ID
   */
  constructor(conversation_id = '') {
    this.id = conversation_id;

    this.logger = new z.util.Logger(`z.entity.Conversation (${this.id})`, z.config.LOGGER.OPTIONS);

    this.accessState = ko.observable(z.conversation.ACCESS_STATE.UNKNOWN);
    this.accessCode = ko.observable();
    this.creator = undefined;
    this.name = ko.observable();
    this.team_id = undefined;
    this.type = ko.observable();

    this.is_loaded = ko.observable(false);
    this.is_pending = ko.observable(false);

    this.participating_user_ets = ko.observableArray([]); // Does not include self user
    this.participating_user_ids = ko.observableArray([]);
    this.selfUser = ko.observable();

    this.hasCreationMessage = false;

    this.firstUserEntity = ko.pureComputed(() => this.participating_user_ets()[0]);
    this.availabilityOfUser = ko.pureComputed(() => this.firstUserEntity() && this.firstUserEntity().availability());

    this.isGuest = ko.observable(false);
    this.isManaged = false;

    this.inTeam = ko.pureComputed(() => this.team_id && !this.isGuest());
    this.isGuestRoom = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isTeamOnly = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY);
    this.withAllTeamMembers = ko.observable(undefined);

    this.isTeam1to1 = ko.pureComputed(() => {
      const isGroupConversation = this.type() === z.conversation.ConversationType.GROUP;
      const hasOneParticipant = this.participating_user_ids().length === 1;
      return isGroupConversation && hasOneParticipant && this.team_id && !this.name();
    });
    this.isGroup = ko.pureComputed(() => {
      const isGroupConversation = this.type() === z.conversation.ConversationType.GROUP;
      return isGroupConversation && !this.isTeam1to1();
    });
    this.is1to1 = ko.pureComputed(() => {
      const is1to1Conversation = this.type() === z.conversation.ConversationType.ONE2ONE;
      return is1to1Conversation || this.isTeam1to1();
    });
    this.isRequest = ko.pureComputed(() => this.type() === z.conversation.ConversationType.CONNECT);
    this.isSelf = ko.pureComputed(() => this.type() === z.conversation.ConversationType.SELF);

    this.hasGuest = ko.pureComputed(() => {
      const hasGuestUser = this.participating_user_ets().some(userEntity => userEntity.isGuest());
      return hasGuestUser && this.isGroup() && this.selfUser() && this.selfUser().inTeam();
    });
    this.hasService = ko.pureComputed(() => this.participating_user_ets().some(userEntity => userEntity.isService));

    // in case this is a one2one conversation this is the connection to that user
    this.connection = ko.observable(new z.connection.ConnectionEntity());
    this.connection.subscribe(connectionEntity => {
      const connectedUserId = connectionEntity && connectionEntity.userId;
      if (connectedUserId && !this.participating_user_ids().includes(connectedUserId)) {
        this.participating_user_ids.push(connectedUserId);
      }
    });

    // E2EE conversation states
    this.archivedState = ko.observable(false).extend({notify: 'always'});
    this.mutedState = ko.observable(z.conversation.NotificationSetting.STATE.EVERYTHING);
    this.verification_state = ko.observable(z.conversation.ConversationVerificationState.UNVERIFIED);

    this.archivedTimestamp = ko.observable(0);
    this.cleared_timestamp = ko.observable(0);
    this.last_event_timestamp = ko.observable(0);
    this.last_read_timestamp = ko.observable(0);
    this.last_server_timestamp = ko.observable(0);
    this.mutedTimestamp = ko.observable(0);

    // Conversation states for view
    this.notificationState = ko.pureComputed(() => {
      const NOTIIFCATION_STATE = z.conversation.NotificationSetting.STATE;
      if (!this.selfUser()) {
        return NOTIIFCATION_STATE.NOTHING;
      }

      const knownNotificationStates = Object.values(NOTIIFCATION_STATE);
      if (knownNotificationStates.includes(this.mutedState())) {
        const isStateMentionsAndReplies = this.mutedState() === NOTIIFCATION_STATE.MENTIONS_AND_REPLIES;
        const isInvalidState = isStateMentionsAndReplies && !this.selfUser().inTeam();

        return isInvalidState ? NOTIIFCATION_STATE.NOTHING : this.mutedState();
      }

      if (typeof this.mutedState() === 'boolean') {
        const migratedMutedState = this.selfUser().inTeam()
          ? NOTIIFCATION_STATE.MENTIONS_AND_REPLIES
          : NOTIIFCATION_STATE.NOTHING;
        return this.mutedState() ? migratedMutedState : NOTIIFCATION_STATE.EVERYTHING;
      }

      return NOTIIFCATION_STATE.EVERYTHING;
    });

    this.is_archived = this.archivedState;
    this.is_cleared = ko.pureComputed(() => this.last_event_timestamp() <= this.cleared_timestamp());
    this.is_verified = ko.pureComputed(() => {
      const hasMappedUsers = this.participating_user_ets().length || !this.participating_user_ids().length;
      const isInitialized = this.selfUser() && hasMappedUsers;
      if (!isInitialized) {
        return undefined;
      }

      const allUserEntities = [this.selfUser()].concat(this.participating_user_ets());
      return allUserEntities.every(userEntity => userEntity.is_verified());
    });

    this.showNotificationsEverything = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.EVERYTHING;
    });
    this.showNotificationsNothing = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.NOTHING;
    });
    this.showNotificationsMentionsAndReplies = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.MENTIONS_AND_REPLIES;
    });

    this.status = ko.observable(z.conversation.ConversationStatus.CURRENT_MEMBER);
    this.removed_from_conversation = ko.pureComputed(() => {
      return this.status() === z.conversation.ConversationStatus.PAST_MEMBER;
    });
    this.isActiveParticipant = ko.pureComputed(() => !this.removed_from_conversation() && !this.isGuest());
    this.isClearable = ko.pureComputed(() => !this.isRequest() && !this.is_cleared());
    this.isLeavable = ko.pureComputed(() => this.isGroup() && !this.removed_from_conversation());
    this.isMutable = ko.pureComputed(() => !this.isRequest() && !this.removed_from_conversation());

    // Messages
    this.localMessageTimer = ko.observable(null);
    this.globalMessageTimer = ko.observable(null);

    this.messageTimer = ko.pureComputed(() => this.globalMessageTimer() || this.localMessageTimer());
    this.hasGlobalMessageTimer = ko.pureComputed(() => this.globalMessageTimer() > 0);

    this.messages_unordered = ko.observableArray();
    this.messages = ko.pureComputed(() =>
      this.messages_unordered().sort((message_a, message_b) => {
        return message_a.timestamp() - message_b.timestamp();
      })
    );

    this.hasAdditionalMessages = ko.observable(true);

    this.messages_visible = ko
      .pureComputed(() => (!this.id ? [] : this.messages().filter(messageEntity => messageEntity.visible())))
      .extend({trackArrayChanges: true});

    // Calling
    this.call = ko.observable(undefined);
    this.hasLocalCall = ko.pureComputed(() => !!this.call() && !this.call().isOngoingOnAnotherClient());

    this.hasActiveCall = ko.pureComputed(() => (this.hasLocalCall() ? this.call().isActiveState() : false));
    this.hasJoinableCall = ko.pureComputed(() => (this.hasLocalCall() ? this.call().canJoinState() : false));

    this.unreadState = ko.pureComputed(() => {
      const unreadState = {
        allEvents: [],
        allMessages: [],
        calls: [],
        otherMessages: [],
        pings: [],
        selfMentions: [],
        selfReplies: [],
      };

      for (let index = this.messages().length - 1; index >= 0; index--) {
        const messageEntity = this.messages()[index];
        if (messageEntity.visible()) {
          const isReadMessage = messageEntity.timestamp() <= this.last_read_timestamp() || messageEntity.user().is_me;
          if (isReadMessage) {
            break;
          }

          const isMissedCall = messageEntity.is_call() && messageEntity.was_missed();
          const isPing = messageEntity.is_ping();
          const isMessage = messageEntity.is_content();
          const isSelfMentioned = isMessage && this.selfUser() && messageEntity.isUserMentioned(this.selfUser().id);
          const isSelfQuoted = isMessage && this.selfUser() && messageEntity.isUserQuoted(this.selfUser().id);

          if (isMissedCall || isPing || isMessage) {
            unreadState.allMessages.push(messageEntity);
          }

          if (isSelfMentioned) {
            unreadState.selfMentions.push(messageEntity);
          } else if (isSelfQuoted) {
            unreadState.selfReplies.push(messageEntity);
          } else if (isMissedCall) {
            unreadState.calls.push(messageEntity);
          } else if (isPing) {
            unreadState.pings.push(messageEntity);
          } else if (isMessage) {
            unreadState.otherMessages.push(messageEntity);
          }

          unreadState.allEvents.push(messageEntity);
        }
      }

      return unreadState;
    });

    /**
     * Display name strategy:
     *
     * 'One-to-One Conversations' and 'Connection Requests':
     * We should not use the conversation name received from the backend as fallback as it will always contain the
     * name of the user who received the connection request initially
     *
     * - Name of the other participant
     * - Name of the other user of the associated connection
     * - "..." if neither of those has been attached yet
     *
     * 'Group Conversation':
     * - Conversation name received from backend
     * - If unnamed, we will create a name from the participant names
     * - Join the user's first names to a comma separated list or uses the user's first name if only one user participating
     * - "..." if the user entities have not yet been attached yet
     */
    this.display_name = ko.pureComputed(() => {
      if (this.isRequest() || this.is1to1()) {
        const [userEntity] = this.participating_user_ets();
        const userName = userEntity && userEntity.name();
        return userName ? userName : '';
      }

      if (this.isGroup()) {
        if (this.name()) {
          return this.name();
        }

        const hasUserEntities = !!this.participating_user_ets().length;
        if (hasUserEntities) {
          const isJustServices = this.participating_user_ets().every(userEntity => userEntity.isService);
          const joinedNames = this.participating_user_ets()
            .filter(userEntity => isJustServices || !userEntity.isService)
            .map(userEntity => userEntity.first_name())
            .join(', ');

          const maxLength = z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH;
          return z.util.StringUtil.truncate(joinedNames, maxLength, false);
        }

        const hasUserIds = !!this.participating_user_ids().length;
        if (!hasUserIds) {
          return z.l10n.text(z.string.conversationsEmptyConversation);
        }
      }

      return '';
    });

    this.shouldPersistStateChanges = false;
    this.publishPersistState = _.debounce(() => amplify.publish(z.event.WebApp.CONVERSATION.PERSIST_STATE, this), 100);

    this._initSubscriptions();
  }

  _initSubscriptions() {
    [
      this.archivedState,
      this.archivedTimestamp,
      this.cleared_timestamp,
      this.messageTimer,
      this.isGuest,
      this.last_event_timestamp,
      this.last_read_timestamp,
      this.last_server_timestamp,
      this.mutedState,
      this.mutedTimestamp,
      this.name,
      this.participating_user_ids,
      this.status,
      this.type,
      this.verification_state,
    ].forEach(property => property.subscribe(this.persistState.bind(this)));
  }

  persistState() {
    if (this.shouldPersistStateChanges) {
      this.publishPersistState();
    }
  }

  setStateChangePersistence(persistChanges) {
    this.shouldPersistStateChanges = persistChanges;
  }

  /**
   * Remove all message from conversation unless there are unread messages.
   * @returns {undefined} No return value
   */
  release() {
    if (!this.unreadState().allEvents.length) {
      this.remove_messages();
      this.is_loaded(false);
      this.hasAdditionalMessages(true);
    }
  }

  /**
   * Set the timestamp of a given type.
   * @note This will only increment timestamps
   * @param {string|number} timestamp - Timestamp to be set
   * @param {Conversation.TIMESTAMP_TYPE} type - Type of timestamp to be updated
   * @param {boolean} forceUpdate - set the timestamp regardless of previous timestamp value (no checks)
   * @returns {boolean|number} Timestamp value which can be 'false' (boolean) if there is no timestamp
   */
  setTimestamp(timestamp, type, forceUpdate = false) {
    if (_.isString(timestamp)) {
      timestamp = window.parseInt(timestamp, 10);
    }

    const entityTimestamp = this[type];
    if (!entityTimestamp) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.INVALID_PARAMETER);
    }

    const updatedTimestamp = forceUpdate ? timestamp : this._incrementTimeOnly(entityTimestamp(), timestamp);

    if (updatedTimestamp !== false) {
      entityTimestamp(updatedTimestamp);
    }
    return updatedTimestamp;
  }

  /**
   * Increment only on timestamp update
   * @param {number} currentTimestamp - Current timestamp
   * @param {number} updatedTimestamp - Timestamp from update
   * @returns {number|boolean} Updated timestamp or false if not increased
   */
  _incrementTimeOnly(currentTimestamp, updatedTimestamp) {
    const timestampIncreased = updatedTimestamp > currentTimestamp;
    return timestampIncreased ? updatedTimestamp : false;
  }

  /**
   * Adds a single message to the conversation.
   * @param {z.entity.Message} messageEntity - Message entity to be added to the conversation.
   * @param {boolean} replaceDuplicate - If a duplicate (or a message that should be replaced) already exists, replace it with the new entity.
   * @returns {z.entity.Message | undefined} replacedEntity - If a message was replaced in the conversation, returns the original message
   */
  add_message(messageEntity, replaceDuplicate = false) {
    if (messageEntity) {
      const messageWithLinkPreview = () => this._findDuplicate(messageEntity.id, messageEntity.from);
      const editedMessage = () => this._findDuplicate(messageEntity.replacing_message_id, messageEntity.from);
      const entityToReplace = messageWithLinkPreview() || editedMessage();
      this.update_timestamps(messageEntity);
      if (entityToReplace) {
        if (replaceDuplicate) {
          if (messageEntity.is_content()) {
            messageEntity.quote(entityToReplace.quote());
          }
          const duplicateIndex = this.messages_unordered.indexOf(entityToReplace);
          this.messages_unordered.splice(duplicateIndex, 1, messageEntity);
        }
        // The duplicated message has been treated (either replaced or ignored). Our job here is done.
        return entityToReplace;
      }
      this.messages_unordered.push(messageEntity);
      amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, messageEntity);
    }
  }

  /**
   * Adds multiple messages to the conversation.
   * @param {Array<z.entity.Message>} message_ets - Array of message entities to be added to the conversation
   * @returns {undefined} No return value
   */
  add_messages(message_ets) {
    message_ets = message_ets.map(message_et => this._checkForDuplicate(message_et)).filter(message_et => message_et);

    // in order to avoid multiple db writes check the messages from the end and stop once
    // we found a message from self user
    for (let counter = message_ets.length - 1; counter >= 0; counter--) {
      const message_et = message_ets[counter];
      if (message_et.user() && message_et.user().is_me) {
        this.update_timestamps(message_et);
        break;
      }
    }

    z.util.koArrayPushAll(this.messages_unordered, message_ets);
  }

  getFirstUnreadSelfMention() {
    return this.unreadState()
      .selfMentions.slice()
      .pop();
  }

  get_last_known_timestamp(currentTimestamp) {
    const last_known_timestamp = Math.max(this.last_server_timestamp(), this.last_event_timestamp());
    return last_known_timestamp || currentTimestamp;
  }

  get_latest_timestamp(currentTimestamp) {
    return Math.max(this.last_server_timestamp(), this.last_event_timestamp(), currentTimestamp);
  }

  get_next_iso_date(currentTimestamp) {
    if (!_.isNumber(currentTimestamp)) {
      currentTimestamp = Date.now();
    }
    const timestamp = Math.max(this.last_server_timestamp() + 1, currentTimestamp);
    return new Date(timestamp).toISOString();
  }

  getNumberOfServices() {
    return this.participating_user_ets().filter(userEntity => userEntity.isService).length;
  }

  getNumberOfParticipants(countSelf = true, countServices = true) {
    const adjustCountForSelf = countSelf && !this.removed_from_conversation() ? 1 : 0;
    const adjustCountForServices = countServices ? 0 : this.getNumberOfServices();

    return this.participating_user_ids().length + adjustCountForSelf - adjustCountForServices;
  }

  getNumberOfClients() {
    const participantsMapped = this.participating_user_ids().length === this.participating_user_ets().length;
    if (participantsMapped) {
      return this.participating_user_ets().reduce((accumulator, userEntity) => {
        return userEntity.devices().length
          ? accumulator + userEntity.devices().length
          : accumulator + z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
      }, this.selfUser().devices().length);
    }

    return this.getNumberOfParticipants() * z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
  }

  /**
   * Prepends messages with new batch of messages.
   * @param {Array<z.entity.Message>} message_ets - Array of messages to be added to conversation
   * @returns {undefined} No return value
   */
  prepend_messages(message_ets) {
    message_ets = message_ets.map(message_et => this._checkForDuplicate(message_et)).filter(message_et => message_et);

    z.util.koArrayUnshiftAll(this.messages_unordered, message_ets);
  }

  /**
   * Removes message from the conversation by message id.
   * @param {string} message_id - ID of the message entity to be removed from the conversation
   * @returns {undefined} No return value
   */
  remove_message_by_id(message_id) {
    this.messages_unordered.remove(message_et => message_id && message_id === message_et.id);
  }

  /**
   * Removes messages from the conversation.
   * @param {number} [timestamp] - Optional timestamp which messages should be removed
   * @returns {undefined} No return value
   */
  remove_messages(timestamp) {
    if (timestamp && _.isNumber(timestamp)) {
      return this.messages_unordered.remove(message_et => timestamp >= message_et.timestamp());
    }
    this.messages_unordered.removeAll();
  }

  shouldUnarchive() {
    if (!this.archivedState() || this.showNotificationsNothing()) {
      return false;
    }

    const isNewerMessage = messageEntity => messageEntity.timestamp() > this.archivedTimestamp();

    const {allEvents, allMessages, selfMentions, selfReplies} = this.unreadState();
    if (this.showNotificationsMentionsAndReplies()) {
      const mentionsAndReplies = selfMentions.concat(selfReplies);
      return mentionsAndReplies.some(isNewerMessage);
    }

    const hasNewMessage = allMessages.some(isNewerMessage);
    if (hasNewMessage) {
      return true;
    }

    return allEvents.some(messageEntity => {
      if (!isNewerMessage(messageEntity)) {
        return false;
      }

      const isCallActivation = messageEntity.is_call() && messageEntity.is_activation();
      const isMemberJoin = messageEntity.is_member() && messageEntity.isMemberJoin();
      const wasSelfUserAdded = isMemberJoin && messageEntity.isUserAffected(this.selfUser().id);

      return isCallActivation || wasSelfUserAdded;
    });
  }

  /**
   * Checks for message duplicates.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity to be added to the conversation
   * @returns {z.entity.Message|undefined} Message if it is not a duplicate
   */
  _checkForDuplicate(messageEntity) {
    if (messageEntity) {
      const existingMessageEntity = this._findDuplicate(messageEntity.id, messageEntity.from);
      if (existingMessageEntity) {
        const logData = {additionalMessage: messageEntity, existingMessage: existingMessageEntity};
        this.logger.warn(`Filtered message '${messageEntity.id}' as duplicate in view`, logData);
        return undefined;
      }
      return messageEntity;
    }
  }

  _findDuplicate(messageId, from) {
    if (messageId) {
      return this.messages_unordered().find(messageEntity => {
        const sameId = messageEntity.id === messageId;
        const sameSender = messageEntity.from === from;
        return sameId && sameSender;
      });
    }
  }

  update_timestamp_server(time, is_backend_timestamp = false) {
    if (is_backend_timestamp) {
      const timestamp = new Date(time).getTime();

      if (!_.isNaN(timestamp)) {
        this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_SERVER);
      }
    }
  }

  /**
   * Update information about conversation activity from single message.
   *
   * @private
   * @param {z.entity.Message} message_et - Message to be added to conversation
   * @returns {undefined} No return value
   */
  update_timestamps(message_et) {
    if (message_et) {
      const timestamp = message_et.timestamp();

      if (timestamp <= this.last_server_timestamp()) {
        if (message_et.timestamp_affects_order()) {
          this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_EVENT);

          const from_self = message_et.user() && message_et.user().is_me;
          if (from_self) {
            this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ);
          }
        }
      }
    }
  }

  /**
   * Get all messages.
   * @returns {Array<z.entity.Message>} Array of all message in the conversation
   */
  get_all_messages() {
    return this.messages();
  }

  /**
   * Get the first message of the conversation.
   * @returns {z.entity.Message|undefined} First message entity or undefined
   */
  getFirstMessage() {
    return this.messages()[0];
  }

  /**
   * Get the last message of the conversation.
   * @returns {z.entity.Message|undefined} Last message entity or undefined
   */
  getLastMessage() {
    return this.messages()[this.messages().length - 1];
  }

  /**
   * Get the message before a given message.
   * @param {z.entity.Message} message_et - Message to look up from
   * @returns {z.entity.Message | undefined} Previous message
   */
  get_previous_message(message_et) {
    const messages_visible = this.messages_visible();
    const message_index = messages_visible.indexOf(message_et);
    if (message_index > 0) {
      return messages_visible[message_index - 1];
    }
  }

  /**
   * Get the last text message that was added by self user.
   * @returns {z.entity.Message} Last message edited
   */
  get_last_editable_message() {
    const messages = this.messages();
    for (let index = messages.length - 1; index >= 0; index--) {
      const message_et = messages[index];
      if (message_et.is_editable()) {
        return message_et;
      }
    }
  }

  /**
   * Get the last delivered message.
   * @returns {z.entity.Message} Last delivered message
   */
  getLastDeliveredMessage() {
    return this.messages()
      .slice()
      .reverse()
      .find(messageEntity => {
        const isDelivered = messageEntity.status() === z.message.StatusType.DELIVERED;
        return isDelivered && messageEntity.user().is_me;
      });
  }

  /**
   * Get a message by it's unique ID.
   * Only lookup in the loaded message list which is a limited view of all the messages in DB.
   *
   * @param {string} messageId - ID of message to be retrieved
   * @returns {z.entity.Message|undefined} Message with ID or undefined
   */
  getMessage(messageId) {
    return this.messages().find(messageEntity => messageEntity.id === messageId);
  }

  /**
   * Get Number of pending uploads for this conversation.
   * @returns {number} Count of pending uploads
   */
  get_number_of_pending_uploads() {
    const pendingUploads = [];

    for (const messageEntity of this.messages()) {
      const [assetEntity] = (messageEntity.assets && messageEntity.assets()) || [];
      const isPendingUpload = assetEntity && assetEntity.pending_upload && assetEntity.pending_upload();
      if (isPendingUpload) {
        pendingUploads.push(messageEntity);
      }
    }

    return pendingUploads.length;
  }

  updateGuests() {
    this.getTemporaryGuests().forEach(userEntity => userEntity.checkGuestExpiration());
  }

  getTemporaryGuests() {
    const userEntities = this.selfUser()
      ? this.participating_user_ets().concat(this.selfUser())
      : this.participating_user_ets();
    return userEntities.filter(userEntity => userEntity.isTemporaryGuest());
  }

  getUsersWithUnverifiedClients() {
    const userEntities = this.selfUser()
      ? this.participating_user_ets().concat(this.selfUser())
      : this.participating_user_ets();
    return userEntities.filter(userEntity => !userEntity.is_verified());
  }

  supportsVideoCall(isCreatingUser = false) {
    if (this.is1to1()) {
      return true;
    }

    const participantCount = this.getNumberOfParticipants(true, false);
    const passesParticipantLimit = participantCount <= z.calling.CallingRepository.CONFIG.MAX_VIDEO_PARTICIPANTS;

    if (!passesParticipantLimit) {
      return false;
    }

    if (this.selfUser().inTeam()) {
      return true;
    }

    if (isCreatingUser) {
      return false;
    }

    return this.call() && this.call().isRemoteVideoCall();
  }

  serialize() {
    return {
      archived_state: this.archivedState(),
      archived_timestamp: this.archivedTimestamp(),
      cleared_timestamp: this.cleared_timestamp(),
      ephemeral_timer: this.localMessageTimer(),
      global_message_timer: this.globalMessageTimer(),
      id: this.id,
      is_guest: this.isGuest(),
      is_managed: this.isManaged,
      last_event_timestamp: this.last_event_timestamp(),
      last_read_timestamp: this.last_read_timestamp(),
      last_server_timestamp: this.last_server_timestamp(),
      muted_state: this.mutedState(),
      muted_timestamp: this.mutedTimestamp(),
      name: this.name(),
      others: this.participating_user_ids(),
      status: this.status(),
      team_id: this.team_id,
      type: this.type(),
      verification_state: this.verification_state(),
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.AvailabilityContextMenu = {
  show: (event, method, elementName) => {
    const entries = [
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.NONE, method),
        label: z.l10n.text(z.string.userAvailabilityNone),
        title: z.l10n.text(z.string.userAvailabilityNone),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.AVAILABLE, method),
        label: z.l10n.text(z.string.userAvailabilityAvailable),
        title: z.l10n.text(z.string.userAvailabilityAvailable),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.BUSY, method),
        label: z.l10n.text(z.string.userAvailabilityBusy),
        title: z.l10n.text(z.string.userAvailabilityBusy),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.AWAY, method),
        label: z.l10n.text(z.string.userAvailabilityAway),
        title: z.l10n.text(z.string.userAvailabilityAway),
      },
    ];

    z.ui.Context.from(event, entries, elementName);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Context = (() => {
  const _addListeners = () => {
    window.addEventListener('wheel', _onWheel);
    window.addEventListener('keydown', _onKeyDown);
    window.addEventListener('mousedown', _onMouseDown);
    window.addEventListener('resize', _cleanup);
  };

  const _onKeyDown = keyboardEvent => {
    keyboardEvent.preventDefault();

    if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
      return _cleanup();
    }

    const expectedKeys = [z.util.KeyboardUtil.KEY.ARROW_UP, z.util.KeyboardUtil.KEY.ARROW_DOWN];

    if (z.util.KeyboardUtil.isOneOfKeys(keyboardEvent, expectedKeys)) {
      return _rotateItem(keyboardEvent.key);
    }

    if (z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
      _triggerItem();
    }
  };

  const _onMouseDown = event => {
    const entry = document.querySelector('.ctx-menu');
    const shouldCloseMenu = entry && !entry.contains(event.target);
    if (shouldCloseMenu) {
      _cleanup();
    }
  };

  const _onWheel = event => event.preventDefault();

  const _rotateItem = key => {
    const entries = Array.from(document.querySelectorAll('.ctx-menu-item'));
    const entry = document.querySelector('.ctx-menu-item.selected');

    if (entries.length) {
      if (!entry) {
        const index = key === z.util.KeyboardUtil.KEY.ARROW_UP ? entries.length - 1 : 0;
        return entries[index].classList.add('selected');
      }

      const direction = key === z.util.KeyboardUtil.KEY.ARROW_UP ? -1 : 1;
      const nextIndext = (entries.indexOf(entry) + direction + entries.length) % entries.length;
      const nextEntry = entries[nextIndext];

      nextEntry.classList.add('selected');
      entry.classList.remove('selected');
    }
  };

  const _removeListeners = () => {
    window.removeEventListener('wheel', _onWheel);
    window.removeEventListener('keydown', _onKeyDown);
    window.removeEventListener('mousedown', _onMouseDown);
    window.removeEventListener('resize', _cleanup);
  };

  const _triggerItem = () => {
    const entry = document.querySelector('.ctx-menu-item.selected');
    if (entry) {
      entry.click();
    }
  };

  const _cleanup = () => {
    Array.from(document.querySelectorAll('.ctx-menu')).forEach(menu => menu.remove());
    _removeListeners();
  };

  const _build = (entries, identifier) => {
    const menu = document.createElement('div');
    menu.classList.add('ctx-menu');

    entries.forEach(entry => {
      const element = document.createElement('div');
      element.setAttribute('data-uie-name', identifier || 'ctx-menu');
      element.setAttribute('title', entry.title || entry.label || '');
      element.classList.add('ctx-menu-item');
      element.innerText = entry.label;

      element.onclick = event => {
        event.stopPropagation();
        _cleanup();
        entry.click();
      };

      element.onmouseenter = () => {
        const selectedEntry = document.querySelector('.ctx-menu-item.selected');
        if (selectedEntry) {
          selectedEntry.classList.remove('selected');
        }
      };

      menu.appendChild(element);
    });

    return menu;
  };

  return {
    /**
     * Build and display custom context menu
     * @param {Event} event - menu will appear at currentTarget position
     * @param {Array} entries - configuration to build the menu {label: 'label', click: function() {}}
     * @param {string} identifier - data-uie-name added to all entries
     * @returns {undefined}
     */
    from: (event, entries, identifier) => {
      event.preventDefault();
      event.stopPropagation();

      _cleanup();

      const clickX = event.clientX;
      const clickY = event.clientY;

      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      const menu = _build(entries, identifier);
      menu.style.visibility = 'hidden';
      document.body.appendChild(menu);

      const menuWidth = menu.offsetWidth;
      const menuHeight = menu.offsetHeight;

      menu.style.left = `${windowWidth - clickX < menuWidth ? clickX - menuWidth : clickX}px`;
      menu.style.top = `${windowHeight - clickY < menuHeight ? clickY - menuHeight : clickY}px`;
      menu.style.visibility = '';

      _addListeners();
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Modal = class Modal {
  static get CLASS() {
    return {
      FADE_IN: 'modal-fadein',
      SHOW: 'modal-show',
    };
  }

  constructor(modal, hideCallback, beforeHideCallback) {
    this._hide = this._hide.bind(this);
    this.handleClick = this.handleClick.bind(this);

    this.modal = typeof modal === 'string' ? document.querySelector(modal) : modal;
    this.hideCallback = hideCallback;
    this.beforeHideCallback = beforeHideCallback;

    this.autoclose = true;

    keyboardJS.bind('esc', this._hide);

    if (this.modal) {
      this.modal.addEventListener('click', this.handleClick);
    }
  }

  handleClick(event) {
    if (event.target === this.modal) {
      this._hide();
    }
  }

  _hide() {
    if (this.autoclose) {
      this.hide();
    }
  }

  show() {
    if (this.modal) {
      this.modal.classList.add(Modal.CLASS.SHOW);
      setTimeout(() => this.modal.classList.add(Modal.CLASS.FADE_IN), 50);
    }
  }

  hide(callback) {
    this.callOptional(this.beforeHideCallback);

    if (this.modal) {
      this.modal.classList.remove(Modal.CLASS.FADE_IN);
      const transitionendPromise = new Promise(resolve => this.modal.addEventListener('transitionend', resolve));
      const timeoutPromise = new Promise(resolve => {
        const {transitionDelay, transitionDuration} = getComputedStyle(this.modal, '::before');

        const delays = transitionDelay.split(',').map(parseFloat);
        const durations = transitionDuration.split(',').map(parseFloat);

        const totals = delays.map((delay, index) => delay + durations[index]);
        const longestDelay = Math.max(...totals);

        setTimeout(resolve, longestDelay * 1000);
      });

      Promise.race([transitionendPromise, timeoutPromise]).then(() => {
        if (this.modal) {
          this.modal.classList.remove(Modal.CLASS.SHOW);
        }
        this.callOptional(this.hideCallback);
        this.callOptional(callback);
      });
    }
  }

  callOptional(fn) {
    if (typeof fn === 'function') {
      return fn();
    }
  }

  toggle() {
    if (this.isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }

  isShown() {
    return !!this.modal && this.modal.classList.contains(Modal.CLASS.SHOW);
  }

  isHidden() {
    return !this.isShown();
  }

  setAutoclose(autoclose) {
    this.autoclose = autoclose;
  }

  destroy() {
    if (this.modal) {
      this.modal.removeEventListener('click', this.handleClick);
    }
    keyboardJS.unbind('esc', this._hide);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

/**
 * Keeps track of elements that are overlayed by other elemenst (thus not visible on screen).
 *
 */
z.ui.OverlayedObserver = (() => {
  // keeps track of all the elements we need to check when there is a mutation
  const overlayedElements = new Map();

  const checkOverlayedElements = mutations => {
    mutations.forEach(({removedNodes}) => {
      if (removedNodes && removedNodes.length) {
        overlayedElements.forEach((onVisible, element) => {
          if (!isOverlayed(element)) {
            onVisible();
            removeElement(element);
          }
        });
      }
    });
  };

  const mutationObserver = new MutationObserver(checkOverlayedElements);

  /**
   * Returns true if an element is above the element being watched.
   *
   * @param {HTMLElement} domElement - the element we want to check.
   * @returns {boolean} Is the element overlayed.
   */
  const isOverlayed = domElement => {
    const box = domElement.getBoundingClientRect();
    const middlePointX = (box.right + box.left) / 2;
    const middlePointY = (box.bottom + box.top) / 2;
    const elementAtPoint = document.elementFromPoint(middlePointX, middlePointY);
    return elementAtPoint && domElement !== elementAtPoint && !domElement.contains(elementAtPoint);
  };

  const addElement = (element, onVisible) => {
    if (!isOverlayed(element)) {
      return onVisible();
    }
    if (overlayedElements.size === 0) {
      mutationObserver.observe(document.body, {childList: true, subtree: true});
    }
    overlayedElements.set(element, onVisible);
  };

  const removeElement = element => {
    overlayedElements.delete(element);
    if (overlayedElements.size < 1) {
      mutationObserver.disconnect();
    }
  };

  return {onElementVisible: addElement, removeElement};
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.ShortcutType = {
  ADD_PEOPLE: 'add_people',
  ARCHIVE: 'archive',
  CALL_MUTE: 'mute_call',
  CALL_REJECT: 'reject',
  DEBUG: 'debug',
  NEXT: 'next',
  NOTIFICATIONS: 'notifications',
  PEOPLE: 'people',
  PING: 'ping',
  PREV: 'prev',
  START: 'start',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Shortcut = (() => {
  const SHORTCUT_MAP = {
    [z.ui.ShortcutType.ADD_PEOPLE]: {
      event: z.event.WebApp.SHORTCUT.ADD_PEOPLE,
      shortcut: {
        electron: {
          macos: 'command + shift + k',
          menu: true,
          pc: 'ctrl + shift + k',
        },
        webapp: {
          macos: 'command + shift + k',
          pc: 'ctrl + shift + k',
        },
      },
    },
    [z.ui.ShortcutType.ARCHIVE]: {
      event: z.event.WebApp.SHORTCUT.ARCHIVE,
      shortcut: {
        electron: {
          macos: 'command + d',
          menu: true,
          pc: 'ctrl + d',
        },
        webapp: {
          macos: 'command + alt + shift + d',
          pc: 'ctrl + alt + d',
        },
      },
    },
    [z.ui.ShortcutType.PREV]: {
      event: z.event.WebApp.SHORTCUT.PREV,
      shortcut: {
        electron: {
          macos: 'command + alt + down',
          menu: true,
          pc: 'alt + shift + down',
        },
        webapp: {
          macos: 'command + alt + down',
          pc: 'alt + shift + down',
        },
      },
    },
    [z.ui.ShortcutType.NEXT]: {
      event: z.event.WebApp.SHORTCUT.NEXT,
      shortcut: {
        electron: {
          macos: 'command + alt + up',
          menu: true,
          pc: 'alt + shift + up',
        },
        webapp: {
          macos: 'command + alt + up',
          pc: 'alt + shift + up',
        },
      },
    },
    [z.ui.ShortcutType.NOTIFICATIONS]: {
      event: z.event.WebApp.SHORTCUT.SILENCE,
      shortcut: {
        electron: {
          macos: 'command + alt + m',
          menu: true,
          pc: 'ctrl + alt + m',
        },
        webapp: {
          macos: 'command + alt + m',
          pc: 'ctrl + alt + m',
        },
      },
    },
    [z.ui.ShortcutType.PING]: {
      event: z.event.WebApp.SHORTCUT.PING,
      shortcut: {
        electron: {
          macos: 'command + k',
          menu: true,
          pc: 'ctrl + k',
        },
        webapp: {
          macos: 'command + alt + k',
          pc: 'ctrl + alt + k',
        },
      },
    },
    [z.ui.ShortcutType.PEOPLE]: {
      event: z.event.WebApp.SHORTCUT.PEOPLE,
      shortcut: {
        electron: {
          macos: 'command + i',
          menu: true,
          pc: 'ctrl + i',
        },
        webapp: {
          macos: 'command + alt + shift + i',
          pc: 'ctrl + alt + i',
        },
      },
    },
    [z.ui.ShortcutType.START]: {
      event: z.event.WebApp.SHORTCUT.START,
      shortcut: {
        electron: {
          macos: 'command + n',
          menu: true,
          pc: 'ctrl + n',
        },
        webapp: {
          macos: 'command + alt + graveaccent', // KeyboardJS fires this when using cmd + alt + n
          pc: 'ctrl + alt + ,',
        },
      },
    },
  };

  const _registerEvent = (platformSpecificShortcut, event) => {
    // bind also 'command + alt + n' for start shortcut
    if (z.util.StringUtil.includes(platformSpecificShortcut, 'graveaccent')) {
      const replacedShortcut = platformSpecificShortcut.replace('graveaccent', 'n');
      _registerEvent(replacedShortcut, event);
    }

    return keyboardJS.on(platformSpecificShortcut, inputEvent => {
      keyboardJS.releaseKey(inputEvent.keyCode);

      // Hotfix WEBAPP-1916
      const ignoreEvent = z.util.StringUtil.includes(platformSpecificShortcut, 'command') && !inputEvent.metaKey;
      if (!ignoreEvent) {
        inputEvent.preventDefault();
        amplify.publish(event);
      }
    });
  };

  const _getBeautifiedShortcutMac = shortcut => {
    return shortcut
      .replace(/\+/g, '')
      .replace(/\s+/g, '')
      .replace('alt', '')
      .replace('command', '')
      .replace('shift', '')
      .replace('up', '')
      .replace('down', '')
      .replace('graveaccent', 'n')
      .toUpperCase();
  };

  const _getBeautifiedShortcutWin = shortcut => {
    return shortcut
      .replace('up', '')
      .replace('down', '')
      .replace('graveaccent', 'n')
      .replace(/\w+/g, string => z.util.StringUtil.capitalizeFirstChar(string));
  };

  const _getShortcut = shortcutName => {
    const platform = z.util.Environment.desktop ? 'electron' : 'webapp';
    const platformShortcuts = SHORTCUT_MAP[shortcutName].shortcut[platform];
    return z.util.Environment.os.mac ? platformShortcuts.macos : platformShortcuts.pc;
  };

  const _getShortcutTooltip = shortcutName => {
    const shortcut = _getShortcut(shortcutName);
    if (shortcut) {
      return z.util.Environment.os.mac ? _getBeautifiedShortcutMac(shortcut) : _getBeautifiedShortcutWin(shortcut);
    }
  };

  const _init = () => {
    for (const shortcut in SHORTCUT_MAP) {
      const shortcutData = SHORTCUT_MAP[shortcut];
      const isMenuShortcut = z.util.Environment.desktop && shortcutData.shortcut.electron.menu;

      if (!isMenuShortcut) {
        _registerEvent(_getShortcut(shortcut), shortcutData.event);
      }
    }
  };

  _init();

  return {
    getBeautifiedShortcutMac: _getBeautifiedShortcutMac,
    getBeautifiedShortcutWin: _getBeautifiedShortcutWin,
    getShortcut: _getShortcut,
    getShortcutTooltip: _getShortcutTooltip,
    shortcutMap: SHORTCUT_MAP,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.ViewportObserver = (() => {
  const observedElements = new Map();
  const intersectionObserver = (() => {
    const onIntersect = entries => {
      entries.forEach(({isIntersecting, target: element}) => {
        if (isIntersecting) {
          intersectionObserver.unobserve(element);

          const onElementIntersects = observedElements.get(element);
          if (onElementIntersects) {
            onElementIntersects();
            _removeElement(element);
          }
        }
      });
    };

    const options = {root: null, rootMargin: '0px', threshold: 0.0};
    return new IntersectionObserver(onIntersect, options);
  })();

  const _addElement = (element, callback) => {
    observedElements.set(element, callback);
    intersectionObserver.observe(element);
  };

  const _removeElement = element => {
    observedElements.delete(element);
    intersectionObserver.unobserve(element);
  };

  return {
    addElement: _addElement,
    removeElement: _removeElement,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.WindowHandler = class WindowHandler {
  constructor() {
    this.init = this.init.bind(this);
    this.logger = new z.util.Logger('z.ui.WindowHandler', z.config.LOGGER.OPTIONS);

    this.height = 0;
    this.width = 0;

    this.isVisible = true;

    return this;
  }

  init() {
    this.width = $(window).width();
    this.height = $(window).height();
    this._listenToUnhandledPromiseRejection();

    document.addEventListener('visibilitychange', () => {
      const isVisible = document.visibilityState === 'visible';
      this.logger.info(`Webapp is ${isVisible ? 'visible' : 'hidden'}`);
    });

    return this;
  }

  _listenToUnhandledPromiseRejection() {
    $(window).on('unhandledrejection', event => {
      const promiseRejectionEvent = event.originalEvent;
      const error = promiseRejectionEvent.reason || {};

      const isDegraded = error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
      if (isDegraded) {
        this.logger.log('User has canceled sending a message to a degraded conversation.');
        promiseRejectionEvent.preventDefault();
        promiseRejectionEvent.stopPropagation();
        return false;
      }
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

//@ts-check

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.SingleInstanceHandler = (() => {
  let checkIntervalId = undefined;

  const CONFIG = {
    COOKIE_NAME: 'app_opened',
    INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
  };

  return class SingleInstanceHandler {
    /**
     * Class responsible for checking that only the current instance of the app is running.
     *
     * @param {function=} onOtherInstanceStarted - A callback to be called if another instance starts.
     *    If provided, will also run an interval that checks the instance integrity once an instance is registrated
     */
    constructor(onOtherInstanceStarted) {
      this.instanceId = undefined;
      this.onOtherInstanceStarted = onOtherInstanceStarted;
    }

    /**
     * Set the cookie to verify we are running a single instace tab.
     * Returns true if the instance has been registered successfully.
     * Returns false if the app is already running in another instance.
     *
     * Side Effects: will also start the interval check if a callback was provided in the constructor
     *
     * @param {string} instanceId - The instance id to register.
     * @returns {boolean} - Has the app being registered successfully.
     */
    registerInstance(instanceId) {
      this.instanceId = instanceId;
      const cookieName = CONFIG.COOKIE_NAME;
      if (!!Cookies.get(cookieName)) {
        return false;
      }
      Cookies.set(cookieName, {appInstanceId: this.instanceId});
      if (this.onOtherInstanceStarted) {
        this._startSingleInstanceCheck();
      }
      return true;
    }

    /**
     * Removes the cookie that keeps track of the running instance.
     *
     * Side Effects: will also stop the interval check
     *
     * @param {boolean} forceRemoval - Do not check that the instance removing it is the current instance.
     * @returns {void} - Returns nothing.
     */
    deregisterInstance(forceRemoval = false) {
      const singleInstanceCookie = Cookies.getJSON(CONFIG.COOKIE_NAME);

      const isOwnInstanceId = singleInstanceCookie && singleInstanceCookie.appInstanceId === this.instanceId;
      if (forceRemoval || isOwnInstanceId) {
        Cookies.remove(CONFIG.COOKIE_NAME);
        this._stopSingleInstanceCheck();
      }
    }

    /**
     * Returns true if another instance is running.
     * Does not check for the id of the running instance and thus cannot be
     * invoked once the registering of the current instance has been done.
     *
     * @param {Function} listener - A listener to be removed.
     * @throws {Error} - When the current app has already been registered.
     * @returns {void} - Returns nothing.
     */
    hasOtherRunningInstance() {
      if (this.instanceId) {
        throw new Error('Current instance has been registered, cannot check other running instances');
      }

      return !!Cookies.get(CONFIG.COOKIE_NAME);
    }

    _isSingleRunningInstance() {
      if (z.util.Environment.electron) {
        return true;
      }
      const singleInstanceCookie = Cookies.getJSON(CONFIG.COOKIE_NAME);

      return singleInstanceCookie && singleInstanceCookie.appInstanceId === this.instanceId;
    }

    _checkSingleInstance() {
      if (!this._isSingleRunningInstance()) {
        // warn listeners if the app has started in another instance
        this.onOtherInstanceStarted();
      }
    }

    _startSingleInstanceCheck() {
      this._stopSingleInstanceCheck();
      checkIntervalId = window.setInterval(this._checkSingleInstance.bind(this), CONFIG.INTERVAL);
    }

    _stopSingleInstanceCheck() {
      if (checkIntervalId) {
        window.clearInterval(checkIntervalId);
      }
      checkIntervalId = undefined;
    }
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.App = class App {
  static get CONFIG() {
    return {
      COOKIES_CHECK: {
        COOKIE_NAME: 'cookies_enabled',
      },
      NOTIFICATION_CHECK: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
      SIGN_OUT_REASONS: {
        IMMEDIATE: [
          z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED,
          z.auth.SIGN_OUT_REASON.CLIENT_REMOVED,
          z.auth.SIGN_OUT_REASON.SESSION_EXPIRED,
        ],
        TEMPORARY_GUEST: [
          z.auth.SIGN_OUT_REASON.MULTIPLE_TABS,
          z.auth.SIGN_OUT_REASON.SESSION_EXPIRED,
          z.auth.SIGN_OUT_REASON.USER_REQUESTED,
        ],
      },
    };
  }

  /**
   * Construct a new app.
   * @param {z.main.Auth} authComponent - Authentication component
   */
  constructor(authComponent) {
    this.backendClient = authComponent.backendClient;
    this.logger = new z.util.Logger('z.main.App', z.config.LOGGER.OPTIONS);

    this.telemetry = new z.telemetry.app_init.AppInitTelemetry();
    this.windowHandler = new z.ui.WindowHandler().init();

    this.service = this._setupServices(authComponent);
    this.repository = this._setupRepositories(authComponent);
    this.view = this._setupViewModels();
    this.util = this._setup_utils();

    this.instanceId = z.util.createRandomUuid();

    this._onExtraInstanceStarted = this._onExtraInstanceStarted.bind(this);
    this.singleInstanceHandler = new z.main.SingleInstanceHandler(this._onExtraInstanceStarted);

    this._subscribeToEvents();

    this.initDebugging();
    this.initApp();
    this.initServiceWorker();
  }

  //##############################################################################
  // Instantiation
  //##############################################################################

  /**
   * Create all app repositories.
   * @param {z.main.Auth} authComponent - Authentication component
   * @returns {Object} All repositories
   */
  _setupRepositories(authComponent) {
    const repositories = {};

    repositories.audio = authComponent.audio;
    repositories.auth = authComponent.repository;
    repositories.cache = new z.cache.CacheRepository();
    repositories.giphy = new z.extension.GiphyRepository(this.service.giphy);
    repositories.location = new z.location.LocationRepository(this.service.location);
    repositories.permission = new z.permission.PermissionRepository();
    repositories.serverTime = new z.time.ServerTimeRepository();
    repositories.storage = new z.storage.StorageRepository(this.service.storage);

    repositories.cryptography = new z.cryptography.CryptographyRepository(
      this.service.cryptography,
      repositories.storage
    );
    repositories.client = new z.client.ClientRepository(this.service.client, repositories.cryptography);
    repositories.media = new z.media.MediaRepository(repositories.permission);
    repositories.user = new z.user.UserRepository(
      this.service.user,
      this.service.asset,
      this.service.self,
      repositories.client,
      repositories.serverTime
    );
    repositories.connection = new z.connection.ConnectionRepository(this.service.connection, repositories.user);
    repositories.event = new z.event.EventRepository(
      this.service.event,
      this.service.notification,
      this.service.webSocket,
      this.service.conversation,
      repositories.cryptography,
      repositories.serverTime,
      repositories.user
    );
    repositories.properties = new z.properties.PropertiesRepository(this.service.properties);
    repositories.lifecycle = new z.lifecycle.LifecycleRepository(this.service.lifecycle, repositories.user);
    repositories.connect = new z.connect.ConnectRepository(this.service.connect, repositories.properties);
    repositories.links = new z.links.LinkPreviewRepository(this.service.asset, repositories.properties);
    repositories.search = new z.search.SearchRepository(this.service.search, repositories.user);
    repositories.team = new z.team.TeamRepository(this.service.team, repositories.user);
    repositories.eventTracker = new z.tracking.EventTrackingRepository(repositories.team, repositories.user);

    repositories.conversation = new z.conversation.ConversationRepository(
      this.service.conversation,
      this.service.asset,
      repositories.client,
      repositories.connection,
      repositories.cryptography,
      repositories.event,
      repositories.giphy,
      repositories.links,
      repositories.serverTime,
      repositories.team,
      repositories.user
    );

    const serviceMiddleware = new z.event.preprocessor.ServiceMiddleware(repositories.conversation, repositories.user);
    const quotedMessageMiddleware = new z.event.preprocessor.QuotedMessageMiddleware(
      this.service.event,
      z.message.MessageHasher
    );
    repositories.event.setEventProcessMiddlewares([
      serviceMiddleware.processEvent.bind(serviceMiddleware),
      quotedMessageMiddleware.processEvent.bind(quotedMessageMiddleware),
    ]);
    repositories.backup = new z.backup.BackupRepository(
      this.service.backup,
      repositories.client,
      repositories.connection,
      repositories.conversation,
      repositories.user
    );
    repositories.broadcast = new z.broadcast.BroadcastRepository(
      this.service.broadcast,
      repositories.client,
      repositories.conversation,
      repositories.cryptography,
      repositories.user
    );
    repositories.calling = new z.calling.CallingRepository(
      this.service.calling,
      repositories.client,
      repositories.conversation,
      repositories.event,
      repositories.media,
      repositories.serverTime,
      repositories.user
    );
    repositories.integration = new z.integration.IntegrationRepository(
      this.service.integration,
      repositories.conversation,
      repositories.team
    );
    repositories.notification = new z.notification.NotificationRepository(
      repositories.calling,
      repositories.conversation,
      repositories.permission,
      repositories.user
    );
    repositories.videoGrid = new z.calling.VideoGridRepository(repositories.calling, repositories.media);

    return repositories;
  }

  /**
   * Create all app services.
   * @param {z.main.Auth} authComponent - Authentication component
   * @returns {Object} All services
   */
  _setupServices(authComponent) {
    const storageService = new z.storage.StorageService();
    const eventService = z.util.Environment.browser.edge
      ? new z.event.EventServiceNoCompound(storageService)
      : new z.event.EventService(storageService);

    return {
      asset: new z.assets.AssetService(this.backendClient),
      auth: authComponent.service,
      backup: new z.backup.BackupService(storageService),
      broadcast: new z.broadcast.BroadcastService(this.backendClient),
      calling: new z.calling.CallingService(this.backendClient),
      client: new z.client.ClientService(this.backendClient, storageService),
      connect: new z.connect.ConnectService(this.backendClient),
      connection: new z.connection.ConnectionService(this.backendClient),
      conversation: new z.conversation.ConversationService(this.backendClient, eventService, storageService),
      cryptography: new z.cryptography.CryptographyService(this.backendClient),
      event: eventService,
      giphy: new z.extension.GiphyService(this.backendClient),
      integration: new z.integration.IntegrationService(this.backendClient),
      lifecycle: new z.lifecycle.LifecycleService(),
      location: new z.location.LocationService(this.backendClient),
      notification: new z.event.NotificationService(this.backendClient, storageService),
      properties: new z.properties.PropertiesService(this.backendClient),
      search: new z.search.SearchService(this.backendClient),
      self: new z.self.SelfService(this.backendClient),
      storage: storageService,
      team: new z.team.TeamService(this.backendClient),
      user: new z.user.UserService(this.backendClient, storageService),
      webSocket: new z.event.WebSocketService(this.backendClient),
    };
  }

  /**
   * Create all app utils.
   * @returns {Object} All utils
   */
  _setup_utils() {
    return window.wire.env.FEATURE.ENABLE_DEBUG ? {debug: new z.util.DebugUtil(this.repository)} : {};
  }

  /**
   * Create all app view models.
   * @returns {Object} All view models
   */
  _setupViewModels() {
    return new z.viewModel.MainViewModel(this.repository);
  }

  /**
   * Subscribe to amplify events.
   * @returns {undefined} No return value
   */
  _subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.LIFECYCLE.REFRESH, this.refresh.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.SIGN_OUT, this.logout.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.UPDATE, this.update.bind(this));
  }

  //##############################################################################
  // Initialization
  //##############################################################################

  /**
   * Initialize the app.
   *
   * @note Locally known clients and sessions must not be touched until after the notification stream has been handled.
   *   Any failure in the Promise chain will result in a logout.
   * @todo Check if we really need to logout the user in all these error cases or how to recover from them
   *
   * @param {boolean} [isReload=_isReload()] - App init after page reload
   * @returns {undefined} No return value
   */
  initApp(isReload = this._isReload()) {
    z.util
      .checkIndexedDb()
      .then(() => this._registerSingleInstance())
      .then(() => this._loadAccessToken())
      .then(() => {
        this.view.loading.updateProgress(2.5);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_ACCESS_TOKEN);

        const protoFile = `ext/proto/@wireapp/protocol-messaging/messages.proto?${z.util.Environment.version(false)}`;
        return Promise.all([this._initiateSelfUser(), z.util.protobuf.loadProtos(protoFile)]);
      })
      .then(() => {
        this.view.loading.updateProgress(5, z.string.initReceivedSelfUser);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_SELF_USER);
        return this._initiateSelfUserClients();
      })
      .then(clientEntity => {
        this.view.loading.updateProgress(7.5, z.string.initValidatedClient);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.VALIDATED_CLIENT);
        this.telemetry.add_statistic(z.telemetry.app_init.AppInitStatisticsValue.CLIENT_TYPE, clientEntity.type);

        return this.repository.cryptography.loadCryptobox(this.service.storage.db);
      })
      .then(() => {
        this.view.loading.updateProgress(10);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.INITIALIZED_CRYPTOGRAPHY);

        this.repository.event.connectWebSocket();

        const promises = [this.repository.conversation.getConversations(), this.repository.connection.getConnections()];
        return Promise.all(promises);
      })
      .then(([conversationEntities, connectionEntities]) => {
        this.view.loading.updateProgress(25, z.string.initReceivedUserData);

        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_USER_DATA);
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.CONVERSATIONS,
          conversationEntities.length,
          50
        );
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.CONNECTIONS,
          connectionEntities.length,
          50
        );

        this.repository.conversation.map_connections(this.repository.connection.connectionEntities());
        this._subscribeToUnloadEvents();

        return this.repository.team.getTeam();
      })
      .then(() => this.repository.user.loadUsers())
      .then(() => this.repository.event.initializeFromStream())
      .then(notificationsCount => {
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.UPDATED_FROM_NOTIFICATIONS);
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.NOTIFICATIONS,
          notificationsCount,
          100
        );

        this.repository.eventTracker.init(this.repository.properties.properties.settings.privacy.improve_wire);
        return this.repository.conversation.initialize_conversations();
      })
      .then(() => {
        this.view.loading.updateProgress(97.5, z.string.initUpdatedFromNotifications);

        this._watchOnlineStatus();
        return this.repository.client.updateClientsForSelf();
      })
      .then(clientEntities => {
        this.view.loading.updateProgress(99);

        this.telemetry.add_statistic(z.telemetry.app_init.AppInitStatisticsValue.CLIENTS, clientEntities.length);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.APP_PRE_LOADED);

        this.repository.user.self().devices(clientEntities);
        this.logger.info('App pre-loading completed');
        return this._handleUrlParams();
      })
      .then(() => {
        this._showInterface();
        this.telemetry.report();
        amplify.publish(z.event.WebApp.LIFECYCLE.LOADED);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.APP_LOADED);
        return this.repository.conversation.updateConversationsOnAppInit();
      })
      .then(() => {
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.UPDATED_CONVERSATIONS);
        this.repository.lifecycle.init();
        this.repository.audio.init(true);
        this.repository.conversation.cleanup_conversations();
        this.logger.info('App fully loaded');
      })
      .catch(error => this._appInitFailure(error, isReload));
  }

  /**
   * Initialize ServiceWorker if supported.
   * @returns {undefined} No return value
   */
  initServiceWorker() {
    if (navigator.serviceWorker) {
      navigator.serviceWorker
        .register(`/sw.js?${z.util.Environment.version(false)}`)
        .then(({scope}) => this.logger.info(`ServiceWorker registration successful with scope: ${scope}`));
    }
  }

  /**
   * Behavior when internet connection is re-established.
   * @returns {undefined} No return value
   */
  onInternetConnectionGained() {
    this.logger.info('Internet connection regained. Re-establishing WebSocket connection...');
    this.backendClient
      .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.CONNECTION_REGAINED)
      .then(() => {
        amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.NO_INTERNET);
        amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        this.repository.event.reconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.ONLINE);
      });
  }

  /**
   * Reflect internet connection loss in the UI.
   * @returns {undefined} No return value
   */
  onInternetConnectionLost() {
    this.logger.warn('Internet connection lost');
    this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.OFFLINE);
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NO_INTERNET);
  }

  _appInitFailure(error, isReload) {
    let logMessage = `Could not initialize app version '${z.util.Environment.version(false)}'`;
    if (z.util.Environment.desktop) {
      logMessage = `${logMessage} - Electron '${platform.os.family}' '${z.util.Environment.version()}'`;
    }
    this.logger.info(logMessage, {error});

    const {message, type} = error;
    const isAuthError = error instanceof z.error.AuthError;
    if (isAuthError) {
      const isTypeMultipleTabs = type === z.error.AuthError.TYPE.MULTIPLE_TABS;
      const signOutReason = isTypeMultipleTabs
        ? z.auth.SIGN_OUT_REASON.MULTIPLE_TABS
        : z.auth.SIGN_OUT_REASON.INDEXED_DB;
      return this._redirectToLogin(signOutReason);
    }

    this.logger.debug(
      `App reload: '${isReload}', Document referrer: '${document.referrer}', Location: '${window.location.href}'`
    );
    if (isReload) {
      const isSessionExpired = [
        z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN,
        z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE,
      ];

      if (isSessionExpired.includes(type)) {
        this.logger.error(`Session expired on page reload: ${message}`, error);
        Raygun.send(new Error('Session expired on page reload', error));
        return this._redirectToLogin(z.auth.SIGN_OUT_REASON.SESSION_EXPIRED);
      }

      const isAccessTokenError = error instanceof z.error.AccessTokenError;
      const isInvalidClient = type === z.error.ClientError.TYPE.NO_VALID_CLIENT;

      if (isAccessTokenError || isInvalidClient) {
        this.logger.warn('Connectivity issues. Trigger reload on regained connectivity.', error);
        const triggerSource = isAccessTokenError
          ? z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_RETRIEVAL
          : z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.APP_INIT_RELOAD;
        return this.backendClient.executeOnConnectivity(triggerSource).then(() => window.location.reload(false));
      }
    }

    if (navigator.onLine) {
      switch (type) {
        case z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE:
        case z.error.AccessTokenError.TYPE.RETRIES_EXCEEDED:
        case z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN: {
          this.logger.warn(`Redirecting to login: ${error.message}`, error);
          return this._redirectToLogin(z.auth.SIGN_OUT_REASON.NOT_SIGNED_IN);
        }

        default: {
          this.logger.error(`Caused by: ${(error ? error.message : undefined) || error}`, error);

          const isAccessTokenError = error instanceof z.error.AccessTokenError;
          if (isAccessTokenError) {
            this.logger.error(`Could not get access token: ${error.message}. Logging out user.`, error);
          } else {
            Raygun.send(error);
          }

          return this.logout(z.auth.SIGN_OUT_REASON.APP_INIT);
        }
      }
    }

    this.logger.warn('No connectivity. Trigger reload on regained connectivity.', error);
    this._watchOnlineStatus();
  }

  /**
   * Check whether we need to set different user information (picture, username).
   * @param {z.entity.User} userEntity - Self user entity
   * @returns {z.entity.User} Checked user entity
   */
  _checkUserInformation(userEntity) {
    if (userEntity.hasActivatedIdentity()) {
      if (!userEntity.mediumPictureResource()) {
        this.repository.user.set_default_picture();
      }
      if (!userEntity.username()) {
        this.repository.user.get_username_suggestion();
      }
    }

    return userEntity;
  }

  /**
   * Initiate the self user by getting it from the backend.
   * @returns {Promise<z.entity.User>} Resolves with the self user entity
   */
  _initiateSelfUser() {
    return this.repository.user.getSelf().then(userEntity => {
      this.logger.info(`Loaded self user with ID '${userEntity.id}'`);

      if (!userEntity.hasActivatedIdentity()) {
        this.logger.info('User does not have an activated identity and seems to be a temporary guest');

        if (!userEntity.isTemporaryGuest()) {
          throw new Error('User does not have an activated identity');
        }
      }

      return this.service.storage
        .init(userEntity.id)
        .then(() => this.repository.client.init(userEntity))
        .then(() => this.repository.properties.init(userEntity))
        .then(() => this._checkUserInformation(userEntity));
    });
  }

  /**
   * Initiate the current client of the self user.
   * @returns {Promise<z.client.Client>} Resolves with the local client entity
   */
  _initiateSelfUserClients() {
    return this.repository.client
      .getValidLocalClient()
      .then(clientObservable => {
        this.repository.cryptography.currentClient = clientObservable;
        this.repository.event.currentClient = clientObservable;
        return this.repository.client.getClientsForSelf();
      })
      .then(() => this.repository.client.currentClient());
  }

  /**
   * Handle URL params.
   * @private
   * @returns {undefined} Not return value
   */
  _handleUrlParams() {
    // Currently no URL params to be handled
  }

  /**
   * Check whether the page has been reloaded.
   * @private
   * @returns {boolean}  True if it is a page refresh
   */
  _isReload() {
    const isReload = z.util.isSameLocation(document.referrer, window.location.href);
    const log = `App reload: '${isReload}', Referrer: '${document.referrer}', Location: '${window.location.href}'`;
    this.logger.debug(log);
    return isReload;
  }

  /**
   * Load the access token from cache or get one from the backend.
   * @returns {Promise} Resolves with the access token
   */
  _loadAccessToken() {
    const isLocalhost = z.util.Environment.frontend.isLocalhost();
    const referrer = document.referrer.toLowerCase();
    const isLoginRedirect = referrer.includes('/auth') || referrer.includes('/login');
    const getCachedToken = isLocalhost || isLoginRedirect;

    return getCachedToken ? this.repository.auth.getCachedAccessToken() : this.repository.auth.getAccessToken();
  }

  //##############################################################################
  // Multiple tabs check
  //##############################################################################

  /**
   * Check that this is the single instance tab of the app.
   * @returns {Promise} Resolves when page is the first tab
   */
  _registerSingleInstance() {
    if (this.singleInstanceHandler.registerInstance(this.instanceId)) {
      this._registerSingleInstanceCleaning();
      return Promise.resolve();
    }
    return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.MULTIPLE_TABS));
  }

  _registerSingleInstanceCleaning(singleInstanceCheckIntervalId) {
    $(window).on('beforeunload', () => {
      this.singleInstanceHandler.deregisterInstance();
    });
  }

  /**
   * Hide the loading spinner and show the application UI.
   * @returns {undefined} No return value
   */
  _showInterface() {
    const conversationEntity = this.repository.conversation.getMostRecentConversation();
    this.logger.info('Showing application UI');
    if (this.repository.user.isTemporaryGuest()) {
      this.view.list.showTemporaryGuest();
    } else if (this.repository.user.shouldChangeUsername()) {
      this.view.list.showTakeover();
    } else if (conversationEntity) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
    } else if (this.repository.user.connect_requests().length) {
      amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    this.view.loading.removeFromView();
    $('#wire-main').attr('data-uie-value', 'is-loaded');

    this.repository.properties.checkPrivacyPermission().then(() => {
      window.setTimeout(() => this.repository.notification.checkPermission(), App.CONFIG.NOTIFICATION_CHECK);
    });
  }

  /**
   * Subscribe to 'beforeunload' to stop calls and disconnect the WebSocket.
   * @returns {undefined} No return value
   */
  _subscribeToUnloadEvents() {
    $(window).on('unload', () => {
      this.logger.info("'window.onunload' was triggered, so we will disconnect from the backend.");
      this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.PAGE_NAVIGATION);
      this.repository.calling.leaveCallOnUnload();

      if (this.repository.user.isActivatedAccount()) {
        this.repository.storage.terminate('window.onunload');
      } else {
        this.repository.conversation.leaveGuestRoom();
        this.repository.storage.deleteDatabase();
      }

      this.repository.notification.clearNotifications();
    });
  }

  /**
   * Subscribe to 'navigator.onLine' related events.
   * @returns {undefined} No return value
   */
  _watchOnlineStatus() {
    this.logger.info('Watching internet connectivity status');
    $(window).on('offline', this.onInternetConnectionLost.bind(this));
    $(window).on('online', this.onInternetConnectionGained.bind(this));
  }

  //##############################################################################
  // Lifecycle
  //##############################################################################

  /**
   * Logs the user out on the backend and deletes cached data.
   *
   * @param {z.auth.SIGN_OUT_REASON} signOutReason - Cause for logout
   * @param {boolean} clearData - Keep data in database
   * @returns {undefined} No return value
   */
  logout(signOutReason, clearData = false) {
    const _redirectToLogin = () => {
      amplify.publish(z.event.WebApp.LIFECYCLE.SIGNED_OUT, clearData);
      this._redirectToLogin(signOutReason);
    };

    const _logout = () => {
      // Disconnect from our backend, end tracking and clear cached data
      this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.LOGOUT);

      // Clear Local Storage (but don't delete the cookie label if you were logged in with a permanent client)
      const keysToKeep = [z.storage.StorageKey.AUTH.SHOW_LOGIN];

      const keepPermanentDatabase = this.repository.client.isCurrentClientPermanent() && !clearData;
      if (keepPermanentDatabase) {
        keysToKeep.push(z.storage.StorageKey.AUTH.PERSIST);
      }

      // @todo remove on next iteration
      const selfUser = this.repository.user.self();
      if (selfUser) {
        const cookieLabelKey = this.repository.client.constructCookieLabelKey(selfUser.email() || selfUser.phone());

        Object.keys(amplify.store()).forEach(keyInAmplifyStore => {
          const isCookieLabelKey = keyInAmplifyStore === cookieLabelKey;
          const deleteLabelKey = isCookieLabelKey && clearData;
          const isCookieLabel = z.util.StringUtil.includes(keyInAmplifyStore, z.storage.StorageKey.AUTH.COOKIE_LABEL);

          if (!deleteLabelKey && isCookieLabel) {
            keysToKeep.push(keyInAmplifyStore);
          }
        });

        const keepConversationInput = signOutReason === z.auth.SIGN_OUT_REASON.SESSION_EXPIRED;
        this.repository.cache.clearCache(keepConversationInput, keysToKeep);
      }

      // Clear IndexedDB
      const clearDataPromise = clearData
        ? this.repository.storage
            .deleteDatabase()
            .catch(error => this.logger.error('Failed to delete database before logout', error))
        : Promise.resolve();

      return clearDataPromise.then(() => _redirectToLogin());
    };

    const _logoutOnBackend = () => {
      this.logger.info(`Logout triggered by '${signOutReason}': Disconnecting user from the backend.`);
      return this.repository.auth
        .logout()
        .then(() => _logout())
        .catch(() => _redirectToLogin());
    };

    if (App.CONFIG.SIGN_OUT_REASONS.IMMEDIATE.includes(signOutReason)) {
      return _logout();
    }

    if (navigator.onLine) {
      return _logoutOnBackend();
    }

    this.logger.warn('No internet access. Continuing when internet connectivity regained.');
    $(window).on('online', () => _logoutOnBackend());
  }

  /**
   * Refresh the web app or desktop wrapper
   * @returns {undefined} No return value
   */
  refresh() {
    this.logger.info(`Refresh to update started`);
    if (z.util.Environment.desktop) {
      // if we are in a desktop env, we just warn the wrapper that we need to reload. It then decide what should be done
      return amplify.publish(z.event.WebApp.LIFECYCLE.RESTART, z.lifecycle.UPDATE_SOURCE.WEBAPP);
    }

    window.location.reload(true);
    window.focus();
  }

  /**
   * Notify about found update
   * @returns {undefined} No return value
   */
  update() {
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.LIFECYCLE_UPDATE);
  }

  /**
   * Redirect to the login page after internet connectivity has been verified.
   * @param {z.auth.SIGN_OUT_REASON} signOutReason - Redirect triggered by session expiration
   * @returns {undefined} No return value
   */
  _redirectToLogin(signOutReason) {
    this.logger.info(`Redirecting to login after connectivity verification. Reason: ${signOutReason}`);
    this.backendClient
      .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.LOGIN_REDIRECT)
      .then(() => {
        const isTemporaryGuestReason = App.CONFIG.SIGN_OUT_REASONS.TEMPORARY_GUEST.includes(signOutReason);
        const isLeavingGuestRoom = isTemporaryGuestReason && this.repository.user.isTemporaryGuest();
        if (isLeavingGuestRoom) {
          const path = z.l10n.text(z.string.urlWebsiteRoot);
          const url = z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path);
          return window.location.replace(url);
        }

        let url = `/auth/${location.search}`;
        const isImmediateSignOutReason = App.CONFIG.SIGN_OUT_REASONS.IMMEDIATE.includes(signOutReason);
        if (isImmediateSignOutReason) {
          url = z.util.URLUtil.appendParameter(url, `${z.auth.URLParameter.REASON}=${signOutReason}`);
        }

        const redirectToLogin = signOutReason !== z.auth.SIGN_OUT_REASON.NOT_SIGNED_IN;
        if (redirectToLogin) {
          url = `${url}#login`;
        }

        window.location.replace(url);
      });
  }

  //##############################################################################
  // Debugging
  //##############################################################################

  /**
   * Disable debugging on any environment.
   * @returns {undefined} No return value
   */
  disableDebugging() {
    z.config.LOGGER.OPTIONS.domains['app.wire.com'] = () => 0;
    this.repository.properties.savePreference(z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING, false);
  }

  /**
   * Enable debugging on any environment.
   * @returns {undefined} No return value
   */
  enableDebugging() {
    z.config.LOGGER.OPTIONS.domains['app.wire.com'] = () => 300;
    this.repository.properties.savePreference(z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING, true);
  }

  /**
   * Initialize debugging features.
   * @returns {undefined} No return value
   */
  initDebugging() {
    if (z.util.Environment.frontend.isLocalhost()) {
      this._attachLiveReload();
    }
  }

  /**
   * Report call telemetry to Raygun for analysis.
   * @returns {undefined} No return value
   */
  reportCall() {
    this.repository.calling.reportCall();
  }

  /**
   * Attach live reload on localhost.
   * @returns {undefined} No return value
   */
  _attachLiveReload() {
    const liveReload = document.createElement('script');
    liveReload.id = 'liveReload';
    liveReload.src = 'http://localhost:32123/livereload.js';
    document.body.appendChild(liveReload);
    $('html').addClass('development');
  }

  _onExtraInstanceStarted() {
    return this._redirectToLogin(z.auth.SIGN_OUT_REASON.MULTIPLE_TABS);
  }
};

//##############################################################################
// Setting up the App
//##############################################################################

$(() => {
  if ($('#wire-main-app').length !== 0) {
    wire.app = new z.main.App(wire.auth);
  }
});

//# sourceMappingURL=wire-app.min.js.map