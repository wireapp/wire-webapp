/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ArrayUtil = {
  chunk: (array, size) => {
    const chunks = [];
    for (let index = 0, length = array.length; index < length; index += size) {
      chunks.push(array.slice(index, index + size));
    }
    return chunks;
  },

  /**
   * Gets all the values that are in array2 which are not in array1.
   *
   * @param {Array} array1 - the base array
   * @param {Array} array2 - the array to compare with
   * @returns {Array} - the array containing values in array2 that are not in array1
   */
  getDifference: (array1, array2) => {
    return array2.filter(element => !array1.includes(element));
  },

  getNextItem: (array, currentItem) => {
    const currentIndex = array.indexOf(currentItem);

    // couldn't find the item
    if (currentIndex === -1) {
      return undefined;
    }

    const nextIndex = currentIndex + 1;

    // item is last item in the array
    if (nextIndex === array.length) {
      return currentIndex > 0 ? array[currentIndex - 1] : undefined;
    }

    return array[nextIndex];
  },

  /**
   * Interpolates an array of numbers using linear interpolation
   *
   * @param {Array<any>} array - source
   * @param {number} length - new length
   * @returns {Array<any>} new array with interpolated values
   */
  interpolate: (array, length) => {
    const newArray = [];
    const scale_factor = (array.length - 1) / (length - 1);

    newArray[0] = array[0];
    newArray[length - 1] = array[array.length - 1];

    for (let index = 1; index < length - 1; index++) {
      const original_index = index * scale_factor;
      const before = Math.floor(original_index).toFixed();
      const after = Math.ceil(original_index).toFixed();
      const point = original_index - before;
      newArray[index] = array[before] + (array[after] - array[before]) * point; // linear interpolation
    }

    return newArray;
  },

  isLastItem: (array, item) => array.indexOf(item) === array.length - 1,

  iterateIndex: (array, currentIndex, reverse = false) => {
    if (_.isArray(array) && array.length && _.isNumber(currentIndex)) {
      if (reverse) {
        const isZeroIndex = currentIndex === 0;
        return isZeroIndex ? array.length - 1 : (currentIndex - 1) % array.length;
      }

      return (currentIndex + 1) % array.length;
    }
  },

  iterateItem: (array, currentItem, reverse = false) => {
    if (_.isArray(array) && array.length) {
      const currentIndex = array.indexOf(currentItem);

      // If item could not be found
      const isNegativeIndex = currentIndex === -1;
      return isNegativeIndex ? undefined : array[z.util.ArrayUtil.iterateIndex(array, currentIndex, reverse)];
    }
  },

  /**
   * Returns random element
   * @param {Array} array - source
   * @returns {Object} random element
   */
  randomElement: (array = []) => array[Math.floor(Math.random() * array.length)],

  /**
   * Remove given element from array
   * @param {Array} array - source
   * @param {Object} element - Element which should be removed
   * @returns {Array|undefined} containing the removed element
   */
  removeElement: (array = [], element) => {
    const index = array.indexOf(element);
    if (index > -1) {
      return array.splice(index, 1);
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ClipboardUtil = {
  copyText: text => {
    if (z.util.Environment.browser.supports.clipboard) {
      return navigator.clipboard.writeText(text);
    }

    try {
      const fallbackSource = document.createElement('textarea');
      fallbackSource.value = text;

      let selectedRange;

      if (window.getSelection) {
        selectedRange = window.getSelection().rangeCount ? window.getSelection().getRangeAt(0) : false;
      }

      document.body.appendChild(fallbackSource);
      fallbackSource.select();
      document.execCommand('copy');
      document.body.removeChild(fallbackSource);

      if (window.getSelection && selectedRange) {
        const currentSelection = window.getSelection();
        currentSelection.removeAllRanges();
        currentSelection.addRange(selectedRange);
      }

      return Promise.resolve();
    } catch (error) {
      return Promise.reject(error);
    }
  },
  pasteText: () => {
    if (z.util.Environment.browser.supports.clipboard) {
      return navigator.clipboard.readText();
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Crypto = {
  Hashing: {
    joaatHash: string => {
      const uint32 = window.uint32;
      let hash = uint32.toUint32(0);
      const key = string.toLowerCase();

      for (let index = 0; index < key.length; index++) {
        hash = uint32.addMod32(hash, uint32.toUint32(key.charCodeAt(index)));
        hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 10));
        hash = uint32.xor(hash, uint32.shiftRight(hash, 6));
      }

      hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 3));
      hash = uint32.xor(hash, uint32.shiftRight(hash, 11));
      hash = uint32.addMod32(hash, uint32.shiftLeft(hash, 15));

      return hash;
    },
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.DebugUtil = class DebugUtil {
  constructor(repositories) {
    const {calling, client, connection, conversation, cryptography, event, user, storage} = repositories;

    this.callingRepository = calling;
    this.clientRepository = client;
    this.conversationRepository = conversation;
    this.connectionRepository = connection;
    this.cryptographyRepository = cryptography;
    this.eventRepository = event;
    this.storageRepository = storage;
    this.userRepository = user;

    this.logger = new z.util.Logger('z.util.DebugUtil', z.config.LOGGER.OPTIONS);
  }

  blockAllConnections() {
    const blockUsers = this.userRepository.users().map(userEntity => this.connectionRepository.blockUser(userEntity));
    return Promise.all(blockUsers);
  }

  breakSession(userId, clientId) {
    const sessionId = `${userId}@${clientId}`;
    const cryptobox = this.cryptographyRepository.cryptobox;
    return cryptobox
      .session_load(sessionId)
      .then(cryptoboxSession => {
        cryptoboxSession.session.session_states = {};

        const record = {
          created: Date.now(),
          id: sessionId,
          serialised: cryptoboxSession.session.serialise(),
          version: 'broken_by_qa',
        };

        cryptobox.cachedSessions.set(sessionId, cryptoboxSession);

        const sessionStoreName = z.storage.StorageSchemata.OBJECT_STORE.SESSIONS;
        return this.storageRepository.storageService.update(sessionStoreName, sessionId, record);
      })
      .then(() => this.logger.log(`Corrupted Session ID '${sessionId}'`));
  }

  getLastMessagesFromDatabase(amount = 10, conversationId = this.conversationRepository.active_conversation().id) {
    return this.storageRepository.storageService.db.events.toArray(records => {
      const messages = records.filter(events => events.conversation === conversationId);
      return messages.slice(amount * -1).reverse();
    });
  }

  haveISentThisMessageToMyOtherClients(
    messageId,
    conversationId = this.conversationRepository.active_conversation().id
  ) {
    let recipients = [];

    const clientId = this.clientRepository.currentClient().id;
    const userId = this.userRepository.self().id;

    const isOTRMessage = notification => notification.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
    const isInCurrentConversation = notification => notification.conversation === conversationId;
    const wasSentByOurCurrentClient = notification =>
      notification.from === userId && (notification.data && notification.data.sender === clientId);
    const hasExpectedTimestamp = (notification, dateTime) => notification.time === dateTime.toISOString();

    return this.conversationRepository
      .get_conversation_by_id(conversationId)
      .then(conversation => {
        return this.conversationRepository.get_message_in_conversation_by_id(conversation, messageId);
      })
      .then(message => {
        return this.eventRepository.notificationService
          .getNotifications(undefined, undefined, z.event.EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX)
          .then(({notifications}) => ({
            message,
            notifications,
          }));
      })
      .then(({message, notifications}) => {
        const dateTime = new Date(message.timestamp());
        return notifications
          .reduce((accumulator, notification) => accumulator.concat(notification.payload), [])
          .filter(event => {
            return (
              isOTRMessage(event) &&
              isInCurrentConversation(event) &&
              wasSentByOurCurrentClient(event) &&
              hasExpectedTimestamp(event, dateTime)
            );
          });
      })
      .then(filteredEvents => {
        recipients = filteredEvents.map(event => event.data.recipient);
        return this.clientRepository.getClientsForSelf();
      })
      .then(selfClients => {
        const selfClientIds = selfClients.map(client => client.id);
        const missingClients = selfClientIds.filter(id => recipients.includes(id));
        const logMessage = missingClients.length
          ? `Message was sent to all other "${selfClients.length}" clients.`
          : `Message was NOT sent to the following own clients: ${missingClients.join(',')}`;
        this.logger.info(logMessage);
      })
      .catch(error => this.logger.info(`Message was not sent to other clients. Reason: ${error.message}`, error));
  }

  getEventInfo(event) {
    const debugInformation = {event};

    return this.conversationRepository
      .get_conversation_by_id(event.conversation)
      .then(conversation_et => {
        debugInformation.conversation = conversation_et;
        return this.userRepository.get_user_by_id(event.from);
      })
      .then(user_et => {
        debugInformation.user = user_et;
        const logMessage = `Hey ${this.userRepository.self().name()}, this is for you:`;
        this.logger.warn(logMessage, debugInformation);
        this.logger.warn(`Conversation: ${debugInformation.conversation.name()}`, debugInformation.conversation);
        this.logger.warn(`From: ${debugInformation.user.name()}`, debugInformation.user);
        return debugInformation;
      });
  }

  exportCryptobox() {
    const clientId = this.clientRepository.currentClient().id;
    const userId = this.userRepository.self().id;
    const fileName = `cryptobox-${userId}-${clientId}.json`;

    this.cryptographyRepository.cryptobox
      .serialize()
      .then(cryptobox => z.util.downloadText(JSON.stringify(cryptobox), fileName));
  }

  getNotificationFromStream(notificationId, notificationIdSince) {
    const clientId = this.clientRepository.currentClient().id;

    const _gotNotifications = ({hasMore, notifications}) => {
      const matchingNotifications = notifications.filter(notification => notification.id === notificationId);
      if (matchingNotifications.length) {
        return matchingNotifications[0];
      }

      if (hasMore) {
        const lastNotification = notifications[notifications.length - 1];
        return this.getNotificationFromStream(notificationId, lastNotification.id);
      }
      this.logger.log(`Notification '${notificationId}' was not found in encrypted notification stream`);
    };

    return wire.app.service.notification.getNotifications(clientId, notificationIdSince, 10000).then(_gotNotifications);
  }

  getNotificationsFromStream(remoteUserId, remoteClientId, matchingNotifications = [], notificationIdSince) {
    const localClientId = this.clientRepository.currentClient().id;
    const localUserId = this.userRepository.self().id;

    const _gotNotifications = ({hasMore, notifications}) => {
      const additionalNotifications = !remoteUserId
        ? notifications
        : notifications.filter(notification => {
            const payload = notification.payload;
            for (const {data, from} of payload) {
              if (data && [localUserId, remoteUserId].includes(from)) {
                const {sender, recipient} = data;
                const incoming_event = sender === remoteClientId && recipient === localClientId;
                const outgoing_event = sender === localClientId && recipient === remoteClientId;
                return incoming_event || outgoing_event;
              }
            }
            return false;
          });

      matchingNotifications = matchingNotifications.concat(additionalNotifications);

      if (hasMore) {
        const lastNotification = notifications[notifications.length - 1];
        return this.getNotificationsFromStream(
          remoteUserId,
          remoteClientId,
          matchingNotifications,
          lastNotification.id
        );
      }

      const logMessage = remoteUserId
        ? `Found '${matchingNotifications.length}' notifications between '${localClientId}' and '${remoteClientId}'`
        : `Found '${matchingNotifications.length}' notifications`;

      this.logger.log(logMessage, matchingNotifications);

      return matchingNotifications;
    };

    const clientScope = remoteUserId === localUserId ? undefined : localClientId;
    return wire.app.service.notification
      .getNotifications(clientScope, notificationIdSince, 10000)
      .then(_gotNotifications);
  }

  getObjectsForDecryptionErrors(sessionId, notificationId) {
    return Promise.all([
      this.getNotificationFromStream(notificationId.toLowerCase()),
      this.getSerialisedIdentity(),
      this.getSerialisedSession(sessionId.toLowerCase()),
    ]).then(resolveArray => {
      return JSON.stringify({
        identity: resolveArray[1],
        notification: resolveArray[0],
        session: resolveArray[2],
      });
    });
  }

  getInfoForClientDecryptionErrors(remoteUserId, remoteClientId) {
    return Promise.all([
      this.getNotificationsFromStream(remoteUserId, remoteClientId),
      this.getSerialisedIdentity(),
      this.getSerialisedSession(`${remoteUserId}@${remoteClientId}`),
    ]).then(resolveArray => {
      return JSON.stringify({
        identity: resolveArray[1],
        notifications: resolveArray[0],
        session: resolveArray[2],
      });
    });
  }

  /**
   * Print call log to console.
   * @returns {undefined} No return value
   */
  logCallMessages() {
    this.callingRepository.printLog();
  }

  logConnectionStatus() {
    this.logger.log('Online Status');
    this.logger.log(`-- Browser online: ${window.navigator.onLine}`);
    this.logger.log(`-- IndexedDB open: ${this.storageRepository.storageService.db.isOpen()}`);
    this.logger.log(`-- WebSocket ready state: ${window.wire.app.service.web_socket.socket.readyState}`);
  }

  reprocessNotificationStream(conversationId = this.conversationRepository.active_conversation().id) {
    const clientId = this.clientRepository.currentClient().id;

    return this.eventRepository.notificationService
      .getNotifications(clientId, undefined, z.event.EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX)
      .then(({notifications}) => {
        this.logger.info(`Fetched "${notifications.length}" notifications for client "${clientId}".`, notifications);

        const isOTRMessage = notification => notification.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
        const isInCurrentConversation = notification => notification.conversation === conversationId;

        return notifications
          .map(notification => notification.payload)
          .reduce((accumulator, payload) => accumulator.concat(payload))
          .filter(notification => {
            return isOTRMessage(notification) && isInCurrentConversation(notification);
          });
      })
      .then(events => {
        this.logger.info(`Reprocessing "${events.length}" OTR messages...`);
        events.forEach(event => this.eventRepository.processEvent(event, z.event.EventRepository.SOURCE.STREAM));
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.EmojiUtil = (() => {
  // http://www.unicode.org/Public/emoji/11.0/emoji-data.txt
  // This is the exact copy of unicode-range definition for `emoji` font in CSS.
  const UNICODE_RANGES = 'U+1f000-1f02b, U+1f004, U+1f02c-1f02f, U+1f030-1f093, U+1f094-1f09f, U+1f0a0-1f0ae, U+1f0af-1f0b0, U+1f0b1-1f0be, U+1f0bf, U+1f0c0, U+1f0c1-1f0cf, U+1f0cf, U+1f0d0, U+1f0d1-1f0df, U+1f0e0-1f0f5, U+1f0f6-1f0ff, U+1f10d-1f10f, U+1f12f, U+1f16c-1f16f, U+1f170-1f171, U+1f17e, U+1f17f, U+1f18e, U+1f191-1f19a, U+1f1ad-1f1e5, U+1f1e6-1f1ff, U+1f201, U+1f201-1f202, U+1f203-1f20f, U+1f21a, U+1f22f, U+1f232-1f236, U+1f232-1f23a, U+1f238-1f23a, U+1f23c-1f23f, U+1f249-1f24f, U+1f250-1f251, U+1f252-1f25f, U+1f260-1f265, U+1f266-1f2ff, U+1f300-1f320, U+1f321, U+1f321-1f32c, U+1f324-1f32c, U+1f32d-1f32f, U+1f330-1f335, U+1f336, U+1f337-1f37c, U+1f37d, U+1f37e-1f37f, U+1f380-1f393, U+1f385, U+1f394-1f39f, U+1f396-1f397, U+1f399-1f39b, U+1f39e-1f39f, U+1f3a0-1f3c4, U+1f3c2-1f3c4, U+1f3c5, U+1f3c6-1f3ca, U+1f3c7, U+1f3ca, U+1f3cb-1f3cc, U+1f3cb-1f3ce, U+1f3cf-1f3d3, U+1f3d4-1f3df, U+1f3e0-1f3f0, U+1f3f1-1f3f7, U+1f3f3-1f3f5, U+1f3f4, U+1f3f7, U+1f3f8-1f3fa, U+1f3f8-1f3ff, U+1f3fb-1f3ff, U+1f400-1f43e, U+1f43f, U+1f440, U+1f441, U+1f442-1f443, U+1f442-1f4f7, U+1f446-1f450, U+1f466-1f469, U+1f46e, U+1f470-1f478, U+1f47c, U+1f481-1f483, U+1f485-1f487, U+1f4aa, U+1f4f8, U+1f4f9-1f4fc, U+1f4fd, U+1f4fd-1f4fe, U+1f4ff, U+1f500-1f53d, U+1f546-1f54a, U+1f549-1f54a, U+1f54b-1f54e, U+1f54b-1f54f, U+1f550-1f567, U+1f568-1f579, U+1f56f-1f570, U+1f573-1f579, U+1f574-1f575, U+1f57a, U+1f57b-1f5a3, U+1f587, U+1f58a-1f58d, U+1f590, U+1f595-1f596, U+1f5a4, U+1f5a5, U+1f5a5-1f5fa, U+1f5a8, U+1f5b1-1f5b2, U+1f5bc, U+1f5c2-1f5c4, U+1f5d1-1f5d3, U+1f5dc-1f5de, U+1f5e1, U+1f5e3, U+1f5e8, U+1f5ef, U+1f5f3, U+1f5fa, U+1f5fb-1f5ff, U+1f600, U+1f601-1f610, U+1f611, U+1f612-1f614, U+1f615, U+1f616, U+1f617, U+1f618, U+1f619, U+1f61a, U+1f61b, U+1f61c-1f61e, U+1f61f, U+1f620-1f625, U+1f626-1f627, U+1f628-1f62b, U+1f62c, U+1f62d, U+1f62e-1f62f, U+1f630-1f633, U+1f634, U+1f635-1f640, U+1f641-1f642, U+1f643-1f644, U+1f645-1f647, U+1f645-1f64f, U+1f64b-1f64f, U+1f680-1f6c5, U+1f6a3, U+1f6b4-1f6b6, U+1f6c0, U+1f6c6-1f6cf, U+1f6cb-1f6cf, U+1f6cc, U+1f6d0, U+1f6d1-1f6d2, U+1f6d3-1f6d4, U+1f6d5-1f6df, U+1f6e0-1f6e5, U+1f6e0-1f6ec, U+1f6e9, U+1f6eb-1f6ec, U+1f6ed-1f6ef, U+1f6f0, U+1f6f0-1f6f3, U+1f6f3, U+1f6f4-1f6f6, U+1f6f7-1f6f8, U+1f6f9, U+1f6fa-1f6ff, U+1f774-1f77f, U+1f7d5-1f7d8, U+1f7d9-1f7ff, U+1f80c-1f80f, U+1f848-1f84f, U+1f85a-1f85f, U+1f888-1f88f, U+1f8ae-1f8ff, U+1f90c-1f90f, U+1f910-1f918, U+1f918, U+1f919-1f91c, U+1f919-1f91e, U+1f91e, U+1f91f, U+1f920-1f927, U+1f926, U+1f928-1f92f, U+1f930, U+1f931-1f932, U+1f933-1f939, U+1f933-1f93a, U+1f93c-1f93e, U+1f93d-1f93e, U+1f93f, U+1f940-1f945, U+1f947-1f94b, U+1f94c, U+1f94d-1f94f, U+1f950-1f95e, U+1f95f-1f96b, U+1f96c-1f970, U+1f971-1f972, U+1f973-1f976, U+1f977-1f979, U+1f97a, U+1f97b, U+1f97c-1f97f, U+1f980-1f984, U+1f985-1f991, U+1f992-1f997, U+1f998-1f9a2, U+1f9a3-1f9af, U+1f9b0-1f9b3, U+1f9b0-1f9b9, U+1f9b5-1f9b6, U+1f9b8-1f9b9, U+1f9ba-1f9bf, U+1f9c0, U+1f9c1-1f9c2, U+1f9c3-1f9cf, U+1f9d0-1f9e6, U+1f9d1-1f9dd, U+1f9e7-1f9ff, U+1fa00-1fa5f, U+1fa60-1fa6d, U+1fa6e-1fffd, U+200d, U+203c, U+2049, U+20e3, U+2139, U+2194-2199, U+21a9-21aa, U+231a-231b, U+2328, U+2388, U+23cf, U+23e9-23ec, U+23e9-23f3, U+23f0, U+23f3, U+23f8-23fa, U+24c2, U+25aa-25ab, U+25b6, U+25c0, U+25fb-25fe, U+25fd-25fe, U+2600-2604, U+2600-2605, U+2607-2612, U+260e, U+2611, U+2614-2615, U+2616-2617, U+2618, U+2619, U+261a-266f, U+261d, U+2620, U+2622-2623, U+2626, U+262a, U+262e-262f, U+2638-263a, U+2640, U+2642, U+2648-2653, U+265f-2660, U+2663, U+2665-2666, U+2668, U+2670-2671, U+2672-267d, U+267b, U+267e-267f, U+267f, U+2680-2685, U+2690-2691, U+2692-2697, U+2692-269c, U+2693, U+2699, U+269b-269c, U+269d, U+269e-269f, U+26a0-26a1, U+26a1, U+26a2-26b1, U+26aa-26ab, U+26b0-26b1, U+26b2, U+26b3-26bc, U+26bd-26be, U+26bd-26bf, U+26c0-26c3, U+26c4-26c5, U+26c4-26cd, U+26c8, U+26ce, U+26cf, U+26cf-26e1, U+26d1, U+26d3-26d4, U+26d4, U+26e2, U+26e3, U+26e4-26e7, U+26e8-26ff, U+26e9-26ea, U+26ea, U+26f0-26f5, U+26f2-26f3, U+26f5, U+26f7-26fa, U+26f9, U+26fa, U+26fd, U+2700, U+2701-2704, U+2702, U+2705, U+2708-2709, U+270a-270b, U+270c-270d, U+270c-2712, U+270f, U+2712, U+2714, U+2716, U+271d, U+2721, U+2728, U+2733-2734, U+2744, U+2747, U+274c, U+274e, U+2753-2755, U+2757, U+2763-2764, U+2763-2767, U+2795-2797, U+27a1, U+27b0, U+27bf, U+2934-2935, U+2b05-2b07, U+2b1b-2b1c, U+2b50, U+2b55, U+3030, U+303d, U+3297, U+3299, U+e0020-e007f, U+fe0f'
    .replace(/U\+/g, '')
    .split(', ')
    .reduce((list, codepoint) => {
      if (codepoint.indexOf('-') === -1) {
        list.push(String.fromCodePoint(`0x${codepoint}`));
      } else {
        const hex_base = 16;
        const [start, end] = codepoint.split('-').map(code => parseInt(code, hex_base));
        for (let code = start; code <= end; code++) {
          list.push(String.fromCodePoint(`0x${code.toString(hex_base)}`));
        }
      }
      return list;
    }, []);

  const UNICODE_RANGE_REGEXP = new RegExp(`[${UNICODE_RANGES.join('')}]`, 'g');

  return {
    UNICODE_RANGES,
    includesOnlyEmojies: text => {
      const isValidString = string => _.isString(string) && string.length > 0;
      const removeEmojies = string => string.replace(UNICODE_RANGE_REGEXP, '');
      const removeWhitespace = string => string.replace(/\s+/g, '');

      return isValidString(text) && removeEmojies(removeWhitespace(text)).length === 0;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Environment = (() => {
  const APP_ENV = {
    INTERNAL: 'wire-webapp-staging.wire.com',
    LOCALHOST: 'localhost',
    PRODUCTION: 'wire.com',
    VIRTUAL_HOST: 'wire.ms', // The domain "wire.ms" is our virtual host for testing contact uploads
  };

  const BROWSER_NAME = {
    CHROME: 'Chrome',
    EDGE: 'Microsoft Edge',
    ELECTRON: 'Electron',
    FIREFOX: 'Firefox',
    OPERA: 'Opera',
    WIRE: 'Wire',
  };

  const PLATFORM_NAME = {
    MACINTOSH: 'Mac',
    WINDOWS: 'Win',
  };

  const _getAppVersion = () => {
    const versionElement = document.head.querySelector("[property='wire:version']");
    const hasVersion = versionElement && versionElement.hasAttribute('version');
    return hasVersion ? versionElement.getAttribute('version').trim() : '';
  };

  const _getElectronVersion = userAgent => {
    // [match, app, version]
    const [, , electronVersion] = /(Wire|WireInternal)\/(\S+)/.exec(userAgent) || [];
    return electronVersion;
  };

  const _getFormattedAppVersion = () => {
    const [year, month, day, hour, minute] = _getAppVersion().split('-');
    return `${year}.${month}.${day}.${hour}${minute}`;
  };

  const _getVersion = () => {
    const browserVersion = window.platform.version || '';
    const [majorVersion] = browserVersion.split('.');
    return window.parseInt(majorVersion, 10);
  };

  const _isChrome = () => window.platform.name === BROWSER_NAME.CHROME || _isElectron();
  const _isDesktop = () => _isElectron() && window.platform.ua.includes(BROWSER_NAME.WIRE);
  const _isEdge = () => window.platform.name === BROWSER_NAME.EDGE;
  const _isElectron = () => window.platform.name === BROWSER_NAME.ELECTRON;
  const _isFirefox = () => window.platform.name === BROWSER_NAME.FIREFOX;
  const _isOpera = () => window.platform.name === BROWSER_NAME.OPERA;

  const _isMac = () => window.platform.ua.includes(PLATFORM_NAME.MACINTOSH);
  const _isWindows = () => window.platform.os.family && window.platform.os.family.includes(PLATFORM_NAME.WINDOWS);

  const isInternal = () => window.location.hostname === APP_ENV.INTERNAL;
  const isLocalhost = () => [APP_ENV.LOCALHOST, APP_ENV.VIRTUAL_HOST].includes(window.location.hostname);
  const isProduction = () => {
    const isProductionHost = window.wire.env.ENVIRONMENT === z.service.BackendEnvironment.PRODUCTION;
    return isProductionHost && !isInternal();
  };

  const _supportsAudioOutputSelection = () => _isChrome();
  const _supportsCalling = () => {
    if (!_supportsMediaDevices()) {
      return false;
    }

    if (window.WebSocket === undefined) {
      return false;
    }

    return _isEdge() ? false : _isChrome() || _isFirefox() || _isOpera();
  };

  const _supportsClipboard = () => !!navigator.clipboard;
  const _supportsIndexedDb = () => {
    try {
      return !!window.indexedDB;
    } catch (error) {
      return false;
    }
  };
  const _supportsMediaDevices = () => !!navigator.mediaDevices && !!navigator.mediaDevices.getUserMedia;

  const _supportsPermissions = () => !!navigator.permissions;
  const _supportsMediaPermissions = () => _supportsPermissions() && _isChrome() && _getVersion() >= 64;

  const _supportsNotifications = () => {
    const notificationNotSupported = window.Notification === undefined;
    if (notificationNotSupported) {
      return false;
    }

    const requestPermissionNotSupported = window.Notification.requestPermission === undefined;
    return requestPermissionNotSupported ? false : document.visibilityState !== undefined;
  };
  const _supportsScreenSharing = () => (window.desktopCapturer ? true : _isFirefox());

  // add body information
  const _osCssClass = _isMac() ? 'os-mac' : 'os-pc';
  const _platformCssClass = _isElectron() ? 'platform-electron' : 'platform-web';
  document.body.classList.add(_osCssClass, _platformCssClass);

  return {
    backend: {
      current: undefined,
    },
    browser: {
      chrome: _isChrome(),
      edge: _isEdge(),
      firefox: _isFirefox(),
      name: window.platform.name,
      opera: _isOpera(),
      supports: {
        audioOutputSelection: _supportsAudioOutputSelection(),
        calling: _supportsCalling(),
        clipboard: _supportsClipboard(),
        indexedDb: _supportsIndexedDb(),
        mediaDevices: _supportsMediaDevices(),
        mediaPermissions: _supportsMediaPermissions(),
        notifications: _supportsNotifications(),
        permissions: _supportsPermissions(),
        screenSharing: _supportsScreenSharing(),
      },
      version: _getVersion(),
    },
    desktop: _isDesktop(),
    electron: _isElectron(),
    electronVersion: _getElectronVersion,
    frontend: {
      isInternal,
      isLocalhost,
      isProduction,
    },
    os: {
      linux: !_isMac() && !_isWindows(),
      mac: _isMac(),
      win: _isWindows(),
    },
    version(showWrapperVersion = true, doNotFormat = false) {
      if (z.util.Environment.frontend.isLocalhost()) {
        return 'dev';
      }

      if (doNotFormat) {
        return _getAppVersion();
      }

      const electronVersion = _getElectronVersion(window.platform.ua);
      const showElectronVersion = electronVersion && showWrapperVersion;
      return showElectronVersion ? electronVersion : _getFormattedAppVersion();
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.checkIndexedDb = () => {
  if (!z.util.Environment.browser.supports.indexedDb) {
    const errorType = z.util.Environment.browser.edge
      ? z.error.AuthError.TYPE.PRIVATE_MODE
      : z.error.AuthError.TYPE.INDEXED_DB_UNSUPPORTED;
    return Promise.reject(new z.error.AuthError(errorType));
  }

  if (z.util.Environment.browser.firefox) {
    let dbOpenRequest;

    try {
      dbOpenRequest = window.indexedDB.open('test');
      dbOpenRequest.onerror = event => {
        if (dbOpenRequest.error) {
          event.preventDefault();
          return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
        }
      };
    } catch (error) {
      return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
    }

    return new Promise((resolve, reject) => {
      let currentAttempt = 0;
      const interval = 10;
      const maxRetry = 50;

      const interval_id = window.setInterval(() => {
        currentAttempt += 1;

        if (dbOpenRequest.readyState === 'done' && !dbOpenRequest.result) {
          window.clearInterval(interval_id);
          return reject(new z.error.AuthError(z.error.AuthError.TYPE.PRIVATE_MODE));
        }

        const tooManyAttempts = currentAttempt >= maxRetry;
        if (tooManyAttempts) {
          window.clearInterval(interval_id);
          resolve();
        }
      }, interval);
    });
  }

  return Promise.resolve();
};

z.util.isSameLocation = (pastLocation, currentLocation) => {
  return pastLocation !== '' && currentLocation.startsWith(pastLocation);
};

z.util.loadImage = function(blob) {
  return new Promise((resolve, reject) => {
    const object_url = window.URL.createObjectURL(blob);
    const img = new Image();
    img.onload = function() {
      resolve(this);
      window.URL.revokeObjectURL(object_url);
    };
    img.onerror = reject;
    img.src = object_url;
  });
};

z.util.loadDataUrl = file => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

z.util.loadFileBuffer = file => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
};

z.util.loadUrlBuffer = (url, xhrAccessorFunction) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';

    xhr.onload = () => {
      const isStatusOK = xhr.status === 200;
      return isStatusOK
        ? resolve({buffer: xhr.response, mimeType: xhr.getResponseHeader('content-type')})
        : reject(new Error(xhr.status));
    };

    xhr.onerror = reject;

    if (typeof xhrAccessorFunction === 'function') {
      xhrAccessorFunction(xhr);
    }
    xhr.send();
  });
};

z.util.loadUrlBlob = url => {
  return z.util.loadUrlBuffer(url).then(({buffer, mimeType}) => new Blob([new Uint8Array(buffer)], {type: mimeType}));
};

/**
 * Get extension of a filename.
 * @param {string} filename - filename including extension
 * @returns {string} File extension
 */
z.util.getFileExtension = filename => {
  if (!_.isString(filename) || !filename.includes('.')) {
    return '';
  }

  if (filename.endsWith('.tar.gz')) {
    return 'tar.gz';
  }

  return filename.substr(filename.lastIndexOf('.') + 1);
};

/**
 * Remove extension of a filename.
 * @param {string} filename - filename including extension
 * @returns {string} New String without extension
 */
z.util.trimFileExtension = filename => {
  if (_.isString(filename)) {
    if (filename.endsWith('.tar.gz')) {
      filename = filename.replace(/\.tar\.gz$/, '');
    }

    return filename.replace(/\.[^/.]+$/, '');
  }

  return '';
};

/**
 * Format bytes into a human readable string.
 * @param {number} bytes - bytes to format
 * @param {number} [decimals] - Number of decimals to keep
 * @returns {string} Bytes as a human readable string
 */
z.util.formatBytes = (bytes, decimals) => {
  if (bytes === 0) {
    return '0B';
  }

  const kilobytes = 1024;
  decimals = decimals + 1 || 2;
  const unit = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  const index = Math.floor(Math.log(bytes) / Math.log(kilobytes));
  return parseFloat((bytes / Math.pow(kilobytes, index)).toFixed(decimals)) + unit[index];
};

z.util.getContentTypeFromDataUrl = data_url => {
  return data_url
    .split(',')[0]
    .split(':')[1]
    .split(';')[0];
};

z.util.stripDataUri = string => string.replace(/^data:.*,/, '');

/**
 * Convert base64 string to UInt8Array.
 * @note Function will remove "data-uri" attribute if present.
 * @param {string} base64 - base64 encoded string
 * @returns {UInt8Array} Typed array
 */
z.util.base64ToArray = base64 => bazinga64.Decoder.fromBase64(z.util.stripDataUri(base64)).asBytes;

/**
 * Convert ArrayBuffer or UInt8Array to base64 string
 * @param {ArrayBuffer|UInt8Array} array - raw binary data or bytes
 * @returns {string} Base64-encoded string
 */
z.util.arrayToBase64 = array => bazinga64.Encoder.toBase64(new Uint8Array(array)).asString;

/**
 * Returns base64 encoded md5 of the the given array.
 * @param {Uint8Array} array - Input array
 * @returns {string} MD5 hash
 */
z.util.arrayToMd5Base64 = array => {
  const wordArray = CryptoJS.lib.WordArray.create(array);
  return CryptoJS.MD5(wordArray).toString(CryptoJS.enc.Base64);
};

/**
 * Convert base64 dataURI to Blob
 * @param {string} base64 - base64 encoded data uri
 * @returns {Blob} Binary output
 */

z.util.base64ToBlob = base64 => {
  const mimeType = z.util.getContentTypeFromDataUrl(base64);
  const bytes = z.util.base64ToArray(base64);
  return new Blob([bytes], {type: mimeType});
};

/**
 * Downloads blob using a hidden link element.
 * @param {Blob} blob - Blob to store
 * @param {string} filename - Data will be saved under this name
 * @param {string} [mimeType] - Mime type of the generated download
 * @returns {number} Timeout identifier
 */

z.util.downloadBlob = (blob, filename, mimeType) => {
  if (blob) {
    const url = window.URL.createObjectURL(blob);
    return z.util.downloadFile(url, filename, mimeType);
  }

  throw new Error('Failed to download blob: Resource not provided');
};

z.util.downloadText = (text, filename = 'default.txt') => {
  const url = `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`;
  return z.util.downloadFile(url, filename);
};

z.util.downloadFile = (url, fileName, mimeType) => {
  const anchor = document.createElement('a');
  anchor.download = fileName;
  anchor.href = url;
  anchor.style = 'display: none';
  if (mimeType) {
    anchor.type = mimeType;
  }

  // Firefox needs the element to be in the DOM for the download to start:
  // @see https://stackoverflow.com/a/32226068
  document.body.appendChild(anchor);
  anchor.click();

  // Wait before removing resource and link. Needed in FF.
  return window.setTimeout(() => {
    const objectURL = anchor.href;
    document.body.removeChild(anchor);
    window.URL.revokeObjectURL(objectURL);
  }, 100);
};

z.util.phoneNumberToE164 = (phoneNumber, countryCode) => {
  return window.PhoneFormat.formatE164(`${countryCode}`.toUpperCase(), `${phoneNumber}`);
};

z.util.createRandomUuid = () => UUID.genV4().hexString;

z.util.encodeBase64 = text => window.btoa(text);

z.util.encodeSha256Base64 = text => CryptoJS.SHA256(text).toString(CryptoJS.enc.Base64);

// Note IE10 listens to "transitionend" instead of "animationend"
z.util.alias = {
  animationend: 'transitionend animationend oAnimationEnd MSAnimationEnd mozAnimationEnd webkitAnimationEnd',
};

// Note: We are using "Underscore.js" to escape HTML in the original message
z.util.renderMessage = (message, selfId, mentionEntities = []) => {
  const createMentionHash = mention => ` @${btoa(JSON.stringify(mention)).replace(/=/g, '')}`;
  const renderMention = mentionData => {
    const elementClasses = mentionData.isSelfMentioned ? ' self-mention' : '';
    const elementAttributes = mentionData.isSelfMentioned
      ? ' data-uie-name="label-self-mention"'
      : ` data-uie-name="label-other-mention" data-user-id="${mentionData.userId}"`;

    const mentionText = mentionData.text.replace(/^@/, '');
    const content = `<span class="mention-at-sign">@</span>${z.util.SanitizationUtil.escapeString(mentionText)}`;
    return `<span class="message-mention${elementClasses}"${elementAttributes}>${content}</span>`;
  };
  const mentionTexts = {};

  let mentionlessText = mentionEntities
    .slice()
    // sort mentions to start with the latest mention first (in order not to have to recompute the index everytime we modify the original text)
    .sort((mention1, mention2) => mention2.startIndex - mention1.startIndex)
    .reduce((strippedText, mention) => {
      const mentionText = message.slice(mention.startIndex, mention.startIndex + mention.length);
      const mentionKey = createMentionHash(mention);
      mentionTexts[mentionKey] = {
        isSelfMentioned: mention.targetsUser(selfId),
        text: mentionText,
        userId: mention.userId,
      };
      return z.util.StringUtil.replaceInRange(
        strippedText,
        mentionKey,
        mention.startIndex,
        mention.startIndex + mention.length
      );
    }, message);

  mentionlessText = marked(mentionlessText, {
    highlight: function(code) {
      const containsMentions = mentionEntities.some(mention => {
        const hash = createMentionHash(mention);
        return code.includes(hash);
      });
      if (containsMentions) {
        // disable code highlighting if there is a mention in there
        // highlighting will be wrong anyway because this is not valid code
        return code;
      }
      return hljs.highlightAuto(code).value;
    },
    sanitize: true,
  });

  // TODO: Remove this when this is merged: https://github.com/SoapBox/linkifyjs/pull/189
  mentionlessText = mentionlessText.replace(/\n/g, '<br />');

  // Remove <br /> if it is the last thing in a message
  if (z.util.StringUtil.getLastChars(mentionlessText, '<br />'.length) === '<br />') {
    mentionlessText = z.util.StringUtil.cutLastChars(mentionlessText, '<br />'.length);
  }

  const parsedText = Object.keys(mentionTexts).reduce((text, mentionHash) => {
    const mentionMarkup = renderMention(mentionTexts[mentionHash]);

    return text.replace(mentionHash, mentionMarkup);
  }, mentionlessText);

  return parsedText;
};

z.util.koArrayPushAll = (koArray, valuesToPush) => {
  // append array to knockout observableArray
  // https://github.com/knockout/knockout/issues/416
  const underlyingArray = koArray();
  koArray.valueWillMutate();
  ko.utils.arrayPushAll(underlyingArray, valuesToPush);
  koArray.valueHasMutated();
};

z.util.koArrayUnshiftAll = (koArray, valuesToShift) => {
  // prepend array to knockout observableArray
  const underlyingArray = koArray();
  koArray.valueWillMutate();
  Array.prototype.unshift.apply(underlyingArray, valuesToShift);
  koArray.valueHasMutated();
};

z.util.koPushDeferred = (target, src, number = 100, delay = 300) => {
  // push array deferred to knockout observableArray
  let interval;

  return (interval = window.setInterval(() => {
    const chunk = src.splice(0, number);
    z.util.koArrayPushAll(target, chunk);

    if (src.length === 0) {
      return window.clearInterval(interval);
    }
  }, delay));
};

/**
 * Add zero padding until limit is reached.
 * @param {string|number} value - Input
 * @param {number} length - Final output length
 * @returns {string} Input value with leading zeros (padding)
 */
z.util.zeroPadding = (value, length = 2) => {
  const zerosNeeded = Math.max(0, length - value.toString().length);
  return `${'0'.repeat(zerosNeeded)}${value}`;
};

/**
 * Test whether the given string is ISO 8601 format equally to date.toISOString()
 * @param {string} dateString - String with data
 * @returns {boolean} True, if input string follows ISO 8601
 */
z.util.isIsoString = dateString => {
  return /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/.test(dateString);
};

z.util.sortGroupsByLastEvent = (groupA, groupB) => groupB.last_event_timestamp() - groupA.last_event_timestamp();

z.util.sortObjectByKeys = (object, reverse) => {
  const keys = Object.keys(object);
  keys.sort();

  if (reverse) {
    keys.reverse();
  }

  // Returns a copy of an object, which is ordered by the keys of the original object.
  return keys.reduce((sortedObject, key) => {
    sortedObject[key] = object[key];
    return sortedObject;
  }, {});
};

// Removes url(' and url(" from the beginning of the string and also ") and ') from the end
z.util.stripUrlWrapper = url => url.replace(/^url\(["']?/, '').replace(/["']?\)$/, '');

z.util.validateProfileImageResolution = (file, minWidth, minHeight) => {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image.width >= minWidth && image.height >= minHeight);
    image.onerror = () => reject(new Error('Failed to load profile picture for size validation'));
    image.src = window.URL.createObjectURL(file);
  });
};

z.util.isValidEmail = email => {
  const regExp = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return regExp.test(email);
};

/**
 * Checks if input has the format of an international phone number
 * @note Begins with + and contains only numbers
 * @param {string} phoneNumber - Input
 * @returns {boolean} True, if the input a phone number
 */
z.util.isValidPhoneNumber = phoneNumber => {
  const allowDebugPhoneNumbers = window.wire.env.FEATURE.ENABLE_DEBUG;
  const regularExpression = allowDebugPhoneNumbers ? /^\+[0-9]\d{1,14}$/ : /^\+[1-9]\d{1,14}$/;

  return regularExpression.test(phoneNumber);
};

z.util.isValidUsername = username => {
  if (username.startsWith('@')) {
    username = username.substring(1);
  }
  return /^[a-z_0-9]{2,21}$/.test(username);
};

z.util.murmurhash3 = (key, seed) => {
  const remainder = key.length & 3; // key.length % 4
  const bytes = key.length - remainder;
  let h1 = seed;
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;
  let index = 0;

  while (index < bytes) {
    let k1 =
      (key.charCodeAt(index) & 0xff) |
      ((key.charCodeAt(++index) & 0xff) << 8) |
      ((key.charCodeAt(++index) & 0xff) << 16) |
      ((key.charCodeAt(++index) & 0xff) << 24);
    ++index;

    k1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;

    h1 ^= k1;
    h1 = (h1 << 13) | (h1 >>> 19);
    const h1b = ((h1 & 0xffff) * 5 + ((((h1 >>> 16) * 5) & 0xffff) << 16)) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16);
  }

  let k1 = 0;

  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(index + 2) & 0xff) << 16;
      break;
    case 2:
      k1 ^= (key.charCodeAt(index + 1) & 0xff) << 8;
      break;
    case 1:
      k1 ^= key.charCodeAt(index) & 0xff;

      k1 = ((k1 & 0xffff) * c1 + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((k1 & 0xffff) * c2 + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
      break;
    default:
      break;
  }

  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = ((h1 & 0xffff) * 0x85ebca6b + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((h1 & 0xffff) * 0xc2b2ae35 + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return h1 >>> 0;
};

z.util.printDevicesId = id => {
  if (!id) {
    return '';
  }

  const idWithPadding = z.util.zeroPadding(id, 16);
  const parts = idWithPadding.match(/.{1,2}/g) || [];
  const prettifiedId = parts.map(part => `<span class='device-id-part'>${part}</span>`);

  return prettifiedId.join('');
};

/**
 * Returns bucket for given value based on the specified bucket limits
 * @example z.util.bucketValues(13, [0, 5, 10, 15, 20, 25]) will return '11-15')
 * @param {number} value - Numeric value
 * @param {Array<number>} bucketLimits - Array with numeric values that define the upper limit of the bucket
 * @returns {string} Bucket
 */
z.util.bucketValues = (value, bucketLimits) => {
  if (value < bucketLimits[0] + 1) {
    return '0';
  }

  for (let index = 0; index < bucketLimits.length; index++) {
    const limit = bucketLimits[index];
    if (value < limit + 1) {
      const previous_limit = bucketLimits[index - 1];
      return `${previous_limit + 1}-${limit}`;
    }
  }

  const last_limit = bucketLimits[bucketLimits.length - 1];
  return `${last_limit + 1}-`;
};

// https://developer.mozilla.org/en-US/Firefox/Performance_best_practices_for_Firefox_fe_engineers
z.util.afterRender = callback => window.requestAnimationFrame(() => window.setTimeout(callback, 0));

/**
 * No operation
 * @returns {void}
 */
z.util.noop = () => {};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.SanitizationUtil = (() => {
  const _getSelfName = (declension = z.string.Declension.NOMINATIVE, bypassSanitization = false) => {
    const selfNameDeclensions = {
      [z.string.Declension.NOMINATIVE]: z.string.conversationYouNominative,
      [z.string.Declension.DATIVE]: z.string.conversationYouDative,
      [z.string.Declension.ACCUSATIVE]: z.string.conversationYouAccusative,
    };

    const selfName = z.l10n.text(selfNameDeclensions[declension]);
    return bypassSanitization ? selfName : z.util.SanitizationUtil.escapeString(selfName);
  };

  return {
    escapeRegex: string => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'),

    escapeString: string => _.escape(string),

    getFirstName: (userEntity, declension, bypassSanitization = false) => {
      if (userEntity.is_me) {
        return _getSelfName(declension, bypassSanitization);
      }
      return bypassSanitization
        ? userEntity.first_name()
        : z.util.SanitizationUtil.escapeString(userEntity.first_name());
    },

    getSelfName: _getSelfName,

    safeMailtoOpen: (event, email) => {
      event.preventDefault();
      event.stopPropagation();

      if (!z.util.isValidEmail(email)) {
        return;
      }

      const newWindow = window.open(`mailto:${email}`);
      if (newWindow) {
        window.setTimeout(() => newWindow.close(), 10);
      }
    },

    /**
     * Opens a new browser tab (target="_blank") with a given URL in a safe environment.
     * @see https://mathiasbynens.github.io/rel-noopener/
     * @param {string} url - URL you want to open in a new browser tab
     * @param {boolean} focus - True, if the new windows should get browser focus
     * @returns {Object} New window handle
     */
    safeWindowOpen: (url, focus = true) => {
      const newWindow = window.open(z.util.URLUtil.prependProtocol(url));

      if (newWindow) {
        newWindow.opener = null;
        if (focus) {
          newWindow.focus();
        }
      }

      return newWindow;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

//@ts-check

'use strict';

/**
 * @typedef {object} DiscreteTimeUnit
 * @property {string} longUnit
 * @property {string} symbol
 * @property {number} value
 */

/**
 * @typedef {object} DurationUnit
 * @property {string} text
 * @property {string} symbol
 * @property {number} value
 */

window.z = window.z || {};
window.z.util = z.util || {};

z.util.TimeUtil = {
  UNITS_IN_MILLIS: {
    DAY: 1000 * 60 * 60 * 24,
    HOUR: 1000 * 60 * 60,
    MINUTE: 1000 * 60,
    SECOND: 1000,
    WEEK: 1000 * 60 * 60 * 24 * 7,
    YEAR: 1000 * 60 * 60 * 24 * 365,
  },

  durationUnits: () => {
    return [
      {
        plural: 'ephemeralUnitsYears',
        singular: 'ephemeralUnitsYear',
        symbol: 'y',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.YEAR,
      },
      {
        plural: 'ephemeralUnitsWeeks',
        singular: 'ephemeralUnitsWeek',
        symbol: 'w',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      },
      {
        plural: 'ephemeralUnitsDays',
        singular: 'ephemeralUnitsDay',
        symbol: 'd',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      },
      {
        plural: 'ephemeralUnitsHours',
        singular: 'ephemeralUnitsHour',
        symbol: 'h',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR,
      },
      {
        plural: 'ephemeralUnitsMinutes',
        singular: 'ephemeralUnitsMinute',
        symbol: 'm',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
      },
      {
        plural: 'ephemeralUnitsSeconds',
        singular: 'ephemeralUnitsSecond',
        symbol: 's',
        value: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    ];
  },

  /**
   * Format milliseconds into 15s, 2m.
   * @param {number} duration - Duration to format in milliseconds
   * @returns {DurationUnit} Unit, value and localized string
   */
  formatDuration: duration => {
    const mappedUnits = z.util.TimeUtil.mapUnits(duration, true);
    const firstNonZeroUnit = mappedUnits.find(unit => unit.value > 0);
    return {
      symbol: firstNonZeroUnit.symbol,
      text: `${firstNonZeroUnit.value} ${z.l10n.text(firstNonZeroUnit.longUnit)}`,
      value: firstNonZeroUnit.value,
    };
  },

  /**
   * Generate a human readable string of the remaining time
   * @param {number} duration - the remaining time in milliseconds
   * @returns {string} readable representation of the remaining time
   */
  formatDurationCaption: duration => {
    const mappedUnits = z.util.TimeUtil.mapUnits(duration, false);
    const hours = mappedUnits.find(unit => unit.symbol === 'h');
    const minutes = mappedUnits.find(unit => unit.symbol === 'm');
    const hasHours = hours.value > 0;
    const validUnitStrings = [];
    for (let index = 0; index < mappedUnits.length; index++) {
      const unit = mappedUnits[index];
      if (unit === hours && hasHours) {
        validUnitStrings.push(`${z.util.zeroPadding(hours.value)}:${z.util.zeroPadding(minutes.value)}`);
        break;
      }
      if (unit.value > 0) {
        validUnitStrings.push(`${unit.value} ${unit.longUnit}`);
      }
      if (validUnitStrings.length === 2) {
        break;
      }
      const nextUnit = mappedUnits[index + 1];
      if (validUnitStrings.length > 0 && nextUnit && nextUnit.value === 0) {
        break;
      }
    }
    const joiner = ` ${z.l10n.text(z.string.and)} `;
    return `${validUnitStrings.join(joiner)} ${z.l10n.text(z.string.ephemeralRemaining)}`;
  },

  /**
   * Format seconds into hh:mm:ss.
   * @param {number} duration - duration to format in seconds
   * @returns {string} Formatted string
   */
  formatSeconds: duration => {
    duration = Math.round(duration || 0);

    const hours = Math.floor(duration / (60 * 60));

    const divisorForMinutes = duration % (60 * 60);
    const minutes = Math.floor(divisorForMinutes / 60);

    const divisor_for_seconds = divisorForMinutes % 60;
    const seconds = Math.ceil(divisor_for_seconds);

    const components = [z.util.zeroPadding(minutes), z.util.zeroPadding(seconds)];

    if (hours > 0) {
      components.unshift(hours);
    }

    return components.join(':');
  },

  /**
   * Human readable format of a timestamp.
   * @note: Not testable due to timezones :(
   * @param {number} timestamp - Timestamp
   * @param {boolean} longFormat - True, if output should have leading numbers
   * @returns {string} Human readable format of a timestamp.
   */
  formatTimestamp: (timestamp, longFormat = true) => {
    const time = moment(timestamp);
    let format = 'DD.MM.YYYY (HH:mm:ss)';

    if (longFormat) {
      format = moment().year() === time.year() ? 'ddd D MMM, HH:mm' : 'ddd D MMM YYYY, HH:mm';
    }

    return time.format(format);
  },

  getCurrentDate: () => new Date().toISOString().substring(0, 10),

  getUnixTimestamp: () => Math.floor(Date.now() / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND),

  /**
   * Calculate the discrete time units (years, weeks, days, hours, minutes, seconds) for a given duration
   * @note Implementation based on: https://gist.github.com/deanrobertcook/7168b38150c303a2b4196216913d34c1
   * @param {number} duration - duration in milliseconds
   * @param {boolean} rounded - should the units be rounded as opposed to floored
   * @returns {DiscreteTimeUnit[]} calculated time units
   */
  mapUnits: (duration, rounded) => {
    const mappedUnits = z.util.TimeUtil.durationUnits().map((unit, index, units) => {
      let value = duration;
      if (index > 0) {
        value %= units[index - 1].value;
      }
      value /= unit.value;
      value = rounded && value >= 1 ? Math.round(value) : Math.floor(value);
      const longUnit = z.string[value === 1 ? unit.singular : unit.plural];
      return {
        longUnit,
        symbol: unit.symbol,
        value,
      };
    });
    return mappedUnits;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.protobuf = {
  loadProtos: file => {
    return new Promise((resolve, reject) => {
      dcodeIO.ProtoBuf.loadProtoFile(file, (error, builder) => {
        if (error) {
          return reject(new Error(`Loading protocol buffer file failed: ${error.message}`));
        }

        z.proto = z.proto || {};
        _.extend(z.proto, builder.build());
        resolve();
      });
    });
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.KeyboardUtil = (() => {
  const KEY_DEFAULT = {
    ARROW_DOWN: 'ArrowDown',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    BACKSPACE: 'Backspace',
    DELETE: 'Delete',
    ENTER: 'Enter',
    ESC: 'Escape',
    KEY_V: 'v',
    SPACE: ' ',
    TAB: 'Tab',
  };

  const KEY_EDGE = {
    ARROW_DOWN: 'Down',
    ARROW_LEFT: 'Left',
    ARROW_RIGHT: 'Right',
    ARROW_UP: 'Up',
  };

  const KEYBOARD_KEY = z.util.Environment.browser.edge ? Object.assign(KEY_DEFAULT, KEY_EDGE) : KEY_DEFAULT;

  const _insertAtCaret = (areaId, text) => {
    // http://stackoverflow.com/a/1064139
    const textArea = document.getElementById(areaId);
    if (!textArea) {
      return;
    }

    const scrollPos = textArea.scrollTop;
    let strPos = 0;
    const br = textArea.selectionStart || textArea.selectionStart === '0' ? 'ff' : document.selection ? 'ie' : false;

    if (br === 'ie') {
      textArea.focus();
      const range = document.selection.createRange();
      range.moveStart('character', -textArea.value.length);
      strPos = range.text.length;
    } else if (br === 'ff') {
      strPos = textArea.selectionStart;
    }

    const front = textArea.value.substring(0, strPos);
    const back = textArea.value.substring(strPos, textArea.value.length);

    textArea.value = `${front}${text}${back}`;
    strPos = strPos + text.length;

    if (br === 'ie') {
      textArea.focus();
      const ieRange = document.selection.createRange();
      ieRange.moveStart('character', -textArea.value.length);
      ieRange.moveStart('character', strPos);
      ieRange.moveEnd('character', 0);
      ieRange.select();
    } else if (br === 'ff') {
      textArea.selectionStart = strPos;
      textArea.selectionEnd = strPos;
      textArea.focus();
    }

    textArea.scrollTop = scrollPos;
  };

  const _isArrowKey = keyboardEvent => {
    return _isOneOfKeys(keyboardEvent, [
      KEYBOARD_KEY.ARROW_DOWN,
      KEYBOARD_KEY.ARROW_LEFT,
      KEYBOARD_KEY.ARROW_RIGHT,
      KEYBOARD_KEY.ARROW_UP,
    ]);
  };

  const _isBackspaceKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.BACKSPACE);
  const _isDeleteKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.DELETE);
  const _isEnterKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.ENTER);
  const _isEscapeKey = keyboardEvent => _isKey(keyboardEvent, KEYBOARD_KEY.ESC);

  const _isFunctionKey = keyboardEvent => {
    return keyboardEvent.altKey || keyboardEvent.ctrlKey || keyboardEvent.metaKey || keyboardEvent.shiftKey;
  };

  const _isKey = (keyboardEvent = {}, expectedKey = '') => {
    const eventKey = keyboardEvent.key ? keyboardEvent.key.toLowerCase() : '';
    return eventKey === expectedKey.toLowerCase();
  };

  const _isMetaKey = keyboardEvent => keyboardEvent.metaKey || keyboardEvent.ctrlKey;

  const _isOneOfKeys = (keyboardEvent, expectedKeys = []) => {
    expectedKeys = expectedKeys.map(key => key.toLowerCase());

    const eventKey = keyboardEvent.key ? keyboardEvent.key.toLowerCase() : '';
    return !!expectedKeys.find(key => key === eventKey);
  };

  const _isPasteAction = keyboardEvent => {
    return _isMetaKey(keyboardEvent) && _isKey(keyboardEvent, KEYBOARD_KEY.KEY_V);
  };

  const _isRemovalAction = keyboardEvent => {
    return _isOneOfKeys(keyboardEvent, [KEYBOARD_KEY.BACKSPACE, KEYBOARD_KEY.DELETE]);
  };

  return {
    KEY: KEYBOARD_KEY,
    insertAtCaret: _insertAtCaret,
    isArrowKey: _isArrowKey,
    isBackspaceKey: _isBackspaceKey,
    isDeleteKey: _isDeleteKey,
    isEnterKey: _isEnterKey,
    isEscapeKey: _isEscapeKey,
    isFunctionKey: _isFunctionKey,
    isKey: _isKey,
    isMetaKey: _isMetaKey,
    isOneOfKeys: _isOneOfKeys,
    isPasteAction: _isPasteAction,
    isRemovalAction: _isRemovalAction,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.LocalizerUtil = {
  joinNames: (userEntities, declension = z.string.Declension.ACCUSATIVE, skipAnd = false, boldNames = false) => {
    const containsSelfUser = userEntities.some(userEntity => userEntity.is_me);
    if (containsSelfUser) {
      userEntities = userEntities.filter(userEntity => !userEntity.is_me);
    }

    const firstNames = userEntities
      .map(userEntity => {
        const firstName = userEntity.first_name();
        return boldNames ? `[bold]${firstName}[/bold]` : firstName;
      })
      .sort((userNameA, userNameB) => z.util.StringUtil.sortByPriority(userNameA, userNameB));

    if (containsSelfUser) {
      firstNames.push(z.util.SanitizationUtil.getSelfName(declension));
    }

    const numberOfNames = firstNames.length;
    const joinByAnd = !skipAnd && numberOfNames >= 2;
    if (joinByAnd) {
      const [secondLastName, lastName] = firstNames.splice(firstNames.length - 2, 2);

      const exactlyTwoNames = numberOfNames === 2;
      const additionalNames = exactlyTwoNames
        ? `${secondLastName} ${z.l10n.text(z.string.and)} ${lastName}`
        : `${secondLastName}${z.l10n.text(z.string.enumerationAnd)}${lastName}`;
      firstNames.push(additionalNames);
    }

    return firstNames.join(', ');
  },
};

/* eslint-disable */
(function() {
  'use strict';

  const _typeof =
    typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
      ? function(obj) {
          return typeof obj;
        }
      : function(obj) {
          return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype
            ? 'symbol'
            : typeof obj;
        };

  (function(exports) {
    'use strict';

    function inherits(parent, child) {
      const props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      const extended = Object.create(parent.prototype);
      for (const p in props) {
        extended[p] = props[p];
      }
      extended.constructor = child;
      child.prototype = extended;
      return child;
    }

    const defaults = {
      defaultProtocol: 'http',
      events: null,
      format: noop,
      formatHref: noop,
      nl2br: false,
      tagName: 'a',
      target: typeToTarget,
      validate: true,
      ignoreTags: [],
      attributes: null,
      className: 'linkified', // Deprecated value - no default class will be provided in the future
    };

    function Options(opts) {
      opts = opts || {};

      this.defaultProtocol = opts.hasOwnProperty('defaultProtocol') ? opts.defaultProtocol : defaults.defaultProtocol;
      this.events = opts.hasOwnProperty('events') ? opts.events : defaults.events;
      this.format = opts.hasOwnProperty('format') ? opts.format : defaults.format;
      this.formatHref = opts.hasOwnProperty('formatHref') ? opts.formatHref : defaults.formatHref;
      this.nl2br = opts.hasOwnProperty('nl2br') ? opts.nl2br : defaults.nl2br;
      this.tagName = opts.hasOwnProperty('tagName') ? opts.tagName : defaults.tagName;
      this.target = opts.hasOwnProperty('target') ? opts.target : defaults.target;
      this.validate = opts.hasOwnProperty('validate') ? opts.validate : defaults.validate;
      this.ignoreTags = [];

      // linkAttributes and linkClass is deprecated
      this.attributes = opts.attributes || opts.linkAttributes || defaults.attributes;
      this.className = opts.hasOwnProperty('className') ? opts.className : opts.linkClass || defaults.className;

      // Make all tags names upper case
      const ignoredTags = opts.hasOwnProperty('ignoreTags') ? opts.ignoreTags : defaults.ignoreTags;
      for (let i = 0; i < ignoredTags.length; i++) {
        this.ignoreTags.push(ignoredTags[i].toUpperCase());
      }
    }

    Options.prototype = {
      /**
       * Given the token, return all options for how it should be displayed
       */
      resolve: function resolve(token) {
        const href = token.toHref(this.defaultProtocol);
        return {
          formatted: this.get('format', token.toString(), token),
          formattedHref: this.get('formatHref', href, token),
          tagName: this.get('tagName', href, token),
          className: this.get('className', href, token),
          target: this.get('target', href, token),
          events: this.getObject('events', href, token),
          attributes: this.getObject('attributes', href, token),
        };
      },

      /**
       * Returns true or false based on whether a token should be displayed as a
       * link based on the user options. By default,
       */
      check: function check(token) {
        return this.get('validate', token.toString(), token);
      },

      // Private methods

      /**
       * Resolve an option's value based on the value of the option and the given
       * params.
       * @param {string} key - Name of option to use
       * @param operator - will be passed to the target option if it's method
       * @param {MultiToken} token - The token from linkify.tokenize
       */
      get: function get(key, operator, token) {
        let optionValue = void 0;

        const option = this[key];
        if (!option) {
          return option;
        }

        switch (typeof option === 'undefined' ? 'undefined' : _typeof(option)) {
          case 'function':
            return option(operator, token.type);
          case 'object':
            optionValue = option.hasOwnProperty(token.type) ? option[token.type] : defaults[key];
            return typeof optionValue === 'function' ? optionValue(operator, token.type) : optionValue;
        }

        return option;
      },
      getObject: function getObject(key, operator, token) {
        const option = this[key];
        return typeof option === 'function' ? option(operator, token.type) : option;
      },
    };

    /**
     * Quick indexOf replacement for checking the ignoreTags option
     */
    function contains(arr, value) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
          return true;
        }
      }
      return false;
    }

    function noop(val) {
      return val;
    }

    function typeToTarget(href, type) {
      return type === 'url' ? '_blank' : null;
    }

    const options = Object.freeze({
      defaults: defaults,
      Options: Options,
      contains: contains,
    });

    function createStateClass() {
      return function(tClass) {
        this.j = [];
        this.T = tClass || null;
      };
    }

    /**
 	A simple state machine that can emit token classes

 	The `j` property in this class refers to state jumps. It's a
 	multidimensional array where for each element:

 	* index [0] is a symbol or class of symbols to transition to.
 	* index [1] is a State instance which matches

 	The type of symbol will depend on the target implementation for this class.
 	In Linkify, we have a two-stage scanner. Each stage uses this state machine
 	but with a slighly different (polymorphic) implementation.

 	The `T` property refers to the token class.

 	TODO: Can the `on` and `next` methods be combined?

 	@class BaseState
 */
    const BaseState = createStateClass();
    BaseState.prototype = {
      defaultTransition: false,

      /**
  	@method constructor
  	@param {Class} tClass Pass in the kind of token to emit if there are
  		no jumps after this state and the state is accepting.
  */

      /**
  	On the given symbol(s), this machine should go to the given state
  		@method on
  	@param {Array|Mixed} symbol
  	@param {BaseState} state Note that the type of this state should be the
  		same as the current instance (i.e., don't pass in a different
  		subclass)
  */
      on: function on(symbol, state) {
        if (symbol instanceof Array) {
          for (let i = 0; i < symbol.length; i++) {
            this.j.push([symbol[i], state]);
          }
          return this;
        }
        this.j.push([symbol, state]);
        return this;
      },

      /**
  	Given the next item, returns next state for that item
  	@method next
  	@param {Mixed} item Should be an instance of the symbols handled by
  		this particular machine.
  	@returns {State} state Returns false if no jumps are available
  */
      next: function next(item) {
        for (let i = 0; i < this.j.length; i++) {
          const jump = this.j[i];
          const symbol = jump[0]; // Next item to check for
          const state = jump[1]; // State to jump to if items match

          // compare item with symbol
          if (this.test(item, symbol)) {
            return state;
          }
        }

        // Nowhere left to jump!
        return this.defaultTransition;
      },

      /**
  	Does this state accept?
  	`true` only of `this.T` exists
  		@method accepts
  	@returns {boolean}
  */
      accepts: function accepts() {
        return !!this.T;
      },

      /**
  	Determine whether a given item "symbolizes" the symbol, where symbol is
  	a class of items handled by this state machine.
  		This method should be overriden in extended classes.
  		@method test
  	@param {Mixed} item - Does this item match the given symbol?
  	@param {Mixed} symbol
  	@returns {boolean}
  */
      test: function test(item, symbol) {
        return item === symbol;
      },

      /**
  	Emit the token for this State (just return it in this case)
  	If this emits a token, this instance is an accepting state
  	@method emit
  	@returns {Class} T
  */
      emit: function emit() {
        return this.T;
      },
    };

    /**
 	State machine for string-based input

 	@class CharacterState
 	@extends BaseState
 */
    const CharacterState = inherits(BaseState, createStateClass(), {
      /**
  	Does the given character match the given character or regular
  	expression?
  		@method test
  	@param {string} char
  	@param {string|RegExp} charOrRegExp
  	@returns {boolean}
  */
      test: function test(character, charOrRegExp) {
        return character === charOrRegExp || (charOrRegExp instanceof RegExp && charOrRegExp.test(character));
      },
    });

    /**
 	State machine for input in the form of TextTokens

 	@class TokenState
 	@extends BaseState
 */
    const TokenState = inherits(BaseState, createStateClass(), {
      /**
       * Similar to `on`, but returns the state the results in the transition from
       * the given item
       * @method jump
       * @param {Mixed} item
       * @param {Token} [token]
       * @returns state
       */
      jump: function jump(token) {
        const tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        let state = this.next(new token('')); // dummy temp token
        if (state === this.defaultTransition) {
          // Make a new state!
          state = new this.constructor(tClass);
          this.on(token, state);
        } else if (tClass) {
          state.T = tClass;
        }
        return state;
      },

      /**
  	Is the given token an instance of the given token class?
  		@method test
  	@param {TextToken} token
  	@param {Class} tokenClass
  	@returns {boolean}
  */
      test: function test(token, tokenClass) {
        return token instanceof tokenClass;
      },
    });

    /**
 	Given a non-empty target string, generates states (if required) for each
 	consecutive substring of characters in str starting from the beginning of
 	the string. The final state will have a special value, as specified in
 	options. All other "in between" substrings will have a default end state.

 	This turns the state machine into a Trie-like data structure (rather than a
 	intelligently-designed DFA).

 	Note that I haven't really tried these with any strings other than
 	DOMAIN.

 	@param {string} str
 	@param {CharacterState} start - State to jump from the first character
 	@param {Class} endToken Token class to emit when the given string has been
 		matched and no more jumps exist.
 	@param {Class} defaultToken "Filler token", or which token type to emit when
 		we don't have a full match
 	@returns {Array} list of newly-created states
 */
    function stateify(str, start, endToken, defaultToken) {
      let i = 0;

      const len = str.length;

      let state = start;

      const newStates = [];

      let nextState = void 0;

      // Find the next state without a jump to the next character
      while (i < len && (nextState = state.next(str[i]))) {
        state = nextState;
        i++;
      }

      if (i >= len) {
        return [];
      } // no new tokens were added

      while (i < len - 1) {
        nextState = new CharacterState(defaultToken);
        newStates.push(nextState);
        state.on(str[i], nextState);
        state = nextState;
        i++;
      }

      nextState = new CharacterState(endToken);
      newStates.push(nextState);
      state.on(str[len - 1], nextState);

      return newStates;
    }

    function createTokenClass() {
      return function(value) {
        if (value) {
          this.v = value;
        }
      };
    }

    /******************************************************************************
 	Text Tokens
 	Tokens composed of strings
 ******************************************************************************/

    /**
 	Abstract class used for manufacturing text tokens.
 	Pass in the value this token represents

 	@class TextToken
 	@abstract
 */
    const TextToken = createTokenClass();
    TextToken.prototype = {
      toString: function toString() {
        return `${this.v}`;
      },
    };

    function inheritsToken(value) {
      const props = value ? {v: value} : {};
      return inherits(TextToken, createTokenClass(), props);
    }

    /**
 	A valid domain token
 	@class DOMAIN
 	@extends TextToken
 */
    const DOMAIN = inheritsToken();

    /**
 	@class AT
 	@extends TextToken
 */
    const AT = inheritsToken('@');

    /**
 	Represents a single colon `:` character

 	@class COLON
 	@extends TextToken
 */
    const COLON = inheritsToken(':');

    /**
 	@class DOT
 	@extends TextToken
 */
    const DOT = inheritsToken('.');

    /**
 	A character class that can surround the URL, but which the URL cannot begin
 	or end with. Does not include certain English punctuation like parentheses.

 	@class PUNCTUATION
 	@extends TextToken
 */
    const PUNCTUATION = inheritsToken();

    /**
 	The word localhost (by itself)
 	@class LOCALHOST
 	@extends TextToken
 */
    const LOCALHOST = inheritsToken();

    /**
 	Newline token
 	@class NL
 	@extends TextToken
 */
    const NL = inheritsToken('\n');

    /**
 	@class NUM
 	@extends TextToken
 */
    const NUM = inheritsToken();

    /**
 	@class PLUS
 	@extends TextToken
 */
    const PLUS = inheritsToken('+');

    /**
 	@class POUND
 	@extends TextToken
 */
    const POUND = inheritsToken('#');

    /**
 	Represents a web URL protocol. Supported types include

 	* `http:`
 	* `https:`
 	* `ftp:`
 	* `ftps:`

 	@class PROTOCOL
 	@extends TextToken
 */
    const PROTOCOL = inheritsToken();

    /**
 	Represents the start of the email URI protocol

 	@class MAILTO
 	@extends TextToken
 */
    const MAILTO = inheritsToken('mailto:');

    /**
 	@class QUERY
 	@extends TextToken
 */
    const QUERY = inheritsToken('?');

    /**
 	@class SLASH
 	@extends TextToken
 */
    const SLASH = inheritsToken('/');

    /**
 	@class UNDERSCORE
 	@extends TextToken
 */
    const UNDERSCORE = inheritsToken('_');

    /**
 	One ore more non-whitespace symbol.
 	@class SYM
 	@extends TextToken
 */
    const SYM = inheritsToken();

    /**
 	@class TLD
 	@extends TextToken
 */
    const TLD = inheritsToken();

    /**
 	Represents a string of consecutive whitespace characters

 	@class WS
 	@extends TextToken
 */
    const WS = inheritsToken();

    /**
 	Opening/closing bracket classes
 */

    const OPENBRACE = inheritsToken('{');
    const OPENBRACKET = inheritsToken('[');
    const OPENANGLEBRACKET = inheritsToken('<');
    const OPENPAREN = inheritsToken('(');
    const CLOSEBRACE = inheritsToken('}');
    const CLOSEBRACKET = inheritsToken(']');
    const CLOSEANGLEBRACKET = inheritsToken('>');
    const CLOSEPAREN = inheritsToken(')');

    const AMPERSAND = inheritsToken('&');

    const text = Object.freeze({
      Base: TextToken,
      DOMAIN: DOMAIN,
      AT: AT,
      COLON: COLON,
      DOT: DOT,
      PUNCTUATION: PUNCTUATION,
      LOCALHOST: LOCALHOST,
      NL: NL,
      NUM: NUM,
      PLUS: PLUS,
      POUND: POUND,
      QUERY: QUERY,
      PROTOCOL: PROTOCOL,
      MAILTO: MAILTO,
      SLASH: SLASH,
      UNDERSCORE: UNDERSCORE,
      SYM: SYM,
      TLD: TLD,
      WS: WS,
      OPENBRACE: OPENBRACE,
      OPENBRACKET: OPENBRACKET,
      OPENANGLEBRACKET: OPENANGLEBRACKET,
      OPENPAREN: OPENPAREN,
      CLOSEBRACE: CLOSEBRACE,
      CLOSEBRACKET: CLOSEBRACKET,
      CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
      CLOSEPAREN: CLOSEPAREN,
      AMPERSAND: AMPERSAND,
    });

    /**
 	The scanner provides an interface that takes a string of text as input, and
 	outputs an array of tokens instances that can be used for easy URL parsing.

 	@module linkify
 	@submodule scanner
 	@main scanner
 */

    const tlds = 'aaa|aarp|abarth|abb|abbott|abbvie|abc|able|abogado|abudhabi|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|aetna|af|afamilycompany|afl|africa|ag|agakhan|agency|ai|aig|aigo|airbus|airforce|airtel|akdn|al|alfaromeo|alibaba|alipay|allfinanz|allstate|ally|alsace|alstom|am|americanexpress|americanfamily|amex|amfam|amica|amsterdam|analytics|android|anquan|anz|ao|aol|apartments|app|apple|aq|aquarelle|ar|arab|aramco|archi|army|arpa|art|arte|as|asda|asia|associates|at|athleta|attorney|au|auction|audi|audible|audio|auspost|author|auto|autos|avianca|aw|aws|ax|axa|az|azure|ba|baby|baidu|banamex|bananarepublic|band|bank|bar|barcelona|barclaycard|barclays|barefoot|bargains|baseball|basketball|bauhaus|bayern|bb|bbc|bbt|bbva|bcg|bcn|bd|be|beats|beauty|beer|bentley|berlin|best|bestbuy|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|blanco|blockbuster|blog|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bofa|bom|bond|boo|book|booking|boots|bosch|bostik|boston|bot|boutique|box|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|calvinklein|cam|camera|camp|cancerresearch|canon|capetown|capital|capitalone|car|caravan|cards|care|career|careers|cars|cartier|casa|case|caseih|cash|casino|cat|catering|catholic|cba|cbn|cbre|cbs|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chintai|chloe|christmas|chrome|chrysler|church|ci|cipriani|circle|cisco|citadel|citi|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|comcast|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cookingchannel|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruise|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|data|date|dating|datsun|day|dclk|dds|de|deal|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|dhl|diamonds|diet|digital|direct|directory|discount|discover|dish|diy|dj|dk|dm|dnp|do|docs|doctor|dodge|dog|doha|domains|dot|download|drive|dtv|dubai|duck|dunlop|duns|dupont|durban|dvag|dvr|dz|earth|eat|ec|eco|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epost|epson|equipment|er|ericsson|erni|es|esq|estate|esurance|et|etisalat|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|extraspace|fage|fail|fairwinds|faith|family|fan|fans|farm|farmers|fashion|fast|fedex|feedback|ferrari|ferrero|fi|fiat|fidelity|fido|film|final|finance|financial|fire|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|flir|florist|flowers|fly|fm|fo|foo|food|foodnetwork|football|ford|forex|forsale|forum|foundation|fox|fr|free|fresenius|frl|frogans|frontdoor|frontier|ftr|fujitsu|fujixerox|fun|fund|furniture|futbol|fyi|ga|gal|gallery|gallo|gallup|game|games|gap|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|george|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glade|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|godaddy|gold|goldpoint|golf|goo|goodhands|goodyear|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|grocery|group|gs|gt|gu|guardian|gucci|guge|guide|guitars|guru|gw|gy|hair|hamburg|hangout|haus|hbo|hdfc|hdfcbank|health|healthcare|help|helsinki|here|hermes|hgtv|hiphop|hisamitsu|hitachi|hiv|hk|hkt|hm|hn|hockey|holdings|holiday|homedepot|homegoods|homes|homesense|honda|honeywell|horse|hospital|host|hosting|hot|hoteles|hotels|hotmail|house|how|hr|hsbc|ht|htc|hu|hughes|hyatt|hyundai|ibm|icbc|ice|icu|id|ie|ieee|ifm|ikano|il|im|imamat|imdb|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|intel|international|intuit|investments|io|ipiranga|iq|ir|irish|is|iselect|ismaili|ist|istanbul|it|itau|itv|iveco|iwc|jaguar|java|jcb|jcp|je|jeep|jetzt|jewelry|jio|jlc|jll|jm|jmp|jnj|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|juniper|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kindle|kitchen|kiwi|km|kn|koeln|komatsu|kosher|kp|kpmg|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|ladbrokes|lamborghini|lamer|lancaster|lancia|lancome|land|landrover|lanxess|lasalle|lat|latino|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|lefrak|legal|lego|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|lilly|limited|limo|lincoln|linde|link|lipsy|live|living|lixil|lk|loan|loans|locker|locus|loft|lol|london|lotte|lotto|love|lpl|lplfinancial|lr|ls|lt|ltd|ltda|lu|lundbeck|lupin|luxe|luxury|lv|ly|ma|macys|madrid|maif|maison|makeup|man|management|mango|map|market|marketing|markets|marriott|marshalls|maserati|mattel|mba|mc|mckinsey|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|merckmsd|metlife|mg|mh|miami|microsoft|mil|mini|mint|mit|mitsubishi|mk|ml|mlb|mls|mm|mma|mn|mo|mobi|mobile|mobily|moda|moe|moi|mom|monash|money|monster|mopar|mormon|mortgage|moscow|moto|motorcycles|mov|movie|movistar|mp|mq|mr|ms|msd|mt|mtn|mtr|mu|museum|mutual|mv|mw|mx|my|mz|na|nab|nadex|nagoya|name|nationwide|natura|navy|nba|nc|ne|nec|net|netbank|netflix|network|neustar|new|newholland|news|next|nextdirect|nexus|nf|nfl|ng|ngo|nhk|ni|nico|nike|nikon|ninja|nissan|nissay|nl|no|nokia|northwesternmutual|norton|now|nowruz|nowtv|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|observer|off|office|okinawa|olayan|olayangroup|oldnavy|ollo|om|omega|one|ong|onl|online|onyourside|ooo|open|oracle|orange|org|organic|origins|osaka|otsuka|ott|ovh|pa|page|panasonic|panerai|paris|pars|partners|parts|party|passagens|pay|pccw|pe|pet|pf|pfizer|pg|ph|pharmacy|phd|philips|phone|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pioneer|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pnc|pohl|poker|politie|porn|post|pr|pramerica|praxi|press|prime|pro|prod|productions|prof|progressive|promo|properties|property|protection|pru|prudential|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|qvc|racing|radio|raid|re|read|realestate|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|reliance|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|richardli|ricoh|rightathome|ril|rio|rip|rmit|ro|rocher|rocks|rodeo|rogers|room|rs|rsvp|ru|rugby|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsclub|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|save|saxo|sb|sbi|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scjohnson|scor|scot|sd|se|search|seat|secure|security|seek|select|sener|services|ses|seven|sew|sex|sexy|sfr|sg|sh|shangrila|sharp|shaw|shell|shia|shiksha|shoes|shop|shopping|shouji|show|showtime|shriram|si|silk|sina|singles|site|sj|sk|ski|skin|sky|skype|sl|sling|sm|smart|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|srt|st|stada|staples|star|starhub|statebank|statefarm|statoil|stc|stcgroup|stockholm|storage|store|stream|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiftcover|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|talk|taobao|target|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|tdk|team|tech|technology|tel|telecity|telefonica|temasek|tennis|teva|tf|tg|th|thd|theater|theatre|tiaa|tickets|tienda|tiffany|tips|tires|tirol|tj|tjmaxx|tjx|tk|tkmaxx|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tr|trade|trading|training|travel|travelchannel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubank|ubs|uconnect|ug|uk|unicom|university|uno|uol|ups|us|uy|uz|va|vacations|vana|vanguard|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|vig|viking|villas|vin|vip|virgin|visa|vision|vista|vistaprint|viva|vivo|vlaanderen|vn|vodka|volkswagen|volvo|vote|voting|voto|voyage|vu|vuelos|wales|walmart|walter|wang|wanggou|warman|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weibo|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|winners|wme|wolterskluwer|woodside|work|works|world|wow|ws|wtc|wtf|xbox|xerox|xfinity|xihuan|xin|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--30rr7y|xn--3bst00m|xn--3ds443g|xn--3e0b707e|xn--3hcrj9c|xn--3oq18vl8pn36a|xn--3pxu8k|xn--42c2d9a|xn--45br5cyl|xn--45brj9c|xn--45q11c|xn--4gbrim|xn--54b7fta0cc|xn--55qw42g|xn--55qx5d|xn--5su34j936bgsg|xn--5tzm5g|xn--6frz82g|xn--6qq986b3xl|xn--80adxhks|xn--80ao21a|xn--80aqecdr1a|xn--80asehdb|xn--80aswg|xn--8y0a063a|xn--90a3ac|xn--90ae|xn--90ais|xn--9dbq2a|xn--9et52u|xn--9krt00a|xn--b4w605ferd|xn--bck1b9a5dre4c|xn--c1avg|xn--c2br7g|xn--cck2b3b|xn--cg4bki|xn--clchc0ea0b2g2a9gcd|xn--czr694b|xn--czrs0t|xn--czru2d|xn--d1acj3b|xn--d1alf|xn--e1a4c|xn--eckvdtc9d|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fhbei|xn--fiq228c5hs|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--fjq720a|xn--flw351e|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--fzys8d69uvgm|xn--g2xx48c|xn--gckr3f0f|xn--gecrj9c|xn--gk3at1e|xn--h2breg3eve|xn--h2brj9c|xn--h2brj9c8c|xn--hxt814e|xn--i1b6b1a6a2e|xn--imr513n|xn--io0a7i|xn--j1aef|xn--j1amh|xn--j6w193g|xn--jlq61u9w7b|xn--jvr189m|xn--kcrx77d1x4a|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--kput3i|xn--l1acc|xn--lgbbat1ad8j|xn--mgb9awbf|xn--mgba3a3ejt|xn--mgba3a4f16a|xn--mgba7c0bbn0a|xn--mgbaakc7dvf|xn--mgbaam7a8h|xn--mgbab2bd|xn--mgbai9azgqp6j|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a|xn--mgbbh1a71e|xn--mgbc0a9azcg|xn--mgbca7dzdo|xn--mgberp4a5d4ar|xn--mgbgu82a|xn--mgbi4ecexp|xn--mgbpl2fh|xn--mgbt3dhd|xn--mgbtx2b|xn--mgbx4cd0ab|xn--mix891f|xn--mk1bu44c|xn--mxtq1m|xn--ngbc5azd|xn--ngbe9e0a|xn--ngbrx|xn--node|xn--nqv7f|xn--nqv7fs00ema|xn--nyqy26a|xn--o3cw4h|xn--ogbpf8fl|xn--p1acf|xn--p1ai|xn--pbt977c|xn--pgbs0dh|xn--pssy2u|xn--q9jyb4c|xn--qcka1pmc|xn--qxam|xn--rhqv96g|xn--rovu88b|xn--rvc1e0am3e|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--tckwe|xn--tiq49xqyj|xn--unup4y|xn--vermgensberater-ctb|xn--vermgensberatung-pwb|xn--vhquv|xn--vuq861b|xn--w4r85el8fhu5dnra|xn--w4rs40l|xn--wgbh1c|xn--wgbl6a|xn--xhq521b|xn--xkc2al3hye2a|xn--xkc2dl3a5ee0h|xn--y9a3aq|xn--yfro4i67o|xn--ygbi2ammx|xn--zfr164b|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|you|youtube|yt|yun|za|zappos|zara|zero|zip|zippo|zm|zone|zuerich|zw'.split(
      '|'
    ); // macro, see gulpfile.js

    const NUMBERS = '0123456789'.split('');
    const ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
    const WHITESPACE = [' ', '\f', '\r', '\t', '\v', '\xA0', '\u1680', '\u180E']; // excluding line breaks

    const domainStates = []; // states that jump to DOMAIN on /[a-z0-9]/
    const makeState = function makeState(tokenClass) {
      return new CharacterState(tokenClass);
    };

    // Frequently used states
    const S_START = makeState();
    const S_NUM = makeState(NUM);
    const S_DOMAIN = makeState(DOMAIN);
    const S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters
    const S_WS = makeState(WS);

    // States for special URL symbols
    S_START.on('@', makeState(AT))
      .on('.', makeState(DOT))
      .on('+', makeState(PLUS))
      .on('#', makeState(POUND))
      .on('?', makeState(QUERY))
      .on('/', makeState(SLASH))
      .on('_', makeState(UNDERSCORE))
      .on(':', makeState(COLON))
      .on('{', makeState(OPENBRACE))
      .on('[', makeState(OPENBRACKET))
      .on('<', makeState(OPENANGLEBRACKET))
      .on('(', makeState(OPENPAREN))
      .on('}', makeState(CLOSEBRACE))
      .on(']', makeState(CLOSEBRACKET))
      .on('>', makeState(CLOSEANGLEBRACKET))
      .on(')', makeState(CLOSEPAREN))
      .on('&', makeState(AMPERSAND))
      .on([',', ';', '!', '"', "'"], makeState(PUNCTUATION));

    // Whitespace jumps
    // Tokens of only non-newline whitespace are arbitrarily long
    S_START.on('\n', makeState(NL)).on(WHITESPACE, S_WS);

    // If any whitespace except newline, more whitespace!
    S_WS.on(WHITESPACE, S_WS);

    // Generates states for top-level domains
    // Note that this is most accurate when tlds are in alphabetical order
    for (let i = 0; i < tlds.length; i++) {
      const newStates = stateify(tlds[i], S_START, TLD, DOMAIN);
      domainStates.push(...newStates);
    }

    // Collect the states generated by different protocls
    const partialProtocolFileStates = stateify('file', S_START, DOMAIN, DOMAIN);
    const partialProtocolFtpStates = stateify('ftp', S_START, DOMAIN, DOMAIN);
    const partialProtocolHttpStates = stateify('http', S_START, DOMAIN, DOMAIN);
    const partialProtocolMailtoStates = stateify('mailto', S_START, DOMAIN, DOMAIN);

    // Add the states to the array of DOMAINeric states
    domainStates.push(...partialProtocolFileStates);
    domainStates.push(...partialProtocolFtpStates);
    domainStates.push(...partialProtocolHttpStates);
    domainStates.push(...partialProtocolMailtoStates);

    // Protocol states
    const S_PROTOCOL_FILE = partialProtocolFileStates.pop();
    const S_PROTOCOL_FTP = partialProtocolFtpStates.pop();
    const S_PROTOCOL_HTTP = partialProtocolHttpStates.pop();
    const S_MAILTO = partialProtocolMailtoStates.pop();
    const S_PROTOCOL_SECURE = makeState(DOMAIN);
    const S_FULL_PROTOCOL = makeState(PROTOCOL); // Full protocol ends with COLON
    const S_FULL_MAILTO = makeState(MAILTO); // Mailto ends with COLON

    // Secure protocols (end with 's')
    S_PROTOCOL_FTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

    S_PROTOCOL_HTTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);

    domainStates.push(S_PROTOCOL_SECURE);

    // Become protocol tokens after a COLON
    S_PROTOCOL_FILE.on(':', S_FULL_PROTOCOL);
    S_PROTOCOL_SECURE.on(':', S_FULL_PROTOCOL);
    S_MAILTO.on(':', S_FULL_MAILTO);

    // Localhost
    const partialLocalhostStates = stateify('localhost', S_START, LOCALHOST, DOMAIN);
    domainStates.push(...partialLocalhostStates);

    // Everything else
    // DOMAINs make more DOMAINs
    // Number and character transitions
    S_START.on(NUMBERS, S_NUM);
    S_NUM.on('-', S_DOMAIN_HYPHEN)
      .on(NUMBERS, S_NUM)
      .on(ALPHANUM, S_DOMAIN); // number becomes DOMAIN

    S_DOMAIN.on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);

    // All the generated states should have a jump to DOMAIN
    for (let _i = 0; _i < domainStates.length; _i++) {
      domainStates[_i].on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
    }

    S_DOMAIN_HYPHEN.on('-', S_DOMAIN_HYPHEN)
      .on(NUMBERS, S_DOMAIN)
      .on(ALPHANUM, S_DOMAIN);

    // Set default transition
    S_START.defaultTransition = makeState(SYM);

    /**
 	Given a string, returns an array of TOKEN instances representing the
 	composition of that string.

 	@method run
 	@param {string} str - Input string to scan
 	@returns {Array} Array of TOKEN instances
 */
    const run = function run(str) {
      // The state machine only looks at lowercase strings.
      // This selective `toLowerCase` is used because lowercasing the entire
      // string causes the length and character position to vary in some in some
      // non-English strings. This happens only on V8-based runtimes.
      const lowerStr = str.replace(/[A-Z]/g, c => {
        return c.toLowerCase();
      });
      const len = str.length;
      const tokens = []; // return value

      let cursor = 0;

      // Tokenize the string
      while (cursor < len) {
        let state = S_START;
        let nextState = null;
        let tokenLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;

        while (cursor < len && (nextState = state.next(lowerStr[cursor]))) {
          state = nextState;

          // Keep track of the latest accepting state
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }

          tokenLength++;
          cursor++;
        }

        if (sinceAccepts < 0) {
          continue;
        } // Should never happen

        // Roll back to the latest accepting state
        cursor -= sinceAccepts;
        tokenLength -= sinceAccepts;

        // Get the class for the new token
        const TOKEN = latestAccepting.emit(); // Current token class

        // No more jumps, just make a new token
        tokens.push(new TOKEN(str.substr(cursor - tokenLength, tokenLength)));
      }

      return tokens;
    };

    const start = S_START;

    const scanner = Object.freeze({
      State: CharacterState,
      TOKENS: text,
      run: run,
      start: start,
    });

    /******************************************************************************
 	Multi-Tokens
 	Tokens composed of arrays of TextTokens
 ******************************************************************************/

    // Is the given token a valid domain token?
    // Should nums be included here?
    function isDomainToken(token) {
      return token instanceof DOMAIN || token instanceof TLD;
    }

    /**
 	Abstract class used for manufacturing tokens of text tokens. That is rather
 	than the value for a token being a small string of text, it's value an array
 	of text tokens.

 	Used for grouping together URLs, emails, hashtags, and other potential
 	creations.

 	@class MultiToken
 	@abstract
 */
    const MultiToken = createTokenClass();

    MultiToken.prototype = {
      /**
  	String representing the type for this token
  	@property type
  	@default 'TOKEN'
  */
      type: 'token',

      /**
  	Is this multitoken a link?
  	@property isLink
  	@default false
  */
      isLink: false,

      /**
  	Return the string this token represents.
  	@method toString
  	@returns {string}
  */
      toString: function toString() {
        const result = [];
        for (let _i2 = 0; _i2 < this.v.length; _i2++) {
          result.push(this.v[_i2].toString());
        }
        return result.join('');
      },

      /**
  	What should the value for this token be in the `href` HTML attribute?
  	Returns the `.toString` value by default.
  		@method toHref
  	@returns {string}
  */
      toHref: function toHref() {
        return this.toString();
      },

      /**
  	Returns a hash of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] - `'http'` by default
  	@returns {Object}
  */
      toObject: function toObject() {
        const protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

        return {
          type: this.type,
          value: this.toString(),
          href: this.toHref(protocol),
        };
      },
    };

    /**
 	Represents an arbitrarily mailto email address with the prefix included
 	@class MAILTO
 	@extends MultiToken
 */
    const MAILTOEMAIL = inherits(MultiToken, createTokenClass(), {
      type: 'email',
      isLink: true,
    });

    /**
 	Represents a list of tokens making up a valid email address
 	@class EMAIL
 	@extends MultiToken
 */
    const EMAIL = inherits(MultiToken, createTokenClass(), {
      type: 'email',
      isLink: true,
      toHref: function toHref() {
        return `mailto:${this.toString()}`;
      },
    });

    /**
 	Represents some plain text
 	@class TEXT
 	@extends MultiToken
 */
    const TEXT = inherits(MultiToken, createTokenClass(), {type: 'text'});

    /**
 	Multi-linebreak token - represents a line break
 	@class NL
 	@extends MultiToken
 */
    const NL$1 = inherits(MultiToken, createTokenClass(), {type: 'nl'});

    /**
 	Represents a list of tokens making up a valid URL
 	@class URL
 	@extends MultiToken
 */
    const URL = inherits(MultiToken, createTokenClass(), {
      type: 'url',
      isLink: true,

      /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@method href
  	@param {string} protocol
  	@returns {string}
  */
      toHref: function toHref() {
        const protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';

        let hasProtocol = false;
        let hasSlashSlash = false;
        const tokens = this.v;
        let result = [];
        let i = 0;

        // Make the first part of the domain lowercase
        // Lowercase protocol
        while (tokens[i] instanceof PROTOCOL) {
          hasProtocol = true;
          result.push(tokens[i].toString().toLowerCase());
          i++;
        }

        // Skip slash-slash
        while (tokens[i] instanceof SLASH) {
          hasSlashSlash = true;
          result.push(tokens[i].toString());
          i++;
        }

        // Lowercase all other characters in the domain
        while (isDomainToken(tokens[i])) {
          result.push(tokens[i].toString().toLowerCase());
          i++;
        }

        // Leave all other characters as they were written
        for (; i < tokens.length; i++) {
          result.push(tokens[i].toString());
        }

        result = result.join('');

        if (!(hasProtocol || hasSlashSlash)) {
          result = `${protocol}://${result}`;
        }

        return result;
      },
      hasProtocol: function hasProtocol() {
        return this.v[0] instanceof PROTOCOL;
      },
    });

    const multi = Object.freeze({
      Base: MultiToken,
      MAILTOEMAIL: MAILTOEMAIL,
      EMAIL: EMAIL,
      NL: NL$1,
      TEXT: TEXT,
      URL: URL,
    });

    /**
 	Not exactly parser, more like the second-stage scanner (although we can
 	theoretically hotswap the code here with a real parser in the future... but
 	for a little URL-finding utility abstract syntax trees may be a little
 	overkill).

 	URL format: http://en.wikipedia.org/wiki/URI_scheme
 	Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
 	reference)

 	@module linkify
 	@submodule parser
 	@main parser
 */

    const makeState$1 = function makeState$1(tokenClass) {
      return new TokenState(tokenClass);
    };

    // The universal starting state.
    const S_START$1 = makeState$1();

    // Intermediate states for URLs. Note that domains that begin with a protocol
    // are treated slighly differently from those that don't.
    const S_PROTOCOL = makeState$1(); // e.g., 'http:'
    const S_MAILTO$1 = makeState$1(); // 'mailto:'
    const S_PROTOCOL_SLASH = makeState$1(); // e.g., '/', 'http:/''
    const S_PROTOCOL_SLASH_SLASH = makeState$1(); // e.g., '//', 'http://'
    const S_DOMAIN$1 = makeState$1(); // parsed string ends with a potential domain name (A)
    const S_DOMAIN_DOT = makeState$1(); // (A) domain followed by DOT
    const S_TLD = makeState$1(URL); // (A) Simplest possible URL with no query string
    const S_TLD_COLON = makeState$1(); // (A) URL followed by colon (potential port number here)
    const S_TLD_PORT = makeState$1(URL); // TLD followed by a port number
    const S_URL = makeState$1(URL); // Long URL with optional port and maybe query string
    const S_URL_NON_ACCEPTING = makeState$1(); // URL followed by some symbols (will not be part of the final URL)
    const S_URL_OPENBRACE = makeState$1(); // URL followed by {
    const S_URL_OPENBRACKET = makeState$1(); // URL followed by [
    const S_URL_OPENANGLEBRACKET = makeState$1(); // URL followed by <
    const S_URL_OPENPAREN = makeState$1(); // URL followed by (
    const S_URL_OPENBRACE_Q = makeState$1(URL); // URL followed by { and some symbols that the URL can end it
    const S_URL_OPENBRACKET_Q = makeState$1(URL); // URL followed by [ and some symbols that the URL can end it
    const S_URL_OPENANGLEBRACKET_Q = makeState$1(URL); // URL followed by < and some symbols that the URL can end it
    const S_URL_OPENPAREN_Q = makeState$1(URL); // URL followed by ( and some symbols that the URL can end it
    const S_URL_OPENBRACE_SYMS = makeState$1(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it
    const S_URL_OPENBRACKET_SYMS = makeState$1(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it
    const S_URL_OPENANGLEBRACKET_SYMS = makeState$1(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it
    const S_URL_OPENPAREN_SYMS = makeState$1(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it
    const S_EMAIL_DOMAIN = makeState$1(); // parsed string starts with local email info + @ with a potential domain name (C)
    const S_EMAIL_DOMAIN_DOT = makeState$1(); // (C) domain followed by DOT
    const S_EMAIL = makeState$1(EMAIL); // (C) Possible email address (could have more tlds)
    const S_EMAIL_COLON = makeState$1(); // (C) URL followed by colon (potential port number here)
    const S_EMAIL_PORT = makeState$1(EMAIL); // (C) Email address with a port
    const S_MAILTO_EMAIL = makeState$1(MAILTOEMAIL); // Email that begins with the mailto prefix (D)
    const S_MAILTO_EMAIL_NON_ACCEPTING = makeState$1(); // (D) Followed by some non-query string chars
    const S_LOCALPART = makeState$1(); // Local part of the email address
    const S_LOCALPART_AT = makeState$1(); // Local part of the email address plus @
    const S_LOCALPART_DOT = makeState$1(); // Local part of the email address plus '.' (localpart cannot end in .)
    const S_NL = makeState$1(NL$1); // single new line

    // Make path from start to protocol (with '//')
    S_START$1.on(NL, S_NL)
      .on(PROTOCOL, S_PROTOCOL)
      .on(MAILTO, S_MAILTO$1)
      .on(SLASH, S_PROTOCOL_SLASH);

    S_PROTOCOL.on(SLASH, S_PROTOCOL_SLASH);
    S_PROTOCOL_SLASH.on(SLASH, S_PROTOCOL_SLASH_SLASH);

    // The very first potential domain name
    S_START$1.on(TLD, S_DOMAIN$1)
      .on(DOMAIN, S_DOMAIN$1)
      .on(LOCALHOST, S_TLD)
      .on(NUM, S_DOMAIN$1);

    // Force URL for protocol followed by anything sane
    S_PROTOCOL_SLASH_SLASH.on(TLD, S_URL)
      .on(DOMAIN, S_URL)
      .on(NUM, S_URL)
      .on(LOCALHOST, S_URL);

    // Account for dots and hyphens
    // hyphens are usually parts of domain names
    S_DOMAIN$1.on(DOT, S_DOMAIN_DOT);
    S_EMAIL_DOMAIN.on(DOT, S_EMAIL_DOMAIN_DOT);

    // Hyphen can jump back to a domain name

    // After the first domain and a dot, we can find either a URL or another domain
    S_DOMAIN_DOT.on(TLD, S_TLD)
      .on(DOMAIN, S_DOMAIN$1)
      .on(NUM, S_DOMAIN$1)
      .on(LOCALHOST, S_DOMAIN$1);

    S_EMAIL_DOMAIN_DOT.on(TLD, S_EMAIL)
      .on(DOMAIN, S_EMAIL_DOMAIN)
      .on(NUM, S_EMAIL_DOMAIN)
      .on(LOCALHOST, S_EMAIL_DOMAIN);

    // S_TLD accepts! But the URL could be longer, try to find a match greedily
    // The `run` function should be able to "rollback" to the accepting state
    S_TLD.on(DOT, S_DOMAIN_DOT);
    S_EMAIL.on(DOT, S_EMAIL_DOMAIN_DOT);

    // Become real URLs after `SLASH` or `COLON NUM SLASH`
    // Here PSS and non-PSS converge
    S_TLD.on(COLON, S_TLD_COLON).on(SLASH, S_URL);
    S_TLD_COLON.on(NUM, S_TLD_PORT);
    S_TLD_PORT.on(SLASH, S_URL);
    S_EMAIL.on(COLON, S_EMAIL_COLON);
    S_EMAIL_COLON.on(NUM, S_EMAIL_PORT);

    // Types of characters the URL can definitely end in
    const qsAccepting = [DOMAIN, AT, LOCALHOST, NUM, PLUS, POUND, PROTOCOL, SLASH, TLD, UNDERSCORE, SYM, AMPERSAND];

    // Types of tokens that can follow a URL and be part of the query string
    // but cannot be the very last characters
    // Characters that cannot appear in the URL at all should be excluded
    const qsNonAccepting = [
      COLON,
      DOT,
      QUERY,
      PUNCTUATION,
      CLOSEBRACE,
      CLOSEBRACKET,
      CLOSEANGLEBRACKET,
      CLOSEPAREN,
      OPENBRACE,
      OPENBRACKET,
      OPENANGLEBRACKET,
      OPENPAREN,
    ];

    // These states are responsible primarily for determining whether or not to
    // include the final round bracket.

    // URL, followed by an opening bracket
    S_URL.on(OPENBRACE, S_URL_OPENBRACE)
      .on(OPENBRACKET, S_URL_OPENBRACKET)
      .on(OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET)
      .on(OPENPAREN, S_URL_OPENPAREN);

    // URL with extra symbols at the end, followed by an opening bracket
    S_URL_NON_ACCEPTING.on(OPENBRACE, S_URL_OPENBRACE)
      .on(OPENBRACKET, S_URL_OPENBRACKET)
      .on(OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET)
      .on(OPENPAREN, S_URL_OPENPAREN);

    // Closing bracket component. This character WILL be included in the URL
    S_URL_OPENBRACE.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN.on(CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_Q.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_Q.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_Q.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_Q.on(CLOSEPAREN, S_URL);
    S_URL_OPENBRACE_SYMS.on(CLOSEBRACE, S_URL);
    S_URL_OPENBRACKET_SYMS.on(CLOSEBRACKET, S_URL);
    S_URL_OPENANGLEBRACKET_SYMS.on(CLOSEANGLEBRACKET, S_URL);
    S_URL_OPENPAREN_SYMS.on(CLOSEPAREN, S_URL);

    // URL that beings with an opening bracket, followed by a symbols.
    // Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
    // has a single opening bracket for some reason).
    S_URL_OPENBRACE.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

    // URL that begins with an opening bracket, followed by some symbols
    S_URL_OPENBRACE_Q.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_Q.on(qsNonAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_Q.on(qsNonAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_Q.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_Q.on(qsNonAccepting, S_URL_OPENPAREN_Q);

    S_URL_OPENBRACE_SYMS.on(qsAccepting, S_URL_OPENBRACE_Q);
    S_URL_OPENBRACKET_SYMS.on(qsAccepting, S_URL_OPENBRACKET_Q);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
    S_URL_OPENPAREN_SYMS.on(qsAccepting, S_URL_OPENPAREN_Q);
    S_URL_OPENBRACE_SYMS.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
    S_URL_OPENBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
    S_URL_OPENANGLEBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
    S_URL_OPENPAREN_SYMS.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);

    // Account for the query string
    S_URL.on(qsAccepting, S_URL);
    S_URL_NON_ACCEPTING.on(qsAccepting, S_URL);

    S_URL.on(qsNonAccepting, S_URL_NON_ACCEPTING);
    S_URL_NON_ACCEPTING.on(qsNonAccepting, S_URL_NON_ACCEPTING);

    // Email address-specific state definitions
    // Note: We are not allowing '/' in email addresses since this would interfere
    // with real URLs

    // For addresses with the mailto prefix
    // 'mailto:' followed by anything sane is a valid email
    S_MAILTO$1.on(TLD, S_MAILTO_EMAIL)
      .on(DOMAIN, S_MAILTO_EMAIL)
      .on(NUM, S_MAILTO_EMAIL)
      .on(LOCALHOST, S_MAILTO_EMAIL);

    // Greedily get more potential valid email values
    S_MAILTO_EMAIL.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
    S_MAILTO_EMAIL_NON_ACCEPTING.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);

    // For addresses without the mailto prefix
    // Tokens allowed in the localpart of the email
    const localpartAccepting = [DOMAIN, NUM, PLUS, POUND, QUERY, UNDERSCORE, SYM, AMPERSAND, TLD];

    // Some of the tokens in `localpartAccepting` are already accounted for here and
    // will not be overwritten (don't worry)
    S_DOMAIN$1.on(localpartAccepting, S_LOCALPART).on(AT, S_LOCALPART_AT);
    S_TLD.on(localpartAccepting, S_LOCALPART).on(AT, S_LOCALPART_AT);
    S_DOMAIN_DOT.on(localpartAccepting, S_LOCALPART);

    // Okay we're on a localpart. Now what?
    // TODO: IP addresses and what if the email starts with numbers?
    S_LOCALPART.on(localpartAccepting, S_LOCALPART)
      .on(AT, S_LOCALPART_AT) // close to an email address now
      .on(DOT, S_LOCALPART_DOT);
    S_LOCALPART_DOT.on(localpartAccepting, S_LOCALPART);
    S_LOCALPART_AT.on(TLD, S_EMAIL_DOMAIN)
      .on(DOMAIN, S_EMAIL_DOMAIN)
      .on(LOCALHOST, S_EMAIL);
    // States following `@` defined above

    const run$1 = function run$1(tokens) {
      const len = tokens.length;
      let cursor = 0;
      const multis = [];
      let textTokens = [];

      while (cursor < len) {
        let state = S_START$1;
        let secondState = null;
        let nextState = null;
        let multiLength = 0;
        let latestAccepting = null;
        let sinceAccepts = -1;

        while (cursor < len && !(secondState = state.next(tokens[cursor]))) {
          // Starting tokens with nowhere to jump to.
          // Consider these to be just plain text
          textTokens.push(tokens[cursor++]);
        }

        while (cursor < len && (nextState = secondState || state.next(tokens[cursor]))) {
          // Get the next state
          secondState = null;
          state = nextState;

          // Keep track of the latest accepting state
          if (state.accepts()) {
            sinceAccepts = 0;
            latestAccepting = state;
          } else if (sinceAccepts >= 0) {
            sinceAccepts++;
          }

          cursor++;
          multiLength++;
        }

        if (sinceAccepts < 0) {
          // No accepting state was found, part of a regular text token
          // Add all the tokens we looked at to the text tokens array
          for (let _i3 = cursor - multiLength; _i3 < cursor; _i3++) {
            textTokens.push(tokens[_i3]);
          }
        } else {
          // Accepting state!

          // First close off the textTokens (if available)
          if (textTokens.length > 0) {
            multis.push(new TEXT(textTokens));
            textTokens = [];
          }

          // Roll back to the latest accepting state
          cursor -= sinceAccepts;
          multiLength -= sinceAccepts;

          // Create a new multitoken
          const MULTI = latestAccepting.emit();
          multis.push(new MULTI(tokens.slice(cursor - multiLength, cursor)));
        }
      }

      // Finally close off the textTokens (if available)
      if (textTokens.length > 0) {
        multis.push(new TEXT(textTokens));
      }

      return multis;
    };

    const parser = Object.freeze({
      State: TokenState,
      TOKENS: multi,
      run: run$1,
      start: S_START$1,
    });

    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      };
    }

    /**
 	Converts a string into tokens that represent linkable and non-linkable bits
 	@method tokenize
 	@param {string} str
 	@returns {Array} tokens
 */
    const tokenize = function tokenize(str) {
      return run$1(run(str));
    };

    /**
 	Returns a list of linkable items in the given string.
 */
    const find = function find(str) {
      const type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      const tokens = tokenize(str);
      const filtered = [];

      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (token.isLink && (!type || token.type === type)) {
          filtered.push(token.toObject());
        }
      }

      return filtered;
    };

    /**
 	Is the given string valid linkable text of some sort
 	Note that this does not trim the text for you.

 	Optionally pass in a second `type` param, which is the type of link to test
 	for.

 	For example,

 		test(str, 'email');

 	Will return `true` if str is a valid email.
 */
    const test = function test(str) {
      const type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      const tokens = tokenize(str);
      return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].type === type);
    };

    exports.find = find;
    exports.inherits = inherits;
    exports.options = options;
    exports.parser = parser;
    exports.scanner = scanner;
    exports.test = test;
    exports.tokenize = tokenize;
  })((self.linkify = self.linkify || {}));
})();

/* eslint-disable */
'use strict';

(function(window, linkify) {
  const linkifyHtml = (function(linkify) {
    'use strict';

    const HTML5NamedCharRefs = {
      // We don't need the complete named character reference because linkifyHtml
      // does not modify the escape sequences. We do need &nbsp; so that
      // whitespace is parsed properly. Other types of whitespace should already
      // be accounted for
      nbsp: '\xA0',
    };

    function EntityParser(named) {
      this.named = named;
    }

    const HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    const CHARCODE = /^#([0-9]+)$/;
    const NAMED = /^([A-Za-z0-9]+)$/;

    EntityParser.prototype.parse = function(entity) {
      if (!entity) {
        return;
      }
      let matches = entity.match(HEXCHARCODE);
      if (matches) {
        return `&#x${matches[1]};`;
      }
      matches = entity.match(CHARCODE);
      if (matches) {
        return `&#${matches[1]};`;
      }
      matches = entity.match(NAMED);
      if (matches) {
        return this.named[matches[1]] || `&${matches[1]};`;
      }
    };

    const WSP = /[\t\n\f ]/;
    const ALPHA = /[A-Za-z]/;
    const CRLF = /\r\n?/g;

    function isSpace(char) {
      return WSP.test(char);
    }

    function isAlpha(char) {
      return ALPHA.test(char);
    }

    function preprocessInput(input) {
      return input.replace(CRLF, '\n');
    }

    function EventedTokenizer(delegate, entityParser) {
      this.delegate = delegate;
      this.entityParser = entityParser;

      this.state = null;
      this.input = null;

      this.index = -1;
      this.line = -1;
      this.column = -1;
      this.tagLine = -1;
      this.tagColumn = -1;

      this.reset();
    }

    EventedTokenizer.prototype = {
      reset: function reset() {
        this.state = 'beforeData';
        this.input = '';

        this.index = 0;
        this.line = 1;
        this.column = 0;

        this.tagLine = -1;
        this.tagColumn = -1;

        this.delegate.reset();
      },

      tokenize: function tokenize(input) {
        this.reset();
        this.tokenizePart(input);
        this.tokenizeEOF();
      },

      tokenizePart: function tokenizePart(input) {
        this.input += preprocessInput(input);

        while (this.index < this.input.length) {
          this.states[this.state].call(this);
        }
      },

      tokenizeEOF: function tokenizeEOF() {
        this.flushData();
      },

      flushData: function flushData() {
        if (this.state === 'data') {
          this.delegate.finishData();
          this.state = 'beforeData';
        }
      },

      peek: function peek() {
        return this.input.charAt(this.index);
      },

      consume: function consume() {
        const char = this.peek();

        this.index++;

        if (char === '\n') {
          this.line++;
          this.column = 0;
        } else {
          this.column++;
        }

        return char;
      },

      consumeCharRef: function consumeCharRef() {
        const endIndex = this.input.indexOf(';', this.index);
        if (endIndex === -1) {
          return;
        }
        const entity = this.input.slice(this.index, endIndex);
        const chars = this.entityParser.parse(entity);
        if (chars) {
          let count = entity.length;
          // consume the entity chars
          while (count) {
            this.consume();
            count--;
          }
          // consume the `;`
          this.consume();

          return chars;
        }
      },

      markTagStart: function markTagStart() {
        // these properties to be removed in next major bump
        this.tagLine = this.line;
        this.tagColumn = this.column;

        if (this.delegate.tagOpen) {
          this.delegate.tagOpen();
        }
      },

      states: {
        beforeData: function beforeData() {
          const char = this.peek();

          if (char === '<') {
            this.state = 'tagOpen';
            this.markTagStart();
            this.consume();
          } else {
            this.state = 'data';
            this.delegate.beginData();
          }
        },

        data: function data() {
          const char = this.peek();

          if (char === '<') {
            this.delegate.finishData();
            this.state = 'tagOpen';
            this.markTagStart();
            this.consume();
          } else if (char === '&') {
            this.consume();
            this.delegate.appendToData(this.consumeCharRef() || '&');
          } else {
            this.consume();
            this.delegate.appendToData(char);
          }
        },

        tagOpen: function tagOpen() {
          const char = this.consume();

          if (char === '!') {
            this.state = 'markupDeclaration';
          } else if (char === '/') {
            this.state = 'endTagOpen';
          } else if (isAlpha(char)) {
            this.state = 'tagName';
            this.delegate.beginStartTag();
            this.delegate.appendToTagName(char.toLowerCase());
          }
        },

        markupDeclaration: function markupDeclaration() {
          const char = this.consume();

          if (char === '-' && this.input.charAt(this.index) === '-') {
            this.consume();
            this.state = 'commentStart';
            this.delegate.beginComment();
          }
        },

        commentStart: function commentStart() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentStartDash';
          } else if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData(char);
            this.state = 'comment';
          }
        },

        commentStartDash: function commentStartDash() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEnd';
          } else if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData('-');
            this.state = 'comment';
          }
        },

        comment: function comment() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEndDash';
          } else {
            this.delegate.appendToCommentData(char);
          }
        },

        commentEndDash: function commentEndDash() {
          const char = this.consume();

          if (char === '-') {
            this.state = 'commentEnd';
          } else {
            this.delegate.appendToCommentData(`-${char}`);
            this.state = 'comment';
          }
        },

        commentEnd: function commentEnd() {
          const char = this.consume();

          if (char === '>') {
            this.delegate.finishComment();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToCommentData(`--${char}`);
            this.state = 'comment';
          }
        },

        tagName: function tagName() {
          const char = this.consume();

          if (isSpace(char)) {
            this.state = 'beforeAttributeName';
          } else if (char === '/') {
            this.state = 'selfClosingStartTag';
          } else if (char === '>') {
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.delegate.appendToTagName(char);
          }
        },

        beforeAttributeName: function beforeAttributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '/') {
            this.state = 'selfClosingStartTag';
            this.consume();
          } else if (char === '>') {
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'attributeName';
            this.delegate.beginAttribute();
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },

        attributeName: function attributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.state = 'afterAttributeName';
            this.consume();
          } else if (char === '/') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '=') {
            this.state = 'beforeAttributeValue';
            this.consume();
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.consume();
            this.delegate.appendToAttributeName(char);
          }
        },

        afterAttributeName: function afterAttributeName() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '/') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '=') {
            this.consume();
            this.state = 'beforeAttributeValue';
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'attributeName';
            this.delegate.beginAttribute();
            this.delegate.appendToAttributeName(char);
          }
        },

        beforeAttributeValue: function beforeAttributeValue() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
          } else if (char === '"') {
            this.state = 'attributeValueDoubleQuoted';
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === "'") {
            this.state = 'attributeValueSingleQuoted';
            this.delegate.beginAttributeValue(true);
            this.consume();
          } else if (char === '>') {
            this.delegate.beginAttributeValue(false);
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'attributeValueUnquoted';
            this.delegate.beginAttributeValue(false);
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
          const char = this.consume();

          if (char === '"') {
            this.delegate.finishAttributeValue();
            this.state = 'afterAttributeValueQuoted';
          } else if (char === '&') {
            this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueSingleQuoted: function attributeValueSingleQuoted() {
          const char = this.consume();

          if (char === "'") {
            this.delegate.finishAttributeValue();
            this.state = 'afterAttributeValueQuoted';
          } else if (char === '&') {
            this.delegate.appendToAttributeValue(this.consumeCharRef("'") || '&');
          } else {
            this.delegate.appendToAttributeValue(char);
          }
        },

        attributeValueUnquoted: function attributeValueUnquoted() {
          const char = this.peek();

          if (isSpace(char)) {
            this.delegate.finishAttributeValue();
            this.consume();
            this.state = 'beforeAttributeName';
          } else if (char === '&') {
            this.consume();
            this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
          } else if (char === '>') {
            this.delegate.finishAttributeValue();
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.consume();
            this.delegate.appendToAttributeValue(char);
          }
        },

        afterAttributeValueQuoted: function afterAttributeValueQuoted() {
          const char = this.peek();

          if (isSpace(char)) {
            this.consume();
            this.state = 'beforeAttributeName';
          } else if (char === '/') {
            this.consume();
            this.state = 'selfClosingStartTag';
          } else if (char === '>') {
            this.consume();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'beforeAttributeName';
          }
        },

        selfClosingStartTag: function selfClosingStartTag() {
          const char = this.peek();

          if (char === '>') {
            this.consume();
            this.delegate.markTagAsSelfClosing();
            this.delegate.finishTag();
            this.state = 'beforeData';
          } else {
            this.state = 'beforeAttributeName';
          }
        },

        endTagOpen: function endTagOpen() {
          const char = this.consume();

          if (isAlpha(char)) {
            this.state = 'tagName';
            this.delegate.beginEndTag();
            this.delegate.appendToTagName(char.toLowerCase());
          }
        },
      },
    };

    function Tokenizer(entityParser, options) {
      this.token = null;
      this.startLine = 1;
      this.startColumn = 0;
      this.options = options || {};
      this.tokenizer = new EventedTokenizer(this, entityParser);
    }

    Tokenizer.prototype = {
      tokenize: function tokenize(input) {
        this.tokens = [];
        this.tokenizer.tokenize(input);
        return this.tokens;
      },

      tokenizePart: function tokenizePart(input) {
        this.tokens = [];
        this.tokenizer.tokenizePart(input);
        return this.tokens;
      },

      tokenizeEOF: function tokenizeEOF() {
        this.tokens = [];
        this.tokenizer.tokenizeEOF();
        return this.tokens[0];
      },

      reset: function reset() {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
      },

      addLocInfo: function addLocInfo() {
        if (this.options.loc) {
          this.token.loc = {
            start: {
              line: this.startLine,
              column: this.startColumn,
            },
            end: {
              line: this.tokenizer.line,
              column: this.tokenizer.column,
            },
          };
        }
        this.startLine = this.tokenizer.line;
        this.startColumn = this.tokenizer.column;
      },

      // Data

      beginData: function beginData() {
        this.token = {
          type: 'Chars',
          chars: '',
        };
        this.tokens.push(this.token);
      },

      appendToData: function appendToData(char) {
        this.token.chars += char;
      },

      finishData: function finishData() {
        this.addLocInfo();
      },

      // Comment

      beginComment: function beginComment() {
        this.token = {
          type: 'Comment',
          chars: '',
        };
        this.tokens.push(this.token);
      },

      appendToCommentData: function appendToCommentData(char) {
        this.token.chars += char;
      },

      finishComment: function finishComment() {
        this.addLocInfo();
      },

      // Tags - basic

      beginStartTag: function beginStartTag() {
        this.token = {
          type: 'StartTag',
          tagName: '',
          attributes: [],
          selfClosing: false,
        };
        this.tokens.push(this.token);
      },

      beginEndTag: function beginEndTag() {
        this.token = {
          type: 'EndTag',
          tagName: '',
        };
        this.tokens.push(this.token);
      },

      finishTag: function finishTag() {
        this.addLocInfo();
      },

      markTagAsSelfClosing: function markTagAsSelfClosing() {
        this.token.selfClosing = true;
      },

      // Tags - name

      appendToTagName: function appendToTagName(char) {
        this.token.tagName += char;
      },

      // Tags - attributes

      beginAttribute: function beginAttribute() {
        this._currentAttribute = ['', '', null];
        this.token.attributes.push(this._currentAttribute);
      },

      appendToAttributeName: function appendToAttributeName(char) {
        this._currentAttribute[0] += char;
      },

      beginAttributeValue: function beginAttributeValue(isQuoted) {
        this._currentAttribute[2] = isQuoted;
      },

      appendToAttributeValue: function appendToAttributeValue(char) {
        this._currentAttribute[1] = this._currentAttribute[1] || '';
        this._currentAttribute[1] += char;
      },

      finishAttributeValue: function finishAttributeValue() {},
    };

    function tokenize$1(input, options) {
      const tokenizer = new Tokenizer(new EntityParser(HTML5NamedCharRefs), options);
      return tokenizer.tokenize(input);
    }

    const HTML5Tokenizer = {
      HTML5NamedCharRefs: HTML5NamedCharRefs,
      EntityParser: EntityParser,
      EventedTokenizer: EventedTokenizer,
      Tokenizer: Tokenizer,
      tokenize: tokenize$1,
    };

    const options = linkify.options;
    const Options = options.Options;

    const StartTag = 'StartTag';
    const EndTag = 'EndTag';
    const Chars = 'Chars';
    const Comment = 'Comment';

    /**
    	`tokens` and `token` in this section refer to tokens generated by the HTML
    	parser.
    */
    function linkifyHtml(str) {
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      const tokens = HTML5Tokenizer.tokenize(str);
      const linkifiedTokens = [];
      const linkified = [];
      let i;

      opts = new Options(opts);

      // Linkify the tokens given by the parser
      for (i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === StartTag) {
          linkifiedTokens.push(token);

          // Ignore all the contents of ignored tags
          const tagName = token.tagName.toUpperCase();
          const isIgnored = tagName === 'A' || options.contains(opts.ignoreTags, tagName);
          if (!isIgnored) {
            continue;
          }

          const preskipLen = linkifiedTokens.length;
          skipTagTokens(tagName, tokens, ++i, linkifiedTokens);
          i += linkifiedTokens.length - preskipLen - 1;
          continue;
        } else if (token.type !== Chars) {
          // Skip this token, it's not important
          linkifiedTokens.push(token);
          continue;
        }

        // Valid text token, linkify it!
        const linkifedChars = linkifyChars(token.chars, opts);
        linkifiedTokens.push(...linkifedChars);
      }

      // Convert the tokens back into a string
      for (i = 0; i < linkifiedTokens.length; i++) {
        const _token = linkifiedTokens[i];
        switch (_token.type) {
          case StartTag: {
            let link = `<${_token.tagName}`;
            if (_token.attributes.length > 0) {
              const attrs = attrsToStrings(_token.attributes);
              link += ` ${attrs.join(' ')}`;
            }
            link += '>';
            linkified.push(link);
            break;
          }
          case EndTag:
            linkified.push(`</${_token.tagName}>`);
            break;
          case Chars:
            linkified.push(escapeText(_token.chars));
            break;
          case Comment:
            linkified.push(`<!--${escapeText(_token.chars)}-->`);
            break;
        }
      }

      return linkified.join('');
    }

    /**
    	`tokens` and `token` in this section referes to tokens returned by
    	`linkify.tokenize`. `linkified` will contain HTML Parser-style tokens
    */
    function linkifyChars(str, opts) {
      const tokens = linkify.tokenize(str);
      const result = [];

      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === 'nl' && opts.nl2br) {
          result.push({
            type: StartTag,
            tagName: 'br',
            attributes: [],
            selfClosing: true,
          });
          continue;
        } else if (!token.isLink || !opts.check(token)) {
          result.push({type: Chars, chars: token.toString()});
          continue;
        }

        const _opts$resolve = opts.resolve(token);

        const formatted = _opts$resolve.formatted;

        const formattedHref = _opts$resolve.formattedHref;

        const tagName = _opts$resolve.tagName;

        const className = _opts$resolve.className;

        const target = _opts$resolve.target;

        const attributes = _opts$resolve.attributes;

        // Build up attributes

        const attributeArray = [['href', formattedHref]];

        if (className) {
          attributeArray.push(['class', className]);
        }

        if (target) {
          attributeArray.push(['target', target]);
        }

        for (const attr in attributes) {
          attributeArray.push([attr, attributes[attr]]);
        }

        // Add the required tokens
        result.push({
          type: StartTag,
          tagName: tagName,
          attributes: attributeArray,
          selfClosing: false,
        });
        result.push({type: Chars, chars: formatted});
        result.push({type: EndTag, tagName: tagName});
      }

      return result;
    }

    /**
    	Returns a list of tokens skipped until the closing tag of tagName.

    	* `tagName` is the closing tag which will prompt us to stop skipping
    	* `tokens` is the array of tokens generated by HTML5Tokenizer which
    	* `i` is the index immediately after the opening tag to skip
    	* `skippedTokens` is an array which skipped tokens are being pushed into

    	Caveats

    	* Assumes that i is the first token after the given opening tagName
    	* The closing tag will be skipped, but nothing after it
    	* Will track whether there is a nested tag of the same type
    */
    function skipTagTokens(tagName, tokens, i, skippedTokens) {
      // number of tokens of this type on the [fictional] stack
      let stackCount = 1;

      while (i < tokens.length && stackCount > 0) {
        const token = tokens[i];

        if (token.type === StartTag && token.tagName.toUpperCase() === tagName) {
          // Nested tag of the same type, "add to stack"
          stackCount++;
        } else if (token.type === EndTag && token.tagName.toUpperCase() === tagName) {
          // Closing tag
          stackCount--;
        }

        skippedTokens.push(token);
        i++;
      }

      // Note that if stackCount > 0 here, the HTML is probably invalid
      return skippedTokens;
    }

    function escapeText(text) {
      // Not required, HTML tokenizer ensures this occurs properly
      return text;
    }

    function escapeAttr(attr) {
      return attr.replace(/"/g, '&quot;');
    }

    function attrsToStrings(attrs) {
      const attrStrs = [];
      for (let i = 0; i < attrs.length; i++) {
        const _attrs$i = attrs[i];

        const name = _attrs$i[0];

        const value = _attrs$i[1];

        attrStrs.push(`${name}="${escapeAttr(value)}"`);
      }
      return attrStrs;
    }

    return linkifyHtml;
  })(linkify);

  window.linkifyHtml = linkifyHtml;
})(window, linkify);

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */
/*global define*/

(function() {
  /**
   * Block-Level Grammar
   */

  const block = {
    blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
    code: noop,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
    fences: noop,
    hr: /^( *[-*_]){3,} *(?:\n+|$)/,
    html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    newline: /^\n+/,
    paragraph: /^((?:[^\n]+\n?(?!hr|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/,
  };

  block.bullet = /(?:[*+-]|\d+\.)/;
  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
  block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();

  block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')(
    'def',
    '\\n+(?=' + block.def.source + ')' //eslint-disable-line
  )();

  block.blockquote = replace(block.blockquote)('def', block.def)();

  block._tag =
    '(?!(?:' +
    'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' +
    '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' +
    '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

  block.html = replace(block.html)('comment', /<!--[\s\S]*?-->/)('closed', /<(tag)[\s\S]+?<\/\1>/)(
    'closing',
    /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/
  )(/tag/g, block._tag)();

  block.paragraph = replace(block.paragraph)('blockquote', block.blockquote)('tag', `<${block._tag}`)(
    'def',
    block.def
  )();

  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);

  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
    paragraph: /^/,
  });

  block.gfm.paragraph = replace(block.paragraph)(
    '(?!',
    `(?!${block.gfm.fences.source.replace('\\1', '\\2')}|${block.list.source.replace('\\1', '\\3')}|`
  )();

  /**
   * Block Lexer
   */

  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = {};
    this.options = options || marked.defaults;
    this.rules = block.normal;

    if (this.options.gfm) {
      this.rules = block.gfm;
    }
  }

  /**
   * Expose Block Rules
   */

  Lexer.rules = block;

  /**
   * Static Lex Method
   */

  Lexer.lex = function(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  };

  /**
   * Preprocessing
   */

  Lexer.prototype.lex = function(src) {
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ')
      .replace(/\u00a0/g, ' ')
      .replace(/\u2424/g, '\n');

    return this.token(src, true);
  };

  /**
   * Lexing
   */

  Lexer.prototype.token = function(src, top, bq) {
    src = src.replace(/^ +$/gm, '');
    let cap;

    while (src) {
      // newline
      if ((cap = this.rules.newline.exec(src))) {
        src = src.substring(cap[0].length);
        if (cap[0].length > 1) {
          this.tokens.push({
            type: 'space',
          });
        }
      }

      // code
      if ((cap = this.rules.code.exec(src))) {
        src = src.substring(cap[0].length);
        cap = cap[0].replace(/^ {4}/gm, '');
        this.tokens.push({
          text: !this.options.pedantic ? cap.replace(/\n+$/, '') : cap,
          type: 'code',
        });
        continue;
      }

      // fences (gfm)
      if ((cap = this.rules.fences.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          lang: cap[2],
          text: cap[3] || '',
          type: 'code',
        });
        continue;
      }

      // html
      if ((cap = this.rules.html.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0],
          type: this.options.sanitize ? 'paragraph' : 'html',
        });
        continue;
      }

      // def
      if (!bq && top && (cap = this.rules.def.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.links[cap[1].toLowerCase()] = {
          href: cap[2],
          title: cap[3],
        };
        continue;
      }

      // top-level paragraph
      if (top && (cap = this.rules.paragraph.exec(src))) {
        src = src.substring(cap[0].length);
        this.tokens.push({
          text: cap[0],
          type: 'paragraph',
        });
        continue;
      }

      // text
      if ((cap = this.rules.text.exec(src))) {
        // Top-level should never reach here.
        src = src.substring(cap[0].length);
        this.tokens.push({
          text: cap[0],
          type: 'text',
        });
        continue;
      }

      if (src) {
        throw new Error(`Infinite loop on byte: ${src.charCodeAt(0)}`);
      }
    }

    return this.tokens;
  };

  /**
   * Inline-Level Grammar
   */

  const inline = {
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    br: /^ {2,}\n(?!\s*$)/,
    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
    del: noop,
    em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
    link: /^!?\[(inside)\]\(href\)/,
    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
    text: /^[_*` ]|^[\s\S]+?\s(?=[_*`])|^[\s\S]+?(?=[\\<!\[]| {2,}\n|$)/,
    url: noop,
  };

  inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
  inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

  inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();

  inline.reflink = replace(inline.reflink)('inside', inline._inside)();

  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);

  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
    strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  });

  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    del: /^~~(?=\S)([\s\S]*?\S)~~/,
    escape: replace(inline.escape)('])', '~|])')(),
    text: replace(inline.text)(']|', '~]|')('|', '|https?://|')(),
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  });

  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: replace(inline.br)('{2,}', '*')(),
    text: replace(inline.gfm.text)('{2,}', '*')(),
  });

  /**
   * Inline Lexer & Compiler
   */

  function InlineLexer(links, options) {
    this.options = options || marked.defaults;
    this.links = links;
    this.rules = inline.normal;
    this.renderer = this.options.renderer || new Renderer();
    this.renderer.options = this.options;

    if (!this.links) {
      throw new Error('Tokens array requires a `links` property.');
    }

    if (this.options.gfm) {
      this.rules = this.options.breaks ? inline.breaks : inline.gfm;
    } else if (this.options.pedantic) {
      this.rules = inline.pedantic;
    }
  }

  /**
   * Expose Inline Rules
   */

  InlineLexer.rules = inline;

  /**
   * Static Lexing/Compiling Method
   */

  InlineLexer.output = function(src, links, options) {
    const newInline = new InlineLexer(links, options);
    return newInline.output(src);
  };

  /**
   * Lexing/Compiling
   */

  InlineLexer.prototype.output = function(src) {
    let out = '';
    let cap;

    while (src) {
      // escape
      if ((cap = this.rules.escape.exec(src))) {
        src = src.substring(cap[0].length);
        out += cap[1];
        continue;
      }

      // tag
      if ((cap = this.rules.tag.exec(src))) {
        if (!this.inLink && /^<a /i.test(cap[0])) {
          this.inLink = true;
        } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
          this.inLink = false;
        }
        src = src.substring(cap[0].length);
        out += this.options.sanitize
          ? this.options.sanitizer
            ? this.options.sanitizer(cap[0])
            : escape(cap[0])
          : cap[0];
        continue;
      }

      // strong
      if ((cap = this.rules.strong.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.strong(this.output(cap[2] || cap[1]));
        continue;
      }

      // em
      if ((cap = this.rules.em.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.em(this.output(cap[2] || cap[1]));
        continue;
      }

      // code
      if ((cap = this.rules.code.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.codespan(escape(cap[2], true));
        continue;
      }

      // br
      if ((cap = this.rules.br.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.br();
        continue;
      }

      if ((cap = linkify.find(src)[0])) {
        const pos = Math.max(0, src.indexOf(cap.value));
        const preString = this.output(src.substring(0, pos));
        if (!/[_*`]$/.test(preString)) {
          src = src.substring(pos + cap.value.length);
          const cleanHref = escape(cap.href);
          const cleanValue = escape(cap.value);
          out +=
            cap.type === 'email'
              ? `${preString}<a href="${cleanHref}" onclick="z.util.SanitizationUtil.safeMailtoOpen(event, '${cleanHref.replace(
                  /^mailto:/,
                  ''
                )}')">${cleanValue}</a>`
              : `${preString}<a href="${cleanHref}" target="_blank" rel="nofollow noopener noreferrer">${cleanValue}</a>`;
          continue;
        }
      }

      // text
      if ((cap = this.rules.text.exec(src))) {
        src = src.substring(cap[0].length);
        out += this.renderer.text(escape(this.smartypants(cap[0])));
        continue;
      }

      if (src) {
        throw new Error(`Infinite loop on byte: ${src.charCodeAt(0)}`);
      }
    }

    return out;
  };

  /**
   * Compile Link
   */

  InlineLexer.prototype.outputLink = function(cap, link) {
    const href = escape(link.href);
    const title = link.title ? escape(link.title) : null;

    return cap[0].charAt(0) !== '!'
      ? this.renderer.link(href, title, cap[1])
      : this.renderer.image(href, title, escape(cap[1]));
  };

  /**
   * Smartypants Transformations
   */

  InlineLexer.prototype.smartypants = function(text) {
    if (!this.options.smartypants) {
      return text;
    }
    return (
      text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026')
    );
  };

  /**
   * Mangle Links
   */

  InlineLexer.prototype.mangle = function(text) {
    if (!this.options.mangle) {
      return text;
    }
    let out = '';
    const l = text.length;
    let i = 0;
    let ch;

    for (; i < l; i++) {
      ch = text.charCodeAt(i);
      if (Math.random() > 0.5) {
        ch = `x${ch.toString(16)}`;
      }
      out += `&#${ch};`;
    }

    return out;
  };

  /**
   * Renderer
   */

  function Renderer(options) {
    this.options = options || {};
  }

  Renderer.prototype.code = function(code, lang, escaped) {
    code = _.unescape(code);
    code = code.replace(/&#x27;/g, "'");

    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    if (!lang) {
      return `<pre><code>${escaped ? code : escape(code, true)}\n</code></pre>`;
    }

    return `<pre><code class="${this.options.langPrefix}${escape(lang, true)}">${
      escaped ? code : escape(code, true)
    }\n</code></pre>\n`;
  };

  Renderer.prototype.blockquote = function(quote) {
    return `<blockquote>\n${quote}</blockquote>\n`;
  };

  Renderer.prototype.html = function(html) {
    return html;
  };

  Renderer.prototype.hr = function() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };

  Renderer.prototype.list = function(body, ordered) {
    const type = ordered ? 'ol' : 'ul';
    return `<${type}>\n${body}</${type}>\n`;
  };

  Renderer.prototype.listitem = function(text) {
    return `<li>${text}</li>\n`;
  };

  Renderer.prototype.paragraph = function(text) {
    return `${text.replace(/\n$/, '')}\n`;
  };

  // span level renderer
  Renderer.prototype.strong = function(text) {
    return `<strong>${text}</strong>`;
  };

  Renderer.prototype.em = function(text) {
    return `<em>${text}</em>`;
  };

  Renderer.prototype.codespan = function(text) {
    return `<code>${text}</code>`;
  };

  Renderer.prototype.br = function() {
    return this.options.xhtml ? '<br/>' : '<br>';
  };

  Renderer.prototype.del = function(text) {
    return `<del>${text}</del>`;
  };

  Renderer.prototype.link = function(href, title, text) {
    if (this.options.sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape(href))
          .replace(/[^\w:]/g, '')
          .toLowerCase();
      } catch (e) {
        return '';
      }
      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return '';
      }
    }
    let out = `<a href="${href}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ` target="_blank" rel="nofollow noopener noreferrer">${text}</a>`;
    return out;
  };

  Renderer.prototype.image = function(href, title, text) {
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  };

  Renderer.prototype.text = function(text) {
    return text;
  };

  /**
   * Parsing & Compiling
   */

  function Parser(options) {
    this.tokens = [];
    this.token = null;
    this.options = options || marked.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
  }

  /**
   * Static Parse Method
   */

  Parser.parse = function(src, options, renderer) {
    const parser = new Parser(options, renderer);
    return parser.parse(src);
  };

  /**
   * Parse Loop
   */

  Parser.prototype.parse = function(src) {
    this.inline = new InlineLexer(src.links, this.options, this.renderer);
    this.tokens = src.reverse();

    let out = '';
    while (this.next()) {
      out += this.tok();
    }

    return out;
  };

  /**
   * Next Token
   */

  Parser.prototype.next = function() {
    return (this.token = this.tokens.pop());
  };

  /**
   * Preview Next Token
   */

  Parser.prototype.peek = function() {
    return this.tokens[this.tokens.length - 1] || 0;
  };

  /**
   * Parse Text Tokens
   */

  Parser.prototype.parseText = function() {
    let body = this.token.text;

    while (this.peek().type === 'text') {
      body += `\n${this.next().text}`;
    }

    return this.inline.output(body);
  };

  /**
   * Parse Current Token
   */

  Parser.prototype.tok = function() {
    switch (this.token.type) {
      case 'space': {
        return '';
      }
      case 'hr': {
        return this.renderer.hr();
      }
      case 'code': {
        return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
      }
      case 'blockquote_start': {
        let body = '';

        while (this.next().type !== 'blockquote_end') {
          body += this.tok();
        }

        return this.renderer.blockquote(body);
      }
      case 'list_start': {
        let body = '';
        const ordered = this.token.ordered;

        while (this.next().type !== 'list_end') {
          body += this.tok();
        }

        return this.renderer.list(body, ordered);
      }
      case 'list_item_start': {
        let body = '';

        while (this.next().type !== 'list_item_end') {
          body += this.token.type === 'text' ? this.parseText() : this.tok();
        }

        return this.renderer.listitem(body);
      }
      case 'loose_item_start': {
        let body = '';

        while (this.next().type !== 'list_item_end') {
          body += this.tok();
        }

        return this.renderer.listitem(body);
      }
      case 'html': {
        const html = !this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
        return this.renderer.html(html);
      }
      case 'paragraph': {
        return this.renderer.paragraph(this.inline.output(this.token.text));
      }
      case 'text': {
        return this.renderer.paragraph(this.parseText());
      }
    }
  };

  /**
   * Helpers
   */

  function escape(html, encode) {
    return html
      .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, (_, n) => {
      n = n.toLowerCase();
      if (n === 'colon') {
        return ':';
      }
      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x'
          ? String.fromCharCode(parseInt(n.substring(2), 16))
          : String.fromCharCode(+n.substring(1));
      }
      return '';
    });
  }

  function replace(regex, opt) {
    regex = regex.source;
    opt = opt || '';
    return function self(name, val) {
      if (!name) {
        return new RegExp(regex, opt);
      }
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return self;
    };
  }

  function noop() {}
  noop.exec = noop;

  function merge(obj) {
    let i = 1;
    let target;
    let key;

    for (; i < arguments.length; i++) {
      target = arguments[i];
      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  /**
   * Marked
   */

  function marked(src, opt, callback) {
    if (callback || typeof opt === 'function') {
      if (!callback) {
        callback = opt;
        opt = null;
      }

      opt = merge({}, marked.defaults, opt || {});

      const highlight = opt.highlight;
      let tokens;
      let pending;
      let i = 0;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      pending = tokens.length;

      const done = function(err) {
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }

        let out;

        try {
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }

        opt.highlight = highlight;

        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;

      if (!pending) {
        return done();
      }

      for (; i < tokens.length; i++) {
        (function(token) {
          if (token.type !== 'code') {
            return --pending || done();
          }
          return highlight(token.text, token.lang, (err, code) => {
            if (err) {
              return done(err);
            }
            if (code == null || code === token.text) {
              return --pending || done();
            }
            token.text = code;
            token.escaped = true;
            return --pending || done();
          });
        })(tokens[i]);
      }

      return;
    }

    try {
      if (opt) {
        opt = merge({}, marked.defaults, opt);
      }
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/chjj/marked.';
      if ((opt || marked.defaults).silent) {
        return `<p>An error occured:</p><pre>${escape(`${e.message}`, true)}</pre>`;
      }
      throw e;
    }
  }

  /**
   * Options
   */

  marked.options = marked.setOptions = function(opt) {
    merge(marked.defaults, opt);
    return marked;
  };

  marked.defaults = {
    breaks: false,
    gfm: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'lang-',
    mangle: true,
    pedantic: false,
    renderer: new Renderer(),
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    xhtml: false,
  };

  /**
   * Expose
   */

  marked.Parser = Parser;
  marked.parser = Parser.parse;

  marked.Renderer = Renderer;

  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;

  marked.InlineLexer = InlineLexer;
  marked.inlineLexer = InlineLexer.output;

  marked.parse = marked;

  if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = marked;
  } else if (typeof define === 'function' && define.amd) {
    define(() => {
      return marked;
    });
  } else {
    this.marked = marked;
  }
}.call(
  (function() {
    return this || (typeof window !== 'undefined' ? window : global);
  })()
));

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.MessageComparator = {
  /**
   * Checks if two arrays with mentions contain different values.
   *
   * @param {z.entity.Message} originalMessageEntity - Message entity
   * @param {Array<z.message.MentionEntity>} [updatedMentions] - Updated mentions
   * @returns {boolean} Are the mentions different from each other
   */
  areMentionsDifferent: (originalMessageEntity, updatedMentions) => {
    const flattenToUserId = mentions => mentions.map(mention => mention.userId).sort();

    const existingMentions = flattenToUserId(originalMessageEntity.get_first_asset().mentions());
    updatedMentions = flattenToUserId(updatedMentions);

    const hasDifferentAmount = existingMentions.length !== updatedMentions.length;
    const hasDifferentUserIDs = existingMentions.some((userId, index) => userId !== updatedMentions[index]);

    return hasDifferentAmount || hasDifferentUserIDs;
  },
  /**
   * Checks if a given text is different from an already existing text on the message entity.
   *
   * @param {z.entity.Message} originalMessageEntity - Message entity
   * @param {string} textMessage - Message to compare with
   * @returns {boolean} Are text the same
   */
  isTextDifferent: (originalMessageEntity, textMessage) => {
    return textMessage !== originalMessageEntity.get_first_asset().text;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

moment.fn.isToday = function() {
  return this.isSame(new Date(), 'd');
};

moment.fn.isCurrentYear = function() {
  return this.isSame(new Date(), 'y');
};

moment.fn.isSameDay = function(date) {
  return this.isSame(date, 'd');
};

moment.fn.isSameMonth = function(date) {
  return this.isSame(date, 'M');
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.util.NumberUtil = {
  capToByte: value => {
    const MAX_VALUE = 255;
    return Math.min(Math.abs(parseInt(value * MAX_VALUE, 10)), MAX_VALUE);
  },

  clamp: (value, min, max) => {
    return Math.max(min, Math.min(max, value));
  },

  getRandomNumber: (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum),

  inRange: (value, lowerBound, upperBound) => value >= lowerBound && value <= upperBound,

  rootMeanSquare: floatArray => {
    const pow = floatArray.map(number => Math.pow(number, 2));
    const sum = pow.reduce((power, number) => power + number);
    return Math.sqrt(sum) / floatArray.length;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ObjectUtil = {
  /**
   * Escapes all properties of a given object.
   * @param {Object} object - Base object
   * @returns {Object} Object copy with escaped properties
   */
  escapeProperties: object => z.util.ObjectUtil.mapRecursive(object, _.escape),

  /**
   * Creates an object copy and applies a mapping functions to all properties of that object.
   *
   * @param {Object} object - Base object
   * @param {Function} mappingFunction - Mapping function
   * @returns {Object} Object copy with mapped properties
   */
  mapRecursive: (object, mappingFunction) => {
    if (typeof object !== 'object') {
      return mappingFunction(object);
    }

    const newObject = {};

    Object.entries(object).forEach(([propertyName, value]) => {
      newObject[propertyName] = z.util.ObjectUtil.mapRecursive(value, mappingFunction);
    });

    return newObject;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.util.PeerConnectionUtil = {
  getIceCandidatesTypes(iceCandidates) {
    return iceCandidates.reduce((types, candidateStr) => {
      const typeMatches = candidateStr.match(/typ (\w+)/);
      if (!typeMatches) {
        return types;
      }
      const candidateType = typeMatches[1];
      types[candidateType] = types[candidateType] + 1 || 1;
      return types;
    }, {});
  },

  /**
   * Returns true if the number and types of ice candidates gathered are sufficient to start a call
   *
   * @param {RTCConfiguration} peerConnectionConfig - the configuration of the peerConnection that initiated the ICE candidate gathering
   * @param {Array<string>} iceCandidates - ICE candidate strings from SDP
   * @returns {boolean} True if the candidates gathered are enough to send a SDP
   */
  isValidIceCandidatesGathering(peerConnectionConfig, iceCandidates) {
    if (iceCandidates.length <= 0) {
      // if there are no candidates, no need to check for more conditions
      // the call cannot work
      return false;
    }
    const numberOfRelays = iceCandidates.filter(candidate => candidate.toLowerCase().includes('relay')).length;
    const numberOfIceServers = (peerConnectionConfig.iceServers || []).length;
    if (numberOfIceServers <= 0) {
      return true;
    }
    if (numberOfIceServers === 1 && numberOfRelays >= 1) {
      return true;
    }
    if (numberOfIceServers >= 2 && numberOfRelays >= 2) {
      return true;
    }
    return false;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.PromiseQueue = class PromiseQueue {
  static get CONFIG() {
    return {
      UNBLOCK_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  /**
   * Construct a new Promise Queue.
   *
   * @param {Object} [options={}] - Initialization options
   * @param {boolean} [options.concurrent=1] - Concurrent promise execution
   * @param {string} options.name - Name for Promise queue
   * @param {boolean} [options.paused=false] - Initial paused state
   * @param {number} [options.timeout=PromiseQueue.CONFIG.UNBLOCK_INTERVAL] - Timeout in ms
   * @returns {PromiseQueue} Process Promises sequentially
   */
  constructor(options = {}) {
    const {concurrent = 1, name, paused = false, timeout = PromiseQueue.CONFIG.UNBLOCK_INTERVAL} = options;

    const loggerName = `z.util.PromiseQueue${name ? ` (${name})` : ''}`;
    this.logger = new z.util.Logger(loggerName, z.config.LOGGER.OPTIONS);

    this._blocked = false;
    this._concurrent = concurrent;
    this._current = 0;
    this._interval = undefined;
    this._paused = paused;
    this._queue = [];
    this._timeout = timeout;
  }

  /**
   * Executes first function in the queue.
   * @returns {undefined} No return value
   */
  execute() {
    if (this._paused || this._blocked) {
      return;
    }

    const queueEntry = this._queue.shift();
    if (queueEntry) {
      this._clearInterval();

      this._current = this._current + 1;
      if (this._current >= this._concurrent) {
        this._blocked = true;
      }

      this._interval = window.setInterval(() => {
        if (!this._paused) {
          const logObject = {pendingEntry: queueEntry, queueState: this._queue};
          this.logger.error('Promise queue failed, unblocking queue', logObject);
          this.resume();
        }
      }, this._timeout);

      queueEntry
        .fn()
        .catch(error => {
          queueEntry.resolveFn = undefined;
          queueEntry.rejectFn(error);
        })
        .then(response => {
          if (queueEntry.resolveFn) {
            queueEntry.resolveFn(response);
          }

          this._clearInterval();

          this._current = this._current - 1;
          if (this._current < this._concurrent) {
            this._blocked = false;
          }

          window.setTimeout(() => this.execute(), 0);
        });
    }
  }

  /**
   * Get the number of queued functions.
   * @returns {number} Number of queued functions
   */
  getLength() {
    return this._queue.length;
  }

  /**
   * Pause or resume the execution.
   * @param {boolean} [shouldPause=true] - Pause queue
   * @returns {z.util.PromiseQueue} PromiseQueue
   */
  pause(shouldPause = true) {
    this._paused = shouldPause;
    if (!this._paused) {
      this.execute();
    }

    return this;
  }

  /**
   * Queued function is executed when queue is empty or previous functions are executed.
   * @param {Function} fn - Function to be executed in queue order
   * @returns {Promise} Resolves when function was executed
   */
  push(fn) {
    return new Promise((resolve, reject) => {
      const queueEntry = {
        fn: fn,
        rejectFn: reject,
        resolveFn: resolve,
      };

      this._queue.push(queueEntry);
      this.execute();
    });
  }

  /**
   * Resume execution of queue.
   * @returns {undefined} No return value
   */
  resume() {
    this._clearInterval();
    this._blocked = false;
    this.pause(false);
  }

  /**
   * Queued function is executed.
   * @param {Function} fn - Function to be executed in queue order
   * @returns {Promise} Resolves when function was executed
   */
  unshift(fn) {
    return new Promise((resolve, reject) => {
      const queueEntry = {
        fn: fn,
        rejectFn: reject,
        resolveFn: resolve,
      };

      this._queue.unshift(queueEntry);
      this.execute();
    });
  }

  _clearInterval() {
    if (this._interval) {
      window.clearInterval(this._interval);
      this._interval = undefined;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

$.fn.scrollEnd = function() {
  const element = $(this).get(0);
  if (!element) {
    return;
  }
  return element.scrollHeight - element.clientHeight;
};

$.fn.scrollToBottom = function() {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  $element.scrollTop($element[0].scrollHeight);
  return window.setTimeout(() => {
    if (!$(this).isScrolledBottom()) {
      return $element.scrollTop($element[0].scrollHeight);
    }
  }, 200);
};

$.fn.scrollBy = function(distance) {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  const scrollTop = $element[0].scrollTop;
  return $element.scrollTop(scrollTop + distance);
};

$.fn.isScrolledBottom = function(offset) {
  if (offset == null) {
    offset = 0;
  }
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  const scrollTop = Math.ceil($element.scrollTop());
  const scrollHeight = $element[0].scrollHeight;
  const height = $element[0].clientHeight;
  return scrollTop + height + offset >= scrollHeight;
};

$.fn.isScrolledTop = function() {
  const $element = $(this);
  if ($element.length === 0) {
    return;
  }
  return $element.scrollTop() === 0;
};

$.fn.isScrollable = function() {
  const element = $(this).get(0);
  if (!element) {
    return;
  }
  return element.scrollHeight > element.clientHeight;
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.StorageUtil = {
  getValue: function(key) {
    return amplify.store(key);
  },
  resetValue: function(key) {
    return z.util.StorageUtil.setValue(key, null);
  },
  setValue: function(key, value, secondsToExpire) {
    const config = secondsToExpire ? {expires: secondsToExpire * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND} : undefined;
    return amplify.store(key, value, config);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.StringUtil = {
  /**
   * @param {ArrayLike} bytes - bytes to convert
   * @returns {string} bytes as hex string
   */
  bytesToHex: bytes => {
    bytes = Array.from(bytes);

    const hexBase = 16;
    const padIndex = 2;

    return bytes
      .map(byte => {
        const stringByte = byte.toString(hexBase);
        return z.util.StringUtil.padStart(stringByte, padIndex, '0');
      })
      .join('');
  },

  capitalizeFirstChar: (string = '') => `${string.charAt(0).toUpperCase()}${string.substring(1)}`,

  /**
   * Returns true if the string and the query match by applying transliteration first.
   *
   * @param {string} string - the string to compare the query against
   * @param {string} query - the query to compare to the string
   * @param {Object} excludedChars - extra characters to ignore when creating a slug ({[string]: string})
   * @param {boolean} fromStart=false - should the query match the string from the beginning of the string
   * @returns {boolean} does the string matches the query
   */
  compareTransliteration: (string, query, excludedChars = {}, fromStart = false) => {
    const nameSlug = z.util.StringUtil.computeTransliteration(string, excludedChars);
    const querySlug = z.util.StringUtil.computeTransliteration(query, excludedChars);
    return fromStart ? nameSlug.startsWith(querySlug) : z.util.StringUtil.includes(nameSlug, querySlug);
  },

  computeTransliteration: (string, excludedChars = {}) => {
    const options = {custom: excludedChars, uric: true};
    return window.getSlug(string, options);
  },

  cutLastChars: (string, length) => string.substring(0, string.length - length),

  format: (...args) => {
    let [string] = args;

    for (let index = 0; index < args.length; ++index) {
      const reg = new RegExp(`\\{${index}\\}`, 'gm');
      string = string.replace(reg, args[index + 1]);
    }

    return string;
  },

  getFirstChar: string => [...string][0],

  getLastChars: (string, length) => (string.length < length ? false : string.substring(string.length - length)),

  getRandomChar: () => {
    let charIndex;
    while (
      !z.util.NumberUtil.inRange(charIndex, 1, 9) &&
      !z.util.NumberUtil.inRange(charIndex, 65, 90) &&
      !z.util.NumberUtil.inRange(charIndex, 97, 122)
    ) {
      charIndex = Math.floor(Math.random() * 122);
    }

    // Returns random alphanumeric character [A-Z, a-z, 0-9]
    return charIndex <= 9 ? charIndex : String.fromCharCode(charIndex);
  },

  /**
   * @param {string} hexString - string to convert
   * @returns {number[]} bytes as array
   */
  hexToBytes: hexString => {
    const bytes = [];
    const hexBase = 16;

    for (let charIndex = 0; charIndex < hexString.length; charIndex += 2) {
      const parsedInt = parseInt(hexString.substr(charIndex, 2), hexBase);
      bytes.push(parsedInt);
    }

    return bytes;
  },

  includes: (string = '', query = '') => string.toLowerCase().includes(query.toLowerCase()),

  obfuscate: text => {
    const alphabet = Array.from('abcdefghijklmnopqrstuvwxyz');
    let obfuscated = '';

    for (const character of text) {
      if (character.match(/[\n\r\s]+/gi)) {
        obfuscated += character;
      } else {
        obfuscated += z.util.ArrayUtil.randomElement(alphabet);
      }
    }

    return obfuscated;
  },

  /**
   * @param {string} str - string to pad
   * @param {number} length - maximum length to pad
   * @param {string} [padCharacter] - character to pad with (default is space)
   * @returns {string} The padded string
   */
  padStart(str, length, padCharacter = ' ') {
    if (str.length >= length) {
      return str;
    }
    return padCharacter.repeat(length - str.length) + str;
  },

  removeLineBreaks: (string = '') => string.replace(/(\r\n|\n|\r)/gm, ''),

  replaceInRange(text, replacement, startIndex, endIndex) {
    const beforePartial = text.slice(0, startIndex);
    const afterPartial = text.slice(endIndex);
    return `${beforePartial}${replacement}${afterPartial}`;
  },

  sortByPriority: (stringA = '', stringB = '', query) => {
    stringA = stringA.toLowerCase();
    stringB = stringB.toLowerCase();

    if (query) {
      if (z.util.StringUtil.startsWith(stringA, query)) {
        if (!z.util.StringUtil.startsWith(stringB, query)) {
          return -1;
        }
      } else if (z.util.StringUtil.startsWith(stringB, query)) {
        if (!z.util.StringUtil.startsWith(stringA, query)) {
          return 1;
        }
      }
    }

    if (stringA < stringB) {
      return -1;
    }

    if (stringA > stringB) {
      return 1;
    }

    return 0;
  },

  splitAtPivotElement: (text, pivot, replacement) => {
    if (!pivot) {
      return [
        {
          isStyled: false,
          text,
        },
      ];
    }

    const findPivot = pivot === '?' ? new RegExp('(\\?)') : new RegExp(`(${pivot})`);

    return text
      .split(findPivot)
      .map(value => {
        return value
          ? {
              isStyled: value === pivot,
              text: value === pivot ? replacement : value,
            }
          : undefined;
      })
      .filter(item => item);
  },

  startsWith: (string = '', query) => string.toLowerCase().startsWith(query.toLowerCase()),

  trimEnd: (string = '') => string.replace(/\s*$/, ''),
  trimStart: (string = '') => string.replace(/^\s*/, ''),

  truncate: (string, outputLength, wordBoundary = true) => {
    if (string.length > outputLength) {
      let truncateIndex = outputLength - 1;
      if (wordBoundary && string.lastIndexOf(' ', outputLength - 1) > outputLength - 25) {
        truncateIndex = string.lastIndexOf(' ', outputLength - 1);
      }
      string = `${string.substr(0, truncateIndex)}…`;
    }
    return string;
  },

  /**
   * @param {string} str - The string to convert
   * @returns {number[]} Converted string as byte array
   */
  utf8ToUtf16BE: str => {
    const BOMChar = '\uFEFF';

    str = `${BOMChar}${str}`;

    const bytes = [];

    for (let i = 0; i < str.length; ++i) {
      const charCode = str.charCodeAt(i);
      bytes.push((charCode & 0xff00) >> 8);
      bytes.push(charCode & 0xff);
    }

    return bytes;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.CountryCodes = (() => {
  const COUNTRY_CODES = [
    {
      code: 93,
      iso: 'AF',
      name: 'Afghanistan',
      population: 31,
    },
    {
      code: 355,
      iso: 'AL',
      name: 'Albania',
      population: 2,
    },
    {
      code: 213,
      iso: 'DZ',
      name: 'Algeria',
      population: 34,
    },
    {
      code: 1684,
      iso: 'AS',
      name: 'American Samoa',
      population: 0,
    },
    {
      code: 376,
      iso: 'AD',
      name: 'Andorra',
      population: 0,
    },
    {
      code: 244,
      iso: 'AO',
      name: 'Angola',
      population: 13,
    },
    {
      code: 1264,
      iso: 'AI',
      name: 'Anguilla',
      population: 0,
    },
    {
      code: 672,
      iso: 'AQ',
      name: 'Antarctica',
      population: 0,
    },
    {
      code: 1268,
      iso: 'AG',
      name: 'Antigua and Barbuda',
      population: 0,
    },
    {
      code: 54,
      iso: 'AR',
      name: 'Argentina',
      population: 41,
    },
    {
      code: 374,
      iso: 'AM',
      name: 'Armenia',
      population: 2,
    },
    {
      code: 297,
      iso: 'AW',
      name: 'Aruba',
      population: 0,
    },
    {
      code: 61,
      iso: 'AU',
      name: 'Australia',
      population: 21,
    },
    {
      code: 43,
      iso: 'AT',
      name: 'Austria',
      population: 8,
    },
    {
      code: 994,
      iso: 'AZ',
      name: 'Azerbaijan',
      population: 8,
    },
    {
      code: 1242,
      iso: 'BS',
      name: 'Bahamas',
      population: 0,
    },
    {
      code: 973,
      iso: 'BH',
      name: 'Bahrain',
      population: 0,
    },
    {
      code: 880,
      iso: 'BD',
      name: 'Bangladesh',
      population: 171,
    },
    {
      code: 1246,
      iso: 'BB',
      name: 'Barbados',
      population: 0,
    },
    {
      code: 375,
      iso: 'BY',
      name: 'Belarus',
      population: 9,
    },
    {
      code: 32,
      iso: 'BE',
      name: 'Belgium',
      population: 10,
    },
    {
      code: 501,
      iso: 'BZ',
      name: 'Belize',
      population: 0,
    },
    {
      code: 229,
      iso: 'BJ',
      name: 'Benin',
      population: 9,
    },
    {
      code: 1441,
      iso: 'BM',
      name: 'Bermuda',
      population: 0,
    },
    {
      code: 975,
      iso: 'BT',
      name: 'Bhutan',
      population: 0,
    },
    {
      code: 591,
      iso: 'BO',
      name: 'Bolivia',
      population: 9,
    },
    {
      code: 387,
      iso: 'BA',
      name: 'Bosnia and Herzegovina',
      population: 4,
    },
    {
      code: 267,
      iso: 'BW',
      name: 'Botswana',
      population: 2,
    },
    {
      code: 55,
      iso: 'BR',
      name: 'Brazil',
      population: 201,
    },
    {
      code: 246,
      iso: 'IO',
      name: 'British Indian Ocean Territory',
      population: 0,
    },
    {
      code: 1284,
      iso: 'VG',
      name: 'British Virgin Islands',
      population: 0,
    },
    {
      code: 673,
      iso: 'BN',
      name: 'Brunei',
      population: 0,
    },
    {
      code: 359,
      iso: 'BG',
      name: 'Bulgaria',
      population: 7,
    },
    {
      code: 226,
      iso: 'BF',
      name: 'Burkina Faso',
      population: 16,
    },
    {
      code: 257,
      iso: 'BI',
      name: 'Burundi',
      population: 9,
    },
    {
      code: 855,
      iso: 'KH',
      name: 'Cambodia',
      population: 14,
    },
    {
      code: 237,
      iso: 'CM',
      name: 'Cameroon',
      population: 19,
    },
    {
      code: 1,
      iso: 'CA',
      name: 'Canada',
      population: 33,
    },
    {
      code: 238,
      iso: 'CV',
      name: 'Cape Verde',
      population: 0,
    },
    {
      code: 1345,
      iso: 'KY',
      name: 'Cayman Islands',
      population: 0,
    },
    {
      code: 236,
      iso: 'CF',
      name: 'Central African Republic',
      population: 4,
    },
    {
      code: 235,
      iso: 'TD',
      name: 'Chad',
      population: 10,
    },
    {
      code: 56,
      iso: 'CL',
      name: 'Chile',
      population: 16,
    },
    {
      code: 86,
      iso: 'CN',
      name: 'China',
      population: 1376,
    },
    {
      code: 61,
      iso: 'CX',
      name: 'Christmas Island',
      population: 0,
    },
    {
      code: 61,
      iso: 'CC',
      name: 'Cocos Islands',
      population: 0,
    },
    {
      code: 57,
      iso: 'CO',
      name: 'Colombia',
      population: 47,
    },
    {
      code: 269,
      iso: 'KM',
      name: 'Comoros',
      population: 0,
    },
    {
      code: 682,
      iso: 'CK',
      name: 'Cook Islands',
      population: 0,
    },
    {
      code: 506,
      iso: 'CR',
      name: 'Costa Rica',
      population: 4,
    },
    {
      code: 385,
      iso: 'HR',
      name: 'Croatia',
      population: 4,
    },
    {
      code: 53,
      iso: 'CU',
      name: 'Cuba',
      population: 11,
    },
    {
      code: 599,
      iso: 'CW',
      name: 'Curacao',
      population: 0,
    },
    {
      code: 357,
      iso: 'CY',
      name: 'Cyprus',
      population: 1,
    },
    {
      code: 420,
      iso: 'CZ',
      name: 'Czech Republic',
      population: 10,
    },
    {
      code: 243,
      iso: 'CD',
      name: 'Democratic Republic of the Congo',
      population: 81,
    },
    {
      code: 45,
      iso: 'DK',
      name: 'Denmark',
      population: 5,
    },
    {
      code: 253,
      iso: 'DJ',
      name: 'Djibouti',
      population: 0,
    },
    {
      code: 1767,
      iso: 'DM',
      name: 'Dominica',
      population: 0,
    },
    {
      code: 1809,
      iso: 'DO',
      name: 'Dominican Republic',
      population: 9,
    },
    {
      code: 670,
      iso: 'TL',
      name: 'East Timor',
      population: 1,
    },
    {
      code: 593,
      iso: 'EC',
      name: 'Ecuador',
      population: 14,
    },
    {
      code: 20,
      iso: 'EG',
      name: 'Egypt',
      population: 91,
    },
    {
      code: 503,
      iso: 'SV',
      name: 'El Salvador',
      population: 6,
    },
    {
      code: 240,
      iso: 'GQ',
      name: 'Equatorial Guinea',
      population: 1,
    },
    {
      code: 291,
      iso: 'ER',
      name: 'Eritrea',
      population: 5,
    },
    {
      code: 372,
      iso: 'EE',
      name: 'Estonia',
      population: 1,
    },
    {
      code: 251,
      iso: 'ET',
      name: 'Ethiopia',
      population: 88,
    },
    {
      code: 500,
      iso: 'FK',
      name: 'Falkland Islands',
      population: 0,
    },
    {
      code: 298,
      iso: 'FO',
      name: 'Faroe Islands',
      population: 0,
    },
    {
      code: 679,
      iso: 'FJ',
      name: 'Fiji',
      population: 0,
    },
    {
      code: 358,
      iso: 'FI',
      name: 'Finland',
      population: 5,
    },
    {
      code: 33,
      iso: 'FR',
      name: 'France',
      population: 64,
    },
    {
      code: 689,
      iso: 'PF',
      name: 'French Polynesia',
      population: 0,
    },
    {
      code: 241,
      iso: 'GA',
      name: 'Gabon',
      population: 1,
    },
    {
      code: 220,
      iso: 'GM',
      name: 'Gambia',
      population: 1,
    },
    {
      code: 995,
      iso: 'GE',
      name: 'Georgia',
      population: 4,
    },
    {
      code: 49,
      iso: 'DE',
      name: 'Germany',
      population: 81,
    },
    {
      code: 233,
      iso: 'GH',
      name: 'Ghana',
      population: 24,
    },
    {
      code: 350,
      iso: 'GI',
      name: 'Gibraltar',
      population: 0,
    },
    {
      code: 30,
      iso: 'GR',
      name: 'Greece',
      population: 11,
    },
    {
      code: 299,
      iso: 'GL',
      name: 'Greenland',
      population: 0,
    },
    {
      code: 1473,
      iso: 'GD',
      name: 'Grenada',
      population: 0,
    },
    {
      code: 1671,
      iso: 'GU',
      name: 'Guam',
      population: 0,
    },
    {
      code: 502,
      iso: 'GT',
      name: 'Guatemala',
      population: 13,
    },
    {
      code: 441481,
      iso: 'GG',
      name: 'Guernsey',
      population: 0,
    },
    {
      code: 224,
      iso: 'GN',
      name: 'Guinea',
      population: 10,
    },
    {
      code: 245,
      iso: 'GW',
      name: 'Guinea-Bissau',
      population: 1,
    },
    {
      code: 592,
      iso: 'GY',
      name: 'Guyana',
      population: 0,
    },
    {
      code: 509,
      iso: 'HT',
      name: 'Haiti',
      population: 9,
    },
    {
      code: 504,
      iso: 'HN',
      name: 'Honduras',
      population: 7,
    },
    {
      code: 852,
      iso: 'HK',
      name: 'Hong Kong',
      population: 6,
    },
    {
      code: 36,
      iso: 'HU',
      name: 'Hungary',
      population: 9,
    },
    {
      code: 354,
      iso: 'IS',
      name: 'Iceland',
      population: 0,
    },
    {
      code: 91,
      iso: 'IN',
      name: 'India',
      population: 1173,
    },
    {
      code: 62,
      iso: 'ID',
      name: 'Indonesia',
      population: 242,
    },
    {
      code: 98,
      iso: 'IR',
      name: 'Iran',
      population: 76,
    },
    {
      code: 964,
      iso: 'IQ',
      name: 'Iraq',
      population: 29,
    },
    {
      code: 353,
      iso: 'IE',
      name: 'Ireland',
      population: 4,
    },
    {
      code: 441624,
      iso: 'IM',
      name: 'Isle of Man',
      population: 0,
    },
    {
      code: 972,
      iso: 'IL',
      name: 'Israel',
      population: 7,
    },
    {
      code: 39,
      iso: 'IT',
      name: 'Italy',
      population: 60,
    },
    {
      code: 225,
      iso: 'CI',
      name: 'Ivory Coast',
      population: 21,
    },
    {
      code: 1876,
      iso: 'JM',
      name: 'Jamaica',
      population: 2,
    },
    {
      code: 81,
      iso: 'JP',
      name: 'Japan',
      population: 127,
    },
    {
      code: 441534,
      iso: 'JE',
      name: 'Jersey',
      population: 0,
    },
    {
      code: 962,
      iso: 'JO',
      name: 'Jordan',
      population: 6,
    },
    {
      code: 7,
      iso: 'KZ',
      name: 'Kazakhstan',
      population: 15,
    },
    {
      code: 254,
      iso: 'KE',
      name: 'Kenya',
      population: 40,
    },
    {
      code: 686,
      iso: 'KI',
      name: 'Kiribati',
      population: 0,
    },
    {
      code: 383,
      iso: 'XK',
      name: 'Kosovo',
      population: 1,
    },
    {
      code: 965,
      iso: 'KW',
      name: 'Kuwait',
      population: 2,
    },
    {
      code: 996,
      iso: 'KG',
      name: 'Kyrgyzstan',
      population: 5,
    },
    {
      code: 856,
      iso: 'LA',
      name: 'Laos',
      population: 6,
    },
    {
      code: 371,
      iso: 'LV',
      name: 'Latvia',
      population: 2,
    },
    {
      code: 961,
      iso: 'LB',
      name: 'Lebanon',
      population: 4,
    },
    {
      code: 266,
      iso: 'LS',
      name: 'Lesotho',
      population: 1,
    },
    {
      code: 231,
      iso: 'LR',
      name: 'Liberia',
      population: 3,
    },
    {
      code: 218,
      iso: 'LY',
      name: 'Libya',
      population: 6,
    },
    {
      code: 423,
      iso: 'LI',
      name: 'Liechtenstein',
      population: 0,
    },
    {
      code: 370,
      iso: 'LT',
      name: 'Lithuania',
      population: 2,
    },
    {
      code: 352,
      iso: 'LU',
      name: 'Luxembourg',
      population: 0,
    },
    {
      code: 853,
      iso: 'MO',
      name: 'Macao',
      population: 0,
    },
    {
      code: 389,
      iso: 'MK',
      name: 'Macedonia',
      population: 2,
    },
    {
      code: 261,
      iso: 'MG',
      name: 'Madagascar',
      population: 21,
    },
    {
      code: 265,
      iso: 'MW',
      name: 'Malawi',
      population: 15,
    },
    {
      code: 60,
      iso: 'MY',
      name: 'Malaysia',
      population: 28,
    },
    {
      code: 960,
      iso: 'MV',
      name: 'Maldives',
      population: 0,
    },
    {
      code: 223,
      iso: 'ML',
      name: 'Mali',
      population: 13,
    },
    {
      code: 356,
      iso: 'MT',
      name: 'Malta',
      population: 0,
    },
    {
      code: 692,
      iso: 'MH',
      name: 'Marshall Islands',
      population: 0,
    },
    {
      code: 222,
      iso: 'MR',
      name: 'Mauritania',
      population: 3,
    },
    {
      code: 230,
      iso: 'MU',
      name: 'Mauritius',
      population: 1,
    },
    {
      code: 262,
      iso: 'YT',
      name: 'Mayotte',
      population: 0,
    },
    {
      code: 52,
      iso: 'MX',
      name: 'Mexico',
      population: 112,
    },
    {
      code: 691,
      iso: 'FM',
      name: 'Micronesia',
      population: 0,
    },
    {
      code: 373,
      iso: 'MD',
      name: 'Moldova',
      population: 4,
    },
    {
      code: 377,
      iso: 'MC',
      name: 'Monaco',
      population: 0,
    },
    {
      code: 976,
      iso: 'MN',
      name: 'Mongolia',
      population: 3,
    },
    {
      code: 382,
      iso: 'ME',
      name: 'Montenegro',
      population: 0,
    },
    {
      code: 1664,
      iso: 'MS',
      name: 'Montserrat',
      population: 0,
    },
    {
      code: 212,
      iso: 'MA',
      name: 'Morocco',
      population: 33,
    },
    {
      code: 258,
      iso: 'MZ',
      name: 'Mozambique',
      population: 22,
    },
    {
      code: 95,
      iso: 'MM',
      name: 'Myanmar',
      population: 53,
    },
    {
      code: 264,
      iso: 'NA',
      name: 'Namibia',
      population: 2,
    },
    {
      code: 674,
      iso: 'NR',
      name: 'Nauru',
      population: 0,
    },
    {
      code: 977,
      iso: 'NP',
      name: 'Nepal',
      population: 28,
    },
    {
      code: 31,
      iso: 'NL',
      name: 'Netherlands',
      population: 16,
    },
    {
      code: 599,
      iso: 'AN',
      name: 'Netherlands Antilles',
      population: 0,
    },
    {
      code: 687,
      iso: 'NC',
      name: 'New Caledonia',
      population: 0,
    },
    {
      code: 64,
      iso: 'NZ',
      name: 'New Zealand',
      population: 4,
    },
    {
      code: 505,
      iso: 'NI',
      name: 'Nicaragua',
      population: 5,
    },
    {
      code: 227,
      iso: 'NE',
      name: 'Niger',
      population: 15,
    },
    {
      code: 234,
      iso: 'NG',
      name: 'Nigeria',
      population: 182,
    },
    {
      code: 683,
      iso: 'NU',
      name: 'Niue',
      population: 0,
    },
    {
      code: 850,
      iso: 'KP',
      name: 'North Korea',
      population: 22,
    },
    {
      code: 1670,
      iso: 'MP',
      name: 'Northern Mariana Islands',
      population: 0,
    },
    {
      code: 47,
      iso: 'NO',
      name: 'Norway',
      population: 5,
    },
    {
      code: 968,
      iso: 'OM',
      name: 'Oman',
      population: 2,
    },
    {
      code: 92,
      iso: 'PK',
      name: 'Pakistan',
      population: 184,
    },
    {
      code: 680,
      iso: 'PW',
      name: 'Palau',
      population: 0,
    },
    {
      code: 970,
      iso: 'PS',
      name: 'Palestine',
      population: 3,
    },
    {
      code: 507,
      iso: 'PA',
      name: 'Panama',
      population: 3,
    },
    {
      code: 675,
      iso: 'PG',
      name: 'Papua New Guinea',
      population: 6,
    },
    {
      code: 595,
      iso: 'PY',
      name: 'Paraguay',
      population: 6,
    },
    {
      code: 51,
      iso: 'PE',
      name: 'Peru',
      population: 29,
    },
    {
      code: 63,
      iso: 'PH',
      name: 'Philippines',
      population: 102,
    },
    {
      code: 64,
      iso: 'PN',
      name: 'Pitcairn',
      population: 0,
    },
    {
      code: 48,
      iso: 'PL',
      name: 'Poland',
      population: 38,
    },
    {
      code: 351,
      iso: 'PT',
      name: 'Portugal',
      population: 10,
    },
    {
      code: 1787,
      iso: 'PR',
      name: 'Puerto Rico',
      population: 3,
    },
    {
      code: 974,
      iso: 'QA',
      name: 'Qatar',
      population: 0,
    },
    {
      code: 242,
      iso: 'CG',
      name: 'Republic of the Congo',
      population: 3,
    },
    {
      code: 262,
      iso: 'RE',
      name: 'Reunion',
      population: 0,
    },
    {
      code: 40,
      iso: 'RO',
      name: 'Romania',
      population: 21,
    },
    {
      code: 7,
      iso: 'RU',
      name: 'Russia',
      population: 140,
    },
    {
      code: 250,
      iso: 'RW',
      name: 'Rwanda',
      population: 11,
    },
    {
      code: 590,
      iso: 'BL',
      name: 'Saint Barthelemy',
      population: 0,
    },
    {
      code: 290,
      iso: 'SH',
      name: 'Saint Helena',
      population: 0,
    },
    {
      code: 1869,
      iso: 'KN',
      name: 'Saint Kitts and Nevis',
      population: 0,
    },
    {
      code: 1758,
      iso: 'LC',
      name: 'Saint Lucia',
      population: 0,
    },
    {
      code: 590,
      iso: 'MF',
      name: 'Saint Martin',
      population: 0,
    },
    {
      code: 508,
      iso: 'PM',
      name: 'Saint Pierre and Miquelon',
      population: 0,
    },
    {
      code: 1784,
      iso: 'VC',
      name: 'Saint Vincent and the Grenadines',
      population: 0,
    },
    {
      code: 685,
      iso: 'WS',
      name: 'Samoa',
      population: 0,
    },
    {
      code: 378,
      iso: 'SM',
      name: 'San Marino',
      population: 0,
    },
    {
      code: 239,
      iso: 'ST',
      name: 'Sao Tome and Principe',
      population: 0,
    },
    {
      code: 966,
      iso: 'SA',
      name: 'Saudi Arabia',
      population: 25,
    },
    {
      code: 221,
      iso: 'SN',
      name: 'Senegal',
      population: 12,
    },
    {
      code: 381,
      iso: 'RS',
      name: 'Serbia',
      population: 7,
    },
    {
      code: 248,
      iso: 'SC',
      name: 'Seychelles',
      population: 0,
    },
    {
      code: 232,
      iso: 'SL',
      name: 'Sierra Leone',
      population: 5,
    },
    {
      code: 65,
      iso: 'SG',
      name: 'Singapore',
      population: 4,
    },
    {
      code: 1721,
      iso: 'SX',
      name: 'Sint Maarten',
      population: 0,
    },
    {
      code: 421,
      iso: 'SK',
      name: 'Slovakia',
      population: 5,
    },
    {
      code: 386,
      iso: 'SI',
      name: 'Slovenia',
      population: 2,
    },
    {
      code: 677,
      iso: 'SB',
      name: 'Solomon Islands',
      population: 0,
    },
    {
      code: 252,
      iso: 'SO',
      name: 'Somalia',
      population: 10,
    },
    {
      code: 27,
      iso: 'ZA',
      name: 'South Africa',
      population: 54,
    },
    {
      code: 82,
      iso: 'KR',
      name: 'South Korea',
      population: 48,
    },
    {
      code: 211,
      iso: 'SS',
      name: 'South Sudan',
      population: 8,
    },
    {
      code: 34,
      iso: 'ES',
      name: 'Spain',
      population: 46,
    },
    {
      code: 94,
      iso: 'LK',
      name: 'Sri Lanka',
      population: 21,
    },
    {
      code: 249,
      iso: 'SD',
      name: 'Sudan',
      population: 35,
    },
    {
      code: 597,
      iso: 'SR',
      name: 'Suriname',
      population: 0,
    },
    {
      code: 47,
      iso: 'SJ',
      name: 'Svalbard and Jan Mayen',
      population: 0,
    },
    {
      code: 268,
      iso: 'SZ',
      name: 'Swaziland',
      population: 1,
    },
    {
      code: 46,
      iso: 'SE',
      name: 'Sweden',
      population: 9,
    },
    {
      code: 41,
      iso: 'CH',
      name: 'Switzerland',
      population: 8,
    },
    {
      code: 963,
      iso: 'SY',
      name: 'Syria',
      population: 22,
    },
    {
      code: 886,
      iso: 'TW',
      name: 'Taiwan',
      population: 22,
    },
    {
      code: 992,
      iso: 'TJ',
      name: 'Tajikistan',
      population: 7,
    },
    {
      code: 255,
      iso: 'TZ',
      name: 'Tanzania',
      population: 41,
    },
    {
      code: 66,
      iso: 'TH',
      name: 'Thailand',
      population: 67,
    },
    {
      code: 228,
      iso: 'TG',
      name: 'Togo',
      population: 6,
    },
    {
      code: 690,
      iso: 'TK',
      name: 'Tokelau',
      population: 0,
    },
    {
      code: 676,
      iso: 'TO',
      name: 'Tonga',
      population: 0,
    },
    {
      code: 1868,
      iso: 'TT',
      name: 'Trinidad and Tobago',
      population: 1,
    },
    {
      code: 216,
      iso: 'TN',
      name: 'Tunisia',
      population: 10,
    },
    {
      code: 90,
      iso: 'TR',
      name: 'Turkey',
      population: 77,
    },
    {
      code: 993,
      iso: 'TM',
      name: 'Turkmenistan',
      population: 4,
    },
    {
      code: 1649,
      iso: 'TC',
      name: 'Turks and Caicos Islands',
      population: 0,
    },
    {
      code: 688,
      iso: 'TV',
      name: 'Tuvalu',
      population: 0,
    },
    {
      code: 1340,
      iso: 'VI',
      name: 'U.S. Virgin Islands',
      population: 0,
    },
    {
      code: 256,
      iso: 'UG',
      name: 'Uganda',
      population: 33,
    },
    {
      code: 380,
      iso: 'UA',
      name: 'Ukraine',
      population: 45,
    },
    {
      code: 971,
      iso: 'AE',
      name: 'United Arab Emirates',
      population: 4,
    },
    {
      code: 44,
      iso: 'GB',
      name: 'United Kingdom',
      population: 65,
    },
    {
      code: 1,
      iso: 'US',
      name: 'United States',
      population: 324,
    },
    {
      code: 598,
      iso: 'UY',
      name: 'Uruguay',
      population: 3,
    },
    {
      code: 998,
      iso: 'UZ',
      name: 'Uzbekistan',
      population: 27,
    },
    {
      code: 678,
      iso: 'VU',
      name: 'Vanuatu',
      population: 0,
    },
    {
      code: 379,
      iso: 'VA',
      name: 'Vatican',
      population: 0,
    },
    {
      code: 58,
      iso: 'VE',
      name: 'Venezuela',
      population: 26,
    },
    {
      code: 84,
      iso: 'VN',
      name: 'Vietnam',
      population: 91,
    },
    {
      code: 681,
      iso: 'WF',
      name: 'Wallis and Futuna',
      population: 0,
    },
    {
      code: 212,
      iso: 'EH',
      name: 'Western Sahara',
      population: 0,
    },
    {
      code: 967,
      iso: 'YE',
      name: 'Yemen',
      population: 24,
    },
    {
      code: 260,
      iso: 'ZM',
      name: 'Zambia',
      population: 16,
    },
    {
      code: 263,
      iso: 'ZW',
      name: 'Zimbabwe',
      population: 12,
    },
  ];

  return {
    COUNTRY_CODES: COUNTRY_CODES,
    /**
     * Get the country code matching to an ISO name
     * @param {number} code - Country code
     * @returns {string} Returns the ISO standard country name of the most populated country with the matching country code
     */
    getCountryByCode: code => {
      let countries = [];

      for (const country of COUNTRY_CODES) {
        if (country.code === window.parseInt(code, 10)) {
          countries.push(country);
        }
      }

      countries = countries.sort((countryA, countryB) => countryA.population - countryB.population);

      const country = countries.pop();
      if (country) {
        return country.iso;
      }
    },

    /**
     * Get the country code matching an ISO name
     * @param {string} isoName - ISO standard country name
     * @returns {number} Matching country code
     */
    getCountryCode: isoName => {
      for (const country of COUNTRY_CODES) {
        if (country.iso === isoName) {
          return country.code;
        }
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.Worker = class Worker {
  constructor(uri) {
    this.post = data => {
      return new Promise((resolve, reject) => {
        const worker = new window.Worker(uri);
        worker.onmessage = event => resolve(event.data);
        worker.onerror = error => reject(error);
        worker.postMessage(data);
      });
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.URLUtil = (() => {
  const TYPE = {
    ACCOUNT: 'TYPE.ACCOUNT',
    SUPPORT: 'TYPE.SUPPORT',
    TEAM_SETTINGS: 'TYPE.TEAM_SETTINGS',
    WEBAPP: 'TYPE.WEBAPP',
    WEBSITE: 'TYPE.WEBSITE',
  };

  const _appendParameter = (url, parameter) => {
    const separator = z.util.StringUtil.includes(url, '?') ? '&' : '?';
    return `${url}${separator}${parameter}`;
  };

  const _buildSupportUrl = support_id => {
    const urlPath = _.isNumber(support_id) ? z.string.urlSupportArticles : z.string.urlSupportRequests;
    return `${_getDomain(TYPE.SUPPORT)}${z.l10n.text(urlPath)}${support_id}`;
  };

  const _buildUrl = (type, path = '') => `${_getDomain(type)}${path && path.startsWith('/') ? path : ''}`;

  const _forwardParameter = (url, parameterName, locationSearch = window.location.search) => {
    const parameterValue = _getParameter(parameterName, locationSearch);
    const hasValue = parameterValue != null;
    return hasValue ? _appendParameter(url, `${parameterName}=${parameterValue}`) : url;
  };

  const _getDomain = urlType => {
    const isProduction = _isProductionBackend();

    switch (urlType) {
      case TYPE.ACCOUNT:
        return isProduction ? window.wire.env.URL.ACCOUNT_BASE : z.config.URL.ACCOUNT.STAGING;
      case TYPE.SUPPORT:
        return z.config.URL.SUPPORT;
      case TYPE.TEAM_SETTINGS:
        return isProduction ? window.wire.env.URL.TEAMS_BASE : z.config.URL.TEAM_SETTINGS.STAGING;
      case TYPE.WEBAPP:
        return isProduction ? window.wire.env.APP_BASE : z.config.URL.WEBAPP.STAGING;
      case TYPE.WEBSITE:
        return isProduction ? window.wire.env.URL.WEBSITE_BASE : z.config.URL.WEBSITE.STAGING;
      default:
        throw new Error('Unknown URL type');
    }
  };

  /**
   * Removes protocol, www and trailing slashes in the given url
   * @param {string} url - URL
   * @returns {string} Plain URL
   */
  const _getDomainName = (url = '') => {
    // force a protocol if there is none
    url = url.replace(/^(?!https?:\/\/)/i, 'http://');
    try {
      const {hostname, pathname, search, hash} = new URL(url);
      return hostname.replace(/^www./, '') + pathname.replace(/\/$/, '') + search + hash;
    } catch (error) {
      return '';
    }
  };

  const _getParameter = (parameterName, locationSearch = window.location.search) => {
    const searchParameters = locationSearch.substring(1).split('&');
    for (const searchParam of searchParameters) {
      const [parameter, value] = searchParam.split('=');
      const isExpectedParameter = parameter === parameterName;
      if (isExpectedParameter) {
        if (value) {
          const decodedValue = window.decodeURI(value);

          if (decodedValue === 'false') {
            return false;
          }

          if (decodedValue === 'true') {
            return true;
          }

          return value;
        }

        return true;
      }
    }

    return null;
  };

  const _getLinksFromHtml = html => {
    if (!html) {
      return [];
    }

    const anchorTags = new RegExp(/<a[\s]+([^>]+)>((?:.(?!\<\/a\>))*.)<\/a>/, 'g');
    const links = html.match(anchorTags);

    const hasLinks = links && links.length;
    return hasLinks ? links.map(element => $(element)[0]) : [];
  };

  const _isProductionBackend = () => z.util.Environment.backend.current === z.service.BackendEnvironment.PRODUCTION;

  /**
   * Prepends http to given url if protocol missing
   * @param {string} url - URL you want to open in a new browser tab
   * @returns {undefined} No return value
   */
  const _prependProtocol = url => (!url.match(/^http[s]?:\/\//i) ? `http://${url}` : url);

  return {
    TYPE: TYPE,
    appendParameter: _appendParameter,
    buildSupportUrl: _buildSupportUrl,
    buildUrl: _buildUrl,
    forwardParameter: _forwardParameter,
    getDomainName: _getDomainName,
    getLinksFromHtml: _getLinksFromHtml,
    getParameter: _getParameter,
    prependProtocol: _prependProtocol,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ValidationUtil = {
  // ToDo: Move z.util.isValidUsername here
  // ToDo: Move z.util.isValidPhoneNumber here
  // ToDo: Move z.util.isIsoString here
  // ToDo: Move z.util.isValidEmail here
  // ToDo: Move z.util.isSameLocation here
  asset: {
    legacy: (assetId, conversationId) => {
      if (!z.util.ValidationUtil.isUUID(assetId) || !z.util.ValidationUtil.isUUID(conversationId)) {
        throw new z.util.ValidationUtilError('Invalid assetId / conversationId');
      }
      return true;
    },

    // https://github.com/wireapp/wire-server/blob/dc3e9a8af5250c0d045e96a31aa23c255b4e01a3/libs/cargohold-types/src/CargoHold/Types/V3.hs#L156-L177
    retentionPolicy: policyId => policyId > 0 && policyId < Object.keys(z.assets.AssetRetentionPolicy).length + 1,

    v3: (assetKey, assetToken) => {
      if (!assetKey) {
        throw new z.util.ValidationUtilError('Asset key not defined');
      }

      const SEPARATOR = '-';
      const [version, type, ...uuid] = assetKey.split(SEPARATOR);

      if (version !== '3') {
        throw new z.util.ValidationUtilError('Invalid asset key (version)');
      }
      if (!z.util.ValidationUtil.asset.retentionPolicy(type)) {
        throw new z.util.ValidationUtilError('Invalid asset key (type)');
      }
      if (!z.util.ValidationUtil.isUUID(uuid.join(SEPARATOR))) {
        throw new z.util.ValidationUtilError('Invalid asset key (UUID)');
      }
      if (assetToken && !z.util.ValidationUtil.isBearerToken(assetToken)) {
        throw new z.util.ValidationUtilError('Invalid asset token');
      }
      return true;
    },
  },

  isBase64: string => {
    try {
      // Will raise a DOM exception if base64 string is invalid
      window.atob(string);
    } catch (error) {
      return false;
    }
    return true;
  },

  // Since some special chars are allowed, remember to always encode Bearer tokens using encodeURIComponents afterwards!
  isBearerToken: token => /^[a-zA-Z0-9\-._~+/]+[=]{0,2}$/.test(token),

  isUUID: string => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(string),

  isValidApiPath: path => {
    const [urlPath] = path.split('?');
    if (!/^\/[a-zA-Z0-9\-_/,]+$/.test(urlPath)) {
      throw new z.util.ValidationUtilError(`Non-compliant path creation attempt. Details: ${path}`);
    }
    return true;
  },

  urls: {
    isTweet: url => {
      const regex = /^http(?:s)?:\/\/(?:(?:www|mobile|0)\.)?twitter\.com\/(?:(?:\w{1,15})\/status(?:es|\/i)?|i\/moments)\/(?:\d{2,21})(?:(?:\?|\/).*)?$/;
      return regex.test(url);
    },
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.ValidationUtilError = class ValidationUtilError extends Error {
  constructor(message = 'Unknown ValidationUtilError') {
    super();

    this.message = message;
    this.name = this.constructor.name;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.util = z.util || {};

z.util.popup = {
  getCursorPixelPosition: input => {
    const css = getComputedStyle(input);
    const boundingRectangleInput = input.getBoundingClientRect();
    const mask = document.createElement('div');
    const span = document.createElement('span');
    const text = document.createTextNode(input.value);

    mask.appendChild(text);
    mask.style.font = css.font;
    mask.style.position = 'fixed';
    mask.style.left = `${input.clientLeft + boundingRectangleInput.left}px`;
    mask.style.top = `${input.clientTop + boundingRectangleInput.top}px`;
    mask.style.color = 'red';
    mask.style.overflow = 'scroll';
    mask.style.visibility = 'hidden';
    mask.style.whiteSpace = 'pre-wrap';
    mask.style.padding = css.padding;
    mask.style.width = css.width;
    mask.style.height = css.height;
    span.innerText = 'I';

    const position = input.selectionStart;
    if (position === input.value.length) {
      mask.appendChild(span);
    } else {
      mask.insertBefore(span, mask.childNodes[0].splitText(position));
    }
    document.body.appendChild(mask);
    span.scrollIntoView();

    const boundingRectangleSpan = span.getBoundingClientRect();

    mask.remove();
    return boundingRectangleSpan;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};

window.z.config = {
  ACCENT_ID: {
    BLUE: 1,
    GREEN: 2,
    ORANGE: 5,
    PINK: 6,
    PURPLE: 7,
    RED: 4,
    YELLOW: 3,
  },

  LOGGER: {
    OPTIONS: {
      domains: {
        'app.wire.com': () => 0,
        localhost: () => 300,
        'wire.ms': () => 300,
        'wire-webapp-staging.wire.com': () => 300,
        'zinfra.io': () => 300,
      },
      name_length: 65,
    },
  },

  // 10 seconds until phone code expires
  LOGIN_CODE_EXPIRATION: 10 * 60,

  // 25 megabyte upload limit for personal use
  MAXIMUM_ASSET_FILE_SIZE_PERSONAL: 25 * 1024 * 1024,

  // 100 megabyte upload limit for organizations
  MAXIMUM_ASSET_FILE_SIZE_TEAM: 100 * 1024 * 1024,

  // 15 megabyte image upload limit
  MAXIMUM_IMAGE_FILE_SIZE: 15 * 1024 * 1024,

  // Maximum characters per sent message
  MAXIMUM_MESSAGE_LENGTH: 8000,

  // Maximum characters per received message
  // Encryption is approx. +40% of the original payload so let's round it at +50%
  MAXIMUM_MESSAGE_LENGTH_RECEIVING: 12000 * 1.5,

  // bigger requests will be split in chunks with a maximum size as defined
  MAXIMUM_USERS_PER_REQUEST: 200,

  // number of messages that will be pulled
  MESSAGES_FETCH_LIMIT: 30,

  MINIMUM_PASSWORD_LENGTH: 8,

  // measured in pixel
  SCROLL_TO_LAST_MESSAGE_THRESHOLD: 100,

  SUPPORT: {
    FORM: {
      BUG: 'new?ticket_form_id=101615',
      CONTACT: 'new',
    },
    ID: {
      CALLING: 202969412,
      CAMERA_ACCESS_DENIED: 202935412,
      DEVICE_ACCESS_DENIED: 213512545,
      DEVICE_NOT_FOUND: 202970662,
      HISTORY: 207834645,
      MICROPHONE_ACCESS_DENIED: 202590081,
      SCREEN_ACCESS_DENIED: 202935412,
    },
  },

  UNSPLASH_URL: 'https://source.unsplash.com/1200x1200/?landscape',

  URL: {
    ACCOUNT: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.ACCOUNT_BASE) || 'https://account.wire.com',
      STAGING: 'https://wire-account-staging.zinfra.io',
    },
    SUPPORT: 'https://support.wire.com',
    TEAM_SETTINGS: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.TEAMS_BASE) || 'https://teams.wire.com',
      STAGING: 'https://wire-admin-staging.zinfra.io',
    },
    WEBAPP: {
      INTERNAL: 'https://wire-webapp-staging.wire.com',
      PRODUCTION: window.wire.env.APP_BASE || 'https://app.wire.com',
      STAGING: 'https://wire-webapp-staging.zinfra.io',
    },
    WEBSITE: {
      PRODUCTION: (window.wire.env.URL && window.wire.env.URL.WEBSITE_BASE) || 'https://wire.com',
      STAGING: 'https://wire-website-staging.zinfra.io',
    },
  },

  URL_PATH: {
    CREATE_TEAM: '/create-team/',
    DECRYPT_ERROR_1: '/privacy/error-1/',
    DECRYPT_ERROR_2: '/privacy/error-2/',
    MANAGE_SERVICES: '/services/',
    MANAGE_TEAM: '/login/',
    PASSWORD_RESET: '/forgot/',
    PRIVACY_HOW: '/privacy/how/',
    PRIVACY_WHY: '/privacy/why/',
    SUPPORT_USERNAME: '/support/username/',
    TERMS_OF_USE: '/legal/terms/',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.BaseError = class BaseError extends Error {
  constructor(name, type, message) {
    super();

    this.name = this.constructor.name;
    this.stack = new Error().stack;

    const ErrorInstanceClass = z.error[name];
    const knownTypes = Object.assign({}, BaseError.TYPE, ErrorInstanceClass.TYPE);
    const isValidType = Object.values(knownTypes).includes(type);

    this.type = isValidType ? type : BaseError.TYPE.UNKNOWN;

    this.message = message || ErrorInstanceClass.MESSAGE[this.type] || BaseError.MESSAGE[this.type];
    if (!this.message) {
      this.message = `${BaseError.MESSAGE.UNKNOWN} ${name}`;
    }
  }

  static get MESSAGE() {
    return {
      INVALID_PARAMETER: 'Invalid parameter passed',
      MISSING_PARAMETER: 'Required parameter is not defined',
      UNKNOWN: 'Unknown',
    };
  }

  static get TYPE() {
    return {
      INVALID_PARAMETER: 'INVALID_PARAMETER',
      MISSING_PARAMETER: 'MISSING_PARAMETER',
      UNKNOWN: 'UNKNOWN',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AccessTokenError = class AccessTokenError extends z.error.BaseError {
  constructor(type, message) {
    super('AccessTokenError', type, message);
  }

  static get MESSAGE() {
    return {
      NOT_FOUND_IN_CACHE: 'No cached access token found in Local Storage',
      REQUEST_FAILED: 'Exceeded allowed number of retries to get Access Token',
      REQUEST_FORBIDDEN: 'Request to POST for access token failed',
      RETRIES_EXCEEDED: 'Request to POST for access token forbidden',
    };
  }

  static get TYPE() {
    return {
      NOT_FOUND_IN_CACHE: 'NOT_FOUND_IN_CACHE',
      REQUEST_FAILED: 'REQUEST_FAILED',
      REQUEST_FORBIDDEN: 'REQUEST_FORBIDDEN',
      RETRIES_EXCEEDED: 'RETRIES_EXCEEDED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AuthError = class AuthError extends z.error.BaseError {
  constructor(type, message) {
    super('AuthError', type, message);
  }

  static get MESSAGE() {
    return {
      COOKIES_DISABLED: 'Cookies are disabled',
      INDEXED_DB_UNSUPPORTED: 'IndexedDB is not supported',
      MULTIPLE_TABS: 'Cannot open in multiple tabs simultaneously',
      PRIVATE_MODE: 'Unsupported Private Mode',
    };
  }

  static get TYPE() {
    return {
      COOKIES_DISABLED: 'COOKIES_DISABLED',
      INDEXED_DB_UNSUPPORTED: 'INDEXED_DB_UNSUPPORTED',
      MULTIPLE_TABS: 'MULTIPLE_TABS',
      PRIVATE_MODE: 'PRIVATE_MODE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.AudioError = class AudioError extends z.error.BaseError {
  constructor(type, message) {
    super('AudioError', type, message);
  }

  static get MESSAGE() {
    return {
      ALREADY_PLAYING: 'Sound is already playing',
      FAILED_TO_PLAY: 'Failed to play sound',
      IGNORED_SOUND: 'Ignored request to play sound',
      NOT_FOUND: 'AudioElement or ID not found',
    };
  }

  static get TYPE() {
    return {
      ALREADY_PLAYING: 'ALREADY_PLAYING',
      FAILED_TO_PLAY: 'FAILED_TO_PLAY',
      IGNORED_SOUND: 'IGNORED_SOUND',
      NOT_FOUND: 'NOT_FOUND',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.BackendClientError = class BackendClientError extends z.error.BaseError {
  constructor(params) {
    const message = params.message || `${params}`;

    super('BackendClientError', BackendClientError.TYPE.GENERIC, message);

    if (_.isObject(params)) {
      this.code = params.code;
      this.label = params.label;
    } else if (_.isNumber(params)) {
      this.code = params;
    }
  }

  static get LABEL() {
    return {
      BAD_GATEWAY: 'bad-gateway',
      BAD_REQUEST: 'bad-request',
      BLACKLISTED_EMAIL: 'blacklisted-email',
      BLACKLISTED_PHONE: 'blacklisted-phone',
      CLIENT_ERROR: 'client-error',
      CONNECTIVITY_PROBLEM: 'connectivity-problem',
      INVALID_CREDENTIALS: 'invalid-credentials',
      INVALID_EMAIL: 'invalid-email',
      INVALID_INVITATION_CODE: 'invalid-invitation-code',
      INVALID_PHONE: 'invalid-phone',
      KEY_EXISTS: 'key-exists',
      MISSING_AUTH: 'missing-auth',
      MISSING_IDENTITY: 'missing-identity',
      NOT_CONNECTED: 'not-connected',
      NOT_FOUND: 'not-found',
      PASSWORD_EXISTS: 'password-exists',
      PENDING_ACTIVATION: 'pending-activation',
      PENDING_LOGIN: 'pending-login',
      PHONE_BUDGET_EXHAUSTED: 'phone-budget-exhausted',
      SERVER_ERROR: 'server-error',
      SERVICE_DISABLED: 'service-disabled',
      SUSPENDED: 'suspended',
      TOO_MANY_BOTS: 'too-many-bots',
      TOO_MANY_CLIENTS: 'too-many-clients',
      TOO_MANY_MEMBERS: 'too-many-members',
      UNAUTHORIZED: 'unauthorized',
      UNKNOWN_CLIENT: 'unknown-client',
    };
  }

  static get STATUS_CODE() {
    return {
      ACCEPTED: 202,
      BAD_GATEWAY: 502,
      BAD_REQUEST: 400,
      CONFLICT: 409,
      CONNECTIVITY_PROBLEM: 0,
      CREATED: 201,
      FORBIDDEN: 403,
      INTERNAL_SERVER_ERROR: 500,
      NO_CONTENT: 204,
      NOT_FOUND: 404,
      OK: 200,
      PRECONDITION_FAILED: 412,
      REQUEST_TIMEOUT: 408,
      REQUEST_TOO_LARGE: 413,
      TOO_MANY_REQUESTS: 429,
      UNAUTHORIZED: 401,
    };
  }

  static get TYPE() {
    return {
      GENERIC: 'GENERIC',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.CallError = class CallError extends z.error.BaseError {
  constructor(type, message) {
    super('CallError', type, message);
  }

  static get MESSAGE() {
    return {
      MISTARGETED_MESSAGE: 'Message targeted at another client',
      NO_CONVERSATION_ID: 'No conversation ID given',
      NO_DATA_CHANNEL: 'No established data channel for call',
      NO_REPLACEABLE_TRACK: 'No replaceable MediaStreamTrack found',
      NO_USER_ID: 'Missing user ID to target message',
      NOT_FOUND: 'No call for conversation ID found',
      NOT_SUPPORTED: 'Calling is not supported',
      RTP_SENDER_NOT_SUPPORTED: 'PeerConnection does not support RtcRtpSender extension',
      UNSUPPORTED_VERSION: 'Unsupported version of the call protocol',
      WRONG_CONVERSATION_TYPE: 'Wrong conversation type for call message',
      WRONG_PAYLOAD_FORMAT: 'Payload for a call message is in wrong format',
      WRONG_SENDER: 'Call change from wrong sender',
      WRONG_STATE: 'Call in wrong state for change',
    };
  }

  static get TYPE() {
    return {
      MISTARGETED_MESSAGE: 'MISTARGETED_MESSAGE',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_DATA_CHANNEL: 'NO_DATA_CHANNEL',
      NO_REPLACEABLE_TRACK: 'NO_REPLACEABLE_TRACK',
      NO_USER_ID: 'NO_USER_ID',
      NOT_FOUND: 'NOT_FOUND',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      RTP_SENDER_NOT_SUPPORTED: 'RTP_SENDER_NOT_SUPPORTED',
      UNSUPPORTED_VERSION: 'UNSUPPORTED_VERSION',
      WRONG_CONVERSATION_TYPE: 'WRONG_CONVERSATION_TYPE',
      WRONG_PAYLOAD_FORMAT: 'WRONG_PAYLOAD_FORMAT',
      WRONG_SENDER: 'WRONG_SENDER',
      WRONG_STATE: 'WRONG_STATE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ClientError = class ClientError extends z.error.BaseError {
  constructor(type, message) {
    super('ClientError', type, message);
  }

  static get MESSAGE() {
    return {
      CLIENT_NOT_SET: 'Local client is not yet set',
      DATABASE_FAILURE: 'Client related database transaction failed',
      NO_CLIENT_ID: 'Client ID is not defined',
      NO_USER_ID: 'User ID is not defined',
      NO_VALID_CLIENT: 'No valid local client found',
      REQUEST_FAILURE: 'Client related backend request failed',
      REQUEST_FORBIDDEN: 'Client related backend request forbidden',
      TOO_MANY_CLIENTS: 'User has reached the maximum of allowed clients',
    };
  }

  static get TYPE() {
    return {
      CLIENT_NOT_SET: 'CLIENT_NOT_SET',
      DATABASE_FAILURE: 'DATABASE_FAILURE',
      NO_CLIENT_ID: 'NO_CLIENT_ID',
      NO_USER_ID: 'NO_USER_ID',
      NO_VALID_CLIENT: 'NO_VALID_CLIENT',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      REQUEST_FORBIDDEN: 'REQUEST_FORBIDDEN',
      TOO_MANY_CLIENTS: 'TOO_MANY_CLIENTS',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConnectError = class ConnectError extends z.error.BaseError {
  constructor(type, message) {
    super('ConnectError', type, message);
  }

  static get MESSAGE() {
    return {
      NO_CONTACTS: 'No contacts found for matching',
      NOT_SUPPORTED: 'Source not supported',
      UPLOAD: 'Address book upload failed',
    };
  }

  static get TYPE() {
    return {
      NO_CONTACTS: 'NO_CONTACTS',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      UPLOAD: 'UPLOAD',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConnectionError = class ConnectionError extends z.error.BaseError {
  constructor(type, message) {
    super('ConnectionError', type, message);
  }

  static get MESSAGE() {
    return {};
  }

  static get TYPE() {
    return {};
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.ConversationError = class ConversationError extends z.error.BaseError {
  constructor(type, message) {
    super('ConversationError', type, message);
  }

  static get MESSAGE() {
    return {
      CONVERSATION_NOT_FOUND: 'Conversation not found',
      DEGRADED_CONVERSATION_CANCELLATION: 'Sending to degraded conversation was canceled by user',
      MESSAGE_NOT_FOUND: 'Message not found in conversation',
      NO_CHANGES: 'Missing changes to message',
      NO_CONVERSATION_ID: 'Conversation ID is not defined',
      NO_MESSAGE_CHANGES: 'Edited message equals original message',
      REQUEST_FAILURE: 'Conversation related backend request failed',
      WRONG_CHANGE: 'Attempted unsupported change on conversation',
      WRONG_CONVERSATION: 'Message was sent in the wrong conversation',
      WRONG_TYPE: 'Wrong message to for action',
      WRONG_USER: 'Wrong user tried to change or delete a message',
    };
  }

  static get TYPE() {
    return {
      CONVERSATION_NOT_FOUND: 'CONVERSATION_NOT_FOUND',
      DEGRADED_CONVERSATION_CANCELLATION: 'DEGRADED_CONVERSATION_CANCELLATION',
      MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',
      NO_CHANGES: 'NO_CHANGES',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_MESSAGE_CHANGES: 'NO_MESSAGE_CHANGES',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      WRONG_CHANGE: 'WRONG_CHANGE',
      WRONG_CONVERSATION: 'WRONG_CONVERSATION',
      WRONG_TYPE: 'WRONG_TYPE',
      WRONG_USER: 'WRONG_USER',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.CryptographyError = class CryptographyError extends z.error.BaseError {
  constructor(type, message) {
    super('CryptographyError', type, message);
  }

  static get MESSAGE() {
    return {
      BROKEN_EXTERNAL: 'Failed to map external message',
      IGNORED_ASSET: 'Ignored asset preview',
      IGNORED_PREVIEW: 'Ignored image preview',
      NO_DATA_CONTENT: 'No message data content found',
      NO_GENERIC_MESSAGE: 'No GenericMessage found',
      PREVIOUSLY_STORED: 'Message was previously stored',
      UNHANDLED_TYPE: 'Unhandled event type',
    };
  }

  static get TYPE() {
    return {
      BROKEN_EXTERNAL: 'BROKEN_EXTERNAL',
      IGNORED_ASSET: 'IGNORED_ASSET',
      IGNORED_PREVIEW: 'IGNORED_PREVIEW',
      NO_DATA_CONTENT: 'NO_DATA_CONTENT',
      NO_GENERIC_MESSAGE: 'NO_GENERIC_MESSAGE',
      PREVIOUSLY_STORED: 'PREVIOUSLY_STORED',
      UNHANDLED_TYPE: 'UNHANDLED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.EventError = class EventError extends z.error.BaseError {
  constructor(type, message) {
    super('EventError', type, message);
  }

  static get MESSAGE() {
    return {
      DATABASE_FAILURE: 'Event related database transaction failure',
      DEPRECATED_SCHEMA: 'Event type is deprecated',
      NO_CLIENT_ID: 'Missing client id',
      NO_EVENT: 'Event is missing',
      NO_LAST_DATE: 'Last event date not found in storage',
      NO_LAST_ID: 'Last notification ID not found in storage',
      NO_NOTIFICATIONS: 'No notifications found',
      OUTDATED_E_CALL_EVENT: 'Ignoring outdated e-call event',
      REQUEST_FAILURE: 'Event related backend request failure',
      VALIDATION_FAILED: 'Event failed validation',
    };
  }

  static get TYPE() {
    return {
      DATABASE_FAILURE: 'DATABASE_FAILURE',
      DEPRECATED_SCHEMA: 'DEPRECATED_SCHEMA',
      NO_CLIENT_ID: 'NO_CLIENT_ID',
      NO_EVENT: 'NO_EVENT',
      NO_LAST_DATE: 'NO_LAST_DATE',
      NO_LAST_ID: 'NO_LAST_ID',
      NO_NOTIFICATIONS: 'NO_NOTIFICATIONS',
      OUTDATED_E_CALL_EVENT: 'EventError.OUTDATED_E_CALL_EVENT',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      VALIDATION_FAILED: 'VALIDATION_FAILED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.LinkPreviewError = class LinkPreviewError extends z.error.BaseError {
  constructor(type, message) {
    super('LinkPreviewError', type, message);
  }

  static get MESSAGE() {
    return {
      BLACKLISTED: 'Skipped preview for blacklisted link',
      NO_DATA_AVAILABLE: 'Link does not provide Open Graph data.',
      NOT_SUPPORTED: 'Your client cannot render link previews using Open Graph data.',
      UNSUPPORTED_TYPE: 'Open Graph data from the given link does not provide necessary attributes.',
    };
  }

  static get TYPE() {
    return {
      BLACKLISTED: 'BLACKLISTED',
      NO_DATA_AVAILABLE: 'NO_DATA_AVAILABLE',
      NOT_SUPPORTED: 'NOT_SUPPORTED',
      UNSUPPORTED_TYPE: 'UNSUPPORTED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.LocationError = class LocationError extends z.error.BaseError {
  constructor(type, message) {
    super('LocationError', type, message);
  }

  static get MESSAGE() {
    return {
      REQUEST_FAILED: 'Location related request failed',
    };
  }

  static get TYPE() {
    return {
      REQUEST_FAILED: 'REQUEST_FAILED',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.MediaError = class MediaError extends z.error.BaseError {
  constructor(type, mediaType, message) {
    super('MediaError', type, message);

    this.mediaType = mediaType;
  }

  static get MESSAGE() {
    return {
      MEDIA_STREAM_DEVICE: 'Device related failure when getting MediaStream',
      MEDIA_STREAM_MISC: 'Other failure when getting MediaStream',
      MEDIA_STREAM_PERMISSION: 'Permission related failure when getting MediaStream',
      NO_MEDIA_DEVICES_FOUND: 'No MediaDevices found',
      SCREEN_NOT_SUPPORTED: 'Screen sharing is not yet supported by this browser',
      STREAM_NOT_FOUND: 'No local MediaStream found',
      UNHANDLED_MEDIA_TYPE: 'Media type unknown',
    };
  }

  static get TYPE() {
    return {
      MEDIA_STREAM_DEVICE: 'MEDIA_STREAM_DEVICE',
      MEDIA_STREAM_MISC: 'MEDIA_STREAM_MISC',
      MEDIA_STREAM_PERMISSION: 'MEDIA_STREAM_PERMISSION',
      NO_MEDIA_DEVICES_FOUND: 'NO_MEDIA_DEVICES_FOUND',
      SCREEN_NOT_SUPPORTED: 'SCREEN_NOT_SUPPORTED',
      STREAM_NOT_FOUND: 'STREAM_NOT_FOUND',
      UNHANDLED_MEDIA_TYPE: 'MediaError.UNHANDLED_MEDIA_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.NotificationError = class NotificationError extends z.error.BaseError {
  constructor(type, message) {
    super('NotificationError', type, message);
  }

  static get MESSAGE() {
    return {
      HIDE_NOTIFICATION: 'Do not show notification for this message',
    };
  }

  static get TYPE() {
    return {
      HIDE_NOTIFICATION: 'HIDE_NOTIFICATION',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.PermissionError = class PermissionError extends z.error.BaseError {
  constructor(type, message) {
    super('PermissionError', type, message);
  }

  static get MESSAGE() {
    return {
      DENIED: 'Permission was denied',
      UNSUPPORTED: 'Permissions API is not supported',
      UNSUPPORTED_TYPE: 'Permissions API does not support requested type',
    };
  }

  static get TYPE() {
    return {
      DENIED: 'DENIED',
      UNSUPPORTED: 'UNSUPPORTED',
      UNSUPPORTED_TYPE: 'UNSUPPORTED_TYPE',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.StorageError = class StorageError extends z.error.BaseError {
  constructor(type, message) {
    super('StorageError', type, message);
  }

  static get MESSAGE() {
    return {
      DATA_STORE_NOT_FOUND: 'Data store not found',
      FAILED_TO_OPEN: 'Failed to open database',
      INVALID_TIME: 'Event time needs to be ISO 8601',
      INVALID_TIMESTAMP: 'Invalid timestamp',
      NO_CONVERSATION_ID: 'Missing conversation ID',
      NO_DATA: 'Storage value is undefined or null',
      NO_SENDER_ID: 'Missing sender ID',
      NO_TIME: 'Missing time',
      NON_SEQUENTIAL_UPDATE: 'Update is non sequential',
      NOT_FOUND: 'Record matching primary key was not found',
    };
  }

  static get TYPE() {
    return {
      DATA_STORE_NOT_FOUND: 'DATA_STORE_NOT_FOUND',
      FAILED_TO_OPEN: 'FAILED_TO_OPEN',
      INVALID_TIME: 'INVALID_TIME',
      INVALID_TIMESTAMP: 'INVALID_TIMESTAMP',
      NO_CONVERSATION_ID: 'NO_CONVERSATION_ID',
      NO_DATA: 'NO_DATA',
      NO_SENDER_ID: 'NO_SENDER_ID',
      NO_TIME: 'NO_TIME',
      NON_SEQUENTIAL_UPDATE: 'NON_SEQUENTIAL_UPDATE',
      NOT_FOUND: 'NOT_FOUND',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.TeamError = class TeamError extends z.error.BaseError {
  constructor(type, message) {
    super('TeamError', type, message);
  }

  static get MESSAGE() {
    return {
      NO_PERMISSIONS: 'No permissions provided',
    };
  }

  static get TYPE() {
    return {
      NO_PERMISSIONS: 'NO_PERMISSIONS',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.error = z.error || {};

z.error.UserError = class UserError extends z.error.BaseError {
  constructor(type, message) {
    super('UserError', type, message);
  }

  static get MESSAGE() {
    return {
      INVALID_UPDATE: 'False input data for requested update',
      PRE_KEY_NOT_FOUND: 'Pre-key not found',
      REQUEST_FAILURE: 'User related backend request failure',
      USER_MISSING_EMAIL: 'Self user has not set email address',
      USER_NOT_FOUND: 'User not found',
      USERNAME_TAKEN: 'Username is already taken',
    };
  }

  static get TYPE() {
    return {
      INVALID_UPDATE: 'INVALID_UPDATE',
      PRE_KEY_NOT_FOUND: 'PRE_KEY_NOT_FOUND',
      REQUEST_FAILURE: 'REQUEST_FAILURE',
      USER_MISSING_EMAIL: 'USER_MISSING_EMAIL',
      USER_NOT_FOUND: 'USER_NOT_FOUND',
      USERNAME_TAKEN: 'USERNAME_TAKEN',
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

window.z.audio.AudioRepository = class AudioRepository {
  constructor() {
    this.logger = new z.util.Logger('z.audio.AudioRepository', z.config.LOGGER.OPTIONS);
    this.audioElements = {};
    this.currentlyLooping = {};
    this.audioPreference = ko.observable(z.audio.AudioPreference.ALL);
    this.audioPreference.subscribe(audioPreference => {
      if (audioPreference === z.audio.AudioPreference.NONE) {
        this._stopAll();
      }
    });
    this.muted = true;
    this._subscribeToEvents();
  }

  /**
   * Check if sound should be played with current setting.
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {Promise} Resolves if the sound should be played.
   */
  _checkSoundSetting(audioId) {
    if (this.muted && !z.audio.AudioPlayingType.MUTED.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    const preferenceIsNone = this.audioPreference() === z.audio.AudioPreference.NONE;
    if (preferenceIsNone && !z.audio.AudioPlayingType.NONE.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    const preferenceIsSome = this.audioPreference() === z.audio.AudioPreference.SOME;
    if (preferenceIsSome && !z.audio.AudioPlayingType.SOME.includes(audioId)) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.IGNORED_SOUND));
    }

    return Promise.resolve();
  }

  /**
   * Create HTMLAudioElement.
   * @private
   * @param {string} sourcePath - Source for HTMLAudioElement
   * @returns {HTMLAudioElement} Returns the audio element.
   */
  _createAudioElement(sourcePath) {
    const audioElement = new Audio();
    audioElement.preload = 'none';
    audioElement.src = sourcePath;
    return audioElement;
  }

  /**
   * Get the sound object
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {Promise} Resolves with the HTMLAudioElement.
   */
  _getSoundById(audioId) {
    if (this.audioElements[audioId]) {
      return Promise.resolve(this.audioElements[audioId]);
    }
    return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.NOT_FOUND));
  }

  /**
   * Initialize all sounds.
   * @private
   * @returns {undefined}
   */
  _initSounds() {
    Object.values(z.audio.AudioType).forEach(audioId => {
      this.audioElements[audioId] = this._createAudioElement(`/audio/${audioId}.mp3`);
    });

    this.logger.info('Initialized sounds');
  }

  /**
   * Start playback of a sound.
   * @private
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @param {HTMLAudioElement} audioElement - AudioElement to play
   * @param {boolean} playInLoop - Play sound in loop
   * @returns {Promise} Resolves with the HTMLAudioElement
   */
  _play(audioId, audioElement, playInLoop = false) {
    if (!audioId || !audioElement) {
      return Promise.reject(new z.error.AudioError(z.error.AudioError.TYPE.NOT_FOUND));
    }

    return new Promise((resolve, reject) => {
      if (audioElement.paused) {
        audioElement.loop = playInLoop;

        if (audioElement.currentTime !== 0) {
          audioElement.currentTime = 0;
        }

        const _playSuccess = () => {
          if (playInLoop) {
            this.currentlyLooping[audioId] = audioId;
          }
          resolve(audioElement);
        };

        const playPromise = audioElement.play();

        if (playPromise) {
          return playPromise
            .then(_playSuccess)
            .catch(() => reject(new z.error.AudioError(z.error.AudioError.TYPE.FAILED_TO_PLAY)));
        }

        _playSuccess();
      } else {
        reject(new z.error.AudioError(z.error.AudioError.TYPE.ALREADY_PLAYING));
      }
    });
  }

  /**
   * Preload all sounds for immediate playback.
   * @private
   * @returns {undefined}
   */
  _preLoad() {
    Object.values(this.audioElements).forEach(audioElement => {
      audioElement.preload = 'auto';
      audioElement.load();
    });

    this.logger.info('Pre-loading audio files for immediate playback');
  }

  /**
   * Stop all sounds playing in loop.
   * @private
   * @returns {undefined}
   */
  _stopAll() {
    Object.keys(this.currentlyLooping).forEach(audioId => this.stop(audioId));
  }

  /**
   * Use Amplify to subscribe to all audio playback related events.
   * @private
   * @returns {undefined}
   */
  _subscribeToAudioEvents() {
    amplify.subscribe(z.event.WebApp.AUDIO.PLAY, this.play.bind(this));
    amplify.subscribe(z.event.WebApp.AUDIO.PLAY_IN_LOOP, this.loop.bind(this));
    amplify.subscribe(z.event.WebApp.AUDIO.STOP, this.stop.bind(this));
  }

  /**
   * Use Amplify to subscribe to required events.
   * @private
   * @returns {undefined}
   */
  _subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setMutedState.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updatedProperties.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.SOUND_ALERTS, this.setAudioPreference.bind(this));
  }

  /**
   * Initialize the repository.
   * @param {boolean} preLoad - Should sounds be pre-loaded with false as default
   * @returns {undefined}
   */
  init(preLoad = false) {
    this._initSounds();
    this._subscribeToAudioEvents();
    if (preLoad) {
      this._preLoad();
    }
  }

  /**
   * Start playback of a sound in a loop.
   * @note Prevent playing multiples instances of looping sounds
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {undefined}
   */
  loop(audioId) {
    this.play(audioId, true);
  }

  /**
   * Start playback of a sound.
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @param {boolean} playInLoop - Play sound in loop
   * @returns {undefined}
   */
  play(audioId, playInLoop = false) {
    this._checkSoundSetting(audioId)
      .then(() => this._getSoundById(audioId))
      .then(audioElement => this._play(audioId, audioElement, playInLoop))
      .then(audioElement => this.logger.info(`Playing sound '${audioId}' (loop: '${playInLoop}')`, audioElement))
      .catch(error => {
        if (!(error instanceof z.error.AudioError)) {
          this.logger.error(`Failed playing sound '${audioId}': ${error.message}`);
          throw error;
        }
      });
  }

  setAudioPreference(audioPreference) {
    this.audioPreference(audioPreference);
  }

  setMutedState(handlingNotifications) {
    const updatedMutedState = handlingNotifications !== z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.muted !== updatedMutedState;
    if (isStateChange) {
      this.muted = updatedMutedState;
      this.logger.debug(`Set muted state to '${this.muted}'`);
    }
  }

  /**
   * Stop playback of a sound.
   * @param {z.audio.AudioType} audioId - Sound identifier
   * @returns {undefined}
   */
  stop(audioId) {
    this._getSoundById(audioId)
      .then(audioElement => {
        if (!audioElement.paused) {
          this.logger.info(`Stopping sound '${audioId}'`, audioElement);
          audioElement.pause();
        }

        if (this.currentlyLooping[audioId]) {
          delete this.currentlyLooping[audioId];
        }
      })
      .catch(error => {
        this.logger.error(`Failed stopping sound '${audioId}': ${error.message}`);
        throw error;
      });
  }

  updatedProperties(properties) {
    this.setAudioPreference(properties.settings.sound.alerts);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioPreference = {
  ALL: 'all',
  NONE: 'none',
  SOME: 'some',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioType = {
  ALERT: 'alert',
  CALL_DROP: 'call_drop',
  INCOMING_CALL: 'ringing_from_them',
  INCOMING_PING: 'ping_from_them',
  NETWORK_INTERRUPTION: 'nw_interruption',
  NEW_MESSAGE: 'new_message',
  OUTGOING_CALL: 'ringing_from_me',
  OUTGOING_PING: 'ping_from_me',
  READY_TO_TALK: 'ready_to_talk',
  TALK_LATER: 'talk_later',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.audio = z.audio || {};

z.audio.AudioPlayingType = {
  MUTED: [z.audio.AudioType.CALL_DROP, z.audio.AudioType.NETWORK_INTERRUPTION],
  NONE: [
    z.audio.AudioType.CALL_DROP,
    z.audio.AudioType.NETWORK_INTERRUPTION,
    z.audio.AudioType.OUTGOING_CALL,
    z.audio.AudioType.READY_TO_TALK,
    z.audio.AudioType.TALK_LATER,
  ],
  SOME: [
    z.audio.AudioType.CALL_DROP,
    z.audio.AudioType.INCOMING_CALL,
    z.audio.AudioType.INCOMING_PING,
    z.audio.AudioType.NETWORK_INTERRUPTION,
    z.audio.AudioType.OUTGOING_CALL,
    z.audio.AudioType.OUTGOING_PING,
    z.audio.AudioType.READY_TO_TALK,
    z.audio.AudioType.TALK_LATER,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.AuthService = class AuthService {
  static get CONFIG() {
    return {
      POST_ACCESS_RETRY: {
        LIMIT: 10,
        TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.5,
      },
      URL_ACCESS: '/access',
      URL_COOKIES: '/cookies',
      URL_LOGIN: '/login',
    };
  }

  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.auth.AuthService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Get all cookies for a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//getCookies
   * @returns {Promise} Promise that resolves with an array of cookies.
   */
  getCookies() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: AuthService.CONFIG.URL_COOKIES,
    });
  }

  /**
   * Get access token if a valid cookie is provided.
   *
   * @example Access token data we expect:
   *  access_token: Lt-IRHxkY9JLA5UuBR3Exxj5lCUf... - Token
   *  expires_in: 900 - Expiration in seconds
   *  token_type: Bearer - Token type
   *  user: 4363e274-69c9-... - User ID
   *
   * @note Don't use our client wrapper here, because to query "/access" we need to set "withCredentials" to "true" in order to send the cookie.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//newAccessToken
   * @param {number} retryAttempt - Retry attempts when a request fails
   * @returns {Promise} Promise which resolves with access token data (token_type, etc.).
   */
  postAccess(retryAttempt = 1) {
    return new Promise((resolve, reject) => {
      const ajaxConfig = {
        crossDomain: true,
        type: 'POST',
        url: this.backendClient.createUrl(AuthService.CONFIG.URL_ACCESS),
        xhrFields: {
          withCredentials: true,
        },
      };

      if (this.backendClient.accessToken) {
        const {accessToken, accessTokenType} = this.backendClient;
        ajaxConfig.headers = {
          Authorization: `${accessTokenType} ${window.decodeURIComponent(accessToken)}`,
        };
      }

      ajaxConfig.success = accessTokenResponse => {
        const {access_token: accessToken, token_type: accessTokenType} = accessTokenResponse;
        this.backendClient.clearQueueUnblockTimeout();
        this.saveAccessTokenInClient(accessTokenType, accessToken);
        resolve(accessTokenResponse);
      };

      ajaxConfig.error = (jqXHR, textStatus, errorThrown) => {
        const isRequestForbidden = jqXHR.status === z.error.BackendClientError.STATUS_CODE.FORBIDDEN;
        if (isRequestForbidden) {
          this.logger.warn(`Request for access token forbidden (Attempt '${retryAttempt}'): ${errorThrown}`, jqXHR);
          return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN));
        }

        const exceededRetries = retryAttempt > AuthService.CONFIG.POST_ACCESS_RETRY.LIMIT;
        if (exceededRetries) {
          this.saveAccessTokenInClient();
          this.logger.warn(`Exceeded limit of attempts to refresh access token': ${errorThrown}`, jqXHR);
          return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.RETRIES_EXCEEDED));
        }

        retryAttempt++;

        const _retry = () => {
          return this.postAccess(retryAttempt)
            .then(resolve)
            .catch(reject);
        };

        const isConnectivityProblem = jqXHR.status === z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM;
        if (isConnectivityProblem) {
          this.logger.warn('Delaying request for access token due to suspected connectivity issue');
          this.backendClient.clearQueueUnblockTimeout();

          return this.backendClient
            .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_REFRESH)
            .then(() => {
              this.logger.info('Continuing to request access token after verifying connectivity');
              this.backendClient.queueState(z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH);
              this.backendClient.scheduleQueueUnblock();
              return _retry();
            });
        }

        return window.setTimeout(() => {
          this.logger.info(`Trying to request a new access token (Attempt '${retryAttempt}')`);
          return _retry();
        }, AuthService.CONFIG.POST_ACCESS_RETRY.TIMEOUT);
      };

      $.ajax(ajaxConfig);
    });
  }

  /**
   * Delete cookies on backend.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//rmCookies
   *
   * @param {string} email - Email address of user
   * @param {string} password - Password of user
   * @param {string[]} [labels] - A list of cookie labels to remove from the system (optional)
   * @returns {jQuery.jqXHR} A superset of the XMLHTTPRequest object.
   */
  postCookiesRemove(email, password, labels) {
    return this.backendClient.sendJson({
      data: {
        email: email,
        labels: labels,
        password: password,
      },
      type: 'POST',
      url: `${AuthService.CONFIG.URL_COOKIES}/remove`,
    });
  }

  /**
   * Login in order to obtain an access-token and cookie.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//login
   *
   * @param {Object} login - Containing sign in information
   * @param {string} login.email - The email address for a password login
   * @param {string} login.phone - The phone number for a password or SMS login
   * @param {string} login.password - The password for a password login
   * @param {string} login.code - The login code for an SMS login
   * @param {boolean} persist - Request a persistent cookie instead of a session cookie
   * @returns {Promise} Promise that resolves with access token
   */
  postLogin(login, persist) {
    const persistParam = window.encodeURIComponent(persist.toString());
    return new Promise((resolve, reject) => {
      $.ajax({
        contentType: 'application/json; charset=utf-8',
        crossDomain: true,
        data: pako.gzip(JSON.stringify(login)),
        headers: {
          'Content-Encoding': 'gzip',
        },
        processData: false,
        type: 'POST',
        url: this.backendClient.createUrl(`${AuthService.CONFIG.URL_LOGIN}?persist=${persistParam}`),
        xhrFields: {
          withCredentials: true,
        },
      })
        .done(resolve)
        .fail((jqXHR, textStatus, errorThrown) => reject(jqXHR.responseJSON || errorThrown));
    });
  }

  /**
   * A login code can be used only once and times out after 10 minutes.
   *
   * @note Only one login code may be pending at a time.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//sendLoginCode
   *
   * @param {Object} requestCode - Containing the phone number in E.164 format and whether a code should be forced
   * @returns {Promise} Promise that resolves on successful login code request
   */
  postLoginSend(requestCode) {
    return this.backendClient.sendJson({
      data: requestCode,
      type: 'POST',
      url: `${AuthService.CONFIG.URL_LOGIN}/send`,
    });
  }

  /**
   * Logout on the backend side.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/auth/logout
   * @returns {jQuery.jqXHR} A superset of the XMLHTTPRequest object.
   */
  postLogout() {
    return this.backendClient.sendRequest({
      type: 'POST',
      url: `${AuthService.CONFIG.URL_ACCESS}/logout`,
      withCredentials: true,
    });
  }

  /**
   * Save the access token date in the client.
   *
   * @param {string} tokenType - Access token type
   * @param {string} token - Access token
   * @returns {undefined}
   */
  saveAccessTokenInClient(tokenType = '', token = '') {
    this.backendClient.accessTokenType = tokenType;
    this.backendClient.accessToken = token;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.AuthRepository = class AuthRepository {
  static get CONFIG() {
    return {
      REFRESH_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  static get ACCESS_TOKEN_TRIGGER() {
    return {
      IMMEDIATE: 'AuthRepository.ACCESS_TOKEN_TRIGGER.IMMEDIATE',
      SCHEDULED: 'AuthRepository.ACCESS_TOKEN_TRIGGER.SCHEDULED',
      TEAMS_REGISTRATION: 'AuthRepository.ACCESS_TOKEN_TRIGGER.TEAMS_REGISTRATION',
      UNAUTHORIZED_REQUEST: 'AuthRepository.ACCESS_TOKEN_TRIGGER.UNAUTHORIZED_REQUEST',
      WEB_SOCKET: 'AuthRepository.ACCESS_TOKEN_TRIGGER.WEB_SOCKET',
    };
  }

  /**
   * Construct a new AuthService
   * @param {z.auth.AuthService} authService - Service for authentication interactions with the backend
   */
  constructor(authService) {
    this.accessTokenRefresh = undefined;
    this.authService = authService;
    this.logger = new z.util.Logger('z.auth.AuthRepository', z.config.LOGGER.OPTIONS);

    this.queueState = this.authService.backendClient.queueState;

    amplify.subscribe(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW, this.renewAccessToken.bind(this));
  }

  /**
   * Print all cookies for a user in the console.
   * @returns {undefined} No return value
   */
  listCookies() {
    this.authService
      .getCookies()
      .then(({cookies}) => {
        this.logger.force_log('Backend cookies:');
        cookies.forEach((cookie, index) => {
          const expirationDate = z.util.TimeUtil.formatTimestamp(cookie.time, false);
          const log = `Label: ${cookie.label} | Type: ${cookie.type} |  Expiration: ${expirationDate}`;
          this.logger.force_log(`Cookie No. ${index + 1} | ${log}`);
        });
      })
      .catch(error => this.logger.force_log('Could not list user cookies', error));
  }

  /**
   * Login (with email or phone) in order to obtain an access-token and cookie.
   *
   * @param {Object} login - Containing sign in information
   * @param {string} login.email - Email address for a password login
   * @param {string} login.phone - Phone number for a password or SMS login
   * @param {string} login.password - Password for a password login
   * @param {string} login.code - Login code for an SMS login
   * @param {boolean} persist - Request a persistent cookie instead of a session cookie
   * @returns {Promise} Promise that resolves with the received access token
   */
  login(login, persist) {
    return this.authService.postLogin(login, persist).then(accessTokenResponse => {
      this.saveAccessToken(accessTokenResponse);
      z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.PERSIST, persist);
      z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.SHOW_LOGIN, true);
      return accessTokenResponse;
    });
  }

  /**
   * Logout the user on the backend.
   * @returns {Promise} Will always resolve
   */
  logout() {
    return this.authService
      .postLogout()
      .then(() => this.logger.info('Log out on backend successful'))
      .catch(error => this.logger.warn(`Log out on backend failed: ${error.message}`, error));
  }

  /**
   * Request SMS validation code.
   * @param {Object} requestCode - Containing the phone number in E.164 format and whether a code should be forced
   * @returns {Promise} Resolves on success
   */
  requestLoginCode(requestCode) {
    return this.authService.postLoginSend(requestCode);
  }

  /**
   * Renew access-token provided a valid cookie.
   * @param {AuthRepository.ACCESS_TOKEN_TRIGGER} renewalTrigger - Trigger for access token renewal
   * @returns {undefined} No return value
   */
  renewAccessToken(renewalTrigger) {
    const isRefreshingToken = this.queueState() === z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH;

    if (!isRefreshingToken) {
      this.queueState(z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH);
      this.authService.backendClient.scheduleQueueUnblock();
      this.logger.info(`Access token renewal started. Source: ${renewalTrigger}`);

      this.getAccessToken()
        .then(() => {
          this.authService.backendClient.executeRequestQueue();
          amplify.publish(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEWED);
        })
        .catch(error => {
          const {message, type} = error;
          const isRequestForbidden = type === z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN;
          if (isRequestForbidden || z.util.Environment.frontend.isLocalhost()) {
            this.logger.warn(`Session expired on access token refresh: ${message}`, error);
            Raygun.send(error);
            return amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.SESSION_EXPIRED, false);
          }

          this.queueState(z.service.QUEUE_STATE.READY);
          this.logger.error(`Refreshing access token failed: '${type}'`, error);
          amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        });
    }
  }

  /**
   * Deletes all access token data stored on the client.
   * @returns {undefined} No return value
   */
  deleteAccessToken() {
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL);
    z.util.StorageUtil.resetValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE);
  }

  /**
   * Get the cached access token from the Amplify store.
   * @returns {Promise} Resolves when the access token was retrieved
   */
  getCachedAccessToken() {
    return new Promise((resolve, reject) => {
      const accessToken = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE);
      const accessTokenType = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE);

      if (accessToken) {
        this.logger.info('Cached access token found in Local Storage', {accessToken});
        this.authService.saveAccessTokenInClient(accessTokenType, accessToken);
        this._scheduleTokenRefresh(z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION));
        return resolve();
      }

      return reject(new z.error.AccessTokenError(z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE));
    });
  }

  /**
   * Initially get access-token provided a valid cookie.
   * @returns {Promise} Resolves with the access token data
   */
  getAccessToken() {
    return this.authService.postAccess().then(accessToken => this.saveAccessToken(accessToken));
  }

  /**
   * Store the access token using Amplify.
   *
   * @param {Object} accessTokenResponse - Access token data structure
   * @param {string} accessTokenResponse.access_token - Access token
   * @param {string} accessTokenResponse.expires_in - Expiration of access token in seconds
   * @param {string} accessTokenResponse.token_type - Type of access token
   * @returns {Object} Access token data
   */
  saveAccessToken(accessTokenResponse) {
    const {access_token: accessToken, expires_in: expiresIn, token_type: accessTokenType} = accessTokenResponse;
    const expiresInMillis = expiresIn * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    const expirationTimestamp = Date.now() + expiresInMillis;

    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE, accessToken, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION, expirationTimestamp, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL, expiresInMillis, expiresIn);
    z.util.StorageUtil.setValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE, accessTokenType, expiresIn);

    this.authService.saveAccessTokenInClient(accessTokenType, accessToken);

    this._logAccessTokenUpdate(accessTokenResponse, expirationTimestamp);
    this._scheduleTokenRefresh(expirationTimestamp);
    return accessTokenResponse;
  }

  /**
   * Logs the update of the access token.
   *
   * @private
   * @param {Object} accessTokenResponse - Access token data structure
   * @param {number} expirationTimestamp - Timestamp when access token expires
   * @returns {undefined}
   */
  _logAccessTokenUpdate(accessTokenResponse, expirationTimestamp) {
    const expirationDate = z.util.TimeUtil.formatTimestamp(expirationTimestamp, false);
    this.logger.info(`Saved updated access token. It will expire on: ${expirationDate}`, accessTokenResponse);
  }

  /**
   * Refreshes the access token in time before it expires.
   *
   * @private
   * @note Access token will be refreshed 1 minute (60000ms) before it expires
   * @param {number} expirationTimestamp - The expiration date (and time) as timestamp
   * @returns {undefined} No undefined value
   */
  _scheduleTokenRefresh(expirationTimestamp) {
    if (this.accessTokenRefresh) {
      window.clearTimeout(this.accessTokenRefresh);
    }
    const callbackTimestamp = expirationTimestamp - AuthRepository.CONFIG.REFRESH_THRESHOLD;

    if (callbackTimestamp < Date.now()) {
      return this.renewAccessToken(AuthRepository.ACCESS_TOKEN_TRIGGER.IMMEDIATE);
    }
    const refreshDate = z.util.TimeUtil.formatTimestamp(callbackTimestamp, false);
    this.logger.info(`Scheduling next access token refresh for '${refreshDate}'`);

    this.accessTokenRefresh = window.setTimeout(() => {
      if (callbackTimestamp > Date.now() + 15000) {
        this.logger.info(`Access token refresh scheduled for '${refreshDate}' skipped because it was executed late`);
      }

      if (navigator.onLine) {
        return this.renewAccessToken(`Schedule for '${refreshDate}'`);
      }

      this.logger.info(`Access token refresh scheduled for '${refreshDate}' skipped because we are offline`);
    }, callbackTimestamp - Date.now());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.SIGN_OUT_REASON = {
  ACCOUNT_DELETED: 'deleted',
  APP_INIT: 'app_init',
  CLIENT_REMOVED: 'client_removed',
  INDEXED_DB: 'indexedDb',
  MULTIPLE_TABS: 'multiple_tabs',
  NOT_SIGNED_IN: 'not_signed_in',
  SESSION_EXPIRED: 'expired',
  USER_REQUESTED: 'user_requested',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.auth = z.auth || {};

z.auth.URLParameter = {
  ENVIRONMENT: 'env',
  LOCALE: 'hl',
  MODE: 'mode',
  REASON: 'reason',
  TRACKING: 'tracking',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.BackendClient = class BackendClient {
  static get CONFIG() {
    return {
      CONNECTIVITY_CHECK: {
        INITIAL_TIMEOUT: 0,
        RECHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
        REQUEST_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.5,
      },
      QUEUE_CHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
    };
  }

  static get CONNECTIVITY_CHECK_TRIGGER() {
    return {
      ACCESS_TOKEN_REFRESH: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_REFRESH',
      ACCESS_TOKEN_RETRIEVAL: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_RETRIEVAL',
      APP_INIT_RELOAD: '.BackendClient.CONNECTIVITY_CHECK_TRIGGER.APP_INIT_RELOAD',
      CONNECTION_REGAINED: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.CONNECTION_REGAINED',
      LOGIN_REDIRECT: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.LOGIN_REDIRECT',
      REQUEST_FAILURE: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.REQUEST_FAILURE',
      UNKNOWN: 'BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN',
    };
  }

  static get IGNORED_BACKEND_ERRORS() {
    return [
      z.error.BackendClientError.STATUS_CODE.BAD_GATEWAY,
      z.error.BackendClientError.STATUS_CODE.CONFLICT,
      z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM,
      z.error.BackendClientError.STATUS_CODE.INTERNAL_SERVER_ERROR,
      z.error.BackendClientError.STATUS_CODE.NOT_FOUND,
      z.error.BackendClientError.STATUS_CODE.PRECONDITION_FAILED,
      z.error.BackendClientError.STATUS_CODE.REQUEST_TIMEOUT,
      z.error.BackendClientError.STATUS_CODE.REQUEST_TOO_LARGE,
      z.error.BackendClientError.STATUS_CODE.TOO_MANY_REQUESTS,
    ];
  }

  static get IGNORED_BACKEND_LABELS() {
    return [
      z.error.BackendClientError.LABEL.INVALID_CREDENTIALS,
      z.error.BackendClientError.LABEL.PASSWORD_EXISTS,
      z.error.BackendClientError.LABEL.TOO_MANY_CLIENTS,
      z.error.BackendClientError.LABEL.TOO_MANY_MEMBERS,
      z.error.BackendClientError.LABEL.UNKNOWN_CLIENT,
    ];
  }

  /**
   * Construct a new client.
   *
   * @param {Object} settings - Settings for different backend environments
   * @param {string} settings.environment - Backend environment used
   * @param {string} settings.restUrl - Backend REST URL
   * @param {string} settings.webSocketUrl - Backend WebSocket URL
   */
  constructor(settings) {
    this.logger = new z.util.Logger('z.service.BackendClient', z.config.LOGGER.OPTIONS);

    z.util.Environment.backend.current = settings.environment;
    this.restUrl = settings.restUrl;
    this.webSocketUrl = settings.webSocketUrl;

    this.connectivityTimeout = undefined;
    this.connectivityQueue = new z.util.PromiseQueue({name: 'BackendClient.Connectivity'});

    this.requestQueue = new z.util.PromiseQueue({concurrent: 4, name: 'BackendClient.Request'});
    this.queueState = ko.observable(z.service.QUEUE_STATE.READY);
    this.queueTimeout = undefined;

    this.accessToken = '';
    this.accessTokenType = '';

    this.numberOfRequests = ko.observable(0);
    this.numberOfRequests.subscribe(newValue => amplify.publish(z.event.WebApp.TELEMETRY.BACKEND_REQUESTS, newValue));

    // Only allow JSON response by default
    $.ajaxSetup({
      contents: {javascript: false},
      dataType: 'json',
    });

    // http://stackoverflow.com/a/18996758/451634
    $.ajaxPrefilter((options, originalOptions, jqXHR) => {
      jqXHR.wireRequest = {
        originalRequestOptions: originalOptions,
        requestDate: new Date(),
        requestId: this.numberOfRequests(),
      };
    });
  }

  /**
   * Create a request URL.
   * @param {string} path - API endpoint path to be suffixed to REST API environment
   * @returns {string} REST API endpoint URL
   */
  createUrl(path) {
    z.util.ValidationUtil.isValidApiPath(path);
    return `${this.restUrl}${path}`;
  }

  /**
   * Request backend status.
   * @returns {$.Promise} jQuery AJAX promise
   */
  status() {
    return $.ajax({
      timeout: BackendClient.CONFIG.CONNECTIVITY_CHECK.REQUEST_TIMEOUT,
      type: 'HEAD',
      url: this.createUrl('/self'),
    });
  }

  /**
   * Delay a function call until backend connectivity is guaranteed.
   * @param {BackendClient.CONNECTIVITY_CHECK_TRIGGER} [source=BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN] - Trigger that requested connectivity check
   * @returns {Promise} Resolves once the connectivity is verified
   */
  executeOnConnectivity(source = BackendClient.CONNECTIVITY_CHECK_TRIGGER.UNKNOWN) {
    this.logger.info(`Connectivity check requested by '${source}'`);
    const {INITIAL_TIMEOUT, RECHECK_TIMEOUT} = BackendClient.CONFIG.CONNECTIVITY_CHECK;

    const _resetQueue = () => {
      if (this.connectivityTimeout) {
        window.clearTimeout(this.connectivityTimeout);
        this.connectivityQueue.pause(false);
      }
      this.connectivityTimeout = undefined;
    };

    const _checkStatus = () => {
      return this.status()
        .done(jqXHR => {
          this.logger.info('Connectivity verified', jqXHR);
          _resetQueue();
        })
        .fail(jqXHR => {
          if (jqXHR.readyState === 4) {
            this.logger.info(`Connectivity verified by server error '${jqXHR.status}'`, jqXHR);
            _resetQueue();
          } else {
            this.logger.warn('Connectivity could not be verified... retrying');
            this.connectivityQueue.pause();
            this.connectivityTimeout = window.setTimeout(_checkStatus, RECHECK_TIMEOUT);
          }
        });
    };

    this.connectivityQueue.pause();
    const queuedPromise = this.connectivityQueue.push(() => Promise.resolve());
    if (!this.connectivityTimeout) {
      this.connectivityTimeout = window.setTimeout(_checkStatus, INITIAL_TIMEOUT);
    }

    return queuedPromise;
  }

  /**
   * Execute queued requests.
   * @returns {undefined} No return value
   */
  executeRequestQueue() {
    this.queueState(z.service.QUEUE_STATE.READY);
    if (this.accessToken && this.requestQueue.getLength()) {
      this.logger.info(`Executing '${this.requestQueue.getLength()}' queued requests`);
      this.requestQueue.resume();
    }
  }

  clearQueueUnblockTimeout() {
    if (this.queueTimeout) {
      window.clearTimeout(this.queueTimeout);
      this.queueTimeout = undefined;
    }
  }

  scheduleQueueUnblock() {
    this.clearQueueUnblockTimeout();
    this.queueTimeout = window.setTimeout(() => {
      const isRefreshingToken = this.queueState() === z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH;
      if (isRefreshingToken) {
        this.logger.log(`Unblocked queue on timeout during '${this.queueState()}'`);
        this.queueState(z.service.QUEUE_STATE.READY);
      }
    }, BackendClient.CONFIG.QUEUE_CHECK_TIMEOUT);
  }

  /**
   * Send jQuery AJAX request with compressed JSON body.
   *
   * @note ContentType will be overwritten with 'application/json; charset=utf-8'
   * @see sendRequest for valid parameters
   *
   * @param {Object} config - AJAX request configuration
   * @returns {Promise} Resolves when the request has been executed
   */
  sendJson(config) {
    const jsonConfig = {
      contentType: 'application/json; charset=utf-8',
      data: config.data ? pako.gzip(JSON.stringify(config.data)) : undefined,
      headers: {'Content-Encoding': 'gzip'},
      processData: false,
    };

    return this.sendRequest($.extend(config, jsonConfig, true));
  }

  /**
   * Queue jQuery AJAX request.
   * @param {Object} config - AJAX request configuration
   * @returns {Promise} Resolves when the request has been executed
   */
  sendRequest(config) {
    if (this.queueState() !== z.service.QUEUE_STATE.READY) {
      const logMessage = `Adding '${config.type}' request to '${config.url}' to queue due to '${this.queueState()}'`;
      this.logger.info(logMessage, config);
    }

    return this.requestQueue.push(() => this._sendRequest(config));
  }

  _prependRequestQueue(config, resolveFn, rejectFn) {
    this.requestQueue.pause().unshift(() => {
      return this._sendRequest(config)
        .then(resolveFn)
        .catch(rejectFn);
    });
  }

  /**
   * Send jQuery AJAX request.
   *
   * @see http://api.jquery.com/jquery.ajax/#jQuery-ajax-settings
   *
   * @private
   * @param {Object} config - Request configuration
   * @param {string} config.contentType - Request content type
   * @param {boolean} config.crossDomain - Cross domain request
   * @param {Object} config.data - Request data payload
   * @param {Object} config.headers - Request headers
   * @param {boolean} config.processData - Process data before sending
   * @param {number} config.timeout - Request timeout
   * @param {string} config.type - Request type
   * @param {string} config.url - Request URL
   * @param {boolean} config.withCredentials - Request send with credentials
   * @returns {Promise} Resolves when the request has been executed
   */
  _sendRequest(config) {
    const {cache, contentType, crossDomain, data, headers, processData, timeout, type, url, withCredentials} = config;
    const ajaxConfig = {cache, contentType, crossDomain, data, headers, processData, timeout, type};

    if (this.accessToken) {
      const authorizationHeader = `${this.accessTokenType} ${window.decodeURIComponent(this.accessToken)}`;
      ajaxConfig.headers = Object.assign({}, headers, {Authorization: authorizationHeader});
    }

    if (url) {
      ajaxConfig.url = this.createUrl(url);
    }

    if (withCredentials) {
      ajaxConfig.xhrFields = {withCredentials: true};
    }

    this.numberOfRequests(this.numberOfRequests() + 1);

    return new Promise((resolve, reject) => {
      $.ajax(ajaxConfig)
        .done((responseData, textStatus, {wireRequest}) => {
          const requestId = wireRequest ? wireRequest.requestId : 'ID not set';
          const logMessage = `Server response to '${config.type}' request '${config.url}' - '${requestId}':`;
          this.logger.debug(this.logger.levels.OFF, logMessage, responseData);

          resolve(responseData);
        })
        .fail(({responseJSON: response, status: statusCode, wireRequest}) => {
          switch (statusCode) {
            case z.error.BackendClientError.STATUS_CODE.CONNECTIVITY_PROBLEM: {
              this.queueState(z.service.QUEUE_STATE.CONNECTIVITY_PROBLEM);
              this._prependRequestQueue(config, resolve, reject);

              return this.executeOnConnectivity().then(() => this.executeRequestQueue());
            }

            case z.error.BackendClientError.STATUS_CODE.FORBIDDEN: {
              if (response) {
                const errorLabel = response.label;
                const errorMessage = `Server request forbidden: ${errorLabel}`;

                if (BackendClient.IGNORED_BACKEND_LABELS.includes(errorLabel)) {
                  this.logger.warn(errorMessage);
                } else {
                  const requestId = wireRequest ? wireRequest.requestId : undefined;
                  const customData = {
                    endpoint: config.url,
                    method: config.type,
                    requestId,
                  };

                  Raygun.send(new Error(errorMessage), customData);
                }
              }
              break;
            }

            case z.error.BackendClientError.STATUS_CODE.ACCEPTED:
            case z.error.BackendClientError.STATUS_CODE.CREATED:
            case z.error.BackendClientError.STATUS_CODE.NO_CONTENT:
            case z.error.BackendClientError.STATUS_CODE.OK: {
              // Prevent empty valid response from being rejected
              if (!response) {
                return resolve({});
              }
              break;
            }

            case z.error.BackendClientError.STATUS_CODE.UNAUTHORIZED: {
              if (!config.skipRetry) {
                this._prependRequestQueue(config, resolve, reject);

                const trigger = z.auth.AuthRepository.ACCESS_TOKEN_TRIGGER.UNAUTHORIZED_REQUEST;
                return amplify.publish(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW, trigger);
              }
            }

            default: {
              if (!BackendClient.IGNORED_BACKEND_ERRORS.includes(statusCode)) {
                const requestId = wireRequest ? wireRequest.requestId : undefined;
                const customData = {
                  endpoint: config.url,
                  method: config.type,
                  requestId,
                };

                Raygun.send(new Error(`Server request failed: ${statusCode}`), customData);
              }
            }
          }

          reject(response || new z.error.BackendClientError(statusCode));
        });
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.BackendEnvironment = {
  DEVELOPMENT: 'development',
  PRODUCTION: 'production',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.service = z.service || {};

z.service.QUEUE_STATE = {
  ACCESS_TOKEN_REFRESH: 'z.service.QUEUE_STATE.ACCESS_TOKEN_REFRESH',
  CONNECTIVITY_PROBLEM: 'z.service.QUEUE_STATE.CONNECTIVITY_PROBLEM',
  READY: 'z.service.QUEUE_STATE.READY',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.Auth = class Auth {
  /**
   * Constructs objects needed for app authentication.
   *
   * @param {Object} settings - Collection of URL settings
   * @param {string} settings.environment - Handle of the backend environment (staging, etc.)
   * @param {string} settings.webSocketUrl - URL to the backend's WebSocket
   * @param {string} settings.restUrl - URL to the backend's REST service
   * @param {string} settings.parameter - Additional parameters for the webapp's login URL
   * @returns {Auth} New authentication object
   */
  constructor(settings) {
    this.settings = settings;
    this.audio = new z.audio.AudioRepository();
    this.backendClient = new z.service.BackendClient(this.settings);
    this.service = new z.auth.AuthService(this.backendClient);
    this.repository = new z.auth.AuthRepository(this.service);
    return this;
  }
};

//##############################################################################
// Setting up the Environment (DIST)
//##############################################################################
$(() => {
  const defaultEnvironment = z.util.Environment.frontend.isProduction()
    ? z.service.BackendEnvironment.PRODUCTION
    : z.service.BackendEnvironment.DEVELOPMENT;
  const env = z.util.URLUtil.getParameter(z.auth.URLParameter.ENVIRONMENT) || defaultEnvironment;

  const isStaging = env === z.service.BackendEnvironment.DEVELOPMENT;
  const settings = isStaging
    ? {
        environment: z.service.BackendEnvironment.DEVELOPMENT,
        restUrl: 'https://staging-nginz-https.zinfra.io',
        webSocketUrl: 'wss://staging-nginz-ssl.zinfra.io',
      }
    : {
        environment: z.service.BackendEnvironment.PRODUCTION,
        restUrl: window.wire.env.BACKEND_REST || 'https://prod-nginz-https.wire.com',
        webSocketUrl: window.wire.env.BACKEND_WS || 'wss://prod-nginz-ssl.wire.com',
      };

  window.wire = Object.assign(window.wire || {}, {
    auth: new z.main.Auth(settings),
  });
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageKey = {
  AUTH: {
    ACCESS_TOKEN: {
      EXPIRATION: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION',
      TTL: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.TTL',
      TYPE: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.TYPE',
      VALUE: 'z.storage.StorageKey.AUTH.ACCESS_TOKEN.VALUE',
    },
    COOKIE_LABEL: 'z.storage.StorageKey.AUTH.COOKIE_LABEL',
    PERSIST: 'z.storage.StorageKey.AUTH.PERSIST',
    SHOW_LOGIN: 'z.storage.StorageKey.AUTH.SHOW_LOGIN',
  },
  CONVERSATION: {
    EMOJI_USAGE_COUNT: 'z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT',
    INPUT: 'z.storage.StorageKey.CONVERSATION.INPUT',
  },
  LOCALIZATION: {
    LOCALE: 'z.storage.StorageKey.LOCALIZATION.LOCALE',
  },
  SEARCH: {
    SUGGESTED_SEARCH_ETS: 'z.storage.StorageKey.SEARCH.SUGGESTED_SEARCH_ETS',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageRepository = class StorageRepository {
  static get CONFIG() {
    return {
      CRYPTOGRAPHY_TABLES: [
        z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY,
        z.storage.StorageSchemata.OBJECT_STORE.CLIENTS,
        z.storage.StorageSchemata.OBJECT_STORE.KEYS,
        z.storage.StorageSchemata.OBJECT_STORE.SESSIONS,
        z.storage.StorageSchemata.OBJECT_STORE.PRE_KEYS,
      ],
    };
  }

  /**
   * Construct an new Storage Repository.
   * @param {z.storage.StorageService} storageService - Service for all storage related interactions
   */
  constructor(storageService) {
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.storage.StorageRepository', z.config.LOGGER.OPTIONS);

    this.AMPLIFY_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY;
  }

  /**
   * Clear all database stores.
   * @returns {Promise} Resolves when stores have been deleted
   */
  clearStores() {
    return this.storageService
      .clearStores()
      .then(() => this.logger.info(`Cleared database '${this.storageService.dbName}'`));
  }

  /**
   * Delete cryptography related information.
   * @note Retain history but clean other information.
   * @returns {Promise} Resolves when stores have been deleted
   */
  deleteCryptographyStores() {
    return this.storageService.deleteStores(StorageRepository.CONFIG.CRYPTOGRAPHY_TABLES);
  }

  /**
   * Delete everything from the database
   * @note Nukes it - no way to recover data
   * @returns {Promise} Resolves when database has been deleted
   */
  deleteDatabase() {
    this.logger.warn(`Deleting database '${this.storageService.dbName}'`);
    return this.storageService.deleteDatabase();
  }

  /**
   * Get a value for a given primary key from the amplify value store.
   *
   * @param {string} primaryKey - Primary key to retrieve the object for
   * @returns {Promise} Resolves with the retrieved value
   */
  getValue(primaryKey) {
    return this.storageService.load(this.AMPLIFY_STORE_NAME, primaryKey).then(record => {
      if (record && record.value) {
        return record.value;
      }
      throw new z.error.StorageError(z.error.StorageError.TYPE.NOT_FOUND);
    });
  }

  /**
   * Save a value in the amplify value store.
   *
   * @param {string} primaryKey - Primary key to save the object with
   * @param {value} value - Object to be stored
   * @returns {Promise} Resolves with the primary key
   */
  saveValue(primaryKey, value) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, primaryKey, {value: value});
  }

  /**
   * Closes the database connection.
   * @param {string} reason - Cause for the termination
   * @returns {undefined} No return value
   */
  terminate(reason) {
    this.storageService.terminate(reason);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageSchemata = class StorageSchemata {
  static get OBJECT_STORE() {
    return {
      AMPLIFY: 'amplify',
      CLIENTS: 'clients',
      CONVERSATION_EVENTS: 'conversation_events',
      CONVERSATIONS: 'conversations',
      EVENTS: 'events',
      KEYS: 'keys',
      PRE_KEYS: 'prekeys',
      SESSIONS: 'sessions',
      USERS: 'users',
    };
  }

  // @see https://github.com/dfahlander/Dexie.js/wiki/Version.stores()
  // @see https://github.com/dfahlander/Dexie.js/wiki/Version.upgrade()
  // @see https://github.com/dfahlander/Dexie.js/wiki/WriteableCollection.modify()
  static get SCHEMATA() {
    return [
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 1,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 2,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: '',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 3,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', raw.conversation, raw.time, raw.type, meta.timestamp',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CLIENTS].toCollection().modify(client => {
            client.meta = {is_verified: true, primary_key: 'local_identity'};
          });
        },
        version: 4,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 5,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: (transaction, database) => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATIONS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.CONVERSATIONS].update(key, {id: key});
          });
          transaction[StorageSchemata.OBJECT_STORE.SESSIONS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.SESSIONS].update(key, {id: key});
          });
          transaction[StorageSchemata.OBJECT_STORE.PRE_KEYS].toCollection().eachKey(key => {
            database[StorageSchemata.OBJECT_STORE.PRE_KEYS].update(key, {id: key});
          });
        },
        version: 6,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            const mappedEvent = event.mapped || event.raw;
            delete event.mapped;
            delete event.raw;
            delete event.meta;
            Object.assign(event, mappedEvent);
          });
        },
        version: 7,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            const isTypeDeleteEveryWhere = event.type === 'conversation.delete-everywhere';
            if (isTypeDeleteEveryWhere) {
              event.time = new Date(event.time).toISOString();
            }
          });
        },
        version: 8,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]: ', conversation, time, type, [conversation+time]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        version: 9,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS].toCollection().modify(event => {
            event.category = z.message.MessageCategorization.categoryFromEvent(event);
          });
        },
        version: 10,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          const localClientPrimaryKey = 'local_identity';

          transaction[StorageSchemata.OBJECT_STORE.CLIENTS].toCollection().each((client, cursor) => {
            const isExpectedMetaPrimaryKey = client.meta.primary_key === localClientPrimaryKey;
            const isExpectedPrimaryKey = client.primary_key === localClientPrimaryKey;

            const isExpectedClient = isExpectedMetaPrimaryKey && isExpectedPrimaryKey;
            if (isExpectedClient) {
              transaction[StorageSchemata.OBJECT_STORE.CLIENTS].delete(cursor.primaryKey);
              transaction[StorageSchemata.OBJECT_STORE.CLIENTS].put(client, localClientPrimaryKey);
            }
          });
        },
        version: 11,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.KEYS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
          transaction[StorageSchemata.OBJECT_STORE.PRE_KEYS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
          transaction[StorageSchemata.OBJECT_STORE.SESSIONS].toCollection().modify(record => {
            record.serialised = z.util.base64ToArray(record.serialised).buffer;
          });
        },
        version: 12,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: (transaction, database) => {
          transaction[StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]
            .toCollection()
            .toArray()
            .then(items => database[StorageSchemata.OBJECT_STORE.EVENTS].bulkPut(items));
        },
        version: 13,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
        },
        upgrade: transaction => {
          transaction[StorageSchemata.OBJECT_STORE.EVENTS].toCollection().modify(event => {
            const isTypeAssetMeta = event.type === 'conversation.asset-meta';
            if (isTypeAssetMeta) {
              event.type = 'conversation.asset-add';
            }
          });
        },
        version: 14,
      },
      {
        schema: {
          [StorageSchemata.OBJECT_STORE.AMPLIFY]: '',
          [StorageSchemata.OBJECT_STORE.CLIENTS]: ', meta.primary_key',
          [StorageSchemata.OBJECT_STORE.CONVERSATION_EVENTS]:
            ', category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.CONVERSATIONS]: ', id, last_event_timestamp',
          [StorageSchemata.OBJECT_STORE.EVENTS]:
            '++primary_key, id, category, conversation, time, type, [conversation+time], [conversation+category]',
          [StorageSchemata.OBJECT_STORE.KEYS]: '',
          [StorageSchemata.OBJECT_STORE.PRE_KEYS]: '',
          [StorageSchemata.OBJECT_STORE.SESSIONS]: '',
          [StorageSchemata.OBJECT_STORE.USERS]: ', id',
        },
        version: 15,
      },
    ];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.storage = z.storage || {};

z.storage.StorageService = class StorageService {
  // Construct an new StorageService.
  constructor() {
    this.logger = new z.util.Logger('z.storage.StorageService', z.config.LOGGER.OPTIONS);

    this.db = undefined;
    this.dbName = undefined;
    this.userId = undefined;
  }

  //##############################################################################
  // Initialization
  //##############################################################################

  /**
   * Initialize the IndexedDB for a user.
   *
   * @param {string} userId - User ID
   * @returns {Promise} Resolves with the database name
   */
  init(userId = this.userId) {
    return Promise.resolve().then(() => {
      const isPermanent = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.PERSIST);
      const clientType = isPermanent ? z.client.ClientType.PERMANENT : z.client.ClientType.TEMPORARY;

      this.userId = userId;
      this.dbName = `wire@${z.util.Environment.backend.current}@${userId}@${clientType}`;

      this.db = new Dexie(this.dbName);

      this.db.on('blocked', () => this.logger.error('Database is blocked'));

      this._upgradeStores();

      return this.db
        .open()
        .then(() => {
          this.logger.info(`Storage Service initialized with database '${this.dbName}' version '${this.db.verno}'`);
          return this.dbName;
        })
        .catch(error => {
          const logMessage = `Failed to initialize database '${this.dbName}': ${error.message || error}`;
          this.logger.error(logMessage, {error: error});
          throw new z.error.StorageError(z.error.StorageError.TYPE.FAILED_TO_OPEN);
        });
    });
  }

  _upgradeStores() {
    z.storage.StorageSchemata.SCHEMATA.forEach(({schema, upgrade, version}) => {
      if (upgrade) {
        return this.db
          .version(version)
          .stores(schema)
          .upgrade(transaction => {
            this.logger.warn(`Database upgrade to version '${version}'`);
            upgrade(transaction, this.db);
          });
      }

      this.db.version(version).stores(schema);
    });
  }

  //##############################################################################
  // Interactions
  //##############################################################################

  /**
   * Clear all stores.
   * @returns {Promise} Resolves when all stores have been cleared
   */
  clearStores() {
    const deleteStorePromises = Object.keys(this.db._dbSchema).map(storeName => this.deleteStore(storeName));
    return Promise.all(deleteStorePromises);
  }

  /**
   * Removes persisted data.
   *
   * @param {string} storeName - Name of the object store
   * @param {string} primaryKey - Primary key
   * @returns {Promise} Resolves when the object is deleted
   */
  delete(storeName, primaryKey) {
    if (this.db[storeName]) {
      return this.db[storeName]
        .delete(primaryKey)
        .then(() => {
          this.logger.info(`Deleted '${primaryKey}' from object store '${storeName}'`);
          return primaryKey;
        })
        .catch(error => {
          this.logger.error(`Failed to delete '${primaryKey}' from store '${storeName}'`, error);
          throw error;
        });
    }

    return Promise.reject(new z.error.StorageError(z.error.StorageError.TYPE.DATA_STORE_NOT_FOUND));
  }

  /**
   * Delete the IndexedDB with all its stores.
   * @returns {Promise} Resolves if a database is found and cleared
   */
  deleteDatabase() {
    if (this.db) {
      return this.db
        .delete()
        .then(() => {
          this.logger.info(`Clearing IndexedDB '${this.dbName}' successful`);
          return true;
        })
        .catch(error => {
          this.logger.error(`Clearing IndexedDB '${this.dbName}' failed`);
          throw error;
        });
    }
    this.logger.error(`IndexedDB '${this.dbName}' not found`);
    return Promise.resolve(true);
  }

  /**
   * Delete a database store.
   * @param {string} storeName - Name of database store to delete
   * @returns {Promise} Resolves when the store has been deleted
   */
  deleteStore(storeName) {
    this.logger.info(`Clearing object store '${storeName}' in database '${this.dbName}'`);
    return this.db[storeName].clear();
  }

  /**
   * Delete multiple database stores.
   * @param {Array<string>} storeNames - Names of database stores to delete
   * @returns {Promise} Resolves when the stores have been deleted
   */
  deleteStores(storeNames) {
    const deleteStorePromises = storeNames.map(storeName => this.deleteStore(storeName));
    return Promise.all(deleteStorePromises);
  }

  /**
   * Returns an array of all records for a given object store.
   *
   * @param {string} storeName - Name of object store
   * @returns {Promise} Resolves with the records from the object store
   */
  getAll(storeName) {
    return this.db[storeName]
      .toArray()
      .then(resultArray => resultArray.filter(result => result))
      .catch(error => {
        this.logger.error(`Failed to load objects from store '${storeName}'`, error);
        throw error;
      });
  }

  /**
   * @param {Array<string>} tableNames - Names of tables to get
   * @returns {Array<Table>} Matching tables
   */
  getTables(tableNames) {
    return tableNames.map(tableName => this.db[tableName]);
  }

  /**
   * Loads persisted data via a promise.
   * @note If a key cannot be found, it resolves and returns "undefined".
   *
   * @param {string} storeName - Name of object store
   * @param {string} primaryKey - Primary key of object to be retrieved
   * @returns {Promise} Resolves with the record matching the primary key
   */
  load(storeName, primaryKey) {
    return this.db[storeName].get(primaryKey).catch(error => {
      this.logger.error(`Failed to load '${primaryKey}' from store '${storeName}'`, error);
      throw error;
    });
  }

  /**
   * Saves objects in the local database.
   *
   * @param {string} storeName - Name of object store where to save the object
   * @param {string} primaryKey - Primary key which should be used to store the object
   * @param {Object} entity - Data to store in object store
   * @returns {Promise} Resolves with the primary key of the persisted object
   */
  save(storeName, primaryKey, entity) {
    if (!entity) {
      return Promise.reject(new z.error.StorageError(z.error.StorageError.TYPE.NO_DATA));
    }

    return this.db[storeName].put(entity, primaryKey).catch(error => {
      this.logger.error(`Failed to put '${primaryKey}' into store '${storeName}'`, error);
      throw error;
    });
  }

  /**
   * Closes the database. This operation completes immediately and there is no returned Promise.
   * @see https://github.com/dfahlander/Dexie.js/wiki/Dexie.close()
   * @param {string} [reason='unknown reason'] - Cause for the termination
   * @returns {undefined} No return value
   */
  terminate(reason = 'unknown reason') {
    this.logger.info(`Closing database connection with '${this.db.name}' because of '${reason}'.`);
    this.db.close();
  }

  /**
   * Update previously persisted data via a promise.
   *
   * @param {string} storeName - Name of object store
   * @param {string} primaryKey - Primary key of object to be updated
   * @param {Object} changes - Object containing the key paths to each property you want to change
   * @returns {Promise} Promise with the number of updated records (0 if no records were changed).
   */
  update(storeName, primaryKey, changes) {
    return this.db[storeName]
      .update(primaryKey, changes)
      .then(numberOfUpdates => {
        const logMessage = `Updated ${numberOfUpdates} record(s) with key '${primaryKey}' in store '${storeName}'`;
        this.logger.info(logMessage, changes);
        return numberOfUpdates;
      })
      .catch(error => {
        this.logger.error(`Failed to update '${primaryKey}' in store '${storeName}'`, error);
        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
z.string = z.string || {};
z.string.da = z.string.da || {};
z.string.cs = z.string.cs || {};
z.string.de = z.string.de || {};
z.string.el = z.string.el || {};
z.string.es = z.string.es || {};
z.string.et = z.string.et || {};
z.string.fi = z.string.fi || {};
z.string.fr = z.string.fr || {};
z.string.hr = z.string.hr || {};
z.string.hu = z.string.hu || {};
z.string.it = z.string.it || {};
z.string.lt = z.string.lt || {};
z.string.nl = z.string.nl || {};
z.string.pl = z.string.pl || {};
z.string.pt = z.string.pt || {};
z.string.ro = z.string.ro || {};
z.string.ru = z.string.ru || {};
z.string.sk = z.string.sk || {};
z.string.sl = z.string.sl || {};
z.string.tr = z.string.tr || {};
z.string.uk = z.string.uk || {};

z.string.Declension = {
  ACCUSATIVE: 'accusative',
  DATIVE: 'dative',
  NOMINATIVE: 'nominative',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.cs.wireMacos = 'Wire pro macOS';
z.string.cs.wireWindows = 'Wire pro Windows';
z.string.cs.wireLinux = 'Wire pro Linux';
z.string.cs.nonexistentUser = 'Smazaný uživatel';
z.string.cs.and = 'a';

z.string.cs.authAccountCountryCode = 'Kód země';
z.string.cs.authAccountPasswordForgot = 'Zapomenuté heslo';
z.string.cs.authAccountPublicComputer = 'Toto je veřejný počítač';
z.string.cs.authAccountSignIn = 'Přihlásit se';
z.string.cs.authAccountSignInPhone = 'Telefon';

z.string.cs.authBlockedCookies = 'Pro přihlášení k Wire povolte soubory cookie.';
z.string.cs.authBlockedDatabase = 'Pro zobrazení zpráv potřebuje Wire potřebuje přístup k úložišti. Úložiště není k dispozici v anonymním režimu.';
z.string.cs.authBlockedTabs = 'Wire je již otevřen na jiné záložce.';

z.string.cs.authVerifyAccountAdd = 'Přidat';
z.string.cs.authVerifyAccountDetail = 'To umožňuje používat Wire na více zařízeních.';
z.string.cs.authVerifyAccountHeadline = 'Přidat emailovou adresu a heslo.';
z.string.cs.authVerifyAccountLogout = 'Odhlásit se';
z.string.cs.authVerifyCodeDescription = 'Zadejte ověřovací kód,\nkterý byl zaslán na {{number}}.';
z.string.cs.authVerifyCodeResend = 'Kód nedošel?';
z.string.cs.authVerifyCodeResendDetail = 'Odeslat znovu';
z.string.cs.authVerifyCodeResendTimer = 'Můžete si vyžádat nový kód {{expiration}}.';
z.string.cs.authVerifyCodeChangePhone = 'Změnit telefonní číslo';
z.string.cs.authVerifyPasswordHeadline = 'Zadejte své heslo';

z.string.cs.authLimitDevicesHeadline = 'Přístroje';
z.string.cs.authLimitDescription = 'Odeberte jeden ze svých přístrojů abyste mohli začít používat Wire na tomto zařízení.';
z.string.cs.authLimitButtonManage = 'Spravovat přístroje';
z.string.cs.authLimitButtonSignOut = 'Odhlásit se';
z.string.cs.authLimitDevicesCurrent = '(Aktuální)';

z.string.cs.authHistoryHeadline = 'Toto je poprvé kdy používáte Wire na tomto přístroji.';
z.string.cs.authHistoryDescription = 'Z důvodů ochrany soukromí se zde nezobrazí historie vaší konverzace.';
z.string.cs.authHistoryReuseHeadline = 'Již jste dříve použili Wire na tomto zařízení.';
z.string.cs.authHistoryReuseDescription = 'Zprávy odeslané v mezičase se zde nezobrazí.';
z.string.cs.authHistoryButton = 'OK';

z.string.cs.authPostedResend = 'Znovu odeslat na {{email}}';
z.string.cs.authPostedResendAction = 'Žádný email nedošel?';
z.string.cs.authPostedResendDetail = 'Zkontrolujte doručenou poštu a postupujte dle instrukcí.';
z.string.cs.authPostedResendHeadline = 'Přišel ti email.';

z.string.cs.authPlaceholderEmail = 'Email';
z.string.cs.authPlaceholderPasswordPut = 'Heslo';
z.string.cs.authPlaceholderPasswordSet = 'Heslo (alespoň 8 znaků)';
z.string.cs.authPlaceholderPhone = 'Telefonní číslo';

z.string.cs.authErrorCode = 'Neplatný kód';
z.string.cs.authErrorCountryCodeInvalid = 'Neplatný kód země';
z.string.cs.authErrorEmailExists = 'Emailová adresa je již používána';
z.string.cs.authErrorEmailForbidden = 'Omlouváme se. Tato emailová adresa byla zakázána.';
z.string.cs.authErrorEmailMalformed = 'Zadejte prosím platnou emailovou adresu.';
z.string.cs.authErrorEmailMissing = 'Zadejte prosím emailovou adresu.';
z.string.cs.authErrorMisc = 'Problémy s připojením. Prosím opakujte akci.';
z.string.cs.authErrorNameShort = 'Zadejte jméno s alespoň 2 znaky';
z.string.cs.authErrorOffline = 'Nejste připojeni k Internetu';
z.string.cs.authErrorPasswordShort = 'Zadejte heslo obsahující alespoň 8 znaků.';
z.string.cs.authErrorPasswordWrong = 'Neplatné heslo. Zkuste to prosím znovu.';
z.string.cs.authErrorPhoneNumberBudget = 'Příliš často se přihlašujete. Opakujte akci později.';
z.string.cs.authErrorPhoneNumberForbidden = 'Omlouváme se. Toto telefonní číslo bylo zakázáno.';
z.string.cs.authErrorPhoneNumberInvalid = 'Neplatné telefonní číslo';
z.string.cs.authErrorPhoneNumberUnknown = 'Neznámé telefonní číslo';
z.string.cs.authErrorSuspended = 'Pro tento účet již není povoleno se přihlásit.';
z.string.cs.authErrorSignIn = 'Zkontrolujte své údaje a zkuste znovu.';

z.string.cs.callStateOutgoing = 'Zvoní…';
z.string.cs.callStateConnecting = 'Připojuji…';
z.string.cs.callStateIncoming = 'Volá…';
z.string.cs.callDecline = 'Zamítnout';
z.string.cs.callAccept = 'Přijmout';
z.string.cs.callJoin = 'Vstoupit';
z.string.cs.callChooseSharedScreen = 'Vybrat obrazovku ke sdílení';
z.string.cs.callParticipants = '{{number}} se účastní hovoru';

z.string.cs.videoCallOverlayMute = 'Ztlumit';
z.string.cs.videoCallOverlayHangUp = 'Zavěsit';

z.string.cs.modalAcknowledgeAction = 'Ok';
z.string.cs.modalConfirmSecondary = 'Zrušit';
z.string.cs.modalOptionSecondary = 'Zrušit';

z.string.cs.modalAccountCreateAction = 'OK';

z.string.cs.modalAccountDeletionAction = 'Smazat';
z.string.cs.modalAccountDeletionHeadline = 'Smazat účet';
z.string.cs.modalAccountDeletionMessage = 'Obdržíte od nás zprávu přes email nebo SMS. Pro trvalé smazání svého účtu otevřete zaslaný odkaz.';

z.string.cs.modalAccountLeaveGuestRoomAction = 'Odejít';

z.string.cs.modalAccountLogoutAction = 'Odhlásit se';
z.string.cs.modalAccountLogoutHeadline = 'Vyčistit data?';
z.string.cs.modalAccountLogoutOption = 'Smazat všechny osobní informace a konverzace z tohoto přístroje.';

z.string.cs.modalAccountNewDevicesSecondary = 'Spravovat přístroje';
z.string.cs.modalAccountNewDevicesHeadline = 'Váš účet byl naposledy použit:';
z.string.cs.modalAccountNewDevicesFrom = 'Od:';
z.string.cs.modalAccountNewDevicesMessage = 'Pokud jste to nebyli vy sami, odeberte použité zařízení a změňte si heslo.';

z.string.cs.modalAccountRemoveDeviceAction = 'Odstranit přístroj';
z.string.cs.modalAccountRemoveDeviceHeadline = 'Odstranit "{{device}}"';
z.string.cs.modalAccountRemoveDeviceMessage = 'Pro odstranění přístroje je vyžadováno heslo.';
z.string.cs.modalAccountRemoveDevicePlaceholder = 'Heslo';

z.string.cs.modalAssetTooLargeMessage = 'Můžete posílat soubory až do velikosti {{number}}';

z.string.cs.modalAssetParallelUploadsMessage = 'Najednou můžete poslat až {{number}} souborů.';

z.string.cs.modalCallEmptyConversationHeadline = 'Nikdo pro volání';
z.string.cs.modalCallEmptyConversationMessage = 'Již zde nikdo jiný není.';

z.string.cs.modalCallNoGroupVideoHeadline = 'Žádné videohovory ve skupinách';
z.string.cs.modalCallNoGroupVideoMessage = 'Videohovory nejsou dostupné pro skupinové konverzace.';

z.string.cs.modalCallNoMicrophoneAction = 'Jak na to';
z.string.cs.modalCallNoMicrophoneMessage = 'Pro volání potřebuje prohlížeč přístup k mikrofonu.';
z.string.cs.modalCallNoMicrophoneHeadline = 'Nelze volat bez mikrofonu';

z.string.cs.modalCallSecondIncomingAction = 'Přijmout';
z.string.cs.modalCallSecondIncomingHeadline = 'Přijmout hovor?';
z.string.cs.modalCallSecondIncomingMessage = 'Aktuální hovor bude ukončen.';

z.string.cs.modalCallSecondOngoingAction = 'Zavěsit';
z.string.cs.modalCallSecondOngoingHeadline = 'Zavěsit hovor na jiném zařízení?';
z.string.cs.modalCallSecondOngoingMessage = 'V jednom okamžiku může být pouze v jednom hovoru.';

z.string.cs.modalCallSecondOutgoingAction = 'Zavěsit';
z.string.cs.modalCallSecondOutgoingHeadline = 'Zavěsit aktuální hovor?';
z.string.cs.modalCallSecondOutgoingMessage = 'V jednom okamžiku může být pouze v jednom hovoru.';

z.string.cs.modalConnectCancelAction = 'Ano';
z.string.cs.modalConnectCancelHeadline = 'Zrušit požadavek?';
z.string.cs.modalConnectCancelMessage = 'Odeberte požadavek na připojení s {{user}}.';
z.string.cs.modalConnectCancelSecondary = 'Ne';

z.string.cs.modalConnectAcceptAction = 'Připojit';
z.string.cs.modalConnectAcceptHeadline = 'Přijmout?';
z.string.cs.modalConnectAcceptMessage = 'Toto naváže spojení a otevře konverzaci s {{user}}.';
z.string.cs.modalConnectAcceptSecondary = 'Ignorovat';

z.string.cs.modalConversationClearAction = 'Smazat';
z.string.cs.modalConversationClearHeadline = 'Vymazat obsah?';
z.string.cs.modalConversationClearOption = 'Také opustit konverzaci';

z.string.cs.modalConversationDeleteMessageAction = 'Smazat';
z.string.cs.modalConversationDeleteMessageHeadline = 'Smazat pouze u mně?';
z.string.cs.modalConversationDeleteMessageMessage = 'Tuto operaci nelze vrátit.';

z.string.cs.modalConversationDeleteMessageEveryoneAction = 'Smazat';
z.string.cs.modalConversationDeleteMessageEveryoneHeadline = 'Smazat pro všechny?';
z.string.cs.modalConversationDeleteMessageEveryoneMessage = 'Tuto operaci nelze vrátit.';

z.string.cs.modalConversationLeaveAction = 'Odejít';
z.string.cs.modalConversationLeaveMessage = 'Nebudete moct odesílat ani přijímat zprávy v této konverzaci.';

z.string.cs.modalConversationMessageTooLongHeadline = 'Zpráva je příliš dlouhá';
z.string.cs.modalConversationMessageTooLongMessage = 'Můžete posílat zprávy dlouhé až {{number}} znaků.';

z.string.cs.modalConversationNewDeviceHeadlineOne = '{{user}} začal(a) používat nové zařízení';
z.string.cs.modalConversationNewDeviceHeadlineMany = '{{users}} začali používat nové zařízení';
z.string.cs.modalConversationNewDeviceHeadlineYou = '{{user}} začal(a) používat nové zařízení';
z.string.cs.modalConversationNewDeviceIncomingCallAction = 'Přijmout volání';
z.string.cs.modalConversationNewDeviceIncomingCallMessage = 'Chcete přesto přijmout hovor?';
z.string.cs.modalConversationNewDeviceMessage = 'Chcete přesto odeslat své zprávy?';
z.string.cs.modalConversationNewDeviceOutgoingCallAction = 'Přesto zavolat';
z.string.cs.modalConversationNewDeviceOutgoingCallMessage = 'Chcete přesto volat?';

z.string.cs.modalConversationNotConnectedHeadline = 'Do konverzace nebyl nikdo přidán';
z.string.cs.modalConversationNotConnectedMessageOne = '{{name}} nemá zájem být přidán(a) do konverzace.';
z.string.cs.modalConversationNotConnectedMessageMany = 'Jeden z lidí které jste vybrali nechce být přidán do konverzace.';

z.string.cs.modalConversationRemoveAction = 'Odstranit';
z.string.cs.modalConversationRemoveHeadline = 'Odstranit?';
z.string.cs.modalConversationRemoveMessage = '{{user}} nebude moci odesílat nebo přijímat zprávy v této konverzaci.';

z.string.cs.modalConversationRemoveGuestsAction = 'Odstranit';

z.string.cs.modalConversationTooManyMembersHeadline = 'Přeplněné kupé';

z.string.cs.modalIntegrationUnavailableHeadline = 'Roboti jsou momentálně nedostupní';
z.string.cs.modalIntegrationUnavailableMessage = 'Děkujeme vám za váš zájem o roboty. Služba je pozastavena, zatímco pracujeme na další verzi.';


z.string.cs.modalImproveWireAction = 'Přijmout';
z.string.cs.modalImproveWireSecondary = 'Ne';

z.string.cs.modalSessionResetHeadline = 'Sezení bylo zresetováno';
z.string.cs.modalSessionResetMessage1 = 'Pokud problém není vyřešen,';
z.string.cs.modalSessionResetMessageLink = 'kontaktujte';
z.string.cs.modalSessionResetMessage2 = 'nás.';

z.string.cs.modalUploadContactsAction = 'Zkusit znovu';
z.string.cs.modalUploadContactsMessage = 'Neobdrželi jsme vaše data. Zkuste prosím kontakty importovat znovu.';

z.string.cs.modalUserBlockAction = 'Blokovat';
z.string.cs.modalUserBlockHeadline = 'Blokovat {{user}}?';
z.string.cs.modalUserBlockMessage = '{{user}} vás nebude moci kontaktovat nebo přizvat ke skupinové konverzaci.';

z.string.cs.modalUserUnblockAction = 'Odblokovat';
z.string.cs.modalUserUnblockHeadline = 'Odblokovat?';
z.string.cs.modalUserUnblockMessage = '{{user}} vás nebude moci kontaktovat nebo přizvat ke skupinové konverzaci.';

z.string.cs.connectionRequestConnect = 'Připojit';
z.string.cs.connectionRequestIgnore = 'Ignorovat';

z.string.cs.conversationGuestIndicator = 'Host';

z.string.cs.conversationYouNominative = 'jste';
z.string.cs.conversationYouDative = 'jste';
z.string.cs.conversationYouAccusative = 'jste';

z.string.cs.conversationConnectionAccepted = 'Připojeno';
z.string.cs.conversationConnectionBlocked = 'Blokováno';
z.string.cs.conversationConnectionCancelRequest = 'Zrušit žádost o připojení';
z.string.cs.conversationDeviceStartedUsingOne = ' začal(a) používat';
z.string.cs.conversationDeviceStartedUsingMany = ' začal(a) používat';
z.string.cs.conversationDeviceUnverified = ' neověřen jeden ze';
z.string.cs.conversationDeviceYourDevices = ' vaše přístroje';
z.string.cs.conversationDeviceUserDevices = ' přístroje uživatele {{user}}';
z.string.cs.conversationDeviceNewDeviceOne = ' nové zařízení';
z.string.cs.conversationDeviceNewDeviceMany = ' nové zařízení';
z.string.cs.conversationDeviceNewPeopleJoinedVerify = ' ověřit zařízení';
z.string.cs.conversationJustNow = 'Právě teď';
z.string.cs.conversationLocationLink = 'Otevřít mapu';
z.string.cs.conversationMessageDelivered = 'Doručeno';
z.string.cs.conversationRename = ' přejmenoval(a) konverzaci';
z.string.cs.conversationRenameYou = ' přejmenoval(a) konverzaci';
z.string.cs.conversationResume = 'Začít konverzovat s {{users}}';
z.string.cs.conversationPing = ' pingl(a)';
z.string.cs.conversationPingYou = ' pingl(a)';
z.string.cs.conversationToday = 'dnes';
z.string.cs.conversationVoiceChannelDeactivate = ' volal(a)';
z.string.cs.conversationVoiceChannelDeactivateYou = ' volal(a)';
z.string.cs.conversationYesterday = 'Včera';
z.string.cs.conversationUnableToDecrypt1 = 'zpráva od uživatele {{user}} nebyla přijata.';
z.string.cs.conversationUnableToDecrypt2 = 'Identita uživatele {{user}} se změnila. Zpráva nedoručena.';
z.string.cs.conversationUnableToDecryptLink = 'Proč?';
z.string.cs.conversationUnableToDecryptErrorMessage = 'Chyba';
z.string.cs.conversationUnableToDecryptResetSession = 'Resetovat sezení';
z.string.cs.conversationMissedMessages = 'Toto zařízení jste nějakou dobu nepoužíval(a). Některé zprávy se nemusí zobrazit.';
z.string.cs.conversationAssetDownloading = 'Stahování…';
z.string.cs.conversationAssetUploadFailed = 'Nahrání selhalo';
z.string.cs.conversationPlaybackError = 'Nelze přehrát';
z.string.cs.conversationContextMenuCopy = 'Vložit';
z.string.cs.conversationContextMenuEdit = 'Upravit';
z.string.cs.conversationContextMenuDelete = 'Odstranit pro mě';
z.string.cs.conversationContextMenuDeleteEveryone = 'Odstranit pro všechny';
z.string.cs.conversationContextMenuDownload = 'Stáhnout';
z.string.cs.conversationContextMenuLike = 'Líbí';
z.string.cs.conversationContextMenuUnlike = 'Nelíbí';
z.string.cs.conversationDeleteTimestamp = 'Smazáno v {{date}}';
z.string.cs.conversationEditTimestamp = 'Upraveno v {{date}}';
z.string.cs.conversationLikesCaption = '{{number}} lidí';
z.string.cs.conversationSendPastedFile = 'Obrázek vložen {{date}}';
z.string.cs.conversationSomeone = 'Někdo';
z.string.cs.conversationTweetAuthor = ' na Twittru';

z.string.cs.groupCreationPreferencesAction = 'Další';
z.string.cs.groupCreationParticipantsPlaceholder = 'Hledat podle jména';


z.string.cs.collectionShowAll = 'Zobrazit všechny {{number}}';
z.string.cs.collectionSectionLinks = 'Odkazy';
z.string.cs.collectionSectionImages = 'Obrázky';
z.string.cs.collectionSectionFiles = 'Soubory';
z.string.cs.collectionSectionAudio = 'Zvukové zprávy';

z.string.cs.fullsearchPlaceholder = 'Prohledat zprávy';
z.string.cs.fullsearchNoResults = 'Žádné výsledky.';

z.string.cs.archiveHeader = 'Archivovat';

z.string.cs.conversationsAllArchived = 'Vše archivováno';
z.string.cs.conversationsContacts = 'Kontakty';
z.string.cs.conversationsConnectionRequestMany = '{{number}} čekajících osob';
z.string.cs.conversationsConnectionRequestOne = '1 čekající osoba';
z.string.cs.conversationsEmptyConversation = 'Skupinová konverzace';
z.string.cs.conversationsNoConversations = 'Zatím žádné konverzace';
z.string.cs.conversationsPopoverArchive = 'Archivovat';
z.string.cs.conversationsPopoverCancel = 'Zrušit žádost';
z.string.cs.conversationsPopoverNotify = 'Zapnout zvuk';
z.string.cs.conversationsPopoverSilence = 'Ztlumit';
z.string.cs.conversationsPopoverUnarchive = 'Obnovit';

z.string.cs.conversationsSecondaryLineEphemeralMessage = 'Vám poslal zprávu';
z.string.cs.conversationsSecondaryLinePeopleLeft = '{{number}} lidí opustilo konverzaci';
z.string.cs.conversationsSecondaryLinePersonLeft = '{{user}} opustil(a) konverzaci';
z.string.cs.conversationsSecondaryLinePersonRemoved = '{{user}} byl odebrán';
z.string.cs.conversationsSecondaryLinePeopleAdded = '{{user}} lidé byli přidáni';
z.string.cs.conversationsSecondaryLinePersonAdded = '{{user}} byl přídán';
z.string.cs.conversationsSecondaryLinePersonAddedYou = '{{user}} vás přidal';
z.string.cs.conversationsSecondaryLineRenamed = '{{user}} přejmenoval konverzaci';
z.string.cs.conversationsSecondaryLineYouLeft = 'Opustil(a) jste konverzaci';
z.string.cs.conversationsSecondaryLineYouWereRemoved = 'Byl(a) jste odebrán(a)';

z.string.cs.takeoverSub = 'Vytvořte si vaše jedinečné jméno na Wire.';
z.string.cs.takeoverLink = 'Dozvědět se více';
z.string.cs.takeoverButtonChoose = 'Vyberte své vlastní';
z.string.cs.takeoverButtonKeep = 'Ponechat tento';

z.string.cs.inviteMetaKeyMac = 'Cmd';
z.string.cs.inviteMetaKeyPc = 'Ctrl';
z.string.cs.inviteHeadline = 'Pozvat lidi do aplikace Wire';
z.string.cs.inviteMessage = 'Jsem na Wire, hledejte {{username}} nebo navštivte get.wire.com.';
z.string.cs.inviteMessageNoEmail = 'Jsem k zastižení na síti Wire. K navázání kontaktu navštivte https://get.wire.com.';

z.string.cs.extensionsBubbleButtonGif = 'Gif';

z.string.cs.extensionsGiphyButtonOk = 'Odeslat';
z.string.cs.extensionsGiphyButtonMore = 'Zkusit jiný';
z.string.cs.extensionsGiphyMessage = '{{tag}} • přes giphy.com';
z.string.cs.extensionsGiphyNoGifs = 'Uups, žádné gify';
z.string.cs.extensionsGiphyRandom = 'Náhodně';

z.string.cs.addParticipantsConfirmLabel = 'Přidat';
z.string.cs.addParticipantsSearchPlaceholder = 'Hledat podle jména';
z.string.cs.addParticipantsTabsPeople = 'Kontakty';
z.string.cs.addParticipantsTabsServices = 'Služby';

z.string.cs.conversationDetailsActionArchive = 'Archivovat';
z.string.cs.conversationDetailsActionCancelRequest = 'Zrušit žádost';
z.string.cs.conversationDetailsActionDevices = 'Přístroje';
z.string.cs.conversationDetailsActionNotifications = 'Upozornění';
z.string.cs.conversationDetailsGuestsOff = 'Vypnout';
z.string.cs.conversationDetailsOptions = 'Nastavení';
z.string.cs.conversationDetailsParticipantsServicesMany = 'Služby';
z.string.cs.conversationDetailsParticipantsUsersMany = 'Kontakty';
z.string.cs.conversationDetailsPeople = 'Kontakty';
z.string.cs.conversationDetailsServices = 'Služby';

z.string.cs.conversationParticipantsTitle = 'Kontakty';
z.string.cs.conversationParticipantsSearchPlaceholder = 'Hledat podle jména';

z.string.cs.groupParticipantActionCancelRequest = 'Zrušit žádost';
z.string.cs.groupParticipantActionDevices = 'Přístroje';
z.string.cs.groupParticipantActionPending = 'Nevyřízené';
z.string.cs.groupParticipantActionSendRequest = 'Připojit';

z.string.cs.notificationSettingsTitle = 'Upozornění';

z.string.cs.participantDevicesDetailHeadline = 'Ověřte, že to odpovídá identifikátoru zobrazeném na {{html1}}uživatele {{user}}{{html2}}.';
z.string.cs.participantDevicesDetailHowTo = 'Jak to mám udělat?';
z.string.cs.participantDevicesDetailResetSession = 'Resetovat sezení';
z.string.cs.participantDevicesDetailShowMyDevice = 'Zorazit identifikátor mého přístroje';
z.string.cs.participantDevicesDetailVerify = 'Ověreno';

z.string.cs.participantDevicesHeader = 'Přístroje';
z.string.cs.participantDevicesHeadline = 'Wire přiřazuje každému přístroji jedinečný identifikátor. Porovnejte je s {{user}} a ověřte svou konverzaci.';
z.string.cs.participantDevicesLearnMore = 'Dozvědět se více';
z.string.cs.participantDevicesWhyVerify = 'Proč mám ověřovat konverzaci?';
z.string.cs.participantDevicesOutdatedClientMessage = '{{user}} používá starší verzi aplikace Wire. Nejsou zde zobrazeny žádné přístroje.';

z.string.cs.participantDevicesSelfAllDevices = 'Zobrazit všechny mé přístroje';
z.string.cs.participantDevicesSelfFingerprint = 'Identifikátor přístoje';

z.string.cs.userProfileButtonConnect = 'Připojit';
z.string.cs.userProfileButtonIgnore = 'Ignorovat';
z.string.cs.userProfileButtonUnblock = 'Odblokovat';

z.string.cs.preferencesAbout = 'O aplikaci';
z.string.cs.preferencesAccount = 'Účet';
z.string.cs.preferencesAV = 'Audio / Video';
z.string.cs.preferencesDeviceDetails = 'Podrobnosti o přístroji';
z.string.cs.preferencesDevices = 'Přístroje';
z.string.cs.preferencesHeadline = 'Předvolby';
z.string.cs.preferencesOptions = 'Nastavení';

z.string.cs.preferencesAboutPrivacyPolicy = 'Ochrana osobních údajů';
z.string.cs.preferencesAboutSupport = 'Podpora';
z.string.cs.preferencesAboutSupportWebsite = 'Webové stránky podpory';
z.string.cs.preferencesAboutSupportContact = 'Kontaktovat podporu';
z.string.cs.preferencesAboutTermsOfUse = 'Podmínky používání';
z.string.cs.preferencesAboutVersion = 'Verze {{version}}';
z.string.cs.preferencesAboutWebsite = 'Wire webové stránky';

z.string.cs.preferencesAccountCreateTeam = 'Vytvořit tým';
z.string.cs.preferencesAccountDelete = 'Smazat účet';
z.string.cs.preferencesAccountLogOut = 'Odhlásit se';
z.string.cs.preferencesAccountManageTeam = 'Spravovat tým';
z.string.cs.preferencesAccountResetPassword = 'Resetovat heslo';
z.string.cs.preferencesAccountTeam = 'v {{name}}';
z.string.cs.preferencesAccountUsernamePlaceholder = 'Celé jméno';
z.string.cs.preferencesAccountUsernameHint = 'Alespoň 2 znaky. Pouze a—z, 0—9 a _';
z.string.cs.preferencesAccountUsernameAvailable = 'Dostupný';
z.string.cs.preferencesAccountUsernameErrorTaken = 'Již uděleno';

z.string.cs.preferencesAVCamera = 'Kamera';
z.string.cs.preferencesAVMicrophone = 'Mikrofon';
z.string.cs.preferencesAVPermissionDetail = 'Povolte v předvolbách prohlížeče';
z.string.cs.preferencesAVSpeakers = 'Reproduktory';

z.string.cs.preferencesDevicesActivatedOn = 'Aktivováno v {{date}}';
z.string.cs.preferencesDevicesActive = 'Aktivní';
z.string.cs.preferencesDevicesActiveDetail = 'Pokud nepoznáváte přístroj výše, odstraňte ho a změňte své heslo.';
z.string.cs.preferencesDevicesCurrent = 'Aktuální';
z.string.cs.preferencesDevicesFingerprint = 'Identifikátor klíče';
z.string.cs.preferencesDevicesFingerprintDetail = 'Aplikace Wire přiděluje každému přístroji unikátní identifikátor. Jejich porovnáním ověříte své přístroje a konverzace.';
z.string.cs.preferencesDevicesId = 'ID: ';
z.string.cs.preferencesDevicesRemoveCancel = 'Zrušit';
z.string.cs.preferencesDevicesRemoveDetail = 'Jestliže jste přestali používat toto zařízení, odeberte jej. Poté z něj budete okamžitě odhlášeni.';
z.string.cs.preferencesDevicesSessionConfirmation = 'Sezení bylo zresetováno.';
z.string.cs.preferencesDevicesSessionDetail = 'Pokud se identifikátory neshodují, resetujte své sezení pro vygenerování nových klíčů na obou stranách.';
z.string.cs.preferencesDevicesSessionReset = 'Resetovat sezení';
z.string.cs.preferencesDevicesSessionOngoing = 'Obnovení relace…';
z.string.cs.preferencesDevicesVerification = 'Ověreno';

z.string.cs.preferencesOptionsAudio = 'Zvuková upozornění';
z.string.cs.preferencesOptionsAudioAll = 'Vše';
z.string.cs.preferencesOptionsAudioAllDetail = 'Všechny zvuky';
z.string.cs.preferencesOptionsAudioNone = 'Žádné';
z.string.cs.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.cs.preferencesOptionsAudioSome = 'Některé';
z.string.cs.preferencesOptionsAudioSomeDetail = 'Chaty a hovory';
z.string.cs.preferencesOptionsContacts = 'Kontakty';
z.string.cs.preferencesOptionsContactsGmail = 'Importovat ze služby Gmail';
z.string.cs.preferencesOptionsContactsMacos = 'Import z kontaktů';
z.string.cs.preferencesOptionsContactsDetail = 'Vaše údaje o kontaktech používáme k propojení s ostatními uživateli. Všechny informace anonymizujeme a nesdílíme je s nikým dalším.';
z.string.cs.preferencesOptionsPopular = 'Podle popularity poptávky';
z.string.cs.preferencesOptionsEmojiReplaceCheckbox = 'Nahradit psané emotikony pomocí emojis';
z.string.cs.preferencesOptionsPreviewsSendCheckbox = 'Vytvořit náhledy pro odeslané odkazy';
z.string.cs.preferencesOptionsPreviewsSendDetail = 'Náhledy mohou být zobrazeny i pro odkazy od jiných lidí.';
z.string.cs.preferencesOptionsNotifications = 'Upozornění';
z.string.cs.preferencesOptionsNotificationsNone = 'Vypnout';
z.string.cs.preferencesOptionsNotificationsObfuscate = 'Skrýt detaily';
z.string.cs.preferencesOptionsNotificationsObfuscateMessage = 'Zobrazit odesílatele';
z.string.cs.preferencesOptionsNotificationsOn = 'Zobrazit odesílatele a zprávu';

z.string.cs.backupCancel = 'Zrušit';

z.string.cs.searchConnect = 'Připojit';
z.string.cs.searchConnections = 'Kontakty';
z.string.cs.searchContacts = 'Kontakty';
z.string.cs.searchCreateGroup = 'Vytvořit skupinu';
z.string.cs.searchGroups = 'Skupiny';
z.string.cs.searchPeople = 'Kontakty';
z.string.cs.searchPlaceholder = 'Hledat podle jméno nebo uživatelského jméno';
z.string.cs.searchServicePlaceholder = 'Hledat podle jména';
z.string.cs.searchServices = 'Služby';
z.string.cs.searchTeamGroups = 'Týmové konverzace';
z.string.cs.searchTeamMembers = 'Členové týmu';
z.string.cs.searchTopPeople = 'Nejaktivnější kontakty';
z.string.cs.searchTrySearch = 'Vyhledávání osob podle\nvlastního nebo uživatelského jména';
z.string.cs.searchNoContactsOnWire = 'V aplikaci Wire nemáte žádné kontakty.\nZkuste vyhledat kontakty podle jména nebo\nuživatelského jména.';
z.string.cs.searchOthers = 'Připojit';

z.string.cs.searchInvite = 'Pozvat lidi do aplikace Wire';
z.string.cs.searchInviteDetail = 'Sdílením svých kontaktů si zjednodušíte propojení s ostatními. Všechny informace anonymizujeme a nikdy je neposkytujeme nikomu dalšímu.';
z.string.cs.searchInviteButtonContacts = 'Z kontaktů';
z.string.cs.searchInviteButtonGmail = 'Z Gmailu';
z.string.cs.searchInviteHeadline = 'Přiveďte své přátele';
z.string.cs.searchInviteShare = 'Sdílet kontakty';

z.string.cs.searchListEveryoneParticipates = 'Všichni, které znáte\njsou již připojeni\nk této konverzaci.';
z.string.cs.searchListNoMatches = 'Žádné odpovídající výsledky.\nZkuste jiné jméno.';


z.string.cs.uploadGoogleHeadline = 'Najít kontakty\npro konverzaci.';
z.string.cs.uploadGoogleMessage = 'Vaše údaje o kontaktech používáme k propojení s ostatními uživateli. Všechny informace anonymizujeme a nesdílíme je s nikým dalším.';

z.string.cs.warningCallUnsupportedIncoming = 'Volá {{user}}. Tento prohlížeč nepodporuje volání.';
z.string.cs.warningCallUnsupportedOutgoing = 'Nemůžete volat, protože prohlížeč nepodporuje volání.';
z.string.cs.warningCallIssues = 'Tato verze aplikace Wire se nemůže účastnit volání. Použijte prosím';
z.string.cs.warningCallUpgradeBrowser = 'Pro volání prosím aktualizujte Google Chrome.';
z.string.cs.warningConnectivityConnectionLost = 'Pokoušíme se o připojení. Wire nemusí být schopen doručit zprávy.';
z.string.cs.warningConnectivityNoInternet = 'Chybí připojení k internetu. Nebudete moci odesílat ani přijímat zprávy.';
z.string.cs.warningLearnMore = 'Dozvědět se více';
z.string.cs.warningLifecycleUpdate = 'Je dostupná nová verze aplikace Wire.';
z.string.cs.warningLifecycleUpdateNotes = 'Co je nového';
z.string.cs.warningLifecycleUpdateLink = 'Aktualizovat nyní';
z.string.cs.warningNotFoundCamera = 'Nelze volat, protože tento počítač nemá kameru.';
z.string.cs.warningNotFoundMicrophone = 'Nelze volat, protože tento počítač nemá mikrofon.';
z.string.cs.warningPermissionDeniedCamera = 'Nelze volat, protože prohlížeč nemá přístup ke kameře.';
z.string.cs.warningPermissionDeniedMicrophone = 'Nelze volat, protože prohlížeč nemá přístup k mikrofonu.';
z.string.cs.warningPermissionDeniedScreen = 'Prohlížeč potřebuje oprávnění ke sdílení obrazovku.';
z.string.cs.warningPermissionRequestCamera = '{{icon}} Povolit přístup ke kameře';
z.string.cs.warningPermissionRequestMicrophone = '{{icon}} Povolit přístup k mikrofonu';
z.string.cs.warningPermissionRequestNotification = '{{icon}} Povolit upozornění';
z.string.cs.warningPermissionRequestScreen = '{{icon}} Povolit přístup k obrazovce';

z.string.cs.userAvailabilityAvailable = 'Dostupný';
z.string.cs.userAvailabilityNone = 'Žádné';

z.string.cs.notificationAssetAdd = 'Sdílel(a) obrázek';
z.string.cs.notificationConnectionAccepted = 'Přijal(a) váš požadavek na připojení';
z.string.cs.notificationConnectionConnected = 'Nyní jste připojeni';
z.string.cs.notificationConnectionRequest = 'Žádá o připojení';
z.string.cs.notificationConversationCreate = '{{user}} zahájil(a) rozhovor';
z.string.cs.notificationConversationRename = '{{user}} přejmenoval(a) rozhovor na {{name}}';
z.string.cs.notificationMemberJoinMany = '{{user}} přidal(a) {{number}} kontakty do konverzace';
z.string.cs.notificationMemberJoinOne = '{{user1}} přidal(a) {{user2}} do konverzace';
z.string.cs.notificationMemberLeaveRemovedYou = '{{user}} tě odebral(a) z konverzace';
z.string.cs.notificationObfuscated = 'Vám poslal zprávu';
z.string.cs.notificationObfuscatedTitle = 'Někdo';
z.string.cs.notificationPing = 'Pingnut';
z.string.cs.notificationReaction = '{{reaction}} tvou zprávu';
z.string.cs.notificationSharedAudio = 'Sdílel(a) zvukovou zprávu';
z.string.cs.notificationSharedFile = 'Sdílel(a) soubor';
z.string.cs.notificationSharedLocation = 'Sdílel(a) polohu';
z.string.cs.notificationSharedVideo = 'Sdílel(a) video';
z.string.cs.notificationVoiceChannelActivate = 'Volá';
z.string.cs.notificationVoiceChannelDeactivate = 'Volal(a)';

z.string.cs.tooltipConversationAllVerified = 'Všechny identifikátory jsou ověřeny';
z.string.cs.tooltipConversationCall = 'Hovor';
z.string.cs.tooltipConversationEphemeral = 'Časované zprávy';
z.string.cs.tooltipConversationFile = 'Přidat soubor';
z.string.cs.tooltipConversationInputPlaceholder = 'Napsat zprávu';
z.string.cs.tooltipConversationPeople = 'Kontakty ({{shortcut}})';
z.string.cs.tooltipConversationPicture = 'Přidat obrázek';
z.string.cs.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.cs.tooltipConversationSearch = 'Hledat';
z.string.cs.tooltipConversationVideoCall = 'Videohovor';

z.string.cs.tooltipConversationsArchive = 'Archivovat ({{shortcut}})';
z.string.cs.tooltipConversationsArchived = 'Zobrazit archiv ({{number}})';
z.string.cs.tooltipConversationsMore = 'Další';
z.string.cs.tooltipConversationsNotify = 'Zapnout zvuk ({{shortcut}})';
z.string.cs.tooltipConversationsPreferences = 'Otevřít předvolby';
z.string.cs.tooltipConversationsSilence = 'Ztlumit ({{shortcut}})';
z.string.cs.tooltipConversationsStart = 'Spustit konverzaci ({{shortcut}})';

z.string.cs.tooltipConversationDetailsRename = 'Změnit název konverzace';

z.string.cs.tooltipPreferencesContactsGmail = 'Přihlaste se ke svému Gmail účtu pro sdílení kontaktů';
z.string.cs.tooltipPreferencesContactsMacos = 'Sdílejte všechny své kontakty z aplikace kontaktů systému macOS';
z.string.cs.tooltipPreferencesPassword = 'Pro změnu hesla otevřete další webovou stránku';
z.string.cs.tooltipPreferencesPicture = 'Změnit obrázek…';
z.string.cs.tooltipPreferencesRename = 'Změnit jméno';

z.string.cs.tooltipSearchClose = 'Zavřít (Esc)';

z.string.cs.initReceivedSelfUser = 'Ahoj, {{user}}.';
z.string.cs.initReceivedUserData = 'Kontrola nových zpráv';
z.string.cs.initDecryption = 'Dešifrovat zprávu';
z.string.cs.initEvents = 'Zprávy se načítají';

z.string.cs.ephemeralUnitsNone = 'Vypnout';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.da.wireMacos = 'Wire til macOS';
z.string.da.wireWindows = 'Wire til Windows';
z.string.da.wireLinux = 'Wire til Linux';
z.string.da.nonexistentUser = 'Slet bruger';
z.string.da.and = 'og';
z.string.da.enumerationAnd = ', og ';

z.string.da.authAccountCountryCode = 'Landekode';
z.string.da.authAccountPasswordForgot = 'Glemt adgangskode';
z.string.da.authAccountPublicComputer = 'Dette er en offentlig computer';
z.string.da.authAccountSignIn = 'Log ind';
z.string.da.authAccountSignInPhone = 'Telefon';

z.string.da.authBlockedCookies = 'Aktiver cookies for at logge på Wire.';
z.string.da.authBlockedDatabase = 'Wire skal have adgang til lokal lagring til at vise dine meddelelser. Lokal lagring er ikke tilgængelig i privat tilstand.';
z.string.da.authBlockedTabs = 'Wire er allerede åben i en anden fane.';
z.string.da.authBlockedTabsAction = 'Brug denne fane i stedet';

z.string.da.authVerifyAccountAdd = 'Tilføj';
z.string.da.authVerifyAccountDetail = 'Dette gør, at du kan bruge Wire på flere enheder.';
z.string.da.authVerifyAccountHeadline = 'Tilføj email adresse og adgangskode.';
z.string.da.authVerifyAccountLogout = 'Log ud';
z.string.da.authVerifyCodeDescription = 'Indtast bekræftelseskoden vi sendte til {{number}}.';
z.string.da.authVerifyCodeResend = 'Ingen kode vist?';
z.string.da.authVerifyCodeResendDetail = 'Gensend';
z.string.da.authVerifyCodeResendTimer = 'Du kan anmode om en ny kode {{expiration}}.';
z.string.da.authVerifyCodeChangePhone = 'Ændre telefon nummer';
z.string.da.authVerifyPasswordHeadline = 'Indtast din adgangskode';

z.string.da.authLimitDevicesHeadline = 'Enheder';
z.string.da.authLimitDescription = 'Fjern en af dine andre enheder for at begynde at bruge Wire på denne.';
z.string.da.authLimitButtonManage = 'Administrér enheder';
z.string.da.authLimitButtonSignOut = 'Log ud';
z.string.da.authLimitDevicesCurrent = '(Nuværende)';

z.string.da.authHistoryHeadline = 'Det er første gang du bruger Wire på denne enhed.';
z.string.da.authHistoryDescription = 'Af hensyn til fortrolighed, vil din chathistorik ikke vises her.';
z.string.da.authHistoryReuseHeadline = 'Du har brugt Wire på denne enhed før.';
z.string.da.authHistoryReuseDescription = 'Beskeder sendt i mellemtiden vises ikke.';
z.string.da.authHistoryButton = 'OK';

z.string.da.authPostedResend = 'Gensend til {{email}}';
z.string.da.authPostedResendAction = 'Ingen email modtaget?';
z.string.da.authPostedResendDetail = 'Tjek din email indbakke og følg anvisningerne.';
z.string.da.authPostedResendHeadline = 'Du har post.';

z.string.da.authPlaceholderEmail = 'Email';
z.string.da.authPlaceholderPasswordPut = 'Adgangskode';
z.string.da.authPlaceholderPasswordSet = 'Adgangskode (mindst 8 tegn)';
z.string.da.authPlaceholderPhone = 'Telefon Nummer';

z.string.da.authErrorCode = 'Ugyldig Kode';
z.string.da.authErrorCountryCodeInvalid = 'Ugyldig Lande Kode';
z.string.da.authErrorEmailExists = 'Email adresse allerede brugt';
z.string.da.authErrorEmailForbidden = 'Beklager. Denne email adresse er forbudt.';
z.string.da.authErrorEmailMalformed = 'Indtast venligst en gyldig email adresse.';
z.string.da.authErrorEmailMissing = 'Indtast venligst en e-mailadresse.';
z.string.da.authErrorMisc = 'Problemer med forbindelsen. Prøv venligst igen.';
z.string.da.authErrorNameShort = 'Indtast et navn på mindst to karakterer';
z.string.da.authErrorOffline = 'Ingen internetforbindelse';
z.string.da.authErrorPasswordShort = 'Vælg en adgangskode på mindst 8 karakterer.';
z.string.da.authErrorPasswordWrong = 'Forkert adgangskode. Prøv igen.';
z.string.da.authErrorPending = 'Kontoen er ikke bekræftet endnu';
z.string.da.authErrorPhoneNumberBudget = 'Du har logget ind alt for ofte. Prøv igen senere.';
z.string.da.authErrorPhoneNumberForbidden = 'Beklager. Dette telefonnummer er ikke tilladt.';
z.string.da.authErrorPhoneNumberInvalid = 'Ugyldigt telefonnummer';
z.string.da.authErrorPhoneNumberUnknown = 'Ukendt telefonnummer';
z.string.da.authErrorSuspended = 'Denne konto har ikke længere tilladelse til at logge ind.';
z.string.da.authErrorSignIn = 'Bekræft venligst dine detaljer og prøv igen.';

z.string.da.callStateOutgoing = 'Ringer op…';
z.string.da.callStateConnecting = 'Forbinder…';
z.string.da.callStateIncoming = 'Ringer op…';
z.string.da.callDecline = 'Afvis';
z.string.da.callAccept = 'Besvar';
z.string.da.callJoin = 'Deltag';
z.string.da.callChooseSharedScreen = 'Vælg en skærm som du vil dele';
z.string.da.callParticipants = '{{number}} i samtalen';

z.string.da.videoCallOverlayMute = 'Stum samtale';
z.string.da.videoCallOverlayHangUp = 'Læg På';

z.string.da.modalAcknowledgeAction = 'Ok';
z.string.da.modalAcknowledgeHeadline = 'Noget gik galt';
z.string.da.modalConfirmSecondary = 'Annuller';
z.string.da.modalOptionSecondary = 'Annuller';

z.string.da.modalAccountCreateAction = 'OK';
z.string.da.modalAccountCreateHeadline = 'Opret en konto?';
z.string.da.modalAccountCreateMessage = 'Ved at oprette en konto vil du miste samtaleoversigten i dette gæsterum.';

z.string.da.modalAccountDeletionAction = 'Slet';
z.string.da.modalAccountDeletionHeadline = 'Slet konto';
z.string.da.modalAccountDeletionMessage = 'Vi vil sende dig en besked via email eller SMS. Følg linket for at permanent slette din konto.';

z.string.da.modalAccountLeaveGuestRoomAction = 'Forlad';
z.string.da.modalAccountLeaveGuestRoomHeadline = 'Forlade gæsterummet?';
z.string.da.modalAccountLeaveGuestRoomMessage = 'Samtaleoversigten vil blive slettet. For at beholde det, oprett en konto næste gang.';

z.string.da.modalAccountLogoutAction = 'Log ud';
z.string.da.modalAccountLogoutHeadline = 'Ryd Data?';
z.string.da.modalAccountLogoutOption = 'Slet alle dine personlige informationer og samtaler på denne enhed.';

z.string.da.modalAccountNewDevicesSecondary = 'Administrér enheder';
z.string.da.modalAccountNewDevicesHeadline = 'Din konto blev brugt på:';
z.string.da.modalAccountNewDevicesFrom = 'Fra:';
z.string.da.modalAccountNewDevicesMessage = 'Hvis du ikke gjorde dette, slet enheden og nulstil din adgangskode.';

z.string.da.modalAccountRemoveDeviceAction = 'Fjern enhed';
z.string.da.modalAccountRemoveDeviceHeadline = 'Fjern "{{device}}"';
z.string.da.modalAccountRemoveDeviceMessage = 'Din adgangskode er krævet for at fjerne denne enhed.';
z.string.da.modalAccountRemoveDevicePlaceholder = 'Adgangskode';

z.string.da.modalAssetTooLargeHeadline = 'Filen er for stor';
z.string.da.modalAssetTooLargeMessage = 'Du kan sende filer med størrelse op til {{number}}';

z.string.da.modalAssetParallelUploadsHeadline = 'Alt for mange filer på en gang';
z.string.da.modalAssetParallelUploadsMessage = 'Du kan sende op til {{number}} filer på én gang.';

z.string.da.modalCallEmptyConversationHeadline = 'Ingen at ringe til';
z.string.da.modalCallEmptyConversationMessage = 'Der er ingen tilbage her.';

z.string.da.modalCallNoGroupVideoHeadline = 'Ingen video opkald i grupper';
z.string.da.modalCallNoGroupVideoMessage = 'Video opkald er ikke tilgængelig i gruppe samtaler.';

z.string.da.modalCallNoMicrophoneAction = 'Fortæl mig hvordan';
z.string.da.modalCallNoMicrophoneMessage = 'Din browser skal have adgang til mikrofonen for at foretage opkald.';
z.string.da.modalCallNoMicrophoneHeadline = 'Kan ikke ringe uden mikrofon';

z.string.da.modalCallSecondIncomingAction = 'Besvar';
z.string.da.modalCallSecondIncomingHeadline = 'Besvar opkald?';
z.string.da.modalCallSecondIncomingMessage = 'Dit nuværende opkald vil afsluttes.';

z.string.da.modalCallSecondOngoingAction = 'Læg På';
z.string.da.modalCallSecondOngoingHeadline = 'Læg på fra en anden enhed?';
z.string.da.modalCallSecondOngoingMessage = 'Du kan kun være i et opkald af gangen.';

z.string.da.modalCallSecondOutgoingAction = 'Læg På';
z.string.da.modalCallSecondOutgoingHeadline = 'Læg nuværende opkald på?';
z.string.da.modalCallSecondOutgoingMessage = 'Du kan kun være i et opkald af gangen.';

z.string.da.modalConnectCancelAction = 'Ja';
z.string.da.modalConnectCancelHeadline = 'Annuller anmodning?';
z.string.da.modalConnectCancelMessage = 'Fjern anmodning om forbindelse til {{user}}.';
z.string.da.modalConnectCancelSecondary = 'Nej';

z.string.da.modalConnectAcceptAction = 'Forbind';
z.string.da.modalConnectAcceptHeadline = 'Acceptér?';
z.string.da.modalConnectAcceptMessage = 'Dette vil forbinde jer og åbne en samtale med {{user}}.';
z.string.da.modalConnectAcceptSecondary = 'Ignorér';

z.string.da.modalConversationClearAction = 'Slet';
z.string.da.modalConversationClearHeadline = 'Slet indhold?';
z.string.da.modalConversationClearMessage = 'Dette vil fjerne samtaleoversigten på alle dine enheder.';
z.string.da.modalConversationClearOption = 'Forlad også samtalen';

z.string.da.modalConversationDeleteMessageAction = 'Slet';
z.string.da.modalConversationDeleteMessageHeadline = 'Slet kun for mig?';
z.string.da.modalConversationDeleteMessageMessage = 'Dette kan ikke fortrydes.';

z.string.da.modalConversationDeleteMessageEveryoneAction = 'Slet';
z.string.da.modalConversationDeleteMessageEveryoneHeadline = 'Slet for alle?';
z.string.da.modalConversationDeleteMessageEveryoneMessage = 'Dette kan ikke fortrydes.';

z.string.da.modalConversationLeaveAction = 'Forlad';
z.string.da.modalConversationLeaveHeadline = 'Forlad {{name}} samtale?';
z.string.da.modalConversationLeaveMessage = 'Du vil ikke være i stand til at sende og modtage beskeder i denne samtale.';

z.string.da.modalConversationMessageTooLongHeadline = 'Besked for lang';
z.string.da.modalConversationMessageTooLongMessage = 'Du kan sende beskeder på op til {{number}} tegn.';

z.string.da.modalConversationNewDeviceAction = 'Send alligevel';
z.string.da.modalConversationNewDeviceHeadlineOne = '{{user}} er begyndt at bruge en ny enhed';
z.string.da.modalConversationNewDeviceHeadlineMany = '{{user}}s er begyndt at bruge nye enheder';
z.string.da.modalConversationNewDeviceHeadlineYou = '{{user}} er begyndt at bruge en ny enhed';
z.string.da.modalConversationNewDeviceIncomingCallAction = 'Besvar opkald';
z.string.da.modalConversationNewDeviceIncomingCallMessage = 'Vil du stadig besvare opkaldet?';
z.string.da.modalConversationNewDeviceMessage = 'Vil du stadig sende dine beskeder?';
z.string.da.modalConversationNewDeviceOutgoingCallAction = 'Ring alligevel';
z.string.da.modalConversationNewDeviceOutgoingCallMessage = 'Vil du stadig placere opkaldet?';

z.string.da.modalConversationNotConnectedHeadline = 'Ingen tilføjet til samtale';
z.string.da.modalConversationNotConnectedMessageOne = '{{name}} vil ikke tilføjes til samtalen.';
z.string.da.modalConversationNotConnectedMessageMany = 'En af de valgte personer vil ikke tilføjes til samtalen.';

z.string.da.modalConversationRemoveAction = 'Fjern';
z.string.da.modalConversationRemoveHeadline = 'Fjern?';
z.string.da.modalConversationRemoveMessage = '{{user}} vil ikke være i stand til at sende eller modtage beskeder i denne samtale.';

z.string.da.modalConversationRemoveGuestsAction = 'Fjern gæster';
z.string.da.modalConversationRemoveGuestsHeadline = 'At deaktivere gæsteadgang?';
z.string.da.modalConversationRemoveGuestsMessage = 'Aktuel gæst vil blive fjernet fra samtalen. Nye gæster vil ikke være tilladt.';

z.string.da.modalConversationRevokeLinkAction = 'Tilbagekalde link';
z.string.da.modalConversationRevokeLinkHeadline = 'Tilbagekalde linket?';
z.string.da.modalConversationRevokeLinkMessage = 'Nye gæster vil ikke kunne tilslutte med dette link. Aktuelle gæster vil stadig have adgang.';

z.string.da.modalConversationGuestOptionsAllowGuestMessage = 'Kunne ikke tillade gæster. Prøv venligst igen.';
z.string.da.modalConversationGuestOptionsDisableGuestMessage = 'Gæsterne kunne ikke fjernes. Prøv venligst igen.';
z.string.da.modalConversationGuestOptionsGetCodeMessage = 'Kunne ikke få adgangslink.';
z.string.da.modalConversationGuestOptionsRequestCodeMessage = 'Kunne ikke anmode om adgangslink. Prøv venligst igen.';
z.string.da.modalConversationGuestOptionsRevokeCodeMessage = 'Kunne ikke tilbagekalde adgangslink. Prøv venligst igen.';
z.string.da.modalConversationGuestOptionsToggleGuestsMessage = 'Kunne ikke ændre gæsterne tilstand.';

z.string.da.modalConversationTooManyMembersHeadline = 'Fuldt hus';
z.string.da.modalConversationTooManyMembersMessage = 'Op til {{number1}} personer kan deltage i en samtale. I øjeblikket er der kun plads til {{number2}} mere.';

z.string.da.modalGifTooLargeHeadline = 'Valgte animation er for stor';
z.string.da.modalGifTooLargeMessage = 'Maksimale størrelse er {{number}} MB.';

z.string.da.modalIntegrationUnavailableHeadline = 'Bots er ikke tilgængelig i øjeblikket';
z.string.da.modalIntegrationUnavailableMessage = 'Tak for din interesse for bots. Tjenesten er i øjeblikket suspenderet, mens vi arbejder på den næste version. Bliv her.';

z.string.da.modalPictureFileFormatHeadline = 'Kan ikke bruge dette billede';
z.string.da.modalPictureFileFormatMessage = 'Vælg venligst en PNG eller JPEG-fil.';

z.string.da.modalPictureTooLargeHeadline = 'Valgte billede er for stor';
z.string.da.modalPictureTooLargeMessage = 'Du kan bruge billeder op til {{number}} MB.';

z.string.da.modalPictureTooSmallHeadline = 'Billede for lille';
z.string.da.modalPictureTooSmallMessage = 'Vælg venligst et billede, der er mindst 320 x 320 px.';

z.string.da.modalImproveWireAction = 'Besvar';
z.string.da.modalImproveWireSecondary = 'Nej';

z.string.da.modalServiceUnavailableHeadline = 'Tilføje tjeneste ikke muligt';
z.string.da.modalServiceUnavailableMessage = 'Tjenesten er utilgængelig i øjeblikket.';

z.string.da.modalSessionResetHeadline = 'Sessionen er blevet nulstillet';
z.string.da.modalSessionResetMessage1 = 'Hvis problemet ikke er løst,';
z.string.da.modalSessionResetMessageLink = 'kontakt';
z.string.da.modalSessionResetMessage2 = 'os.';

z.string.da.modalUploadContactsAction = 'Prøv igen';
z.string.da.modalUploadContactsMessage = 'Vi har ikke modtaget dine oplysninger. Venligst prøv at importere dine kontakter igen.';

z.string.da.modalUserBlockAction = 'Blokér';
z.string.da.modalUserBlockHeadline = 'Blokkér {{user}}?';
z.string.da.modalUserBlockMessage = '{{user}} vil ikke kunne kontakte dig eller tilføje dig til gruppesamtaler.';

z.string.da.modalUserUnblockAction = 'Fjern Blokering';
z.string.da.modalUserUnblockHeadline = 'Fjern Blokering?';
z.string.da.modalUserUnblockMessage = '{{user}} vil igen kunne kontakte dig og tilføje dig til gruppesamtaler.';

z.string.da.connectionRequestConnect = 'Forbind';
z.string.da.connectionRequestIgnore = 'Ignorér';

z.string.da.conversationGuestIndicator = 'Gæst';
z.string.da.userRemainingTimeHours = '{{time}}t tilbage';
z.string.da.userRemainingTimeMinutes = 'Mindre end {{time}}m tilbage';

z.string.da.conversationYouNominative = 'dig';
z.string.da.conversationYouDative = 'dig';
z.string.da.conversationYouAccusative = 'dig';

z.string.da.conversationConnectionAccepted = 'Forbundet';
z.string.da.conversationConnectionBlocked = 'Blokeret';
z.string.da.conversationConnectionCancelRequest = 'Annullér anmodning om forbindelse';
z.string.da.conversationCreateTemporary = 'Du tilsluttede dig til samtalen';
z.string.da.conversationCreateWith = 'med {{users}}';
z.string.da.conversationDeviceStartedUsingOne = ' begyndte at bruge';
z.string.da.conversationDeviceStartedUsingMany = ' begyndte at bruge';
z.string.da.conversationDeviceUnverified = ' har afbekræftet en af';
z.string.da.conversationDeviceYourDevices = ' dine enheder';
z.string.da.conversationDeviceUserDevices = ' {{user}}’s enheder';
z.string.da.conversationDeviceNewDeviceOne = ' en ny enhed';
z.string.da.conversationDeviceNewDeviceMany = ' nye enheder';
z.string.da.conversationDeviceNewPeopleJoined = 'Nye mennesker tilsluttede.';
z.string.da.conversationDeviceNewPeopleJoinedVerify = ' verificer enheder';
z.string.da.conversationJustNow = 'Lige nu';
z.string.da.conversationLocationLink = 'Åben Kort';
z.string.da.conversationMessageDelivered = 'Leveret';
z.string.da.conversationRename = ' omdøbte samtalen';
z.string.da.conversationRenameYou = ' omdøbte samtalen';
z.string.da.conversationResume = 'Start en samtale med {{users}}';
z.string.da.conversationPing = ' pingede';
z.string.da.conversationPingYou = ' pingede';
z.string.da.conversationToday = 'i dag';
z.string.da.conversationVoiceChannelDeactivate = ' ringede';
z.string.da.conversationVoiceChannelDeactivateYou = ' ringede';
z.string.da.conversationYesterday = 'I går';
z.string.da.conversationUnableToDecrypt1 = 'en besked fra {{user}} blev ikke modtaget.';
z.string.da.conversationUnableToDecrypt2 = '{{user}}’s enheds identitet er ændret. Uleveret besked.';
z.string.da.conversationUnableToDecryptLink = 'Hvorfor?';
z.string.da.conversationUnableToDecryptErrorMessage = 'Fejl';
z.string.da.conversationUnableToDecryptResetSession = 'Nulstil session';
z.string.da.conversationMissedMessages = 'Du har ikke brugt denne enhed i et stykke tid. Nogle meddelelser vises måske ikke her.';
z.string.da.conversationAssetUploading = 'Uploader…';
z.string.da.conversationAssetDownloading = 'Downloader…';
z.string.da.conversationAssetUploadFailed = 'Upload Mislykkedes';
z.string.da.conversationPlaybackError = 'Ikke i stand til at afspille';
z.string.da.conversationContextMenuCopy = 'Kopiér';
z.string.da.conversationContextMenuEdit = 'Redigér';
z.string.da.conversationContextMenuDelete = 'Slet for mig';
z.string.da.conversationContextMenuDeleteEveryone = 'Slet for alle';
z.string.da.conversationContextMenuDownload = 'Download';
z.string.da.conversationContextMenuLike = 'Synes Om';
z.string.da.conversationContextMenuUnlike = 'Synes Ikke Om';
z.string.da.conversationDeleteTimestamp = 'Slettet på {{date}}';
z.string.da.conversationEditTimestamp = 'Redigeret på {{date}}';
z.string.da.conversationLikesCaption = '{{number}} personer';
z.string.da.conversationSendPastedFile = 'Indsatte billede d. {{date}}';
z.string.da.conversationSomeone = 'Nogen';
z.string.da.conversationTweetAuthor = ' på Twitter';

z.string.da.groupCreationPreferencesAction = 'Næste';
z.string.da.groupCreationPreferencesErrorNameShort = 'Mindst 1 tegn';
z.string.da.groupCreationPreferencesErrorNameLong = 'For mange tegn';
z.string.da.groupCreationPreferencesHeader = 'Opret gruppe';
z.string.da.groupCreationPreferencesPlaceholder = 'Gruppenavn';
z.string.da.groupCreationParticipantsActionCreate = 'Færdig';
z.string.da.groupCreationParticipantsActionSkip = 'Spring over';
z.string.da.groupCreationParticipantsHeader = 'Tilføj personer';
z.string.da.groupCreationParticipantsHeaderWithCounter = 'Tilføj personer ({{number}})';
z.string.da.groupCreationParticipantsPlaceholder = 'Søg ved navn';

z.string.da.guestRoomConversationName = 'Gæsterum';
z.string.da.guestRoomToggleName = 'Tillad gæster';
z.string.da.guestRoomToggleInfo = 'Åbn denne samtale for personer uden for dit team.';
z.string.da.guestRoomToggleInfoExtended = 'Åbn denne samtale for personer uden for dit team. Du kan altid ændre det senere.';

z.string.da.guestRoomConversationBadge = 'Gæster er til stede';

z.string.da.guestRoomConversationHead = 'Folk uden for dit team kan deltage i denne samtale.';
z.string.da.guestRoomConversationButton = 'Inviter personer';

z.string.da.collectionShowAll = 'Vis alle {{number}}';
z.string.da.collectionSectionLinks = 'Links';
z.string.da.collectionSectionImages = 'Billeder';
z.string.da.collectionSectionFiles = 'Filer';
z.string.da.collectionSectionAudio = 'Lydbeskeder';

z.string.da.fullsearchPlaceholder = 'Søg i tekstbeskeder';
z.string.da.fullsearchNoResults = 'Ingen resultater.';

z.string.da.archiveHeader = 'Arkivér';

z.string.da.conversationsAllArchived = 'Alt arkiveret';
z.string.da.conversationsContacts = 'Kontakter';
z.string.da.conversationsConnectionRequestMany = '{{number}} personer venter';
z.string.da.conversationsConnectionRequestOne = '1 person venter';
z.string.da.conversationsEmptyConversation = 'Gruppesamtale';
z.string.da.conversationsNoConversations = 'Ingen samtaler';
z.string.da.conversationsPopoverArchive = 'Arkiver samtale';
z.string.da.conversationsPopoverBlock = 'Bloker kontakt…';
z.string.da.conversationsPopoverCancel = 'Annuller anmodning';
z.string.da.conversationsPopoverClear = 'Slet indhold…';
z.string.da.conversationsPopoverLeave = 'Forlad gruppen…';
z.string.da.conversationsPopoverNotify = 'Lyd til samtale';
z.string.da.conversationsPopoverSilence = 'Stum samtale';
z.string.da.conversationsPopoverUnarchive = 'Genopret samtale';

z.string.da.conversationsSecondaryLineEphemeralMessage = 'Sendte dig en besked';
z.string.da.conversationsSecondaryLinePeopleLeft = '{{number}} personer forlod';
z.string.da.conversationsSecondaryLinePersonLeft = '{{user}} forlod';
z.string.da.conversationsSecondaryLinePersonRemoved = '{{user}} blev fjernet';
z.string.da.conversationsSecondaryLinePersonRemovedTeam = '{{user}} blev fjernet fra teamet';
z.string.da.conversationsSecondaryLinePeopleAdded = '{{user}} personer blev tilføjet';
z.string.da.conversationsSecondaryLinePersonAdded = '{{user}} blev tilføjet';
z.string.da.conversationsSecondaryLinePersonAddedSelf = '{{user}} tilsluttede';
z.string.da.conversationsSecondaryLinePersonAddedYou = '{{user}} har tilføjet dig';
z.string.da.conversationsSecondaryLineRenamed = '{{user}} omdøbte samtalen';
z.string.da.conversationsSecondaryLineYouLeft = 'Du forlod';
z.string.da.conversationsSecondaryLineYouWereRemoved = 'Du blev fjernet';

z.string.da.takeoverSub = 'Vælg dit unikke navn på Wire.';
z.string.da.takeoverLink = 'Lær mere';
z.string.da.takeoverButtonChoose = 'Vælg dit eget';
z.string.da.takeoverButtonKeep = 'Behold denne';

z.string.da.inviteMetaKeyMac = 'Cmd';
z.string.da.inviteMetaKeyPc = 'Ctrl';
z.string.da.inviteHintSelected = 'Tryk {{metaKey}} + C for at kopiere';
z.string.da.inviteHintUnselected = 'Vælg og tryk på {{metaKey}} + C';
z.string.da.inviteHeadline = 'Inviter personer til Wire';
z.string.da.inviteMessage = 'Jeg er på Wire, søg efter {{username}} eller besøg get.wire.com.';
z.string.da.inviteMessageNoEmail = 'Jeg er på Wire. Besøg get.wire.com for at forbinde dig med mig.';

z.string.da.extensionsBubbleButtonGif = 'Gif';

z.string.da.extensionsGiphyButtonOk = 'Send';
z.string.da.extensionsGiphyButtonMore = 'Prøv en anden';
z.string.da.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.da.extensionsGiphyNoGifs = 'Ups, ingen gifs';
z.string.da.extensionsGiphyRandom = 'Tilfældig';

z.string.da.addParticipantsConfirmLabel = 'Tilføj';
z.string.da.addParticipantsHeader = 'Tilføj personer';
z.string.da.addParticipantsHeaderWithCounter = 'Tilføj personer ({{number}})';
z.string.da.addParticipantsSearchPlaceholder = 'Søg ved navn';
z.string.da.addParticipantsServiceConfirmButton = 'Tilføj tjeneste';
z.string.da.addParticipantsTabsPeople = 'Personer';
z.string.da.addParticipantsTabsServices = 'Tjenester';

z.string.da.conversationDetailsActionArchive = 'Arkiver samtale';
z.string.da.conversationDetailsActionAddParticipants = 'Tilføj deltagere';
z.string.da.conversationDetailsActionBlock = 'Bloker kontakt…';
z.string.da.conversationDetailsActionCancelRequest = 'Annuller anmodning';
z.string.da.conversationDetailsActionClear = 'Slet indhold…';
z.string.da.conversationDetailsActionCreateGroup = 'Opret gruppe';
z.string.da.conversationDetailsActionDevices = 'Enheder';
z.string.da.conversationDetailsActionGuestOptions = 'Gæst indstillinger';
z.string.da.conversationDetailsActionNotifications = 'Notifikationer';
z.string.da.conversationDetailsActionLeave = 'Forlad gruppen…';
z.string.da.conversationDetailsGuestsOff = 'Slået Fra';
z.string.da.conversationDetailsGuestsOn = 'Aktiv';
z.string.da.conversationDetailsOptions = 'Egenskaber';
z.string.da.conversationDetailsParticipantsServicesOne = 'Tjeneste';
z.string.da.conversationDetailsParticipantsServicesMany = 'Tjenester';
z.string.da.conversationDetailsParticipantsUsersOne = 'Person';
z.string.da.conversationDetailsParticipantsUsersMany = 'Personer';
z.string.da.conversationDetailsPeople = 'Personer';
z.string.da.conversationDetailsServices = 'Tjenester';

z.string.da.conversationParticipantsTitle = 'Personer';
z.string.da.conversationParticipantsSearchPlaceholder = 'Søg ved navn';

z.string.da.groupParticipantActionBlock = 'Bloker kontakt…';
z.string.da.groupParticipantActionCancelRequest = 'Annuller anmodning';
z.string.da.groupParticipantActionDevices = 'Enheder';
z.string.da.groupParticipantActionIgnoreRequest = 'Ignorer forespørgsel';
z.string.da.groupParticipantActionIncomingRequest = 'Accepter anmodning';
z.string.da.groupParticipantActionLeave = 'Forlad gruppen…';
z.string.da.groupParticipantActionOpenConversation = 'Åbn samtale';
z.string.da.groupParticipantActionPending = 'Afventer';
z.string.da.groupParticipantActionRemove = 'Fjern fra gruppe…';
z.string.da.groupParticipantActionSelfProfile = 'Åbn Profil';
z.string.da.groupParticipantActionSendRequest = 'Forbind';
z.string.da.groupParticipantActionUnblock = 'Fjern blokering af kontakt…';

z.string.da.guestOptionsCopyLink = 'Kopier link';
z.string.da.guestOptionsCopyLinkDone = 'Link kopieret!';
z.string.da.guestOptionsCreateLink = 'Opret link';
z.string.da.guestOptionsInfoHeader = 'Inviter andre med et link';
z.string.da.guestOptionsInfoText = 'Alle med linket kan tilføje sig til samtalen, også selvom de ikke har Wire.';
z.string.da.guestOptionsRevokeLink = 'Tilbagekald link…';
z.string.da.guestOptionsTitle = 'Gæst indstillinger';

z.string.da.notificationSettingsTitle = 'Notifikationer';

z.string.da.participantDevicesDetailHeadline = 'Bekræft at dette passer med fingeraftrykket vist på {{html1}}{{user}}’s enhed{{html2}}.';
z.string.da.participantDevicesDetailHowTo = 'Hvordan gør jeg det?';
z.string.da.participantDevicesDetailResetSession = 'Nulstil session';
z.string.da.participantDevicesDetailShowMyDevice = 'Vis min enheds fingeraftryk';
z.string.da.participantDevicesDetailVerify = 'Bekræftet';

z.string.da.participantDevicesHeader = 'Enheder';
z.string.da.participantDevicesHeadline = 'Wire giver hver enhed et unikt fingeraftryk. Sammenlign dem med {{user}} og bekræft din samtale.';
z.string.da.participantDevicesLearnMore = 'Lær mere';
z.string.da.participantDevicesWhyVerify = 'Hvorfor verificere samtaler?';
z.string.da.participantDevicesOutdatedClientMessage = '{{user}} bruger en gammel version af Wire. Ingen enheder er vist her.';

z.string.da.participantDevicesSelfAllDevices = 'Vis alle mine enheder';
z.string.da.participantDevicesSelfFingerprint = 'Enheds fingeraftryk';

z.string.da.userProfileButtonConnect = 'Forbind';
z.string.da.userProfileButtonIgnore = 'Ignorér';
z.string.da.userProfileButtonUnblock = 'Fjern Blokering';

z.string.da.preferencesAbout = 'Om';
z.string.da.preferencesAccount = 'Konto';
z.string.da.preferencesAV = 'Lyd / Video';
z.string.da.preferencesDeviceDetails = 'Enheds Detaljer';
z.string.da.preferencesDevices = 'Enheder';
z.string.da.preferencesHeadline = 'Indstillinger';
z.string.da.preferencesOptions = 'Egenskaber';

z.string.da.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.da.preferencesAboutPrivacyPolicy = 'Privatlivspolitik';
z.string.da.preferencesAboutSupport = 'Support';
z.string.da.preferencesAboutSupportWebsite = 'Support hjemmeside';
z.string.da.preferencesAboutSupportContact = 'Kontakt Support';
z.string.da.preferencesAboutTermsOfUse = 'Vilkår for anvendelse';
z.string.da.preferencesAboutVersion = 'Version {{version}}';
z.string.da.preferencesAboutWebsite = 'Wire hjemmeside';

z.string.da.preferencesAccountAvaibilityUnset = 'Sæt en status';
z.string.da.preferencesAccountCreateTeam = 'Opret team';
z.string.da.preferencesAccountDelete = 'Slet konto';
z.string.da.preferencesAccountLeaveGuestRoom = 'Forlad gæsterummet';
z.string.da.preferencesAccountLeaveGuestRoomDescription = 'Du vil ikke længere have mulighed for at få adgang til beskederne i denne samtale.';
z.string.da.preferencesAccountLogOut = 'Log ud';
z.string.da.preferencesAccountManageTeam = 'Administrer arbejdsgrupper';
z.string.da.preferencesAccountResetPassword = 'Nulstil adgangskode';
z.string.da.preferencesAccountTeam = 'i {{name}}';
z.string.da.preferencesAccountUsernamePlaceholder = 'Dit fulde navn';
z.string.da.preferencesAccountUsernameHint = 'Mindst to tegn. Kun a-z, 0-9 og _.';
z.string.da.preferencesAccountUsernameAvailable = 'Ledig';
z.string.da.preferencesAccountUsernameErrorTaken = 'Allerede i brug';

z.string.da.preferencesAVCamera = 'Kamera';
z.string.da.preferencesAVMicrophone = 'Mikrofon';
z.string.da.preferencesAVPermissionDetail = 'Aktivér fra din browser indstillinger';
z.string.da.preferencesAVSpeakers = 'Højtalere';
z.string.da.preferencesAVTryAgain = 'Prøv Igen';

z.string.da.preferencesDevicesActivatedOn = 'Aktiveret på {{date}}';
z.string.da.preferencesDevicesActive = 'Aktiv';
z.string.da.preferencesDevicesActiveDetail = 'Hvis du ikke kan genkende en enhed ovenfor, fjern den og nulstil din adgangskode.';
z.string.da.preferencesDevicesCurrent = 'Aktuel';
z.string.da.preferencesDevicesFingerprint = 'Nøgle fingeraftryk';
z.string.da.preferencesDevicesFingerprintDetail = 'Wire giver hver enhed et unikt fingeraftryk. Sammenlign dem og bekræft dine enheder og samtaler.';
z.string.da.preferencesDevicesId = 'ID: ';
z.string.da.preferencesDevicesRemove = 'Fjern…';
z.string.da.preferencesDevicesRemoveCancel = 'Annuller';
z.string.da.preferencesDevicesRemoveDetail = 'Fjern denne enhed, hvis du ikke bruger den længere. Du bliver logget ud af enheden med det samme.';
z.string.da.preferencesDevicesSessionConfirmation = 'Sessionen er blevet nulstillet.';
z.string.da.preferencesDevicesSessionDetail = 'Hvis fingeraftrykkene ikke stemmer overens, nulstil sessionen for at generere nye krypteringsnøgler hos begge parter.';
z.string.da.preferencesDevicesSessionReset = 'Nulstil session';
z.string.da.preferencesDevicesSessionOngoing = 'Nulstiller session…';
z.string.da.preferencesDevicesVerification = 'Bekræftet';

z.string.da.preferencesOptionsAudio = 'Lyd advarsler';
z.string.da.preferencesOptionsAudioAll = 'Alle';
z.string.da.preferencesOptionsAudioAllDetail = 'Alle lyde';
z.string.da.preferencesOptionsAudioNone = 'Ingen';
z.string.da.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.da.preferencesOptionsAudioSome = 'Nogle';
z.string.da.preferencesOptionsAudioSomeDetail = 'Ping og opkald';
z.string.da.preferencesOptionsContacts = 'Kontakter';
z.string.da.preferencesOptionsContactsGmail = 'Importér fra Gmail';
z.string.da.preferencesOptionsContactsMacos = 'Omportér fra Kontakter';
z.string.da.preferencesOptionsContactsDetail = 'Vi bruger dine kontaktdata til at forbinde dig med andre. Vi anonymisere alle oplysninger og deler ikke det med alle andre.';
z.string.da.preferencesOptionsPopular = 'Ved populær efterspørgsel';
z.string.da.preferencesOptionsEmojiReplaceCheckbox = 'Erstat type emoticons med emoji';
z.string.da.preferencesOptionsPreviewsSendCheckbox = 'Lav previews til links du sender';
z.string.da.preferencesOptionsPreviewsSendDetail = 'Previews kan stadig blive vist for link fra andre.';
z.string.da.preferencesOptionsNotifications = 'Notifikationer';
z.string.da.preferencesOptionsNotificationsNone = 'Slået Fra';
z.string.da.preferencesOptionsNotificationsObfuscate = 'Skjul detaljer';
z.string.da.preferencesOptionsNotificationsObfuscateMessage = 'Vis afsender';
z.string.da.preferencesOptionsNotificationsOn = 'Vis afsender og besked';
z.string.da.preferencesOptionsCallLogs = 'Fejlfinding';
z.string.da.preferencesOptionsCallLogsGet = 'Gem samtale debug rapporten';
z.string.da.preferencesOptionsCallLogsDetail = 'Denne information hjælper Wire Support med at diagnosticere opkaldsproblemer.';

z.string.da.preferencesOptionsBackupHeader = 'Historik';
z.string.da.preferencesOptionsBackupExportHeadline = 'Sikkerhedskopier samtaler';
z.string.da.preferencesOptionsBackupExportSecondary = 'Lav en sikkerhedskopi for at gemme din samtale historik. Du kan bruge den til at gendanne historikken hvis du mister din computer eller skifter til en ny.\nSikkerhedskopi filen er ikke beskyttet af Wire end-to-end kryptering, så gem den it sikkert sted.';
z.string.da.preferencesOptionsBackupImportHeadline = 'Gendan fra sikkerhedskopi';
z.string.da.preferencesOptionsBackupImportSecondary = 'Du kan kun gendanne historik fra en sikkerhedskopi til den samme platform. Din sikkerhedskopi vil overskrive samtaler du allerede har på denne enhed.';

z.string.da.backupExportGenericErrorHeadline = 'Filen kunne ikke gemmes';
z.string.da.backupExportGenericErrorSecondary = 'Sikkerhedskopiering blev ikke færdiggjort.';
z.string.da.backupExportProgressHeadline = 'Forbereder…';
z.string.da.backupExportProgressSecondary = 'Sikkerhedskopierer · {{processed}} af {{total}} — {{progress}}%';
z.string.da.backupExportSuccessHeadline = 'Sikkerhedskopiering fuldført';
z.string.da.backupExportSuccessSecondary = 'Du kan bruge dette til at gendanne din historik hvis du mister din computer eller skifter til en ny.';
z.string.da.backupImportGenericErrorHeadline = 'Noget gik galt';
z.string.da.backupImportGenericErrorSecondary = 'Din historik kunne ikke gendannes.';
z.string.da.backupImportAccountErrorHeadline = 'Forkert sikkerhedskopi';
z.string.da.backupImportAccountErrorSecondary = 'Du kan ikke gendanne historik fra en anden konto.';
z.string.da.backupImportVersionErrorHeadline = 'Ukompatibel sikkerhedskopi';
z.string.da.backupImportVersionErrorSecondary = 'Denne sikkerhedskopi er lavet på en nyere eller uddateret version af Wire og kan ikke blive gendannet her.';
z.string.da.backupImportIncompatibleErrorHeadline = 'Forkert sikkerhedskopi';
z.string.da.backupImportIncompatibleErrorSecondary = 'Du kan ikke gendanne historik fra en anden konto.';
z.string.da.backupImportOutdatedErrorHeadline = 'Ukompatibel sikkerhedskopi';
z.string.da.backupImportOutdatedErrorSecondary = 'Denne sikkerhedskopi er lavet på en nyere eller uddateret version af Wire og kan ikke blive gendannet her.';
z.string.da.backupImportProgressHeadline = 'Forbereder…';
z.string.da.backupImportProgressSecondary = 'Gendanner historik · {{processed}} af {{total}} — {{progress}}%';
z.string.da.backupImportSuccessHeadline = 'Historik gendannet.';
z.string.da.backupCancel = 'Annuller';
z.string.da.backupTryAgain = 'Prøv Igen';

z.string.da.searchConnect = 'Forbind';
z.string.da.searchConnections = 'Forbindelser';
z.string.da.searchContacts = 'Kontakter';
z.string.da.searchCreateGroup = 'Opret gruppe';
z.string.da.searchCreateGuestRoom = 'Opret gæsterum';
z.string.da.searchGroups = 'Grupper';
z.string.da.searchPeople = 'Personer';
z.string.da.searchPlaceholder = 'Søg på navn eller brugernavn';
z.string.da.searchServicePlaceholder = 'Søg ved navn';
z.string.da.searchServices = 'Tjenester';
z.string.da.searchTeamGroups = 'Team samtaler';
z.string.da.searchTeamMembers = 'Team medlemmer';
z.string.da.searchTopPeople = 'Top personer';
z.string.da.searchTrySearch = 'Find personer ved navn eller Brugernavn';
z.string.da.searchNoContactsOnWire = 'Du har ingen kontakter på Wire. Prøv at finde folk ved navn eller brugernavn.';
z.string.da.searchMemberInvite = 'Inviter personer til holdet';
z.string.da.searchOthers = 'Forbind';

z.string.da.searchInvite = 'Inviter personer til Wire';
z.string.da.searchInviteDetail = 'At dele dine kontakter hjælper med at forbinde til andre. Vi anonymiserer al information og deler det ikke med nogen andre.';
z.string.da.searchInviteButtonContacts = 'Fra Kontakter';
z.string.da.searchInviteButtonGmail = 'Fra Gmail';
z.string.da.searchInviteHeadline = 'Få dine venner med';
z.string.da.searchInviteShare = 'Del Kontakter';

z.string.da.searchServiceConfirmButton = 'Tilføj tjeneste';

z.string.da.searchListEveryoneParticipates = 'Alle du er \nforbundet med er allerede i \ndenne samtale.';
z.string.da.searchListNoMatches = 'Ingen passende resultater.\nPrøv at indtaste et andet navn.';

z.string.da.temporaryGuestCta = 'Opret en konto';
z.string.da.temporaryGuestDescription = 'Sikrer din virksomhed med krypteret gruppe chat og konference opkald.';
z.string.da.temporaryGuestTimeRemaining = ' tilbage i dette gæsterum';

z.string.da.temporaryGuestJoinMessage = 'Denne samtale vil være tilgængelig for dig i 24 timer.';
z.string.da.temporaryGuestJoinDescription = 'Hvis du lukker eller opdaterer denne side, vil du miste adgang.';

z.string.da.temporaryGuestLeaveMessage = ' er ikke længere med i denne samtale.';
z.string.da.temporaryGuestLeaveDescription = 'Hvis du lukker eller opdaterer denne side, vil du miste adgang til samtale historikken.';

z.string.da.uploadGoogleHeadline = 'Finde personer at snakke med.';
z.string.da.uploadGoogleMessage = 'Vi bruger dine kontaktdata til at forbinde dig med andre. Vi anonymisere alle oplysninger og deler ikke det med alle andre.';

z.string.da.warningCallUnsupportedIncoming = '{{user}} ringer. Din browser understøtter ikke opkald.';
z.string.da.warningCallUnsupportedOutgoing = 'Du kan ikke ringe, fordi din browser ikke understøtter opkald.';
z.string.da.warningCallIssues = 'Denne version af Wire kan ikke deltage i opkaldet. Brug venligst';
z.string.da.warningCallUpgradeBrowser = 'Venligst opdater Google Chrome for at ringe.';
z.string.da.warningConnectivityConnectionLost = 'Forsøger at forbinde. Wire kan muligvis ikke levere beskeder.';
z.string.da.warningConnectivityNoInternet = 'Ingen Internet. Du vil ikke kunne sende eller modtage beskeder.';
z.string.da.warningLearnMore = 'Lær mere';
z.string.da.warningLifecycleUpdate = 'En ny version af Wire er tilgængelig.';
z.string.da.warningLifecycleUpdateNotes = 'Hvad er nyt';
z.string.da.warningLifecycleUpdateLink = 'Opdatér nu';
z.string.da.warningNotFoundCamera = 'Du kan ikke ringe, fordi din computer har ikke et kamera.';
z.string.da.warningNotFoundMicrophone = 'Du kan ikke ringe, fordi din computer har ikke en mikrofon.';
z.string.da.warningPermissionDeniedCamera = 'Du kan ikke ringe, fordi din browser ikke har adgang til kameraet.';
z.string.da.warningPermissionDeniedMicrophone = 'Du kan ikke ringe, fordi din browser ikke har adgang til mikrofonen.';
z.string.da.warningPermissionDeniedScreen = 'Din browser skal have tilladelse til at dele din skærm.';
z.string.da.warningPermissionRequestCamera = '{{icon}} Tillad adgang til kamera';
z.string.da.warningPermissionRequestMicrophone = '{{icon}} Tillad adgang til mikrofon';
z.string.da.warningPermissionRequestNotification = '{{icon}} Tillad meddelelser';
z.string.da.warningPermissionRequestScreen = '{{icon}} Tillad adgang til skærm';

z.string.da.userAvailabilityAvailable = 'Ledig';
z.string.da.userAvailabilityAway = 'Ikke til stede';
z.string.da.userAvailabilityBusy = 'Optaget';
z.string.da.userAvailabilityNone = 'Ingen';

z.string.da.notificationAssetAdd = 'Delte et billede';
z.string.da.notificationConnectionAccepted = 'Accepterede din anmodning om forbindelse';
z.string.da.notificationConnectionConnected = 'Du er nu forbundet';
z.string.da.notificationConnectionRequest = 'Ønsker at forbinde';
z.string.da.notificationConversationCreate = '{{user}} startede en samtale';
z.string.da.notificationConversationRename = '{{user}} omdøbte samtalen til {{name}}';
z.string.da.notificationMemberJoinMany = '{{user}} tilføjede {{number}} personer til samtalen';
z.string.da.notificationMemberJoinSelf = '{{user}} tilsluttede sig samtalen';
z.string.da.notificationMemberJoinOne = '{{user1}} tilføjede {{user2}} til samtalen';
z.string.da.notificationMemberLeaveRemovedYou = '{{user}} har fjernet dig fra en samtale';
z.string.da.notificationObfuscated = 'Sendte dig en besked';
z.string.da.notificationObfuscatedTitle = 'Nogen';
z.string.da.notificationPing = 'Pingede';
z.string.da.notificationReaction = '{{reaction}} din besked';
z.string.da.notificationSharedAudio = 'Delte en lyd besked';
z.string.da.notificationSharedFile = 'Delte en fil';
z.string.da.notificationSharedLocation = 'Delte en placering';
z.string.da.notificationSharedVideo = 'Delte en video';
z.string.da.notificationVoiceChannelActivate = 'Ringer';
z.string.da.notificationVoiceChannelDeactivate = 'Ringede';

z.string.da.tooltipConversationAllVerified = 'Alle fingeraftryk er bekræftede';
z.string.da.tooltipConversationCall = 'Ring op';
z.string.da.tooltipConversationEphemeral = 'Tidsbestemt besked';
z.string.da.tooltipConversationFile = 'Tilføj fil';
z.string.da.tooltipConversationInputPlaceholder = 'Skriv en besked';
z.string.da.tooltipConversationInputPlaceholderAvailable = '{{user}} er tilgængelig';
z.string.da.tooltipConversationInputPlaceholderAway = '{{user}} er ikke til stede';
z.string.da.tooltipConversationInputPlaceholderBusy = '{{user}} er optaget';
z.string.da.tooltipConversationPeople = 'Personer ({{shortcut}})';
z.string.da.tooltipConversationPicture = 'Tilføj billede';
z.string.da.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.da.tooltipConversationSearch = 'Søg';
z.string.da.tooltipConversationVideoCall = 'Videoopkald';

z.string.da.tooltipConversationsArchive = 'Arkiv ({{shortcut}})';
z.string.da.tooltipConversationsArchived = 'Vis arkiv ({{number}})';
z.string.da.tooltipConversationsMore = 'Mere';
z.string.da.tooltipConversationsNotify = 'Unmute ({{shortcut}})';
z.string.da.tooltipConversationsPreferences = 'Åbn indstillinger';
z.string.da.tooltipConversationsSilence = 'Mute ({{shortcut}})';
z.string.da.tooltipConversationsStart = 'Start samtale ({{shortcut}})';

z.string.da.tooltipConversationDetailsAddPeople = 'Tilføj deltagere til samtalen ({{shortcut}})';
z.string.da.tooltipConversationDetailsRename = 'Ændre samtalens navn';

z.string.da.tooltipPreferencesContactsGmail = 'Log ind på din Gmail konto for at dele kontakter';
z.string.da.tooltipPreferencesContactsMacos = 'Del alle dine kontakter fra macOS Kontakter app';
z.string.da.tooltipPreferencesPassword = 'Åbn en anden hjemmeside for at nulstille din adgangskode';
z.string.da.tooltipPreferencesPicture = 'Ændre dit billede…';
z.string.da.tooltipPreferencesRename = 'Ændre dit navn';

z.string.da.tooltipSearchClose = 'Luk (Esc)';

z.string.da.initReceivedSelfUser = 'Hej, {{user}}.';
z.string.da.initValidatedClient = 'Henter dine forbindelser og samtaler';
z.string.da.initReceivedUserData = 'Tjekker for nye beskeder';
z.string.da.initDecryption = 'Dekrypterer beskeder';
z.string.da.initEvents = 'Indlæser meddelelser';
z.string.da.initUpdatedFromNotifications = 'Snart færdig - God fornøjelse med Wire';
z.string.da.initProgress = ' — {{number1}} af {{number2}}';

z.string.da.ephemeralUnitsNone = 'Slået Fra';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.de.wire = 'Wire';
z.string.de.wireMacos = 'Wire für macOS';
z.string.de.wireWindows = 'Wire für Windows';
z.string.de.wireLinux = 'Wire für Linux';
z.string.de.nonexistentUser = 'Gelöschte Person';
z.string.de.and = 'und';
z.string.de.enumerationAnd = ' und ';

z.string.de.authAccountCountryCode = 'Landesvorwahl';
z.string.de.authAccountPasswordForgot = 'Passwort vergessen';
z.string.de.authAccountPublicComputer = 'Dies ist ein öffentlicher Computer';
z.string.de.authAccountSignIn = 'Login';
z.string.de.authAccountSignInPhone = 'Handy Login';

z.string.de.authBlockedCookies = 'Aktiviere Cookies, um dich bei Wire einzuloggen.';
z.string.de.authBlockedDatabase = 'Wire benötigt zum Anzeigen deiner Nachrichten Zugriff auf den lokalen Speicher. In Privaten Fenstern ist dieser nicht verfügbar.';
z.string.de.authBlockedTabs = 'Wire ist bereits in einem anderen Tab geöffnet.';
z.string.de.authBlockedTabsAction = 'Stattdessen diesen Tab verwenden';

z.string.de.authVerifyAccountAdd = 'Hinzufügen';
z.string.de.authVerifyAccountDetail = 'Hiermit kannst du Wire auf mehreren Geräten verwenden.';
z.string.de.authVerifyAccountHeadline = 'E-Mail-Adresse und Passwort hinzufügen.';
z.string.de.authVerifyAccountLogout = 'Abmelden';
z.string.de.authVerifyCodeDescription = 'Gib den Code ein, den wir an \n{{number}} gesendet haben.';
z.string.de.authVerifyCodeResend = 'Keinen Code erhalten?';
z.string.de.authVerifyCodeResendDetail = 'Erneut senden';
z.string.de.authVerifyCodeResendTimer = 'Du kannst {{expiration}} einen neuen Code anfordern.';
z.string.de.authVerifyCodeChangePhone = 'Telefonnummer ändern';
z.string.de.authVerifyPasswordHeadline = 'Passwort eingeben';

z.string.de.authLimitDevicesHeadline = 'Geräte';
z.string.de.authLimitDescription = 'Entferne eines deiner anderen Geräte, um Wire hier zu nutzen.';
z.string.de.authLimitButtonManage = 'Geräte verwalten';
z.string.de.authLimitButtonSignOut = 'Abmelden';
z.string.de.authLimitDevicesCurrent = '(Aktuelles Gerät)';

z.string.de.authHistoryHeadline = 'Du benutzt Wire zum ersten Mal auf diesem Gerät.';
z.string.de.authHistoryDescription = 'Aus Datenschutzgründen wird dein bisheriger Gesprächsverlauf nicht angezeigt.';
z.string.de.authHistoryReuseHeadline = 'Du hast Wire auf diesem Gerät bereits früher genutzt.';
z.string.de.authHistoryReuseDescription = 'Nachrichten, die in der Zwischenzeit gesendet wurden, werden nicht angezeigt.';
z.string.de.authHistoryButton = 'Verstanden';

z.string.de.authPostedResend = 'Erneut an {{email}} senden';
z.string.de.authPostedResendAction = 'E-Mail nicht erhalten?';
z.string.de.authPostedResendDetail = 'Schaue in deinen Posteingang und folge den Anweisungen.';
z.string.de.authPostedResendHeadline = 'Du hast Post.';

z.string.de.authPlaceholderEmail = 'E-Mail';
z.string.de.authPlaceholderPasswordPut = 'Passwort';
z.string.de.authPlaceholderPasswordSet = 'Passwort (min. acht Zeichen)';
z.string.de.authPlaceholderPhone = 'Telefonnummer';

z.string.de.authErrorCode = 'Ungültiger Verifizierungs-Code';
z.string.de.authErrorCountryCodeInvalid = 'Ungültige Landesvorwahl';
z.string.de.authErrorEmailExists = 'E-Mail-Adresse bereits vergeben';
z.string.de.authErrorEmailForbidden = 'Es tut uns leid. Diese E-Mail-Adresse ist verboten.';
z.string.de.authErrorEmailMalformed = 'Bitte gib eine gültige E-Mail-Adresse ein.';
z.string.de.authErrorEmailMissing = 'Bitte gib eine E-Mail-Adresse ein.';
z.string.de.authErrorMisc = 'Probleme mit der Verbindung. Versuche es erneut.';
z.string.de.authErrorNameShort = 'Gib einen Namen mit mindestens zwei Zeichen ein';
z.string.de.authErrorOffline = 'Keine Internetverbindung';
z.string.de.authErrorPasswordShort = 'Wähle ein Passwort mit mindestens acht Zeichen.';
z.string.de.authErrorPasswordWrong = 'Falsches Passwort. Bitte versuche es erneut.';
z.string.de.authErrorPending = 'Benutzerkonto noch nicht verifiziert';
z.string.de.authErrorPhoneNumberBudget = 'Du hast dich zu oft eingeloggt. Versuche es später erneut.';
z.string.de.authErrorPhoneNumberForbidden = 'Diese Telefonnummer ist leider nicht nutzbar.';
z.string.de.authErrorPhoneNumberInvalid = 'Ungültige Telefonnummer';
z.string.de.authErrorPhoneNumberUnknown = 'Unbekannte Telefonnummer';
z.string.de.authErrorSuspended = 'Benutzerkonto ist nicht mehr zum Login berechtigt.';
z.string.de.authErrorSignIn = 'Überprüfe deine Eingaben und versuche es erneut.';

z.string.de.callStateOutgoing = 'Klingeln…';
z.string.de.callStateConnecting = 'Verbinde…';
z.string.de.callStateIncoming = 'Ruft an…';
z.string.de.callStateIncomingGroup = '{{user}} ruft an';
z.string.de.callDecline = 'Ablehnen';
z.string.de.callAccept = 'Annehmen';
z.string.de.callJoin = 'Beitreten';
z.string.de.callChooseSharedScreen = 'Wähle einen Bildschirm aus';
z.string.de.callParticipants = '{{number}} im Anruf';
z.string.de.callNoCameraAccess = 'Kein Kamerazugriff';

z.string.de.videoCallOverlayFitVideoLabel = 'Das Video per Doppelklick anpassen';
z.string.de.videoCallOverlayConversations = 'Unterhaltungen';
z.string.de.videoCallOverlayMute = 'Stummschalten';
z.string.de.videoCallOverlayVideo = 'Video';
z.string.de.videoCallOverlayShareScreen = 'Bildschirm teilen';
z.string.de.videoCallOverlayHangUp = 'Beenden';
z.string.de.videoCallPaused = 'Video wurde angehalten';
z.string.de.videoCallScreenShareNotSupported = 'Bildschirmfreigabe wird von diesem Browser nicht unterstützt';

z.string.de.modalAcknowledgeAction = 'Ok';
z.string.de.modalAcknowledgeHeadline = 'Fehler aufgetreten';
z.string.de.modalConfirmSecondary = 'Abbrechen';
z.string.de.modalOptionSecondary = 'Abbrechen';

z.string.de.modalAccountCreateAction = 'Verstanden';
z.string.de.modalAccountCreateHeadline = 'Benutzerkonto erstellen?';
z.string.de.modalAccountCreateMessage = 'Wenn du ein Benutzerkonto erstellst, verlierst du den Unterhaltungsverlauf dieses Gästebereichs.';

z.string.de.modalAccountDeletionAction = 'Löschen';
z.string.de.modalAccountDeletionHeadline = 'Benutzerkonto löschen';
z.string.de.modalAccountDeletionMessage = 'In Kürze erhältst du eine Nachricht per E-Mail oder SMS. Folge dem Link darin, um dein Konto zu löschen.';

z.string.de.modalAccountLeaveGuestRoomAction = 'Verlassen';
z.string.de.modalAccountLeaveGuestRoomHeadline = 'Gästebereich verlassen?';
z.string.de.modalAccountLeaveGuestRoomMessage = 'Der Unterhaltungsverlauf wird gelöscht. Erstelle beim nächsten Mal ein Benutzerkonto, um ihn zu behalten.';

z.string.de.modalAccountLogoutAction = 'Abmelden';
z.string.de.modalAccountLogoutHeadline = 'Daten löschen?';
z.string.de.modalAccountLogoutOption = 'Deine persönlichen Daten und Unterhaltungen vollständig von diesem Gerät entfernen.';

z.string.de.modalAccountNewDevicesSecondary = 'Geräte verwalten';
z.string.de.modalAccountNewDevicesHeadline = 'Dein Benutzerkonto wurde verwendet:';
z.string.de.modalAccountNewDevicesFrom = 'Mit:';
z.string.de.modalAccountNewDevicesMessage = 'Falls du dieses Gerät nicht hinzugefügt hast, entferne es und setze dein Passwort zurück.';

z.string.de.modalAccountRemoveDeviceAction = 'Gerät entfernen';
z.string.de.modalAccountRemoveDeviceHeadline = 'Entferne "{{device}}"';
z.string.de.modalAccountRemoveDeviceMessage = 'Dein Passwort wird zum Entfernen des Gerätes benötigt.';
z.string.de.modalAccountRemoveDevicePlaceholder = 'Passwort';

z.string.de.modalAssetTooLargeHeadline = 'Datei zu groß';
z.string.de.modalAssetTooLargeMessage = 'Du kannst Dateien bis zu {{number}} senden.';

z.string.de.modalAssetParallelUploadsHeadline = 'Zu viele Dateien auf einmal';
z.string.de.modalAssetParallelUploadsMessage = 'Du kannst bis zu {{number}} Dateien auf einmal senden.';

z.string.de.modalCallEmptyConversationHeadline = 'Niemand um anzurufen';
z.string.de.modalCallEmptyConversationMessage = 'Es ist niemand mehr in der Unterhaltung.';

z.string.de.modalCallEmptyLogHeadline = 'Keine Anrufe';
z.string.de.modalCallEmptyLogMessage = 'Es gab keine Anrufe, für die der Debug-Bericht erstellt werden kann.';

z.string.de.modalCallNoGroupVideoHeadline = 'Keine Videoanrufe in Gruppen';
z.string.de.modalCallNoGroupVideoMessage = 'Videoanrufe sind in Gruppen nicht verfügbar.';

z.string.de.modalCallNoMicrophoneAction = 'Zeig mir wie';
z.string.de.modalCallNoMicrophoneMessage = 'Dein Browser benötigt für Anrufe Zugriff auf das Mikrofon.';
z.string.de.modalCallNoMicrophoneHeadline = 'Anrufe sind ohne Mikrofon nicht möglich';

z.string.de.modalCallSecondIncomingAction = 'Annehmen';
z.string.de.modalCallSecondIncomingHeadline = 'Anruf annehmen?';
z.string.de.modalCallSecondIncomingMessage = 'Dein aktueller Anruf wird beendet.';

z.string.de.modalCallSecondOngoingAction = 'Beenden';
z.string.de.modalCallSecondOngoingHeadline = 'Anruf auf einem anderen Gerät beenden?';
z.string.de.modalCallSecondOngoingMessage = 'Nur ein zeitgleicher Anruf möglich.';

z.string.de.modalCallSecondOutgoingAction = 'Beenden';
z.string.de.modalCallSecondOutgoingHeadline = 'Aktuellen Anruf beenden?';
z.string.de.modalCallSecondOutgoingMessage = 'Nur ein zeitgleicher Anruf möglich.';

z.string.de.modalConnectCancelAction = 'Ja';
z.string.de.modalConnectCancelHeadline = 'Kontaktanfrage abbrechen?';
z.string.de.modalConnectCancelMessage = 'Ziehe die Kontaktanfrage an {{user}} zurück.';
z.string.de.modalConnectCancelSecondary = 'Nein';

z.string.de.modalConnectAcceptAction = 'Kontakt hinzufügen';
z.string.de.modalConnectAcceptHeadline = 'Annehmen?';
z.string.de.modalConnectAcceptMessage = '{{user}} wird zu deinen Kontakten hinzugefügt und die Unterhaltung mit ihm geöffnet.';
z.string.de.modalConnectAcceptSecondary = 'Ignorieren';

z.string.de.modalConversationClearAction = 'Löschen';
z.string.de.modalConversationClearHeadline = 'Unterhaltungsverlauf löschen?';
z.string.de.modalConversationClearMessage = 'Der Unterhaltungsverlauf wird auf all deinen Geräten gelöscht.';
z.string.de.modalConversationClearOption = 'Unterhaltung auch verlassen';

z.string.de.modalConversationDeleteMessageAction = 'Löschen';
z.string.de.modalConversationDeleteMessageHeadline = 'Nur für mich löschen?';
z.string.de.modalConversationDeleteMessageMessage = 'Dies kann nicht rückgängig gemacht werden.';

z.string.de.modalConversationDeleteMessageEveryoneAction = 'Löschen';
z.string.de.modalConversationDeleteMessageEveryoneHeadline = 'Für alle löschen?';
z.string.de.modalConversationDeleteMessageEveryoneMessage = 'Dies kann nicht rückgängig gemacht werden.';

z.string.de.modalConversationLeaveAction = 'Verlassen';
z.string.de.modalConversationLeaveHeadline = 'Unterhaltung {{name}} verlassen?';
z.string.de.modalConversationLeaveMessage = 'Du wirst keine Nachrichten in dieser Unterhaltung senden oder empfangen können.';

z.string.de.modalConversationMessageTooLongHeadline = 'Nachricht zu lang';
z.string.de.modalConversationMessageTooLongMessage = 'Du kannst Nachrichten mit bis zu {{number}} Zeichen senden.';

z.string.de.modalConversationNewDeviceAction = 'Dennoch senden';
z.string.de.modalConversationNewDeviceHeadlineOne = '{{user}} hat begonnen ein neues Gerät zu nutzen';
z.string.de.modalConversationNewDeviceHeadlineMany = '{{users}} haben begonnen neue Geräte zu nutzen';
z.string.de.modalConversationNewDeviceHeadlineYou = '{{user}} hast begonnen ein neues Gerät zu nutzen';
z.string.de.modalConversationNewDeviceIncomingCallAction = 'Anruf annehmen';
z.string.de.modalConversationNewDeviceIncomingCallMessage = 'Möchtest du den Anruf dennoch annehmen?';
z.string.de.modalConversationNewDeviceMessage = 'Möchtest du deine Nachricht dennoch senden?';
z.string.de.modalConversationNewDeviceOutgoingCallAction = 'Dennoch anrufen';
z.string.de.modalConversationNewDeviceOutgoingCallMessage = 'Möchtest du wirklich anrufen?';

z.string.de.modalConversationNotConnectedHeadline = 'Niemand wurde zur Unterhaltung hinzugefügt';
z.string.de.modalConversationNotConnectedMessageOne = '{{name}} will nicht zur Unterhaltung hinzugefügt werden.';
z.string.de.modalConversationNotConnectedMessageMany = 'Eine der ausgewählten Personen will nicht zur Unterhaltung hinzugefügt werden.';

z.string.de.modalConversationRemoveAction = 'Entfernen';
z.string.de.modalConversationRemoveHeadline = 'Entfernen?';
z.string.de.modalConversationRemoveMessage = '{{user}} wird in dieser Unterhaltung keine Nachrichten schicken oder empfangen können.';

z.string.de.modalConversationRemoveGuestsAction = 'Entfernen';
z.string.de.modalConversationRemoveGuestsHeadline = 'Zugang deaktivieren?';
z.string.de.modalConversationRemoveGuestsMessage = 'Aktuelle Gäste und Dienste werden aus der Unterhaltung entfernt. Neue Gäste und Dienste können nicht hinzugefügt werden.';

z.string.de.modalConversationRevokeLinkAction = 'Link widerrufen';
z.string.de.modalConversationRevokeLinkHeadline = 'Link widerrufen?';
z.string.de.modalConversationRevokeLinkMessage = 'Neue Gäste werden nicht mehr mit diesem Link beitreten können. Aktuelle Gäste haben weiterhin Zugriff auf die Unterhaltung.';

z.string.de.modalConversationGuestOptionsAllowGuestMessage = 'Gäste und Dienste konnten nicht zugelassen werden. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsDisableGuestMessage = 'Gäste und Dienste konnten nicht entfernt werden. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsGetCodeMessage = 'Konnte Zugangs-Link nicht laden.';
z.string.de.modalConversationGuestOptionsRequestCodeMessage = 'Konnte Zugangs-Link nicht erstellen. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsRevokeCodeMessage = 'Konnte Zugangs-Link nicht widerrufen. Bitte versuche es erneut.';
z.string.de.modalConversationGuestOptionsToggleGuestsMessage = 'Konnte den Gast-Status nicht wechseln.';

z.string.de.modalConversationTooManyMembersHeadline = 'Die Gruppe ist voll';
z.string.de.modalConversationTooManyMembersMessage = 'An einer Gruppe können bis zu {{number1}} Personen teilnehmen. Hier ist nur noch Platz für {{number2}} Personen.';

z.string.de.modalGifTooLargeHeadline = 'Ausgewählte Animation zu groß';
z.string.de.modalGifTooLargeMessage = 'Maximale Größe beträgt {{number}} MB.';

z.string.de.modalIntegrationUnavailableHeadline = 'Bots momentan nicht verfügbar';
z.string.de.modalIntegrationUnavailableMessage = 'Vielen Dank für dein Interesse an Bots. Der Dienst ist derzeit ausgesetzt, während wir an der nächsten Generation arbeiten. Bleib gespannt.';

z.string.de.modalPictureFileFormatHeadline = 'Bild kann nicht verwendet werden';
z.string.de.modalPictureFileFormatMessage = 'Bitte wähle eine PNG- oder JPEG-Datei.';

z.string.de.modalPictureTooLargeHeadline = 'Ausgewähltes Bild zu groß';
z.string.de.modalPictureTooLargeMessage = 'Du kannst Bilder mit bis zu {{number}} MB verwenden.';

z.string.de.modalPictureTooSmallHeadline = 'Ausgewähltes Bild zu klein';
z.string.de.modalPictureTooSmallMessage = 'Wähle ein Bild mit mindestens 320 × 320 Pixeln.';

z.string.de.modalImproveWireAction = 'Ich willige ein';
z.string.de.modalImproveWireSecondary = 'Nein';
z.string.de.modalImproveWireHeadline = 'Hilf uns, Wire zu verbessern';
z.string.de.modalImproveWireMessage = 'Ich willige ein, dass Wire anonymisierte Nutzungs- und Fehlerberichte erstellen und verwenden darf, um die Wire-App zu verbessern. Ich kann diese Einwilligung jederzeit widerrufen.';

z.string.de.modalServiceUnavailableHeadline = 'Hinzufügen des Dienstes nicht möglich';
z.string.de.modalServiceUnavailableMessage = 'Der Dienst ist derzeit nicht verfügbar.';

z.string.de.modalSessionResetHeadline = 'Die Session wurde zurückgesetzt';
z.string.de.modalSessionResetMessage1 = 'Wenn das Problem weiterhin besteht,';
z.string.de.modalSessionResetMessageLink = 'kontaktiere';
z.string.de.modalSessionResetMessage2 = 'uns.';

z.string.de.modalUploadContactsAction = 'Erneut versuchen';
z.string.de.modalUploadContactsMessage = 'Wir haben die Informationen nicht erhalten. Bitte importiere deine Kontakte erneut.';

z.string.de.modalUserBlockAction = 'Blockieren';
z.string.de.modalUserBlockHeadline = '{{user}} blockieren?';
z.string.de.modalUserBlockMessage = '{{user}} wird dich nicht länger kontaktieren oder zu Gruppen hinzufügen können.';

z.string.de.modalUserUnblockAction = 'Freigeben';
z.string.de.modalUserUnblockHeadline = 'Freigeben?';
z.string.de.modalUserUnblockMessage = '{{user}} wird dich wieder kontaktieren und zu Gruppen hinzufügen können.';

z.string.de.modalNoCameraTitle = 'Kein Kamerazugriff';
z.string.de.modalNoCameraMessage = 'Wire hat keinen Zugriff auf die Kamera.[br][faqLink]Zur Behebung bitte diesen Support Artikel anschauen[/faqLink].';

z.string.de.connectionRequestConnect = 'Kontakt hinzufügen';
z.string.de.connectionRequestIgnore = 'Ignorieren';

z.string.de.conversationGuestIndicator = 'Gast';
z.string.de.userRemainingTimeHours = '{{time}}h verbleibend';
z.string.de.userRemainingTimeMinutes = 'Weniger als {{time}}m verbleibend';

z.string.de.conversationYouNominative = 'du';
z.string.de.conversationYouDative = 'dir';
z.string.de.conversationYouAccusative = 'dich';

z.string.de.conversationConnectionAccepted = 'Hinzugefügt';
z.string.de.conversationConnectionBlocked = 'Blockiert';
z.string.de.conversationConnectionCancelRequest = 'Kontaktanfrage abbrechen';
z.string.de.conversationCreateTemporary = 'Du bist der Unterhaltung beigetreten';
z.string.de.conversationCreateWith = 'mit {{users}}';
z.string.de.conversationDeviceStartedUsingOne = ' benutzt';
z.string.de.conversationDeviceStartedUsingMany = ' benutzen';
z.string.de.conversationDeviceUnverified = ' hat die Überprüfung widerrufen für';
z.string.de.conversationDeviceYourDevices = ' eines deiner Geräte';
z.string.de.conversationDeviceUserDevices = ' ein Gerät von {{user}}';
z.string.de.conversationDeviceNewDeviceOne = ' ein neues Gerät';
z.string.de.conversationDeviceNewDeviceMany = ' neue Geräte';
z.string.de.conversationDeviceNewPeopleJoined = 'Neue Personen beigetreten.';
z.string.de.conversationDeviceNewPeopleJoinedVerify = 'Überprüfe Geräte';
z.string.de.conversationJustNow = 'Gerade eben';
z.string.de.conversationLocationLink = 'Zeige Standort';
z.string.de.conversationCreated = '[bold]{{name}}[/bold] hat eine Unterhaltung mit {{users}} begonnen';
z.string.de.conversationCreatedMore = '[bold]{{name}}[/bold] hat eine Unterhaltung mit {{users}} und [showmore]{{count}} anderen[/showmore] begonnen';
z.string.de.conversationCreatedName = '[bold]{{name}}[/bold] hat eine Unterhaltung begonnen';
z.string.de.conversationCreatedNameYou = '[bold]Du[/bold] hast eine Unterhaltung begonnen';
z.string.de.conversationCreatedYou = 'Du hast eine Unterhaltung mit {{users}} begonnen';
z.string.de.conversationCreatedYouMore = 'Du hast eine Unterhaltung mit {{users}} und [showmore]{{count}} anderen[/showmore] begonnen';
z.string.de.conversationCreateWithMore = 'mit {{users}} und [showmore]{{count}} anderen[/showmore]';
z.string.de.conversationCreateTeam = 'mit [showmore]allen Team-Mitgliedern[/showmore]';
z.string.de.conversationCreateTeamGuest = 'mit [showmore]allen Team-Mitgliedern und einem Gast[/showmore]';
z.string.de.conversationCreateTeamGuests = 'mit [showmore]allen Team-Mitgliedern und {{count}} Gästen[/showmore]';
z.string.de.conversationMemberJoined = '[bold]{{name}}[/bold] hat {{users}} hinzugefügt';
z.string.de.conversationMemberJoinedYou = '[bold]Du[/bold] hast {{users}} hinzugefügt';
z.string.de.conversationMemberJoinedMore = '[bold]{{name}}[/bold] hat {{users}} und [showmore]{{count}} andere[/showmore] hinzugefügt';
z.string.de.conversationMemberJoinedYouMore = '[bold]Du[/bold] hast {{users}} und [showmore]{{count}} andere[/showmore] hinzugefügt';
z.string.de.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] ist beigetreten';
z.string.de.conversationMemberJoinedSelfYou = '[bold]Du[/bold] bist beigetreten';
z.string.de.conversationMemberLeft = '[bold]{{name}}[/bold] hat die Unterhaltung verlassen';
z.string.de.conversationMemberLeftYou = '[bold]Du[/bold] hast die Unterhaltung verlassen';
z.string.de.conversationMemberRemoved = '[bold]{{name}}[/bold] hat {{users}} entfernt';
z.string.de.conversationMemberRemovedYou = '[bold]Du[/bold] hast {{users}} entfernt';
z.string.de.conversationTeamLeft = '[bold]{{name}}[/bold] wurde aus dem Team entfernt';
z.string.de.conversationMessageDelivered = 'Zugestellt';
z.string.de.conversationRename = ' hat die Unterhaltung umbenannt';
z.string.de.conversationRenameYou = ' hast die Unterhaltung umbenannt';
z.string.de.conversationUpdatedTimer = ' hat temporäre Nachrichten auf {{time}} gestellt';
z.string.de.conversationUpdatedTimerYou = ' hast temporäre Nachrichten auf {{time}} gestellt';
z.string.de.conversationResetTimer = ' hat temporäre Nachrichten ausgeschaltet';
z.string.de.conversationResetTimerYou = ' hast temporäre Nachrichten ausgeschaltet';
z.string.de.conversationResume = 'Beginne eine Unterhaltung mit {{users}}';
z.string.de.conversationPing = ' hat gepingt';
z.string.de.conversationPingYou = ' hast gepingt';
z.string.de.conversationToday = 'Heute';
z.string.de.conversationVoiceChannelDeactivate = ' hat versucht anzurufen';
z.string.de.conversationVoiceChannelDeactivateYou = ' hast versucht anzurufen';
z.string.de.conversationYesterday = 'Gestern';
z.string.de.conversationUnableToDecrypt1 = 'Eine Nachricht von [highlight]{{user}}[/highlight] wurde nicht empfangen.';
z.string.de.conversationUnableToDecrypt2 = '[highlight]{{users}}s[/highlight] Geräte-Identität hat sich geändert. Nachricht kann nicht entschlüsselt werden.';
z.string.de.conversationUnableToDecryptLink = 'Warum?';
z.string.de.conversationUnableToDecryptErrorMessage = 'Fehler';
z.string.de.conversationUnableToDecryptResetSession = 'Session zurücksetzen';
z.string.de.conversationMissedMessages = 'Du hast Wire eine Weile nicht benutzt. Einige ältere Nachrichten könnten nicht angezeigt werden.';
z.string.de.conversationAssetUploading = 'Hochladen…';
z.string.de.conversationAssetDownloading = 'Herunterladen…';
z.string.de.conversationAssetUploadFailed = 'Hochladen fehlgeschlagen';
z.string.de.conversationPlaybackError = 'Konnte nicht abgespielt werden';
z.string.de.conversationContextMenuCopy = 'Kopieren';
z.string.de.conversationContextMenuEdit = 'Bearbeiten';
z.string.de.conversationContextMenuDelete = 'Für mich löschen…';
z.string.de.conversationContextMenuDeleteEveryone = 'Für alle löschen…';
z.string.de.conversationContextMenuDownload = 'Herunterladen';
z.string.de.conversationContextMenuLike = 'Gefällt mir';
z.string.de.conversationContextMenuReply = 'Antworten';
z.string.de.conversationContextMenuUnlike = 'Gefällt mir nicht mehr';
z.string.de.conversationDeleteTimestamp = 'Gelöscht: {{date}}';
z.string.de.conversationEditTimestamp = 'Editiert: {{date}}';
z.string.de.conversationLikesCaption = '{{number}} Personen';
z.string.de.conversationSendPastedFile = 'Bild eingefügt am {{date}}';
z.string.de.conversationSomeone = 'Jemand';
z.string.de.conversationTweetAuthor = ' auf Twitter';
z.string.de.conversationServicesWarning = 'Dienste haben Zugriff auf den Inhalt dieser Unterhaltung';

z.string.de.groupCreationPreferencesAction = 'Weiter';
z.string.de.groupCreationPreferencesErrorNameShort = 'Gib mindestens ein Zeichen ein';
z.string.de.groupCreationPreferencesErrorNameLong = 'Der eingegebene Gruppenname ist zu lang';
z.string.de.groupCreationPreferencesHeader = 'Gruppe erstellen';
z.string.de.groupCreationPreferencesPlaceholder = 'Gruppenname';
z.string.de.groupCreationParticipantsActionCreate = 'Fertig';
z.string.de.groupCreationParticipantsActionSkip = 'Überspringen';
z.string.de.groupCreationParticipantsHeader = 'Personen hinzufügen';
z.string.de.groupCreationParticipantsHeaderWithCounter = 'Personen hinzufügen ({{number}})';
z.string.de.groupCreationParticipantsPlaceholder = 'Nach Namen suchen';
z.string.de.groupSizeInfo = 'Bis zu {{count}} Personen können an einer Unterhaltung teilnehmen. Videoanrufe funktionieren mit bis zu 3 anderen Personen und dir.';

z.string.de.guestRoomConversationName = 'Gästebereich';
z.string.de.guestRoomToggleName = 'Gäste und Dienste zulassen';
z.string.de.guestRoomToggleInfo = 'Öffne diese Unterhaltung für Dienste und Personen außerhalb des Teams.';
z.string.de.guestRoomToggleInfoExtended = 'Öffne diese Unterhaltung für Dienste und Personen außerhalb des Teams. Diese Einstellung kann später jederzeit geändert werden.';

z.string.de.guestRoomConversationBadge = 'Gäste anwesend';
z.string.de.guestRoomConversationBadgeService = 'Dienste aktiv';
z.string.de.guestRoomConversationBadgeGuestAndService = 'Gäste und Dienste anwesend';

z.string.de.guestRoomConversationHead = 'Personen außerhalb des Teams können an dieser Unterhaltung teilnehmen.';
z.string.de.guestRoomConversationButton = 'Personen einladen';

z.string.de.collectionShowAll = 'Zeige alle {{number}}';
z.string.de.collectionSectionLinks = 'Links';
z.string.de.collectionSectionImages = 'Bilder';
z.string.de.collectionSectionFiles = 'Dateien';
z.string.de.collectionSectionAudio = 'Audio-Nachrichten';

z.string.de.fullsearchPlaceholder = 'Nachrichten durchsuchen';
z.string.de.fullsearchNoResults = 'Kein Treffer';

z.string.de.archiveHeader = 'Archivieren';

z.string.de.conversationsAllArchived = 'Alle Unterhaltungen archiviert';
z.string.de.conversationsContacts = 'Kontakte';
z.string.de.conversationsConnectionRequestMany = '{{number}} Kontaktanfragen';
z.string.de.conversationsConnectionRequestOne = 'Eine Kontaktanfrage';
z.string.de.conversationsEmptyConversation = 'Gruppenunterhaltung';
z.string.de.conversationsNoConversations = 'Beginne eine Unterhaltung oder erstelle eine Gruppe.';
z.string.de.conversationsPopoverArchive = 'Archivieren';
z.string.de.conversationsPopoverBlock = 'Blockieren…';
z.string.de.conversationsPopoverCancel = 'Anfrage abbrechen';
z.string.de.conversationsPopoverClear = 'Unterhaltungsverlauf löschen…';
z.string.de.conversationsPopoverLeave = 'Gruppe verlassen…';
z.string.de.conversationsPopoverNotificationSettings = 'Benachrichtigungen…';
z.string.de.conversationsPopoverNotify = 'Benachrichtigen';
z.string.de.conversationsPopoverSilence = 'Stummschalten';
z.string.de.conversationsPopoverUnarchive = 'Reaktivieren';

z.string.de.conversationsSecondaryLineEphemeralMention = 'Hat dich erwähnt';
z.string.de.conversationsSecondaryLineEphemeralMentionGroup = 'Jemand hat dich erwähnt';
z.string.de.conversationsSecondaryLineEphemeralMessage = 'Hat eine Nachricht gesendet';
z.string.de.conversationsSecondaryLineEphemeralMessageGroup = 'Jemand hat eine Nachricht gesendet';
z.string.de.conversationsSecondaryLineEphemeralReply = 'Hat dir geantwortet';
z.string.de.conversationsSecondaryLineEphemeralReplyGroup = 'Jemand hat dir geantwortet';
z.string.de.conversationsSecondaryLineIncomingCall = '{{user}} ruft an';
z.string.de.conversationsSecondaryLinePeopleLeft = '{{number}} Personen entfernt';
z.string.de.conversationsSecondaryLinePersonLeft = '{{user}} hat die Unterhaltung verlassen';
z.string.de.conversationsSecondaryLinePersonRemoved = '{{user}} wurde entfernt';
z.string.de.conversationsSecondaryLinePersonRemovedTeam = '{{user}} wurde aus dem Team entfernt';
z.string.de.conversationsSecondaryLinePeopleAdded = '{{user}} Personen wurden hinzugefügt';
z.string.de.conversationsSecondaryLinePersonAdded = '{{user}} wurde hinzugefügt';
z.string.de.conversationsSecondaryLinePersonAddedSelf = '{{user}} ist beigetreten';
z.string.de.conversationsSecondaryLinePersonAddedYou = '{{user}} hat dich hinzugefügt';
z.string.de.conversationsSecondaryLineRenamed = '{{user}} hat die Unterhaltung umbenannt';
z.string.de.conversationsSecondaryLineSummaryMessage = '{{number}} Nachricht';
z.string.de.conversationsSecondaryLineSummaryMessages = '{{number}} Nachrichten';
z.string.de.conversationsSecondaryLineSummaryMention = '{{number}} Erwähnung';
z.string.de.conversationsSecondaryLineSummaryMentions = '{{number}} Erwähnungen';
z.string.de.conversationsSecondaryLineSummaryMissedCall = '{{number}} verpasster Anruf';
z.string.de.conversationsSecondaryLineSummaryMissedCalls = '{{number}} verpasste Anrufe';
z.string.de.conversationsSecondaryLineSummaryPing = '{{number}} Ping';
z.string.de.conversationsSecondaryLineSummaryPings = '{{number}} Pings'
z.string.de.conversationsSecondaryLineSummaryReply = '{{number}} Antwort';
z.string.de.conversationsSecondaryLineSummaryReplies = '{{number}} Antworten';
z.string.de.conversationsSecondaryLineYouLeft = 'Du hast die Unterhaltung verlassen';
z.string.de.conversationsSecondaryLineYouWereRemoved = 'Du wurdest entfent';

z.string.de.takeoverSub = 'Sichere dir deinen persönlichen Benutzernamen auf Wire.';
z.string.de.takeoverLink = 'Erfahre mehr';
z.string.de.takeoverButtonChoose = 'Wähle deinen eigenen';
z.string.de.takeoverButtonKeep = 'Behalte diesen';

z.string.de.inviteMetaKeyMac = 'Cmd';
z.string.de.inviteMetaKeyPc = 'Strg';
z.string.de.inviteHintSelected = 'Zum Kopieren {{metaKey}} + C drücken';
z.string.de.inviteHintUnselected = 'Markieren und {{metaKey}} + C drücken';
z.string.de.inviteHeadline = 'Lade Freunde zu Wire ein';
z.string.de.inviteMessage = 'Ich benutze Wire. Suche nach {{username}} oder gehe auf get.wire.com.';
z.string.de.inviteMessageNoEmail = 'Ich benutze Wire. Gehe auf get.wire.com, um mich als Kontakt hinzuzufügen.';

z.string.de.extensionsBubbleButtonGif = 'Gif';

z.string.de.extensionsGiphyButtonOk = 'Senden';
z.string.de.extensionsGiphyButtonMore = 'Neues Gif';
z.string.de.extensionsGiphyMessage = '{{tag}} • über giphy.com';
z.string.de.extensionsGiphyNoGifs = 'Ups, kein GIF';
z.string.de.extensionsGiphyRandom = 'Zufällig';

z.string.de.addParticipantsConfirmLabel = 'Hinzufügen';
z.string.de.addParticipantsHeader = 'Teilnehmer hinzufügen';
z.string.de.addParticipantsHeaderWithCounter = 'Teilnehmer hinzufügen ({{number}})';
z.string.de.addParticipantsManageServices = 'Dienste verwalten';
z.string.de.addParticipantsManageServicesNoResults = 'Dienste verwalten';
z.string.de.addParticipantsNoServicesManager = 'Dienste sind Helfer, die den Workflow verbessern können.';
z.string.de.addParticipantsNoServicesMember = 'Dienste sind Helfer, die den Workflow verbessern können. Bitte an den Administrator wenden, um diese zu aktivieren.';
z.string.de.addParticipantsSearchPlaceholder = 'Nach Namen suchen';
z.string.de.addParticipantsServiceConfirmButton = 'Dienst hinzufügen';
z.string.de.addParticipantsTabsPeople = 'Kontakte';
z.string.de.addParticipantsTabsServices = 'Dienste';

z.string.de.conversationDetailsActionArchive = 'Archivieren';
z.string.de.conversationDetailsActionAddParticipants = 'Teilnehmer hinzufügen';
z.string.de.conversationDetailsActionBlock = 'Kontakt blockieren…';
z.string.de.conversationDetailsActionCancelRequest = 'Anfrage abbrechen…';
z.string.de.conversationDetailsActionClear = 'Unterhaltungsverlauf löschen…';
z.string.de.conversationDetailsActionConversationParticipants = 'Zeige alle ({{number}})';
z.string.de.conversationDetailsActionCreateGroup = 'Gruppe erstellen';
z.string.de.conversationDetailsActionDevices = 'Geräte';
z.string.de.conversationDetailsActionGuestOptions = 'Gäste und Dienste';
z.string.de.conversationDetailsActionTimedMessages = 'Temporäre Nachrichten';
z.string.de.conversationDetailsActionNotifications = 'Benachrichtigungen';
z.string.de.conversationDetailsActionLeave = 'Gruppe verlassen…';
z.string.de.conversationDetailsGuestsOff = 'Aus';
z.string.de.conversationDetailsGuestsOn = 'An';
z.string.de.conversationDetailsOptions = 'Optionen';
z.string.de.conversationDetailsParticipantsServicesOne = 'Dienst';
z.string.de.conversationDetailsParticipantsServicesMany = 'Dienste';
z.string.de.conversationDetailsParticipantsUsersOne = 'Person';
z.string.de.conversationDetailsParticipantsUsersMany = 'Personen';
z.string.de.conversationDetailsPeople = 'Personen';
z.string.de.conversationDetailsServices = 'Dienste';

z.string.de.conversationParticipantsTitle = 'Unterhaltungsübersicht';
z.string.de.conversationParticipantsSearchPlaceholder = 'Nach Namen suchen';

z.string.de.groupParticipantActionBlock = 'Kontakt blockieren…';
z.string.de.groupParticipantActionCancelRequest = 'Anfrage abbrechen…';
z.string.de.groupParticipantActionDevices = 'Geräte';
z.string.de.groupParticipantActionIgnoreRequest = 'Anfrage ignorieren';
z.string.de.groupParticipantActionIncomingRequest = 'Anfrage akzeptieren';
z.string.de.groupParticipantActionLeave = 'Gruppe verlassen…';
z.string.de.groupParticipantActionOpenConversation = 'Unterhaltung öffnen';
z.string.de.groupParticipantActionPending = 'Ausstehend';
z.string.de.groupParticipantActionRemove = 'Aus Gruppe entfernen…';
z.string.de.groupParticipantActionSelfProfile = 'Profil öffnen';
z.string.de.groupParticipantActionSendRequest = 'Kontakt hinzufügen';
z.string.de.groupParticipantActionUnblock = 'Freigeben…';

z.string.de.guestOptionsCopyLink = 'Link kopieren';
z.string.de.guestOptionsCopyLinkDone = 'Link kopiert!';
z.string.de.guestOptionsCreateLink = 'Link erstellen';
z.string.de.guestOptionsInfoHeader = 'Andere per Link einladen';
z.string.de.guestOptionsInfoText = 'Jeder kann der Gruppe mit diesem Link beitreten - auch ohne eine Wire-Benutzerkonto.';
z.string.de.guestOptionsRevokeLink = 'Link widerrufen';
z.string.de.guestOptionsTitle = 'Gäste und Dienste';

z.string.de.notificationSettingsTitle = 'Benachrichtigungen';
z.string.de.notificationSettingsDisclaimer = 'Immer benachrichtigen (einschließlich Audio- und Videoanrufe) oder nur bei Erwähnungen oder wenn jemand auf eine deiner Nachrichten antwortet.';
z.string.de.notificationSettingsEverything = 'Alles';
z.string.de.notificationSettingsMentionsAndReplies = 'Erwähnungen und Antworten';
z.string.de.notificationSettingsNothing = 'Nichts';

z.string.de.timedMessagesTitle = 'Temporäre Nachrichten';
z.string.de.timedMessageDisclaimer = 'Temporäre Nachrichten werden für alle Teilnehmer dieser Unterhaltung eingeschaltet.';

z.string.de.participantDevicesDetailHeadline = 'Überprüfe, ob dieser Fingerabdruck mit dem auf {{html1}}{{user}}s Gerät{{html2}} übereinstimmt.';
z.string.de.participantDevicesDetailHowTo = 'Wie mache ich das?';
z.string.de.participantDevicesDetailResetSession = 'Session zurücksetzen';
z.string.de.participantDevicesDetailShowMyDevice = 'Zeige meinen Fingerabdruck';
z.string.de.participantDevicesDetailVerify = 'Ok';

z.string.de.participantDevicesHeader = 'Geräte';
z.string.de.participantDevicesHeadline = 'Wire gibt jedem Gerät einen einzigartigen Fingerabdruck. Vergleiche diese mit {{user}} und überprüfe deine Unterhaltung.';
z.string.de.participantDevicesLearnMore = 'Erfahre mehr';
z.string.de.participantDevicesWhyVerify = 'Warum sollte ich meine Unterhaltungen verifizieren?';
z.string.de.participantDevicesOutdatedClientMessage = '{{user}} benutzt eine ältere Version von Wire. Es werden keine Geräte angezeigt.';

z.string.de.participantDevicesSelfAllDevices = 'Alle meine Geräte anzeigen';
z.string.de.participantDevicesSelfFingerprint = 'Fingerabdruck des Geräts';

z.string.de.userProfileButtonConnect = 'Kontakt hinzufügen';
z.string.de.userProfileButtonIgnore = 'Ignorieren';
z.string.de.userProfileButtonUnblock = 'Freigeben';

z.string.de.preferencesAbout = 'Über Wire';
z.string.de.preferencesAccount = 'Benutzerkonto';
z.string.de.preferencesAV = 'Audio / Video';
z.string.de.preferencesDeviceDetails = 'Gerätedetails';
z.string.de.preferencesDevices = 'Geräte';
z.string.de.preferencesHeadline = 'Einstellungen';
z.string.de.preferencesOptions = 'Optionen';

z.string.de.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.de.preferencesAboutPrivacyPolicy = 'Datenschutzrichtlinie';
z.string.de.preferencesAboutSupport = 'Support';
z.string.de.preferencesAboutSupportWebsite = 'Support-Webseite';
z.string.de.preferencesAboutSupportContact = 'Kontaktiere den Support';
z.string.de.preferencesAboutTermsOfUse = 'Nutzungsbedingungen';
z.string.de.preferencesAboutVersion = 'Version {{version}}';
z.string.de.preferencesAboutWebsite = 'Wire-Webseite';

z.string.de.preferencesAccountAvaibilityUnset = 'Wähle einen Status';
z.string.de.preferencesAccountCreateTeam = 'Team erstellen';
z.string.de.preferencesAccountData = 'Datennutzung';
z.string.de.preferencesAccountDataCheckbox = 'Anonyme Nutzungsdaten senden';
z.string.de.preferencesAccountDataDetail = 'Anonymisierte Nutzungs- und Fehlerberichte schicken, um Wire zu verbessern.';
z.string.de.preferencesAccountDelete = 'Benutzerkonto löschen';
z.string.de.preferencesAccountLeaveGuestRoom = 'Gästebereich verlassen';
z.string.de.preferencesAccountLeaveGuestRoomDescription = 'Du wirst nicht länger auf die Nachrichten dieser Unterhaltung zugreifen können.';
z.string.de.preferencesAccountLogOut = 'Abmelden';
z.string.de.preferencesAccountManageTeam = 'Team verwalten';
z.string.de.preferencesAccountMarketingConsentCheckbox = 'Newsletter abonnieren';
z.string.de.preferencesAccountMarketingConsentDetail = 'Neuigkeiten und Informationen zu Produktaktualisierungen von Wire per E-Mail erhalten.';
z.string.de.preferencesAccountResetPassword = 'Passwort zurücksetzen';
z.string.de.preferencesAccountTeam = 'in {{name}}';
z.string.de.preferencesAccountUsernamePlaceholder = 'Dein vollständiger Name';
z.string.de.preferencesAccountUsernameHint = 'Mindestens zwei Zeichen. a—z, 0—9, und _.';
z.string.de.preferencesAccountUsernameAvailable = 'Verfügbar';
z.string.de.preferencesAccountUsernameErrorTaken = 'Bereits vergeben';

z.string.de.preferencesAVCamera = 'Kamera';
z.string.de.preferencesAVMicrophone = 'Mikrofon';
z.string.de.preferencesAVPermissionDetail = 'In deinen Browser-Einstellungen aktivieren';
z.string.de.preferencesAVSpeakers = 'Lautsprecher';
z.string.de.preferencesAVTemporaryDisclaimer = 'Gäste können Videokonferenzen nicht selbst starten. Wähle die Kamera aus, die bei der Teilnahme verwendet werden soll.';
z.string.de.preferencesAVNoCamera = 'Wire hat keinen Zugriff auf die Kamera.[br][faqLink]Zur Behebung bitte diesen Support Artikel anschauen[/faqLink].';
z.string.de.preferencesAVTryAgain = 'Erneut versuchen';

z.string.de.preferencesDevicesActivatedOn = 'Aktiviert {{date}}';
z.string.de.preferencesDevicesActive = 'Aktiv';
z.string.de.preferencesDevicesActiveDetail = 'Falls du eines dieser Geräte nicht erkennst, entferne es und setze dein Passwort zurück.';
z.string.de.preferencesDevicesCurrent = 'Dieses Gerät';
z.string.de.preferencesDevicesFingerprint = 'Schlüssel-Fingerabdruck';
z.string.de.preferencesDevicesFingerprintDetail = 'Wire gibt jedem Gerät einen einzigartigen Fingerabdruck. Vergleiche diese und verifiziere deine Geräte und Unterhaltungen.';
z.string.de.preferencesDevicesId = 'ID: ';
z.string.de.preferencesDevicesRemove = 'Entfernen…';
z.string.de.preferencesDevicesRemoveCancel = 'Abbrechen';
z.string.de.preferencesDevicesRemoveDetail = 'Entferne das Gerät, wenn du es nicht mehr nutzt. Du wirst auf diesem Gerät umgehend abgemeldet.';
z.string.de.preferencesDevicesSessionConfirmation = 'Die Session wurde zurückgesetzt.';
z.string.de.preferencesDevicesSessionDetail = 'Falls die Fingerabdrücke nicht übereinstimmen, setze die Session zurück um neue Verschlüsselungs-Schlüssel auf beiden Seiten zu erstellen.';
z.string.de.preferencesDevicesSessionReset = 'Session zurücksetzen';
z.string.de.preferencesDevicesSessionOngoing = 'Setze Session zurück…';
z.string.de.preferencesDevicesVerification = 'Verifiziert';

z.string.de.preferencesOptionsAudio = 'Benachrichtigungstöne';
z.string.de.preferencesOptionsAudioAll = 'Alle';
z.string.de.preferencesOptionsAudioAllDetail = 'Alle Töne';
z.string.de.preferencesOptionsAudioNone = 'Keine';
z.string.de.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.de.preferencesOptionsAudioSome = 'Einige';
z.string.de.preferencesOptionsAudioSomeDetail = 'Pings und Anrufe';
z.string.de.preferencesOptionsContacts = 'Kontakte';
z.string.de.preferencesOptionsContactsGmail = 'Aus Gmail importieren';
z.string.de.preferencesOptionsContactsMacos = 'Aus Kontakte importieren';
z.string.de.preferencesOptionsContactsDetail = 'Wir verwenden deine Daten, um Kontakte für dich zu erstellen. Wir anonymisieren alle Informationen und teilen sie mit niemand anderem.';
z.string.de.preferencesOptionsPopular = 'Auf allgemeinen Wunsch';
z.string.de.preferencesOptionsEmojiReplaceCheckbox = 'Schrift-Emoticons mit Emojis ersetzen';
z.string.de.preferencesOptionsEmojiReplaceDetail = ':-) → [icon]';
z.string.de.preferencesOptionsPreviewsSendCheckbox = 'Vorschau beim Senden von Links erstellen';
z.string.de.preferencesOptionsPreviewsSendDetail = 'Vorschauen können weiterhin für von anderen Personen gesendete Links angezeigt werden.';
z.string.de.preferencesOptionsNotifications = 'Benachrichtigungen';
z.string.de.preferencesOptionsNotificationsNone = 'Aus';
z.string.de.preferencesOptionsNotificationsObfuscate = 'Details verbergen';
z.string.de.preferencesOptionsNotificationsObfuscateMessage = 'Absendername zeigen';
z.string.de.preferencesOptionsNotificationsOn = 'Zeige Absendername und Nachricht';
z.string.de.preferencesOptionsCallLogs = 'Fehlerbehebung';
z.string.de.preferencesOptionsCallLogsGet = 'Anruf-Fehlerbericht speichern';
z.string.de.preferencesOptionsCallLogsDetail = 'Diese Informationen helfen uns, Probleme bei Anrufen zu diagnostizieren.';

z.string.de.preferencesOptionsBackupHeader = 'Gesprächsverlauf';
z.string.de.preferencesOptionsBackupExportHeadline = 'Unterhaltungen sichern';
z.string.de.preferencesOptionsBackupExportSecondary = 'Erstelle ein Backup, um den Gesprächsverlauf zu sichern. Damit können Unterhaltungen wiederhergestellt werden, falls du deinen Computer verlierst oder einen neuen nutzen möchtest.\n\nWähle ein sicheres Passwort, um die Backup-Datei zu schützen.';
z.string.de.preferencesOptionsBackupImportHeadline = 'Backup wiederherstellen';
z.string.de.preferencesOptionsBackupImportSecondary = 'Es können nur Backup-Dateien derselben Plattform wiederhergestellt werden. Der Inhalt der Backup-Datei ersetzt den Gesprächsverlauf auf diesem Gerät.';

z.string.de.backupExportGenericErrorHeadline = 'Datei nicht gespeichert';
z.string.de.backupExportGenericErrorSecondary = 'Das Backup wurde nicht abgeschlossen.';
z.string.de.backupExportProgressHeadline = 'Vorbereiten…';
z.string.de.backupExportProgressSecondary = 'Erstelle Backup · {{processed}} von {{total}} — {{progress}}%';
z.string.de.backupExportProgressCompressing = 'Backup-Datei wird erstellt';
z.string.de.backupExportSaveFileAction = 'Backup speichern';
z.string.de.backupExportSuccessHeadline = 'Backup erstellt';
z.string.de.backupExportSuccessSecondary = 'Mit diesem Backup kann der Gesprächsverlauf wiederhergestellt werden, wenn du dein Gerät verlierst oder zu einem neuen wechselst.';
z.string.de.backupImportGenericErrorHeadline = 'Fehler aufgetreten';
z.string.de.backupImportGenericErrorSecondary = 'Der Gesprächsverlauf konnte nicht wiederhergestellt werden.';
z.string.de.backupImportAccountErrorHeadline = 'Falsches Backup';
z.string.de.backupImportAccountErrorSecondary = 'Der Gesprächsverlauf eines anderen Kontos kann nicht wiederhergestellt werden.';
z.string.de.backupImportVersionErrorHeadline = 'Inkompatibles Backup';
z.string.de.backupImportVersionErrorSecondary = 'Diese Backup-Datei wurde von einer anderen Version von Wire erstellt und kann deshalb nicht wiederhergestellt werden.';
z.string.de.backupImportIncompatibleErrorHeadline = 'Falsches Backup';
z.string.de.backupImportIncompatibleErrorSecondary = 'Der Gesprächsverlauf eines anderen Benutzerkontos kann nicht wiederhergestellt werden.';
z.string.de.backupImportOutdatedErrorHeadline = 'Inkompatibles Backup';
z.string.de.backupImportOutdatedErrorSecondary = 'Diese Backup-Datei wurde von einer anderen Version von Wire erstellt und kann deshalb nicht wiederhergestellt werden.';
z.string.de.backupImportProgressHeadline = 'Vorbereiten…';
z.string.de.backupImportProgressSecondary = 'Stelle Gesprächsverlauf wieder her · {{processed}} von {{total}} — {{progress}}%';
z.string.de.backupImportSuccessHeadline = 'Gesprächsverlauf wiederhergestellt.';
z.string.de.backupCancel = 'Abbrechen';
z.string.de.backupTryAgain = 'Erneut versuchen';

z.string.de.searchConnect = 'Vorschläge';
z.string.de.searchConnections = 'Kontakte';
z.string.de.searchContacts = 'Kontakte';
z.string.de.searchCreateGroup = 'Gruppe erstellen';
z.string.de.searchCreateGuestRoom = 'Gästebereich erstellen';
z.string.de.searchGroups = 'Gruppen';
z.string.de.searchPeople = 'Kontakte';
z.string.de.searchPlaceholder = 'Name oder Benutzername suchen';
z.string.de.searchServicePlaceholder = 'Nach Namen suchen';
z.string.de.searchServices = 'Dienste';
z.string.de.searchManageServices = 'Dienste verwalten';
z.string.de.searchManageServicesNoResults = 'Dienste verwalten';
z.string.de.searchNoServicesManager = 'Dienste sind Helfer, die den Workflow verbessern können.';
z.string.de.searchNoServicesMember = 'Dienste sind Helfer, die den Workflow verbessern können. Bitte an den Administrator wenden, um diese für das Team zu aktivieren.';
z.string.de.searchTeamGroups = 'Team-Gruppen';
z.string.de.searchTeamMembers = 'Team-Mitglieder';
z.string.de.searchTopPeople = 'Top Kontakte';
z.string.de.searchTrySearch = 'Finde Kontakte anhand ihres\nNamens oder Benutzernamens';
z.string.de.searchNoContactsOnWire = 'Du hast keine Kontakte auf Wire.\nSuche nach Namen\noder Benutzernamen.';
z.string.de.searchMemberInvite = 'Lade weitere Mitglieder ein';
z.string.de.searchOthers = 'Suchergebnisse';

z.string.de.searchInvite = 'Lade Freunde zu Wire ein';
z.string.de.searchInviteDetail = 'Wir verwenden deine Kontaktdaten, um Kontakte für dich zu erstellen. Wir anonymisieren alle Informationen und geben sie nicht weiter.';
z.string.de.searchInviteButtonContacts = 'Aus Kontakte';
z.string.de.searchInviteButtonGmail = 'Aus Gmail';
z.string.de.searchInviteHeadline = 'Hole deine Freunde';
z.string.de.searchInviteShare = 'Teile deine Kontakte';

z.string.de.searchServiceConfirmButton = 'Unterhaltung öffnen';

z.string.de.searchListEveryoneParticipates = 'Alle deine Kontakte\nsind bereits in\ndieser Unterhaltung.';
z.string.de.searchListNoMatches = 'Kein passendes Ergebnis.\nSuche nach einen\nanderen Namen.';

z.string.de.temporaryGuestCta = 'Erstelle ein Benutzerkonto';
z.string.de.temporaryGuestDescription = 'Für sichere Unternehmen mit verschlüsselter Kommunikation in Gruppen und Telefonkonferenzen.';
z.string.de.temporaryGuestTimeRemaining = ' verbleibend in diesem Gästebereich';

z.string.de.temporaryGuestJoinMessage = 'Diese Unterhaltung steht für dich 24 Stunden lang zur Verfügung.';
z.string.de.temporaryGuestJoinDescription = 'Wenn du diese Seite schließt oder neu lädst, verlierst du den Zugriff.';

z.string.de.temporaryGuestLeaveMessage = ' bist nicht länger Teil dieser Unterhaltung.';
z.string.de.temporaryGuestLeaveDescription = 'Wenn du diese Seite schließt oder neu lädst, verlierst du den Zugriff auf den Unterhaltungsverlauf.';

z.string.de.uploadGoogleHeadline = 'Finde Kontakte \nauf Wire.';
z.string.de.uploadGoogleMessage = 'Wir verwenden deine Daten, um Kontakte für dich zu erstellen. Wir anonymisieren alle Informationen und teilen sie mit niemand anderem.';

z.string.de.urlSupportRoot = '/hc/de/';
z.string.de.urlSupportArticles = '/hc/de/articles/';
z.string.de.urlSupportRequests = '/hc/de/requests/';
z.string.de.urlWebappRoot = '/?hl=de';
z.string.de.urlWebsiteRoot = '/de/';
z.string.de.urlWebsiteCreateTeam = '/de/create-team/';
z.string.de.urlWebsitePrivacy = '/de/privacy/';
z.string.de.warningCallUnsupportedIncoming = '{{user}} ruft an. Dein Browser unterstützt keine Anrufe.';
z.string.de.warningCallUnsupportedOutgoing = 'Du kannst nicht anrufen, da dein Browser keine Anfrufe unterstützt.';
z.string.de.warningCallIssues = 'Diese Version von Wire kann nicht an Anrufen teilnehmen. Nutze';
z.string.de.warningCallUpgradeBrowser = 'Für Anrufe aktualisiere Google Chrome.';
z.string.de.warningConnectivityConnectionLost = 'Verbindung wird wiederhergestellt. Wire kann Nachrichten möglicherweise nicht empfangen.';
z.string.de.warningConnectivityNoInternet = 'Keine Internetverbindung. Du kannst keine Nachrichten senden und empfangen.';
z.string.de.warningLearnMore = 'Erfahre mehr';
z.string.de.warningLifecycleUpdate = 'Eine neue Version von Wire ist verfügbar.';
z.string.de.warningLifecycleUpdateNotes = 'Was ist neu';
z.string.de.warningLifecycleUpdateLink = 'Jetzt aktualisieren';
z.string.de.warningNotFoundCamera = 'Du kannst nicht anrufen, da dein Computer keine Kamera hat.';
z.string.de.warningNotFoundMicrophone = 'Du kannst nicht anrufen, da dein Computer kein Mikrofon hat.';
z.string.de.warningPermissionDeniedCamera = 'Du kannst nicht anrufen, da dein Browser keinen Zugriff auf die Kamera hat.';
z.string.de.warningPermissionDeniedMicrophone = 'Du kannst nicht anrufen, da dein Browser keinen Zugriff auf das Mikrofon hat.';
z.string.de.warningPermissionDeniedScreen = 'Der Browser braucht die Berechtigung zur Bildschirmfreigabe.';
z.string.de.warningPermissionRequestCamera = '[icon] Zugriff auf Kamera gewähren';
z.string.de.warningPermissionRequestMicrophone = '[icon] Zugriff auf Mikrofon gewähren';
z.string.de.warningPermissionRequestNotification = '[icon] Benachrichtigungen zulassen';
z.string.de.warningPermissionRequestScreen = '[icon] Zugriff auf Bildschirm gewähren';

z.string.de.userAvailabilityAvailable = 'Verfügbar';
z.string.de.userAvailabilityAway = 'Abwesend';
z.string.de.userAvailabilityBusy = 'Beschäftigt';
z.string.de.userAvailabilityNone = 'Keine';

z.string.de.notificationAssetAdd = 'Hat ein Bild geteilt';
z.string.de.notificationConnectionAccepted = 'Hat deine Kontaktanfrage akzeptiert';
z.string.de.notificationConnectionConnected = 'Ist jetzt ein Kontakt von dir';
z.string.de.notificationConnectionRequest = 'Möchte dich als Kontakt hinzufügen';
z.string.de.notificationConversationCreate = '{{user}} hat eine Unterhaltung begonnen';
z.string.de.notificationConversationMessageTimerUpdate = '{{user}} hat temporäre Nachrichten auf {{time}} gestellt';
z.string.de.notificationConversationMessageTimerReset = '{{user}} hat temporäre Nachrichten ausgeschaltet';
z.string.de.notificationConversationRename = '{{user}} hat die Unterhaltung in {{name}} umbenannt';
z.string.de.notificationMemberJoinMany = '{{user}} hat {{number}} Kontakte zur Unterhaltung hinzugefügt';
z.string.de.notificationMemberJoinSelf = '{{user}} ist der Unterhaltung beigetreten';
z.string.de.notificationMemberJoinOne = '{{user1}} hat {{user2}} zur Unterhaltung hinzugefügt';
z.string.de.notificationMemberLeaveRemovedYou = '{{user}} hat dich aus der Unterhaltung entfernt';
z.string.de.notificationMention = 'Erwähnung: {{text}}';
z.string.de.notificationObfuscated = 'Hat eine Nachricht gesendet';
z.string.de.notificationObfuscatedMention = 'Hat dich erwähnt';
z.string.de.notificationObfuscatedReply = 'Hat dir geantwortet';
z.string.de.notificationObfuscatedTitle = 'Jemand';
z.string.de.notificationPing = 'Hat gepingt';
z.string.de.notificationReaction = '{{reaction}} deine Nachricht';
z.string.de.notificationReply = 'Antwort: {{text}}';
z.string.de.notificationSharedAudio = 'Hat eine Audio-Nachricht geteilt';
z.string.de.notificationSharedFile = 'Hat eine Datei geteilt';
z.string.de.notificationSharedLocation = 'Hat einen Standort geteilt';
z.string.de.notificationSharedVideo = 'Hat ein Video geteilt';
z.string.de.notificationTitleGroup = '{{user}} in {{conversation}}';
z.string.de.notificationVoiceChannelActivate = 'Ruft an';
z.string.de.notificationVoiceChannelDeactivate = 'Hat versucht anzurufen';

z.string.de.tooltipConversationAllVerified = 'Alle Fingerabdrücke sind überprüft';
z.string.de.tooltipConversationCall = 'Anruf';
z.string.de.tooltipConversationEphemeral = 'Temporäre Nachricht';
z.string.de.tooltipConversationFile = 'Datei senden';
z.string.de.tooltipConversationInputPlaceholder = 'Schreibe eine Nachricht';
z.string.de.tooltipConversationInputPlaceholderAvailable = '{{user}} ist verfügbar';
z.string.de.tooltipConversationInputPlaceholderAway = '{{user}} ist abwesend';
z.string.de.tooltipConversationInputPlaceholderBusy = '{{user}} ist beschäftigt';
z.string.de.tooltipConversationPeople = 'Unterhaltungsübersicht ({{shortcut}})';
z.string.de.tooltipConversationPicture = 'Bild senden';
z.string.de.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.de.tooltipConversationSearch = 'Suche';
z.string.de.tooltipConversationVideoCall = 'Videoanruf';

z.string.de.tooltipConversationsArchive = 'Archivieren ({{shortcut}})';
z.string.de.tooltipConversationsArchived = 'Archiv anzeigen ({{number}})';
z.string.de.tooltipConversationsMore = 'Mehr';
z.string.de.tooltipConversationsNotifications = 'Benachrichtigungseinstellungen öffnen ({{shortcut}})';
z.string.de.tooltipConversationsNotify = 'Benachrichtigen ({{shortcut}})';
z.string.de.tooltipConversationsPreferences = 'Einstellungen öffnen';
z.string.de.tooltipConversationsSilence = 'Stummschalten ({{shortcut}})';
z.string.de.tooltipConversationsStart = 'Unterhaltung beginnen ({{shortcut}})';

z.string.de.tooltipConversationDetailsAddPeople = 'Teilnehmer zur Unterhaltung hinzufügen ({{shortcut}})';
z.string.de.tooltipConversationDetailsRename = 'Unterhaltung umbenennen';

z.string.de.tooltipPreferencesContactsGmail = 'Melde dich an deinem Gmail-Konto an, um deine Kontakte zu teilen';
z.string.de.tooltipPreferencesContactsMacos = 'Teile alle deine Kontakte aus der macOS Kontakte-App';
z.string.de.tooltipPreferencesPassword = 'Öffne eine andere Website, um dein Passwort zurückzusetzen';
z.string.de.tooltipPreferencesPicture = 'Ändere dein Bild…';
z.string.de.tooltipPreferencesRename = 'Ändere deinen Namen';

z.string.de.tooltipSearchClose = 'Schließen (Esc)';

z.string.de.initReceivedSelfUser = 'Hallo, {{user}}.';
z.string.de.initValidatedClient = 'Lade deine Kontakte und Unterhaltungen';
z.string.de.initReceivedUserData = 'Suche nach neuen Events';
z.string.de.initDecryption = 'Entschlüssele Events';
z.string.de.initEvents = 'Lade Nachrichten';
z.string.de.initUpdatedFromNotifications = 'Fast fertig - viel Spaß mit Wire';
z.string.de.initProgress = ' — {{number1}} von {{number2}}';

z.string.de.ephemeralUnitsNone = 'Aus';
z.string.de.ephemeralUnitsSecond = 'Sekunde';
z.string.de.ephemeralUnitsSeconds = 'Sekunden';
z.string.de.ephemeralUnitsMinute = 'Minute';
z.string.de.ephemeralUnitsMinutes = 'Minuten';
z.string.de.ephemeralUnitsHour = 'Stunde';
z.string.de.ephemeralUnitsHours = 'Stunden';
z.string.de.ephemeralUnitsDay = 'Tag';
z.string.de.ephemeralUnitsDays = 'Tage';
z.string.de.ephemeralUnitsWeek = 'Woche';
z.string.de.ephemeralUnitsWeeks = 'Wochen';
z.string.de.ephemeralUnitsYear = 'Jahr';
z.string.de.ephemeralUnitsYears = 'Jahre';
z.string.de.ephemeralRemaining = 'verbleibend';

z.string.de.replyAudioMessage = 'Audionachricht';
z.string.de.replyQuoteError = 'Diese Nachricht ist nicht sichtbar.';
z.string.de.replyQuoteShowMore = 'Mehr anzeigen';
z.string.de.replyQuoteShowLess = 'Weniger anzeigen';
z.string.de.replyQuoteTimeStampDate = 'Ursprüngliche Nachricht vom {{date}}';
z.string.de.replyQuoteTimeStampTime = 'Ursprüngliche Nachricht von {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.el.wireMacos = 'Wire για macOS';
z.string.el.wireWindows = 'Wire για Windows';
z.string.el.wireLinux = 'Wire για Linux';
z.string.el.nonexistentUser = 'Διεγραμμένος χρήστης';
z.string.el.and = 'και';
z.string.el.enumerationAnd = ', και ';

z.string.el.authAccountCountryCode = 'Κωδικός Χώρας';
z.string.el.authAccountPasswordForgot = 'Ξέχασα τον κωδικό πρόσβασης';
z.string.el.authAccountPublicComputer = 'Αυτός είναι ένας δημόσιος υπολογιστής';
z.string.el.authAccountSignIn = 'Σύνδεση';
z.string.el.authAccountSignInPhone = 'Τηλεφωνο';

z.string.el.authBlockedCookies = 'Ενεργοποιήστε τα cookies για να συνδεθείτε στο Wire.';
z.string.el.authBlockedDatabase = 'Το Wire χρειάζεται πρόσβαση σε τοπικό αποθηκευτικό χώρο για την προβολή των μηνυμάτων σας. Η τοπική αποθήκευση δεν είναι διαθέσιμη σε ιδιωτική λειτουργία.';
z.string.el.authBlockedTabs = 'Το Wire είναι ήδη ανοικτό σε άλλη καρτέλα.';

z.string.el.authVerifyAccountAdd = 'Προσθήκη';
z.string.el.authVerifyAccountDetail = 'Αυτό σας επιτρέπει να χρησιμοποιήσετε το Wire σε πολλαπλές συσκευές.';
z.string.el.authVerifyAccountHeadline = 'Προσθέστε email και κωδικό πρόσβασης.';
z.string.el.authVerifyAccountLogout = 'Αποσύνδεση';
z.string.el.authVerifyCodeDescription = 'Εισάγετε τον κωδικό επαλήθευσης που στείλαμε στο {{number}}.';
z.string.el.authVerifyCodeResend = 'Δεν εμφανίζεται ο κωδικός;';
z.string.el.authVerifyCodeResendDetail = 'Επαναποστολή';
z.string.el.authVerifyCodeResendTimer = 'Μπορείτε να ζητήσετε νέο κωδικό {{expiration}}.';
z.string.el.authVerifyCodeChangePhone = 'Αλλαγή αριθμού τηλεφώνου';
z.string.el.authVerifyPasswordHeadline = 'Εισάγετε τον κωδικό σας';

z.string.el.authLimitDevicesHeadline = 'Συσκευές';
z.string.el.authLimitDescription = 'Αφαιρέστε μία από τις άλλες συσκευές σας για να αρχίσετε να χρησιμοποιείτε το Wire σε αυτήν.';
z.string.el.authLimitButtonManage = 'Διαχείριση συσκευών';
z.string.el.authLimitButtonSignOut = 'Αποσύνδεση';
z.string.el.authLimitDevicesCurrent = '(Τρέχουσα)';

z.string.el.authHistoryHeadline = 'Είναι η πρώτη φορά που χρησιμοποιείτε το Wire σε αυτήν τη συσκευή.';
z.string.el.authHistoryDescription = 'Για λόγους απορρήτου, το ιστορικό συνομιλιών σας δεν θα εμφανίζεται εδώ.';
z.string.el.authHistoryReuseHeadline = 'Έχετε χρησιμοποιήσει ξανά το Wire σε αυτήν την συσκευή.';
z.string.el.authHistoryReuseDescription = 'Τα μηνύματα που αποστέλλονται  την ίδια στιγμή δεν θα εμφανίζονται εδώ.';
z.string.el.authHistoryButton = 'Εντάξει';

z.string.el.authPostedResend = 'Επαναποστολή σε {{email}}';
z.string.el.authPostedResendAction = 'Δεν εμφανίζεται το email;';
z.string.el.authPostedResendDetail = 'Ελέγξτε τα email σας και ακολουθήστε τις οδηγίες που θα βρείτε.';
z.string.el.authPostedResendHeadline = 'Έχετε μήνυμα.';

z.string.el.authPlaceholderEmail = 'Email';
z.string.el.authPlaceholderPasswordPut = 'Κωδικός Πρόσβασης';
z.string.el.authPlaceholderPasswordSet = 'Κωδικος προσβασης (το λιγοτερο 8 χαρακτηρες)';
z.string.el.authPlaceholderPhone = 'Αριθμός Κινητού Τηλεφώνου';

z.string.el.authErrorCode = 'Μη έγκυρος κωδικός';
z.string.el.authErrorCountryCodeInvalid = 'Μη έγκυρος κωδικός χώρας';
z.string.el.authErrorEmailExists = 'Η Διεύθυνση Ηλ. Ταχυδρομείου χρησιμοποιείται ήδη';
z.string.el.authErrorEmailForbidden = 'Λυπούμαστε. Αυτή η διεύθυνση email δεν επιτρέπεται.';
z.string.el.authErrorEmailMalformed = 'Παρακαλούμε εισάγετε μια έγκυρη διεύθυνση email.';
z.string.el.authErrorEmailMissing = 'Παρακαλώ εισάγετε μια διεύθυνση email.';
z.string.el.authErrorMisc = 'Προβλήματα σύνδεσης. Παρακαλούμε δοκιμάστε ξανά.';
z.string.el.authErrorNameShort = 'Πληκτρολογήστε ένα όνομα με τουλάχιστον 2 χαρακτήρες';
z.string.el.authErrorOffline = 'Δεν υπάρχει σύνδεση στο διαδίκτυο';
z.string.el.authErrorPasswordShort = 'Επιλέξτε έναν κωδικό πρόσβασης με τουλάχιστον 8 χαρακτήρες.';
z.string.el.authErrorPasswordWrong = 'Λανθασμένος κωδικός. Παρακαλούμε δοκιμάστε ξανά.';
z.string.el.authErrorPhoneNumberBudget = 'Έχετε συνδεθεί πολλές φορές. Προσπαθήστε ξανά αργότερα.';
z.string.el.authErrorPhoneNumberForbidden = 'Λυπούμαστε. Αυτός ο αριθμός τηλεφώνου δεν είναι επιτρεπτός.';
z.string.el.authErrorPhoneNumberInvalid = 'Μη έγκυρος αριθμός τηλεφώνου';
z.string.el.authErrorPhoneNumberUnknown = 'Άγνωστος αριθμός τηλεφώνου';
z.string.el.authErrorSuspended = 'Αυτός ο λογαριασμός δεν είναι πλέον εξουσιοδοτημένος για σύνδεση.';
z.string.el.authErrorSignIn = 'Παρακαλούμε επιβεβαιώστε τα στοιχεία σας και προσπαθήστε ξανά.';

z.string.el.callStateOutgoing = 'Καλεί…';
z.string.el.callStateConnecting = 'Συνδέεται…';
z.string.el.callStateIncoming = 'Καλεί…';
z.string.el.callDecline = 'Απόρριψη';
z.string.el.callAccept = 'Αποδοχή';
z.string.el.callJoin = 'Συμμετοχή';
z.string.el.callChooseSharedScreen = 'Επιλέξτε μια οθόνη για κοινή χρήση';
z.string.el.callParticipants = '{{number}} στο τηλεφώνημα';

z.string.el.videoCallOverlayMute = 'Σίγαση';
z.string.el.videoCallOverlayHangUp = 'Τερματισμός κλήσης';

z.string.el.modalAcknowledgeAction = 'Εντάξει';
z.string.el.modalAcknowledgeHeadline = 'Κάτι πήγε στραβά';
z.string.el.modalConfirmSecondary = 'Ακύρωση';
z.string.el.modalOptionSecondary = 'Ακύρωση';

z.string.el.modalAccountCreateAction = 'Εντάξει';
z.string.el.modalAccountCreateHeadline = 'Δημιουργία λογαριασμού;';

z.string.el.modalAccountDeletionAction = 'Διαγραφή';
z.string.el.modalAccountDeletionHeadline = 'Διαγραφή λογαριασμού';
z.string.el.modalAccountDeletionMessage = 'Θα σας στείλουμε ένα μήνυμα μέσω email ή SMS. Πατήστε επάνω στον σύνδεσμο μας για να διαγράψετε τον λογαριασμό σας οριστικά.';

z.string.el.modalAccountLeaveGuestRoomAction = 'Αποχώρηση';

z.string.el.modalAccountLogoutAction = 'Αποσύνδεση';
z.string.el.modalAccountLogoutHeadline = 'Εκκαθάριση δεδομένων;';
z.string.el.modalAccountLogoutOption = 'Διαγράψτε όλα τα προσωπικά σας στοιχεία και συνομιλίες από αυτή την συσκευή.';

z.string.el.modalAccountNewDevicesSecondary = 'Διαχείριση συσκευών';
z.string.el.modalAccountNewDevicesHeadline = 'Ο λογαριασμός σας χρησιμοποιήθηκε στις:';
z.string.el.modalAccountNewDevicesFrom = 'Από:';
z.string.el.modalAccountNewDevicesMessage = 'Εάν δεν το κάνατε αυτό, αφαιρέστε την συσκευή κι επαναφέρετε τον κωδικό σας.';

z.string.el.modalAccountRemoveDeviceAction = 'Αφαίρεση συσκευής';
z.string.el.modalAccountRemoveDeviceHeadline = 'Αφαίρεση "{{device}}"';
z.string.el.modalAccountRemoveDeviceMessage = 'Απαιτείται ο κωδικός πρόσβασης σας για να αφαιρέσετε την συσκευή.';
z.string.el.modalAccountRemoveDevicePlaceholder = 'Κωδικός Πρόσβασης';

z.string.el.modalAssetTooLargeHeadline = 'Το αρχείο είναι πολύ μεγάλο';
z.string.el.modalAssetTooLargeMessage = 'Μπορείτε να στείλετε αρχεία έως {{number}}';

z.string.el.modalAssetParallelUploadsHeadline = 'Πάρα πολλά αρχεία ταυτόχρονα';
z.string.el.modalAssetParallelUploadsMessage = 'Μπορείτε να στείλετε μέχρι και {{number}} αρχεία ταυτόχρονα.';

z.string.el.modalCallEmptyConversationHeadline = 'Κανένας για κλήση';
z.string.el.modalCallEmptyConversationMessage = 'Δεν υπάρχει κανένας εδώ.';

z.string.el.modalCallNoGroupVideoHeadline = 'Καμία βιντεοκλήση σε ομάδες';
z.string.el.modalCallNoGroupVideoMessage = 'Οι Βιντεοκλήσεις δεν είναι διαθέσιμες σε ομαδικές συνομιλίες.';

z.string.el.modalCallNoMicrophoneAction = 'Πείτε μας πως';
z.string.el.modalCallNoMicrophoneMessage = 'Το πρόγραμμα περιήγησής σας χρειάζεται πρόσβαση στο μικρόφωνο για να κάνετε κλήσεις.';
z.string.el.modalCallNoMicrophoneHeadline = 'Αδύνατη η κλήση χωρίς μικρόφωνο';

z.string.el.modalCallSecondIncomingAction = 'Απάντηση';
z.string.el.modalCallSecondIncomingHeadline = 'Απάντηση κλήσης;';
z.string.el.modalCallSecondIncomingMessage = 'Η τρέχουσα κλήση σας θα τερματιστεί.';

z.string.el.modalCallSecondOngoingAction = 'Τερματισμός κλήσης';
z.string.el.modalCallSecondOngoingHeadline = 'Τερματισμός κλήσης από άλλη συσκευή;';
z.string.el.modalCallSecondOngoingMessage = 'Μπορείτε να είστε σε μία κλήση κάθε φορά.';

z.string.el.modalCallSecondOutgoingAction = 'Τερματισμός κλήσης';
z.string.el.modalCallSecondOutgoingHeadline = 'Τερματισμός τρέχουσας κλήσης;';
z.string.el.modalCallSecondOutgoingMessage = 'Μπορείτε να είστε σε μία κλήση κάθε φορά.';

z.string.el.modalConnectCancelAction = 'Ναι';
z.string.el.modalConnectCancelHeadline = 'Ακύρωση Αιτήματος;';
z.string.el.modalConnectCancelMessage = 'Κατάργηση αιτήματος σύνδεσης στον {{user}}.';
z.string.el.modalConnectCancelSecondary = '’Οχι';

z.string.el.modalConnectAcceptAction = 'Σύνδεση';
z.string.el.modalConnectAcceptHeadline = 'Αποδοχή;';
z.string.el.modalConnectAcceptMessage = 'Αυτό θα σας συνδέσει και θα ανοίξει συνομιλία με {{user}}.';
z.string.el.modalConnectAcceptSecondary = 'Αγνόηση';

z.string.el.modalConversationClearAction = 'Διαγραφή';
z.string.el.modalConversationClearHeadline = 'Διαγραφή περιεχομένου;';
z.string.el.modalConversationClearOption = 'Επίσης θα αποχωρήσετε από την συνομιλία';

z.string.el.modalConversationDeleteMessageAction = 'Διαγραφή';
z.string.el.modalConversationDeleteMessageHeadline = 'Διαγραφή μόνο για εμένα;';
z.string.el.modalConversationDeleteMessageMessage = 'Αυτή η ενέργεια δεν μπορεί να αναιρεθεί.';

z.string.el.modalConversationDeleteMessageEveryoneAction = 'Διαγραφή';
z.string.el.modalConversationDeleteMessageEveryoneHeadline = 'Διαγραφή για όλους;';
z.string.el.modalConversationDeleteMessageEveryoneMessage = 'Αυτή η ενέργεια δεν μπορεί να αναιρεθεί.';

z.string.el.modalConversationLeaveAction = 'Αποχώρηση';
z.string.el.modalConversationLeaveMessage = 'Δεν θα μπορείτε να στέλνετε ή να λαμβάνετε μηνύματα σε αυτή την συνομιλία.';

z.string.el.modalConversationMessageTooLongHeadline = 'Υπερμέγεθες μήνυμα';
z.string.el.modalConversationMessageTooLongMessage = 'Μπορείτε να στείλετε μηνύματα έως {{number}} χαρακτήρες.';

z.string.el.modalConversationNewDeviceAction = 'Αποστολή ούτως ή άλλως';
z.string.el.modalConversationNewDeviceHeadlineOne = '{{user}} ξεκίνησε την χρήση μίας νέας συσκευής';
z.string.el.modalConversationNewDeviceHeadlineMany = '{{users}} ξεκίνησε την χρήση νέων συσκευών';
z.string.el.modalConversationNewDeviceHeadlineYou = '{{user}} ξεκίνησε την χρήση μίας νέας συσκευής';
z.string.el.modalConversationNewDeviceIncomingCallAction = 'Απάντηση κλήσης';
z.string.el.modalConversationNewDeviceIncomingCallMessage = 'Είστε σίγουρος ότι θέλετε να δεχτείτε την κλήση;';
z.string.el.modalConversationNewDeviceMessage = 'Εξακολουθείτε να στέλνετε τα μηνύματα σας;';
z.string.el.modalConversationNewDeviceOutgoingCallAction = 'Κλήση ούτως ή άλλως';
z.string.el.modalConversationNewDeviceOutgoingCallMessage = 'Είστε σίγουρος ότι θέλετε να πραγματοποιήσετε την κλήση;';

z.string.el.modalConversationNotConnectedMessageOne = '{{name}} δεν επιθυμεί να προστεθεί στις συνομιλίες.';
z.string.el.modalConversationNotConnectedMessageMany = 'Ένα από τα άτομα που επιλέξατε δεν επιθυμεί να προστεθεί στις συνομιλίες.';

z.string.el.modalConversationRemoveAction = 'Αφαίρεση';
z.string.el.modalConversationRemoveHeadline = 'Αφαίρεση;';
z.string.el.modalConversationRemoveMessage = '{{user}} δεν θα μπορεί να στείλει ή να λάβει μηνύματα σε αυτή την συνομιλία.';

z.string.el.modalConversationRemoveGuestsAction = 'Αφαιρέστε τους επισκέπτες';

z.string.el.modalConversationRevokeLinkAction = 'Ανάκληση συνδέσμου';

z.string.el.modalConversationTooManyMembersHeadline = 'Full house';

z.string.el.modalIntegrationUnavailableHeadline = 'Προσωρινά δεν είναι διαθέσιμο';

z.string.el.modalPictureFileFormatMessage = 'Παρακαλώ επιλέξτε ένα αρχείο PNG ή JPEG.';

z.string.el.modalImproveWireAction = 'Αποδοχή';
z.string.el.modalImproveWireSecondary = '’Οχι';

z.string.el.modalSessionResetHeadline = 'Η περίοδος λειτουργίας σύνδεσης έχει επαναφερθεί';
z.string.el.modalSessionResetMessage1 = 'Εάν το πρόβλημα δεν επιλυθεί,';
z.string.el.modalSessionResetMessageLink = 'επαφή';
z.string.el.modalSessionResetMessage2 = 'Εμάς.';

z.string.el.modalUploadContactsAction = 'Προσπαθήστε ξανά';
z.string.el.modalUploadContactsMessage = 'Δεν λάβαμε πληροφορίες σας. Παρακαλούμε προσπαθήστε ξανά να εισάγετε τις επαφές σας.';

z.string.el.modalUserBlockAction = 'Αποκλεισμός';
z.string.el.modalUserBlockHeadline = 'Αποκλεισμός {{user}};';
z.string.el.modalUserBlockMessage = '{{user}} δεν θα μπορέσει να επικοινωνήσει μαζί σας ή να σας προσθέσει σε ομαδικές συνομιλίες.';

z.string.el.modalUserUnblockAction = 'Άρση αποκλεισμού';
z.string.el.modalUserUnblockHeadline = 'Άρση αποκλεισμού';
z.string.el.modalUserUnblockMessage = '{{user}} θα μπορεί να επικοινωνήσει μαζί σας και να σας προσθέσει ξανά σε ομαδικές συνομιλίες.';

z.string.el.connectionRequestConnect = 'Σύνδεση';
z.string.el.connectionRequestIgnore = 'Αγνόηση';

z.string.el.conversationGuestIndicator = 'Επισκέπτης';

z.string.el.conversationYouNominative = 'εσύ';
z.string.el.conversationYouDative = 'εσύ';
z.string.el.conversationYouAccusative = 'εσύ';

z.string.el.conversationConnectionAccepted = 'Συνδέθηκε';
z.string.el.conversationConnectionBlocked = 'Αποκλεισμένοι';
z.string.el.conversationConnectionCancelRequest = 'Ακύρωση αιτήματος σύνδεσης';
z.string.el.conversationDeviceStartedUsingOne = 'έναρξη χρήσεως';
z.string.el.conversationDeviceStartedUsingMany = 'έναρξη χρήσεως';
z.string.el.conversationDeviceUnverified = ' μία εξ αυτών είναι μη επαληθευμένη';
z.string.el.conversationDeviceYourDevices = 'οι συσκευές σας';
z.string.el.conversationDeviceUserDevices = ' {{user}}´ς συσκευές';
z.string.el.conversationDeviceNewDeviceOne = 'μία νέα συσκευή';
z.string.el.conversationDeviceNewDeviceMany = ' νέες συσκευές';
z.string.el.conversationDeviceNewPeopleJoinedVerify = 'επαληθευμένες συσκευές';
z.string.el.conversationJustNow = 'Μόλις τώρα';
z.string.el.conversationLocationLink = 'Άνοιγμα χάρτη';
z.string.el.conversationMessageDelivered = 'Παραδόθηκε';
z.string.el.conversationRename = ' η συνομιλία μετονομάστηκε';
z.string.el.conversationRenameYou = ' η συνομιλία μετονομάστηκε';
z.string.el.conversationResume = 'Ξεκινήστε μία συζήτηση με {{users}}';
z.string.el.conversationPing = ' σκουντημα';
z.string.el.conversationPingYou = ' σκουντημα';
z.string.el.conversationToday = 'σήμερα';
z.string.el.conversationVoiceChannelDeactivate = ' κάλεσε';
z.string.el.conversationVoiceChannelDeactivateYou = ' κάλεσε';
z.string.el.conversationYesterday = 'Χθές';
z.string.el.conversationUnableToDecrypt1 = 'ένα μήνυμα από τον {{user}} δεν παρελήφθη.';
z.string.el.conversationUnableToDecrypt2 = '{{user}}´ς η ταυτότητα συσκευής άλλαξε. Ανεπίδοτο μήνυμα.';
z.string.el.conversationUnableToDecryptLink = 'Γιατί;';
z.string.el.conversationUnableToDecryptErrorMessage = 'Σφάλμα';
z.string.el.conversationUnableToDecryptResetSession = 'Επαναφορά περιόδου σύνδεσης';
z.string.el.conversationMissedMessages = 'Δεν έχετε χρησιμοποιήσει αυτή την συσκευή για ένα χρονικό διάστημα. Ορισμένα μηνύματα ενδέχεται να μην εμφανίζονται εδώ.';
z.string.el.conversationAssetDownloading = 'Γίνετε λήψη…';
z.string.el.conversationAssetUploadFailed = 'Η Μεταφόρτωση Απέτυχε';
z.string.el.conversationPlaybackError = 'Αδύνατη η αναπαραγωγή';
z.string.el.conversationContextMenuCopy = 'Αντιγραφή';
z.string.el.conversationContextMenuEdit = 'Eπεξεργασία';
z.string.el.conversationContextMenuDelete = 'Διαγραφή για εμένα';
z.string.el.conversationContextMenuDeleteEveryone = 'Διαγραφή για όλους';
z.string.el.conversationContextMenuDownload = 'Λήψη';
z.string.el.conversationContextMenuLike = 'Μου αρέσει';
z.string.el.conversationContextMenuUnlike = 'Δεν μου αρέσει';
z.string.el.conversationDeleteTimestamp = 'Διεγράφη στις {{date}}';
z.string.el.conversationEditTimestamp = 'Επεξεργάστηκε στις {{date}}';
z.string.el.conversationLikesCaption = '{{number}} άτομα';
z.string.el.conversationSendPastedFile = 'Επικολλημένη εικόνα στις {{date}}';
z.string.el.conversationSomeone = 'Κάποιος';
z.string.el.conversationTweetAuthor = ' στο Twitter';

z.string.el.groupCreationPreferencesAction = 'Επόμενο';
z.string.el.groupCreationPreferencesHeader = 'Δημιουργία ομάδος';
z.string.el.groupCreationPreferencesPlaceholder = 'Όνομα ομάδος';
z.string.el.groupCreationParticipantsActionCreate = 'Έγινε';
z.string.el.groupCreationParticipantsActionSkip = 'Παράλειψη';
z.string.el.groupCreationParticipantsHeader = 'Προσθήκη ατόμων';
z.string.el.groupCreationParticipantsHeaderWithCounter = 'Προσθήκη ατόμων ({{number}})';
z.string.el.groupCreationParticipantsPlaceholder = 'Αναζήτηση βάση ονόματος';

z.string.el.guestRoomConversationName = 'Δωμάτιο καλεσμένων';

z.string.el.guestRoomConversationButton = 'Πρόσκληση ατόμων';

z.string.el.collectionShowAll = 'Προβολή όλων {{number}}';
z.string.el.collectionSectionLinks = 'Σύνδεσμοι';
z.string.el.collectionSectionImages = 'Εικόνες';
z.string.el.collectionSectionFiles = 'Αρχεία';
z.string.el.collectionSectionAudio = 'Ηχητικά μηνύματα';

z.string.el.fullsearchPlaceholder = 'Αναζήτηση μηνυμάτων κειμένου';
z.string.el.fullsearchNoResults = 'Χωρίς Αποτέλεσμα.';

z.string.el.archiveHeader = 'Αρχειοθέτηση';

z.string.el.conversationsAllArchived = 'Τα πάντα αρχειοθετήθηκαν';
z.string.el.conversationsContacts = 'Επαφές';
z.string.el.conversationsConnectionRequestMany = '{{number}} άτομα σε αναμονή';
z.string.el.conversationsConnectionRequestOne = '1 άτομο σε αναμονή';
z.string.el.conversationsEmptyConversation = 'Ομαδική συζήτηση';
z.string.el.conversationsNoConversations = 'Δεν υπάρχουν ακόμα συζητήσεις';
z.string.el.conversationsPopoverArchive = 'Αρχειοθέτηση';
z.string.el.conversationsPopoverCancel = 'Ακύρωση αιτήματος';
z.string.el.conversationsPopoverClear = 'Διαγραφή περιεχομένου…';
z.string.el.conversationsPopoverNotify = 'Ενεργή ένταση';
z.string.el.conversationsPopoverSilence = 'Σίγαση';
z.string.el.conversationsPopoverUnarchive = 'Αναίρεση αρχειοθέτησης';

z.string.el.conversationsSecondaryLineEphemeralMessage = 'Σας έστειλε ένα μήνυμα';
z.string.el.conversationsSecondaryLinePeopleLeft = '{{number}} άτομα αποχώρησαν';
z.string.el.conversationsSecondaryLinePersonLeft = '{{user}} αποχώρησε';
z.string.el.conversationsSecondaryLinePersonRemoved = '{{user}} αφαιρέθηκε';
z.string.el.conversationsSecondaryLinePeopleAdded = '{{user}} άτομο προστέθηκε';
z.string.el.conversationsSecondaryLinePersonAdded = '{{user}} προστέθηκε';
z.string.el.conversationsSecondaryLinePersonAddedYou = '{{user}} σας πρόσθεσε';
z.string.el.conversationsSecondaryLineRenamed = '{{user}} μετονόμασε την συνομιλία';
z.string.el.conversationsSecondaryLineYouLeft = 'Αποχωρήσατε';
z.string.el.conversationsSecondaryLineYouWereRemoved = 'Σας αφαίρεσαν';

z.string.el.takeoverSub = 'Ζητήστε το μοναδικό σας όνομα στο Wire.';
z.string.el.takeoverLink = 'Μάθετε περισσότερα';
z.string.el.takeoverButtonChoose = 'Επιλέξτε το δικό σας';
z.string.el.takeoverButtonKeep = 'Κρατήστε το';

z.string.el.inviteMetaKeyMac = 'Cmd';
z.string.el.inviteMetaKeyPc = 'Ctrl';
z.string.el.inviteHeadline = 'Πρόσκληση ατόμων στο Wire';
z.string.el.inviteMessage = 'Είμαι στο Wire, αναζήτησε για {{username}} ή επισκέψου την ιστοσελίδα get.wire.com.';
z.string.el.inviteMessageNoEmail = 'Είμαι στο Wire.Επισκέψου την ιστοσελίδα get.wire.com για να συνδεθείς μαζί μου.';

z.string.el.extensionsBubbleButtonGif = 'Εικόνες Gif';

z.string.el.extensionsGiphyButtonOk = 'Αποστολή';
z.string.el.extensionsGiphyButtonMore = 'Δοκιμάστε ξανά';
z.string.el.extensionsGiphyMessage = '{{tag}} • μέσω giphy.com';
z.string.el.extensionsGiphyNoGifs = 'Ουπς! δεν υπάρχουν gifs';
z.string.el.extensionsGiphyRandom = 'Τυχαία';

z.string.el.addParticipantsConfirmLabel = 'Προσθήκη';
z.string.el.addParticipantsHeader = 'Προσθήκη ατόμων';
z.string.el.addParticipantsHeaderWithCounter = 'Προσθήκη ατόμων ({{number}})';
z.string.el.addParticipantsSearchPlaceholder = 'Αναζήτηση βάση ονόματος';
z.string.el.addParticipantsTabsPeople = 'Άτομα';
z.string.el.addParticipantsTabsServices = 'Υπηρεσίες';

z.string.el.conversationDetailsActionArchive = 'Αρχειοθέτηση';
z.string.el.conversationDetailsActionAddParticipants = 'Προσθήκη συμμετεχόντων';
z.string.el.conversationDetailsActionBlock = 'Αποκλεισμός επαφής';
z.string.el.conversationDetailsActionCancelRequest = 'Ακύρωση αιτήματος';
z.string.el.conversationDetailsActionClear = 'Διαγραφή περιεχομένου';
z.string.el.conversationDetailsActionCreateGroup = 'Δημιουργία ομάδος';
z.string.el.conversationDetailsActionDevices = 'Συσκευές';
z.string.el.conversationDetailsActionNotifications = 'Ειδοποιησεις';
z.string.el.conversationDetailsGuestsOff = 'Ανενεργό';
z.string.el.conversationDetailsOptions = 'Επιλογές';
z.string.el.conversationDetailsParticipantsServicesOne = 'Υπηρεσία';
z.string.el.conversationDetailsParticipantsServicesMany = 'Υπηρεσίες';
z.string.el.conversationDetailsParticipantsUsersOne = 'Άτομο';
z.string.el.conversationDetailsParticipantsUsersMany = 'Άτομα';
z.string.el.conversationDetailsPeople = 'Άτομα';
z.string.el.conversationDetailsServices = 'Υπηρεσίες';

z.string.el.conversationParticipantsTitle = 'Άτομα';
z.string.el.conversationParticipantsSearchPlaceholder = 'Αναζήτηση βάση ονόματος';

z.string.el.groupParticipantActionCancelRequest = 'Ακύρωση αιτήματος';
z.string.el.groupParticipantActionDevices = 'Συσκευές';
z.string.el.groupParticipantActionPending = 'Εκκρεμεί';
z.string.el.groupParticipantActionSendRequest = 'Σύνδεση';

z.string.el.guestOptionsCopyLink = 'Αντιγραφή συνδέσμου';
z.string.el.guestOptionsCreateLink = 'Δημιουργία συνδέσμου';
z.string.el.guestOptionsRevokeLink = 'Ανάκληση συνδέσμου';

z.string.el.notificationSettingsTitle = 'Ειδοποιησεις';

z.string.el.participantDevicesDetailHeadline = 'Βεβαιωθείτε ότι αυτό αντιστοιχεί στο αποτύπωμα που εμφανίζεται στην συσκευή {{html1}} {{user}} {{html2}}.';
z.string.el.participantDevicesDetailHowTo = 'Πώς μπορώ να το κάνω;';
z.string.el.participantDevicesDetailResetSession = 'Επαναφορά περιόδου σύνδεσης';
z.string.el.participantDevicesDetailShowMyDevice = 'Προβολή αποτυπωμάτων της συσκευής μου';
z.string.el.participantDevicesDetailVerify = 'Επιβεβαιωμένο';

z.string.el.participantDevicesHeader = 'Συσκευές';
z.string.el.participantDevicesHeadline = 'Το Wire παρέχει σε κάθε συσκευή ένα μοναδικό αποτύπωμα. Συγκρίνετε τα με {{user}} και επαληθεύστε την συνομιλία σας.';
z.string.el.participantDevicesLearnMore = 'Μάθετε περισσότερα';
z.string.el.participantDevicesWhyVerify = 'Γιατί να επαληθεύσω τις συνομιλίες;';
z.string.el.participantDevicesOutdatedClientMessage = '{{user}} χρησιμοποιεί μια παλιά έκδοση του Wire. Δεν εμφανίζονται εδώ συσκευές.';

z.string.el.participantDevicesSelfAllDevices = 'Εμφάνιση όλων των συσκευών μου';
z.string.el.participantDevicesSelfFingerprint = 'Αποτυπώματα συσκευής';

z.string.el.userProfileButtonConnect = 'Σύνδεση';
z.string.el.userProfileButtonIgnore = 'Αγνόηση';
z.string.el.userProfileButtonUnblock = 'Άρση αποκλεισμού';

z.string.el.preferencesAbout = 'Περί';
z.string.el.preferencesAccount = 'Λογαριασμός';
z.string.el.preferencesAV = 'Ήχος / βίντεο';
z.string.el.preferencesDeviceDetails = 'Λεπτομέρειες Συσκευής';
z.string.el.preferencesDevices = 'Συσκευές';
z.string.el.preferencesHeadline = 'Προτιμήσεις';
z.string.el.preferencesOptions = 'Επιλογές';

z.string.el.preferencesAboutPrivacyPolicy = 'Πολιτική Απορρήτου';
z.string.el.preferencesAboutSupport = 'Υποστήριξη';
z.string.el.preferencesAboutSupportWebsite = 'Ιστοσελίδα υποστήριξης';
z.string.el.preferencesAboutSupportContact = 'Επικοινωνήστε με το τμήμα υποστήριξης';
z.string.el.preferencesAboutTermsOfUse = 'Όροι Χρήσης';
z.string.el.preferencesAboutVersion = 'Έκδοση {{version}}';
z.string.el.preferencesAboutWebsite = 'Η Ιστοσελίδα του Wire';

z.string.el.preferencesAccountCreateTeam = 'Δημιουργήστε μια ομάδα';
z.string.el.preferencesAccountDelete = 'Διαγραφή λογαριασμού';
z.string.el.preferencesAccountLogOut = 'Αποσύνδεση';
z.string.el.preferencesAccountManageTeam = 'Διαχείριση ομάδων';
z.string.el.preferencesAccountResetPassword = 'Επαναφορά κωδικού πρόσβασης';
z.string.el.preferencesAccountTeam = 'στο {{name}}';
z.string.el.preferencesAccountUsernamePlaceholder = 'Ονοματεπώνυμο';
z.string.el.preferencesAccountUsernameHint = 'Τουλάχιστον 2 χαρακτήρες. a—z, 0—9 και _ μόνο.';
z.string.el.preferencesAccountUsernameAvailable = 'Διαθέσιμο';
z.string.el.preferencesAccountUsernameErrorTaken = 'Χρησιμοποιείται ήδη';

z.string.el.preferencesAVCamera = 'Κάμερα';
z.string.el.preferencesAVMicrophone = 'Μικρόφωνο';
z.string.el.preferencesAVPermissionDetail = 'Ενεργοποίηση από τις Προτιμήσεις του φυλλομετρητή σας';
z.string.el.preferencesAVSpeakers = 'Ηχεια';

z.string.el.preferencesDevicesActivatedOn = 'Ενεργοποιήθηκε στις {{date}}';
z.string.el.preferencesDevicesActive = 'Συνδεμένος';
z.string.el.preferencesDevicesActiveDetail = 'Εάν δεν αναγνωρίζετε μία από τις παραπάνω συσκευές, αφαιρέστε την και επαναφέρετε τον κωδικό σας.';
z.string.el.preferencesDevicesCurrent = 'Τρεχων';
z.string.el.preferencesDevicesFingerprint = 'Κλειδί αποτυπώματος';
z.string.el.preferencesDevicesFingerprintDetail = 'Το Wire δίνει σε κάθε συσκευή ένα μοναδικό αποτύπωμα. Συγκρίνετε τα και επαληθεύστε τις συσκευές σας και τις συνομιλίες σας.';
z.string.el.preferencesDevicesId = 'ID: ';
z.string.el.preferencesDevicesRemoveCancel = 'Ακύρωση';
z.string.el.preferencesDevicesRemoveDetail = 'Αφαιρέστε αυτήν την συσκευή εάν έχετε σταματήσει να την χρησιμοποιήτε. Θα πρέπει να αποσυνδεθείτε από αυτήν την συσκευή αμέσως.';
z.string.el.preferencesDevicesSessionConfirmation = 'Η περίοδος λειτουργίας έχει επαναφερθεί.';
z.string.el.preferencesDevicesSessionDetail = 'Εάν τα αποτυπώματα δεν ταιριάζουν, επαναφέρετε την περίοδο σύνδεσης για να δημιουργήσετε νέα κλειδιά κρυπτογράφησης και στις δύο πλευρές.';
z.string.el.preferencesDevicesSessionReset = 'Επαναφορά περιόδου σύνδεσης';
z.string.el.preferencesDevicesSessionOngoing = 'Επαναφορά της περιόδου σύνδεσης…';
z.string.el.preferencesDevicesVerification = 'Επιβεβαιωμένο';

z.string.el.preferencesOptionsAudio = 'Ειδοποιήσεις ήχου';
z.string.el.preferencesOptionsAudioAll = 'Όλα';
z.string.el.preferencesOptionsAudioAllDetail = 'Όλοι οι ήχοι';
z.string.el.preferencesOptionsAudioNone = 'Καθόλου';
z.string.el.preferencesOptionsAudioNoneDetail = 'Σσσσς!';
z.string.el.preferencesOptionsAudioSome = 'Μερικώς';
z.string.el.preferencesOptionsAudioSomeDetail = 'Κουδουνίσματα και κλήσεις';
z.string.el.preferencesOptionsContacts = 'Επαφές';
z.string.el.preferencesOptionsContactsGmail = 'Εισαγωγή από το Gmail';
z.string.el.preferencesOptionsContactsMacos = 'Εισαγωγή από τις Επαφές';
z.string.el.preferencesOptionsContactsDetail = 'Χρησιμοποιούμε τις επαφές σας για να συνδέεστε με άλλους. Κρατάμε όλες σας τις πληροφορίες ανώνυμες και δεν τις μοιραζόμαστε με κανέναν άλλον.';
z.string.el.preferencesOptionsPopular = 'Απο δημοφιλεις προτασεις';
z.string.el.preferencesOptionsEmojiReplaceCheckbox = 'Αντικατάσταση τύπου emoticons με emojis';
z.string.el.preferencesOptionsPreviewsSendCheckbox = 'Δημιουργία προεπισκόπησης για απεσταλμένους συνδέσμους σας';
z.string.el.preferencesOptionsPreviewsSendDetail = 'Οι προβολές ενδέχεται να εξακολουθούν να εμφανίζονται για συνδέσμους από άλλα άτομα.';
z.string.el.preferencesOptionsNotifications = 'Ειδοποιησεις';
z.string.el.preferencesOptionsNotificationsNone = 'Ανενεργό';
z.string.el.preferencesOptionsNotificationsObfuscate = 'Απόκρυψη λεπτομερειών';
z.string.el.preferencesOptionsNotificationsObfuscateMessage = 'Εμφάνιση αποστολέα';
z.string.el.preferencesOptionsNotificationsOn = 'Εμφάνιση αποστολέα και μηνύματος';

z.string.el.backupImportGenericErrorHeadline = 'Κάτι πήγε στραβά';
z.string.el.backupCancel = 'Ακύρωση';

z.string.el.searchConnect = 'Σύνδεση';
z.string.el.searchConnections = 'Συνδέσεις';
z.string.el.searchContacts = 'Επαφές';
z.string.el.searchCreateGroup = 'Δημιουργία ομάδας';
z.string.el.searchGroups = 'Ομάδες';
z.string.el.searchPeople = 'Άτομα';
z.string.el.searchPlaceholder = 'Αναζητηση ονοματος χρηστη';
z.string.el.searchServicePlaceholder = 'Αναζήτηση βάση ονόματος';
z.string.el.searchServices = 'Υπηρεσίες';
z.string.el.searchTeamGroups = 'Συνομιλίες ομάδας';
z.string.el.searchTeamMembers = 'Μέλη ομάδας';
z.string.el.searchTopPeople = 'Αγαπημένα άτομα';
z.string.el.searchTrySearch = 'Εύρεση ατόμων βάση ονόματος ή ονόματος χρήστη';
z.string.el.searchNoContactsOnWire = 'Δεν έχετε επαφές στο Wire. Προσπαθήστε να βρείτε άτομα με το όνομα ή το όνομα χρήστη τους.';
z.string.el.searchOthers = 'Σύνδεση';

z.string.el.searchInvite = 'Πρόσκληση ατόμων για συμμετοχή στο Wire';
z.string.el.searchInviteDetail = 'Κάντε κοινή χρήση των επαφών σας για να μπορέσετε να συνδεθείτε με άλλους χρήστες.Κρατάμε ανώνυμες όλες σας τις πληροφορίες και δεν τις μοιραζόμαστε με κανέναν άλλον.';
z.string.el.searchInviteButtonContacts = 'Από τις Επαφές';
z.string.el.searchInviteButtonGmail = 'Από το Gmail';
z.string.el.searchInviteHeadline = 'Προτείνετε το στους φίλους σας';
z.string.el.searchInviteShare = 'Κοινή χρήση Επαφών';

z.string.el.searchListEveryoneParticipates = 'Όλοι όσοι συνδεθήκατε βρίσκεστε ήδη εντός της συνομιλίας.';
z.string.el.searchListNoMatches = 'Δεν υπάρχουν σχετικά αποτελέσματα.\nΔοκιμάστε να εισάγετε ένα διαφορετικό όνομα.';

z.string.el.temporaryGuestCta = 'Δημιουργία λογαριασμού';

z.string.el.uploadGoogleHeadline = 'Εύρεση ατόμων για συνομιλία.';
z.string.el.uploadGoogleMessage = 'Χρησιμοποιούμε τις επαφές σας για να συνδέεστε με άλλους. Κρατάμε όλες σας τις πληροφορίες ανώνυμες και δεν τις μοιραζόμαστε με κανέναν άλλον.';

z.string.el.warningCallUnsupportedIncoming = '{{user}} καλεί. Το πρόγραμμα περιήγησής σας δεν υποστηρίζει κλήσεις.';
z.string.el.warningCallUnsupportedOutgoing = 'Δεν μπορείτε να καλέσετε, επειδή το πρόγραμμα περιήγησής σας δεν υποστηρίζει κλήσεις.';
z.string.el.warningCallIssues = 'Αυτή η έκδοση του Wire δεν μπορεί να μετέχει στην κλήση. Παρακαλούμε χρησιμοποιήστε';
z.string.el.warningCallUpgradeBrowser = 'Για να καλέσετε, παρακαλούμε ενημερώστε το Google Chrome.';
z.string.el.warningConnectivityConnectionLost = 'Προσπαθείτε να συνδεθείτε. Το Wire μπορεί να μην είναι σε θέση να παραδώσει μηνύματα.';
z.string.el.warningConnectivityNoInternet = 'Χωρίς σύνδεση. Δεν θα μπορείτε να στείλετε ή να λάβετε μηνύματα.';
z.string.el.warningLearnMore = 'Μάθετε περισσότερα';
z.string.el.warningLifecycleUpdate = 'Διατίθεται μια νέα έκδοση του Wire.';
z.string.el.warningLifecycleUpdateNotes = 'Τι νέο υπάρχει';
z.string.el.warningLifecycleUpdateLink = 'Ενημέρωση τώρα';
z.string.el.warningNotFoundCamera = 'Δεν μπορείτε να πραγματοποιήσετε κλήση επειδή ο υπολογιστής σας δεν διαθέτει κάμερα.';
z.string.el.warningNotFoundMicrophone = 'Δεν μπορείτε να καλέσετε, επειδή ο υπολογιστής σας δεν διαθέτει μικρόφωνο.';
z.string.el.warningPermissionDeniedCamera = 'Δεν μπορείτε να καλέσετε, επειδή το πρόγραμμα περιήγησής σας δεν έχει πρόσβαση σε κάμερα.';
z.string.el.warningPermissionDeniedMicrophone = 'Δεν μπορείτε να καλέσετε, επειδή το πρόγραμμα περιήγησής σας δεν έχει πρόσβαση στο μικρόφωνο.';
z.string.el.warningPermissionDeniedScreen = 'Το πρόγραμμα περιήγησής σας χρειάζεται άδεια για να μοιραστείτε την οθόνη σας.';
z.string.el.warningPermissionRequestCamera = '{{icon}} Να επιτρέπεται η πρόσβαση στην κάμερα';
z.string.el.warningPermissionRequestMicrophone = '{{icon}} Να επιτρέπεται η πρόσβαση στο μικρόφωνο';
z.string.el.warningPermissionRequestNotification = '{{icon}} Να επιτρέπονται οι ειδοποιήσεις';
z.string.el.warningPermissionRequestScreen = '{{icon}} Να επιτρέπεται η πρόσβαση στην οθόνη';

z.string.el.userAvailabilityAvailable = 'Διαθέσιμο';
z.string.el.userAvailabilityNone = 'Καθόλου';

z.string.el.notificationAssetAdd = 'Κοινοποίηση εικόνας';
z.string.el.notificationConnectionAccepted = 'Η αίτηση σύνδεσης σας έγινε αποδεκτή';
z.string.el.notificationConnectionConnected = 'Μόλις συνδεθήκατε';
z.string.el.notificationConnectionRequest = 'Θέλει να συνδεθεί';
z.string.el.notificationConversationCreate = '{{user}} ξεκίνησε μία συνομιλία';
z.string.el.notificationConversationRename = '{{user}} μετονόμασε την συνομιλία σε {{name}}';
z.string.el.notificationMemberJoinMany = '{{user}} πρόσθεσε {{number}} άτομα στην συνομιλία';
z.string.el.notificationMemberJoinOne = '{{user1}} πρόσθεσε {{user2}} στην συνομιλία';
z.string.el.notificationMemberLeaveRemovedYou = '{{user}} σας αφαίρεσε από την συνομιλία';
z.string.el.notificationObfuscated = 'Σας έστειλε ένα μήνυμα';
z.string.el.notificationObfuscatedTitle = 'Κάποιος';
z.string.el.notificationPing = 'Σκουντημα';
z.string.el.notificationReaction = '{{reaction}} το μήνυμα σας';
z.string.el.notificationSharedAudio = 'Κοινοποιήθηκε ηχητικό μήνυμα';
z.string.el.notificationSharedFile = 'Κοινοποίηση αρχείου';
z.string.el.notificationSharedLocation = 'Κοινή χρήση της τοποθεσίας σας';
z.string.el.notificationSharedVideo = 'Κοινοποίηση βίντεο';
z.string.el.notificationVoiceChannelActivate = 'Καλεί';
z.string.el.notificationVoiceChannelDeactivate = 'Κάλεσε';

z.string.el.tooltipConversationAllVerified = 'Όλα τα αποτυπώματα επαληθεύτηκαν';
z.string.el.tooltipConversationCall = 'Κλήση';
z.string.el.tooltipConversationEphemeral = 'Προσωρινό μήνυμα';
z.string.el.tooltipConversationFile = 'Προσθήκη αρχείου';
z.string.el.tooltipConversationInputPlaceholder = 'Πληκτρολογηση μηνυματος';
z.string.el.tooltipConversationPeople = 'Άτομα ({{shortcut}})';
z.string.el.tooltipConversationPicture = 'Προσθήκη εικόνας';
z.string.el.tooltipConversationPing = 'Κουδούνισμα ({{shortcut}})';
z.string.el.tooltipConversationSearch = 'Αναζήτηση';
z.string.el.tooltipConversationVideoCall = 'Βιντεοκλήση';

z.string.el.tooltipConversationsArchive = 'Αρχειοθέτηση ({{shortcut}})';
z.string.el.tooltipConversationsArchived = 'Προβολή αρχειοθέτησης ({{number}})';
z.string.el.tooltipConversationsMore = 'Περισσότερα';
z.string.el.tooltipConversationsNotify = 'Αύξηση έντασης ({{shortcut}})';
z.string.el.tooltipConversationsPreferences = 'Ανοίξτε τις προτιμήσεις';
z.string.el.tooltipConversationsSilence = 'Σίγαση ({{shortcut}})';
z.string.el.tooltipConversationsStart = 'Ξεκινήστε συνομιλία ({{shortcut}})';

z.string.el.tooltipConversationDetailsRename = 'Αλλαγή ονόματος της συνομιλίας';

z.string.el.tooltipPreferencesContactsGmail = 'Συνδεθείτε στον λογαριασμό Gmail σας για να κοινοποιήσετε τις επαφές';
z.string.el.tooltipPreferencesContactsMacos = 'Κοινοποίηση όλων των επαφών σας από macOS της εφαρμογής Επαφές';
z.string.el.tooltipPreferencesPassword = 'Ανοίξτε άλλη ιστοσελίδα για να επαναφέρετε τον κωδικό πρόσβασης σας';
z.string.el.tooltipPreferencesPicture = 'Επιλέξτε εικόνα...';
z.string.el.tooltipPreferencesRename = 'Επιλέξτε το όνομα σας';

z.string.el.tooltipSearchClose = 'Κλείσιμο (Esc)';

z.string.el.initReceivedSelfUser = 'Γεια σου, {{user}}.';
z.string.el.initReceivedUserData = 'Ελέγξτε για νέα μηνύματα';
z.string.el.initEvents = 'Φόρτωση μηνυμάτων';

z.string.el.ephemeralUnitsNone = 'Ανενεργό';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.es.wireMacos = 'Wire para macOS';
z.string.es.wireWindows = 'Wire para Windows';
z.string.es.wireLinux = 'Wire para Linux';
z.string.es.nonexistentUser = 'Usuario Borrado';
z.string.es.and = 'y';
z.string.es.enumerationAnd = ' y ';

z.string.es.authAccountCountryCode = 'Código de País';
z.string.es.authAccountPasswordForgot = 'Contraseña Olvidada';
z.string.es.authAccountPublicComputer = 'Es un ordenador público';
z.string.es.authAccountSignIn = 'Iniciar sesión';
z.string.es.authAccountSignInPhone = 'Acceso con número de teléfono';

z.string.es.authBlockedCookies = 'Habilita las cookies para iniciar sesión.';
z.string.es.authBlockedDatabase = 'Wire necesita acceso al almacenamiento local para mostrar los mensajes. No está disponible en modo privado.';
z.string.es.authBlockedTabs = 'Wire ya está abierto en otra pestaña.';
z.string.es.authBlockedTabsAction = 'Utilice esta pestaña en su lugar';

z.string.es.authVerifyAccountAdd = 'Agregar';
z.string.es.authVerifyAccountDetail = 'Esto le permite usar Wire en múltiples dispositivos.';
z.string.es.authVerifyAccountHeadline = 'Agregar dirección de correo electrónico y contraseña.';
z.string.es.authVerifyAccountLogout = 'Cerrar sesión';
z.string.es.authVerifyCodeDescription = 'Ingresa el código de verificación\nque hemos enviado a {{number}}.';
z.string.es.authVerifyCodeResend = '¿No ha recibido ningún código?';
z.string.es.authVerifyCodeResendDetail = 'Reenviar';
z.string.es.authVerifyCodeResendTimer = 'Puede solicitar un nuevo código en {{expiration}}.';
z.string.es.authVerifyCodeChangePhone = 'Cambiar número de teléfono';
z.string.es.authVerifyPasswordHeadline = 'Introduzca su contraseña';

z.string.es.authLimitDevicesHeadline = 'Dispositivos';
z.string.es.authLimitDescription = 'Quite uno de los dispositivos para comenzar a usar Wire en este dispositivo.';
z.string.es.authLimitButtonManage = 'Administrar dispositivos';
z.string.es.authLimitButtonSignOut = 'Cerrar sesión';
z.string.es.authLimitDevicesCurrent = '(Actual)';

z.string.es.authHistoryHeadline = 'Es la primera vez que usas Wire en este dispositivo.';
z.string.es.authHistoryDescription = 'Por motivos de privacidad, tu historial de conversación no aparecerá aquí.';
z.string.es.authHistoryReuseHeadline = 'Ya has utilizado Wire en este dispositivo antes.';
z.string.es.authHistoryReuseDescription = 'Los mensajes enviados mientras tanto no aparecerán aquí.';
z.string.es.authHistoryButton = 'OK';

z.string.es.authPostedResend = 'Reenviar a {{email}}';
z.string.es.authPostedResendAction = '¿No aparece ningún correo electrónico?';
z.string.es.authPostedResendDetail = 'Revise su buzón de correo electrónico y siga las instrucciones.';
z.string.es.authPostedResendHeadline = 'Tiene un correo electrónico.';

z.string.es.authPlaceholderEmail = 'Correo';
z.string.es.authPlaceholderPasswordPut = 'Contraseña';
z.string.es.authPlaceholderPasswordSet = 'Contraseña (mínimo 8 caracteres)';
z.string.es.authPlaceholderPhone = 'Número de teléfono';

z.string.es.authErrorCode = 'Código no válido';
z.string.es.authErrorCountryCodeInvalid = 'Código de país no válido';
z.string.es.authErrorEmailExists = 'Este correo electrónico ya está registrado';
z.string.es.authErrorEmailForbidden = 'Lo sentimos. Esta dirección de correo electrónico está prohibida.';
z.string.es.authErrorEmailMalformed = 'Por favor, introduce una dirección de correo electrónico válida.';
z.string.es.authErrorEmailMissing = 'Por favor, introduce una dirección de correo electrónico.';
z.string.es.authErrorMisc = 'Problemas con la conexión. Por favor, inténtelo de nuevo.';
z.string.es.authErrorNameShort = 'Introduce un nombre con al menos 2 caracteres';
z.string.es.authErrorOffline = 'No hay conexión a Internet';
z.string.es.authErrorPasswordShort = 'Elige una contraseña con al menos 8 caracteres.';
z.string.es.authErrorPasswordWrong = 'Contraseña incorrecta. Por favor, inténtelo de nuevo.';
z.string.es.authErrorPending = 'La cuenta aún no esta verificada';
z.string.es.authErrorPhoneNumberBudget = 'Has entrado muchas veces. Prueba más tarde.';
z.string.es.authErrorPhoneNumberForbidden = 'Lo sentimos. Este número de teléfono está prohibido.';
z.string.es.authErrorPhoneNumberInvalid = 'Número de teléfono no válido';
z.string.es.authErrorPhoneNumberUnknown = 'Número de Teléfono Desconocido';
z.string.es.authErrorSuspended = 'Esta cuenta ya no está autorizada a iniciar sesión.';
z.string.es.authErrorSignIn = 'Por favor, verifica tus datos y vuelve a intentarlo.';

z.string.es.callStateOutgoing = 'Sonando…';
z.string.es.callStateConnecting = 'Conectando…';
z.string.es.callStateIncoming = 'Llamando…';
z.string.es.callStateIncomingGroup = '{{user}} está llamando';
z.string.es.callDecline = 'Rechazar';
z.string.es.callAccept = 'Aceptar';
z.string.es.callJoin = 'Entrar';
z.string.es.callChooseSharedScreen = 'Elige una pantalla para compartir';
z.string.es.callParticipants = '{{number}} en la llamada';
z.string.es.callNoCameraAccess = 'Sin acceso a la cámara';

z.string.es.videoCallOverlayFitVideoLabel = 'Haga doble clic para ajustar o rellenar el video';
z.string.es.videoCallOverlayConversations = 'Conversaciones';
z.string.es.videoCallOverlayMute = 'Silenciar';
z.string.es.videoCallOverlayVideo = 'Video';
z.string.es.videoCallOverlayShareScreen = 'Compartir pantalla';
z.string.es.videoCallOverlayHangUp = 'Colgar';
z.string.es.videoCallPaused = 'Video pausado';
z.string.es.videoCallScreenShareNotSupported = 'Este navegador no permite compartir pantallas';

z.string.es.modalAcknowledgeAction = 'OK';
z.string.es.modalAcknowledgeHeadline = 'Algo salió mal';
z.string.es.modalConfirmSecondary = 'Cancelar';
z.string.es.modalOptionSecondary = 'Cancelar';

z.string.es.modalAccountCreateAction = 'OK';
z.string.es.modalAccountCreateHeadline = '¿Crear una cuenta?';
z.string.es.modalAccountCreateMessage = 'Al crear una cuenta perderá el histórico de la conversación de esta sala de invitados.';

z.string.es.modalAccountDeletionAction = 'Eliminar';
z.string.es.modalAccountDeletionHeadline = 'Eliminar cuenta';
z.string.es.modalAccountDeletionMessage = 'Enviaremos un mensaje por correo electrónico o SMS. Sigue el enlace para borrar permanentemente tu cuenta.';

z.string.es.modalAccountLeaveGuestRoomAction = 'Abandonar';
z.string.es.modalAccountLeaveGuestRoomHeadline = '¿Abandonar la sala de invitados?';
z.string.es.modalAccountLeaveGuestRoomMessage = 'El historial de conversacion será eliminado. Para guardarlo, cree una cuenta la próxima vez.';

z.string.es.modalAccountLogoutAction = 'Cerrar sesión';
z.string.es.modalAccountLogoutHeadline = '¿Borrar los Datos?';
z.string.es.modalAccountLogoutOption = 'Borrar todos sus datos personales y las conversaciones en este dispositivo.';

z.string.es.modalAccountNewDevicesSecondary = 'Administrar dispositivos';
z.string.es.modalAccountNewDevicesHeadline = 'Tu cuenta fue usada en:';
z.string.es.modalAccountNewDevicesFrom = 'Desde:';
z.string.es.modalAccountNewDevicesMessage = 'Si usted no hizo esto, retire el dispositivo y restablecer la contraseña.';

z.string.es.modalAccountRemoveDeviceAction = 'Eliminar dispositivo';
z.string.es.modalAccountRemoveDeviceHeadline = 'Eliminar "{{device}}"';
z.string.es.modalAccountRemoveDeviceMessage = 'Se requiere tu contraseña para eliminar el dispositivo.';
z.string.es.modalAccountRemoveDevicePlaceholder = 'Contraseña';

z.string.es.modalAssetTooLargeHeadline = 'Archivo demasiado grande';
z.string.es.modalAssetTooLargeMessage = 'Puedes enviar archivos de hasta {{number}}';

z.string.es.modalAssetParallelUploadsHeadline = 'Demasiados archivos a la vez';
z.string.es.modalAssetParallelUploadsMessage = 'Puede enviar hasta {{number}} archivos a la vez.';

z.string.es.modalCallEmptyConversationHeadline = 'Nadie para llamar';
z.string.es.modalCallEmptyConversationMessage = 'No hay nadie aqui.';

z.string.es.modalCallEmptyLogHeadline = 'No hay llamadas';
z.string.es.modalCallEmptyLogMessage = 'No hay llamadas para crear el informe de depuración.';

z.string.es.modalCallNoGroupVideoHeadline = 'No hay videollamadas en grupos';
z.string.es.modalCallNoGroupVideoMessage = 'Video llamadas no están disponibles en conversaciones de grupo.';

z.string.es.modalCallNoMicrophoneAction = 'Explíqueme cómo';
z.string.es.modalCallNoMicrophoneMessage = 'Para hablar, tu navegador necesita permiso de usar el micrófono.';
z.string.es.modalCallNoMicrophoneHeadline = 'No se puede llamar sin micrófono';

z.string.es.modalCallSecondIncomingAction = 'Contestar';
z.string.es.modalCallSecondIncomingHeadline = '¿Contestar llamada?';
z.string.es.modalCallSecondIncomingMessage = 'Su llamada en curso terminara.';

z.string.es.modalCallSecondOngoingAction = 'Colgar';
z.string.es.modalCallSecondOngoingHeadline = '¿Colgar llamada en otro dispositivo?';
z.string.es.modalCallSecondOngoingMessage = 'Solo puedes estar en una llamada a la vez.';

z.string.es.modalCallSecondOutgoingAction = 'Colgar';
z.string.es.modalCallSecondOutgoingHeadline = '¿Colgar llamada actual?';
z.string.es.modalCallSecondOutgoingMessage = 'Solo puedes estar en una llamada a la vez.';

z.string.es.modalConnectCancelAction = 'Si';
z.string.es.modalConnectCancelHeadline = '¿Cancelar solicitud?';
z.string.es.modalConnectCancelMessage = 'Eliminar la solicitud de conexión con {{user}}.';
z.string.es.modalConnectCancelSecondary = 'No';

z.string.es.modalConnectAcceptAction = 'Conectar';
z.string.es.modalConnectAcceptHeadline = '¿Aceptar?';
z.string.es.modalConnectAcceptMessage = 'Esto los conectará y abrirá la conversación con {{user}}.';
z.string.es.modalConnectAcceptSecondary = 'Ignorar';

z.string.es.modalConversationClearAction = 'Eliminar';
z.string.es.modalConversationClearHeadline = '¿Borrar contenido?';
z.string.es.modalConversationClearMessage = 'Esto borrará el historial de conversaciones en todos sus dispositivos.';
z.string.es.modalConversationClearOption = 'También abandonar la conversación';

z.string.es.modalConversationDeleteMessageAction = 'Eliminar';
z.string.es.modalConversationDeleteMessageHeadline = '¿Eliminar sólo para mí?';
z.string.es.modalConversationDeleteMessageMessage = 'Esto no se puede deshacer.';

z.string.es.modalConversationDeleteMessageEveryoneAction = 'Eliminar';
z.string.es.modalConversationDeleteMessageEveryoneHeadline = '¿Eliminar para todos?';
z.string.es.modalConversationDeleteMessageEveryoneMessage = 'Esto no se puede deshacer.';

z.string.es.modalConversationLeaveAction = 'Abandonar';
z.string.es.modalConversationLeaveHeadline = '¿Dejar la conversación {{name}}?';
z.string.es.modalConversationLeaveMessage = 'No podrá enviar o recibir mensajes en esta conversación.';

z.string.es.modalConversationMessageTooLongHeadline = 'El mensaje es demasiado largo';
z.string.es.modalConversationMessageTooLongMessage = 'Puede enviar mensajes de hasta {{number}} caracteres.';

z.string.es.modalConversationNewDeviceAction = 'Enviar de todos modos';
z.string.es.modalConversationNewDeviceHeadlineOne = '{{user}} comenzó a utilizar un dispositivo nuevo';
z.string.es.modalConversationNewDeviceHeadlineMany = '{{user}}s comenzaron a utilizar dispositivos nuevos';
z.string.es.modalConversationNewDeviceHeadlineYou = '{{user}} comenzó a utilizar un dispositivo nuevo';
z.string.es.modalConversationNewDeviceIncomingCallAction = '¿Acepta la llamada?';
z.string.es.modalConversationNewDeviceIncomingCallMessage = '¿Desea aceptar la llamada?';
z.string.es.modalConversationNewDeviceMessage = '¿Aún quieres enviar su mensaje?';
z.string.es.modalConversationNewDeviceOutgoingCallAction = 'Llamar de todos modos';
z.string.es.modalConversationNewDeviceOutgoingCallMessage = '¿Desea realizar la llamada?';

z.string.es.modalConversationNotConnectedHeadline = 'No hay nadie añadido a la conversación';
z.string.es.modalConversationNotConnectedMessageOne = '{{name}} no quiere ser añadido a las conversaciones.';
z.string.es.modalConversationNotConnectedMessageMany = 'Una de las personas que has seleccionado no quiere ser añadida a conversaciones.';

z.string.es.modalConversationRemoveAction = 'Eliminar';
z.string.es.modalConversationRemoveHeadline = '¿Quitar?';
z.string.es.modalConversationRemoveMessage = '{{user}} no podrá enviar o recibir mensajes en esta conversación.';

z.string.es.modalConversationRemoveGuestsAction = 'Eliminar';
z.string.es.modalConversationRemoveGuestsHeadline = '¿Desactivar el acceso de invitados?';
z.string.es.modalConversationRemoveGuestsMessage = 'Los invitados y servicios actuales serán eliminados de la conversación. No se permitirán nuevos invitados o servicios.';

z.string.es.modalConversationRevokeLinkAction = 'Revocar enlace';
z.string.es.modalConversationRevokeLinkHeadline = '¿Revocar el enlace?';
z.string.es.modalConversationRevokeLinkMessage = 'Los nuevos invitados no podrán unirse a este enlace. Los invitados actuales seguirán teniendo acceso.';

z.string.es.modalConversationGuestOptionsAllowGuestMessage = 'No se admiten invitados o servicios. Por favor, inténtalo de nuevo.';
z.string.es.modalConversationGuestOptionsDisableGuestMessage = 'No se pudieron eliminar los invitados y servicios. Por favor, inténtalo de nuevo.';
z.string.es.modalConversationGuestOptionsGetCodeMessage = 'No se pudo obtener el enlace de acceso.';
z.string.es.modalConversationGuestOptionsRequestCodeMessage = 'No se ha podido solicitar el enlace de acceso. Por favor, inténtalo de nuevo.';
z.string.es.modalConversationGuestOptionsRevokeCodeMessage = 'No se pudo revocar el enlace de acceso. Por favor, inténtalo de nuevo.';
z.string.es.modalConversationGuestOptionsToggleGuestsMessage = 'No se pudo cambiar el estado de los invitados.';

z.string.es.modalConversationTooManyMembersHeadline = 'Grupo completo';
z.string.es.modalConversationTooManyMembersMessage = 'Hasta {{number1}} personas pueden unirse a una conversación. Actualmente sólo hay espacio para {{number2}} personas más.';

z.string.es.modalGifTooLargeHeadline = 'La animación seleccionada es demasiado grande';
z.string.es.modalGifTooLargeMessage = 'El tamaño máximo es {{number}} MB.';

z.string.es.modalIntegrationUnavailableHeadline = 'Bots no disponibles por el momento';
z.string.es.modalIntegrationUnavailableMessage = 'Gracias por su interés en los bots. El servicio está suspendido mientras trabajamos en la próxima versión.';

z.string.es.modalPictureFileFormatHeadline = 'No es posible utilizar esta foto';
z.string.es.modalPictureFileFormatMessage = 'Por favor, elija un archivo PNG o JPEG.';

z.string.es.modalPictureTooLargeHeadline = 'La imagen seleccionada es demasiado grande';
z.string.es.modalPictureTooLargeMessage = 'Puede utilizar imágenes de hasta {{number}} MB.';

z.string.es.modalPictureTooSmallHeadline = 'Imagen demasiado pequeña';
z.string.es.modalPictureTooSmallMessage = 'Por favor, elija una foto que sea de al menos 320 x 320 px.';

z.string.es.modalImproveWireAction = 'Aceptar';
z.string.es.modalImproveWireSecondary = 'No ahora';
z.string.es.modalImproveWireHeadline = 'Ayúdenos a mejorar Wire';
z.string.es.modalImproveWireMessage = 'El envío anónimo de informes de uso y fallos nos ayuda a mejorar nuestros productos y servicios. No usamos esta información para nada más.';

z.string.es.modalServiceUnavailableHeadline = 'No es posible añadir un servicio';
z.string.es.modalServiceUnavailableMessage = 'El servicio no está disponible en este momento.';

z.string.es.modalSessionResetHeadline = 'La sesión ha sido restablecida';
z.string.es.modalSessionResetMessage1 = 'Si no se resuelva el problema,';
z.string.es.modalSessionResetMessageLink = 'comunicarse con';
z.string.es.modalSessionResetMessage2 = 'nosotros.';

z.string.es.modalUploadContactsAction = 'Vuelve a intentarlo';
z.string.es.modalUploadContactsMessage = 'No recibimos tu información. Por favor, intenta importar tus contactos otra vez.';

z.string.es.modalUserBlockAction = 'Bloquear';
z.string.es.modalUserBlockHeadline = '¿Bloquear a {{user}}?';
z.string.es.modalUserBlockMessage = '{{user}} no podrá ponerse en contacto contigo o añadirte a chats de grupo.';

z.string.es.modalUserUnblockAction = 'Desbloquear';
z.string.es.modalUserUnblockHeadline = '¿Desbloquear?';
z.string.es.modalUserUnblockMessage = '{{user}} ahora podrá ponerse en contacto contigo o añadirte a chats de grupo.';

z.string.es.modalNoCameraTitle = 'Sin acceso a la cámara';
z.string.es.modalNoCameraMessage = 'Wire no tiene acceso a la cámara.[br][faqLink]Consulte este artículo de asistencia[/faqLink] para saber cómo solucionar el problema.';

z.string.es.connectionRequestConnect = 'Conectar';
z.string.es.connectionRequestIgnore = 'Ignorar';

z.string.es.conversationGuestIndicator = 'Invitado';
z.string.es.userRemainingTimeHours = '{{time}}horas restantes';
z.string.es.userRemainingTimeMinutes = 'Menos de {{time}}m restante';

z.string.es.conversationYouNominative = 'tú';
z.string.es.conversationYouDative = 'tú';
z.string.es.conversationYouAccusative = 'tú';

z.string.es.conversationConnectionAccepted = 'Conectado';
z.string.es.conversationConnectionBlocked = 'Bloqueado';
z.string.es.conversationConnectionCancelRequest = 'Cancelar solicitud de conexión';
z.string.es.conversationCreateTemporary = 'Te uniste a la conversación';
z.string.es.conversationCreateWith = 'con {{users}}';
z.string.es.conversationDeviceStartedUsingOne = ' comenzó a utilizar';
z.string.es.conversationDeviceStartedUsingMany = ' comenzó a utilizar';
z.string.es.conversationDeviceUnverified = ' uno no verificado de';
z.string.es.conversationDeviceYourDevices = ' tus dispositivos';
z.string.es.conversationDeviceUserDevices = ' {{user}} dispositivos';
z.string.es.conversationDeviceNewDeviceOne = ' un nuevo dispositivo';
z.string.es.conversationDeviceNewDeviceMany = ' nuevos dispositivos';
z.string.es.conversationDeviceNewPeopleJoined = 'Nuevas personas se unieron.';
z.string.es.conversationDeviceNewPeopleJoinedVerify = 'Verificar dispositivos';
z.string.es.conversationJustNow = 'Justo ahora';
z.string.es.conversationLocationLink = 'Abrir Mapa';
z.string.es.conversationCreated = '[bold]{{name}}[/bold] inició una conversación con {{users}}';
z.string.es.conversationCreatedMore = '[bold]{{name}}[/bold] inició una conversación con {{users}} y [showmore]{{count}} más[/showmore]';
z.string.es.conversationCreatedName = '[bold]{{name}}[/bold] inició la conversación';
z.string.es.conversationCreatedNameYou = '[bold]Tu[/bold] iniciaste la conversación';
z.string.es.conversationCreatedYou = '[[Tú]] iniciaste una conversación con %2$s';
z.string.es.conversationCreatedYouMore = 'Iniciaste una conversación con {{users}}, y [showmore]{{count}} más[/showmore]';
z.string.es.conversationCreateWithMore = 'con {{users}} y [showmore]{{count}} más[/showmore]';
z.string.es.conversationCreateTeam = 'con [showmore]todos los miembros del equipo[/showmore]';
z.string.es.conversationCreateTeamGuest = 'con [showmore]todos los miembros del equipo y un invitado[/showmore]';
z.string.es.conversationCreateTeamGuests = 'con [showmore]todos los miembros del equipo y {{count}} invitados[/showmore]';
z.string.es.conversationMemberJoined = '[bold]{{name}}[/bold] añadió a {{users}} a la conversación';
z.string.es.conversationMemberJoinedYou = '[bold] Tú [/bold] añadiste a {{users}} a la conversación';
z.string.es.conversationMemberJoinedMore = '[bold]{{name}}[/bold] agregó a {{users}} y [showmore]{{count}} más[/showmore] a la conversación';
z.string.es.conversationMemberJoinedYouMore = '[bold] Tú [/bold] añadiste a {{users}}y [showmore]{{count}}[/showmore] a la conversación';
z.string.es.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] se unió';
z.string.es.conversationMemberJoinedSelfYou = '[bold]Tú[/bold] te uniste';
z.string.es.conversationMemberLeft = '[bold]{{name}}[/bold] se fue';
z.string.es.conversationMemberLeftYou = '[bold]Tú[/bold] te fuiste';
z.string.es.conversationMemberRemoved = '[bold]{{name}}[/bold] ha removido a {{users}}';
z.string.es.conversationMemberRemovedYou = '[bold]Tú[/bold] has removido a {{users}}';
z.string.es.conversationTeamLeft = '[bold]{{name}}[/bold] fue removido del equipo';
z.string.es.conversationMessageDelivered = 'Entregado';
z.string.es.conversationRename = ' renombró la conversación';
z.string.es.conversationRenameYou = ' renombró la conversación';
z.string.es.conversationUpdatedTimer = ' ajustar el temporizador de mensajes a {{time}}';
z.string.es.conversationUpdatedTimerYou = ' ajustar el temporizador de mensajes a {{time}}';
z.string.es.conversationResetTimer = ' apagó el temporizador de mensajes';
z.string.es.conversationResetTimerYou = ' apagó el temporizador de mensajes';
z.string.es.conversationResume = 'Iniciar una conversación con {{users}}';
z.string.es.conversationPing = ' ping';
z.string.es.conversationPingYou = ' ping';
z.string.es.conversationToday = 'hoy';
z.string.es.conversationVoiceChannelDeactivate = ' llamó';
z.string.es.conversationVoiceChannelDeactivateYou = ' llamó';
z.string.es.conversationYesterday = 'Ayer';
z.string.es.conversationUnableToDecrypt1 = 'un mensaje de {{user}} no se ha recibido.';
z.string.es.conversationUnableToDecrypt2 = 'La identidad del dispositivo de {{user}} ha cambiado. Mensaje no entregado.';
z.string.es.conversationUnableToDecryptLink = '¿Por qué?';
z.string.es.conversationUnableToDecryptErrorMessage = 'Error';
z.string.es.conversationUnableToDecryptResetSession = 'Restablecer sesión';
z.string.es.conversationMissedMessages = 'No has utilizado este dispositivo durante un tiempo. Algunos mensajes no aparecerán aquí.';
z.string.es.conversationAssetUploading = 'Subiendo…';
z.string.es.conversationAssetDownloading = 'Descargando…';
z.string.es.conversationAssetUploadFailed = 'Error al subir la información';
z.string.es.conversationPlaybackError = 'Incapaz de reproducir';
z.string.es.conversationContextMenuCopy = 'Copiar';
z.string.es.conversationContextMenuEdit = 'Editar';
z.string.es.conversationContextMenuDelete = 'Eliminar para mí';
z.string.es.conversationContextMenuDeleteEveryone = 'Eliminar para Todos…';
z.string.es.conversationContextMenuDownload = 'Descargar';
z.string.es.conversationContextMenuLike = 'Me gusta';
z.string.es.conversationContextMenuUnlike = 'No me gusta';
z.string.es.conversationDeleteTimestamp = 'Eliminados el {{date}}';
z.string.es.conversationEditTimestamp = 'Editado {{date}}';
z.string.es.conversationLikesCaption = '{{number}}o de personas';
z.string.es.conversationSendPastedFile = 'Imagen añadida el {{date}}';
z.string.es.conversationSomeone = 'Alguien';
z.string.es.conversationTweetAuthor = ' en Twitter';
z.string.es.conversationServicesWarning = 'Hay servicios con acceso al contenido de esta conversación';

z.string.es.groupCreationPreferencesAction = 'Siguiente';
z.string.es.groupCreationPreferencesErrorNameShort = 'Por lo menos 1 caracter';
z.string.es.groupCreationPreferencesErrorNameLong = 'Demasiados caracteres';
z.string.es.groupCreationPreferencesHeader = 'Crear grupo';
z.string.es.groupCreationPreferencesPlaceholder = 'Nombre del grupo';
z.string.es.groupCreationParticipantsActionCreate = 'Listo';
z.string.es.groupCreationParticipantsActionSkip = 'Omitir';
z.string.es.groupCreationParticipantsHeader = 'Agregar personas';
z.string.es.groupCreationParticipantsHeaderWithCounter = 'Añadir personas ({{number}})';
z.string.es.groupCreationParticipantsPlaceholder = 'Buscar por nombre';
z.string.es.groupSizeInfo = 'Hasta {{count}} personas pueden unirse a una conversación de grupo. Las videollamadas funcionan con hasta 3 personas y contigo.';

z.string.es.guestRoomConversationName = 'Sala de invitados';
z.string.es.guestRoomToggleName = 'Permitir invitados y servicios';
z.string.es.guestRoomToggleInfo = 'Abrir esta conversación a servicios y personas fuera de su equipo.';
z.string.es.guestRoomToggleInfoExtended = 'Abrir esta conversación a servicios y personas fuera de su equipo. Siempre puedes cambiarlo más tarde.';

z.string.es.guestRoomConversationBadge = 'Invitados presentes';
z.string.es.guestRoomConversationBadgeService = 'Servicios activos';
z.string.es.guestRoomConversationBadgeGuestAndService = 'Hay invitados y servicios activos';

z.string.es.guestRoomConversationHead = 'Personas ajenas a su equipo pueden unirse a esta conversación.';
z.string.es.guestRoomConversationButton = 'Invitar personas';

z.string.es.collectionShowAll = 'Mostrar los {{number}}';
z.string.es.collectionSectionLinks = 'Enlaces';
z.string.es.collectionSectionImages = 'Fotos';
z.string.es.collectionSectionFiles = 'Ficheros';
z.string.es.collectionSectionAudio = 'Mensajes de audio';

z.string.es.fullsearchPlaceholder = 'Buscar mensajes';
z.string.es.fullsearchNoResults = 'Ningún resultado.';

z.string.es.archiveHeader = 'Archivar';

z.string.es.conversationsAllArchived = 'Todo archivado';
z.string.es.conversationsContacts = 'Contactos';
z.string.es.conversationsConnectionRequestMany = '{{number}} personas en espera';
z.string.es.conversationsConnectionRequestOne = '1 persona en espera';
z.string.es.conversationsEmptyConversation = 'Conversación en grupo';
z.string.es.conversationsNoConversations = 'Iniciar una conversación o crear un grupo.';
z.string.es.conversationsPopoverArchive = 'Archivar';
z.string.es.conversationsPopoverBlock = 'Bloquear…';
z.string.es.conversationsPopoverCancel = 'Cancelar solicitud';
z.string.es.conversationsPopoverClear = 'Eliminar contenido…';
z.string.es.conversationsPopoverLeave = 'Abandonar el grupo…';
z.string.es.conversationsPopoverNotificationSettings = 'Notificaciones…';
z.string.es.conversationsPopoverNotify = 'Sonido';
z.string.es.conversationsPopoverSilence = 'Silenciar';
z.string.es.conversationsPopoverUnarchive = 'Desarchivar';

z.string.es.conversationsSecondaryLineEphemeralMention = 'Te mencionó';
z.string.es.conversationsSecondaryLineEphemeralMentionGroup = 'Alguien te mencionó';
z.string.es.conversationsSecondaryLineEphemeralMessage = 'Te envió un mensaje';
z.string.es.conversationsSecondaryLineEphemeralMessageGroup = 'Alguien envió un mensaje';
z.string.es.conversationsSecondaryLineIncomingCall = '{{user}} está llamando';
z.string.es.conversationsSecondaryLinePeopleLeft = '{{number}} personas se fueron';
z.string.es.conversationsSecondaryLinePersonLeft = '{{user}} se fue';
z.string.es.conversationsSecondaryLinePersonRemoved = '{{user}} fue eliminado';
z.string.es.conversationsSecondaryLinePersonRemovedTeam = '{{user}} fue eliminado del equipo';
z.string.es.conversationsSecondaryLinePeopleAdded = '{{user}} personas se han añadido';
z.string.es.conversationsSecondaryLinePersonAdded = '{{user}} se ha añadido';
z.string.es.conversationsSecondaryLinePersonAddedSelf = '{{user}} se unió';
z.string.es.conversationsSecondaryLinePersonAddedYou = '{{user}} te ha añadido';
z.string.es.conversationsSecondaryLineRenamed = '{{user}} renombró la conversación';
z.string.es.conversationsSecondaryLineSummaryMessage = '{{number}} mensaje';
z.string.es.conversationsSecondaryLineSummaryMessages = '{{number}} mensajes';
z.string.es.conversationsSecondaryLineSummaryMention = '{{number}} mención';
z.string.es.conversationsSecondaryLineSummaryMentions = '{{number}} menciones';
z.string.es.conversationsSecondaryLineSummaryMissedCall = '{{number}} llamada perdida';
z.string.es.conversationsSecondaryLineSummaryMissedCalls = '{{number}} llamadas perdidas';
z.string.es.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.es.conversationsSecondaryLineSummaryPings = '{{number}} pings'
z.string.es.conversationsSecondaryLineYouLeft = 'Te fuiste';
z.string.es.conversationsSecondaryLineYouWereRemoved = 'Te han eliminado';

z.string.es.takeoverSub = 'Reclama tu nombre único en Wire.';
z.string.es.takeoverLink = 'Aprender más';
z.string.es.takeoverButtonChoose = 'Elegir tu propio nombre';
z.string.es.takeoverButtonKeep = 'Conservar este';

z.string.es.inviteMetaKeyMac = 'Cmd';
z.string.es.inviteMetaKeyPc = 'Ctrl';
z.string.es.inviteHintSelected = 'Presione {{metaKey}} + C para copiar';
z.string.es.inviteHintUnselected = 'Seleccione y presione {{metaKey}} + C';
z.string.es.inviteHeadline = 'Invitar amigos a Wire';
z.string.es.inviteMessage = 'Estoy en Wire, búscame como {{username}} o visita get.wire.com.';
z.string.es.inviteMessageNoEmail = 'Estoy en Wire. Visita get.wire.com para conectar conmigo.';

z.string.es.extensionsBubbleButtonGif = 'Gif';

z.string.es.extensionsGiphyButtonOk = 'Enviar';
z.string.es.extensionsGiphyButtonMore = 'Buscar otro';
z.string.es.extensionsGiphyMessage = '{{tag}} · vía giphy.com';
z.string.es.extensionsGiphyNoGifs = 'Uups, no hay gifs';
z.string.es.extensionsGiphyRandom = 'Aleatorio';

z.string.es.addParticipantsConfirmLabel = 'Agregar';
z.string.es.addParticipantsHeader = 'Agregar participantes';
z.string.es.addParticipantsHeaderWithCounter = 'Añadir participantes ({{number}})';
z.string.es.addParticipantsManageServices = 'Gestionar servicios';
z.string.es.addParticipantsManageServicesNoResults = 'Gestionar servicios';
z.string.es.addParticipantsNoServicesManager = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo.';
z.string.es.addParticipantsNoServicesMember = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo. Para activarlos, póngase en contacto con el administrador.';
z.string.es.addParticipantsSearchPlaceholder = 'Buscar por nombre';
z.string.es.addParticipantsServiceConfirmButton = 'Añadir un servicio';
z.string.es.addParticipantsTabsPeople = 'Personas';
z.string.es.addParticipantsTabsServices = 'Servicios';

z.string.es.conversationDetailsActionArchive = 'Archivar';
z.string.es.conversationDetailsActionAddParticipants = 'Añadir participantes';
z.string.es.conversationDetailsActionBlock = 'Bloquear…';
z.string.es.conversationDetailsActionCancelRequest = 'Cancelar solicitud';
z.string.es.conversationDetailsActionClear = 'Eliminar contenido…';
z.string.es.conversationDetailsActionConversationParticipants = 'Mostrar todo ({{number}})';
z.string.es.conversationDetailsActionCreateGroup = 'Crear grupo';
z.string.es.conversationDetailsActionDevices = 'Dispositivos';
z.string.es.conversationDetailsActionGuestOptions = 'Invitados y servicios';
z.string.es.conversationDetailsActionTimedMessages = 'Mensajes temporizados';
z.string.es.conversationDetailsActionNotifications = 'Notificaciones';
z.string.es.conversationDetailsActionLeave = 'Abandonar el grupo…';
z.string.es.conversationDetailsGuestsOff = 'Desactivar';
z.string.es.conversationDetailsGuestsOn = 'En';
z.string.es.conversationDetailsOptions = 'Opciones';
z.string.es.conversationDetailsParticipantsServicesOne = 'Servicio';
z.string.es.conversationDetailsParticipantsServicesMany = 'Servicios';
z.string.es.conversationDetailsParticipantsUsersOne = 'Persona';
z.string.es.conversationDetailsParticipantsUsersMany = 'Personas';
z.string.es.conversationDetailsPeople = 'Personas';
z.string.es.conversationDetailsServices = 'Servicios';

z.string.es.conversationParticipantsTitle = 'Personas';
z.string.es.conversationParticipantsSearchPlaceholder = 'Buscar por nombre';

z.string.es.groupParticipantActionBlock = 'Bloquear…';
z.string.es.groupParticipantActionCancelRequest = 'Cancelar solicitud';
z.string.es.groupParticipantActionDevices = 'Dispositivos';
z.string.es.groupParticipantActionIgnoreRequest = 'Ignorar la solicitud';
z.string.es.groupParticipantActionIncomingRequest = 'Aceptar la solicitud';
z.string.es.groupParticipantActionLeave = 'Abandonar el grupo…';
z.string.es.groupParticipantActionOpenConversation = 'Abrir la conversación';
z.string.es.groupParticipantActionPending = 'Pendiente';
z.string.es.groupParticipantActionRemove = 'Remover del grupo…';
z.string.es.groupParticipantActionSelfProfile = 'Abrir perfil';
z.string.es.groupParticipantActionSendRequest = 'Conectar';
z.string.es.groupParticipantActionUnblock = 'Desbloquear…';

z.string.es.guestOptionsCopyLink = 'Copiar el enlace';
z.string.es.guestOptionsCopyLinkDone = 'Se copió el enlace.';
z.string.es.guestOptionsCreateLink = 'Crear un enlace';
z.string.es.guestOptionsInfoHeader = 'Invitar a otros con un enlace';
z.string.es.guestOptionsInfoText = 'Cualquiera que posea el enlace puede unirse a la conversación, incluso si no usa Wire.';
z.string.es.guestOptionsRevokeLink = 'Revocar el enlace…';
z.string.es.guestOptionsTitle = 'Invitados y servicios';

z.string.es.notificationSettingsTitle = 'Notificaciones';
z.string.es.notificationSettingsDisclaimer = 'Se te notificará acerca de todo (incluidas llamadas de audio y video) o sólo cuando se te menciona.';
z.string.es.notificationSettingsEverything = 'Todo';
z.string.es.notificationSettingsNothing = 'Nada';

z.string.es.timedMessagesTitle = 'Mensaje temporizado';
z.string.es.timedMessageDisclaimer = 'Los mensajes cronometrados se activarán para todos los participantes en esta conversación.';

z.string.es.participantDevicesDetailHeadline = 'Verifica que esta coincida con la huella digital que se muestra en el {{html1}}dispositivo de {{user}}’s{{html2}}.';
z.string.es.participantDevicesDetailHowTo = '¿Cómo lo hago?';
z.string.es.participantDevicesDetailResetSession = 'Restablecer sesión';
z.string.es.participantDevicesDetailShowMyDevice = 'Mostrar la huella digital de mi dispositivo';
z.string.es.participantDevicesDetailVerify = 'Verificado';

z.string.es.participantDevicesHeader = 'Dispositivos';
z.string.es.participantDevicesHeadline = 'Wire proporciona a cada dispositivo una huella digital única. Comparala con {{user}} y verifica tu conversación.';
z.string.es.participantDevicesLearnMore = 'Aprender más';
z.string.es.participantDevicesWhyVerify = '¿Por qué verificar las conversaciones?';
z.string.es.participantDevicesOutdatedClientMessage = '{{user}} está utilizando una versión antigua de Wire. No se muestran dispositivos aquí.';

z.string.es.participantDevicesSelfAllDevices = 'Mostrar todos mis dispositivos';
z.string.es.participantDevicesSelfFingerprint = 'Huella digital de tu dispositivo';

z.string.es.userProfileButtonConnect = 'Conectar';
z.string.es.userProfileButtonIgnore = 'Ignorar';
z.string.es.userProfileButtonUnblock = 'Desbloquear';

z.string.es.preferencesAbout = 'Acerca de';
z.string.es.preferencesAccount = 'Cuenta';
z.string.es.preferencesAV = 'Audio / Vídeo';
z.string.es.preferencesDeviceDetails = 'Detalles del dispositivo';
z.string.es.preferencesDevices = 'Dispositivos';
z.string.es.preferencesHeadline = 'Preferencias';
z.string.es.preferencesOptions = 'Opciones';

z.string.es.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.es.preferencesAboutPrivacyPolicy = 'Política de Privacidad';
z.string.es.preferencesAboutSupport = 'Soporte';
z.string.es.preferencesAboutSupportWebsite = 'Sitio web de Soporte';
z.string.es.preferencesAboutSupportContact = 'Contactar con Soporte';
z.string.es.preferencesAboutTermsOfUse = 'Términos de uso';
z.string.es.preferencesAboutVersion = 'Versión {{version}}';
z.string.es.preferencesAboutWebsite = 'Página web de Wire';

z.string.es.preferencesAccountAvaibilityUnset = 'Establecer estado';
z.string.es.preferencesAccountCreateTeam = 'Crear un equipo';
z.string.es.preferencesAccountData = 'Permisos de uso de datos';
z.string.es.preferencesAccountDataCheckbox = 'Enviar datos anónimos';
z.string.es.preferencesAccountDataDetail = 'Ayude a mejorar Wire enviando informes anónimos sobre el uso y los fallos.';
z.string.es.preferencesAccountDelete = 'Eliminar cuenta';
z.string.es.preferencesAccountLeaveGuestRoom = 'Abandonar la sala de invitados';
z.string.es.preferencesAccountLeaveGuestRoomDescription = 'Ya no podrá acceder a los mensajes de esta conversación.';
z.string.es.preferencesAccountLogOut = 'Cerrar sesión';
z.string.es.preferencesAccountManageTeam = 'Administrar equipo';
z.string.es.preferencesAccountMarketingConsentCheckbox = 'Recibir boletín de noticias';
z.string.es.preferencesAccountMarketingConsentDetail = 'Reciba noticias y actualizaciones de productos de Wire por correo electrónico.';
z.string.es.preferencesAccountResetPassword = 'Restablecer contraseña';
z.string.es.preferencesAccountTeam = 'en {{name}}';
z.string.es.preferencesAccountUsernamePlaceholder = 'Tu nombre completo';
z.string.es.preferencesAccountUsernameHint = 'Al menos 2 caracteres. Sólo a–z, 0–9 y _.';
z.string.es.preferencesAccountUsernameAvailable = 'Disponible';
z.string.es.preferencesAccountUsernameErrorTaken = 'No disponible';

z.string.es.preferencesAVCamera = 'Cámara';
z.string.es.preferencesAVMicrophone = 'Micrófono';
z.string.es.preferencesAVPermissionDetail = 'Habilitar desde las preferencias de tu navegador';
z.string.es.preferencesAVSpeakers = 'Altavoz';
z.string.es.preferencesAVTemporaryDisclaimer = 'Los invitados no pueden iniciar videoconferencias. Seleccione la cámara que desea utilizar si se une a una.';
z.string.es.preferencesAVNoCamera = 'Wire no tiene acceso a la cámara.[br][faqLink]Consulte este artículo de asistencia[/faqLink] para saber cómo solucionar el problema.';
z.string.es.preferencesAVTryAgain = 'Intentar de nuevo';

z.string.es.preferencesDevicesActivatedOn = 'Activado el {{date}}';
z.string.es.preferencesDevicesActive = 'Activo';
z.string.es.preferencesDevicesActiveDetail = 'Si no reconoces un dispositivo anterior, elimínalo y restablece tu contraseña.';
z.string.es.preferencesDevicesCurrent = 'Actual';
z.string.es.preferencesDevicesFingerprint = 'Huella digital';
z.string.es.preferencesDevicesFingerprintDetail = 'Wire proporciona a cada dispositivo una huella digital única. Compare las huellas dactilares para verificar su dispositivos y conversaciones.';
z.string.es.preferencesDevicesId = 'ID: ';
z.string.es.preferencesDevicesRemove = 'Eliminar…';
z.string.es.preferencesDevicesRemoveCancel = 'Cancelar';
z.string.es.preferencesDevicesRemoveDetail = 'Elimina este dispositivo si has dejado de usarlo. Se cerrará la sesión inmediatamente en este dispositivo.';
z.string.es.preferencesDevicesSessionConfirmation = 'La sesión ha sido restablecida.';
z.string.es.preferencesDevicesSessionDetail = 'Si no coinciden las huellas digitales, reiniciar la sesión para generar nuevas claves de cifrado en ambos lados.';
z.string.es.preferencesDevicesSessionReset = 'Restablecer sesión';
z.string.es.preferencesDevicesSessionOngoing = 'Restableciendo sesión…';
z.string.es.preferencesDevicesVerification = 'Verificado';

z.string.es.preferencesOptionsAudio = 'Alertas de sonido';
z.string.es.preferencesOptionsAudioAll = 'Todos';
z.string.es.preferencesOptionsAudioAllDetail = 'Todos los sonidos';
z.string.es.preferencesOptionsAudioNone = 'Ninguno';
z.string.es.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.es.preferencesOptionsAudioSome = 'Algunos';
z.string.es.preferencesOptionsAudioSomeDetail = 'Pings y llamadas';
z.string.es.preferencesOptionsContacts = 'Contactos';
z.string.es.preferencesOptionsContactsGmail = 'Importar desde Gmail';
z.string.es.preferencesOptionsContactsMacos = 'Importar desde Contactos';
z.string.es.preferencesOptionsContactsDetail = 'Compartir tus contactos te ayuda a conectarte con otros. Toda la información es anónima y no será compartida con nadie más.';
z.string.es.preferencesOptionsPopular = 'Por demanda popular';
z.string.es.preferencesOptionsEmojiReplaceCheckbox = 'Sustituir emoticonos por emojis';
z.string.es.preferencesOptionsPreviewsSendCheckbox = 'Crear vistas previas para los enlaces enviados';
z.string.es.preferencesOptionsPreviewsSendDetail = 'Las vistas previas todavía pueden mostrarse para enlaces de otras personas.';
z.string.es.preferencesOptionsNotifications = 'Notificaciones';
z.string.es.preferencesOptionsNotificationsNone = 'Desactivar';
z.string.es.preferencesOptionsNotificationsObfuscate = 'Ocultar detalles';
z.string.es.preferencesOptionsNotificationsObfuscateMessage = 'Mostrar remitente';
z.string.es.preferencesOptionsNotificationsOn = 'Mostrar remitente y mensaje';
z.string.es.preferencesOptionsCallLogs = 'Solución de problemas';
z.string.es.preferencesOptionsCallLogsGet = 'Guardar el informe de depuración de llamadas';
z.string.es.preferencesOptionsCallLogsDetail = 'Esta información ayuda al Soporte de Wire a diagnosticar problemas de llamadas.';

z.string.es.preferencesOptionsBackupHeader = 'Historia';
z.string.es.preferencesOptionsBackupExportHeadline = 'Realizar copias de seguridad de las conversaciones';
z.string.es.preferencesOptionsBackupExportSecondary = 'Cree una copia de seguridad para conservar el historial de conversaciones. Puede utilizarla para restaurar el historial si pierde el equipo o cambia a uno nuevo. El archivo de copia de seguridad no está protegido por el cifrado de extremo a extremo de Wire, así que guárdelo en un lugar seguro.';
z.string.es.preferencesOptionsBackupImportHeadline = 'Restaurar desde la copia de seguridad';
z.string.es.preferencesOptionsBackupImportSecondary = 'Sólo puede restaurar el historial desde una copia de seguridad de la misma plataforma. Su copia de seguridad sobrescribirá las conversaciones que pueda tener en este dispositivo.';

z.string.es.backupExportGenericErrorHeadline = 'El archivo no se ha podido guardar';
z.string.es.backupExportGenericErrorSecondary = 'La copia de seguridad no se ha completado.';
z.string.es.backupExportProgressHeadline = 'Preparando…';
z.string.es.backupExportProgressSecondary = 'Haciendo copias de seguridad. {{processed}} de {{total}} - {{progress}}%';
z.string.es.backupExportProgressCompressing = 'Preparando el archivo de respaldo';
z.string.es.backupExportSaveFileAction = 'Guardar archivo';
z.string.es.backupExportSuccessHeadline = 'Backup listo';
z.string.es.backupExportSuccessSecondary = 'Puedes utilizar esto para restaurar el historial de conversaciones si pierdes la computadora o cambias a una nueva.';
z.string.es.backupImportGenericErrorHeadline = 'Algo salió mal';
z.string.es.backupImportGenericErrorSecondary = 'Tu historial no pudo ser restaurado.';
z.string.es.backupImportAccountErrorHeadline = 'Copia de seguridad incorrecta';
z.string.es.backupImportAccountErrorSecondary = 'No se puede restaurar el historial desde una cuenta diferente.';
z.string.es.backupImportVersionErrorHeadline = 'Copia de seguridad incompatible';
z.string.es.backupImportVersionErrorSecondary = 'Esta copia de seguridad fue creada por una versión antigua o más reciente de Wire y no se puede restaurar aquí.';
z.string.es.backupImportIncompatibleErrorHeadline = 'Copia de seguridad incorrecta';
z.string.es.backupImportIncompatibleErrorSecondary = 'No se puede restaurar el historial desde una cuenta diferente.';
z.string.es.backupImportOutdatedErrorHeadline = 'Copia de seguridad incompatible';
z.string.es.backupImportOutdatedErrorSecondary = 'Esta copia de seguridad fue creada por una versión antigua o más reciente de Wire y no se puede restaurar aquí.';
z.string.es.backupImportProgressHeadline = 'Preparando…';
z.string.es.backupImportProgressSecondary = 'Restaurando la copia de seguridad. {{processed}} de {{total}} - {{progress}}%';
z.string.es.backupImportSuccessHeadline = 'Historia restaurada.';
z.string.es.backupCancel = 'Cancelar';
z.string.es.backupTryAgain = 'Intentar de nuevo';

z.string.es.searchConnect = 'Conectar';
z.string.es.searchConnections = 'Conexiones';
z.string.es.searchContacts = 'Contactos';
z.string.es.searchCreateGroup = 'Crear grupo';
z.string.es.searchCreateGuestRoom = 'Crear una sala de invitados';
z.string.es.searchGroups = 'Grupos';
z.string.es.searchPeople = 'Personas';
z.string.es.searchPlaceholder = 'Buscar por nombre o usuario';
z.string.es.searchServicePlaceholder = 'Buscar por nombre';
z.string.es.searchServices = 'Servicios';
z.string.es.searchManageServices = 'Gestionar los servicios';
z.string.es.searchManageServicesNoResults = 'Gestionar servicios';
z.string.es.searchNoServicesManager = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo.';
z.string.es.searchNoServicesMember = 'Los servicios son auxiliares que pueden mejorar su flujo de trabajo. Para activarlos, póngase en contacto con el administrador.';
z.string.es.searchTeamGroups = 'Conversaciones de equipo';
z.string.es.searchTeamMembers = 'Miembros del equipo';
z.string.es.searchTopPeople = 'Personas más importantes';
z.string.es.searchTrySearch = 'Encontrar personas por nombre o usuario';
z.string.es.searchNoContactsOnWire = 'No tienes contactos en Wire. Trata de encontrar personas por nombre o usuario.';
z.string.es.searchMemberInvite = 'Invitar personas a unirse al equipo';
z.string.es.searchOthers = 'Conectar';

z.string.es.searchInvite = 'Invitar amigos a Wire';
z.string.es.searchInviteDetail = 'Compartir tus contactos te ayuda a conectar con otros. Anonimizamos toda la información y no la compartimos con nadie.';
z.string.es.searchInviteButtonContacts = 'Desde los contactos';
z.string.es.searchInviteButtonGmail = 'Desde Gmail';
z.string.es.searchInviteHeadline = 'Tráete a tus amigos';
z.string.es.searchInviteShare = 'Compartir contactos';

z.string.es.searchServiceConfirmButton = 'Abrir conversación';

z.string.es.searchListEveryoneParticipates = 'Todas las personas con quien estás conectado ya se encuentran en esta conversación.';
z.string.es.searchListNoMatches = 'No hay resultados coincidentes. Intente con un nombre diferente.';

z.string.es.temporaryGuestCta = 'Crear una cuenta';
z.string.es.temporaryGuestDescription = 'Asegurá tu negocio con mensajes de grupos y llamadas cifradas de punta a punta.';
z.string.es.temporaryGuestTimeRemaining = ' no hay nadie en esta sala de invitados';

z.string.es.temporaryGuestJoinMessage = 'Esta conversación estará disponible durante las próximas 24 horas.';
z.string.es.temporaryGuestJoinDescription = 'Si cierras o actualizas esta página, perderás acceso.';

z.string.es.temporaryGuestLeaveMessage = ' ya no eres parte de esta conversación.';
z.string.es.temporaryGuestLeaveDescription = 'Si cierras o actualizas esta página, perderás acceso al historial de conversación.';

z.string.es.uploadGoogleHeadline = 'Buscar con quien hablar.';
z.string.es.uploadGoogleMessage = 'Compartir tus contactos te ayuda a conectarte con otros. Toda la información es anónima y no será compartida con nadie más.';

z.string.es.warningCallUnsupportedIncoming = '{{user}} está llamando. Tu navegador no está configurada para llamadas.';
z.string.es.warningCallUnsupportedOutgoing = 'No puedes llamar porque tu navegador no está configurada para llamadas.';
z.string.es.warningCallIssues = 'Esta versión de Wire no puede participar en la llamada. Por favor, usa';
z.string.es.warningCallUpgradeBrowser = 'Para llamar se necesita una versión reciente de Google Chrome.';
z.string.es.warningConnectivityConnectionLost = 'Intentando conectar. Es posible que Wire no podrá entregar mensajes.';
z.string.es.warningConnectivityNoInternet = 'No hay Internet. No podrás enviar o recibir mensajes.';
z.string.es.warningLearnMore = 'Aprender más';
z.string.es.warningLifecycleUpdate = 'Hay una nueva versión de Wire disponible.';
z.string.es.warningLifecycleUpdateNotes = 'Novedades';
z.string.es.warningLifecycleUpdateLink = 'Actualiza ahora';
z.string.es.warningNotFoundCamera = 'No puedes llamar porque tu máquina no tiene cámera.';
z.string.es.warningNotFoundMicrophone = 'No puedes llamar porque tu máquina no tiene micrófono.';
z.string.es.warningPermissionDeniedCamera = 'No puedes llamar porque tu máquina no tiene accesso a la cámera.';
z.string.es.warningPermissionDeniedMicrophone = 'No puedes llamar porque tu máquina no tiene acceso al micrófono.';
z.string.es.warningPermissionDeniedScreen = 'Tu navegador necesita permiso para compartir la pantalla.';
z.string.es.warningPermissionRequestCamera = '{{icon}} Permitir acceso a la cámara';
z.string.es.warningPermissionRequestMicrophone = '{{icon}} Permitir acceso al micrófono';
z.string.es.warningPermissionRequestNotification = '{{icon}} Permitir notificaciones';
z.string.es.warningPermissionRequestScreen = '{{icon}} Permitir acceso a la pantalla';

z.string.es.userAvailabilityAvailable = 'Disponible';
z.string.es.userAvailabilityAway = 'Ausente';
z.string.es.userAvailabilityBusy = 'Ocupado';
z.string.es.userAvailabilityNone = 'Ninguno';

z.string.es.notificationAssetAdd = 'Compartió una foto';
z.string.es.notificationConnectionAccepted = 'Aceptó tu solicitud de conexión';
z.string.es.notificationConnectionConnected = 'Ahora está conectado';
z.string.es.notificationConnectionRequest = 'Quiere conectar';
z.string.es.notificationConversationCreate = '{{user}} inició una conversación';
z.string.es.notificationConversationMessageTimerUpdate = '{{user}} estableció el temporizador de mensajes a {{time}}';
z.string.es.notificationConversationMessageTimerReset = '{{user}} apagó el temporizador de mensajes';
z.string.es.notificationConversationRename = '{{user}} renombró la conversación a {{name}}';
z.string.es.notificationMemberJoinMany = '{{user}} agregó a {{number}} personas a la conversación';
z.string.es.notificationMemberJoinSelf = '{user} se unió a la conversación';
z.string.es.notificationMemberJoinOne = '{{user1}} agregó a {{user2}} a la conversación';
z.string.es.notificationMemberLeaveRemovedYou = '{{user}} te eliminó de la conversación';
z.string.es.notificationMention = 'Mención nueva:';
z.string.es.notificationObfuscated = 'Te envió un mensaje';
z.string.es.notificationObfuscatedMention = 'Te mencionó';
z.string.es.notificationObfuscatedTitle = 'Alguien';
z.string.es.notificationPing = 'Hizo ping';
z.string.es.notificationReaction = '{{reaction}} su mensaje';
z.string.es.notificationSharedAudio = 'Compartió un mensaje de audio';
z.string.es.notificationSharedFile = 'Compartió un archivo';
z.string.es.notificationSharedLocation = 'Compartió una ubicación';
z.string.es.notificationSharedVideo = 'Compartió un video';
z.string.es.notificationTitleGroup = '{{user}} en {{conversation}}';
z.string.es.notificationVoiceChannelActivate = 'Llamando';
z.string.es.notificationVoiceChannelDeactivate = 'Llamó';

z.string.es.tooltipConversationAllVerified = 'Todas las huellas digitales están verificadas';
z.string.es.tooltipConversationCall = 'Llamar';
z.string.es.tooltipConversationEphemeral = 'Mensaje temporizado';
z.string.es.tooltipConversationFile = 'Añadir archivo';
z.string.es.tooltipConversationInputPlaceholder = 'Escriba un mensaje';
z.string.es.tooltipConversationInputPlaceholderAvailable = '{{user}} está disponible';
z.string.es.tooltipConversationInputPlaceholderAway = '{{user}} está ausente';
z.string.es.tooltipConversationInputPlaceholderBusy = '{{user}} está ocupado';
z.string.es.tooltipConversationPeople = 'Personas ({{shortcut}})';
z.string.es.tooltipConversationPicture = 'Añadir imagen';
z.string.es.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.es.tooltipConversationSearch = 'Buscar';
z.string.es.tooltipConversationVideoCall = 'Videollamada';

z.string.es.tooltipConversationsArchive = 'Archivo ({{shortcut}})';
z.string.es.tooltipConversationsArchived = 'Mostrar archivo ({{number}})';
z.string.es.tooltipConversationsMore = 'Más';
z.string.es.tooltipConversationsNotifications = 'Abrir configuración de notificaciones ({{shortcut}})';
z.string.es.tooltipConversationsNotify = 'Activar sónido ({{shortcut}})';
z.string.es.tooltipConversationsPreferences = 'Abrir preferencias';
z.string.es.tooltipConversationsSilence = 'Silenciar ({{shortcut}})';
z.string.es.tooltipConversationsStart = 'Empezar una conversación ({{shortcut}})';

z.string.es.tooltipConversationDetailsAddPeople = 'Añadir participantes a la conversación ({{shortcut}})';
z.string.es.tooltipConversationDetailsRename = 'Cambiar nombre de la conversación';

z.string.es.tooltipPreferencesContactsGmail = 'Iniciar sesión en tu cuenta de Gmail para compartir los contactos';
z.string.es.tooltipPreferencesContactsMacos = 'Compartir todos tus contactos desde la aplicación de Contactos de macOS';
z.string.es.tooltipPreferencesPassword = 'Abrir otra página web para restablecer su contraseña';
z.string.es.tooltipPreferencesPicture = 'Cambiar tu foto…';
z.string.es.tooltipPreferencesRename = 'Cambiar tu nombre';

z.string.es.tooltipSearchClose = 'Cerrar (Esc)';

z.string.es.initReceivedSelfUser = 'Hola, {{user}}.';
z.string.es.initValidatedClient = 'Cargando conexiones y conversaciones';
z.string.es.initReceivedUserData = 'Buscando mensajes nuevos';
z.string.es.initDecryption = 'Descifrando mensajes';
z.string.es.initEvents = 'Cargando mensajes';
z.string.es.initUpdatedFromNotifications = 'Casi terminado - Disfruta  Wire';
z.string.es.initProgress = ' — {{number1}} de {{number2}}';

z.string.es.ephemeralUnitsNone = 'Desactivar';
z.string.es.ephemeralUnitsSecond = 'segundo';
z.string.es.ephemeralUnitsSeconds = 'segundos';
z.string.es.ephemeralUnitsMinute = 'minuto';
z.string.es.ephemeralUnitsMinutes = 'minutos';
z.string.es.ephemeralUnitsHour = 'hora';
z.string.es.ephemeralUnitsHours = 'horas';
z.string.es.ephemeralUnitsDay = 'día';
z.string.es.ephemeralUnitsDays = 'días';
z.string.es.ephemeralUnitsWeek = 'semana';
z.string.es.ephemeralUnitsWeeks = 'semanas';
z.string.es.ephemeralUnitsYear = 'año';
z.string.es.ephemeralUnitsYears = 'años';
z.string.es.ephemeralRemaining = 'restantes';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.et.wire = 'Wire';
z.string.et.wireMacos = 'Wire macOS-ile';
z.string.et.wireWindows = 'Wire Windowsile';
z.string.et.wireLinux = 'Wire Linuxile';
z.string.et.nonexistentUser = 'Kustutatud kasutaja';
z.string.et.and = 'ja';
z.string.et.enumerationAnd = ' ja ';

//=Rakenduse laadimine
z.string.et.authAccountCountryCode = 'Riigi kood';
z.string.et.authAccountPasswordForgot = 'Unustasid parooli?';
z.string.et.authAccountPublicComputer = 'See on avalik arvuti';
z.string.et.authAccountSignIn = 'Logi sisse';
z.string.et.authAccountSignInPhone = 'Telefoniga sisse logimine';

z.string.et.authBlockedCookies = 'Wire’i sisselogimiseks luba küpsised.';
z.string.et.authBlockedDatabase = 'Wire vajab sõnumite kuvamiseks ligipääsu kohalikule hoidlale (local storage). Kohalik hoidla ei ole privaatrežiimis saadaval.';
z.string.et.authBlockedTabs = 'Wire on juba teisel kaardil avatud.';
z.string.et.authBlockedTabsAction = 'Kasuta hoopis seda brauserisakki';

z.string.et.authVerifyAccountAdd = 'Lisa';
z.string.et.authVerifyAccountDetail = 'See võimaldab kasutada Wire’i mitmes seadmes.';
z.string.et.authVerifyAccountHeadline = 'Lisa meiliaadress ja parool.';
z.string.et.authVerifyAccountLogout = 'Logi välja';
z.string.et.authVerifyCodeDescription = 'Sisesta kinnituskood,\nmille saatsime numbrile {{number}}.';
z.string.et.authVerifyCodeResend = 'Kood ei saabu?';
z.string.et.authVerifyCodeResendDetail = 'Saada uuesti';
z.string.et.authVerifyCodeResendTimer = 'Sa võid uue koodi tellida {{expiration}} pärast.';
z.string.et.authVerifyCodeChangePhone = 'Numbri muutmine';
z.string.et.authVerifyPasswordHeadline = 'Sisesta parool';

z.string.et.authLimitDevicesHeadline = 'Seadmed';
z.string.et.authLimitDescription = 'Eemalda üks oma teistest seadmetest, et sellel Wire’i kasutada.';
z.string.et.authLimitButtonManage = 'Seadmete haldus';
z.string.et.authLimitButtonSignOut = 'Logi välja';
z.string.et.authLimitDevicesCurrent = '(Praegune)';

z.string.et.authHistoryHeadline = 'Kasutad sellel seadmel Wire’it esimest korda.';
z.string.et.authHistoryDescription = 'Privaatuse tagamiseks ei ilmu siia sinu varasemad vestlused.';
z.string.et.authHistoryReuseHeadline = 'Oled sellel seadmel juba varem Wire’i kasutanud.';
z.string.et.authHistoryReuseDescription = 'Vahepeal saadetud sõnumid ei ilmu siia.';
z.string.et.authHistoryButton = 'OK';

z.string.et.authPostedResend = 'Saada uuesti aadressile {{email}}';
z.string.et.authPostedResendAction = 'E-kiri ei saabu?';
z.string.et.authPostedResendDetail = 'Kontrolli oma e-postkasti ja järgi kirjas olevaid juhiseid.';
z.string.et.authPostedResendHeadline = 'Sulle tuli kiri.';

z.string.et.authPlaceholderEmail = 'E-post';
z.string.et.authPlaceholderPasswordPut = 'Parool';
z.string.et.authPlaceholderPasswordSet = 'Parool (vähemalt 8 märki)';
z.string.et.authPlaceholderPhone = 'Telefoninumber';

z.string.et.authErrorCode = 'Vigane kood';
z.string.et.authErrorCountryCodeInvalid = 'Vale riigikood';
z.string.et.authErrorEmailExists = 'E-posti aadress on juba kasutusel';
z.string.et.authErrorEmailForbidden = 'Vabandust. See e-posti aadress on keelatud.';
z.string.et.authErrorEmailMalformed = 'Palun sisesta korrektne e-posti aadress.';
z.string.et.authErrorEmailMissing = 'Palun sisesta e-posti aadress.';
z.string.et.authErrorMisc = 'Probleemid ühendusega. Palun proovi uuesti.';
z.string.et.authErrorNameShort = 'Sisesta vähemalt 2-täheline nimi';
z.string.et.authErrorOffline = 'Internetiühendus puudub';
z.string.et.authErrorPasswordShort = 'Vali vähemalt 8-täheline parool.';
z.string.et.authErrorPasswordWrong = 'Vale parool. Palun proovi uuesti.';
z.string.et.authErrorPending = 'Konto pole veel kinnitatud';
z.string.et.authErrorPhoneNumberBudget = 'Sa logisid liiga tihti sisse. Proovi hiljem uuesti.';
z.string.et.authErrorPhoneNumberForbidden = 'Vabandust. See telefoninumber on keelatud.';
z.string.et.authErrorPhoneNumberInvalid = 'Sobimatu telefoninumber';
z.string.et.authErrorPhoneNumberUnknown = 'Tundmatu telefoninumber';
z.string.et.authErrorSuspended = 'See konto ei ole enam sisse logimiseks autoriseeritud.';
z.string.et.authErrorSignIn = 'Palun kinnita oma andmeid ja proovi uuesti.';

z.string.et.callStateOutgoing = 'Heliseb…';
z.string.et.callStateConnecting = 'Ühendan…';
z.string.et.callStateIncoming = 'Helistab…';
z.string.et.callStateIncomingGroup = '{{user}} helistab';
z.string.et.callDecline = 'Keeldu';
z.string.et.callAccept = 'Nõustu';
z.string.et.callJoin = 'Liitu';
z.string.et.callChooseSharedScreen = 'Vali ekraan, mida jagada';
z.string.et.callParticipants = '{{number}} kõnes';
z.string.et.callNoCameraAccess = 'Kaamera ligipääs puudub';

z.string.et.videoCallOverlayFitVideoLabel = 'Topeltklõpsa, et mahutada video ekraanialasse';
z.string.et.videoCallOverlayConversations = 'Vestlused';
z.string.et.videoCallOverlayMute = 'Vaigista vestlus';
z.string.et.videoCallOverlayVideo = 'Video';
z.string.et.videoCallOverlayShareScreen = 'Jaga ekraani';
z.string.et.videoCallOverlayHangUp = 'Lõpeta kõne';
z.string.et.videoCallPaused = 'Video pausil';
z.string.et.videoCallScreenShareNotSupported = 'Sinu brauser ei toeta ekraanijagamist';

z.string.et.modalAcknowledgeAction = 'Ok';
z.string.et.modalAcknowledgeHeadline = 'Midagi läks valesti';
z.string.et.modalConfirmSecondary = 'Tühista';
z.string.et.modalOptionSecondary = 'Tühista';

z.string.et.modalAccountCreateAction = 'OK';
z.string.et.modalAccountCreateHeadline = 'Loo konto?';
z.string.et.modalAccountCreateMessage = 'Konto luues kaotad vestluste ajaloo siin külalistetoas.';

z.string.et.modalAccountDeletionAction = 'Kustuta';
z.string.et.modalAccountDeletionHeadline = 'Kustuta konto';
z.string.et.modalAccountDeletionMessage = 'Me saadame sõnumi e-posti või SMSi kaudu. Järgi linki, et püsivalt oma konto kustutada.';

z.string.et.modalAccountLeaveGuestRoomAction = 'Lahku';
z.string.et.modalAccountLeaveGuestRoomHeadline = 'Lahkud külalistetoast?';
z.string.et.modalAccountLeaveGuestRoomMessage = 'Vestluse ajalugu kustutatakse. Edaspidi ajaloo säilitamiseks registreeri endale konto.';

z.string.et.modalAccountLogoutAction = 'Logi välja';
z.string.et.modalAccountLogoutHeadline = 'Tühjendad andmed?';
z.string.et.modalAccountLogoutOption = 'Kustuta kõik isikuandmed ja vestlused sellest seadmest.';

z.string.et.modalAccountNewDevicesSecondary = 'Seadmete haldus';
z.string.et.modalAccountNewDevicesHeadline = 'Sinu kontot kasutati:';
z.string.et.modalAccountNewDevicesFrom = 'Kohast:';
z.string.et.modalAccountNewDevicesMessage = 'Kui sina seda ei teinud, eemalda seade ja lähtesta oma parool.';

z.string.et.modalAccountRemoveDeviceAction = 'Eemalda seade';
z.string.et.modalAccountRemoveDeviceHeadline = 'Eemalda "{{device}}"';
z.string.et.modalAccountRemoveDeviceMessage = 'Seadme eemaldamiseks pead sisestama parooli.';
z.string.et.modalAccountRemoveDevicePlaceholder = 'Parool';

z.string.et.modalAssetTooLargeHeadline = 'Liiga suur fail';
z.string.et.modalAssetTooLargeMessage = 'Sa saad saata faile kuni {{number}}';

z.string.et.modalAssetParallelUploadsHeadline = 'Liiga palju faile korraga';
z.string.et.modalAssetParallelUploadsMessage = 'Sa saad ühekorraga saata kuni {{number}} faili.';

z.string.et.modalCallEmptyConversationHeadline = 'Pole kellelegi helistada';
z.string.et.modalCallEmptyConversationMessage = 'Siia pole kedagi jäänud.';

z.string.et.modalCallEmptyLogHeadline = 'Kõned puuduvad';
z.string.et.modalCallEmptyLogMessage = 'Kõned puuduvad, vearaporti saatmine pole võimalik.';

z.string.et.modalCallNoGroupVideoHeadline = 'Videokõnesid ei saa teha gruppides';
z.string.et.modalCallNoGroupVideoMessage = 'Videokõned pole saadaval grupivestlustes.';

z.string.et.modalCallNoMicrophoneAction = 'Ütle, kuidas';
z.string.et.modalCallNoMicrophoneMessage = 'Sinu brauser vajab mikrofonile juurdepääsu kõnede tegemiseks.';
z.string.et.modalCallNoMicrophoneHeadline = 'Mikrofonita ei saa helistada';

z.string.et.modalCallSecondIncomingAction = 'Vasta';
z.string.et.modalCallSecondIncomingHeadline = 'Vasta?';
z.string.et.modalCallSecondIncomingMessage = 'Käimasolev kõne lõpeb.';

z.string.et.modalCallSecondOngoingAction = 'Lõpeta kõne';
z.string.et.modalCallSecondOngoingHeadline = 'Lõpetad teises seadmes kõne?';
z.string.et.modalCallSecondOngoingMessage = 'Sa saad olla korraga ainult ühes kõnes.';

z.string.et.modalCallSecondOutgoingAction = 'Lõpeta kõne';
z.string.et.modalCallSecondOutgoingHeadline = 'Lõpetad käimasoleva kõne?';
z.string.et.modalCallSecondOutgoingMessage = 'Sa saad olla korraga ainult ühes kõnes.';

z.string.et.modalConnectCancelAction = 'Jah';
z.string.et.modalConnectCancelHeadline = 'Tühistad kontaktisoov?';
z.string.et.modalConnectCancelMessage = 'Eemalda ühenduse taotlus kasutajale {{user}}.';
z.string.et.modalConnectCancelSecondary = 'Ei';

z.string.et.modalConnectAcceptAction = 'Ühendu';
z.string.et.modalConnectAcceptHeadline = 'Nõustud?';
z.string.et.modalConnectAcceptMessage = 'See ühendab teid ja avab vestluse kasutajaga {{user}}.';
z.string.et.modalConnectAcceptSecondary = 'Ignoreeri';

z.string.et.modalConversationClearAction = 'Kustuta';
z.string.et.modalConversationClearHeadline = 'Kustuta sisu?';
z.string.et.modalConversationClearMessage = 'See kustutab vestluse ajaloo kõigis seadmetes.';
z.string.et.modalConversationClearOption = 'Lahku samuti vestlusest';

z.string.et.modalConversationDeleteMessageAction = 'Kustuta';
z.string.et.modalConversationDeleteMessageHeadline = 'Kustuta ainult minu jaoks?';
z.string.et.modalConversationDeleteMessageMessage = 'Seda ei saa tagasi võtta.';

z.string.et.modalConversationDeleteMessageEveryoneAction = 'Kustuta';
z.string.et.modalConversationDeleteMessageEveryoneHeadline = 'Kustuta kõigi jaoks?';
z.string.et.modalConversationDeleteMessageEveryoneMessage = 'Seda ei saa tagasi võtta.';

z.string.et.modalConversationLeaveAction = 'Lahku';
z.string.et.modalConversationLeaveHeadline = 'Lahkud vestlusest {{name}}?';
z.string.et.modalConversationLeaveMessage = 'Sa ei saa selles vestluses sõnumeid saata ega vastu võtta.';

z.string.et.modalConversationMessageTooLongHeadline = 'Sõnum on liiga pikk';
z.string.et.modalConversationMessageTooLongMessage = 'Sa saad saata sõnumeid, mis on kuni {{number}} tähemärki pikad.';

z.string.et.modalConversationNewDeviceAction = 'Saada siiski';
z.string.et.modalConversationNewDeviceHeadlineOne = '{{user}} hakkas uut seadet kasutama';
z.string.et.modalConversationNewDeviceHeadlineMany = '{{users}} hakkasid uusi seadmeid kasutama';
z.string.et.modalConversationNewDeviceHeadlineYou = '{{user}} hakkasid uut seadet kasutama';
z.string.et.modalConversationNewDeviceIncomingCallAction = 'Võta kõne vastu';
z.string.et.modalConversationNewDeviceIncomingCallMessage = 'Kas sa soovid siiski kõne vastu võtta?';
z.string.et.modalConversationNewDeviceMessage = 'Kas tahad ikka seda sõnumit saata?';
z.string.et.modalConversationNewDeviceOutgoingCallAction = 'Helista siiski';
z.string.et.modalConversationNewDeviceOutgoingCallMessage = 'Kas sa soovid siiski kõne teha?';

z.string.et.modalConversationNotConnectedHeadline = 'Kedagi pole vestlusse veel lisatud';
z.string.et.modalConversationNotConnectedMessageOne = '{{name}} ei soovi vestlustega liituda.';
z.string.et.modalConversationNotConnectedMessageMany = 'Üks valitud inimestest ei soovi vestlustega liituda.';

z.string.et.modalConversationRemoveAction = 'Eemalda';
z.string.et.modalConversationRemoveHeadline = 'Eemaldad?';
z.string.et.modalConversationRemoveMessage = '{{user}} ei saa siin vestluses sõnumeid saata ega vastu võtta.';

z.string.et.modalConversationRemoveGuestsAction = 'Eemalda külalised';
z.string.et.modalConversationRemoveGuestsHeadline = 'Lülitad välja külaliste juurdepääsu?';
z.string.et.modalConversationRemoveGuestsMessage = 'Praegune külaline eemaldatakse vestlusest. Uusi külalisi ei lubata.';

z.string.et.modalConversationRevokeLinkAction = 'Tühista link';
z.string.et.modalConversationRevokeLinkHeadline = 'Tühistad lingi?';
z.string.et.modalConversationRevokeLinkMessage = 'Uued külalised ei saa selle lingi abil liituda. Praegustel külalistel on jätkuvalt ligipääs.';

z.string.et.modalConversationGuestOptionsAllowGuestMessage = 'Külaliste lubamine ebaõnnestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsDisableGuestMessage = 'Külaliste eemaldamine ebaõnnestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsGetCodeMessage = 'Ligipääsulinki ei saadud.';
z.string.et.modalConversationGuestOptionsRequestCodeMessage = 'Ligipääsulingi taotlemine ebaõnnestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsRevokeCodeMessage = 'Ligipääsulingi tühistamine ebaõnnestus. Palun proovi uuesti.';
z.string.et.modalConversationGuestOptionsToggleGuestsMessage = 'Külaliste oleku muutumine ebaõnnestus.';

z.string.et.modalConversationTooManyMembersHeadline = 'Täismaja';
z.string.et.modalConversationTooManyMembersMessage = 'Vestlusega saavad liituda kuni {{number1}} inimest. Hetkel on ruumi veel {{number2}} inimesele.';

z.string.et.modalGifTooLargeHeadline = 'Valitud animatsioon on liiga suur';
z.string.et.modalGifTooLargeMessage = 'Maksimaalne suurus on {{number}} MB.';

z.string.et.modalIntegrationUnavailableHeadline = 'Integratsioonide tugi puudub';
z.string.et.modalIntegrationUnavailableMessage = 'Aitäh, et integratsioonide vastu huvi tunned. Ajutiselt vestlused integratsioone ei toeta.';

z.string.et.modalPictureFileFormatHeadline = 'Seda pilti ei saa kasutada';
z.string.et.modalPictureFileFormatMessage = 'Palun vali PNG või JPEG fail.';

z.string.et.modalPictureTooLargeHeadline = 'Valitud pilt on liiga suur';
z.string.et.modalPictureTooLargeMessage = 'Sa saad kasutada pilte suurusega kuni {{number}} MB.';

z.string.et.modalPictureTooSmallHeadline = 'Pilt on liiga väike';
z.string.et.modalPictureTooSmallMessage = 'Palun vali pilt, mis on vähemalt 320 x 320 px suur.';

z.string.et.modalImproveWireAction = 'Nõustu';
z.string.et.modalImproveWireSecondary = 'Mitte praegu';
z.string.et.modalImproveWireHeadline = 'Aita meil muuta Wire’i paremaks';
z.string.et.modalImproveWireMessage = 'Anonüümsete kasutus- ja krahhiaruannete saatmine aitab meil oma tooteid ja teenuseid parandada. Me ei kasuta seda infot mitte millegi muu jaoks.';

z.string.et.modalServiceUnavailableHeadline = 'Teenuse lisamine pole võimalik';
z.string.et.modalServiceUnavailableMessage = 'Teenus pole hetkel saadaval.';

z.string.et.modalSessionResetHeadline = 'Sessioon on lähtestatud';
z.string.et.modalSessionResetMessage1 = 'Kui probleem ei lahene,';
z.string.et.modalSessionResetMessageLink = 'kontakteeru';
z.string.et.modalSessionResetMessage2 = 'meiega.';

z.string.et.modalUploadContactsAction = 'Proovi uuesti';
z.string.et.modalUploadContactsMessage = 'Me ei saanud sinu infot kätte. Palun proovi uuesti kontakte importida.';

z.string.et.modalUserBlockAction = 'Blokeeri';
z.string.et.modalUserBlockHeadline = 'Blokeerid kasutaja {{user}}?';
z.string.et.modalUserBlockMessage = '{{user}} ei saa sulle sõnumeid saata ega sind grupivestlustesse lisada.';

z.string.et.modalUserUnblockAction = 'Eemalda blokeering';
z.string.et.modalUserUnblockHeadline = 'Eemaldad blokeeringu?';
z.string.et.modalUserUnblockMessage = '{{user}} saab sinuga uuesti ühendust võtta ja sind grupivestlustesse lisada.';

z.string.et.modalNoCameraTitle = 'Kaamera ligipääs puudub';
z.string.et.modalNoCameraMessage = 'Wire ei saa kaamerale ligi.[br][faqLink]Loe seda tugiartiklit[/faqLink] et parandada see probleem.';

z.string.et.connectionRequestConnect = 'Ühendu';
z.string.et.connectionRequestIgnore = 'Ignoreeri';

z.string.et.conversationGuestIndicator = 'Külaline';
z.string.et.userRemainingTimeHours = '{{time}}h jäänud';
z.string.et.userRemainingTimeMinutes = 'Alla {{time}}m jäänud';

z.string.et.conversationYouNominative = 'sina';
z.string.et.conversationYouDative = 'sina';
z.string.et.conversationYouAccusative = 'sina';

z.string.et.conversationConnectionAccepted = 'Ühendatud';
z.string.et.conversationConnectionBlocked = 'Blokeeritud';
z.string.et.conversationConnectionCancelRequest = 'Tühista ühendussoov';
z.string.et.conversationCreateTemporary = 'Sina liitusid vestlusega';
z.string.et.conversationCreateWith = ' koos {{users}}';
z.string.et.conversationDeviceStartedUsingOne = ' hakkas kasutama';
z.string.et.conversationDeviceStartedUsingMany = ' hakkas kasutama';
z.string.et.conversationDeviceUnverified = ' eemaldasid kinnituse ühel';
z.string.et.conversationDeviceYourDevices = ' oma seadmetest';
z.string.et.conversationDeviceUserDevices = ' kasutaja {{user}} seadmed';
z.string.et.conversationDeviceNewDeviceOne = ' uus seade';
z.string.et.conversationDeviceNewDeviceMany = ' uut seadet';
z.string.et.conversationDeviceNewPeopleJoined = 'Uued inimesed liitusid.';
z.string.et.conversationDeviceNewPeopleJoinedVerify = ' kinnita seadmed';
z.string.et.conversationJustNow = 'Just nüüd';
z.string.et.conversationLocationLink = 'Ava kaart';
z.string.et.conversationCreated = '[bold]{{name}}[/bold] alustas vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreatedMore = '[bold]{{name}}[/bold] alustas vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreatedName = '[bold]{{name}}[/bold] alustas vestlust';
z.string.et.conversationCreatedNameYou = '[bold]Sina[/bold] alustasid vestlust';
z.string.et.conversationCreatedYou = 'Sina alustasid vestlust kasutajatega {{users}}';
z.string.et.conversationCreatedYouMore = 'Sina alustasid vestlust kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreateWithMore = 'kasutajate {{users}} ja [showmore]{{count}} teisega[/showmore]';
z.string.et.conversationCreateTeam = '[showmore]kõikide meeskonnaliikmetega[/showmore]';
z.string.et.conversationCreateTeamGuest = '[showmore]kõikide meeskonnaliikmete ja ühe külalisega[/showmore]';
z.string.et.conversationCreateTeamGuests = '[showmore]kõikide meeskonnaliikmete ja {{count}} külalisega[/showmore]';
z.string.et.conversationMemberJoined = '[bold]{{name}}[/bold] lisas vestlusesse {{users}}';
z.string.et.conversationMemberJoinedYou = '[bold]Sina[/bold] lisasid vestlusesse {{users}}';
z.string.et.conversationMemberJoinedMore = '[bold]{{name}}[/bold] lisas vestlusesse {{users}} ja [showmore]{{count}} teist[/showmore]';
z.string.et.conversationMemberJoinedYouMore = '[bold]Sina[/bold] lisasid vestlusesse {{users}} ja [showmore]{{count}} teist[/showmore]';
z.string.et.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] liitus';
z.string.et.conversationMemberJoinedSelfYou = '[bold]Sina[/bold] liitusid';
z.string.et.conversationMemberLeft = '[bold]{{name}}[/bold] lahkus';
z.string.et.conversationMemberLeftYou = '[bold]Sina[/bold] lahkusid';
z.string.et.conversationMemberRemoved = '[bold]{{name}}[/bold] eemaldas {{users}}';
z.string.et.conversationMemberRemovedYou = '[bold]Sina[/bold] eemaldasid {{users}}';
z.string.et.conversationTeamLeft = '[bold]{{name}}[/bold] eemaldati meeskonnast';
z.string.et.conversationMessageDelivered = 'Kohale toimetatud';
z.string.et.conversationRename = ' nimetas vestluse ümber';
z.string.et.conversationRenameYou = ' nimetasid vestluse ümber';
z.string.et.conversationUpdatedTimer = ' määras sõnumi taimeriks {{time}}';
z.string.et.conversationUpdatedTimerYou = ' määras sõnumi taimeriks {{time}}';
z.string.et.conversationResetTimer = ' lülitas sõnumi taimeri välja';
z.string.et.conversationResetTimerYou = ' lülitas sõnumi taimeri välja';
z.string.et.conversationResume = 'Alusta vestlust kasutajatega {{users}}';
z.string.et.conversationPing = ' pingis';
z.string.et.conversationPingYou = ' pingisid';
z.string.et.conversationToday = 'täna';
z.string.et.conversationVoiceChannelDeactivate = ' helistas';
z.string.et.conversationVoiceChannelDeactivateYou = ' helistasid';
z.string.et.conversationYesterday = 'Eile';
z.string.et.conversationUnableToDecrypt1 = 'sõnumit kasutajalt {{user}} ei võetud vastu.';
z.string.et.conversationUnableToDecrypt2 = 'Kasutaja {{user}} seadme identiteet muutus. Sõnumit ei saadetud.';
z.string.et.conversationUnableToDecryptLink = 'Miks?';
z.string.et.conversationUnableToDecryptErrorMessage = 'Viga';
z.string.et.conversationUnableToDecryptResetSession = 'Lähtesta seanss';
z.string.et.conversationMissedMessages = 'Sa ei ole seda seadet mõnda aega kasutanud. Osad sõnumid ei pruugi siia ilmuda.';
z.string.et.conversationAssetUploading = 'Üleslaadimine…';
z.string.et.conversationAssetDownloading = 'Allalaadimine…';
z.string.et.conversationAssetUploadFailed = 'Üleslaadimine ebaõnnestus';
z.string.et.conversationPlaybackError = 'Ei saa esitada';
z.string.et.conversationContextMenuCopy = 'Kopeeri';
z.string.et.conversationContextMenuEdit = 'Muuda';
z.string.et.conversationContextMenuDelete = 'Kustuta minu jaoks';
z.string.et.conversationContextMenuDeleteEveryone = 'Kustuta kõigi jaoks…';
z.string.et.conversationContextMenuDownload = 'Laadi alla';
z.string.et.conversationContextMenuLike = 'Meeldib';
z.string.et.conversationContextMenuReply = 'Vasta';
z.string.et.conversationContextMenuUnlike = 'Eemalda meeldimine';
z.string.et.conversationDeleteTimestamp = 'Kustutati kuupäeval {{date}}';
z.string.et.conversationEditTimestamp = 'Muudeti kuupäeval {{date}}';
z.string.et.conversationLikesCaption = '{{number}} inimest';
z.string.et.conversationSendPastedFile = 'Kleepis pildi kuupäeval {{date}}';
z.string.et.conversationSomeone = 'Keegi';
z.string.et.conversationTweetAuthor = ' Twitteris';
z.string.et.conversationServicesWarning = 'Teenustel on ligipääs selle vestluse sisule';

z.string.et.groupCreationPreferencesAction = 'Järgmine';
z.string.et.groupCreationPreferencesErrorNameShort = 'Vähemalt 1 tähemärk';
z.string.et.groupCreationPreferencesErrorNameLong = 'Liiga palju tähemärke';
z.string.et.groupCreationPreferencesHeader = 'Uus grupp';
z.string.et.groupCreationPreferencesPlaceholder = 'Grupi nimi';
z.string.et.groupCreationParticipantsActionCreate = 'Valmis';
z.string.et.groupCreationParticipantsActionSkip = 'Jäta vahele';
z.string.et.groupCreationParticipantsHeader = 'Lisa inimesi';
z.string.et.groupCreationParticipantsHeaderWithCounter = 'Lisa inimesi ({{number}})';
z.string.et.groupCreationParticipantsPlaceholder = 'Otsi nime järgi';
z.string.et.groupSizeInfo = 'Grupivestlusega saab liituda kuni {{count}} inimest. Videokõned töötavad kuni 4 osalejaga grupis.';

z.string.et.guestRoomConversationName = 'Külalistetuba';
z.string.et.guestRoomToggleName = 'Luba külalisi';
z.string.et.guestRoomToggleInfo = 'Ava see vestlus meeskonnast väljas olevatele inimestele.';
z.string.et.guestRoomToggleInfoExtended = 'Ava see vestlus meeskonnast väljas olevatele inimestele. Sa saad seda alati hiljem muuta.';

z.string.et.guestRoomConversationBadge = 'Kohal on külalisi';
z.string.et.guestRoomConversationBadgeService = 'Kohal on teenuseid';
z.string.et.guestRoomConversationBadgeGuestAndService = 'Kohal on külalisi ja teenuseid';

z.string.et.guestRoomConversationHead = 'Inimesed väljaspool sinu meeskonda saavad liituda selle vestlusega.';
z.string.et.guestRoomConversationButton = 'Kutsu inimesi';

z.string.et.collectionShowAll = 'Kuva kõik {{number}}';
z.string.et.collectionSectionLinks = 'Lingid';
z.string.et.collectionSectionImages = 'Pildid';
z.string.et.collectionSectionFiles = 'Failid';
z.string.et.collectionSectionAudio = 'Helisõnumid';

z.string.et.fullsearchPlaceholder = 'Otsi tekstsõnumeid';
z.string.et.fullsearchNoResults = 'Tulemusi ei leitud.';

z.string.et.archiveHeader = 'Arhiveeri';

z.string.et.conversationsAllArchived = 'Kõik on arhiveeritud';
z.string.et.conversationsContacts = 'Kontaktid';
z.string.et.conversationsConnectionRequestMany = '{{number}} inimest ootel';
z.string.et.conversationsConnectionRequestOne = '1 inimene on ootel';
z.string.et.conversationsEmptyConversation = 'Grupivestlus';
z.string.et.conversationsNoConversations = 'Alusta vestlust või loo grupp.';
z.string.et.conversationsPopoverArchive = 'Arhiveeri vestlus';
z.string.et.conversationsPopoverBlock = 'Blokeeri kontakt…';
z.string.et.conversationsPopoverCancel = 'Tühista taotlus…';
z.string.et.conversationsPopoverClear = 'Kustuta sisu…';
z.string.et.conversationsPopoverLeave = 'Lahku grupist…';
z.string.et.conversationsPopoverNotificationSettings = 'Teated…';
z.string.et.conversationsPopoverNotify = 'Eemalda vestluse vaigistus';
z.string.et.conversationsPopoverSilence = 'Vaigista vestlus';
z.string.et.conversationsPopoverUnarchive = 'Taasta vestlus arhiivist';

z.string.et.conversationsSecondaryLineEphemeralMention = 'Mainis sind';
z.string.et.conversationsSecondaryLineEphemeralMentionGroup = 'Keegi mainis sind';
z.string.et.conversationsSecondaryLineEphemeralMessage = 'Saatis sulle sõnumi';
z.string.et.conversationsSecondaryLineEphemeralMessageGroup = 'Keegi saatis sõnumi';
z.string.et.conversationsSecondaryLineEphemeralReply = 'Vastas sulle';
z.string.et.conversationsSecondaryLineEphemeralReplyGroup = 'Keegi vastas sulle';
z.string.et.conversationsSecondaryLineIncomingCall = '{{user}} helistab';
z.string.et.conversationsSecondaryLinePeopleLeft = '{{number}} inimest lahkusid';
z.string.et.conversationsSecondaryLinePersonLeft = '{{user}} lahkus';
z.string.et.conversationsSecondaryLinePersonRemoved = '{{user}} eemaldati';
z.string.et.conversationsSecondaryLinePersonRemovedTeam = '{{user}} eemaldati meeskonnast';
z.string.et.conversationsSecondaryLinePeopleAdded = '{{user}} inimest lisati';
z.string.et.conversationsSecondaryLinePersonAdded = '{{user}} lisati';
z.string.et.conversationsSecondaryLinePersonAddedSelf = '{{user}} liitus';
z.string.et.conversationsSecondaryLinePersonAddedYou = '{{user}} lisas sind';
z.string.et.conversationsSecondaryLineRenamed = '{{user}} nimetas vestluse ümber';
z.string.et.conversationsSecondaryLineSummaryMessage = '{{number}} sõnum';
z.string.et.conversationsSecondaryLineSummaryMessages = '{{number}} sõnumit';
z.string.et.conversationsSecondaryLineSummaryMention = '{{number}} mainimine';
z.string.et.conversationsSecondaryLineSummaryMentions = '{{number}} mainimist';
z.string.et.conversationsSecondaryLineSummaryMissedCall = '{{number}} vastamata kõne';
z.string.et.conversationsSecondaryLineSummaryMissedCalls = '{{number}} vastamata kõnet';
z.string.et.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.et.conversationsSecondaryLineSummaryPings = '{{number}} pingi'
z.string.et.conversationsSecondaryLineSummaryReply = '{{number}} vastus';
z.string.et.conversationsSecondaryLineSummaryReplies = '{{number}} vastust';
z.string.et.conversationsSecondaryLineYouLeft = 'Sina lahkusid';
z.string.et.conversationsSecondaryLineYouWereRemoved = 'Sind eemaldati vestlusest';

z.string.et.takeoverSub = 'Haara oma unikaalne nimi Wire’is.';
z.string.et.takeoverLink = 'Loe lähemalt';
z.string.et.takeoverButtonChoose = 'Vali enda oma';
z.string.et.takeoverButtonKeep = 'Vali see sama';

z.string.et.inviteMetaKeyMac = 'Cmd';
z.string.et.inviteMetaKeyPc = 'Ctrl';
z.string.et.inviteHintSelected = 'Kopeerimiseks vajuta {{metaKey}} + C';
z.string.et.inviteHintUnselected = 'Vali ja vajuta {{metaKey}} + C';
z.string.et.inviteHeadline = 'Kutsu inimesi Wire’iga liituma';
z.string.et.inviteMessage = 'Kasutan suhtlemiseks Wire äppi. Mu kasutajanimi on {{username}}. Tõmba äpp siit get.wire.com';
z.string.et.inviteMessageNoEmail = 'Kasutan suhtluseks Wire äppi. Külasta get.wire.com et minuga suhelda.';

z.string.et.extensionsBubbleButtonGif = 'Gif';

z.string.et.extensionsGiphyButtonOk = 'Saada';
z.string.et.extensionsGiphyButtonMore = 'Proovi järgmist';
z.string.et.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.et.extensionsGiphyNoGifs = 'Ups, gif-e pole';
z.string.et.extensionsGiphyRandom = 'Juhuslik';

z.string.et.addParticipantsConfirmLabel = 'Lisa';
z.string.et.addParticipantsHeader = 'Lisa inimesi';
z.string.et.addParticipantsHeaderWithCounter = 'Lisa inimesi ({{number}})';
z.string.et.addParticipantsManageServices = 'Halda teenuseid';
z.string.et.addParticipantsManageServicesNoResults = 'Halda teenuseid';
z.string.et.addParticipantsNoServicesManager = 'Teenused on abistajad, mis võivad aidata sul töid teha.';
z.string.et.addParticipantsNoServicesMember = 'Teenused on abistajad, mis võivad aidata sul töid teha. Nende lubamiseks küsi oma administraatorilt.';
z.string.et.addParticipantsSearchPlaceholder = 'Otsi nime järgi';
z.string.et.addParticipantsServiceConfirmButton = 'Lisa teenus';
z.string.et.addParticipantsTabsPeople = 'Inimesed';
z.string.et.addParticipantsTabsServices = 'Teenused';

z.string.et.conversationDetailsActionArchive = 'Arhiveeri vestlus';
z.string.et.conversationDetailsActionAddParticipants = 'Lisa osalejaid';
z.string.et.conversationDetailsActionBlock = 'Blokeeri kontakt';
z.string.et.conversationDetailsActionCancelRequest = 'Tühista taotlus…';
z.string.et.conversationDetailsActionClear = 'Kustuta sisu';
z.string.et.conversationDetailsActionConversationParticipants = 'Kuva kõik ({{number}})';
z.string.et.conversationDetailsActionCreateGroup = 'Uus grupp';
z.string.et.conversationDetailsActionDevices = 'Seadmed';
z.string.et.conversationDetailsActionGuestOptions = 'Külaliste valikud';
z.string.et.conversationDetailsActionTimedMessages = 'Kustuvad sõnumid';
z.string.et.conversationDetailsActionNotifications = 'Teated';
z.string.et.conversationDetailsActionLeave = 'Lahku grupist';
z.string.et.conversationDetailsGuestsOff = 'Väljas';
z.string.et.conversationDetailsGuestsOn = 'Sees';
z.string.et.conversationDetailsOptions = 'Valikud';
z.string.et.conversationDetailsParticipantsServicesOne = 'Teenus';
z.string.et.conversationDetailsParticipantsServicesMany = 'Teenused';
z.string.et.conversationDetailsParticipantsUsersOne = 'Inimene';
z.string.et.conversationDetailsParticipantsUsersMany = 'Inimesed';
z.string.et.conversationDetailsPeople = 'Inimesed';
z.string.et.conversationDetailsServices = 'Teenused';

z.string.et.conversationParticipantsTitle = 'Inimesed';
z.string.et.conversationParticipantsSearchPlaceholder = 'Otsi nime järgi';

z.string.et.groupParticipantActionBlock = 'Blokeeri kontakt…';
z.string.et.groupParticipantActionCancelRequest = 'Tühista taotlus…';
z.string.et.groupParticipantActionDevices = 'Seadmed';
z.string.et.groupParticipantActionIgnoreRequest = 'Ignoreeri taotlust';
z.string.et.groupParticipantActionIncomingRequest = 'Nõustu taotlusega';
z.string.et.groupParticipantActionLeave = 'Lahku grupist…';
z.string.et.groupParticipantActionOpenConversation = 'Ava vestlus';
z.string.et.groupParticipantActionPending = 'Ootel';
z.string.et.groupParticipantActionRemove = 'Eemalda grupist';
z.string.et.groupParticipantActionSelfProfile = 'Ava profiil';
z.string.et.groupParticipantActionSendRequest = 'Ühendu';
z.string.et.groupParticipantActionUnblock = 'Tühista kontakti blokeering';

z.string.et.guestOptionsCopyLink = 'Kopeeri link';
z.string.et.guestOptionsCopyLinkDone = 'Link kopeeritud!';
z.string.et.guestOptionsCreateLink = 'Loo link';
z.string.et.guestOptionsInfoHeader = 'Kutsu teisi lingi abil';
z.string.et.guestOptionsInfoText = 'Igaüks saab liituda selle lingiga vestlusesse 24 tunniks, isegi kui neil pole Wire’i.';
z.string.et.guestOptionsRevokeLink = 'Tühista link';
z.string.et.guestOptionsTitle = 'Külaliste valikud';

z.string.et.notificationSettingsTitle = 'Teated';
z.string.et.notificationSettingsDisclaimer = 'Sind teavitatakse kõigest (s.h. hääl- ja videokõned) või ainult siis, kui sind mainitakse.';
z.string.et.notificationSettingsEverything = 'Kõik';
z.string.et.notificationSettingsMentionsAndReplies = 'Mainimised ja vastused';
z.string.et.notificationSettingsNothing = 'Puuduvad';

z.string.et.timedMessagesTitle = 'Kustuvad sõnumid';
z.string.et.timedMessageDisclaimer = 'Kustuvad sõnumid lülitatatakse kõikide osalejate jaoks sisse selles vestluses.';

z.string.et.participantDevicesDetailHeadline = 'Veendu, et see vastab {{html1}}kasutaja {{user}} seadmel{{html2}} kuvatud sõrmejäljele.';
z.string.et.participantDevicesDetailHowTo = 'Kuidas ma seda teen?';
z.string.et.participantDevicesDetailResetSession = 'Lähtesta seanss';
z.string.et.participantDevicesDetailShowMyDevice = 'Näita mu seadme sõrmejälge';
z.string.et.participantDevicesDetailVerify = 'Kinnitatud';

z.string.et.participantDevicesHeader = 'Seadmed';
z.string.et.participantDevicesHeadline = 'Wire annab igale seadmele unikaalse sõrmejälje. Võrdle neid kasutajaga {{user}} ja kinnita oma vestlus.';
z.string.et.participantDevicesLearnMore = 'Loe lähemalt';
z.string.et.participantDevicesWhyVerify = 'Miks vestluste turvalisust kontrollida?';
z.string.et.participantDevicesOutdatedClientMessage = '{{user}} kasutab vana Wire’i versiooni. Seadmete kohta puudub info.';

z.string.et.participantDevicesSelfAllDevices = 'Näita kõiki mu seadmeid';
z.string.et.participantDevicesSelfFingerprint = 'Seadme sõrmejälg';

z.string.et.userProfileButtonConnect = 'Ühendu';
z.string.et.userProfileButtonIgnore = 'Ignoreeri';
z.string.et.userProfileButtonUnblock = 'Eemalda blokeering';

z.string.et.preferencesAbout = 'Teave';
z.string.et.preferencesAccount = 'Konto';
z.string.et.preferencesAV = 'Audio/video';
z.string.et.preferencesDeviceDetails = 'Seadme üksikasjad';
z.string.et.preferencesDevices = 'Seadmed';
z.string.et.preferencesHeadline = 'Eelistused';
z.string.et.preferencesOptions = 'Valikud';

z.string.et.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.et.preferencesAboutPrivacyPolicy = 'Privaatsuspoliitika';
z.string.et.preferencesAboutSupport = 'Klienditugi';
z.string.et.preferencesAboutSupportWebsite = 'Kasutajatoe veebisait';
z.string.et.preferencesAboutSupportContact = 'Võta kasutajatoega ühendust';
z.string.et.preferencesAboutTermsOfUse = 'Kasutustingimused';
z.string.et.preferencesAboutVersion = 'Versioon {{version}}';
z.string.et.preferencesAboutWebsite = 'Wire’i koduleht';

z.string.et.preferencesAccountAvaibilityUnset = 'Sea olek';
z.string.et.preferencesAccountCreateTeam = 'Loo meeskond';
z.string.et.preferencesAccountData = 'Andmekasutuse õigused';
z.string.et.preferencesAccountDataCheckbox = 'Saada anonüümseid andmeid';
z.string.et.preferencesAccountDataDetail = 'Aita Wire’i paremaks muuta, saates anonüümseid kasutus- ja krahhiaruandeid.';
z.string.et.preferencesAccountDelete = 'Kustuta konto';
z.string.et.preferencesAccountLeaveGuestRoom = 'Lahku külalistetoast';
z.string.et.preferencesAccountLeaveGuestRoomDescription = 'Sa ei saa enam selle vestluse sõnumitele ligi.';
z.string.et.preferencesAccountLogOut = 'Logi välja';
z.string.et.preferencesAccountManageTeam = 'Meeskonna haldamine';
z.string.et.preferencesAccountMarketingConsentCheckbox = 'Saa uudiskirja';
z.string.et.preferencesAccountMarketingConsentDetail = 'Saa Wire’ilt uudiseid ja tooteuuendusi e-posti teel.';
z.string.et.preferencesAccountResetPassword = 'Lähesta parool';
z.string.et.preferencesAccountTeam = 'vestluses {{name}}';
z.string.et.preferencesAccountUsernamePlaceholder = 'Sinu täisnimi';
z.string.et.preferencesAccountUsernameHint = 'Vähemalt 2 tähemärki. Ainult a-z, 0-9 ja _.';
z.string.et.preferencesAccountUsernameAvailable = 'Saadaval';
z.string.et.preferencesAccountUsernameErrorTaken = 'Juba kasutusel';

z.string.et.preferencesAVCamera = 'Kaamera';
z.string.et.preferencesAVMicrophone = 'Mikrofon';
z.string.et.preferencesAVPermissionDetail = 'Luba oma brauseri Eelistustest';
z.string.et.preferencesAVSpeakers = 'Kõlarid';
z.string.et.preferencesAVTemporaryDisclaimer = 'Külalised ei saa alustada videokonverentse. Vali kasutatav kaamera, kui liitud mõnega.';
z.string.et.preferencesAVNoCamera = 'Wire ei saa kaamerale ligi.[br][faqLink]Loe seda tugiartiklit[/faqLink] et parandada see probleem.';
z.string.et.preferencesAVTryAgain = 'Proovi uuesti';

z.string.et.preferencesDevicesActivatedOn = 'Aktiveeritud kuupäeval {{date}}';
z.string.et.preferencesDevicesActive = 'Aktiivne';
z.string.et.preferencesDevicesActiveDetail = 'Kui sa ei tunne mõnda ülalolevat seadet ära, eemalda see ja lähtesta oma parool.';
z.string.et.preferencesDevicesCurrent = 'Praegune';
z.string.et.preferencesDevicesFingerprint = 'Võtme sõrmejälg';
z.string.et.preferencesDevicesFingerprintDetail = 'Wire annab igale seadmele unikaalse sõrmejälje. Võrdle neid ja kinnita oma seadmed ning vestlused.';
z.string.et.preferencesDevicesId = 'ID: ';
z.string.et.preferencesDevicesRemove = 'Eemalda…';
z.string.et.preferencesDevicesRemoveCancel = 'Tühista';
z.string.et.preferencesDevicesRemoveDetail = 'Eemalda see seade kui oled lõpetanud selle kasutamise. Sind logitakse koheselt seadmest välja.';
z.string.et.preferencesDevicesSessionConfirmation = 'Sessioon on lähtestatud.';
z.string.et.preferencesDevicesSessionDetail = 'Kui sõrmejäljed ei kattu, lähtesta sessioon, et luua mõlemal poolel uued krüpteerimisvõtmed.';
z.string.et.preferencesDevicesSessionReset = 'Lähtesta seanss';
z.string.et.preferencesDevicesSessionOngoing = 'Seansi lähtestamine…';
z.string.et.preferencesDevicesVerification = 'Kinnitatud';

z.string.et.preferencesOptionsAudio = 'Heliteated';
z.string.et.preferencesOptionsAudioAll = 'Kõik';
z.string.et.preferencesOptionsAudioAllDetail = 'Kõik helid';
z.string.et.preferencesOptionsAudioNone = 'Puudub';
z.string.et.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.et.preferencesOptionsAudioSome = 'Mõned';
z.string.et.preferencesOptionsAudioSomeDetail = 'Pingid ja kõned';
z.string.et.preferencesOptionsContacts = 'Kontaktid';
z.string.et.preferencesOptionsContactsGmail = 'Impordi Gmailist';
z.string.et.preferencesOptionsContactsMacos = 'Impordi kontaktidest';
z.string.et.preferencesOptionsContactsDetail = 'Me kasutame su kontakte, et ühendada sind teistega. Me muudame kogu info anonüümseks ja ei jaga seda kellegi teisega.';
z.string.et.preferencesOptionsPopular = 'Publiku nõudmisel';
z.string.et.preferencesOptionsEmojiReplaceCheckbox = 'Asenda kirjutatud emotikonid emojidega';
z.string.et.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.et.preferencesOptionsPreviewsSendCheckbox = 'Loo eelvaateid saadetavatele linkidele';
z.string.et.preferencesOptionsPreviewsSendDetail = 'Eelvaateid võidakse siiski näidata teiste inimeste linkide puhul.';
z.string.et.preferencesOptionsNotifications = 'Teated';
z.string.et.preferencesOptionsNotificationsNone = 'Väljas';
z.string.et.preferencesOptionsNotificationsObfuscate = 'Peida üksikasjad';
z.string.et.preferencesOptionsNotificationsObfuscateMessage = 'Kuva saatjat';
z.string.et.preferencesOptionsNotificationsOn = 'Kuva saatjat ja sõnumit';
z.string.et.preferencesOptionsCallLogs = 'Veaotsing';
z.string.et.preferencesOptionsCallLogsGet = 'Salvesta kõne silumisraport';
z.string.et.preferencesOptionsCallLogsDetail = 'See teave aitab Wire kasutajatoel leida helistamise probleeme.';

z.string.et.preferencesOptionsBackupHeader = 'Ajalugu';
z.string.et.preferencesOptionsBackupExportHeadline = 'Varunda vestlused';
z.string.et.preferencesOptionsBackupExportSecondary = 'Loo varundus, et säilitada oma vestlusajalugu. Sa saad seda kasutada, et taastada ajalugu, kui kaotad oma arvuti või hakkad kasutama uut.\nVarundusfail ei ole kaitstud Wire’i otsast-otsani krüpteeringuga, seega hoia seda turvalises kohas.';
z.string.et.preferencesOptionsBackupImportHeadline = 'Taasta varundusest';
z.string.et.preferencesOptionsBackupImportSecondary = 'Sa saad taastada ajalugu ainult sama platvormi varundusest. Sinu varundus kirjutab üle vestlused, mis sul võivad selles seadmes olla.';

z.string.et.backupExportGenericErrorHeadline = 'Faili ei saanud salvestada';
z.string.et.backupExportGenericErrorSecondary = 'Varundust ei viidud lõpule.';
z.string.et.backupExportProgressHeadline = 'Ettevalmistamine…';
z.string.et.backupExportProgressSecondary = 'Varundamine · {{processed}} / {{total}} — {{progress}}%';
z.string.et.backupExportProgressCompressing = 'Valmistan varundusfaili ette';
z.string.et.backupExportSaveFileAction = 'Salvesta fail';
z.string.et.backupExportSuccessHeadline = 'Varundus valmis';
z.string.et.backupExportSuccessSecondary = 'Sa saad seda kasutada, et taastada ajalugu, kui kaotad oma arvuti või hakkad kasutama uut.';
z.string.et.backupImportGenericErrorHeadline = 'Midagi läks valesti';
z.string.et.backupImportGenericErrorSecondary = 'Sinu ajalugu ei saanud taastada.';
z.string.et.backupImportAccountErrorHeadline = 'Vale varundus';
z.string.et.backupImportAccountErrorSecondary = 'Sa ei saa taastada teise konto ajalugu.';
z.string.et.backupImportVersionErrorHeadline = 'Ühildumatu varundus';
z.string.et.backupImportVersionErrorSecondary = 'See varundus loodi uuema või aegunud Wire’i versiooni kaudu ja seda ei saa siin taastada.';
z.string.et.backupImportIncompatibleErrorHeadline = 'Vale varundus';
z.string.et.backupImportIncompatibleErrorSecondary = 'Sa ei saa taastada teise konto ajalugu.';
z.string.et.backupImportOutdatedErrorHeadline = 'Ühildumatu varundus';
z.string.et.backupImportOutdatedErrorSecondary = 'See varundus loodi uuema või aegunud Wire’i versiooni kaudu ja seda ei saa siin taastada.';
z.string.et.backupImportProgressHeadline = 'Ettevalmistamine…';
z.string.et.backupImportProgressSecondary = 'Taastan ajalugu · {{processed}} / {{total}} — {{progress}}%';
z.string.et.backupImportSuccessHeadline = 'Ajalugu taastatud.';
z.string.et.backupCancel = 'Tühista';
z.string.et.backupTryAgain = 'Proovi uuesti';

z.string.et.searchConnect = 'Ühendu';
z.string.et.searchConnections = 'Ühendused';
z.string.et.searchContacts = 'Kontaktid';
z.string.et.searchCreateGroup = 'Loo grupp';
z.string.et.searchCreateGuestRoom = 'Loo külalistetuba';
z.string.et.searchGroups = 'Grupid';
z.string.et.searchPeople = 'Inimesed';
z.string.et.searchPlaceholder = 'Otsi nime või kasutajanime järgi';
z.string.et.searchServicePlaceholder = 'Otsi nime järgi';
z.string.et.searchServices = 'Teenused';
z.string.et.searchManageServices = 'Halda teenuseid';
z.string.et.searchManageServicesNoResults = 'Halda teenuseid';
z.string.et.searchNoServicesManager = 'Teenused on abistajad, mis võivad aidata sul töid teha.';
z.string.et.searchNoServicesMember = 'Teenused on abistajad, mis võivad aidata sul töid teha. Nende lubamiseks küsi oma administraatorilt.';
z.string.et.searchTeamGroups = 'Meeskonnavestlused';
z.string.et.searchTeamMembers = 'Meeskonnaliikmed';
z.string.et.searchTopPeople = 'Lemmikinimesed';
z.string.et.searchTrySearch = 'Leia inimesi\nnime või kasutajanime järgi';
z.string.et.searchNoContactsOnWire = 'Sul pole Wire’is ühtegi kontakti.\nProovi inimesi leida\nnime või kasutajanime järgi.';
z.string.et.searchMemberInvite = 'Kutsu inimesi meeskonnaga liituma';
z.string.et.searchOthers = 'Ühendu';

z.string.et.searchInvite = 'Kutsu inimesi Wire’iga liituma';
z.string.et.searchInviteDetail = 'Kontaktide jagamine aitab sul teistega ühenduda. Me muudame kogu info anonüümseks ja ei jaga seda kellegi teisega.';
z.string.et.searchInviteButtonContacts = 'Kontaktidest';
z.string.et.searchInviteButtonGmail = 'Gmailist';
z.string.et.searchInviteHeadline = 'Too oma sõbrad';
z.string.et.searchInviteShare = 'Jaga kontakte';

z.string.et.searchServiceConfirmButton = 'Lisa teenus';

z.string.et.searchListEveryoneParticipates = 'Kõik sinu\nkontaktid on juba\nselles vestluses.';
z.string.et.searchListNoMatches = 'Sobivaid tulemusi ei leitud.\nProovi sisestada mõni muu nimi.';

z.string.et.temporaryGuestCta = 'Loo konto';
z.string.et.temporaryGuestDescription = 'Turva oma äri krüptitud grupi sõnumside ja kõnedega.';
z.string.et.temporaryGuestTimeRemaining = ' jäänud siin külalistetoas';

z.string.et.temporaryGuestJoinMessage = 'See vestlus muutub sulle saadavaks 24 tunniks.';
z.string.et.temporaryGuestJoinDescription = 'Kui sa lehe sulged või laadid uuesti, kaotad ligipääsu.';

z.string.et.temporaryGuestLeaveMessage = ' pole enam selles vestluses.';
z.string.et.temporaryGuestLeaveDescription = 'Kui sa lehe sulged või laadid uuesti, kaotad ligipääsu vestlusajaloole.';

z.string.et.uploadGoogleHeadline = 'Otsi inimesi\nkellega rääkida.';
z.string.et.uploadGoogleMessage = 'Me kasutame su kontakte, et ühendada sind teistega. Me muudame kogu info anonüümseks ja ei jaga seda kellegi teisega.';

z.string.et.urlSupportRoot = '/';
z.string.et.urlSupportArticles = '/hc/en-us/articles/';
z.string.et.urlSupportRequests = '/hc/en-us/requests/';
z.string.et.urlWebappRoot = '/';
z.string.et.urlWebsiteRoot = '/';
z.string.et.urlWebsiteCreateTeam = '/create-team/';
z.string.et.urlWebsitePrivacy = '/privacy';
z.string.et.warningCallUnsupportedIncoming = '{{user}} helistab. Sinu brauser ei toeta kõnesid.';
z.string.et.warningCallUnsupportedOutgoing = 'Sa ei saa helistada, kuna sinu brauser ei toeta kõnesid.';
z.string.et.warningCallIssues = 'See Wire’i versioon ei saa kõnes osaleda. Palun kasuta';
z.string.et.warningCallUpgradeBrowser = 'Helistamiseks palun uuenda Google Chrome’i.';
z.string.et.warningConnectivityConnectionLost = 'Proovin ühenduda. Wire ei pruugi sõnumeid edastada.';
z.string.et.warningConnectivityNoInternet = 'Internet puudub. Sa ei saa sõnumeid saata ega vastu võtta.';
z.string.et.warningLearnMore = 'Loe lähemalt';
z.string.et.warningLifecycleUpdate = 'Uus Wire’i versioon on saadaval.';
z.string.et.warningLifecycleUpdateNotes = 'Mis on uut';
z.string.et.warningLifecycleUpdateLink = 'Uuenda nüüd';
z.string.et.warningNotFoundCamera = 'Sa ei saa kõnet teha, kuna su arvutil pole kaamerat.';
z.string.et.warningNotFoundMicrophone = 'Sa ei saa helistada, kuna su arvutil pole mikrofoni.';
z.string.et.warningPermissionDeniedCamera = 'Sa ei saa kõnet teha, kuna su brauseril pole kaamerale ligipääsu.';
z.string.et.warningPermissionDeniedMicrophone = 'Sa ei saa helistada, kuna su brauseril pole mikrofonile ligipääsu.';
z.string.et.warningPermissionDeniedScreen = 'Su brauser vajab ligipääsu ekraani jagamiseks.';
z.string.et.warningPermissionRequestCamera = '{{icon}} Luba kaamerale juurdepääs';
z.string.et.warningPermissionRequestMicrophone = '{{icon}} Luba mikrofonile juurdepääs';
z.string.et.warningPermissionRequestNotification = '{{icon}} Luba teated';
z.string.et.warningPermissionRequestScreen = '{{icon}} Luba ekraanile juurdepääs';

z.string.et.userAvailabilityAvailable = 'Saadaval';
z.string.et.userAvailabilityAway = 'Eemal';
z.string.et.userAvailabilityBusy = 'Hõivatud';
z.string.et.userAvailabilityNone = 'Puudub';

z.string.et.notificationAssetAdd = 'Jagas pilti';
z.string.et.notificationConnectionAccepted = 'Nõustus sinu ühendamistaotlusega';
z.string.et.notificationConnectionConnected = 'Sa oled nüüd ühendatud';
z.string.et.notificationConnectionRequest = 'Soovib ühenduda';
z.string.et.notificationConversationCreate = '{{user}} alustas vestlust';
z.string.et.notificationConversationMessageTimerUpdate = '{{user}} määras sõnumi taimeriks {{time}}';
z.string.et.notificationConversationMessageTimerReset = '{{user}} lülitas sõnumi taimeri välja';
z.string.et.notificationConversationRename = '{{user}} nimetas vestluse ümber: {{name}}';
z.string.et.notificationMemberJoinMany = '{{user}} lisas vestlusesse {{number}} inimest';
z.string.et.notificationMemberJoinSelf = '{{user}} liitus vestlusega';
z.string.et.notificationMemberJoinOne = '{{user1}} lisas vestlusesse {{user2}}';
z.string.et.notificationMemberLeaveRemovedYou = '{{user}} eemaldas sind vestlusest';
z.string.et.notificationMention = 'Uus mainimine:';
z.string.et.notificationObfuscated = 'Saatis sulle sõnumi';
z.string.et.notificationObfuscatedMention = 'Mainis sind';
z.string.et.notificationObfuscatedReply = 'Vastas sulle';
z.string.et.notificationObfuscatedTitle = 'Keegi';
z.string.et.notificationPing = 'Pingis';
z.string.et.notificationReaction = '{{reaction}} su sõnum';
z.string.et.notificationReply = 'Vastus: {{text}}';
z.string.et.notificationSharedAudio = 'Jagas häälsõnumit';
z.string.et.notificationSharedFile = 'Jagas faili';
z.string.et.notificationSharedLocation = 'Jagas asukohta';
z.string.et.notificationSharedVideo = 'Jagas videot';
z.string.et.notificationTitleGroup = '{{user}} vestluses {{conversation}}';
z.string.et.notificationVoiceChannelActivate = 'Helistamine';
z.string.et.notificationVoiceChannelDeactivate = 'helistas';

z.string.et.tooltipConversationAllVerified = 'Kõik sõrmejäljed on kinnitatud';
z.string.et.tooltipConversationCall = 'Kõne';
z.string.et.tooltipConversationEphemeral = 'Kustuv sõnum';
z.string.et.tooltipConversationFile = 'Lisa fail';
z.string.et.tooltipConversationInputPlaceholder = 'Kirjuta sõnum';
z.string.et.tooltipConversationInputPlaceholderAvailable = '{{user}} on saadaval';
z.string.et.tooltipConversationInputPlaceholderAway = '{{user}} on eemal';
z.string.et.tooltipConversationInputPlaceholderBusy = '{{user}} on hõivatud';
z.string.et.tooltipConversationPeople = 'Inimesed ({{shortcut}})';
z.string.et.tooltipConversationPicture = 'Lisa pilt';
z.string.et.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.et.tooltipConversationSearch = 'Otsing';
z.string.et.tooltipConversationVideoCall = 'Videokõne';

z.string.et.tooltipConversationsArchive = 'Arhiveeri ({{shortcut}})';
z.string.et.tooltipConversationsArchived = 'Kuva arhiiv ({{number}})';
z.string.et.tooltipConversationsMore = 'Veel';
z.string.et.tooltipConversationsNotifications = 'Ava teadete seaded ({{shortcut}})';
z.string.et.tooltipConversationsNotify = 'Eemalda vaigistus ({{shortcut}})';
z.string.et.tooltipConversationsPreferences = 'Ava eelistused';
z.string.et.tooltipConversationsSilence = 'Vaigista ({{shortcut}})';
z.string.et.tooltipConversationsStart = 'Alusta vestlust ({{shortcut}})';

z.string.et.tooltipConversationDetailsAddPeople = 'Lisa vestlusesse osalejaid ({{shortcut}})';
z.string.et.tooltipConversationDetailsRename = 'Muuda vestluse nime';

z.string.et.tooltipPreferencesContactsGmail = 'Logi oma Gmaili kontosse sisse, et jagada kontakte';
z.string.et.tooltipPreferencesContactsMacos = 'Jaga kõiki oma kontakte macOS Kontaktide rakendusest';
z.string.et.tooltipPreferencesPassword = 'Ava teine veebileht oma parooli lähtestamiseks';
z.string.et.tooltipPreferencesPicture = 'Muuda oma pilti…';
z.string.et.tooltipPreferencesRename = 'Muuda oma nime';

z.string.et.tooltipSearchClose = 'Sulge (Esc)';

z.string.et.initReceivedSelfUser = 'Tere, {{user}}.';
z.string.et.initValidatedClient = 'Toon ühendusi ja vestlusi';
z.string.et.initReceivedUserData = 'Kontrollin uusi sõnumeid';
z.string.et.initDecryption = 'Dekrüptin sõnumeid';
z.string.et.initEvents = 'Laadin sõnumeid';
z.string.et.initUpdatedFromNotifications = 'Peaaegu valmis - naudi Wire’i';
z.string.et.initProgress = ' — {{number1}}/{{number2}}';

z.string.et.ephemeralUnitsNone = 'Väljas';
z.string.et.ephemeralUnitsSecond = 'sekund';
z.string.et.ephemeralUnitsSeconds = 'sekundit';
z.string.et.ephemeralUnitsMinute = 'minut';
z.string.et.ephemeralUnitsMinutes = 'minutit';
z.string.et.ephemeralUnitsHour = 'tund';
z.string.et.ephemeralUnitsHours = 'tundi';
z.string.et.ephemeralUnitsDay = 'päev';
z.string.et.ephemeralUnitsDays = 'päeva';
z.string.et.ephemeralUnitsWeek = 'nädal';
z.string.et.ephemeralUnitsWeeks = 'nädalat';
z.string.et.ephemeralUnitsYear = 'aasta';
z.string.et.ephemeralUnitsYears = 'aastat';
z.string.et.ephemeralRemaining = 'on jäänud';

z.string.et.replyAudioMessage = 'Helisõnum';
z.string.et.replyQuoteError = 'Sa ei saa seda sõnumit näha.';
z.string.et.replyQuoteShowMore = 'Kuva rohkem';
z.string.et.replyQuoteShowLess = 'Kuva vähem';
z.string.et.replyQuoteTimeStampDate = 'Originaalsõnum ajast {{date}}';
z.string.et.replyQuoteTimeStampTime = 'Originaalsõnum kellast {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.fi.wireMacos = 'Wire macOS: lle';
z.string.fi.wireWindows = 'Wire Windowsille';
z.string.fi.wireLinux = 'Wire Linuxille';
z.string.fi.nonexistentUser = 'Poistettu käyttäjä';
z.string.fi.and = 'ja';

z.string.fi.authAccountCountryCode = 'Maakoodi';
z.string.fi.authAccountPasswordForgot = 'Unohdin salasanani';
z.string.fi.authAccountPublicComputer = 'Tämä on julkinen tietokone';
z.string.fi.authAccountSignIn = 'Kirjaudu sisään';
z.string.fi.authAccountSignInPhone = 'Puhelinnumero';

z.string.fi.authBlockedCookies = 'Salli evästeet kirjautuaksesi Wireen.';
z.string.fi.authBlockedDatabase = 'Wire tarvitsee pääsyn paikalliseen säilöösi säilöäkseen viestejä. Paikallinen säilö ei ole saatavilla yksityisessä tilassa.';
z.string.fi.authBlockedTabs = 'Wire on jo avoinna toisessa välilehdessä.';

z.string.fi.authVerifyAccountAdd = 'Lisää';
z.string.fi.authVerifyAccountDetail = 'Tämä mahdollistaa Wiren käytön useilla laitteilla.';
z.string.fi.authVerifyAccountHeadline = 'Lisää sähköpostiosoitteesi ja salasanasi.';
z.string.fi.authVerifyAccountLogout = 'Kirjaudu ulos';
z.string.fi.authVerifyCodeDescription = 'Syötä vahvistuskoodi jonka lähetimme {{number}}.';
z.string.fi.authVerifyCodeResend = 'Eikö koodi ole tullut perille?';
z.string.fi.authVerifyCodeResendDetail = 'Lähetä uudelleen';
z.string.fi.authVerifyCodeResendTimer = 'Voit pyytää uuden koodin {{expiration}} kuluttua.';
z.string.fi.authVerifyCodeChangePhone = 'Vaihda puhelinnumero';
z.string.fi.authVerifyPasswordHeadline = 'Kirjoita salasanasi';

z.string.fi.authLimitDevicesHeadline = 'Laitteet';
z.string.fi.authLimitDescription = 'Poista yksi laitteistasi aloittaaksesi Wiren käytön tässä laiteessa.';
z.string.fi.authLimitButtonManage = 'Hallitse laitteita';
z.string.fi.authLimitButtonSignOut = 'Kirjaudu ulos';
z.string.fi.authLimitDevicesCurrent = '(Nykyinen)';

z.string.fi.authHistoryHeadline = 'Käytät Wireä ensimmäistä kertaa tällä laitteella.';
z.string.fi.authHistoryDescription = 'Tietosuojasyistä keskusteluhistoriasi ei näy täällä.';
z.string.fi.authHistoryReuseHeadline = 'Olet käyttänyt Wireä tällä laitteella aiemmin.';
z.string.fi.authHistoryReuseDescription = 'Sillä välin lähetetyt viestit eivät näy tässä.';
z.string.fi.authHistoryButton = 'OK';

z.string.fi.authPostedResend = 'Lähetä uudelleen sähköpostiosoitteeseen: {{email}}';
z.string.fi.authPostedResendAction = 'Eikö sähköposti saavu perille?';
z.string.fi.authPostedResendDetail = 'Tarkista sähköpostisi saapuneet-kansio ja seuraa ohjeita.';
z.string.fi.authPostedResendHeadline = 'Sinulle on sähköpostia.';

z.string.fi.authPlaceholderEmail = 'Sähköposti';
z.string.fi.authPlaceholderPasswordPut = 'Salasana';
z.string.fi.authPlaceholderPasswordSet = 'Salasana (vähintään 8 merkkiä pitkä)';
z.string.fi.authPlaceholderPhone = 'Puhelinnumero';

z.string.fi.authErrorCode = 'Virheellinen koodi';
z.string.fi.authErrorCountryCodeInvalid = 'Maakoodi ei kelpaa';
z.string.fi.authErrorEmailExists = 'Tälle sähköpostille on jo luotu tunnus';
z.string.fi.authErrorEmailForbidden = 'Valitettavasti tämä sähköpostiosoite on kielletty.';
z.string.fi.authErrorEmailMalformed = 'Kirjoita voimassa oleva sähköpostiosoite.';
z.string.fi.authErrorEmailMissing = 'Kirjoita sähköpostiosoite.';
z.string.fi.authErrorMisc = 'Ongelmia yhteyden kanssa. Yritä uudelleen.';
z.string.fi.authErrorNameShort = 'Kirjoita nimi, jossa on vähintään 2 merkkiä';
z.string.fi.authErrorOffline = 'Ei internet-yhteyttä';
z.string.fi.authErrorPasswordShort = 'Valitse salasana, jossa on vähintään 8 merkkiä.';
z.string.fi.authErrorPasswordWrong = 'Väärä salasana. Yritä uudelleen.';
z.string.fi.authErrorPhoneNumberBudget = 'Kirjauduit sisään liian usein. Yritä myöhemmin uudelleen.';
z.string.fi.authErrorPhoneNumberForbidden = 'Valitettavasti tämä puhelinnumero on kielletty.';
z.string.fi.authErrorPhoneNumberInvalid = 'Virheellinen puhelinnumero';
z.string.fi.authErrorPhoneNumberUnknown = 'Tuntematon puhelinnumero';
z.string.fi.authErrorSuspended = 'Tämä tili ei ole enää oikeutettu kirjautumaan sisään.';
z.string.fi.authErrorSignIn = 'Vahvista tietosi ja yritä uudelleen.';

z.string.fi.callStateOutgoing = 'Soi…';
z.string.fi.callStateConnecting = 'Yhdistetään…';
z.string.fi.callStateIncoming = 'Soitetaan…';
z.string.fi.callDecline = 'Kieltäydy';
z.string.fi.callAccept = 'Hyväksy';
z.string.fi.callJoin = 'Liity';
z.string.fi.callChooseSharedScreen = 'Valitse näyttö jonka haluat jakaa';
z.string.fi.callParticipants = '{{number}} puhelussa';

z.string.fi.videoCallOverlayMute = 'Mykistä';
z.string.fi.videoCallOverlayHangUp = 'Katkaise puhelu';

z.string.fi.modalAcknowledgeAction = 'Ok';
z.string.fi.modalConfirmSecondary = 'Peruuta';
z.string.fi.modalOptionSecondary = 'Peruuta';

z.string.fi.modalAccountCreateAction = 'OK';

z.string.fi.modalAccountDeletionAction = 'Poista';
z.string.fi.modalAccountDeletionHeadline = 'Poista tili';
z.string.fi.modalAccountDeletionMessage = 'Lähetämme viestin sähköpostina tai tekstiviestinä. Paina viestissä olevaa linkkiä poistaaksesi tilisi lopullisesti.';

z.string.fi.modalAccountLeaveGuestRoomAction = 'Poistu';

z.string.fi.modalAccountLogoutAction = 'Kirjaudu ulos';
z.string.fi.modalAccountLogoutHeadline = 'Tyhjennä tiedot?';
z.string.fi.modalAccountLogoutOption = 'Poista kaikki henkilökohtaiset tiedot ja keskustelut tästä laitteesta.';

z.string.fi.modalAccountNewDevicesSecondary = 'Hallitse laitteita';
z.string.fi.modalAccountNewDevicesHeadline = 'Tiliäsi käytettiin:';
z.string.fi.modalAccountNewDevicesFrom = 'Laite:';
z.string.fi.modalAccountNewDevicesMessage = 'Jos et tehnyt tätä, poista laite ja vaihda salasanasi.';

z.string.fi.modalAccountRemoveDeviceAction = 'Poista laite';
z.string.fi.modalAccountRemoveDeviceHeadline = 'Poista "{{device}}"';
z.string.fi.modalAccountRemoveDeviceMessage = 'Sinun täytyy kirjoittaa salasanasi poistaaksesi laitteen.';
z.string.fi.modalAccountRemoveDevicePlaceholder = 'Salasana';

z.string.fi.modalAssetTooLargeMessage = 'Voit lähettää maksimissaan {{number}} kokoisia tiedostoja';

z.string.fi.modalAssetParallelUploadsMessage = 'Voit lähettää jopa {{number}} tiedostoa samaan aikaan.';

z.string.fi.modalCallEmptyConversationHeadline = 'Ei ketään kelle soittaa';
z.string.fi.modalCallEmptyConversationMessage = 'Täällä ei ole ketään jäljellä.';

z.string.fi.modalCallNoGroupVideoHeadline = 'Ei videopuheluja ryhmissä';
z.string.fi.modalCallNoGroupVideoMessage = 'Videopuhelut eivät ole saatavilla ryhmäkeskusteluissa.';

z.string.fi.modalCallNoMicrophoneAction = 'Kerro miten';
z.string.fi.modalCallNoMicrophoneMessage = 'Selaimellasi täytyy olla käyttöoikeus mikrofoniisi voidaksesi käydä puhelinkeskusteluja.';
z.string.fi.modalCallNoMicrophoneHeadline = 'Et voi käydä puhelinkeskusteluja ilman mikrofonia';

z.string.fi.modalCallSecondIncomingAction = 'Vastaa';
z.string.fi.modalCallSecondIncomingHeadline = 'Vastaatko puheluun?';
z.string.fi.modalCallSecondIncomingMessage = 'Sinun tämänhetkinen puhelu päättyy.';

z.string.fi.modalCallSecondOngoingAction = 'Katkaise puhelu';
z.string.fi.modalCallSecondOngoingHeadline = 'Katkaise puhelu toisessa laitteessa?';
z.string.fi.modalCallSecondOngoingMessage = 'Voit olla vain yhdessä puhelussa kerrallaan.';

z.string.fi.modalCallSecondOutgoingAction = 'Katkaise puhelu';
z.string.fi.modalCallSecondOutgoingHeadline = 'Katkaise nykyinen puhelu?';
z.string.fi.modalCallSecondOutgoingMessage = 'Voit olla vain yhdessä puhelussa kerrallaan.';

z.string.fi.modalConnectCancelAction = 'Kyllä';
z.string.fi.modalConnectCancelHeadline = 'Peruuta pyyntö?';
z.string.fi.modalConnectCancelMessage = 'Poista yhteyspyyntö {{user}}:lle.';
z.string.fi.modalConnectCancelSecondary = 'Ei';

z.string.fi.modalConnectAcceptAction = 'Yhdistä';
z.string.fi.modalConnectAcceptHeadline = 'Hyväksy?';
z.string.fi.modalConnectAcceptMessage = 'Tämä yhdistää teidät ja avaa keskustelun {{user}} kanssa.';
z.string.fi.modalConnectAcceptSecondary = 'Hylkää';

z.string.fi.modalConversationClearAction = 'Poista';
z.string.fi.modalConversationClearHeadline = 'Poista sisältö?';
z.string.fi.modalConversationClearOption = 'Poistu myös keskustelusta';

z.string.fi.modalConversationDeleteMessageAction = 'Poista';
z.string.fi.modalConversationDeleteMessageHeadline = 'Poista ainoastaan minulta?';
z.string.fi.modalConversationDeleteMessageMessage = 'Tätä ei voi perua.';

z.string.fi.modalConversationDeleteMessageEveryoneAction = 'Poista';
z.string.fi.modalConversationDeleteMessageEveryoneHeadline = 'Poista kaikilta?';
z.string.fi.modalConversationDeleteMessageEveryoneMessage = 'Tätä ei voi perua.';

z.string.fi.modalConversationLeaveAction = 'Poistu';
z.string.fi.modalConversationLeaveMessage = 'Et pysty lähettämään tai vastaanottamaan viestejä tässä keskustelussa.';

z.string.fi.modalConversationMessageTooLongHeadline = 'Viesti on liian pitkä';
z.string.fi.modalConversationMessageTooLongMessage = 'Voit lähettää viestejä joissa on maksimissaan {{number}} merkkiä.';

z.string.fi.modalConversationNewDeviceHeadlineOne = '{{user}} aloitti käyttämään uutta laitetta';
z.string.fi.modalConversationNewDeviceHeadlineMany = '{{users}} aloittivat käyttämään uusia laitteita';
z.string.fi.modalConversationNewDeviceHeadlineYou = '{{user}} aloitti käyttämään uutta laitetta';
z.string.fi.modalConversationNewDeviceIncomingCallAction = 'Vastaa puheluun';
z.string.fi.modalConversationNewDeviceIncomingCallMessage = 'Haluatko silti vastata puheluun?';
z.string.fi.modalConversationNewDeviceMessage = 'Haluatko vielä silti lähettää viestisi?';
z.string.fi.modalConversationNewDeviceOutgoingCallAction = 'Soita kuitenkin';
z.string.fi.modalConversationNewDeviceOutgoingCallMessage = 'Haluatko silti soittaa puhelun?';

z.string.fi.modalConversationNotConnectedHeadline = 'Ketään ei ole lisätty keskusteluun';
z.string.fi.modalConversationNotConnectedMessageOne = '{{name}} ei halua tulla lisätyksi keskusteluihin.';
z.string.fi.modalConversationNotConnectedMessageMany = 'Yksi valitsimistasi käyttäjistä ei halua tulla lisätyksi keskusteluihin.';

z.string.fi.modalConversationRemoveAction = 'Poista';
z.string.fi.modalConversationRemoveHeadline = 'Poista?';
z.string.fi.modalConversationRemoveMessage = '{{user}} ei pysty lähettämään tai vastaanottamaan viestejä tässä keskustelussa.';

z.string.fi.modalConversationRemoveGuestsAction = 'Poista';

z.string.fi.modalConversationTooManyMembersHeadline = 'Kaikki puhelukanavat varattuja';

z.string.fi.modalIntegrationUnavailableHeadline = 'Botit eivät käytettävissä';
z.string.fi.modalIntegrationUnavailableMessage = 'Kiitos mielenkiinnostasi botteihin. Tämä palvelu on väliaikaisesti pois käytöstä, koska työstämme seuraavaa versiota.';


z.string.fi.modalImproveWireAction = 'Hyväksy';
z.string.fi.modalImproveWireSecondary = 'Ei';

z.string.fi.modalSessionResetHeadline = 'Istunto on nollattu';
z.string.fi.modalSessionResetMessage1 = 'Jos ongelma ei ole ratkennut';
z.string.fi.modalSessionResetMessageLink = 'ota yhteys';
z.string.fi.modalSessionResetMessage2 = 'meihin.';

z.string.fi.modalUploadContactsAction = 'Yritä uudelleen';
z.string.fi.modalUploadContactsMessage = 'Emme vastaanottaneet tietojasi. Ole hyvä ja yritä tuoda kontaktisi uudelleen.';

z.string.fi.modalUserBlockAction = 'Estä';
z.string.fi.modalUserBlockHeadline = 'Estä {{user}}?';
z.string.fi.modalUserBlockMessage = '{{user}} ei pysty ottamaan sinuun yhteyttä tai lisäämään sinua ryhmäkeskusteluihin.';

z.string.fi.modalUserUnblockAction = 'Poista esto';
z.string.fi.modalUserUnblockHeadline = 'Poista esto?';
z.string.fi.modalUserUnblockMessage = '{{user}} pystyy jälleen ottamaan sinuun yhteyttä ja lisäämään sinut ryhmäkeskusteluihin.';

z.string.fi.connectionRequestConnect = 'Yhdistä';
z.string.fi.connectionRequestIgnore = 'Hylkää';

z.string.fi.conversationGuestIndicator = 'Vieras';

z.string.fi.conversationYouNominative = 'sinä';
z.string.fi.conversationYouDative = 'sinä';
z.string.fi.conversationYouAccusative = 'sinä';

z.string.fi.conversationConnectionAccepted = 'Yhdistetty';
z.string.fi.conversationConnectionBlocked = 'Estetty';
z.string.fi.conversationConnectionCancelRequest = 'Peruuta yhteyspyyntö';
z.string.fi.conversationDeviceStartedUsingOne = ' aloitti käyttämään';
z.string.fi.conversationDeviceStartedUsingMany = ' aloitti käyttämään';
z.string.fi.conversationDeviceUnverified = ' vahvistamattomia yksi';
z.string.fi.conversationDeviceYourDevices = ' sinun laitteet';
z.string.fi.conversationDeviceUserDevices = ' {{user}} n laitteet';
z.string.fi.conversationDeviceNewDeviceOne = ' uutta laitetta';
z.string.fi.conversationDeviceNewDeviceMany = ' uusia laitteita';
z.string.fi.conversationDeviceNewPeopleJoinedVerify = ' vahvista laitteet';
z.string.fi.conversationJustNow = 'Juuri nyt';
z.string.fi.conversationLocationLink = 'Avaa kartta';
z.string.fi.conversationMessageDelivered = 'Toimitettu';
z.string.fi.conversationRename = ' keskustelun nimi vaihdettu';
z.string.fi.conversationRenameYou = ' keskustelun nimi vaihdettu';
z.string.fi.conversationResume = 'Aloita keskustelu {{users}} n kanssa';
z.string.fi.conversationPing = ' pinggasi';
z.string.fi.conversationPingYou = ' pinggasi';
z.string.fi.conversationToday = 'tänään';
z.string.fi.conversationVoiceChannelDeactivate = ' soitti';
z.string.fi.conversationVoiceChannelDeactivateYou = ' soitti';
z.string.fi.conversationYesterday = 'Eilen';
z.string.fi.conversationUnableToDecrypt1 = 'Käyttäjän {{user}} viesti ei tullut perille.';
z.string.fi.conversationUnableToDecrypt2 = 'Käyttäjän {{user}} laitteen identiteetti muuttui. Viestiä ei toimitettu.';
z.string.fi.conversationUnableToDecryptLink = 'Miksi?';
z.string.fi.conversationUnableToDecryptErrorMessage = 'Virhe';
z.string.fi.conversationUnableToDecryptResetSession = 'Nollaa istunto';
z.string.fi.conversationMissedMessages = 'Et ole käyttänyt tätä laitetta pitkään aikaan. Jotkut viestit eivät saata näkyä täällä.';
z.string.fi.conversationAssetDownloading = 'Ladataan…';
z.string.fi.conversationAssetUploadFailed = 'Lähetys epäonnistui';
z.string.fi.conversationPlaybackError = 'Toisto epäonnistui';
z.string.fi.conversationContextMenuCopy = 'Kopioi';
z.string.fi.conversationContextMenuEdit = 'Muokkaa';
z.string.fi.conversationContextMenuDelete = 'Poista minulta';
z.string.fi.conversationContextMenuDeleteEveryone = 'Poista kaikilta';
z.string.fi.conversationContextMenuDownload = 'Lataa';
z.string.fi.conversationContextMenuLike = 'Tykkää';
z.string.fi.conversationContextMenuUnlike = 'Poista tykkäys';
z.string.fi.conversationDeleteTimestamp = 'Poistettu {{date}}';
z.string.fi.conversationEditTimestamp = 'Muokattu {{date}}';
z.string.fi.conversationLikesCaption = '{{number}} henkeä';
z.string.fi.conversationSendPastedFile = 'Liitetty kuva, {{date}}';
z.string.fi.conversationSomeone = 'Joku';
z.string.fi.conversationTweetAuthor = ' Twitterissä';

z.string.fi.groupCreationPreferencesAction = 'Seuraava';
z.string.fi.groupCreationParticipantsActionCreate = 'Valmis';
z.string.fi.groupCreationParticipantsPlaceholder = 'Hae nimellä';


z.string.fi.collectionShowAll = 'Näytä kaikki {{number}}';
z.string.fi.collectionSectionLinks = 'Linkit';
z.string.fi.collectionSectionImages = 'Kuvat';
z.string.fi.collectionSectionFiles = 'Tiedostot';
z.string.fi.collectionSectionAudio = 'Ääniviestit';

z.string.fi.fullsearchPlaceholder = 'Etsi viestejä';
z.string.fi.fullsearchNoResults = 'Ei tuloksia.';

z.string.fi.archiveHeader = 'Arkistoi';

z.string.fi.conversationsAllArchived = 'Kaikki arkistoitu';
z.string.fi.conversationsContacts = 'Yhteystiedot';
z.string.fi.conversationsConnectionRequestMany = '{{number}} ihmisiä odottaa';
z.string.fi.conversationsConnectionRequestOne = '1 ihminen odottaa';
z.string.fi.conversationsEmptyConversation = 'Ryhmäkeskustelu';
z.string.fi.conversationsNoConversations = 'Ei vielä keskusteluita';
z.string.fi.conversationsPopoverArchive = 'Arkistoi';
z.string.fi.conversationsPopoverCancel = 'Peru pyyntö';
z.string.fi.conversationsPopoverNotify = 'Poista mykistys';
z.string.fi.conversationsPopoverSilence = 'Mykistä';
z.string.fi.conversationsPopoverUnarchive = 'Palauta arkistosta';

z.string.fi.conversationsSecondaryLineEphemeralMessage = 'Lähetti sinulle viestin';
z.string.fi.conversationsSecondaryLinePeopleLeft = '{{number}} henkilöä poistui';
z.string.fi.conversationsSecondaryLinePersonLeft = '{{user}} poistui';
z.string.fi.conversationsSecondaryLinePersonRemoved = '{{user}} poistettiin';
z.string.fi.conversationsSecondaryLinePeopleAdded = '{{user}} henkilöä lisättiin';
z.string.fi.conversationsSecondaryLinePersonAdded = '{{user}} lisättiin';
z.string.fi.conversationsSecondaryLinePersonAddedYou = '{{user}} lisäsi sinut';
z.string.fi.conversationsSecondaryLineRenamed = '{{user}} vaihtoi keskustelun nimeä';
z.string.fi.conversationsSecondaryLineYouLeft = 'Poistuit';
z.string.fi.conversationsSecondaryLineYouWereRemoved = 'Sinut poistettiin';

z.string.fi.takeoverSub = 'Valtaa yksilöllinen nimesi Wiressä.';
z.string.fi.takeoverLink = 'Lue lisää';
z.string.fi.takeoverButtonChoose = 'Valitse omasi';
z.string.fi.takeoverButtonKeep = 'Pidä tämä';

z.string.fi.inviteMetaKeyMac = 'Cmd';
z.string.fi.inviteMetaKeyPc = 'Ctrl';
z.string.fi.inviteHeadline = 'Kutsu ihmisiä Wireen';
z.string.fi.inviteMessage = 'Olen Wiressä, etsi {{username}} tai mene osoitteeseen get.wire.com.';
z.string.fi.inviteMessageNoEmail = 'Olen Wiressä. Mene osoitteeseen get.wire.com ottaaksesi minuun yhteyttä.';

z.string.fi.extensionsBubbleButtonGif = 'Gif';

z.string.fi.extensionsGiphyButtonOk = 'Lähetä';
z.string.fi.extensionsGiphyButtonMore = 'Kokeile toista';
z.string.fi.extensionsGiphyMessage = '{{tag}} • giphy.com:in kautta';
z.string.fi.extensionsGiphyNoGifs = 'Upsista, ei giffejä';
z.string.fi.extensionsGiphyRandom = 'Satunnainen';

z.string.fi.addParticipantsConfirmLabel = 'Lisää';
z.string.fi.addParticipantsSearchPlaceholder = 'Hae nimellä';
z.string.fi.addParticipantsTabsPeople = 'Ihmiset';
z.string.fi.addParticipantsTabsServices = 'Palvelut';

z.string.fi.conversationDetailsActionArchive = 'Arkistoi';
z.string.fi.conversationDetailsActionCancelRequest = 'Peru pyyntö';
z.string.fi.conversationDetailsActionDevices = 'Laitteet';
z.string.fi.conversationDetailsActionNotifications = 'Ilmoitukset';
z.string.fi.conversationDetailsGuestsOff = 'Pois päältä';
z.string.fi.conversationDetailsOptions = 'Valinnat';
z.string.fi.conversationDetailsParticipantsServicesMany = 'Palvelut';
z.string.fi.conversationDetailsParticipantsUsersMany = 'Ihmiset';
z.string.fi.conversationDetailsPeople = 'Ihmiset';
z.string.fi.conversationDetailsServices = 'Palvelut';

z.string.fi.conversationParticipantsTitle = 'Ihmiset';
z.string.fi.conversationParticipantsSearchPlaceholder = 'Hae nimellä';

z.string.fi.groupParticipantActionCancelRequest = 'Peru pyyntö';
z.string.fi.groupParticipantActionDevices = 'Laitteet';
z.string.fi.groupParticipantActionPending = 'Odottaa';
z.string.fi.groupParticipantActionSendRequest = 'Yhdistä';

z.string.fi.notificationSettingsTitle = 'Ilmoitukset';

z.string.fi.participantDevicesDetailHeadline = 'Vahvista että tämä vastaa sormenjälkeä joka näkyy {{html1}}{{user}}’s n laitteella{{html2}}.';
z.string.fi.participantDevicesDetailHowTo = 'Miten teen sen?';
z.string.fi.participantDevicesDetailResetSession = 'Nollaa istunto';
z.string.fi.participantDevicesDetailShowMyDevice = 'Näytä laitteeni sormenjälki';
z.string.fi.participantDevicesDetailVerify = 'Vahvistettu';

z.string.fi.participantDevicesHeader = 'Laitteet';
z.string.fi.participantDevicesHeadline = 'Wire antaa jokaiselle laitteelle yksilöllisen sormenjäljen. Vertaa niitä {{user}} kanssa ja vahvista keskustelusi.';
z.string.fi.participantDevicesLearnMore = 'Lue lisää';
z.string.fi.participantDevicesWhyVerify = 'Miksi vahvistaa keskusteluja?';
z.string.fi.participantDevicesOutdatedClientMessage = '{{user}} käyttää vanhaa Wire-versiota. Laitteita ei näytetä täällä.';

z.string.fi.participantDevicesSelfAllDevices = 'Näytä kaikki laitteeni';
z.string.fi.participantDevicesSelfFingerprint = 'Laitteen sormenjälki';

z.string.fi.userProfileButtonConnect = 'Yhdistä';
z.string.fi.userProfileButtonIgnore = 'Hylkää';
z.string.fi.userProfileButtonUnblock = 'Poista esto';

z.string.fi.preferencesAbout = 'Tietoja meistä';
z.string.fi.preferencesAccount = 'Tili';
z.string.fi.preferencesAV = 'Audio / Video';
z.string.fi.preferencesDeviceDetails = 'Laitteen yksityiskohdat';
z.string.fi.preferencesDevices = 'Laitteet';
z.string.fi.preferencesHeadline = 'Asetukset';
z.string.fi.preferencesOptions = 'Valinnat';

z.string.fi.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.fi.preferencesAboutPrivacyPolicy = 'Yksityisyyskäytännöt';
z.string.fi.preferencesAboutSupport = 'Tuki';
z.string.fi.preferencesAboutSupportWebsite = 'Tuki sivusto';
z.string.fi.preferencesAboutSupportContact = 'Ota yhteyttä tukeen';
z.string.fi.preferencesAboutTermsOfUse = 'Käyttöehdot';
z.string.fi.preferencesAboutVersion = 'Versio {{version}}';
z.string.fi.preferencesAboutWebsite = 'Wiren verkkosivu';

z.string.fi.preferencesAccountCreateTeam = 'Luo tiimi';
z.string.fi.preferencesAccountDelete = 'Poista tili';
z.string.fi.preferencesAccountLogOut = 'Kirjaudu ulos';
z.string.fi.preferencesAccountManageTeam = 'Hallinnoi tiimiä';
z.string.fi.preferencesAccountResetPassword = 'Vaihda salasana';
z.string.fi.preferencesAccountTeam = 'tiimissä {{name}}';
z.string.fi.preferencesAccountUsernamePlaceholder = 'Koko nimesi';
z.string.fi.preferencesAccountUsernameHint = 'Vähintään 2 merkkiä, vain a - z, 0 - 9 ja _.';
z.string.fi.preferencesAccountUsernameAvailable = 'Saatavilla';
z.string.fi.preferencesAccountUsernameErrorTaken = 'On jo käytössä';

z.string.fi.preferencesAVCamera = 'Kamera';
z.string.fi.preferencesAVMicrophone = 'Mikrofoni';
z.string.fi.preferencesAVPermissionDetail = 'Salli selaimesi asetuksista';
z.string.fi.preferencesAVSpeakers = 'Kaiuttimet';

z.string.fi.preferencesDevicesActivatedOn = 'Aktivoitu {{date}}';
z.string.fi.preferencesDevicesActive = 'Aktiivinen';
z.string.fi.preferencesDevicesActiveDetail = 'Jos et tunnista yllä olevaa laitetta, poista se ja vaihda salasanasi.';
z.string.fi.preferencesDevicesCurrent = 'Nykyinen';
z.string.fi.preferencesDevicesFingerprint = 'Sormenjälki avain';
z.string.fi.preferencesDevicesFingerprintDetail = 'Wire antaa jokaiselle laitteelle yksilöllisen sormenjäljen. Vertaa niitä ja varmenna laitteesi ja keskustelusi.';
z.string.fi.preferencesDevicesId = 'ID: ';
z.string.fi.preferencesDevicesRemoveCancel = 'Peruuta';
z.string.fi.preferencesDevicesRemoveDetail = 'Poista tämä laite jos olet lakannut käyttämästä sitä. Sinut kirjataan ulos tästä laitteesta välittömästi.';
z.string.fi.preferencesDevicesSessionConfirmation = 'Istunto on nollattu.';
z.string.fi.preferencesDevicesSessionDetail = 'Jos sormenjäljet eivät täsmää, nollaa istunto luodaksesi uudet salausavaimet molemmille osapuolille.';
z.string.fi.preferencesDevicesSessionReset = 'Nollaa istunto';
z.string.fi.preferencesDevicesSessionOngoing = 'Nollataan istuntoa…';
z.string.fi.preferencesDevicesVerification = 'Vahvistettu';

z.string.fi.preferencesOptionsAudio = 'Äänimerkit';
z.string.fi.preferencesOptionsAudioAll = 'Kaikki';
z.string.fi.preferencesOptionsAudioAllDetail = 'Kaikki äänet';
z.string.fi.preferencesOptionsAudioNone = 'Ei mitään';
z.string.fi.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.fi.preferencesOptionsAudioSome = 'Jotain';
z.string.fi.preferencesOptionsAudioSomeDetail = 'Pingit ja puhelut';
z.string.fi.preferencesOptionsContacts = 'Yhteystiedot';
z.string.fi.preferencesOptionsContactsGmail = 'Tuo Gmailista';
z.string.fi.preferencesOptionsContactsMacos = 'Tuo Yhteystiedoista';
z.string.fi.preferencesOptionsContactsDetail = 'Käytämme sinun kontaktitietoja yhdistääksemme sinut muiden kanssa. Anonymisoimme kaiken tiedon ja emme jaa sitä ulkopuolisille.';
z.string.fi.preferencesOptionsPopular = 'Yleisön pyynnöstä';
z.string.fi.preferencesOptionsEmojiReplaceCheckbox = 'Korvaa tekstihymiöt emojeilla';
z.string.fi.preferencesOptionsPreviewsSendCheckbox = 'Luo esikatselut lähettämillesi linkeille';
z.string.fi.preferencesOptionsPreviewsSendDetail = 'Esikatselut saattavat silti näkyä muiden lähettämissä linkeissä.';
z.string.fi.preferencesOptionsNotifications = 'Ilmoitukset';
z.string.fi.preferencesOptionsNotificationsNone = 'Pois päältä';
z.string.fi.preferencesOptionsNotificationsObfuscate = 'Piilota yksityiskohdat';
z.string.fi.preferencesOptionsNotificationsObfuscateMessage = 'Näytä lähettäjä';
z.string.fi.preferencesOptionsNotificationsOn = 'Näytä lähettäjä ja viesti';

z.string.fi.backupCancel = 'Peruuta';

z.string.fi.searchConnect = 'Yhdistä';
z.string.fi.searchConnections = 'Yhteydet';
z.string.fi.searchContacts = 'Yhteystiedot';
z.string.fi.searchCreateGroup = 'Luo ryhmä';
z.string.fi.searchGroups = 'Ryhmät';
z.string.fi.searchPeople = 'Ihmiset';
z.string.fi.searchPlaceholder = 'Etsi nimellä tai käyttäjänimellä';
z.string.fi.searchServicePlaceholder = 'Hae nimellä';
z.string.fi.searchServices = 'Palvelut';
z.string.fi.searchTeamGroups = 'Tiimikeskustelut';
z.string.fi.searchTeamMembers = 'Tiimin jäsenet';
z.string.fi.searchTopPeople = 'Eniten käytetyt kontaktit';
z.string.fi.searchTrySearch = 'Etsi käyttäjiä nimellä tai käyttäjänimellä';
z.string.fi.searchNoContactsOnWire = 'Sinulla ei ole kontakteja Wiressä. Yritä etsiä muita käyttäjiä nimellä tai käyttäjänimellä.';
z.string.fi.searchOthers = 'Yhdistä';

z.string.fi.searchInvite = 'Kutsu henkilöitä Wireen';
z.string.fi.searchInviteDetail = 'Yhteystietojesi jakaminen auttaa sinua löytämään uusia kontakteja. Anonymisoimme kaiken tiedon ja emme jaa sitä ulkopuolisille.';
z.string.fi.searchInviteButtonContacts = 'Kontakteista';
z.string.fi.searchInviteButtonGmail = 'Gmailista';
z.string.fi.searchInviteHeadline = 'Kutsu kavereitasi';
z.string.fi.searchInviteShare = 'Jaa yhteystietoja';

z.string.fi.searchListEveryoneParticipates = 'Jokainen jonka kanssa olet yhdistetty on jo tässä keskustelussa.';
z.string.fi.searchListNoMatches = 'Ei vastaavia tuloksia. Yritä toisella nimellä.';


z.string.fi.uploadGoogleHeadline = 'Etsi ihmisiä joiden kanssa jutella.';
z.string.fi.uploadGoogleMessage = 'Käytämme sinun kontaktitietoja yhdistääksemme sinut muiden kanssa. Anonymisoimme kaiken tiedon ja emme jaa sitä ulkopuolisille.';

z.string.fi.warningCallUnsupportedIncoming = '{{user}} soittaa. Selaimesi ei tue puheluja.';
z.string.fi.warningCallUnsupportedOutgoing = 'Et voi soittaa puhelua koska selaimesi ei tue puheluja.';
z.string.fi.warningCallIssues = 'Tämä versio Wirestä ei pysty osallistumaan puheluun. Käytä';
z.string.fi.warningCallUpgradeBrowser = 'Soittaaksesi puhelun, päivitä Google Chrome.';
z.string.fi.warningConnectivityConnectionLost = 'Yritetään yhdistää. Wire ei mahdollisesti pysty toimitttamaan viestejä perille.';
z.string.fi.warningConnectivityNoInternet = 'Ei Internetiä. Et pysty lähettämään tai vastaanottamaan viestejä.';
z.string.fi.warningLearnMore = 'Lue lisää';
z.string.fi.warningLifecycleUpdate = 'Wiren uusi versio on saatavilla.';
z.string.fi.warningLifecycleUpdateNotes = 'Uutuudet';
z.string.fi.warningLifecycleUpdateLink = 'Päivitä nyt';
z.string.fi.warningNotFoundCamera = 'Et voi soittaa puhelua koska tietokoneessasi ei ole kameraa.';
z.string.fi.warningNotFoundMicrophone = 'Et voi soittaa puhelua koska tietokoneessasi ei ole mikrofonia.';
z.string.fi.warningPermissionDeniedCamera = 'Et voi soittaa puhelua koska selaimellasi ei ole oikeutta käyttä kameraa.';
z.string.fi.warningPermissionDeniedMicrophone = 'Et voi soittaa puhelua koska selaimellasi ei ole oikeuta käyttää mikrofonia.';
z.string.fi.warningPermissionDeniedScreen = 'Selaimesi tarvitsee luvan jakaa näyttösi.';
z.string.fi.warningPermissionRequestCamera = '{{icon}} Anna käyttöoikeus kameraan';
z.string.fi.warningPermissionRequestMicrophone = '{{icon}} Anna käyttöoikeus mikrofoniin';
z.string.fi.warningPermissionRequestNotification = '{{icon}} Salli ilmoitukset';
z.string.fi.warningPermissionRequestScreen = '{{icon}} Salli näytön käyttö';

z.string.fi.userAvailabilityAvailable = 'Saatavilla';
z.string.fi.userAvailabilityNone = 'Ei mitään';

z.string.fi.notificationAssetAdd = 'Jakoi kuvan';
z.string.fi.notificationConnectionAccepted = 'Hyväksyi yhteyspyyntösi';
z.string.fi.notificationConnectionConnected = 'Olet nyt yhteydessä';
z.string.fi.notificationConnectionRequest = 'Haluaa luoda kontaktin';
z.string.fi.notificationConversationCreate = '{{user}} aloitti keskustelun';
z.string.fi.notificationConversationRename = '{{user}} nimesi keskustelun uudelleen {{name}}ksi';
z.string.fi.notificationMemberJoinMany = '{{user}} lisäsi {{number}} ihmistä keskusteluun';
z.string.fi.notificationMemberJoinOne = '{{user1}} lisäsi {{user2}}n keskusteluun';
z.string.fi.notificationMemberLeaveRemovedYou = '{{user}} poisti sinut keskustelusta';
z.string.fi.notificationObfuscated = 'Lähetti sinulle viestin';
z.string.fi.notificationObfuscatedTitle = 'Joku';
z.string.fi.notificationPing = 'Pinggasi';
z.string.fi.notificationReaction = '{{reaction}} sinun viesti';
z.string.fi.notificationSharedAudio = 'Jakoi ääniviestin';
z.string.fi.notificationSharedFile = 'Jakoi tiedoston';
z.string.fi.notificationSharedLocation = 'Jakoi sijainnin';
z.string.fi.notificationSharedVideo = 'Jakoi videon';
z.string.fi.notificationVoiceChannelActivate = 'Soittaa';
z.string.fi.notificationVoiceChannelDeactivate = 'Soitti';

z.string.fi.tooltipConversationAllVerified = 'Kaikki sormenjäljet on vahvistettu';
z.string.fi.tooltipConversationCall = 'Puhelu';
z.string.fi.tooltipConversationEphemeral = 'Ajoitettu viesti';
z.string.fi.tooltipConversationFile = 'Lisää tiedosto';
z.string.fi.tooltipConversationInputPlaceholder = 'Kirjoita viesti';
z.string.fi.tooltipConversationPeople = 'Ihmiset ({{shortcut}})';
z.string.fi.tooltipConversationPicture = 'Lisää kuva';
z.string.fi.tooltipConversationPing = 'Pingaa ({{shortcut}})';
z.string.fi.tooltipConversationSearch = 'Etsi';
z.string.fi.tooltipConversationVideoCall = 'Videopuhelu';

z.string.fi.tooltipConversationsArchive = 'Arkisto ({{shortcut}})';
z.string.fi.tooltipConversationsArchived = 'Näytä arkisto ({{number}})';
z.string.fi.tooltipConversationsMore = 'Lisää';
z.string.fi.tooltipConversationsNotify = 'Poist mykistys ({{shortcut}})';
z.string.fi.tooltipConversationsPreferences = 'Avaa asetukset';
z.string.fi.tooltipConversationsSilence = 'Mykistä ({{shortcut}})';
z.string.fi.tooltipConversationsStart = 'Aloita keskustelu ({{shortcut}})';

z.string.fi.tooltipConversationDetailsRename = 'Muuta keskustelun nimeä';

z.string.fi.tooltipPreferencesContactsGmail = 'Kirjaudu gmail-tilillesi jakaaksesi kontakteja';
z.string.fi.tooltipPreferencesContactsMacos = 'Jaa kaikki yhteystietosi macOs Yhteystieto sovelluksesta';
z.string.fi.tooltipPreferencesPassword = 'Avaa toinen nettisivu vaihtaaksesi salasanasi';
z.string.fi.tooltipPreferencesPicture = 'Vaihda kuvasi…';
z.string.fi.tooltipPreferencesRename = 'Vaihda nimesi';

z.string.fi.tooltipSearchClose = 'Sulje (Esc)';

z.string.fi.initReceivedSelfUser = 'He, {{user}}.';
z.string.fi.initValidatedClient = 'Haetaan yhteyksiäsi ja keskustelujasi';
z.string.fi.initReceivedUserData = 'Tarkistetaan uusia viestejä';
z.string.fi.initDecryption = 'Puretaan viestejä';
z.string.fi.initEvents = 'Ladataan viestejä';
z.string.fi.initUpdatedFromNotifications = 'Melkein valmista - nauti Wirestä';
z.string.fi.initProgress = ' — {{number1}} / {{number2}}';

z.string.fi.ephemeralUnitsNone = 'Pois päältä';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.fr.wire = 'Wire';
z.string.fr.wireMacos = 'Wire pour macOS';
z.string.fr.wireWindows = 'Wire pour Windows';
z.string.fr.wireLinux = 'Wire pour Linux';
z.string.fr.nonexistentUser = 'Utilisateur supprimé';
z.string.fr.and = 'et';
z.string.fr.enumerationAnd = ', et ';

//=L'application se charge
z.string.fr.authAccountCountryCode = 'Indicatif du pays';
z.string.fr.authAccountPasswordForgot = 'Mot de passe oublié';
z.string.fr.authAccountPublicComputer = 'Cet ordinateur est public';
z.string.fr.authAccountSignIn = 'Se connecter';
z.string.fr.authAccountSignInPhone = 'Téléphone';

z.string.fr.authBlockedCookies = 'Autorisez les cookies pour vous connecter à Wire.';
z.string.fr.authBlockedDatabase = 'Wire a besoin d’accéder à votre espace de stockage pour afficher les messages. Il n’est pas disponible en navigation privée.';
z.string.fr.authBlockedTabs = 'Wire est déjà ouvert dans un autre onglet.';
z.string.fr.authBlockedTabsAction = 'Utiliser cet onglet à la place';

z.string.fr.authVerifyAccountAdd = 'Ajouter';
z.string.fr.authVerifyAccountDetail = 'Cela vous permet d’utiliser Wire sur plusieurs appareils.';
z.string.fr.authVerifyAccountHeadline = 'Ajouter une adresse e-mail et un mot de passe.';
z.string.fr.authVerifyAccountLogout = 'Se déconnecter';
z.string.fr.authVerifyCodeDescription = 'Saisissez le code de vérification que nous avons envoyé au {{number}}.';
z.string.fr.authVerifyCodeResend = 'Pas de code à l’horizon ?';
z.string.fr.authVerifyCodeResendDetail = 'Renvoyer';
z.string.fr.authVerifyCodeResendTimer = 'Vous pourrez demander un nouveau code {{expiration}}.';
z.string.fr.authVerifyCodeChangePhone = 'Changer le numéro de téléphone';
z.string.fr.authVerifyPasswordHeadline = 'Saisissez votre mot de passe';

z.string.fr.authLimitDevicesHeadline = 'Appareils';
z.string.fr.authLimitDescription = 'Supprimez un de vos autres appareils pour commencer à utiliser Wire sur celui-ci.';
z.string.fr.authLimitButtonManage = 'Gérer les appareils';
z.string.fr.authLimitButtonSignOut = 'Se déconnecter';
z.string.fr.authLimitDevicesCurrent = '(actuel)';

z.string.fr.authHistoryHeadline = 'C’est la première fois que vous utilisez Wire sur cet appareil.';
z.string.fr.authHistoryDescription = 'Pour des raisons de confidentialité, votre historique de conversation n’apparaîtra pas ici.';
z.string.fr.authHistoryReuseHeadline = 'Vous avez déjà utilisé Wire sur cet appareil.';
z.string.fr.authHistoryReuseDescription = 'Les messages envoyés entre-temps n’apparaîtront pas ici.';
z.string.fr.authHistoryButton = 'OK';

z.string.fr.authPostedResend = 'Renvoyer à {{email}}';
z.string.fr.authPostedResendAction = 'Aucun e-mail à l’horizon ?';
z.string.fr.authPostedResendDetail = 'Vérifiez votre boîte de réception et suivez les instructions.';
z.string.fr.authPostedResendHeadline = 'Vous avez du courrier.';

z.string.fr.authPlaceholderEmail = 'E-mail';
z.string.fr.authPlaceholderPasswordPut = 'Mot de passe';
z.string.fr.authPlaceholderPasswordSet = 'Mot de passe (8 caractères minimum)';
z.string.fr.authPlaceholderPhone = 'Numéro de téléphone';

z.string.fr.authErrorCode = 'Code invalide';
z.string.fr.authErrorCountryCodeInvalid = 'Indicatif du pays invalide';
z.string.fr.authErrorEmailExists = 'Adresse e-mail déjà utilisée';
z.string.fr.authErrorEmailForbidden = 'Désolé. Cette adresse e-mail est bannie.';
z.string.fr.authErrorEmailMalformed = 'Veuillez saisir une adresse e-mail valide.';
z.string.fr.authErrorEmailMissing = 'Veuillez saisir une adresse e-mail.';
z.string.fr.authErrorMisc = 'Problèmes de connexion. Veuillez réessayer.';
z.string.fr.authErrorNameShort = 'Saisissez un nom composé d’au moins 2 caractères';
z.string.fr.authErrorOffline = 'Pas de connexion Internet';
z.string.fr.authErrorPasswordShort = 'Choisissez un mot de passe d’au moins 8 caractères.';
z.string.fr.authErrorPasswordWrong = 'Mot de passe incorrect. Veuillez réessayer.';
z.string.fr.authErrorPending = 'Le compte n’est pas encore vérifié';
z.string.fr.authErrorPhoneNumberBudget = 'Vous vous êtes connecté trop souvent. Réessayez plus tard.';
z.string.fr.authErrorPhoneNumberForbidden = 'Désolé. Ce numéro de téléphone est banni.';
z.string.fr.authErrorPhoneNumberInvalid = 'Numéro de téléphone non valide';
z.string.fr.authErrorPhoneNumberUnknown = 'Numéro de téléphone inconnu';
z.string.fr.authErrorSuspended = 'Ce compte n’est plus autorisé à se connecter.';
z.string.fr.authErrorSignIn = 'Veuillez vérifier vos informations et réessayez.';

z.string.fr.callStateOutgoing = 'Sonnerie…';
z.string.fr.callStateConnecting = 'Connexion…';
z.string.fr.callStateIncoming = 'Appel…';
z.string.fr.callStateIncomingGroup = '{{user}} appelle';
z.string.fr.callDecline = 'Décliner';
z.string.fr.callAccept = 'Accepter';
z.string.fr.callJoin = 'Rejoindre';
z.string.fr.callChooseSharedScreen = 'Choisissez un écran à partager';
z.string.fr.callParticipants = '{{number}} sur l’appel';
z.string.fr.callNoCameraAccess = 'Appareil photo indisponible';

z.string.fr.videoCallOverlayFitVideoLabel = 'Double-cliquez pour adapter la taille de la vidéo';
z.string.fr.videoCallOverlayConversations = 'Conversations';
z.string.fr.videoCallOverlayMute = 'Mettre en sourdine';
z.string.fr.videoCallOverlayVideo = 'Vidéo';
z.string.fr.videoCallOverlayShareScreen = 'Partager l’Écran';
z.string.fr.videoCallOverlayHangUp = 'Raccrocher';
z.string.fr.videoCallPaused = 'Vidéo en pause';
z.string.fr.videoCallScreenShareNotSupported = 'Le partage d’écran n’est pas compatible avec ce navigateur';

z.string.fr.modalAcknowledgeAction = 'OK';
z.string.fr.modalAcknowledgeHeadline = 'Une erreur est survenue';
z.string.fr.modalConfirmSecondary = 'Annuler';
z.string.fr.modalOptionSecondary = 'Annuler';

z.string.fr.modalAccountCreateAction = 'OK';
z.string.fr.modalAccountCreateHeadline = 'Créer un compte ?';
z.string.fr.modalAccountCreateMessage = 'En créant un compte, vous perdrez l’historique de conversation dans cette chambre d’invités.';

z.string.fr.modalAccountDeletionAction = 'Supprimer';
z.string.fr.modalAccountDeletionHeadline = 'Supprimer le compte';
z.string.fr.modalAccountDeletionMessage = 'Nous allons envoyer un e-mail ou un SMS. Cliquez sur le lien pour supprimer définitivement votre compte.';

z.string.fr.modalAccountLeaveGuestRoomAction = 'Quitter';
z.string.fr.modalAccountLeaveGuestRoomHeadline = 'Quitter la conversation ?';
z.string.fr.modalAccountLeaveGuestRoomMessage = 'L’historique de la conversation sera supprimé. Pour le conserver, créez un compte la prochaine fois.';

z.string.fr.modalAccountLogoutAction = 'Se déconnecter';
z.string.fr.modalAccountLogoutHeadline = 'Supprimer les données ?';
z.string.fr.modalAccountLogoutOption = 'Supprime toutes vos informations personnelles et conversations de cet appareil.';

z.string.fr.modalAccountNewDevicesSecondary = 'Gérer les appareils';
z.string.fr.modalAccountNewDevicesHeadline = 'Votre compte a été utilisé le :';
z.string.fr.modalAccountNewDevicesFrom = 'Depuis :';
z.string.fr.modalAccountNewDevicesMessage = 'Si ce n’était pas vous, supprimez l’appareil et changez votre mot de passe.';

z.string.fr.modalAccountRemoveDeviceAction = 'Supprimer l’appareil';
z.string.fr.modalAccountRemoveDeviceHeadline = 'Supprimer "{{device}}"';
z.string.fr.modalAccountRemoveDeviceMessage = 'Votre mot de passe est nécessaire pour supprimer l’appareil.';
z.string.fr.modalAccountRemoveDevicePlaceholder = 'Mot de passe';

z.string.fr.modalAssetTooLargeHeadline = 'Fichier trop volumineux';
z.string.fr.modalAssetTooLargeMessage = 'Vous pouvez envoyer des fichiers jusqu’à {{number}}';

z.string.fr.modalAssetParallelUploadsHeadline = 'Trop de fichiers à la fois';
z.string.fr.modalAssetParallelUploadsMessage = 'Vous pouvez envoyer jusqu’à {{number}} fichiers à la fois.';

z.string.fr.modalCallEmptyConversationHeadline = 'Personne à appeler';
z.string.fr.modalCallEmptyConversationMessage = 'Il n’y a plus personne ici.';

z.string.fr.modalCallEmptyLogHeadline = 'Aucun appel';
z.string.fr.modalCallEmptyLogMessage = 'Il n’y a aucun appel sur lequel se baser pour le rapport de débogage.';

z.string.fr.modalCallNoGroupVideoHeadline = 'Pas d’appel vidéo en groupe';
z.string.fr.modalCallNoGroupVideoMessage = 'Les appels vidéo ne sont pas disponibles dans les conversations de groupe.';

z.string.fr.modalCallNoMicrophoneAction = 'Dites-moi comment faire';
z.string.fr.modalCallNoMicrophoneMessage = 'Votre navigateur doit avoir accès au micro pour passer des appels.';
z.string.fr.modalCallNoMicrophoneHeadline = 'Impossible d’appeler sans micro';

z.string.fr.modalCallSecondIncomingAction = 'Répondre';
z.string.fr.modalCallSecondIncomingHeadline = 'Répondre à l’appel ?';
z.string.fr.modalCallSecondIncomingMessage = 'Votre appel en cours sera terminé.';

z.string.fr.modalCallSecondOngoingAction = 'Raccrocher';
z.string.fr.modalCallSecondOngoingHeadline = 'Raccrocher l’appel d’un autre appareil ?';
z.string.fr.modalCallSecondOngoingMessage = 'Vous ne pouvez être que dans un appel à la fois.';

z.string.fr.modalCallSecondOutgoingAction = 'Raccrocher';
z.string.fr.modalCallSecondOutgoingHeadline = 'Raccrocher l’appel en cours ?';
z.string.fr.modalCallSecondOutgoingMessage = 'Vous ne pouvez être que dans un appel à la fois.';

z.string.fr.modalConnectCancelAction = 'Oui';
z.string.fr.modalConnectCancelHeadline = 'Annuler la demande ?';
z.string.fr.modalConnectCancelMessage = 'Annuler la demande de connexion à {{user}}.';
z.string.fr.modalConnectCancelSecondary = 'Non';

z.string.fr.modalConnectAcceptAction = 'Se connecter';
z.string.fr.modalConnectAcceptHeadline = 'Accepter ?';
z.string.fr.modalConnectAcceptMessage = 'Cela vous connectera et ouvrira la conversation avec {{user}}.';
z.string.fr.modalConnectAcceptSecondary = 'Ignorer';

z.string.fr.modalConversationClearAction = 'Supprimer';
z.string.fr.modalConversationClearHeadline = 'Effacer le contenu ?';
z.string.fr.modalConversationClearMessage = 'Ceci effacera la conversation sur tous vos appareils.';
z.string.fr.modalConversationClearOption = 'Quitter aussi la conversation';

z.string.fr.modalConversationDeleteMessageAction = 'Supprimer';
z.string.fr.modalConversationDeleteMessageHeadline = 'Supprimer seulement pour moi ?';
z.string.fr.modalConversationDeleteMessageMessage = 'Cela est irréversible.';

z.string.fr.modalConversationDeleteMessageEveryoneAction = 'Supprimer';
z.string.fr.modalConversationDeleteMessageEveryoneHeadline = 'Supprimer pour tout le monde ?';
z.string.fr.modalConversationDeleteMessageEveryoneMessage = 'Cela est irréversible.';

z.string.fr.modalConversationLeaveAction = 'Quitter';
z.string.fr.modalConversationLeaveHeadline = 'Quitter la conversation "{{name}}" ?';
z.string.fr.modalConversationLeaveMessage = 'Vous ne pourrez plus envoyer ou recevoir de messages dans cette conversation.';

z.string.fr.modalConversationMessageTooLongHeadline = 'Message trop long';
z.string.fr.modalConversationMessageTooLongMessage = 'Vous pouvez envoyer des messages de {{number}} caractères maximum.';

z.string.fr.modalConversationNewDeviceAction = 'Envoyer quand même';
z.string.fr.modalConversationNewDeviceHeadlineOne = '{{user}} utilise un nouvel appareil';
z.string.fr.modalConversationNewDeviceHeadlineMany = '{{users}} utilisent de nouveaux appareils';
z.string.fr.modalConversationNewDeviceHeadlineYou = '{{user}} utilise un nouvel appareil';
z.string.fr.modalConversationNewDeviceIncomingCallAction = 'Décrocher';
z.string.fr.modalConversationNewDeviceIncomingCallMessage = 'Voulez-vous quand même décrocher ?';
z.string.fr.modalConversationNewDeviceMessage = 'Voulez-vous toujours envoyer vos messages ?';
z.string.fr.modalConversationNewDeviceOutgoingCallAction = 'Appeler quand même';
z.string.fr.modalConversationNewDeviceOutgoingCallMessage = 'Voulez-vous quand même appeler ?';

z.string.fr.modalConversationNotConnectedHeadline = 'Personne n’a été ajouté à la conversation';
z.string.fr.modalConversationNotConnectedMessageOne = '{{name}} ne veut pas être ajouté aux conversations.';
z.string.fr.modalConversationNotConnectedMessageMany = 'Une des personnes sélectionnées ne veut pas être ajoutée aux conversations.';

z.string.fr.modalConversationRemoveAction = 'Exclure';
z.string.fr.modalConversationRemoveHeadline = 'Exclure ?';
z.string.fr.modalConversationRemoveMessage = '{{user}} ne pourra plus envoyer ou recevoir de messages dans cette conversation.';

z.string.fr.modalConversationRemoveGuestsAction = 'Exclure';
z.string.fr.modalConversationRemoveGuestsHeadline = 'Désactiver l’accès ?';
z.string.fr.modalConversationRemoveGuestsMessage = 'Tous les invités et services seront retirés de la conversation. Il ne sera plus possible d’ajouter de nouveaux invités ou services.';

z.string.fr.modalConversationRevokeLinkAction = 'Révoquer le lien';
z.string.fr.modalConversationRevokeLinkHeadline = 'Révoquer le lien ?';
z.string.fr.modalConversationRevokeLinkMessage = 'Les invités ne pourront plus rejoindre la conversation avec ce lien. Les invités ayant déjà rejoint la conversation conserveront leurs accès.';

z.string.fr.modalConversationGuestOptionsAllowGuestMessage = 'Impossible d’accepter des invités ou des services. Veuillez réessayer.';
z.string.fr.modalConversationGuestOptionsDisableGuestMessage = 'Impossible de retirer des invités ou des services. Veuillez réessayer.';
z.string.fr.modalConversationGuestOptionsGetCodeMessage = 'Impossible de récupérer le lien d’accès.';
z.string.fr.modalConversationGuestOptionsRequestCodeMessage = 'La demande de lien d’accès a échoué. Merci de réessayer.';
z.string.fr.modalConversationGuestOptionsRevokeCodeMessage = 'Impossible de révoquer le lien d’accès. Merci de réessayer.';
z.string.fr.modalConversationGuestOptionsToggleGuestsMessage = 'Impossible de changer les réglages pour les invités.';

z.string.fr.modalConversationTooManyMembersHeadline = 'Le groupe est complet';
z.string.fr.modalConversationTooManyMembersMessage = 'Jusqu’à {{number1}} personnes peuvent participer à une conversation. Actuellement, il n’y a de la place que pour {{number2}} de plus.';

z.string.fr.modalGifTooLargeHeadline = 'L’image sélectionnée est trop volumineuse';
z.string.fr.modalGifTooLargeMessage = 'La taille maximale autorisée est {{number}} MB.';

z.string.fr.modalIntegrationUnavailableHeadline = 'Les bots sont indisponibles pour le moment';
z.string.fr.modalIntegrationUnavailableMessage = 'Merci de votre intérêt pour les bots. Ce service est actuellement désactivé pendant que nous travaillons sur la prochaine version. Restez à l’écoute.';

z.string.fr.modalPictureFileFormatHeadline = 'Impossible d’utiliser cette image';
z.string.fr.modalPictureFileFormatMessage = 'Veuillez choisir un fichier PNG ou JPEG.';

z.string.fr.modalPictureTooLargeHeadline = 'La photo sélectionnée est trop volumineuse';
z.string.fr.modalPictureTooLargeMessage = 'Vous pouvez envoyer des images allant jusqu’à {{number}} MB.';

z.string.fr.modalPictureTooSmallHeadline = 'L’image sélectionnée est trop petite';
z.string.fr.modalPictureTooSmallMessage = 'Merci de choisir une image mesurant au moins 320 × 320 px.';

z.string.fr.modalImproveWireAction = 'Accepter';
z.string.fr.modalImproveWireSecondary = 'Non';
z.string.fr.modalImproveWireHeadline = 'Aidez-nous à améliorer Wire';
z.string.fr.modalImproveWireMessage = 'Wire peut créer et utiliser des rapports d’utilisation et d’erreurs anonymes afin d’améliorer l’application. Vous pouvez révoquer votre autorisation à tout moment.';

z.string.fr.modalServiceUnavailableHeadline = 'L’ajout du service est impossible';
z.string.fr.modalServiceUnavailableMessage = 'Le service est temporairement indisponible.';

z.string.fr.modalSessionResetHeadline = 'La session a été réinitialisée';
z.string.fr.modalSessionResetMessage1 = 'Si le problème n’est pas résolu,';
z.string.fr.modalSessionResetMessageLink = 'contactez';
z.string.fr.modalSessionResetMessage2 = '-nous.';

z.string.fr.modalUploadContactsAction = 'Réessayer';
z.string.fr.modalUploadContactsMessage = 'Nous n’avons pas reçu votre information. Veuillez réessayer d’importer vos contacts.';

z.string.fr.modalUserBlockAction = 'Bloquer';
z.string.fr.modalUserBlockHeadline = 'Bloquer {{user}} ?';
z.string.fr.modalUserBlockMessage = '{{user}} ne pourra plus vous contacter ou vous ajouter à des conversations de groupe.';

z.string.fr.modalUserUnblockAction = 'Débloquer';
z.string.fr.modalUserUnblockHeadline = 'Débloquer ?';
z.string.fr.modalUserUnblockMessage = '{{user}} pourra de nouveau vous parler ou vous ajouter à des conversations de groupe.';

z.string.fr.modalNoCameraTitle = 'Appareil photo indisponible';
z.string.fr.modalNoCameraMessage = 'Wire n’a pas accès à la caméra.[br][faqLink]Lisez cet article de support[/faqLink] pour savoir comment résoudre ce problème.';

z.string.fr.connectionRequestConnect = 'Se connecter';
z.string.fr.connectionRequestIgnore = 'Ignorer';

z.string.fr.conversationGuestIndicator = 'Invité';
z.string.fr.userRemainingTimeHours = '{{time}} heures restantes';
z.string.fr.userRemainingTimeMinutes = 'Moins de {{time}} minutes restantes';

z.string.fr.conversationYouNominative = 'vous';
z.string.fr.conversationYouDative = 'vous';
z.string.fr.conversationYouAccusative = 'vous';

z.string.fr.conversationConnectionAccepted = 'Connecté';
z.string.fr.conversationConnectionBlocked = 'Bloqué';
z.string.fr.conversationConnectionCancelRequest = 'Annuler la demande de connexion';
z.string.fr.conversationCreateTemporary = 'Vous avez rejoint la conversation';
z.string.fr.conversationCreateWith = 'avec {{users}}';
z.string.fr.conversationDeviceStartedUsingOne = ' utilise';
z.string.fr.conversationDeviceStartedUsingMany = ' utilise';
z.string.fr.conversationDeviceUnverified = ' a annulé la vérification d’un';
z.string.fr.conversationDeviceYourDevices = ' de vos appareils';
z.string.fr.conversationDeviceUserDevices = ' des appareils de {{user}}';
z.string.fr.conversationDeviceNewDeviceOne = ' un nouvel appareil';
z.string.fr.conversationDeviceNewDeviceMany = ' de nouveaux appareils';
z.string.fr.conversationDeviceNewPeopleJoined = 'De nouvelles personnes ont rejoint la conversation.';
z.string.fr.conversationDeviceNewPeopleJoinedVerify = 'Vérifier les appareils';
z.string.fr.conversationJustNow = 'À l’instant';
z.string.fr.conversationLocationLink = 'Ouvrir la carte';
z.string.fr.conversationCreated = '[bold]{{name}}[/bold] a démarré une conversation avec {{users}}';
z.string.fr.conversationCreatedMore = '[bold]{{name}}[/bold] a démarré une conversation avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreatedName = '[bold]{{name}}[/bold] a démarré la conversation';
z.string.fr.conversationCreatedNameYou = '[bold]Vous[/bold] avez démarré la conversation';
z.string.fr.conversationCreatedYou = 'Vous avez commencé une conversation avec {{users}}';
z.string.fr.conversationCreatedYouMore = 'Vous avez démarré la conversation avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreateWithMore = 'avec {{users}}, et [showmore]{{count}} autres[/showmore]';
z.string.fr.conversationCreateTeam = 'avec [showmore]tous les membres de l’équipe[/showmore]';
z.string.fr.conversationCreateTeamGuest = 'avec [showmore]tous les membres de l’équipe et un invité[/showmore]';
z.string.fr.conversationCreateTeamGuests = 'avec [showmore]tous les membres de l’équipe et {{count}} invités[/showmore]';
z.string.fr.conversationMemberJoined = '[bold]{{name}}[/bold] a ajouté {{users}} à la conversation';
z.string.fr.conversationMemberJoinedYou = '[bold]Vous[/bold] avez ajouté {{users}} à la conversation';
z.string.fr.conversationMemberJoinedMore = '[bold]{{name}}[/bold] a ajouté {{users}}, et [showmore]{{count}} autres[/showmore] à la conversation';
z.string.fr.conversationMemberJoinedYouMore = '[bold]Vous[/bold] avez ajouté {{users}}, et [showmore]{{count}} plus[/showmore] à la conversation';
z.string.fr.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] a rejoint la conversation';
z.string.fr.conversationMemberJoinedSelfYou = '[bold]Vous[/bold] avez rejoint la conversation';
z.string.fr.conversationMemberLeft = '[bold]{{name}}[/bold] a quitté la conversation';
z.string.fr.conversationMemberLeftYou = '[bold]Vous[/bold] avez quitté la conversation';
z.string.fr.conversationMemberRemoved = '[bold]{{name}}[/bold] a exclu {{users}}';
z.string.fr.conversationMemberRemovedYou = '[bold]Vous[/bold] avez exclu {{users}}';
z.string.fr.conversationTeamLeft = '[bold]{{name}}[/bold] a été retiré de l’équipe';
z.string.fr.conversationMessageDelivered = 'Distribué';
z.string.fr.conversationRename = ' a renommé la conversation';
z.string.fr.conversationRenameYou = ' a renommé la conversation';
z.string.fr.conversationUpdatedTimer = ' a défini les messages éphémère à {{time}}';
z.string.fr.conversationUpdatedTimerYou = ' avez défini les message éphémères à {{time}}';
z.string.fr.conversationResetTimer = ' a désactivé les messages éphémères';
z.string.fr.conversationResetTimerYou = ' avez désactivé les messages éphémères';
z.string.fr.conversationResume = 'Commencez une conversation avec {{users}}';
z.string.fr.conversationPing = ' a fait un signe';
z.string.fr.conversationPingYou = ' a fait un signe';
z.string.fr.conversationToday = 'aujourd’hui';
z.string.fr.conversationVoiceChannelDeactivate = ' a essayé d’appeler';
z.string.fr.conversationVoiceChannelDeactivateYou = ' a essayé d’appeler';
z.string.fr.conversationYesterday = 'Hier';
z.string.fr.conversationUnableToDecrypt1 = 'Un message de [highlight]{{user}}[/highlight] n’a pas été reçu.';
z.string.fr.conversationUnableToDecrypt2 = 'L’identité de l’appareil de {{user}} a changé. Message non délivré.';
z.string.fr.conversationUnableToDecryptLink = 'Pourquoi ?';
z.string.fr.conversationUnableToDecryptErrorMessage = 'Erreur';
z.string.fr.conversationUnableToDecryptResetSession = 'Réinitialiser la session';
z.string.fr.conversationMissedMessages = 'Vous n’avez pas utilisé cet appareil depuis un moment. Il est possible que certains messages n’apparaissent pas ici.';
z.string.fr.conversationAssetUploading = 'Envoi en cours…';
z.string.fr.conversationAssetDownloading = 'Téléchargement en cours…';
z.string.fr.conversationAssetUploadFailed = 'Échec de l’envoi';
z.string.fr.conversationPlaybackError = 'Lecture impossible';
z.string.fr.conversationContextMenuCopy = 'Copier';
z.string.fr.conversationContextMenuEdit = 'Édition';
z.string.fr.conversationContextMenuDelete = 'Supprimer pour moi…';
z.string.fr.conversationContextMenuDeleteEveryone = 'Supprimer pour tout le monde…';
z.string.fr.conversationContextMenuDownload = 'Télécharger';
z.string.fr.conversationContextMenuLike = 'J’aime';
z.string.fr.conversationContextMenuReply = 'Répondre';
z.string.fr.conversationContextMenuUnlike = 'Je n’aime plus';
z.string.fr.conversationDeleteTimestamp = 'Supprimé : {{date}}';
z.string.fr.conversationEditTimestamp = 'Modifié : {{date}}';
z.string.fr.conversationLikesCaption = '{{number}} personnes';
z.string.fr.conversationSendPastedFile = 'Image collée le {{date}}';
z.string.fr.conversationSomeone = 'Quelqu’un';
z.string.fr.conversationTweetAuthor = ' via Twitter';
z.string.fr.conversationServicesWarning = 'Les services ont accès au contenu de la conversation';

z.string.fr.groupCreationPreferencesAction = 'Suivant';
z.string.fr.groupCreationPreferencesErrorNameShort = 'Au moins un caractère';
z.string.fr.groupCreationPreferencesErrorNameLong = 'Trop de caractères';
z.string.fr.groupCreationPreferencesHeader = 'Nouveau groupe';
z.string.fr.groupCreationPreferencesPlaceholder = 'Nom du groupe';
z.string.fr.groupCreationParticipantsActionCreate = 'Terminé';
z.string.fr.groupCreationParticipantsActionSkip = 'Passer';
z.string.fr.groupCreationParticipantsHeader = 'Ajouter un contact';
z.string.fr.groupCreationParticipantsHeaderWithCounter = 'Ajouter des participants ({{number}})';
z.string.fr.groupCreationParticipantsPlaceholder = 'Rechercher par nom';
z.string.fr.groupSizeInfo = 'Les conversations de groupe peuvent accueillir jusqu’à {{count}} personnes. Les appels vidéo peuvent accueillir jusqu’à 3 personnes en plus de vous.';

z.string.fr.guestRoomConversationName = 'Espace invité';
z.string.fr.guestRoomToggleName = 'Autoriser les invités et les services';
z.string.fr.guestRoomToggleInfo = 'Rendre cette conversation accessible à des personnes et services étrangers à votre équipe.';
z.string.fr.guestRoomToggleInfoExtended = 'Rendre cette conversation accessible à des personnes et services étrangers à votre équipe. Vous pouvez toujours changer cette option plus tard.';

z.string.fr.guestRoomConversationBadge = 'Des invités sont présents';
z.string.fr.guestRoomConversationBadgeService = 'Des services sont actifs';
z.string.fr.guestRoomConversationBadgeGuestAndService = 'Des invités et des services sont présents';

z.string.fr.guestRoomConversationHead = 'Des personnes étrangères à votre équipe peuvent rejoindre la conversation.';
z.string.fr.guestRoomConversationButton = 'Inviter des personnes';

z.string.fr.collectionShowAll = 'Tout afficher ({{number}})';
z.string.fr.collectionSectionLinks = 'Liens';
z.string.fr.collectionSectionImages = 'Images';
z.string.fr.collectionSectionFiles = 'Fichiers';
z.string.fr.collectionSectionAudio = 'Messages vocaux';

z.string.fr.fullsearchPlaceholder = 'Chercher dans les messages';
z.string.fr.fullsearchNoResults = 'Aucun résultat.';

z.string.fr.archiveHeader = 'Archiver';

z.string.fr.conversationsAllArchived = 'Tout a été archivé';
z.string.fr.conversationsContacts = 'Contacts';
z.string.fr.conversationsConnectionRequestMany = '{{number}} personnes en attente';
z.string.fr.conversationsConnectionRequestOne = '1 personne en attente';
z.string.fr.conversationsEmptyConversation = 'Conversation de groupe';
z.string.fr.conversationsNoConversations = 'Commencez une conversation ou créez un groupe.';
z.string.fr.conversationsPopoverArchive = 'Archiver';
z.string.fr.conversationsPopoverBlock = 'Bloquer…';
z.string.fr.conversationsPopoverCancel = 'Annuler la demande';
z.string.fr.conversationsPopoverClear = 'Supprimer le contenu…';
z.string.fr.conversationsPopoverLeave = 'Quitter le groupe…';
z.string.fr.conversationsPopoverNotificationSettings = 'Notifications…';
z.string.fr.conversationsPopoverNotify = 'Activer le micro';
z.string.fr.conversationsPopoverSilence = 'Mettre en sourdine';
z.string.fr.conversationsPopoverUnarchive = 'Restaurer';

z.string.fr.conversationsSecondaryLineEphemeralMention = 'Vous a mentionné';
z.string.fr.conversationsSecondaryLineEphemeralMentionGroup = 'Quelqu’un vous a mentionné';
z.string.fr.conversationsSecondaryLineEphemeralMessage = 'vous a envoyé un message';
z.string.fr.conversationsSecondaryLineEphemeralMessageGroup = 'Quelqu’un a envoyé un message';
z.string.fr.conversationsSecondaryLineEphemeralReply = 'Vous a répondu';
z.string.fr.conversationsSecondaryLineEphemeralReplyGroup = 'Quelqu’un vous a répondu';
z.string.fr.conversationsSecondaryLineIncomingCall = '{{user}} appelle';
z.string.fr.conversationsSecondaryLinePeopleLeft = '{{number}} personnes sont parties';
z.string.fr.conversationsSecondaryLinePersonLeft = '{{user}} est parti';
z.string.fr.conversationsSecondaryLinePersonRemoved = '{{user}} a été exclu';
z.string.fr.conversationsSecondaryLinePersonRemovedTeam = '{{user}} a été exclu de l’équipe';
z.string.fr.conversationsSecondaryLinePeopleAdded = '{{user}} personnes ont été ajoutées';
z.string.fr.conversationsSecondaryLinePersonAdded = '{{user}} a été ajouté';
z.string.fr.conversationsSecondaryLinePersonAddedSelf = '{{user}} a rejoint la conversation';
z.string.fr.conversationsSecondaryLinePersonAddedYou = '{{user}} vous a ajouté';
z.string.fr.conversationsSecondaryLineRenamed = '{{user}} a renommé la conversation';
z.string.fr.conversationsSecondaryLineSummaryMessage = '{{number}} message';
z.string.fr.conversationsSecondaryLineSummaryMessages = '{{number}} messages';
z.string.fr.conversationsSecondaryLineSummaryMention = '{{number}} mention';
z.string.fr.conversationsSecondaryLineSummaryMentions = '{{number}} mentions';
z.string.fr.conversationsSecondaryLineSummaryMissedCall = '{{number}} appel manqué';
z.string.fr.conversationsSecondaryLineSummaryMissedCalls = '{{number}} appels manqués';
z.string.fr.conversationsSecondaryLineSummaryPing = '{{number}} signe';
z.string.fr.conversationsSecondaryLineSummaryPings = '{{number}} signes'
z.string.fr.conversationsSecondaryLineSummaryReply = '{{number}} réponse';
z.string.fr.conversationsSecondaryLineSummaryReplies = '{{number}} réponses';
z.string.fr.conversationsSecondaryLineYouLeft = 'Vous êtes parti';
z.string.fr.conversationsSecondaryLineYouWereRemoved = 'Vous avez été exclu';

z.string.fr.takeoverSub = 'Choisissez votre nom d’utilisateur unique sur Wire.';
z.string.fr.takeoverLink = 'En savoir plus';
z.string.fr.takeoverButtonChoose = 'Choisissez le vôtre';
z.string.fr.takeoverButtonKeep = 'Garder celui-là';

z.string.fr.inviteMetaKeyMac = 'Cmd';
z.string.fr.inviteMetaKeyPc = 'Ctrl';
z.string.fr.inviteHintSelected = 'Appuyez sur {{metaKey}} + C pour copier';
z.string.fr.inviteHintUnselected = 'Sélectionnez et appuyez sur {{metaKey}} + C';
z.string.fr.inviteHeadline = 'Invitez des personnes sur Wire';
z.string.fr.inviteMessage = 'Je suis sur Wire, cherche {{username}} ou va sur get.wire.com .';
z.string.fr.inviteMessageNoEmail = 'Je suis sur Wire. Va sur get.wire.com pour me rejoindre.';

z.string.fr.extensionsBubbleButtonGif = 'Gif';

z.string.fr.extensionsGiphyButtonOk = 'Envoyer';
z.string.fr.extensionsGiphyButtonMore = 'Autre gif';
z.string.fr.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.fr.extensionsGiphyNoGifs = 'Oups, pas de gif';
z.string.fr.extensionsGiphyRandom = 'Au hasard';

z.string.fr.addParticipantsConfirmLabel = 'Ajouter';
z.string.fr.addParticipantsHeader = 'Ajouter des participants';
z.string.fr.addParticipantsHeaderWithCounter = 'Ajouter des participants ({{number}})';
z.string.fr.addParticipantsManageServices = 'Gérer les services';
z.string.fr.addParticipantsManageServicesNoResults = 'Gérer les services';
z.string.fr.addParticipantsNoServicesManager = 'Les services sont des programmes qui peuvent améliorer votre flux de travail.';
z.string.fr.addParticipantsNoServicesMember = 'Les services sont des programmes qui peuvent améliorer votre flux de travail. Pour les activer, contactez votre administrateur.';
z.string.fr.addParticipantsSearchPlaceholder = 'Rechercher par nom';
z.string.fr.addParticipantsServiceConfirmButton = 'Ajouter un service';
z.string.fr.addParticipantsTabsPeople = 'Personnes';
z.string.fr.addParticipantsTabsServices = 'Services';

z.string.fr.conversationDetailsActionArchive = 'Archiver';
z.string.fr.conversationDetailsActionAddParticipants = 'Ajouter des participants';
z.string.fr.conversationDetailsActionBlock = 'Bloquer…';
z.string.fr.conversationDetailsActionCancelRequest = 'Annuler la demande';
z.string.fr.conversationDetailsActionClear = 'Supprimer le contenu…';
z.string.fr.conversationDetailsActionConversationParticipants = 'Tout afficher ({{number}})';
z.string.fr.conversationDetailsActionCreateGroup = 'Nouveau groupe';
z.string.fr.conversationDetailsActionDevices = 'Appareils';
z.string.fr.conversationDetailsActionGuestOptions = 'Invités et services';
z.string.fr.conversationDetailsActionTimedMessages = 'Messages éphémères';
z.string.fr.conversationDetailsActionNotifications = 'Notifications';
z.string.fr.conversationDetailsActionLeave = 'Quitter le groupe…';
z.string.fr.conversationDetailsGuestsOff = 'Désactiver';
z.string.fr.conversationDetailsGuestsOn = 'Activé';
z.string.fr.conversationDetailsOptions = 'Options';
z.string.fr.conversationDetailsParticipantsServicesOne = 'Service';
z.string.fr.conversationDetailsParticipantsServicesMany = 'Services';
z.string.fr.conversationDetailsParticipantsUsersOne = 'Personne';
z.string.fr.conversationDetailsParticipantsUsersMany = 'Personnes';
z.string.fr.conversationDetailsPeople = 'Personnes';
z.string.fr.conversationDetailsServices = 'Services';

z.string.fr.conversationParticipantsTitle = 'Personnes';
z.string.fr.conversationParticipantsSearchPlaceholder = 'Rechercher par nom';

z.string.fr.groupParticipantActionBlock = 'Bloquer…';
z.string.fr.groupParticipantActionCancelRequest = 'Annuler la demande';
z.string.fr.groupParticipantActionDevices = 'Appareils';
z.string.fr.groupParticipantActionIgnoreRequest = 'Ignorer la demande';
z.string.fr.groupParticipantActionIncomingRequest = 'Accepter la demande';
z.string.fr.groupParticipantActionLeave = 'Quitter le groupe…';
z.string.fr.groupParticipantActionOpenConversation = 'Ouvrir la conversation';
z.string.fr.groupParticipantActionPending = 'En attente';
z.string.fr.groupParticipantActionRemove = 'Retirer du groupe…';
z.string.fr.groupParticipantActionSelfProfile = 'Ouvrir le profil';
z.string.fr.groupParticipantActionSendRequest = 'Se connecter';
z.string.fr.groupParticipantActionUnblock = 'Débloquer…';

z.string.fr.guestOptionsCopyLink = 'Copier le lien';
z.string.fr.guestOptionsCopyLinkDone = 'Lien copié !';
z.string.fr.guestOptionsCreateLink = 'Créer le lien';
z.string.fr.guestOptionsInfoHeader = 'Inviter des personnes via un lien';
z.string.fr.guestOptionsInfoText = 'N’importe qui avec le lien peut rejoindre la conversation, même s’ils n’utilisent pas Wire.';
z.string.fr.guestOptionsRevokeLink = 'Révoquer le lien';
z.string.fr.guestOptionsTitle = 'Invités et services';

z.string.fr.notificationSettingsTitle = 'Notifications';
z.string.fr.notificationSettingsDisclaimer = 'Vous pouvez choisir d’être notifié pour tous les évènements (y compris les appels audios et vidéos) ou juste lorsque vous êtes mentionné.';
z.string.fr.notificationSettingsEverything = 'Toutes';
z.string.fr.notificationSettingsMentionsAndReplies = 'Mentions et réponses';
z.string.fr.notificationSettingsNothing = 'Aucune';

z.string.fr.timedMessagesTitle = 'Messages éphémères';
z.string.fr.timedMessageDisclaimer = 'Les messages éphémères seront activés pour tous les participants de cette conversation.';

z.string.fr.participantDevicesDetailHeadline = 'Vérifiez que cela correspond à l’empreinte affichée sur {{html1}}l’appareil de {{user}}{{html2}}.';
z.string.fr.participantDevicesDetailHowTo = 'Comment faire ?';
z.string.fr.participantDevicesDetailResetSession = 'Réinitialiser la session';
z.string.fr.participantDevicesDetailShowMyDevice = 'Afficher l’empreinte de mon appareil';
z.string.fr.participantDevicesDetailVerify = 'Vérifié';

z.string.fr.participantDevicesHeader = 'Appareils';
z.string.fr.participantDevicesHeadline = 'Wire donne à chaque appareil une empreinte unique. Comparez-les avec {{user}} et vérifiez votre conversation.';
z.string.fr.participantDevicesLearnMore = 'En savoir plus';
z.string.fr.participantDevicesWhyVerify = 'Pourquoi vérifier les conversations ?';
z.string.fr.participantDevicesOutdatedClientMessage = '{{user}} utilise une ancienne version de Wire. Aucun appareil n’est affiché ici.';

z.string.fr.participantDevicesSelfAllDevices = 'Afficher tous mes appareils';
z.string.fr.participantDevicesSelfFingerprint = 'Empreinte de l’appareil';

z.string.fr.userProfileButtonConnect = 'Se connecter';
z.string.fr.userProfileButtonIgnore = 'Ignorer';
z.string.fr.userProfileButtonUnblock = 'Débloquer';

z.string.fr.preferencesAbout = 'À propos';
z.string.fr.preferencesAccount = 'Compte';
z.string.fr.preferencesAV = 'Audio / Vidéo';
z.string.fr.preferencesDeviceDetails = 'Informations de l’appareil';
z.string.fr.preferencesDevices = 'Appareils';
z.string.fr.preferencesHeadline = 'Préférences';
z.string.fr.preferencesOptions = 'Options';

z.string.fr.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.fr.preferencesAboutPrivacyPolicy = 'Politique de confidentialité';
z.string.fr.preferencesAboutSupport = 'Assistance';
z.string.fr.preferencesAboutSupportWebsite = 'Site d’assistance de Wire';
z.string.fr.preferencesAboutSupportContact = 'Contacter l’assistance technique';
z.string.fr.preferencesAboutTermsOfUse = 'Conditions d’utilisation';
z.string.fr.preferencesAboutVersion = 'Version {{version}}';
z.string.fr.preferencesAboutWebsite = 'Site de Wire';

z.string.fr.preferencesAccountAvaibilityUnset = 'Définir un statut';
z.string.fr.preferencesAccountCreateTeam = 'Créer une équipe';
z.string.fr.preferencesAccountData = 'Utilisation des Données Personnelles';
z.string.fr.preferencesAccountDataCheckbox = 'Envoyer des données anonymes';
z.string.fr.preferencesAccountDataDetail = 'Vous pouvez aider à améliorer Wire en envoyant des données anonymes sur votre utilisation et des rapports d’erreur.';
z.string.fr.preferencesAccountDelete = 'Supprimer le compte';
z.string.fr.preferencesAccountLeaveGuestRoom = 'Quitter l’espace invité';
z.string.fr.preferencesAccountLeaveGuestRoomDescription = 'Vous ne pourrez plus accéder aux messages de cette conversation.';
z.string.fr.preferencesAccountLogOut = 'Se déconnecter';
z.string.fr.preferencesAccountManageTeam = 'Gérer l’équipe';
z.string.fr.preferencesAccountMarketingConsentCheckbox = 'Recevoir notre newsletter';
z.string.fr.preferencesAccountMarketingConsentDetail = 'Recevoir des e-mails sur les nouveautés de Wire.';
z.string.fr.preferencesAccountResetPassword = 'Réinitialiser le mot de passe';
z.string.fr.preferencesAccountTeam = 'dans {{name}}';
z.string.fr.preferencesAccountUsernamePlaceholder = 'Votre nom complet';
z.string.fr.preferencesAccountUsernameHint = 'Au moins 2 caractères. Uniquement a–z, 0–9 et _.';
z.string.fr.preferencesAccountUsernameAvailable = 'Disponible';
z.string.fr.preferencesAccountUsernameErrorTaken = 'Déjà pris';

z.string.fr.preferencesAVCamera = 'Webcam';
z.string.fr.preferencesAVMicrophone = 'Microphone';
z.string.fr.preferencesAVPermissionDetail = 'Activer à partir des préférences de votre navigateur';
z.string.fr.preferencesAVSpeakers = 'Haut-parleurs';
z.string.fr.preferencesAVTemporaryDisclaimer = 'Les invités ne peuvent pas démarrer de vidéoconférences. Sélectionnez la caméra à utiliser si vous en rejoignez une.';
z.string.fr.preferencesAVNoCamera = 'Wire n’a pas accès à la caméra.[br][faqLink]Lisez cet article[/faqLink] pour savoir comment résoudre ce problème.';
z.string.fr.preferencesAVTryAgain = 'Réessayez';

z.string.fr.preferencesDevicesActivatedOn = 'Activé le {{date}}';
z.string.fr.preferencesDevicesActive = 'Actifs';
z.string.fr.preferencesDevicesActiveDetail = 'Si vous ne reconnaissez pas l’un des appareils ci-dessus, supprimez-le et changez votre mot de passe.';
z.string.fr.preferencesDevicesCurrent = 'Actuel';
z.string.fr.preferencesDevicesFingerprint = 'Empreinte';
z.string.fr.preferencesDevicesFingerprintDetail = 'Wire donne à chaque appareil une empreinte unique. Comparez-les et vérifiez vos appareils et conversations.';
z.string.fr.preferencesDevicesId = 'ID : ';
z.string.fr.preferencesDevicesRemove = 'Supprimer…';
z.string.fr.preferencesDevicesRemoveCancel = 'Annuler';
z.string.fr.preferencesDevicesRemoveDetail = 'Supprimez ce périphérique si vous avez cessé de l’utiliser. Vous serez déconnecté de cet appareil immédiatement.';
z.string.fr.preferencesDevicesSessionConfirmation = 'La session a été réinitialisée.';
z.string.fr.preferencesDevicesSessionDetail = 'Si les empreintes ne correspondent pas, réinitialisez la session afin de générer de nouvelles clés de chiffrement des deux côtés.';
z.string.fr.preferencesDevicesSessionReset = 'Réinitialiser la session';
z.string.fr.preferencesDevicesSessionOngoing = 'Réinitialisation de la session…';
z.string.fr.preferencesDevicesVerification = 'Vérifié';

z.string.fr.preferencesOptionsAudio = 'Alertes sonores';
z.string.fr.preferencesOptionsAudioAll = 'Toutes';
z.string.fr.preferencesOptionsAudioAllDetail = 'Tous les sons';
z.string.fr.preferencesOptionsAudioNone = 'Aucune';
z.string.fr.preferencesOptionsAudioNoneDetail = 'Chuuut !';
z.string.fr.preferencesOptionsAudioSome = 'Certaines';
z.string.fr.preferencesOptionsAudioSomeDetail = 'Signes et appels';
z.string.fr.preferencesOptionsContacts = 'Contacts';
z.string.fr.preferencesOptionsContactsGmail = 'Importer depuis Gmail';
z.string.fr.preferencesOptionsContactsMacos = 'Importer depuis Contacts';
z.string.fr.preferencesOptionsContactsDetail = 'Nous utilisons les données de vos contacts afin de vous connecter à d’autres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne d’autre.';
z.string.fr.preferencesOptionsPopular = 'À la demande générale';
z.string.fr.preferencesOptionsEmojiReplaceCheckbox = 'Remplace les émoticônes typographiques par des emojis';
z.string.fr.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.fr.preferencesOptionsPreviewsSendCheckbox = 'Crée des aperçus pour les liens que vous envoyez';
z.string.fr.preferencesOptionsPreviewsSendDetail = 'Les aperçus pourront toujours s’afficher pour les liens d’autres personnes.';
z.string.fr.preferencesOptionsNotifications = 'Notifications';
z.string.fr.preferencesOptionsNotificationsNone = 'Désactiver';
z.string.fr.preferencesOptionsNotificationsObfuscate = 'Masquer les détails';
z.string.fr.preferencesOptionsNotificationsObfuscateMessage = 'Afficher l’expéditeur';
z.string.fr.preferencesOptionsNotificationsOn = 'Afficher l’expéditeur et le message';
z.string.fr.preferencesOptionsCallLogs = 'Résolution de problèmes';
z.string.fr.preferencesOptionsCallLogsGet = 'Sauvegarder le rapport de débogage des appels';
z.string.fr.preferencesOptionsCallLogsDetail = 'Cette information aide l’assistance de Wire à diagnostiquer les problèmes d’appel.';

z.string.fr.preferencesOptionsBackupHeader = 'Historique';
z.string.fr.preferencesOptionsBackupExportHeadline = 'Sauvegarder les conversations';
z.string.fr.preferencesOptionsBackupExportSecondary = 'Créez une sauvegarde afin de conserver l’historique de vos conversations. Vous pourrez utiliser celle-ci si vous perdez votre périphérique ou si vous basculez vers un nouveau.\nLe fichier de sauvegarde n’est pas protégé par le chiffrement de bout-en-bout de Wire, enregistrez-le dans un endroit sûr.';
z.string.fr.preferencesOptionsBackupImportHeadline = 'Restaurer depuis une sauvegarde';
z.string.fr.preferencesOptionsBackupImportSecondary = 'Vous pouvez uniquement restaurer l’historique depuis une sauvegarde provenant d’une plateforme identique. Ceci effacera les conversations que vous avez déjà sur cet appareil.';

z.string.fr.backupExportGenericErrorHeadline = 'Le fichier n’a pas pu être sauvegardé';
z.string.fr.backupExportGenericErrorSecondary = 'La sauvegarde a échoué.';
z.string.fr.backupExportProgressHeadline = 'Préparation en cours…';
z.string.fr.backupExportProgressSecondary = 'Sauvegarde en cours · {{processed}} sur {{total}} — {{progress}}%';
z.string.fr.backupExportProgressCompressing = 'Fichier de sauvegarde en préparation';
z.string.fr.backupExportSaveFileAction = 'Enregistrer le fichier';
z.string.fr.backupExportSuccessHeadline = 'Sauvegarde prête';
z.string.fr.backupExportSuccessSecondary = 'Vous pourrez utiliser cette sauvegarde si vous perdez votre périphérique ou si vous basculez vers un nouveau.';
z.string.fr.backupImportGenericErrorHeadline = 'Une erreur est survenue';
z.string.fr.backupImportGenericErrorSecondary = 'Votre historique n’a pas pu être restauré.';
z.string.fr.backupImportAccountErrorHeadline = 'Fichier de sauvegarde invalide';
z.string.fr.backupImportAccountErrorSecondary = 'Vous ne pouvez pas restaurer l’histoire d’un autre compte.';
z.string.fr.backupImportVersionErrorHeadline = 'Sauvegarde incompatible';
z.string.fr.backupImportVersionErrorSecondary = 'Cette sauvegarde a été créée par une version plus récente ou expirée de Wire et ne peut pas être restaurée ici.';
z.string.fr.backupImportIncompatibleErrorHeadline = 'Fichier de sauvegarde invalide';
z.string.fr.backupImportIncompatibleErrorSecondary = 'Vous ne pouvez pas restaurer l’histoire d’un autre compte.';
z.string.fr.backupImportOutdatedErrorHeadline = 'Sauvegarde incompatible';
z.string.fr.backupImportOutdatedErrorSecondary = 'Cette sauvegarde a été créée par une version plus récente ou expirée de Wire et ne peut pas être restaurée ici.';
z.string.fr.backupImportProgressHeadline = 'Préparation en cours…';
z.string.fr.backupImportProgressSecondary = 'Restauration en cours · {{processed}} sur {{total}} — {{progress}}%';
z.string.fr.backupImportSuccessHeadline = 'L’historique a été restauré.';
z.string.fr.backupCancel = 'Annuler';
z.string.fr.backupTryAgain = 'Réessayez';

z.string.fr.searchConnect = 'Se connecter';
z.string.fr.searchConnections = 'Contacts';
z.string.fr.searchContacts = 'Contacts';
z.string.fr.searchCreateGroup = 'Créer un groupe';
z.string.fr.searchCreateGuestRoom = 'Créer un espace pour invités';
z.string.fr.searchGroups = 'Groupes';
z.string.fr.searchPeople = 'Personnes';
z.string.fr.searchPlaceholder = 'Chercher par nom ou par identifiant';
z.string.fr.searchServicePlaceholder = 'Rechercher par nom';
z.string.fr.searchServices = 'Services';
z.string.fr.searchManageServices = 'Gérer les Services';
z.string.fr.searchManageServicesNoResults = 'Gérer les services';
z.string.fr.searchNoServicesManager = 'Les services sont des programmes qui peuvent améliorer votre flux de travail.';
z.string.fr.searchNoServicesMember = 'Les services sont des programmes qui peuvent améliorer votre flux de travail. Pour les activer, contactez votre administrateur.';
z.string.fr.searchTeamGroups = 'Conversations d’équipe';
z.string.fr.searchTeamMembers = 'Membres de l’équipe';
z.string.fr.searchTopPeople = 'Contacts favoris';
z.string.fr.searchTrySearch = 'Trouver des contacts par\nnom ou identifiant';
z.string.fr.searchNoContactsOnWire = 'Vous n’avez pas de contacts sur Wire.\nEssayez de trouver des gens par\nleur nom ou leur nom d’utilisateur.';
z.string.fr.searchMemberInvite = 'Inviter des personnes à rejoindre l’équipe';
z.string.fr.searchOthers = 'Se connecter';

z.string.fr.searchInvite = 'Invitez des personnes à rejoindre Wire';
z.string.fr.searchInviteDetail = 'Partager vos contacts vous permet de vous connecter à d’autres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne d’autre.';
z.string.fr.searchInviteButtonContacts = 'Depuis vos contacts';
z.string.fr.searchInviteButtonGmail = 'Depuis Gmail';
z.string.fr.searchInviteHeadline = 'Invitez vos amis';
z.string.fr.searchInviteShare = 'Partagez vos contacts';

z.string.fr.searchServiceConfirmButton = 'Ajouter un service';

z.string.fr.searchListEveryoneParticipates = 'Toutes les personnes\navec qui vous êtes connecté(e)\nsont déjà dans cette conversation.';
z.string.fr.searchListNoMatches = 'Aucun résultat.\nEssayez avec un nom différent.';

z.string.fr.temporaryGuestCta = 'Créer un compte';
z.string.fr.temporaryGuestDescription = 'Protégez votre activité avec des messages de groupe et des appels chiffrés.';
z.string.fr.temporaryGuestTimeRemaining = ' restants dans cet espace pour invités';

z.string.fr.temporaryGuestJoinMessage = 'Cette conversation vous sera accessible pendant 24 heures.';
z.string.fr.temporaryGuestJoinDescription = 'Si vous fermez ou rafraîchissez cette page, votre accès sera perdu.';

z.string.fr.temporaryGuestLeaveMessage = ' ne font plus partie de cette conversation.';
z.string.fr.temporaryGuestLeaveDescription = 'Si vous fermez ou rafraîchissez cette page, votre n’aurez plus accès à l’historique de cette conversation.';

z.string.fr.uploadGoogleHeadline = 'Trouvez des personnes\nà qui parler.';
z.string.fr.uploadGoogleMessage = 'Nous utilisons les données de vos contacts afin de vous connecter à d’autres personnes. Nous anonymisons toutes les informations et ne les partageons avec personne d’autre.';

z.string.fr.urlSupportRoot = '/';
z.string.fr.urlWebappRoot = '/';
z.string.fr.urlWebsiteRoot = '/';
z.string.fr.urlWebsiteCreateTeam = '/create-team/';
z.string.fr.warningCallUnsupportedIncoming = '{{user}} vous appelle. Votre navigateur ne prend pas en charge les appels.';
z.string.fr.warningCallUnsupportedOutgoing = 'Vous ne pouvez pas appeler parce que votre navigateur ne prend pas en charge les appels.';
z.string.fr.warningCallIssues = 'Cette version de Wire ne peut pas participer à cet appel. Utilisez plutôt';
z.string.fr.warningCallUpgradeBrowser = 'Pour pouvoir appeler, mettez à jour Google Chrome.';
z.string.fr.warningConnectivityConnectionLost = 'Tentative de connexion. Wire n’est peut-être pas en mesure d’envoyer des messages.';
z.string.fr.warningConnectivityNoInternet = 'Pas de connexion Internet. Vous ne pourrez pas envoyer ou recevoir de messages.';
z.string.fr.warningLearnMore = 'En savoir plus';
z.string.fr.warningLifecycleUpdate = 'Une nouvelle version de Wire est disponible.';
z.string.fr.warningLifecycleUpdateNotes = 'Nouveautés';
z.string.fr.warningLifecycleUpdateLink = 'Mettre à jour maintenant';
z.string.fr.warningNotFoundCamera = 'Vous ne pouvez pas appeler car votre ordinateur ne dispose pas d’une webcam.';
z.string.fr.warningNotFoundMicrophone = 'Vous ne pouvez pas appeler car votre ordinateur ne dispose pas d’un micro.';
z.string.fr.warningPermissionDeniedCamera = 'Vous ne pouvez pas appeler car votre navigateur n’a pas accès à votre webcam.';
z.string.fr.warningPermissionDeniedMicrophone = 'Vous ne pouvez pas appeler car votre navigateur n’a pas accès à votre micro.';
z.string.fr.warningPermissionDeniedScreen = 'Votre navigateur a besoin de votre permission pour partager votre écran.';
z.string.fr.warningPermissionRequestCamera = '{{icon}} Autoriser l’accès à la webcam';
z.string.fr.warningPermissionRequestMicrophone = '{{icon}} Autoriser l’accès au micro';
z.string.fr.warningPermissionRequestNotification = '{{icon}} Autoriser les notifications';
z.string.fr.warningPermissionRequestScreen = '{{icon}} Autoriser l’accès à l’écran';

z.string.fr.userAvailabilityAvailable = 'Disponible';
z.string.fr.userAvailabilityAway = 'Absent(e)';
z.string.fr.userAvailabilityBusy = 'Occupé(e)';
z.string.fr.userAvailabilityNone = 'Aucune';

z.string.fr.notificationAssetAdd = 'A partagé une image';
z.string.fr.notificationConnectionAccepted = 'A accepté votre demande de connexion';
z.string.fr.notificationConnectionConnected = 'Vous êtes connecté';
z.string.fr.notificationConnectionRequest = 'Souhaite se connecter';
z.string.fr.notificationConversationCreate = '{{user}} a commencé une conversation';
z.string.fr.notificationConversationMessageTimerUpdate = '{{user}} a défini les messages éphémères à {{time}}';
z.string.fr.notificationConversationMessageTimerReset = '{{user}} a désactivé les messages éphémères';
z.string.fr.notificationConversationRename = '{{user}} a renommé la conversation en {{name}}';
z.string.fr.notificationMemberJoinMany = '{{user}} a ajouté {{number}} personnes à la conversation';
z.string.fr.notificationMemberJoinSelf = '{{user}} a rejoint la conversation';
z.string.fr.notificationMemberJoinOne = '{{user1}} a ajouté {{user2}} à la conversation';
z.string.fr.notificationMemberLeaveRemovedYou = '{{user}} vous a exclu de la conversation';
z.string.fr.notificationMention = 'Nouvelle mention :';
z.string.fr.notificationObfuscated = 'vous a envoyé un message';
z.string.fr.notificationObfuscatedMention = 'Vous a mentionné';
z.string.fr.notificationObfuscatedReply = 'Vous a répondu';
z.string.fr.notificationObfuscatedTitle = 'Quelqu’un';
z.string.fr.notificationPing = 'a fait un signe';
z.string.fr.notificationReaction = '{{reaction}} votre message';
z.string.fr.notificationReply = 'Réponse : {{text}}';
z.string.fr.notificationSharedAudio = 'A partagé un message vocal';
z.string.fr.notificationSharedFile = 'A partagé un fichier';
z.string.fr.notificationSharedLocation = 'A partagé une position';
z.string.fr.notificationSharedVideo = 'A partagé une vidéo';
z.string.fr.notificationTitleGroup = '{{user}} dans {{conversation}}';
z.string.fr.notificationVoiceChannelActivate = 'Appel en cours';
z.string.fr.notificationVoiceChannelDeactivate = 'vous a appelé';

z.string.fr.tooltipConversationAllVerified = 'Toutes les empreintes sont vérifiées';
z.string.fr.tooltipConversationCall = 'Appeler';
z.string.fr.tooltipConversationEphemeral = 'Message éphémère';
z.string.fr.tooltipConversationFile = 'Ajouter un fichier';
z.string.fr.tooltipConversationInputPlaceholder = 'Écrivez un message';
z.string.fr.tooltipConversationInputPlaceholderAvailable = '{{user}} est disponible';
z.string.fr.tooltipConversationInputPlaceholderAway = '{{user}} est absent(e)';
z.string.fr.tooltipConversationInputPlaceholderBusy = '{{user}} est occupé(e)';
z.string.fr.tooltipConversationPeople = 'Personnes ({{shortcut}})';
z.string.fr.tooltipConversationPicture = 'Ajouter une image';
z.string.fr.tooltipConversationPing = 'Faire un signe ({{shortcut}})';
z.string.fr.tooltipConversationSearch = 'Recherche';
z.string.fr.tooltipConversationVideoCall = 'Appel vidéo';

z.string.fr.tooltipConversationsArchive = 'Archiver ({{shortcut}})';
z.string.fr.tooltipConversationsArchived = 'Voir les archives ({{number}})';
z.string.fr.tooltipConversationsMore = 'Plus';
z.string.fr.tooltipConversationsNotifications = 'Ouvrir les paramètres de notifications ({{shortcut}})';
z.string.fr.tooltipConversationsNotify = 'Activer les notifications ({{shortcut}})';
z.string.fr.tooltipConversationsPreferences = 'Ouvrir les préférences';
z.string.fr.tooltipConversationsSilence = 'Désactiver les notifications ({{shortcut}})';
z.string.fr.tooltipConversationsStart = 'Commencer une conversation ({{shortcut}})';

z.string.fr.tooltipConversationDetailsAddPeople = 'Ajouter des participants à la conversation ({{shortcut}})';
z.string.fr.tooltipConversationDetailsRename = 'Changer le nom de la conversation';

z.string.fr.tooltipPreferencesContactsGmail = 'Connectez-vous à votre compte Gmail pour importer des contacts';
z.string.fr.tooltipPreferencesContactsMacos = 'Partagez tous vos contacts depuis l’application Contacts de macOS';
z.string.fr.tooltipPreferencesPassword = 'Ouvre une page web pour réinitialiser votre mot de passe';
z.string.fr.tooltipPreferencesPicture = 'Changez votre image de profil…';
z.string.fr.tooltipPreferencesRename = 'Changez votre nom';

z.string.fr.tooltipSearchClose = 'Fermer (Échap)';

z.string.fr.initReceivedSelfUser = 'Bonjour, {{user}}.';
z.string.fr.initValidatedClient = 'Téléchargement de vos contacts et de vos conversations';
z.string.fr.initReceivedUserData = 'Recherche de nouveaux messages';
z.string.fr.initDecryption = 'Déchiffrement des messages';
z.string.fr.initEvents = 'Chargement des messages';
z.string.fr.initUpdatedFromNotifications = 'Presque terminé - Profitez de Wire';
z.string.fr.initProgress = ' — {{number1}} sur {{number2}}';

z.string.fr.ephemeralUnitsNone = 'Désactiver';
z.string.fr.ephemeralUnitsSecond = 'seconde';
z.string.fr.ephemeralUnitsSeconds = 'secondes';
z.string.fr.ephemeralUnitsMinute = 'minute';
z.string.fr.ephemeralUnitsMinutes = 'minutes';
z.string.fr.ephemeralUnitsHour = 'heure';
z.string.fr.ephemeralUnitsHours = 'heures';
z.string.fr.ephemeralUnitsDay = 'jour';
z.string.fr.ephemeralUnitsDays = 'jours';
z.string.fr.ephemeralUnitsWeek = 'semaine';
z.string.fr.ephemeralUnitsWeeks = 'semaines';
z.string.fr.ephemeralUnitsYear = 'année';
z.string.fr.ephemeralUnitsYears = 'années';
z.string.fr.ephemeralRemaining = 'restant';

z.string.fr.replyAudioMessage = 'Message vocal';
z.string.fr.replyQuoteError = 'Vous ne pouvez pas voir ce message.';
z.string.fr.replyQuoteShowMore = 'Plus';
z.string.fr.replyQuoteShowLess = 'Réduire';
z.string.fr.replyQuoteTimeStampDate = 'Message original du {{date}}';
z.string.fr.replyQuoteTimeStampTime = 'Message original de {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.hr.wireMacos = 'Wire za macOS';
z.string.hr.wireWindows = 'Wire za Windows';
z.string.hr.wireLinux = 'Wire za Linux';
z.string.hr.nonexistentUser = 'Izbrisani korisnik';
z.string.hr.and = 'i';

z.string.hr.authAccountCountryCode = 'Pozivni broj';
z.string.hr.authAccountPasswordForgot = 'Zaboravljena lozinka';
z.string.hr.authAccountSignIn = 'Prijava';
z.string.hr.authAccountSignInPhone = 'Telefon';

z.string.hr.authVerifyAccountAdd = 'Dodaj';
z.string.hr.authVerifyAccountDetail = 'Ovo Vam omogućuje da koristite Wire na više uređaja.';
z.string.hr.authVerifyAccountHeadline = 'Dodajte email adresu i lozinku.';
z.string.hr.authVerifyAccountLogout = 'Odjava';
z.string.hr.authVerifyCodeDescription = 'Unesite kontrolni kod koji smo poslali na {{number}}.';
z.string.hr.authVerifyCodeResend = 'Kod se ne pojavljuje?';
z.string.hr.authVerifyCodeResendDetail = 'Ponovno pošalji';
z.string.hr.authVerifyCodeResendTimer = 'Možete zatražiti novi kod {{expiration}}.';
z.string.hr.authVerifyCodeChangePhone = 'Promjeni broj telefona';
z.string.hr.authVerifyPasswordHeadline = 'Upišite Vašu šifru';

z.string.hr.authLimitDevicesHeadline = 'Uređaji';
z.string.hr.authLimitDescription = 'Uklonite jedan od Vaših ostalih uređaja kako bi ste počeli koristiti Wire na ovom.';
z.string.hr.authLimitButtonManage = 'Upravljanje uređajima';
z.string.hr.authLimitButtonSignOut = 'Odjava';
z.string.hr.authLimitDevicesCurrent = '(Trenutno)';

z.string.hr.authHistoryHeadline = 'Ovo je prvi put da koristite Wire na ovom uređaju.';
z.string.hr.authHistoryDescription = 'Iz sigurnosnih razloga, povijest razgovora se neće pojaviti ovdje.';
z.string.hr.authHistoryReuseHeadline = 'Već ste upotrebljavali Wire na ovom uređaju.';
z.string.hr.authHistoryReuseDescription = 'Poruke poslane u međuvremenu neće se pojaviti.';
z.string.hr.authHistoryButton = 'U redu';

z.string.hr.authPostedResend = 'Ponovno pošalji na {{email}}';
z.string.hr.authPostedResendAction = 'Email se ne pojavljuje?';
z.string.hr.authPostedResendDetail = 'Provjerite svoj email sandučić i slijedite upute.';
z.string.hr.authPostedResendHeadline = 'Imate poštu.';

z.string.hr.authPlaceholderEmail = 'Email';
z.string.hr.authPlaceholderPasswordPut = 'Lozinka';
z.string.hr.authPlaceholderPasswordSet = 'Lozinka (najmanje 8 znakova)';
z.string.hr.authPlaceholderPhone = 'Telefonski broj';

z.string.hr.authErrorCode = 'Neispravan kod';
z.string.hr.authErrorCountryCodeInvalid = 'Nevažeći kod države';
z.string.hr.authErrorEmailExists = 'Email adresa je već u upotrebi';
z.string.hr.authErrorEmailForbidden = 'Ova email adresa je zabranjena.';
z.string.hr.authErrorEmailMalformed = 'Molimo unesite ispravnu e-mail adresu.';
z.string.hr.authErrorEmailMissing = 'Molimo unesite email adresu.';
z.string.hr.authErrorMisc = 'Problemi s vezom. Molimo pokušajte ponovo.';
z.string.hr.authErrorNameShort = 'Unesite naziv s najmanje 2 znaka';
z.string.hr.authErrorOffline = 'Nema internetske veze';
z.string.hr.authErrorPasswordShort = 'Odaberite lozinku s najmanje 8 znakova.';
z.string.hr.authErrorPasswordWrong = 'Pogrešna lozinka, molimo pokušajte ponovno.';
z.string.hr.authErrorPhoneNumberForbidden = 'Ova email adresa je zabranjena.';
z.string.hr.authErrorPhoneNumberInvalid = 'Nevažeći broj';
z.string.hr.authErrorPhoneNumberUnknown = 'Nepoznat broj';
z.string.hr.authErrorSignIn = 'Molimo provjerite vaše podatke i pokušajte ponovno.';

z.string.hr.callStateOutgoing = 'Zvoni...';
z.string.hr.callStateConnecting = 'Povezivanje…';
z.string.hr.callStateIncoming = 'Pozivanje…';
z.string.hr.callDecline = 'Odbij';
z.string.hr.callAccept = 'Prihvati';
z.string.hr.callJoin = 'Pridruži se';
z.string.hr.callChooseSharedScreen = 'Odaberite zaslon za zajedničko korištenje';

z.string.hr.videoCallOverlayMute = 'Isključi zvuk';
z.string.hr.videoCallOverlayHangUp = 'Poklopi';

z.string.hr.modalAcknowledgeAction = 'Ok';
z.string.hr.modalConfirmSecondary = 'Odustani';
z.string.hr.modalOptionSecondary = 'Odustani';

z.string.hr.modalAccountCreateAction = 'U redu';

z.string.hr.modalAccountDeletionAction = 'Obriši';
z.string.hr.modalAccountDeletionHeadline = 'Brisanje računa';
z.string.hr.modalAccountDeletionMessage = 'Poslati ćemo Vam poslati poruku putem e-maila ili SMS-a. Slijedite link za trajno brisanje računa.';

z.string.hr.modalAccountLeaveGuestRoomAction = 'Izađi';

z.string.hr.modalAccountLogoutAction = 'Odjava';
z.string.hr.modalAccountLogoutHeadline = 'Obriši podatke?';
z.string.hr.modalAccountLogoutOption = 'Izbriši sve osobne informacije i razgovore na ovom uređaju.';

z.string.hr.modalAccountNewDevicesSecondary = 'Upravljanje uređajima';
z.string.hr.modalAccountNewDevicesHeadline = 'Vaš račun je korišten na:';
z.string.hr.modalAccountNewDevicesFrom = 'Šalje:';
z.string.hr.modalAccountNewDevicesMessage = 'Ako niste to učinili, uklonite uređaj i ponovno postavite lozinku.';

z.string.hr.modalAccountRemoveDeviceAction = 'Uklanjanje uređaja';
z.string.hr.modalAccountRemoveDeviceHeadline = 'Uklanjanje "{{device}}"';
z.string.hr.modalAccountRemoveDeviceMessage = 'Lozinka potrebna za uklanjanje uređaja.';
z.string.hr.modalAccountRemoveDevicePlaceholder = 'Lozinka';

z.string.hr.modalAssetTooLargeMessage = 'Možete poslati datoteke do {{number}}';

z.string.hr.modalAssetParallelUploadsMessage = 'Možete poslati {{number}} datoteke odjednom.';

z.string.hr.modalCallEmptyConversationHeadline = 'Nemam koga zvati';
z.string.hr.modalCallEmptyConversationMessage = 'Nema osoba u konverzaciji.';

z.string.hr.modalCallNoGroupVideoHeadline = 'Nema video poziva u grupama';
z.string.hr.modalCallNoGroupVideoMessage = 'Video pozivi nisu dostupni u grupnim razgovorima.';

z.string.hr.modalCallNoMicrophoneAction = 'Recite mi kako';
z.string.hr.modalCallNoMicrophoneMessage = 'Your browser needs access to the microphone to make calls.';
z.string.hr.modalCallNoMicrophoneHeadline = 'Poziv nije moguć bez mikrofona';

z.string.hr.modalCallSecondIncomingAction = 'Odgovori';
z.string.hr.modalCallSecondIncomingHeadline = 'Odgovoriti na poziv?';
z.string.hr.modalCallSecondIncomingMessage = 'Vaš trenutni poziv će završiti.';

z.string.hr.modalCallSecondOngoingAction = 'Poklopi';
z.string.hr.modalCallSecondOngoingHeadline = 'Prekini poziv na drugom uređaju?';
z.string.hr.modalCallSecondOngoingMessage = 'Možete biti u samo jednom pozivu u isto vrijeme.';

z.string.hr.modalCallSecondOutgoingAction = 'Poklopi';
z.string.hr.modalCallSecondOutgoingHeadline = 'Prekinuti trenutni poziv?';
z.string.hr.modalCallSecondOutgoingMessage = 'Možete biti u samo jednom pozivu u isto vrijeme.';

z.string.hr.modalConnectCancelAction = 'Da';
z.string.hr.modalConnectCancelHeadline = 'Poništiti zahtjev?';
z.string.hr.modalConnectCancelMessage = 'Uklanjanje zahtjeva za povezivanje s {{user}}.';
z.string.hr.modalConnectCancelSecondary = 'Ne';

z.string.hr.modalConnectAcceptAction = 'Poveži se';
z.string.hr.modalConnectAcceptHeadline = 'Prihvatiti?';
z.string.hr.modalConnectAcceptMessage = 'Ovo će vas spojiti i otvoriti razgovor s {{user}}.';
z.string.hr.modalConnectAcceptSecondary = 'Ignoriraj';

z.string.hr.modalConversationClearAction = 'Obriši';
z.string.hr.modalConversationClearHeadline = 'Izbrisati sadržaj?';
z.string.hr.modalConversationClearOption = 'Također napusti razgovor';

z.string.hr.modalConversationDeleteMessageAction = 'Obriši';
z.string.hr.modalConversationDeleteMessageHeadline = 'Izbriši samo za mene?';
z.string.hr.modalConversationDeleteMessageMessage = 'Ovo se ne može poništiti.';

z.string.hr.modalConversationDeleteMessageEveryoneAction = 'Obriši';
z.string.hr.modalConversationDeleteMessageEveryoneHeadline = 'Izbriši za sve?';
z.string.hr.modalConversationDeleteMessageEveryoneMessage = 'Ovo se ne može poništiti.';

z.string.hr.modalConversationLeaveAction = 'Izađi';
z.string.hr.modalConversationLeaveMessage = 'Nećete moći slati ili primati poruke u ovom razgovoru.';

z.string.hr.modalConversationMessageTooLongHeadline = 'Poruka preduga';
z.string.hr.modalConversationMessageTooLongMessage = 'Možete slati poruke do {{number}} znakova.';

z.string.hr.modalConversationNewDeviceHeadlineOne = '{{user}} počeo koristiti novi uređaj';
z.string.hr.modalConversationNewDeviceHeadlineMany = '{{users}} je počeo/ počela koristiti nove uređaje';
z.string.hr.modalConversationNewDeviceHeadlineYou = '{{user}} počeo koristiti novi uređaj';
z.string.hr.modalConversationNewDeviceMessage = 'Još uvijek želite poslati poruku?';
z.string.hr.modalConversationNewDeviceOutgoingCallAction = 'Svejedno iniciraj poziv';

z.string.hr.modalConversationNotConnectedMessageOne = '{{name}} ne želi biti dodan/a razgovorima.';
z.string.hr.modalConversationNotConnectedMessageMany = 'Jedna od osoba koje ste odabrali ne želi biti dodana u razgovore.';

z.string.hr.modalConversationRemoveAction = 'Ukloni';
z.string.hr.modalConversationRemoveHeadline = 'Ukloniti?';
z.string.hr.modalConversationRemoveMessage = '{{user}} neće moći slati ili primati poruke u ovom razgovoru.';

z.string.hr.modalConversationRemoveGuestsAction = 'Ukloni';

z.string.hr.modalConversationTooManyMembersHeadline = 'Puna kuća';



z.string.hr.modalImproveWireAction = 'Prihvati';
z.string.hr.modalImproveWireSecondary = 'Ne';

z.string.hr.modalSessionResetHeadline = 'Sesija je resetirana';
z.string.hr.modalSessionResetMessage1 = 'Ako problem nije razriješen,';
z.string.hr.modalSessionResetMessageLink = 'kontaktirajte';
z.string.hr.modalSessionResetMessage2 = 'nas.';

z.string.hr.modalUploadContactsAction = 'Pokušaj ponovno';
z.string.hr.modalUploadContactsMessage = 'Nismo dobili podatke. Pokušajte ponovno uvesti svoje kontakte.';

z.string.hr.modalUserBlockAction = 'Blokiraj';
z.string.hr.modalUserBlockHeadline = 'Blokiraj {{user}}?';
z.string.hr.modalUserBlockMessage = '{{user}} neće biti u mogućnosti kontaktirati vas ili vas pozvati u grupnu konverzaciju.';

z.string.hr.modalUserUnblockAction = 'Odblokiraj';
z.string.hr.modalUserUnblockHeadline = 'Odblokirati?';

z.string.hr.connectionRequestConnect = 'Poveži se';
z.string.hr.connectionRequestIgnore = 'Ignoriraj';

z.string.hr.conversationYouNominative = 'ti';
z.string.hr.conversationYouDative = 'ti';
z.string.hr.conversationYouAccusative = 'ti';

z.string.hr.conversationConnectionAccepted = 'Povezani';
z.string.hr.conversationConnectionBlocked = 'Blokiran';
z.string.hr.conversationConnectionCancelRequest = 'Odjavi zahtjev za vezu';
z.string.hr.conversationDeviceStartedUsingOne = ' počela/o koristiti';
z.string.hr.conversationDeviceStartedUsingMany = ' počela/o koristiti';
z.string.hr.conversationDeviceUnverified = ' neverificirala/o je jedan od';
z.string.hr.conversationDeviceYourDevices = ' tvojih uređaja';
z.string.hr.conversationDeviceUserDevices = ' {{user}} uređaji';
z.string.hr.conversationDeviceNewDeviceOne = ' novi uređaj';
z.string.hr.conversationDeviceNewDeviceMany = ' novi uređaji';
z.string.hr.conversationJustNow = 'Upravo';
z.string.hr.conversationLocationLink = 'Otvori kartu';
z.string.hr.conversationMessageDelivered = 'Dostavljeno';
z.string.hr.conversationRename = ' preimenovala/o razgovor';
z.string.hr.conversationRenameYou = ' preimenovala/o razgovor';
z.string.hr.conversationResume = 'Započni razgovor s {{users}}';
z.string.hr.conversationPing = ' pingala/o';
z.string.hr.conversationPingYou = ' pingala/o';
z.string.hr.conversationToday = 'danas';
z.string.hr.conversationVoiceChannelDeactivate = ' zvao';
z.string.hr.conversationVoiceChannelDeactivateYou = ' zvao';
z.string.hr.conversationYesterday = 'Jučer';
z.string.hr.conversationUnableToDecrypt1 = 'poruka od {{user}} nije primljena.';
z.string.hr.conversationUnableToDecrypt2 = '{{user}} identitet uređaja promijenjen. Neisporučena poruka.';
z.string.hr.conversationUnableToDecryptLink = 'Zašto?';
z.string.hr.conversationUnableToDecryptErrorMessage = 'Pogreška';
z.string.hr.conversationUnableToDecryptResetSession = 'Resetiraj sesiju';
z.string.hr.conversationMissedMessages = 'Niste upotrebljavali ovaj uređaj neko vrijeme. Neke poruke možda neće biti vidljive na njemu.';
z.string.hr.conversationAssetDownloading = 'Preuzimanje…';
z.string.hr.conversationAssetUploadFailed = 'Prijenos neuspješan';
z.string.hr.conversationPlaybackError = 'Reprodukcija neuspješna';
z.string.hr.conversationContextMenuCopy = 'Kopiraj';
z.string.hr.conversationContextMenuEdit = 'Promjeni';
z.string.hr.conversationContextMenuDelete = 'Brisanje poruke za mene';
z.string.hr.conversationContextMenuDeleteEveryone = 'Brisanje poruke za sve sudionike';
z.string.hr.conversationContextMenuDownload = 'Preuzimanje';
z.string.hr.conversationContextMenuLike = 'Sviđa mi se';
z.string.hr.conversationContextMenuUnlike = 'Ne sviđa mi se';
z.string.hr.conversationDeleteTimestamp = 'Izbrisano na {{date}}';
z.string.hr.conversationEditTimestamp = 'Promijenjeno na {{date}}';
z.string.hr.conversationLikesCaption = '{{number}} ljudi';
z.string.hr.conversationSendPastedFile = 'Slika zaljepljena na {{date}}';
z.string.hr.conversationSomeone = 'Netko';
z.string.hr.conversationTweetAuthor = ' na Twitteru';

z.string.hr.groupCreationParticipantsPlaceholder = 'Traži po imenu';


z.string.hr.collectionSectionLinks = 'Linkovi';
z.string.hr.collectionSectionImages = 'Slike';
z.string.hr.collectionSectionFiles = 'Dokumenti';

z.string.hr.fullsearchPlaceholder = 'Pretraži poruke';
z.string.hr.fullsearchNoResults = 'Nema rezultata.';

z.string.hr.archiveHeader = 'Arhiviraj';

z.string.hr.conversationsAllArchived = 'Sve arhivirano';
z.string.hr.conversationsContacts = 'Kontakti';
z.string.hr.conversationsConnectionRequestMany = '{{number}} ljudi čekaju';
z.string.hr.conversationsConnectionRequestOne = '1 osoba čeka';
z.string.hr.conversationsEmptyConversation = 'Grupni razgovor';
z.string.hr.conversationsNoConversations = 'Nema razgovora';
z.string.hr.conversationsPopoverArchive = 'Arhiviraj';
z.string.hr.conversationsPopoverCancel = 'Poništi zahtjev';
z.string.hr.conversationsPopoverNotify = 'Uključi zvuk';
z.string.hr.conversationsPopoverSilence = 'Isključi zvuk';
z.string.hr.conversationsPopoverUnarchive = 'Dearhiviraj';

z.string.hr.conversationsSecondaryLineEphemeralMessage = 'Poslao ti je poruku';

z.string.hr.takeoverSub = 'Zatražite svoje jedinstveno ime na Wire.';
z.string.hr.takeoverLink = 'Saznaj više';
z.string.hr.takeoverButtonChoose = 'Odaberite vlastitu';
z.string.hr.takeoverButtonKeep = 'Zadrži ovu';

z.string.hr.inviteMetaKeyMac = 'Cmd';
z.string.hr.inviteMetaKeyPc = 'Ctrl';
z.string.hr.inviteHeadline = 'Pozvati ljude na Wire';

z.string.hr.extensionsBubbleButtonGif = 'Gif';

z.string.hr.extensionsGiphyButtonOk = 'Pošalji';
z.string.hr.extensionsGiphyButtonMore = 'Probaj nešto drugo';
z.string.hr.extensionsGiphyMessage = '• {{tag}} s giphy.com';
z.string.hr.extensionsGiphyNoGifs = 'Ups, nema Gif-ova';
z.string.hr.extensionsGiphyRandom = 'Nasumično';

z.string.hr.addParticipantsConfirmLabel = 'Dodaj';
z.string.hr.addParticipantsSearchPlaceholder = 'Traži po imenu';
z.string.hr.addParticipantsTabsPeople = 'Kontakti';
z.string.hr.addParticipantsTabsServices = 'Usluge';

z.string.hr.conversationDetailsActionArchive = 'Arhiviraj';
z.string.hr.conversationDetailsActionCancelRequest = 'Poništi zahtjev';
z.string.hr.conversationDetailsActionDevices = 'Uređaji';
z.string.hr.conversationDetailsActionNotifications = 'Obavijesti';
z.string.hr.conversationDetailsGuestsOff = 'Isključi';
z.string.hr.conversationDetailsOptions = 'Opcije';
z.string.hr.conversationDetailsParticipantsServicesMany = 'Usluge';
z.string.hr.conversationDetailsParticipantsUsersMany = 'Kontakti';
z.string.hr.conversationDetailsPeople = 'Kontakti';
z.string.hr.conversationDetailsServices = 'Usluge';

z.string.hr.conversationParticipantsTitle = 'Kontakti';
z.string.hr.conversationParticipantsSearchPlaceholder = 'Traži po imenu';

z.string.hr.groupParticipantActionCancelRequest = 'Poništi zahtjev';
z.string.hr.groupParticipantActionDevices = 'Uređaji';
z.string.hr.groupParticipantActionPending = 'Na čekanju';
z.string.hr.groupParticipantActionSendRequest = 'Poveži se';

z.string.hr.notificationSettingsTitle = 'Obavijesti';

z.string.hr.participantDevicesDetailHeadline = 'Provjerite da je otisak prikazan na {{html1}}{{user}}’s device{{html2}}.';
z.string.hr.participantDevicesDetailHowTo = 'Kako to da učinim?';
z.string.hr.participantDevicesDetailResetSession = 'Resetiraj sesiju';
z.string.hr.participantDevicesDetailShowMyDevice = 'Pokaži otisak mog uređaja';
z.string.hr.participantDevicesDetailVerify = 'Verificirano';

z.string.hr.participantDevicesHeader = 'Uređaji';
z.string.hr.participantDevicesHeadline = 'Wire daje svakom uređaju jedinstveni otisak. Usporedite otiske s {{user}} da bi verificirali razgovor.';
z.string.hr.participantDevicesLearnMore = 'Saznaj više';
z.string.hr.participantDevicesWhyVerify = 'Zašto ovjeravati razgovore?';
z.string.hr.participantDevicesOutdatedClientMessage = '{{user}} koristi staru verziju Wire. Nema novih uređaja.';

z.string.hr.participantDevicesSelfAllDevices = 'Pokaži sve uređaje';
z.string.hr.participantDevicesSelfFingerprint = 'Otisak uređaja';

z.string.hr.userProfileButtonConnect = 'Poveži se';
z.string.hr.userProfileButtonIgnore = 'Ignoriraj';
z.string.hr.userProfileButtonUnblock = 'Odblokiraj';

z.string.hr.preferencesAbout = 'O programu';
z.string.hr.preferencesAccount = 'Račun';
z.string.hr.preferencesAV = 'Audio / Video';
z.string.hr.preferencesDeviceDetails = 'Detalji o uređaju';
z.string.hr.preferencesDevices = 'Uređaji';
z.string.hr.preferencesHeadline = 'Osobne postavke';
z.string.hr.preferencesOptions = 'Opcije';

z.string.hr.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.hr.preferencesAboutPrivacyPolicy = 'Pravilnik o zaštiti privatnosti';
z.string.hr.preferencesAboutSupport = 'Podrška';
z.string.hr.preferencesAboutSupportWebsite = 'Wire Podrška';
z.string.hr.preferencesAboutSupportContact = 'Kontaktirajte podršku';
z.string.hr.preferencesAboutTermsOfUse = 'Uvjeti uporabe';
z.string.hr.preferencesAboutVersion = 'Verzija {{version}}';
z.string.hr.preferencesAboutWebsite = 'Wire website';

z.string.hr.preferencesAccountDelete = 'Brisanje računa';
z.string.hr.preferencesAccountLogOut = 'Odjava';
z.string.hr.preferencesAccountResetPassword = 'Resetiraj lozinku';
z.string.hr.preferencesAccountUsernamePlaceholder = 'Vaše puno ime';
z.string.hr.preferencesAccountUsernameHint = 'Najmanje 2 znaka. Samo a-z, 0-9, i _.';
z.string.hr.preferencesAccountUsernameAvailable = 'Dostupno';
z.string.hr.preferencesAccountUsernameErrorTaken = 'Već uzeto';

z.string.hr.preferencesAVCamera = 'Kamera';
z.string.hr.preferencesAVMicrophone = 'Mikrofon';
z.string.hr.preferencesAVPermissionDetail = 'Omogućite iz opcija preglednika';
z.string.hr.preferencesAVSpeakers = 'Zvučnici';

z.string.hr.preferencesDevicesActivatedOn = 'Aktiviran u {{date}}';
z.string.hr.preferencesDevicesActive = 'Aktivno';
z.string.hr.preferencesDevicesActiveDetail = 'Ako ne prepoznajete neki od navedenih uređaja, uklonite ga i resetirajte Vašu lozinku.';
z.string.hr.preferencesDevicesCurrent = 'Trenutno';
z.string.hr.preferencesDevicesFingerprint = 'Otisak prsta';
z.string.hr.preferencesDevicesFingerprintDetail = 'Wire daje svakom uređaju jedinstveni otisak. Usporedite otiske da bi verificirali uređaje i razgovore.';
z.string.hr.preferencesDevicesId = 'ID: ';
z.string.hr.preferencesDevicesRemoveCancel = 'Odustani';
z.string.hr.preferencesDevicesRemoveDetail = 'Uklonite ovaj uređaj ako ste ga prestali koristiti. Odmah ćete biti automatski odjavljeni.';
z.string.hr.preferencesDevicesSessionConfirmation = 'Sesija je resetirana.';
z.string.hr.preferencesDevicesSessionDetail = 'Ako otisci prstiju ne odgovaraju, resetirajte sesiju da bi generirali nove ključeve za šifriranje na obje strane.';
z.string.hr.preferencesDevicesSessionReset = 'Resetiraj sesiju';
z.string.hr.preferencesDevicesSessionOngoing = 'Resetiranje sesije…';
z.string.hr.preferencesDevicesVerification = 'Verificirano';

z.string.hr.preferencesOptionsAudio = 'Zvukovi upozorenja';
z.string.hr.preferencesOptionsAudioAll = 'Svi';
z.string.hr.preferencesOptionsAudioAllDetail = 'Svi zvukovi';
z.string.hr.preferencesOptionsAudioNone = 'Ništa';
z.string.hr.preferencesOptionsAudioNoneDetail = 'Ššššš!';
z.string.hr.preferencesOptionsAudioSome = 'Neki';
z.string.hr.preferencesOptionsAudioSomeDetail = 'Pingovi i pozivi';
z.string.hr.preferencesOptionsContacts = 'Kontakti';
z.string.hr.preferencesOptionsContactsGmail = 'Uvezi iz Gmaila';
z.string.hr.preferencesOptionsContactsMacos = 'Uvezi iz kontakata';
z.string.hr.preferencesOptionsContactsDetail = 'Mi koristimo vaše kontakt podatke za povezivanje s drugima. Sve informacije su anonimiziane i nisu dijeljene s drugima.';
z.string.hr.preferencesOptionsNotifications = 'Obavijesti';
z.string.hr.preferencesOptionsNotificationsNone = 'Isključi';
z.string.hr.preferencesOptionsNotificationsObfuscate = 'Sakrij detalje';
z.string.hr.preferencesOptionsNotificationsOn = 'Prikaži pošiljatelja i poruku';

z.string.hr.backupCancel = 'Odustani';

z.string.hr.searchConnect = 'Poveži se';
z.string.hr.searchConnections = 'Veze';
z.string.hr.searchContacts = 'Kontakti';
z.string.hr.searchCreateGroup = 'Napravi grupu';
z.string.hr.searchGroups = 'Grupe';
z.string.hr.searchPeople = 'Kontakti';
z.string.hr.searchPlaceholder = 'Pretraži po imenu ili korisničkom imenu';
z.string.hr.searchServicePlaceholder = 'Traži po imenu';
z.string.hr.searchServices = 'Usluge';
z.string.hr.searchTopPeople = 'Top veze';
z.string.hr.searchTrySearch = 'Traženje ljudi po imenu ili korisničkom imenu';
z.string.hr.searchNoContactsOnWire = 'Nemate veza na Wire. Pokušajte pronaći ljude po imenu ili korisničkom imenu.';
z.string.hr.searchOthers = 'Poveži se';

z.string.hr.searchInviteButtonContacts = 'Iz kontakata';
z.string.hr.searchInviteButtonGmail = 'Iz Gmaila';
z.string.hr.searchInviteHeadline = 'Pozovi prijatelje';
z.string.hr.searchInviteShare = 'Podijeli kontakte';

z.string.hr.searchListEveryoneParticipates = 'Svi ljudi s kojima ste povezani su već u ovom razgovoru.';
z.string.hr.searchListNoMatches = 'Nema odgovarajućih rezultata. Pokušajte unijeti drugačije ime.';


z.string.hr.uploadGoogleHeadline = 'Pronađi ljude za razgovor.';
z.string.hr.uploadGoogleMessage = 'Mi koristimo vaše kontakt podatke za povezivanje s drugima. Sve informacije su anonimiziane i nisu dijeljene s drugima.';

z.string.hr.warningCallUnsupportedIncoming = '{{user}} zove. Vaš preglednik ne podržava pozive.';
z.string.hr.warningCallUnsupportedOutgoing = 'Poziv nije moguć jer vaš preglednik ne podržava pozive.';
z.string.hr.warningCallIssues = 'Ova verzija Wire nema pozive. Molimo vas da koristite';
z.string.hr.warningCallUpgradeBrowser = 'Da bi imali pozive, molimo ažurirajte Google Chrome.';
z.string.hr.warningConnectivityConnectionLost = 'Povezivanje u tijeku. Postoji mogućnost da Wire neće moći isporučiti poruke.';
z.string.hr.warningConnectivityNoInternet = 'Nema Interneta. Nećete moći slati ili primati poruke.';
z.string.hr.warningLearnMore = 'Saznaj više';
z.string.hr.warningLifecycleUpdate = 'Nova verzija Wire je dostupna.';
z.string.hr.warningLifecycleUpdateNotes = 'Što je novo';
z.string.hr.warningLifecycleUpdateLink = 'Ažuriraj sada';
z.string.hr.warningNotFoundCamera = 'Poziv nije moguć jer računalo nema kameru.';
z.string.hr.warningNotFoundMicrophone = 'Poziv nije moguć jer računalo nema mikrofon.';
z.string.hr.warningPermissionDeniedCamera = 'Poziv nije moguć jer računalo nema pristup kameri.';
z.string.hr.warningPermissionDeniedMicrophone = 'Poziv nije moguć jer računalo nema pristup mikrofonu.';
z.string.hr.warningPermissionDeniedScreen = 'Vaš preglednik treba dozvolu za zajedničko korištenje vašeg zaslona.';
z.string.hr.warningPermissionRequestCamera = '{{icon}} dopusti pristup kameri';
z.string.hr.warningPermissionRequestMicrophone = '{{icon}} dopusti pristup mikrofonu';
z.string.hr.warningPermissionRequestNotification = '{{icon}} Dopusti notifikacije';
z.string.hr.warningPermissionRequestScreen = '{{icon}} dopusti pristup zaslonu';

z.string.hr.userAvailabilityAvailable = 'Dostupno';
z.string.hr.userAvailabilityNone = 'Ništa';

z.string.hr.notificationAssetAdd = 'Podijelila/o sliku';
z.string.hr.notificationConnectionAccepted = 'Prihvatila/o zahtjev za vezu';
z.string.hr.notificationConnectionRequest = 'Želi se povezati';
z.string.hr.notificationConversationCreate = '{{user}} je započela/o razgovor';
z.string.hr.notificationConversationRename = '{{user}} je preimenovala/o razgovor u {{name}}';
z.string.hr.notificationMemberJoinMany = '{{user}} dodala/o {{number}} ljudi u razgovor';
z.string.hr.notificationMemberJoinOne = '{{user1}} dodala/o {{user2}} u razgovor';
z.string.hr.notificationMemberLeaveRemovedYou = '{{user}} vas je izbrisao / izbrisala iz razgovora';
z.string.hr.notificationObfuscated = 'Poslao ti je poruku';
z.string.hr.notificationObfuscatedTitle = 'Netko';
z.string.hr.notificationPing = 'Pingala/o';
z.string.hr.notificationReaction = '{{reaction}} tvoju poruku';
z.string.hr.notificationSharedAudio = 'Podijelila/o audio poruku';
z.string.hr.notificationSharedFile = 'Podijelila/o datoteku';
z.string.hr.notificationSharedLocation = 'Podijelila/o lokaciju';
z.string.hr.notificationSharedVideo = 'Podijelila/o video';
z.string.hr.notificationVoiceChannelActivate = 'Pozivanje';
z.string.hr.notificationVoiceChannelDeactivate = 'Zvala/o';

z.string.hr.tooltipConversationAllVerified = 'Svi otisci su verificirani';
z.string.hr.tooltipConversationCall = 'Poziv';
z.string.hr.tooltipConversationEphemeral = 'Odgođeno slanje';
z.string.hr.tooltipConversationFile = 'Dodaj datoteku';
z.string.hr.tooltipConversationInputPlaceholder = 'Upiši poruku';
z.string.hr.tooltipConversationPeople = 'Ljudi ({{shortcut}})';
z.string.hr.tooltipConversationPicture = 'Dodaj sliku';
z.string.hr.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.hr.tooltipConversationSearch = 'Traži';
z.string.hr.tooltipConversationVideoCall = 'Video poziv';

z.string.hr.tooltipConversationsArchive = 'Arhiva ({{shortcut}})';
z.string.hr.tooltipConversationsArchived = 'Pokaži arhivu ({{number}})';
z.string.hr.tooltipConversationsMore = 'Više';
z.string.hr.tooltipConversationsNotify = 'Uključi zvukove ({{shortcut}})';
z.string.hr.tooltipConversationsSilence = 'Isključi zvukove ({{shortcut}})';
z.string.hr.tooltipConversationsStart = 'Početak razgovora ({{shortcut}})';

z.string.hr.tooltipConversationDetailsRename = 'Promijeni naziv razgovora';

z.string.hr.tooltipPreferencesContactsGmail = 'Prijavite se na svoj Gmail račun za dijeljenje kontakata';
z.string.hr.tooltipPreferencesContactsMacos = 'Podijelite sve svoje kontakte s macOS Contacts aplikacijom';
z.string.hr.tooltipPreferencesPassword = 'Otvori web stranicu za ponovno postavljanje lozinke';
z.string.hr.tooltipPreferencesPicture = 'Promjena slike…';
z.string.hr.tooltipPreferencesRename = 'Promijeni ime';

z.string.hr.tooltipSearchClose = 'Zatvori (Esc)';

z.string.hr.initReceivedSelfUser = 'Pozdrav, {{user}}.';
z.string.hr.initValidatedClient = 'Učitavanje veze i razgovora';
z.string.hr.initReceivedUserData = 'Provjeravanje novih poruka';
z.string.hr.initEvents = 'Učitavanje poruka';

z.string.hr.ephemeralUnitsNone = 'Isključi';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use=szigorú';

z.string.hu.wire = 'Wire';
z.string.hu.wireMacos = 'Wire MacOS-hez';
z.string.hu.wireWindows = 'Wire Windowshoz';
z.string.hu.wireLinux = 'Wire Linuxhoz';
z.string.hu.nonexistentUser = 'Törölt felhasználó';
z.string.hu.and = 'és';
z.string.hu.enumerationAnd = 'és ';

//=Alkalmazás betöltése
z.string.hu.authAccountCountryCode = 'Országhívó-kód';
z.string.hu.authAccountPasswordForgot = 'Elfelejtett jelszó';
z.string.hu.authAccountPublicComputer = 'Ez egy nyilvános számítógép';
z.string.hu.authAccountSignIn = 'Bejelentkezés';
z.string.hu.authAccountSignInPhone = 'Telefonos bejelentkezés';

z.string.hu.authBlockedCookies = 'A bejelentkezéshez engedélyezni kell a böngésző-sütiket.';
z.string.hu.authBlockedDatabase = 'Az üzenetek megjelenítéséhez a Wire-nek el kell érnie a helyi tárhelyet. A böngésző privát módú használatakor a helyi tárhely nem áll rendelkezésre.';
z.string.hu.authBlockedTabs = 'A Wire már nyitva van egy másik böngészőlapon.';
z.string.hu.authBlockedTabsAction = 'Inkább használjuk ezt a fület';

z.string.hu.authVerifyAccountAdd = 'Hozzáadás';
z.string.hu.authVerifyAccountDetail = 'Ezáltal akár több eszközön is használhatod a Wire-t.';
z.string.hu.authVerifyAccountHeadline = 'E-mail cím és jelszó megadása.';
z.string.hu.authVerifyAccountLogout = 'Kijelentkezés';
z.string.hu.authVerifyCodeDescription = 'Írd be az ellenőrző kódot,\namit a {{number}} telefonszámra küldtünk.';
z.string.hu.authVerifyCodeResend = 'Nem kaptál kódot?';
z.string.hu.authVerifyCodeResendDetail = 'Újraküldés';
z.string.hu.authVerifyCodeResendTimer = 'Új kódot kérhetsz {{expiration}} múlva.';
z.string.hu.authVerifyCodeChangePhone = 'Telefonszám módosítása';
z.string.hu.authVerifyPasswordHeadline = 'Add meg a jelszavad';

z.string.hu.authLimitDevicesHeadline = 'Eszközök';
z.string.hu.authLimitDescription = 'Ahhoz, hogy használni tudd a Wire-t ezen az eszközön, először távolítsd el azt valamelyik másikról.';
z.string.hu.authLimitButtonManage = 'Eszközök kezelése';
z.string.hu.authLimitButtonSignOut = 'Kijelentkezés';
z.string.hu.authLimitDevicesCurrent = '(Ez az eszköz)';

z.string.hu.authHistoryHeadline = 'Első alkalommal használod a Wire-t ezen az eszközön.';
z.string.hu.authHistoryDescription = 'Adatvédelmi okokból a beszélgetés előzményei nem jelennek meg.';
z.string.hu.authHistoryReuseHeadline = 'Már használtad a Wire-t ezen az eszközön.';
z.string.hu.authHistoryReuseDescription = 'Az előző használat óta elküldött üzenetek ezen az eszközön nem fognak megjelenni.';
z.string.hu.authHistoryButton = 'OK';

z.string.hu.authPostedResend = 'Újraküldés ide: {{email}}';
z.string.hu.authPostedResendAction = 'Nem kaptál e-mailt?';
z.string.hu.authPostedResendDetail = 'Ellenőrizd bejövő e-mailjeidet és kövesd az utasításokat.';
z.string.hu.authPostedResendHeadline = 'Leveled érkezett.';

z.string.hu.authPlaceholderEmail = 'E-mail';
z.string.hu.authPlaceholderPasswordPut = 'Jelszó';
z.string.hu.authPlaceholderPasswordSet = 'Jelszó (legalább 8 karakter)';
z.string.hu.authPlaceholderPhone = 'Telefonszám';

z.string.hu.authErrorCode = 'Érvénytelen kód';
z.string.hu.authErrorCountryCodeInvalid = 'Érvénytelen az Országhívó-kód';
z.string.hu.authErrorEmailExists = 'Ez az e-mail cím már foglalt';
z.string.hu.authErrorEmailForbidden = 'Sajnáljuk. Ez az e-mail cím nem megengedett.';
z.string.hu.authErrorEmailMalformed = 'Kérjük, valós e-mail címet adj meg.';
z.string.hu.authErrorEmailMissing = 'Kérjük, add meg az e-mail címed.';
z.string.hu.authErrorMisc = 'Csatlakozási probléma. Kérjük, próbáld meg újra.';
z.string.hu.authErrorNameShort = 'Legalább 2 karakterből álló nevet adj meg';
z.string.hu.authErrorOffline = 'Nincs internetkapcsolat';
z.string.hu.authErrorPasswordShort = 'Válassz egy legalább 8 karakter hosszú jelszót.';
z.string.hu.authErrorPasswordWrong = 'Hibás jelszó. Kérjük, próbáld meg újra.';
z.string.hu.authErrorPending = 'A fiók még nincs ellenőrizve';
z.string.hu.authErrorPhoneNumberBudget = 'Túl gyakran jelentkeztél be. Próbáld meg később.';
z.string.hu.authErrorPhoneNumberForbidden = 'Sajnáljuk. Ez a telefonszám nem megengedett.';
z.string.hu.authErrorPhoneNumberInvalid = 'Érvénytelen telefonszám';
z.string.hu.authErrorPhoneNumberUnknown = 'Ismeretlen telefonszám';
z.string.hu.authErrorSuspended = 'Ezzel az azonosítóval már nem lehet bejelentkezni.';
z.string.hu.authErrorSignIn = 'Kérjük, ellenőrizd az adataid, majd próbáld meg újra.';

z.string.hu.callStateOutgoing = 'Kicsengés…';
z.string.hu.callStateConnecting = 'Csatlakozás…';
z.string.hu.callStateIncoming = 'Hívás…';
z.string.hu.callStateIncomingGroup = '{{user}} hív';
z.string.hu.callDecline = 'Elutasítás';
z.string.hu.callAccept = 'Elfogadás';
z.string.hu.callJoin = 'Csatlakozás';
z.string.hu.callChooseSharedScreen = 'Válaszd ki a megosztandó képernyőt';
z.string.hu.callParticipants = '{{number}} partner a vonalban';

z.string.hu.videoCallOverlayConversations = 'Beszélgetések';
z.string.hu.videoCallOverlayMute = 'Némítás';
z.string.hu.videoCallOverlayVideo = 'Videó';
z.string.hu.videoCallOverlayShareScreen = 'Képernyő megosztása';
z.string.hu.videoCallOverlayHangUp = 'Hívás befejezése';
z.string.hu.videoCallPaused = 'Videó szüneteltetve';

z.string.hu.modalAcknowledgeAction = 'Ok';
z.string.hu.modalAcknowledgeHeadline = 'Valami nem stimmel';
z.string.hu.modalConfirmSecondary = 'Mégsem';
z.string.hu.modalOptionSecondary = 'Mégsem';

z.string.hu.modalAccountCreateAction = 'OK';
z.string.hu.modalAccountCreateHeadline = 'Fiók létrehozása?';
z.string.hu.modalAccountCreateMessage = 'Ha létrehozol egy fiókot, akkor elveszted a beszélgetés előzményit ebben a vendégszobában.';

z.string.hu.modalAccountDeletionAction = 'Törlés';
z.string.hu.modalAccountDeletionHeadline = 'Fiók törlése';
z.string.hu.modalAccountDeletionMessage = 'Küldünk egy e-mailt vagy SMS-t. Fiókod végleges törléséhez nyisd meg a kapott linket.';

z.string.hu.modalAccountLeaveGuestRoomAction = 'Kilépés';
z.string.hu.modalAccountLeaveGuestRoomHeadline = 'Elhagyod a vendégszobát?';
z.string.hu.modalAccountLeaveGuestRoomMessage = 'A beszélgetés előzményei törlődnek. Ha meg szeretnéd tartani, inkább legközelebb hozz létre egy fiókot.';

z.string.hu.modalAccountLogoutAction = 'Kijelentkezés';
z.string.hu.modalAccountLogoutHeadline = 'Adatok törlése?';
z.string.hu.modalAccountLogoutOption = 'Ez törli az összes személyes adatodat és beszélgetéseidet erről az eszközről.';

z.string.hu.modalAccountNewDevicesSecondary = 'Eszközök kezelése';
z.string.hu.modalAccountNewDevicesHeadline = 'Fiókod legutóbbi használata:';
z.string.hu.modalAccountNewDevicesFrom = 'Eszköz:';
z.string.hu.modalAccountNewDevicesMessage = 'Ha ezt nem te voltál, akkor töröld az eszközt, és állítsd alaphelyzetbe jelszavad.';

z.string.hu.modalAccountRemoveDeviceAction = 'Eszköz eltávolítása';
z.string.hu.modalAccountRemoveDeviceHeadline = '"{{device}}" eltávolítása';
z.string.hu.modalAccountRemoveDeviceMessage = 'Az eszköz eltávolításához add meg a jelszavad.';
z.string.hu.modalAccountRemoveDevicePlaceholder = 'Jelszó';

z.string.hu.modalAssetTooLargeHeadline = 'A fájl túl nagy';
z.string.hu.modalAssetTooLargeMessage = 'Maximum {{number}} méretű fájlokat küldhetsz';

z.string.hu.modalAssetParallelUploadsHeadline = 'Egyszerre ez túl sok fájl';
z.string.hu.modalAssetParallelUploadsMessage = 'Egyszerre {{number}} fájt küldhetsz.';

z.string.hu.modalCallEmptyConversationHeadline = 'Senki sem hívható';
z.string.hu.modalCallEmptyConversationMessage = 'Senki sem maradt itt.';

z.string.hu.modalCallEmptyLogHeadline = 'Nincsenek hívások';
z.string.hu.modalCallEmptyLogMessage = 'Nincsenek hívások, amikről hibanapló készíthető lenne.';

z.string.hu.modalCallNoGroupVideoHeadline = 'A csoportokban a videóhívás nem elérhető';
z.string.hu.modalCallNoGroupVideoMessage = 'Videohívások nem érhetők el a csoportos beszélgetésben.';

z.string.hu.modalCallNoMicrophoneAction = 'Mit kell tennem';
z.string.hu.modalCallNoMicrophoneMessage = 'A hívásokhoz a böngésződnek hozzá kell férnie a mikrofonodhoz.';
z.string.hu.modalCallNoMicrophoneHeadline = 'Nem kezdeményezhetsz hívást mikrofon nélkül';

z.string.hu.modalCallSecondIncomingAction = 'Fogadás';
z.string.hu.modalCallSecondIncomingHeadline = 'Fogadod a hívást?';
z.string.hu.modalCallSecondIncomingMessage = 'A folyamatban lévő hívás véget ért.';

z.string.hu.modalCallSecondOngoingAction = 'Hívás befejezése';
z.string.hu.modalCallSecondOngoingHeadline = 'Bontsuk a hívást a másik eszközön?';
z.string.hu.modalCallSecondOngoingMessage = 'Egyszerre csak egy hívásban vehetsz részt.';

z.string.hu.modalCallSecondOutgoingAction = 'Hívás befejezése';
z.string.hu.modalCallSecondOutgoingHeadline = 'Leteszed a folyamatban lévő hívást?';
z.string.hu.modalCallSecondOutgoingMessage = 'Egyszerre csak egy hívásban vehetsz részt.';

z.string.hu.modalConnectCancelAction = 'Igen';
z.string.hu.modalConnectCancelHeadline = 'Kérelem visszavonása?';
z.string.hu.modalConnectCancelMessage = 'Visszavonod a csatlakozási kérelmet {{user}} partnerhez.';
z.string.hu.modalConnectCancelSecondary = 'Nem';

z.string.hu.modalConnectAcceptAction = 'Csatlakozás';
z.string.hu.modalConnectAcceptHeadline = 'Elfogadod?';
z.string.hu.modalConnectAcceptMessage = 'Ezzel csatlakozol és beszélgetést indítasz {{user}} partnerrel.';
z.string.hu.modalConnectAcceptSecondary = 'Figyelmen kívül hagyás';

z.string.hu.modalConversationClearAction = 'Törlés';
z.string.hu.modalConversationClearHeadline = 'Törlöd a tartalmat?';
z.string.hu.modalConversationClearMessage = 'Ezzel törlöd a beszélgetés előzményét az összes eszközödről.';
z.string.hu.modalConversationClearOption = 'Kilépés a beszélgetésből is';

z.string.hu.modalConversationDeleteMessageAction = 'Törlés';
z.string.hu.modalConversationDeleteMessageHeadline = 'Törlés csak nálam?';
z.string.hu.modalConversationDeleteMessageMessage = 'Ezt a műveletet nem lehet visszavonni.';

z.string.hu.modalConversationDeleteMessageEveryoneAction = 'Törlés';
z.string.hu.modalConversationDeleteMessageEveryoneHeadline = 'Törlés minden résztvevőnél?';
z.string.hu.modalConversationDeleteMessageEveryoneMessage = 'Ezt a műveletet nem lehet visszavonni.';

z.string.hu.modalConversationLeaveAction = 'Kilépés';
z.string.hu.modalConversationLeaveHeadline = 'Kilépsz ebből a beszélgetésből: "{{name}}"?';
z.string.hu.modalConversationLeaveMessage = 'Ezután nem fogsz tudni üzeneteket küldeni és fogadni ebben a beszélgetésben.';

z.string.hu.modalConversationMessageTooLongHeadline = 'Az üzenet túl hosszú';
z.string.hu.modalConversationMessageTooLongMessage = 'Maximum {{number}} karakter hosszú üzenetet küldhetsz.';

z.string.hu.modalConversationNewDeviceAction = 'Küldés mindenképpen';
z.string.hu.modalConversationNewDeviceHeadlineOne = '{{user}} elkezdett használni egy új eszközt';
z.string.hu.modalConversationNewDeviceHeadlineMany = '{{users}} elkezdtek új eszközöket használni';
z.string.hu.modalConversationNewDeviceHeadlineYou = '{{user}} elkezdett használni egy új eszközt';
z.string.hu.modalConversationNewDeviceIncomingCallAction = 'Hívás fogadása';
z.string.hu.modalConversationNewDeviceIncomingCallMessage = 'Biztos, hogy még mindig fogadni szeretnéd a hívást?';
z.string.hu.modalConversationNewDeviceMessage = 'Biztos, hogy még mindig el szeretnéd küldeni az üzeneteidet?';
z.string.hu.modalConversationNewDeviceOutgoingCallAction = 'Hívás mindenképpen';
z.string.hu.modalConversationNewDeviceOutgoingCallMessage = 'Biztos, hogy még mindig kezdeményezni szeretnéd a hívást?';

z.string.hu.modalConversationNotConnectedHeadline = 'Senki nem lett hozzáadva a beszélgetéshez';
z.string.hu.modalConversationNotConnectedMessageOne = '{{name}} nem szeretne csatlakozni a beszélgetéshez.';
z.string.hu.modalConversationNotConnectedMessageMany = 'Az egyik kiválasztott partner nem szeretne csatlakozni a beszélgetéshez.';

z.string.hu.modalConversationRemoveAction = 'Eltávolítás';
z.string.hu.modalConversationRemoveHeadline = 'Törlöd?';
z.string.hu.modalConversationRemoveMessage = '{{user}} nem fog tudni üzenetet küldeni és fogadni ebben a beszélgetésben.';

z.string.hu.modalConversationRemoveGuestsAction = 'Vendégek eltávolítása';
z.string.hu.modalConversationRemoveGuestsHeadline = 'Kikapcsolod a vendég hozzáférést?';
z.string.hu.modalConversationRemoveGuestsMessage = 'A jelenlegi vendég el lesz távolítva a beszélgetésből. Új vendégek sem csatlakozhatnak.';

z.string.hu.modalConversationRevokeLinkAction = 'Link visszavonása';
z.string.hu.modalConversationRevokeLinkHeadline = 'Visszavonod a hivatkozást?';
z.string.hu.modalConversationRevokeLinkMessage = 'Új vendégek nem tudnak ezzel a hivatkozással csatlakozni. A már meglévő vendégeknek továbbra is megmarad a hozzáférése.';

z.string.hu.modalConversationGuestOptionsAllowGuestMessage = 'Nem sikerült engedélyezni a vendégeket. Kérjük, próbáld újra.';
z.string.hu.modalConversationGuestOptionsDisableGuestMessage = 'Nem sikerült eltávolítani a vendégeket. Kérjük, próbáld újra.';
z.string.hu.modalConversationGuestOptionsGetCodeMessage = 'Nem sikerült hozzáférési hivatkozást beszerezni.';
z.string.hu.modalConversationGuestOptionsRequestCodeMessage = 'Nem sikerült hozzáférési hivatkozást igényelni. Kérjük, próbáld újra.';
z.string.hu.modalConversationGuestOptionsRevokeCodeMessage = 'Nem sikerült visszavonni a hozzáférési hivatkozást. Kérjük, próbáld újra.';
z.string.hu.modalConversationGuestOptionsToggleGuestsMessage = 'Nem sikerült megváltoztatni a vendég állapotát.';

z.string.hu.modalConversationTooManyMembersHeadline = 'Telt ház';
z.string.hu.modalConversationTooManyMembersMessage = 'Legfeljebb {{number1}} partner tud csatlakozni a beszélgetéshez. Még {{number2}} partner számára van hely.';

z.string.hu.modalGifTooLargeHeadline = 'A kiválsztott animáció túl nagy';
z.string.hu.modalGifTooLargeMessage = 'A maximális méret {{number}} MB lehet.';

z.string.hu.modalIntegrationUnavailableHeadline = 'A botok jelenleg nem elérhetőek';
z.string.hu.modalIntegrationUnavailableMessage = 'Köszönjük, hogy érdeklődsz a botokkal kapcsolatban. A szolgáltatást jelenleg felfüggesztettük, amíg a következő verzión dolgozunk. Hamarosan jelentkezünk.';

z.string.hu.modalPictureFileFormatHeadline = 'Nem lehet ezt a képet használni';
z.string.hu.modalPictureFileFormatMessage = 'Kérjük, PNG vagy JPEG képet használj.';

z.string.hu.modalPictureTooLargeHeadline = 'A kiválasztott kép túl nagy';
z.string.hu.modalPictureTooLargeMessage = 'Maximum {{number}} MB méretű képeket használhatsz.';

z.string.hu.modalPictureTooSmallHeadline = 'A kép túl kicsi';
z.string.hu.modalPictureTooSmallMessage = 'Kérjük, legalább 320 x 320 képpont méretű képet válassz.';

z.string.hu.modalImproveWireAction = 'Elfogadás';
z.string.hu.modalImproveWireSecondary = 'Most nem';
z.string.hu.modalImproveWireHeadline = 'Segíts nekünk jobbá tenni a Wire-t';
z.string.hu.modalImproveWireMessage = 'Segíts jobbá tenni termékeinket és szolgáltatásainkat azzal, hogy névtelen használati és hibajelentéseket küldesz. Ezeket az információkat semmi másra nem használjuk.';

z.string.hu.modalServiceUnavailableHeadline = 'Új szolgáltatás hozzáadása nem lehetséges';
z.string.hu.modalServiceUnavailableMessage = 'A szolgáltatás jelenleg nem elérhető.';

z.string.hu.modalSessionResetHeadline = 'A munkamenet alaphelyzetbe állítva';
z.string.hu.modalSessionResetMessage1 = 'Ha a probléma továbbra is fennáll,';
z.string.hu.modalSessionResetMessageLink = 'lépj kapcsolatba';
z.string.hu.modalSessionResetMessage2 = 'velünk.';

z.string.hu.modalUploadContactsAction = 'Újra próbálás';
z.string.hu.modalUploadContactsMessage = 'Nem kaptuk meg az adataidat. Kérjük, próbáld meg újra a névjegyek importálását.';

z.string.hu.modalUserBlockAction = 'Tiltás';
z.string.hu.modalUserBlockHeadline = '{{user}} tiltása?';
z.string.hu.modalUserBlockMessage = '{{user}} nem tud majd kapcsolatba lépni veled, sem meghívni téged csoportos beszélgetésekbe.';

z.string.hu.modalUserUnblockAction = 'Tiltás feloldása';
z.string.hu.modalUserUnblockHeadline = 'Feloldod a letiltást?';
z.string.hu.modalUserUnblockMessage = '{{user}} újra kapcsolatba tud lépni veled és meg tud hívni téged csoportos beszélgetésekbe.';

z.string.hu.connectionRequestConnect = 'Csatlakozás';
z.string.hu.connectionRequestIgnore = 'Figyelmen kívül hagyás';

z.string.hu.conversationGuestIndicator = 'Vendég';
z.string.hu.userRemainingTimeHours = '{{time}} óra van hátra';
z.string.hu.userRemainingTimeMinutes = 'Kevesebb mint {{time}} perc van hátra';

z.string.hu.conversationYouNominative = 'te';
z.string.hu.conversationYouDative = 'te';
z.string.hu.conversationYouAccusative = 'te';

z.string.hu.conversationConnectionAccepted = 'Csatlakozva';
z.string.hu.conversationConnectionBlocked = 'Letiltva';
z.string.hu.conversationConnectionCancelRequest = 'Csatlakozási kérés visszavonása';
z.string.hu.conversationCreateTemporary = 'Csatlakoztál a beszélgetéshez';
z.string.hu.conversationCreateWith = ' velük: {{users}}';
z.string.hu.conversationDeviceStartedUsingOne = ' elkezdett használni';
z.string.hu.conversationDeviceStartedUsingMany = ' elkezdett használni';
z.string.hu.conversationDeviceUnverified = ' visszavontad az ellenőrzött státuszt';
z.string.hu.conversationDeviceYourDevices = ' az egyik eszközödről';
z.string.hu.conversationDeviceUserDevices = ' {{user}} egyik eszköze';
z.string.hu.conversationDeviceNewDeviceOne = ' egy új eszközt';
z.string.hu.conversationDeviceNewDeviceMany = ' új eszközöket';
z.string.hu.conversationDeviceNewPeopleJoined = 'Új partnerek csatlakoztak.';
z.string.hu.conversationDeviceNewPeopleJoinedVerify = ' eszközök ellenőrzése';
z.string.hu.conversationJustNow = 'Épp most';
z.string.hu.conversationLocationLink = 'Térkép megnyitása';
z.string.hu.conversationMessageDelivered = 'Kézbesítve';
z.string.hu.conversationRename = ' átnevezte a beszélgetést';
z.string.hu.conversationRenameYou = ' átnevezte a beszélgetést';
z.string.hu.conversationResume = 'Beszélgetés indítása a következőkkel: {{users}}';
z.string.hu.conversationPing = ' kopogott';
z.string.hu.conversationPingYou = ' kopogott';
z.string.hu.conversationToday = 'ma';
z.string.hu.conversationVoiceChannelDeactivate = ' hívást kezdeményezett';
z.string.hu.conversationVoiceChannelDeactivateYou = ' hívást kezdeményezett';
z.string.hu.conversationYesterday = 'Tegnap';
z.string.hu.conversationUnableToDecrypt1 = 'Nem kaptál meg egy üzenetet tőle: {{user}}.';
z.string.hu.conversationUnableToDecrypt2 = '{{user}} eszközének azonosítója megváltozott. Kézbesítetlen üzenet.';
z.string.hu.conversationUnableToDecryptLink = 'Miért?';
z.string.hu.conversationUnableToDecryptErrorMessage = 'Hiba';
z.string.hu.conversationUnableToDecryptResetSession = 'Munkamenet visszaállítása';
z.string.hu.conversationMissedMessages = 'Ezt a készüléket már nem használtad egy ideje, ezért nem biztos, hogy minden üzenet megjelenik itt.';
z.string.hu.conversationAssetUploading = 'Feltöltés…';
z.string.hu.conversationAssetDownloading = 'Letöltés…';
z.string.hu.conversationAssetUploadFailed = 'A feltöltés sikertelen';
z.string.hu.conversationPlaybackError = 'Nem lehet lejátszani';
z.string.hu.conversationContextMenuCopy = 'Másolás';
z.string.hu.conversationContextMenuEdit = 'Szerkesztés';
z.string.hu.conversationContextMenuDelete = 'Törlés nálam';
z.string.hu.conversationContextMenuDeleteEveryone = 'Törlés mindenkinél';
z.string.hu.conversationContextMenuDownload = 'Letöltés';
z.string.hu.conversationContextMenuLike = 'Tetszik';
z.string.hu.conversationContextMenuUnlike = 'Nem tetszik';
z.string.hu.conversationDeleteTimestamp = 'Törölve: {{date}}';
z.string.hu.conversationEditTimestamp = 'Módosítva: {{date}}';
z.string.hu.conversationLikesCaption = '{{number}} partner';
z.string.hu.conversationSendPastedFile = 'Kép beillesztve ({{date}})';
z.string.hu.conversationSomeone = 'Valaki';
z.string.hu.conversationTweetAuthor = ' Twitteren';

z.string.hu.groupCreationPreferencesAction = 'Tovább';
z.string.hu.groupCreationPreferencesErrorNameShort = 'Legalább 1 karakter';
z.string.hu.groupCreationPreferencesErrorNameLong = 'Túl sok karakter';
z.string.hu.groupCreationPreferencesHeader = 'Új csoport';
z.string.hu.groupCreationPreferencesPlaceholder = 'Csoportnév';
z.string.hu.groupCreationParticipantsActionCreate = 'Kész';
z.string.hu.groupCreationParticipantsActionSkip = 'Kihagyás';
z.string.hu.groupCreationParticipantsHeader = 'Partnerek hozzáadása';
z.string.hu.groupCreationParticipantsHeaderWithCounter = 'Partnerek hozzáadása ({{number}})';
z.string.hu.groupCreationParticipantsPlaceholder = 'Keresés név szerint';
z.string.hu.groupSizeInfo = 'Maximum {{count}} partner csatlakozhat a csoportos beszélgetéshez. Videóhívások 4 vagy kevesebb emberrel lehetségesek.';

z.string.hu.guestRoomConversationName = 'Vendégszoba';
z.string.hu.guestRoomToggleName = 'Vendégek engedélyezése';
z.string.hu.guestRoomToggleInfo = 'Megnyitja a beszélgetést a csapatodon kívüli partnerek számára is.';
z.string.hu.guestRoomToggleInfoExtended = 'A beszélgetés elérhető a csapaton kívüli embereknek is. Ezt később bármikor megváltoztathatod.';

z.string.hu.guestRoomConversationBadge = 'Vendégek is vannak itt';

z.string.hu.guestRoomConversationHead = 'Csapatodon kívüli emberek is csatlakozhatnak ehhez a beszélgetéshez.';
z.string.hu.guestRoomConversationButton = 'Partner meghívása';

z.string.hu.collectionShowAll = 'Mind a(z) {{number}} mutatása';
z.string.hu.collectionSectionLinks = 'Hivatkozások';
z.string.hu.collectionSectionImages = 'Képek';
z.string.hu.collectionSectionFiles = 'Fájlok';
z.string.hu.collectionSectionAudio = 'Hangüzenetek';

z.string.hu.fullsearchPlaceholder = 'Szöveges üzenetek keresése';
z.string.hu.fullsearchNoResults = 'Nincs találat.';

z.string.hu.archiveHeader = 'Archiválás';

z.string.hu.conversationsAllArchived = 'Minden archiválva';
z.string.hu.conversationsContacts = 'Névjegyek';
z.string.hu.conversationsConnectionRequestMany = '{{number}} partner várakozik';
z.string.hu.conversationsConnectionRequestOne = '1 partner várakozik';
z.string.hu.conversationsEmptyConversation = 'Csoportos beszélgetés';
z.string.hu.conversationsNoConversations = 'Indíts egy beszélgetést vagy hozz létre egy csoportot.';
z.string.hu.conversationsPopoverArchive = 'Archiválás';
z.string.hu.conversationsPopoverBlock = 'Letilt…';
z.string.hu.conversationsPopoverCancel = 'Kérelem visszavonása';
z.string.hu.conversationsPopoverClear = 'Tartalom törlése…';
z.string.hu.conversationsPopoverLeave = 'Kilépés a csoportból…';
z.string.hu.conversationsPopoverNotify = 'Némítás feloldása';
z.string.hu.conversationsPopoverSilence = 'Némítás';
z.string.hu.conversationsPopoverUnarchive = 'Archiválás visszavonása';

z.string.hu.conversationsSecondaryLineEphemeralMessage = 'Üzenetet küldött';
z.string.hu.conversationsSecondaryLineIncomingCall = '{{user}} hív';
z.string.hu.conversationsSecondaryLinePeopleLeft = '{{number}} partner kilépett a beszélgetésből';
z.string.hu.conversationsSecondaryLinePersonLeft = '{{user}} kilépett';
z.string.hu.conversationsSecondaryLinePersonRemoved = '{{user}} eltávolítva';
z.string.hu.conversationsSecondaryLinePersonRemovedTeam = '{{user}} el lett távolítva a csapatból';
z.string.hu.conversationsSecondaryLinePeopleAdded = '{{user}} hozzáadva';
z.string.hu.conversationsSecondaryLinePersonAdded = '{{user}} hozzáadva';
z.string.hu.conversationsSecondaryLinePersonAddedSelf = '{{user}} csatlakozott';
z.string.hu.conversationsSecondaryLinePersonAddedYou = '{{user}} hozzáadott téged';
z.string.hu.conversationsSecondaryLineRenamed = '{{user}} átnevezte a beszélgetést';
z.string.hu.conversationsSecondaryLineYouLeft = 'Kiléptél';
z.string.hu.conversationsSecondaryLineYouWereRemoved = 'El lettél távolítva';

z.string.hu.takeoverSub = 'Foglald le egyedi Wire felhasználóneved.';
z.string.hu.takeoverLink = 'További információ';
z.string.hu.takeoverButtonChoose = 'Válaszd ki a sajátod';
z.string.hu.takeoverButtonKeep = 'Tartsd meg ezt';

z.string.hu.inviteMetaKeyMac = 'Cmd';
z.string.hu.inviteMetaKeyPc = 'Ctrl';
z.string.hu.inviteHintSelected = 'Nyomd meg a {{metaKey}} + C billentyűkombinációt a másoláshoz';
z.string.hu.inviteHintUnselected = 'Jelöld ki a szöveget, majd nyomd meg a {{metaKey}} + C billentyűkombinációt';
z.string.hu.inviteHeadline = 'Hívj meg másokat is a Wire-re';
z.string.hu.inviteMessage = 'Fent vagyok a Wire-ön. Keress rá a felhasználónevemre: {{username}} vagy nyisd meg a get.wire.com weboldalt.';
z.string.hu.inviteMessageNoEmail = 'Fent vagyok a Wire-ön. Látogass el a get.wire.com weboldalra és lépj kapcsolatba velem.';

z.string.hu.extensionsBubbleButtonGif = 'Gif';

z.string.hu.extensionsGiphyButtonOk = 'Küldés';
z.string.hu.extensionsGiphyButtonMore = 'Másik keresése';
z.string.hu.extensionsGiphyMessage = '{{tag}} • Forrás: giphy.com';
z.string.hu.extensionsGiphyNoGifs = 'Hoppá, nincs gif';
z.string.hu.extensionsGiphyRandom = 'Véletlenszerű';

z.string.hu.addParticipantsConfirmLabel = 'Hozzáadás';
z.string.hu.addParticipantsHeader = 'Partnerek hozzáadása';
z.string.hu.addParticipantsHeaderWithCounter = 'Partnerek hozzáadása ({{number}})';
z.string.hu.addParticipantsSearchPlaceholder = 'Keresés név szerint';
z.string.hu.addParticipantsServiceConfirmButton = 'Új szolgáltatás';
z.string.hu.addParticipantsTabsPeople = 'Partner';
z.string.hu.addParticipantsTabsServices = 'Szolgáltatások';

z.string.hu.conversationDetailsActionArchive = 'Beszélgetés archiválása';
z.string.hu.conversationDetailsActionAddParticipants = 'Résztvevők hozzáadása';
z.string.hu.conversationDetailsActionBlock = 'Partner tiltása';
z.string.hu.conversationDetailsActionCancelRequest = 'Kérelem visszavonása';
z.string.hu.conversationDetailsActionClear = 'Tartalom törlése';
z.string.hu.conversationDetailsActionCreateGroup = 'Új csoport';
z.string.hu.conversationDetailsActionDevices = 'Eszközök';
z.string.hu.conversationDetailsActionGuestOptions = 'Vendég opciók';
z.string.hu.conversationDetailsActionNotifications = 'Értesítések';
z.string.hu.conversationDetailsActionLeave = 'Kilépés a csoportból';
z.string.hu.conversationDetailsGuestsOff = 'Kikapcsolva';
z.string.hu.conversationDetailsGuestsOn = 'Be';
z.string.hu.conversationDetailsOptions = 'Beállítások';
z.string.hu.conversationDetailsParticipantsServicesOne = 'Szolgáltatás';
z.string.hu.conversationDetailsParticipantsServicesMany = 'Szolgáltatások';
z.string.hu.conversationDetailsParticipantsUsersOne = 'Személy';
z.string.hu.conversationDetailsParticipantsUsersMany = 'Partner';
z.string.hu.conversationDetailsPeople = 'Partner';
z.string.hu.conversationDetailsServices = 'Szolgáltatások';

z.string.hu.conversationParticipantsTitle = 'Partner';
z.string.hu.conversationParticipantsSearchPlaceholder = 'Keresés név szerint';

z.string.hu.groupParticipantActionBlock = 'Letilt…';
z.string.hu.groupParticipantActionCancelRequest = 'Kérelem visszavonása';
z.string.hu.groupParticipantActionDevices = 'Eszközök';
z.string.hu.groupParticipantActionIgnoreRequest = 'Kérés figyelmen kívül hatása';
z.string.hu.groupParticipantActionIncomingRequest = 'Kérés elfogadása';
z.string.hu.groupParticipantActionLeave = 'Kilépés a csoportból…';
z.string.hu.groupParticipantActionOpenConversation = 'Beszélgetés megnyitása';
z.string.hu.groupParticipantActionPending = 'Függőben lévő';
z.string.hu.groupParticipantActionRemove = 'Eltávolítás a csoportból';
z.string.hu.groupParticipantActionSelfProfile = 'Profil megnyitása';
z.string.hu.groupParticipantActionSendRequest = 'Csatlakozás';
z.string.hu.groupParticipantActionUnblock = 'Tiltás feloldása';

z.string.hu.guestOptionsCopyLink = 'Hivatkozás másolása';
z.string.hu.guestOptionsCopyLinkDone = 'Hivatkozás másolva!';
z.string.hu.guestOptionsCreateLink = 'Hivatkozás létrehozása';
z.string.hu.guestOptionsInfoHeader = 'Hívj meg másokat egy hivatkozással';
z.string.hu.guestOptionsInfoText = 'Bárki, akinek megvan ez a hivatkozás, csatlakozhat a beszélgetéshez 24 órán belül, akkor is, ha egyébként nincsenek a Wire-ön.';
z.string.hu.guestOptionsRevokeLink = 'Link visszavonása';
z.string.hu.guestOptionsTitle = 'Vendég opciók';

z.string.hu.notificationSettingsTitle = 'Értesítések';

z.string.hu.participantDevicesDetailHeadline = 'Ellenőrizd, hogy ez egyezik-e {{html1}}{{user}} eszközén látható{{html2}} ujjlenyomattal.';
z.string.hu.participantDevicesDetailHowTo = 'Hogyan csináljam?';
z.string.hu.participantDevicesDetailResetSession = 'Munkamenet visszaállítása';
z.string.hu.participantDevicesDetailShowMyDevice = 'Eszköz ujjlenyomatának megjelenítése';
z.string.hu.participantDevicesDetailVerify = 'Ellenőrizve';

z.string.hu.participantDevicesHeader = 'Eszközök';
z.string.hu.participantDevicesHeadline = 'A Wire-ben minden eszköz egyedi ujjlenyomattal rendelkezik. Hasonlítsd össze ezt az ujjlenyomatot {{user}} partnerrel és ellenőrizd a beszélgetést.';
z.string.hu.participantDevicesLearnMore = 'További információ';
z.string.hu.participantDevicesWhyVerify = 'Miért ellenőrizd a beszélgetéseket?';
z.string.hu.participantDevicesOutdatedClientMessage = '{{user}} a Wire régi verzióját használja. Eszközei itt nem jeleníthetőek meg.';

z.string.hu.participantDevicesSelfAllDevices = 'Összes saját eszköz mutatása';
z.string.hu.participantDevicesSelfFingerprint = 'Eszköz ujjlenyomata';

z.string.hu.userProfileButtonConnect = 'Csatlakozás';
z.string.hu.userProfileButtonIgnore = 'Figyelmen kívül hagyás';
z.string.hu.userProfileButtonUnblock = 'Tiltás feloldása';

z.string.hu.preferencesAbout = 'Névjegy';
z.string.hu.preferencesAccount = 'Fiók';
z.string.hu.preferencesAV = 'Hang / Videó';
z.string.hu.preferencesDeviceDetails = 'Eszköz részletei';
z.string.hu.preferencesDevices = 'Eszközök';
z.string.hu.preferencesHeadline = 'Beállítások';
z.string.hu.preferencesOptions = 'Beállítások';

z.string.hu.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.hu.preferencesAboutPrivacyPolicy = 'Adatvédelmi Nyilatkozat';
z.string.hu.preferencesAboutSupport = 'Ügyfélszolgálat';
z.string.hu.preferencesAboutSupportWebsite = 'Wire Ügyfélszolgálat';
z.string.hu.preferencesAboutSupportContact = 'Kapcsolatfelvétel az Ügyfélszolgálattal';
z.string.hu.preferencesAboutTermsOfUse = 'Felhasználási feltételek';
z.string.hu.preferencesAboutVersion = 'Verzió {{version}}';
z.string.hu.preferencesAboutWebsite = 'Wire weboldala';

z.string.hu.preferencesAccountAvaibilityUnset = 'Állapot beállítása';
z.string.hu.preferencesAccountCreateTeam = 'Csapat létrehozása';
z.string.hu.preferencesAccountData = 'Adatokhasználati engedélyek';
z.string.hu.preferencesAccountDataCheckbox = 'Adatok küldése névtelenül';
z.string.hu.preferencesAccountDataDetail = 'Névtelen használati és hibajelentések küldésével segíthetsz, hogy a Wire még jobb legyen.';
z.string.hu.preferencesAccountDelete = 'Fiók törlése';
z.string.hu.preferencesAccountLeaveGuestRoom = 'Vendégszoba elhagyása';
z.string.hu.preferencesAccountLeaveGuestRoomDescription = 'Ezután nem tudod elérni az ebben a beszélgetésben lévő üzeneteket.';
z.string.hu.preferencesAccountLogOut = 'Kijelentkezés';
z.string.hu.preferencesAccountManageTeam = 'Csapat kezelése';
z.string.hu.preferencesAccountMarketingConsentCheckbox = 'Feliratkozás hírlevélre';
z.string.hu.preferencesAccountMarketingConsentDetail = 'Hírek és termékinformációk fogadása e-mailben a Wire-től.';
z.string.hu.preferencesAccountResetPassword = 'Jelszó visszaállítása';
z.string.hu.preferencesAccountTeam = 'innen: {{name}}';
z.string.hu.preferencesAccountUsernamePlaceholder = 'Teljes neved';
z.string.hu.preferencesAccountUsernameHint = 'Legalább 2 karakter, és kizárólag a—z, 0—9 és _ karakterek.';
z.string.hu.preferencesAccountUsernameAvailable = 'Elérhető';
z.string.hu.preferencesAccountUsernameErrorTaken = 'Már foglalt';

z.string.hu.preferencesAVCamera = 'Kamera';
z.string.hu.preferencesAVMicrophone = 'Mikrofon';
z.string.hu.preferencesAVPermissionDetail = 'Engedélyezze a böngésző Beállításainál';
z.string.hu.preferencesAVSpeakers = 'Hangszórók';
z.string.hu.preferencesAVTryAgain = 'Próbáld újra';

z.string.hu.preferencesDevicesActivatedOn = 'Legutóbb aktiválva: {{date}}';
z.string.hu.preferencesDevicesActive = 'Aktív';
z.string.hu.preferencesDevicesActiveDetail = 'Ha a fenti eszközök közül valamelyik nem ismerős, akkor töröld azt és változtass jelszót.';
z.string.hu.preferencesDevicesCurrent = 'Ez az eszköz';
z.string.hu.preferencesDevicesFingerprint = 'Eszközazonosító ujjlenyomat';
z.string.hu.preferencesDevicesFingerprintDetail = 'A Wire-ben minden eszköz egyedi ujjlenyomattal rendelkezik. Összehasonlítással ellenőrizd az eszközöket és a beszélgetéseket.';
z.string.hu.preferencesDevicesId = 'Eszközazonosító (ID): ';
z.string.hu.preferencesDevicesRemove = 'Eltávolítás…';
z.string.hu.preferencesDevicesRemoveCancel = 'Mégsem';
z.string.hu.preferencesDevicesRemoveDetail = 'Távolítsd el ezt az eszközt, ha már nem használod. Ezzel együtt azonnal ki is jelentkezel erről az eszközről.';
z.string.hu.preferencesDevicesSessionConfirmation = 'A munkamenet alaphelyzetbe lett állítva.';
z.string.hu.preferencesDevicesSessionDetail = 'Ha az ujjlenyomatok nem egyeznek, állítsd vissza a munkamenet, így mindkét oldalon új titkosítási kulcsok jönnek létre.';
z.string.hu.preferencesDevicesSessionReset = 'Munkamenet visszaállítása';
z.string.hu.preferencesDevicesSessionOngoing = 'Munkamenet visszaállítása…';
z.string.hu.preferencesDevicesVerification = 'Ellenőrizve';

z.string.hu.preferencesOptionsAudio = 'Hangjelzések';
z.string.hu.preferencesOptionsAudioAll = 'Minden';
z.string.hu.preferencesOptionsAudioAllDetail = 'Minden hang';
z.string.hu.preferencesOptionsAudioNone = 'Semmi';
z.string.hu.preferencesOptionsAudioNoneDetail = 'Pssszt!';
z.string.hu.preferencesOptionsAudioSome = 'Néhány';
z.string.hu.preferencesOptionsAudioSomeDetail = 'Kopogások és hívások';
z.string.hu.preferencesOptionsContacts = 'Névjegyek';
z.string.hu.preferencesOptionsContactsGmail = 'Importálás Gmail-ből';
z.string.hu.preferencesOptionsContactsMacos = 'Importálás Névjegyek-ből';
z.string.hu.preferencesOptionsContactsDetail = 'A névjegyeid importálásával könnyebben kapcsolatba léphetsz másokkal. Minden információt anonimizálunk, és semmit nem osszuk meg senki mással.';
z.string.hu.preferencesOptionsPopular = 'Közkívánatra';
z.string.hu.preferencesOptionsEmojiReplaceCheckbox = 'Cserélje ki a begépelt hangulatjeleket emojikra';
z.string.hu.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.hu.preferencesOptionsPreviewsSendCheckbox = 'Előnézet készítése az elküldött hivatkozásokról';
z.string.hu.preferencesOptionsPreviewsSendDetail = 'A más partnerektől kapott hivatkozások előnézete továbbra is látható lesz.';
z.string.hu.preferencesOptionsNotifications = 'Értesítések';
z.string.hu.preferencesOptionsNotificationsNone = 'Kikapcsolva';
z.string.hu.preferencesOptionsNotificationsObfuscate = 'Részletek elrejtése';
z.string.hu.preferencesOptionsNotificationsObfuscateMessage = 'Küldő mutatása';
z.string.hu.preferencesOptionsNotificationsOn = 'Küldő és üzenet mutatása';
z.string.hu.preferencesOptionsCallLogs = 'Hibaelhárítás';
z.string.hu.preferencesOptionsCallLogsGet = 'Hívások hibanaplójának mentése';
z.string.hu.preferencesOptionsCallLogsDetail = 'Ez az információ segít a Wire Ügyfélszolgálatnak a hívással kapcsolatos problémák diagnosztizálásában.';

z.string.hu.preferencesOptionsBackupHeader = 'Előzmények';
z.string.hu.preferencesOptionsBackupExportHeadline = 'Beszélgetések mentése';
z.string.hu.preferencesOptionsBackupExportSecondary = 'Biztonsági mentés készítésével megőrizheted a beszélgetések előzményeit. Később ezzel vissza tudod állítani az előzményeket, ha elhagyod a számítógéped vagy újat kezdesz használni.\nA mentés nincs titkosítva, ezért biztonságos helyen tárold.';
z.string.hu.preferencesOptionsBackupImportHeadline = 'Visszaállítás biztonsági másolatból';
z.string.hu.preferencesOptionsBackupImportSecondary = 'Csak ugyanazon platformon készült mentést tudsz visszaállítani. A visszaállítás felülírja az eszközön jelenleg lévő beszélgetéseket.';

z.string.hu.backupExportGenericErrorHeadline = 'Nem sikerült a fájl mentése';
z.string.hu.backupExportGenericErrorSecondary = 'A mentés nem készült el.';
z.string.hu.backupExportProgressHeadline = 'Előkészítés…';
z.string.hu.backupExportProgressSecondary = 'Mentés folyamatban · {{processed}} / {{total}} — {{progress}}%';
z.string.hu.backupExportProgressCompressing = 'Biztonsági másolat készítése';
z.string.hu.backupExportSaveFileAction = 'Fájl mentése';
z.string.hu.backupExportSuccessHeadline = 'Biztonsági mentés kész';
z.string.hu.backupExportSuccessSecondary = 'Ennek segítségével vissza tudod állítani az előzményeket, ha elhagyod a számítógéped vagy elkezdesz egy újat használni.';
z.string.hu.backupImportGenericErrorHeadline = 'Valami nem stimmel';
z.string.hu.backupImportGenericErrorSecondary = 'Az előzmények visszaállítása nem sikerült.';
z.string.hu.backupImportAccountErrorHeadline = 'Rossz mentés';
z.string.hu.backupImportAccountErrorSecondary = 'Az előzményeket nem lehet másik felhasználói fiókból visszaállítani.';
z.string.hu.backupImportVersionErrorHeadline = 'A mentés nem kompatibilis';
z.string.hu.backupImportVersionErrorSecondary = 'Ez a mentés egy újabb vagy elavultabb Wire verzióval készült és nem lehet itt visszaállítani.';
z.string.hu.backupImportIncompatibleErrorHeadline = 'Rossz mentés';
z.string.hu.backupImportIncompatibleErrorSecondary = 'Az előzményeket nem lehet másik felhasználói fiókból visszaállítani.';
z.string.hu.backupImportOutdatedErrorHeadline = 'A mentés nem kompatibilis';
z.string.hu.backupImportOutdatedErrorSecondary = 'Ez a mentés egy újabb vagy elavultabb Wire verzióval készült és nem lehet itt visszaállítani.';
z.string.hu.backupImportProgressHeadline = 'Előkészítés…';
z.string.hu.backupImportProgressSecondary = 'Visszaállítás folyamatban · {{processed}} / {{total}} — {{progress}}%';
z.string.hu.backupImportSuccessHeadline = 'Az előzmények visszaállítva.';
z.string.hu.backupCancel = 'Mégsem';
z.string.hu.backupTryAgain = 'Próbáld újra';

z.string.hu.searchConnect = 'Csatlakozás';
z.string.hu.searchConnections = 'Kapcsolatok';
z.string.hu.searchContacts = 'Névjegyek';
z.string.hu.searchCreateGroup = 'Csoport létrehozása';
z.string.hu.searchCreateGuestRoom = 'Vendégszoba létrehozása';
z.string.hu.searchGroups = 'Csoportok';
z.string.hu.searchPeople = 'Partner';
z.string.hu.searchPlaceholder = 'Keresés név vagy felhasználónév alapján';
z.string.hu.searchServicePlaceholder = 'Keresés név szerint';
z.string.hu.searchServices = 'Szolgáltatások';
z.string.hu.searchTeamGroups = 'Csapat beszélgetés';
z.string.hu.searchTeamMembers = 'Csapattagok';
z.string.hu.searchTopPeople = 'Top Partnerek';
z.string.hu.searchTrySearch = 'Partnerek keresése\nnév vagy felhasználónév alapján';
z.string.hu.searchNoContactsOnWire = 'Nincsenek névjegyeid a Wire-ön.\nPróbálj új partnereket keresni, \nnév vagy @felhasználónév alapján.';
z.string.hu.searchMemberInvite = 'Hívj meg másokat a csapatba';
z.string.hu.searchOthers = 'Csatlakozás';

z.string.hu.searchInvite = 'Hívj meg másokat is a Wire-re';
z.string.hu.searchInviteDetail = 'Névjegyeid megosztása megkönnyíti, hogy kapcsolatba lépj másokkal. Az összes információt anonimizáljuk és nem osztjuk meg senki mással.';
z.string.hu.searchInviteButtonContacts = 'Névjegyekből';
z.string.hu.searchInviteButtonGmail = 'Gmail-ből';
z.string.hu.searchInviteHeadline = 'Hozd a barátaidat is';
z.string.hu.searchInviteShare = 'Névjegyek megosztása';

z.string.hu.searchServiceConfirmButton = 'Új szolgáltatás';

z.string.hu.searchListEveryoneParticipates = 'Az összes partnered, \nakivel felvetted a kapcsolatot,\nmár ebben a beszélgetésben van.';
z.string.hu.searchListNoMatches = 'Nincs találat. \nPróbálj megy egy másik nevet.';

z.string.hu.temporaryGuestCta = 'Fiók létrehozása';
z.string.hu.temporaryGuestDescription = 'Tedd biztonságosabbá vállalkozásodat a csoportos üzenetek és beszélgetések titkosításával.';
z.string.hu.temporaryGuestTimeRemaining = ' maradt ebben a vendégszobában';

z.string.hu.temporaryGuestJoinMessage = 'Ez a beszélgetés 24 órán keresztül lesz elérhető.';
z.string.hu.temporaryGuestJoinDescription = 'Ha bezárod vagy újratöltöd ezt az oldalt, akkor elveszted a hozzáférésed.';

z.string.hu.temporaryGuestLeaveMessage = ' már nem részesei ennek a beszélgetésnek.';
z.string.hu.temporaryGuestLeaveDescription = 'Ha bezárod vagy újratöltöd ezt az oldalt, akkor elveszted a hozzáférést a beszélgetés előzményeihez.';

z.string.hu.uploadGoogleHeadline = 'Keress partnereket\na Wire-ön.';
z.string.hu.uploadGoogleMessage = 'A névjegyeid importálásával könnyebben kapcsolatba léphetsz másokkal. Minden információt anonimizálunk, és semmit nem osszuk meg senki mással.';

z.string.hu.urlSupportRoot = '/';
z.string.hu.urlSupportArticles = '/hc/en-us/articles/';
z.string.hu.urlSupportRequests = '/hc/en-us/requests/';
z.string.hu.urlWebappRoot = '/';
z.string.hu.urlWebsiteRoot = '/';
z.string.hu.urlWebsiteCreateTeam = '/csapat-létrehozása/';
z.string.hu.urlWebsitePrivacy = '/adatvédelem';
z.string.hu.warningCallUnsupportedIncoming = '{{user}} hív. Böngésződ nem támogatja a hanghívásokat.';
z.string.hu.warningCallUnsupportedOutgoing = 'Nem kezdeményezhetsz hívást, mert böngésződ nem támogatja a hanghívásokat.';
z.string.hu.warningCallIssues = 'Ezzel a Wire verzióval nem tudsz részt venni a hívásban. Kérjük, használd ezt:';
z.string.hu.warningCallUpgradeBrowser = 'Kérjük, hogy hanghívásokhoz frissítsd a Google Chrome-ot.';
z.string.hu.warningConnectivityConnectionLost = 'Kapcsolódási kísérlet folyamatban. A Wire most nem tud üzeneteket kézbesíteni.';
z.string.hu.warningConnectivityNoInternet = 'Nincs internet. Üzenetek küldése és fogadása most nem lehetséges.';
z.string.hu.warningLearnMore = 'További információ';
z.string.hu.warningLifecycleUpdate = 'Elérhető a Wire új verziója.';
z.string.hu.warningLifecycleUpdateNotes = 'Újdonságok';
z.string.hu.warningLifecycleUpdateLink = 'Frissítés most';
z.string.hu.warningNotFoundCamera = 'Nem kezdeményezhetsz hívást, mert nincs kamerád.';
z.string.hu.warningNotFoundMicrophone = 'Nem kezdeményezhetsz hívást, mert nincs mikrofonod.';
z.string.hu.warningPermissionDeniedCamera = 'Nem kezdeményezhetsz hívást, mert böngésződ nem férhet hozzá a kamerádhoz.';
z.string.hu.warningPermissionDeniedMicrophone = 'Nem kezdeményezhetsz hívást, mert böngésződ nem férhet hozzá a mikrofonodhoz.';
z.string.hu.warningPermissionDeniedScreen = 'A képernyőmegosztást engedélyezned kell a böngészőben.';
z.string.hu.warningPermissionRequestCamera = '{{icon}} Kamera hozzáférés engedélyezése';
z.string.hu.warningPermissionRequestMicrophone = '{{icon}} Mikrofon hozzáférés engedélyezése';
z.string.hu.warningPermissionRequestNotification = '{{icon}} Értesítések engedélyezése';
z.string.hu.warningPermissionRequestScreen = '{{icon}} Képernyőmegosztás engedélyezése';

z.string.hu.userAvailabilityAvailable = 'Elérhető';
z.string.hu.userAvailabilityAway = 'Nincs a gépnél';
z.string.hu.userAvailabilityBusy = 'Elfoglalt';
z.string.hu.userAvailabilityNone = 'Semmi';

z.string.hu.notificationAssetAdd = 'Megosztott egy képet';
z.string.hu.notificationConnectionAccepted = 'Elfogadta a csatlakozási kérelmedet';
z.string.hu.notificationConnectionConnected = 'Most már csatlakozva vagytok';
z.string.hu.notificationConnectionRequest = 'Szeretne csatlakozni';
z.string.hu.notificationConversationCreate = '{{user}} beszélgetést indított';
z.string.hu.notificationConversationRename = '{{user}} átnevezte a beszélgetést erre: {{name}}';
z.string.hu.notificationMemberJoinMany = '{{user}} hozzáadott {{number}} partnert a beszélgetéshez';
z.string.hu.notificationMemberJoinSelf = '{{user}} csatlakozott a beszélgetéshez';
z.string.hu.notificationMemberJoinOne = '{{user1}} hozzáadta {{user2}} partnert a beszélgetéshez';
z.string.hu.notificationMemberLeaveRemovedYou = '{{user}} eltávolított a beszélgetésből';
z.string.hu.notificationObfuscated = 'Üzenetet küldött';
z.string.hu.notificationObfuscatedTitle = 'Valaki';
z.string.hu.notificationPing = 'Kopogott';
z.string.hu.notificationReaction = 'Reagált egy üzenetre: {{reaction}}';
z.string.hu.notificationSharedAudio = 'Megosztott egy hangüzenetet';
z.string.hu.notificationSharedFile = 'Megosztott egy fájlt';
z.string.hu.notificationSharedLocation = 'Megosztott egy helyet';
z.string.hu.notificationSharedVideo = 'Megosztott egy videót';
z.string.hu.notificationVoiceChannelActivate = 'Hív';
z.string.hu.notificationVoiceChannelDeactivate = 'Hívta';

z.string.hu.tooltipConversationAllVerified = 'Minden ujjlenyomat ellenőrizve';
z.string.hu.tooltipConversationCall = 'Hívás';
z.string.hu.tooltipConversationEphemeral = 'Időzített üzenet';
z.string.hu.tooltipConversationFile = 'Fájl hozzáadása';
z.string.hu.tooltipConversationInputPlaceholder = 'Üzenet írása';
z.string.hu.tooltipConversationInputPlaceholderAvailable = '{{user}} elérhető';
z.string.hu.tooltipConversationInputPlaceholderAway = '{{user}} nincs a gépnél';
z.string.hu.tooltipConversationInputPlaceholderBusy = '{{user}} elfoglalt';
z.string.hu.tooltipConversationPeople = 'Partnerek ({{shortcut}})';
z.string.hu.tooltipConversationPicture = 'Kép hozzáadása';
z.string.hu.tooltipConversationPing = 'Kopogás ({{shortcut}})';
z.string.hu.tooltipConversationSearch = 'Keresés';
z.string.hu.tooltipConversationVideoCall = 'Videóhívás';

z.string.hu.tooltipConversationsArchive = 'Archiválás ({{shortcut}})';
z.string.hu.tooltipConversationsArchived = 'Archívum megtekintése ({{number}})';
z.string.hu.tooltipConversationsMore = 'Továbbiak';
z.string.hu.tooltipConversationsNotify = 'Némítás feloldása ({{shortcut}})';
z.string.hu.tooltipConversationsPreferences = 'Beállítások megnyitása';
z.string.hu.tooltipConversationsSilence = 'Némítás ({{shortcut}})';
z.string.hu.tooltipConversationsStart = 'Beszélgetés megkezdése ({{shortcut}})';

z.string.hu.tooltipConversationDetailsAddPeople = 'Résztvevők hozzáadása a beszélgetéshez ({{shortcut}})';
z.string.hu.tooltipConversationDetailsRename = 'Beszélgetés nevének megváltoztatása';

z.string.hu.tooltipPreferencesContactsGmail = 'Kapcsolataid megosztásához jelentkezz be Gmail fiókodba';
z.string.hu.tooltipPreferencesContactsMacos = 'Oszd meg névjegyeidet a macOS Névjegyek alkalmazásából';
z.string.hu.tooltipPreferencesPassword = 'Nyiss meg egy másik weboldalt jelszavad visszaállításához';
z.string.hu.tooltipPreferencesPicture = 'Profilkép módosítása…';
z.string.hu.tooltipPreferencesRename = 'Név módosítása';

z.string.hu.tooltipSearchClose = 'Bezárás (Esc)';

z.string.hu.initReceivedSelfUser = 'Szia {{user}}!';
z.string.hu.initValidatedClient = 'Kapcsolatok és a beszélgetések lekérése';
z.string.hu.initReceivedUserData = 'Új üzenetek megtekintése';
z.string.hu.initDecryption = 'Üzenetek visszafejtése';
z.string.hu.initEvents = 'Üzenetek betöltése';
z.string.hu.initUpdatedFromNotifications = 'Majdnem kész - Élvezd a Wire-t';
z.string.hu.initProgress = ' — {{number1}} / {{number2}}';

z.string.hu.ephemeralUnitsNone = 'Kikapcsolva';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.it.wireMacos = 'Wire per macOS';
z.string.it.wireWindows = 'Wire per Windows';
z.string.it.wireLinux = 'Wire per Linux';
z.string.it.nonexistentUser = 'Elimina utente';
z.string.it.and = 'e';

z.string.it.authAccountCountryCode = 'Codice del paese';
z.string.it.authAccountPasswordForgot = 'Ho dimenticato la password';
z.string.it.authAccountPublicComputer = 'Questo computer è pubblico';
z.string.it.authAccountSignIn = 'Accedi';
z.string.it.authAccountSignInPhone = 'Telefono';

z.string.it.authBlockedDatabase = 'Wire ha bisogno di accedere la memoria locale per visualizzare i messaggi. Archiviazione locale non è disponibile in modalità privata.';
z.string.it.authBlockedTabs = 'Wire è già aperto in un’altra scheda.';

z.string.it.authVerifyAccountAdd = 'Aggiungi';
z.string.it.authVerifyAccountDetail = 'Questo ti consente di usare Wire su più dispositivi.';
z.string.it.authVerifyAccountHeadline = 'Aggiungi indirizzo email e password.';
z.string.it.authVerifyAccountLogout = 'Logout';
z.string.it.authVerifyCodeDescription = 'Inserisci il codice di verifica che abbiamo inviato a {{number}}.';
z.string.it.authVerifyCodeResend = 'Non hai ricevuto nessun codice?';
z.string.it.authVerifyCodeResendDetail = 'Inviare di nuovo';
z.string.it.authVerifyCodeResendTimer = 'È possibile richiedere un nuovo codice {{expiration}}.';
z.string.it.authVerifyCodeChangePhone = 'Cambia numero di telefono';
z.string.it.authVerifyPasswordHeadline = 'Inserisci la tua password';

z.string.it.authLimitDevicesHeadline = 'Dispositivi';
z.string.it.authLimitDescription = 'Rimuovi uno dei tuoi dispositivi per iniziare a utilizzare Wire su questo.';
z.string.it.authLimitButtonManage = 'Gestione dei dispositivi';
z.string.it.authLimitButtonSignOut = 'Logout';
z.string.it.authLimitDevicesCurrent = '(Corrente)';

z.string.it.authHistoryHeadline = 'È la prima volta che utilizzi Wire questo dispositivo.';
z.string.it.authHistoryDescription = 'Per motivi di privacy, la cronologia delle tue conversazioni non apparirà qui.';
z.string.it.authHistoryReuseHeadline = 'Hai utilizzato Wire su questo dispositivo prima.';
z.string.it.authHistoryReuseDescription = 'I messaggi inviati nel frattempo non verranno visualizzati qui.';
z.string.it.authHistoryButton = 'OK';

z.string.it.authPostedResend = 'Invia di nuovo a {{email}}';
z.string.it.authPostedResendAction = 'Non hai ricevuto nessuna email?';
z.string.it.authPostedResendDetail = 'Verifica la tua casella di posta e segui le istruzioni.';
z.string.it.authPostedResendHeadline = 'C’è posta per te.';

z.string.it.authPlaceholderEmail = 'Email';
z.string.it.authPlaceholderPasswordPut = 'Password';
z.string.it.authPlaceholderPasswordSet = 'Password (almeno 8 caratteri)';
z.string.it.authPlaceholderPhone = 'Numero di telefono';

z.string.it.authErrorCode = 'Codice non valido';
z.string.it.authErrorCountryCodeInvalid = 'Prefisso paese non valido';
z.string.it.authErrorEmailExists = 'Indirizzo email già registrato';
z.string.it.authErrorEmailForbidden = 'Siamo spiacenti. Questo indirizzo email è vietato.';
z.string.it.authErrorEmailMalformed = 'Inserisci un indirizzo email valido.';
z.string.it.authErrorEmailMissing = 'Inserisci un indirizzo email.';
z.string.it.authErrorMisc = 'Problemi di connessione. Riprova.';
z.string.it.authErrorNameShort = 'Inserisci un nome con almeno 2 caratteri';
z.string.it.authErrorOffline = 'Nessuna connessione internet';
z.string.it.authErrorPasswordShort = 'Scegli una password con almeno 8 caratteri.';
z.string.it.authErrorPasswordWrong = 'Password errata. Riprova.';
z.string.it.authErrorPhoneNumberBudget = 'Hai eseguito l’accesso troppo spesso. Riprova più tardi.';
z.string.it.authErrorPhoneNumberForbidden = 'Spiacenti. Questo numero di telefono è vietato.';
z.string.it.authErrorPhoneNumberInvalid = 'Numero di telefono non valido';
z.string.it.authErrorPhoneNumberUnknown = 'Numero di telefono sconosciuto';
z.string.it.authErrorSuspended = 'Questo account non è più autorizzato ad accedere.';
z.string.it.authErrorSignIn = 'Verifica i tuoi dati e riprova.';

z.string.it.callStateOutgoing = 'Sta squillando…';
z.string.it.callStateConnecting = 'Connessione in corso…';
z.string.it.callStateIncoming = 'Chiamata in corso…';
z.string.it.callDecline = 'Rifiuta';
z.string.it.callAccept = 'Accetta';
z.string.it.callJoin = 'Entra';
z.string.it.callChooseSharedScreen = 'Scegli quale schermata condividere';
z.string.it.callParticipants = '{{number}} nella chiamata';

z.string.it.videoCallOverlayMute = 'Silenzia';
z.string.it.videoCallOverlayHangUp = 'Riattacca';

z.string.it.modalAcknowledgeAction = 'Ok';
z.string.it.modalConfirmSecondary = 'Annulla';
z.string.it.modalOptionSecondary = 'Annulla';

z.string.it.modalAccountCreateAction = 'OK';

z.string.it.modalAccountDeletionAction = 'Elimina';
z.string.it.modalAccountDeletionHeadline = 'Elimina account';
z.string.it.modalAccountDeletionMessage = 'Ti invieremo un SMS o una email. Segui il link per eliminare definitivamente il tuo account.';

z.string.it.modalAccountLeaveGuestRoomAction = 'Abbandona';

z.string.it.modalAccountLogoutAction = 'Logout';
z.string.it.modalAccountLogoutHeadline = 'Cancella dati?';
z.string.it.modalAccountLogoutOption = 'Elimina tutti i tuoi dati personali e le conversazioni su questo dispositivo.';

z.string.it.modalAccountNewDevicesSecondary = 'Gestione dei dispositivi';
z.string.it.modalAccountNewDevicesHeadline = 'Il tuo account è stato utilizzato su:';
z.string.it.modalAccountNewDevicesFrom = 'Da:';
z.string.it.modalAccountNewDevicesMessage = 'Se non sei stato tu, riuovi il dispositivo e reimposta la password.';

z.string.it.modalAccountRemoveDeviceAction = 'Rimuovi dispositivo';
z.string.it.modalAccountRemoveDeviceHeadline = 'Rimuovi "{{device}}"';
z.string.it.modalAccountRemoveDeviceMessage = 'La tua password è necessaria per rimuovere il dispositivo.';
z.string.it.modalAccountRemoveDevicePlaceholder = 'Password';

z.string.it.modalAssetTooLargeMessage = 'Puoi inviare file fino a {{number}}';

z.string.it.modalAssetParallelUploadsMessage = 'È possibile inviare fino a {{number}} file in una sola volta.';

z.string.it.modalCallEmptyConversationHeadline = 'Nessuno da chiamare';
z.string.it.modalCallEmptyConversationMessage = 'Non c’è più nessuno qui.';

z.string.it.modalCallNoGroupVideoHeadline = 'Nessuna video chiamata nei gruppi';
z.string.it.modalCallNoGroupVideoMessage = 'Le videochiamate non sono disponibili nelle chat di gruppo.';

z.string.it.modalCallNoMicrophoneAction = 'Dimmi come';
z.string.it.modalCallNoMicrophoneMessage = 'Il browser ha bisogno di accedere al microfono per effettuare le chiamate.';
z.string.it.modalCallNoMicrophoneHeadline = 'Impossibile chiamare senza microfono';

z.string.it.modalCallSecondIncomingAction = 'Rispondi';
z.string.it.modalCallSecondIncomingHeadline = 'Rispondere alla chiamata?';
z.string.it.modalCallSecondIncomingMessage = 'La chiamata attuale terminerà.';

z.string.it.modalCallSecondOngoingAction = 'Riattacca';
z.string.it.modalCallSecondOngoingHeadline = 'Riagganciare la chiamata su un altro dispositivo?';
z.string.it.modalCallSecondOngoingMessage = 'È possibile partecipare a una sola chiamata alla volta.';

z.string.it.modalCallSecondOutgoingAction = 'Riattacca';
z.string.it.modalCallSecondOutgoingHeadline = 'Riagganciare la chiamata corrente?';
z.string.it.modalCallSecondOutgoingMessage = 'È possibile partecipare a una sola chiamata alla volta.';

z.string.it.modalConnectCancelAction = 'Sì';
z.string.it.modalConnectCancelHeadline = 'Annullare la richiesta?';
z.string.it.modalConnectCancelMessage = 'Rimuovere la richiesta di connessione a {{user}}.';
z.string.it.modalConnectCancelSecondary = 'No';

z.string.it.modalConnectAcceptAction = 'Connetti';
z.string.it.modalConnectAcceptHeadline = 'Accettare?';
z.string.it.modalConnectAcceptMessage = 'Questo ti collegherà e aprirà la conversazione con {{user}}.';
z.string.it.modalConnectAcceptSecondary = 'Ignora';

z.string.it.modalConversationClearAction = 'Elimina';
z.string.it.modalConversationClearHeadline = 'Eliminare il contenuto?';
z.string.it.modalConversationClearOption = 'In aggiunta, abbandona la conversazione';

z.string.it.modalConversationDeleteMessageAction = 'Elimina';
z.string.it.modalConversationDeleteMessageHeadline = 'Eliminare solo per me?';
z.string.it.modalConversationDeleteMessageMessage = 'Questa azione non può essere annullata.';

z.string.it.modalConversationDeleteMessageEveryoneAction = 'Elimina';
z.string.it.modalConversationDeleteMessageEveryoneHeadline = 'Eliminare per tutti?';
z.string.it.modalConversationDeleteMessageEveryoneMessage = 'Questa azione non può essere annullata.';

z.string.it.modalConversationLeaveAction = 'Abbandona';
z.string.it.modalConversationLeaveMessage = 'Non sarai più in grado di inviare o ricevere messaggi in questa conversazione.';

z.string.it.modalConversationMessageTooLongHeadline = 'Messaggio troppo lungo';
z.string.it.modalConversationMessageTooLongMessage = 'È possibile inviare messaggi fino a {{number}} caratteri.';

z.string.it.modalConversationNewDeviceHeadlineOne = '{{user}} ha iniziato a utilizzare un nuovo dispositivo';
z.string.it.modalConversationNewDeviceHeadlineMany = '{{user}}s ha iniziato a utilizzare nuovi dispositivi';
z.string.it.modalConversationNewDeviceHeadlineYou = '{{user}} ha iniziato a utilizzare un nuovo dispositivo';
z.string.it.modalConversationNewDeviceIncomingCallAction = 'Accetta la chiamata';
z.string.it.modalConversationNewDeviceIncomingCallMessage = 'Vuoi accettare la chiamata?';
z.string.it.modalConversationNewDeviceMessage = 'Vuoi comunque mandare il messaggio?';
z.string.it.modalConversationNewDeviceOutgoingCallAction = 'Chiama comunque';
z.string.it.modalConversationNewDeviceOutgoingCallMessage = 'Vuoi effettuare la chiamata?';

z.string.it.modalConversationNotConnectedMessageOne = '{{name}} non vuole partecipare alle conversazioni.';
z.string.it.modalConversationNotConnectedMessageMany = 'Una delle persone che hai selezionato non vuole essere aggiunta alle conversazioni.';

z.string.it.modalConversationRemoveAction = 'Rimuovi';
z.string.it.modalConversationRemoveHeadline = 'Rimuovere?';
z.string.it.modalConversationRemoveMessage = '{{user}} non sarà in grado di inviare o ricevere messaggi in questa conversazione.';

z.string.it.modalConversationRemoveGuestsAction = 'Rimuovi';

z.string.it.modalConversationTooManyMembersHeadline = 'Chiamata piena';



z.string.it.modalImproveWireAction = 'Accetta';
z.string.it.modalImproveWireSecondary = 'No';

z.string.it.modalSessionResetHeadline = 'La sessione è stata reimpostata';
z.string.it.modalSessionResetMessage1 = 'Se il problema non viene risolto,';
z.string.it.modalSessionResetMessageLink = 'contatta';
z.string.it.modalSessionResetMessage2 = 'Wire.';

z.string.it.modalUploadContactsAction = 'Riprova';
z.string.it.modalUploadContactsMessage = 'Non abbiamo ricevuto i tuoi dati. Per favore riprova ad importare i tuoi contatti.';

z.string.it.modalUserBlockAction = 'Blocca';
z.string.it.modalUserBlockHeadline = 'Bloccare {{user}}?';
z.string.it.modalUserBlockMessage = '{{user}} non sarà in grado di contattarti o aggiungerti alle conversazioni di gruppo.';

z.string.it.modalUserUnblockAction = 'Sblocca';
z.string.it.modalUserUnblockHeadline = 'Sblocca?';
z.string.it.modalUserUnblockMessage = '{{user}} sarà in grado di contattarti e aggiungerti alle conversazioni di gruppo di nuovo.';

z.string.it.connectionRequestConnect = 'Connetti';
z.string.it.connectionRequestIgnore = 'Ignora';

z.string.it.conversationGuestIndicator = 'Ospite';

z.string.it.conversationYouNominative = 'tu';
z.string.it.conversationYouDative = 'tu';
z.string.it.conversationYouAccusative = 'tu';

z.string.it.conversationConnectionAccepted = 'Connesso';
z.string.it.conversationConnectionBlocked = 'Bloccato';
z.string.it.conversationConnectionCancelRequest = 'Annulla la richiesta di connessione';
z.string.it.conversationDeviceStartedUsingOne = ' ha iniziato ad usare';
z.string.it.conversationDeviceStartedUsingMany = ' ha iniziato ad usare';
z.string.it.conversationDeviceUnverified = ' hai tolto la verifica di';
z.string.it.conversationDeviceYourDevices = ' i tuoi dispositivi';
z.string.it.conversationDeviceUserDevices = ' Dispositivi di {{user}}’s';
z.string.it.conversationDeviceNewDeviceOne = ' un nuovo dispositivo';
z.string.it.conversationDeviceNewDeviceMany = ' nuovi dispositivi';
z.string.it.conversationDeviceNewPeopleJoinedVerify = ' verifica i dispositivi';
z.string.it.conversationJustNow = 'Adesso';
z.string.it.conversationLocationLink = 'Apri mappa';
z.string.it.conversationMessageDelivered = 'Consegnato';
z.string.it.conversationRename = ' ha rinominato la conversazione';
z.string.it.conversationRenameYou = ' ha rinominato la conversazione';
z.string.it.conversationResume = 'Inizia una conversazione con {{users}}';
z.string.it.conversationPing = ' ha fatto un trillo';
z.string.it.conversationPingYou = ' ha fatto un trillo';
z.string.it.conversationToday = 'oggi';
z.string.it.conversationVoiceChannelDeactivate = ' ha chiamato';
z.string.it.conversationVoiceChannelDeactivateYou = ' ha chiamato';
z.string.it.conversationYesterday = 'Ieri';
z.string.it.conversationUnableToDecrypt1 = 'un messaggio da {{user}} non è stato ricevuto.';
z.string.it.conversationUnableToDecrypt2 = 'L’identità dei dispositivi {{user}}´s è cambiata. Messaggi non consegnati.';
z.string.it.conversationUnableToDecryptLink = 'Perchè?';
z.string.it.conversationUnableToDecryptErrorMessage = 'Errore';
z.string.it.conversationUnableToDecryptResetSession = 'Resetta la sessione';
z.string.it.conversationMissedMessages = 'È da un po’ di tempo che non utilizzi questo dispositivo. Alcuni messaggi potrebbero non apparire qui.';
z.string.it.conversationAssetDownloading = 'Download in corso…';
z.string.it.conversationAssetUploadFailed = 'Caricamento fallito';
z.string.it.conversationPlaybackError = 'Impossibile riprodurre';
z.string.it.conversationContextMenuCopy = 'Copia';
z.string.it.conversationContextMenuEdit = 'Modifica';
z.string.it.conversationContextMenuDelete = 'Elimina per me';
z.string.it.conversationContextMenuDeleteEveryone = 'Elimina per tutti';
z.string.it.conversationContextMenuDownload = 'Scarica';
z.string.it.conversationContextMenuLike = 'Mi piace';
z.string.it.conversationContextMenuUnlike = 'Non mi piace più';
z.string.it.conversationDeleteTimestamp = 'Cancellato il {{date}}';
z.string.it.conversationEditTimestamp = 'Modificato il {{date}}';
z.string.it.conversationLikesCaption = '{{number}} persone';
z.string.it.conversationSendPastedFile = 'Immagine incollata alle {{date}}';
z.string.it.conversationSomeone = 'Qualcuno';
z.string.it.conversationTweetAuthor = ' su Twitter';

z.string.it.groupCreationParticipantsPlaceholder = 'Cerca per nome';


z.string.it.collectionShowAll = 'Mostra tutti i {{number}}';
z.string.it.collectionSectionLinks = 'Link';
z.string.it.collectionSectionImages = 'Immagini';
z.string.it.collectionSectionFiles = 'Files';
z.string.it.collectionSectionAudio = 'Messaggi audio';

z.string.it.fullsearchPlaceholder = 'Cerca messaggi di testo';
z.string.it.fullsearchNoResults = 'Nessun risultato.';

z.string.it.archiveHeader = 'Archivia';

z.string.it.conversationsAllArchived = 'Tutto archiviato';
z.string.it.conversationsContacts = 'Contatti';
z.string.it.conversationsConnectionRequestMany = '{{number}} persone in attesa';
z.string.it.conversationsConnectionRequestOne = '1 persona in attesa';
z.string.it.conversationsEmptyConversation = 'Conversazione di gruppo';
z.string.it.conversationsNoConversations = 'Nessuna conversazione';
z.string.it.conversationsPopoverArchive = 'Archivia';
z.string.it.conversationsPopoverCancel = 'Annulla richiesta';
z.string.it.conversationsPopoverNotify = 'Riattiva audio';
z.string.it.conversationsPopoverSilence = 'Silenzia';
z.string.it.conversationsPopoverUnarchive = 'Disarchivia';

z.string.it.conversationsSecondaryLineEphemeralMessage = 'Ti ha inviato un messaggio';
z.string.it.conversationsSecondaryLinePeopleLeft = '{{number}} utenti hanno abbandonato';
z.string.it.conversationsSecondaryLinePersonLeft = '{{user}} ha abbandonato';
z.string.it.conversationsSecondaryLinePersonRemoved = '{{user}} è stato rimosso';
z.string.it.conversationsSecondaryLinePeopleAdded = '{{user}} persone sono state aggiunte';
z.string.it.conversationsSecondaryLinePersonAdded = '{{user}} è stato aggiunto';
z.string.it.conversationsSecondaryLinePersonAddedYou = '{{user}} ti ha aggiunto';
z.string.it.conversationsSecondaryLineRenamed = '{{user}} ha cambiato nome di conversazione';
z.string.it.conversationsSecondaryLineYouLeft = 'Hai abbandonato';
z.string.it.conversationsSecondaryLineYouWereRemoved = 'Sei stato rimosso';

z.string.it.takeoverSub = 'Rivendica il tuo username su Wire.';
z.string.it.takeoverLink = 'Ulteriori informazioni';
z.string.it.takeoverButtonChoose = 'Scegli il tuo';
z.string.it.takeoverButtonKeep = 'Tieni questo';

z.string.it.inviteMetaKeyMac = 'Cmd';
z.string.it.inviteMetaKeyPc = 'Ctrl';
z.string.it.inviteHeadline = 'Invita amici ad usare Wire';
z.string.it.inviteMessage = 'Sono su Wire, cerca {{username}} o visita get.wire.com.';
z.string.it.inviteMessageNoEmail = 'Sono su Wire. Visita get.wire.com per connetterti con me.';

z.string.it.extensionsBubbleButtonGif = 'Gif';

z.string.it.extensionsGiphyButtonOk = 'Invia';
z.string.it.extensionsGiphyButtonMore = 'Prova un altro';
z.string.it.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.it.extensionsGiphyNoGifs = 'Oops, nessuna gif';
z.string.it.extensionsGiphyRandom = 'Scelta casuale';

z.string.it.addParticipantsConfirmLabel = 'Aggiungi';
z.string.it.addParticipantsSearchPlaceholder = 'Cerca per nome';
z.string.it.addParticipantsTabsPeople = 'Persone';
z.string.it.addParticipantsTabsServices = 'Servizi';

z.string.it.conversationDetailsActionArchive = 'Archivia';
z.string.it.conversationDetailsActionCancelRequest = 'Annulla richiesta';
z.string.it.conversationDetailsActionDevices = 'Dispositivi';
z.string.it.conversationDetailsActionNotifications = 'Notifiche';
z.string.it.conversationDetailsGuestsOff = 'Off';
z.string.it.conversationDetailsOptions = 'Opzioni';
z.string.it.conversationDetailsParticipantsServicesMany = 'Servizi';
z.string.it.conversationDetailsParticipantsUsersMany = 'Persone';
z.string.it.conversationDetailsPeople = 'Persone';
z.string.it.conversationDetailsServices = 'Servizi';

z.string.it.conversationParticipantsTitle = 'Persone';
z.string.it.conversationParticipantsSearchPlaceholder = 'Cerca per nome';

z.string.it.groupParticipantActionCancelRequest = 'Annulla richiesta';
z.string.it.groupParticipantActionDevices = 'Dispositivi';
z.string.it.groupParticipantActionPending = 'In sospeso';
z.string.it.groupParticipantActionSendRequest = 'Connetti';

z.string.it.notificationSettingsTitle = 'Notifiche';

z.string.it.participantDevicesDetailHeadline = 'Verifica che questo corrisponda all’impronta digitale sul {{html1}}dispositivo di {{user}}{{html2}}.';
z.string.it.participantDevicesDetailHowTo = 'Come si fa?';
z.string.it.participantDevicesDetailResetSession = 'Resetta la sessione';
z.string.it.participantDevicesDetailShowMyDevice = 'Visualizza impronta digitale del dispositivo';
z.string.it.participantDevicesDetailVerify = 'Verificato';

z.string.it.participantDevicesHeader = 'Dispositivi';
z.string.it.participantDevicesHeadline = 'Wire dà un’impronta unica a ogni dispositivo. Confrontale con {{user}} e verifica la tua conversazione.';
z.string.it.participantDevicesLearnMore = 'Ulteriori informazioni';
z.string.it.participantDevicesWhyVerify = 'Perché verificare le conversazioni?';
z.string.it.participantDevicesOutdatedClientMessage = '{{user}} sta utilizzando una vecchia versione di Wire. Nessun dispositivo da visualizzare qui.';

z.string.it.participantDevicesSelfAllDevices = 'Mostra tutti i miei dispositivi';
z.string.it.participantDevicesSelfFingerprint = 'Impronta digitale dispositivo';

z.string.it.userProfileButtonConnect = 'Connetti';
z.string.it.userProfileButtonIgnore = 'Ignora';
z.string.it.userProfileButtonUnblock = 'Sblocca';

z.string.it.preferencesAbout = 'Info';
z.string.it.preferencesAccount = 'Account';
z.string.it.preferencesAV = 'Audio / Video';
z.string.it.preferencesDeviceDetails = 'Dettagli sul dispositivo';
z.string.it.preferencesDevices = 'Dispositivi';
z.string.it.preferencesHeadline = 'Preferenze';
z.string.it.preferencesOptions = 'Opzioni';

z.string.it.preferencesAboutPrivacyPolicy = 'Normativa sulla privacy';
z.string.it.preferencesAboutSupport = 'Supporto';
z.string.it.preferencesAboutSupportWebsite = 'Sito di assistenza';
z.string.it.preferencesAboutSupportContact = 'Contatta il supporto';
z.string.it.preferencesAboutTermsOfUse = 'Termini d’uso';
z.string.it.preferencesAboutVersion = 'Versione {{version}}';
z.string.it.preferencesAboutWebsite = 'Sito di Wire';

z.string.it.preferencesAccountCreateTeam = 'Crea un team';
z.string.it.preferencesAccountDelete = 'Elimina account';
z.string.it.preferencesAccountLogOut = 'Logout';
z.string.it.preferencesAccountManageTeam = 'Gestione Team';
z.string.it.preferencesAccountResetPassword = 'Reimposta la password';
z.string.it.preferencesAccountTeam = 'in {{name}}';
z.string.it.preferencesAccountUsernamePlaceholder = 'Il tuo nome e cognome';
z.string.it.preferencesAccountUsernameHint = 'Almeno 2 caratteri. a-z, 0-9 e solo _.';
z.string.it.preferencesAccountUsernameAvailable = 'Disponibile';
z.string.it.preferencesAccountUsernameErrorTaken = 'E’ già stato scelto';

z.string.it.preferencesAVCamera = 'Fotocamera';
z.string.it.preferencesAVMicrophone = 'Microfono';
z.string.it.preferencesAVPermissionDetail = 'Attiva dalle tue preferenze di browser';
z.string.it.preferencesAVSpeakers = 'Altoparlanti';

z.string.it.preferencesDevicesActivatedOn = 'Attivato il {{date}}';
z.string.it.preferencesDevicesActive = 'Attivi';
z.string.it.preferencesDevicesActiveDetail = 'Se non riconosci un dispositivo qui sopra, rimuovilo e reimposta la password.';
z.string.it.preferencesDevicesCurrent = 'Attuale';
z.string.it.preferencesDevicesFingerprint = 'Impronta digitale della chiave';
z.string.it.preferencesDevicesFingerprintDetail = 'Wire dà un impronta digitale unica a ogni dispositivo. Confrontale per verificare i tuoi dispositivi e le conversazioni.';
z.string.it.preferencesDevicesId = 'ID: ';
z.string.it.preferencesDevicesRemoveCancel = 'Annulla';
z.string.it.preferencesDevicesRemoveDetail = 'RimuovI questo dispositivo se hai smesso di usarlo. Verrai disconnesso immediatamente.';
z.string.it.preferencesDevicesSessionConfirmation = 'La sessione è stata resettata.';
z.string.it.preferencesDevicesSessionDetail = 'Se le impronte digitali non corrispondono, è necessario resettare la sessione per generare nuove chiavi di crittografia da entrambe le parti.';
z.string.it.preferencesDevicesSessionReset = 'Resetta la sessione';
z.string.it.preferencesDevicesSessionOngoing = 'Resettando la sessione…';
z.string.it.preferencesDevicesVerification = 'Verificato';

z.string.it.preferencesOptionsAudio = 'Suoni notifiche';
z.string.it.preferencesOptionsAudioAll = 'Tutti';
z.string.it.preferencesOptionsAudioAllDetail = 'Tutti i suoni';
z.string.it.preferencesOptionsAudioNone = 'Nessuno';
z.string.it.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.it.preferencesOptionsAudioSome = 'Alcuni';
z.string.it.preferencesOptionsAudioSomeDetail = 'Trilli e chiamate';
z.string.it.preferencesOptionsContacts = 'Contatti';
z.string.it.preferencesOptionsContactsGmail = 'Importa da Gmail';
z.string.it.preferencesOptionsContactsMacos = 'Importa dalla rubrica';
z.string.it.preferencesOptionsContactsDetail = 'Utilizziamo i dati del tuo contatto per connetterti con gli altri. Rendiamo anonime tutte le informazioni e non le condividiamo con nessuno.';
z.string.it.preferencesOptionsPopular = 'A grande richiesta';
z.string.it.preferencesOptionsEmojiReplaceCheckbox = 'Sostituire il tipo emoticon con Emoji';
z.string.it.preferencesOptionsPreviewsSendCheckbox = 'Genera anteprime per i link inviati da te';
z.string.it.preferencesOptionsPreviewsSendDetail = 'È possibile che vengano comunque mostrate delle anteprime per i link inviati dagli altri utenti.';
z.string.it.preferencesOptionsNotifications = 'Notifiche';
z.string.it.preferencesOptionsNotificationsNone = 'Off';
z.string.it.preferencesOptionsNotificationsObfuscate = 'Nascondi dettagli';
z.string.it.preferencesOptionsNotificationsObfuscateMessage = 'Mostra mittente';
z.string.it.preferencesOptionsNotificationsOn = 'Mostra mittente e messaggio';

z.string.it.backupCancel = 'Annulla';

z.string.it.searchConnect = 'Connetti';
z.string.it.searchConnections = 'Connessioni';
z.string.it.searchContacts = 'Contatti';
z.string.it.searchCreateGroup = 'Crea gruppo';
z.string.it.searchGroups = 'Gruppi';
z.string.it.searchPeople = 'Persone';
z.string.it.searchPlaceholder = 'Ricerca per nome o username';
z.string.it.searchServicePlaceholder = 'Cerca per nome';
z.string.it.searchServices = 'Servizi';
z.string.it.searchTeamGroups = 'Conversazioni di Team';
z.string.it.searchTeamMembers = 'Membri del team';
z.string.it.searchTopPeople = 'Contattati frequenti';
z.string.it.searchTrySearch = 'Trova le persone per nome o username';
z.string.it.searchNoContactsOnWire = 'Non hai nessun contatto su Wire. Prova a trovare persone per nome o username.';
z.string.it.searchOthers = 'Connetti';

z.string.it.searchInvite = 'Invita amici ad usare Wire';
z.string.it.searchInviteDetail = 'Condividere i contatti dalla rubrica ti aiuta a connetterti con gli altri. Rendiamo tutte le informazioni dei contatti anonime e non sono cedute a nessun altro.';
z.string.it.searchInviteButtonContacts = 'Dalla rubrica';
z.string.it.searchInviteButtonGmail = 'Da Gmail';
z.string.it.searchInviteHeadline = 'Invita i tuoi amici';
z.string.it.searchInviteShare = 'Condividi contatti';

z.string.it.searchListEveryoneParticipates = 'Tutte le persone a cui sei connesso sono già in questa conversazione.';
z.string.it.searchListNoMatches = 'Nessun risultato corrispondente. Provare ad inserire un nome diverso.';


z.string.it.uploadGoogleHeadline = 'Trova persone con cui parlare.';
z.string.it.uploadGoogleMessage = 'Utilizziamo i dati del tuo contatto per connetterti con gli altri. Rendiamo anonime tutte le informazioni e non le condividiamo con nessuno.';

z.string.it.warningCallUnsupportedIncoming = '{{user}} sta chiamando. Il tuo browser non supporta le chiamate.';
z.string.it.warningCallUnsupportedOutgoing = 'Non puoi chiamare perchè il tuo browser non supporta le chiamate.';
z.string.it.warningCallIssues = 'Questa versione di Wire non può partecipare alla chiamata. Per favore usa';
z.string.it.warningCallUpgradeBrowser = 'Per chiamare, per favore aggiorna Google Chrome.';
z.string.it.warningConnectivityConnectionLost = 'Tentativo di connessione. Wire non è in grado di consegnare i messaggi.';
z.string.it.warningConnectivityNoInternet = 'Nessuna connessione. Non sarai in grado di inviare o ricevere messaggi.';
z.string.it.warningLearnMore = 'Ulteriori informazioni';
z.string.it.warningLifecycleUpdate = 'Una nuova versione di Wire è disponibile.';
z.string.it.warningLifecycleUpdateNotes = 'Novità';
z.string.it.warningLifecycleUpdateLink = 'Aggiorna Ora';
z.string.it.warningNotFoundCamera = 'Non puoi chiamare perchè il tuo computer non ha una webcam.';
z.string.it.warningNotFoundMicrophone = 'Non puoi chiamare perchè il tuo computer non ha un microfono.';
z.string.it.warningPermissionDeniedCamera = 'Non puoi chiamare perchè il tuo browser non ha accesso alla webcam.';
z.string.it.warningPermissionDeniedMicrophone = 'Non puoi chiamare perchè il tuo browser non ha accesso al microfono.';
z.string.it.warningPermissionDeniedScreen = 'Il browser richiede l’autorizzazione per condividere il tuo schermo.';
z.string.it.warningPermissionRequestCamera = '{{icon}} Consenti accesso alla webcam';
z.string.it.warningPermissionRequestMicrophone = '{{icon}} Consenti accesso al microfono';
z.string.it.warningPermissionRequestNotification = '{{icon}} Consenti notifiche';
z.string.it.warningPermissionRequestScreen = '{{icon}} Consenti accesso allo schermo';

z.string.it.userAvailabilityAvailable = 'Disponibile';
z.string.it.userAvailabilityNone = 'Nessuno';

z.string.it.notificationAssetAdd = 'Ha condiviso un’immagine';
z.string.it.notificationConnectionAccepted = 'Ha accettato la tua richiesta di connessione';
z.string.it.notificationConnectionConnected = 'Siete connessi ora';
z.string.it.notificationConnectionRequest = 'Vuole connettersi';
z.string.it.notificationConversationCreate = '{{user}} ha iniziato una conversazione';
z.string.it.notificationConversationRename = '{{user}} ha rinominato la conversazione in {{name}}';
z.string.it.notificationMemberJoinMany = '{{user}} ha aggiunto {{number}} persone alla conversazione';
z.string.it.notificationMemberJoinOne = '{{user1}} ha aggiunto {{user2}} alla conversazione';
z.string.it.notificationMemberLeaveRemovedYou = '{{user}} ti ha rimosso da una conversazione';
z.string.it.notificationObfuscated = 'Ti ha inviato un messaggio';
z.string.it.notificationObfuscatedTitle = 'Qualcuno';
z.string.it.notificationPing = 'Ha fatto un trillo';
z.string.it.notificationReaction = '{{reaction}} il tuo messaggio';
z.string.it.notificationSharedAudio = 'Ha condiviso un messaggio vocale';
z.string.it.notificationSharedFile = 'Ha condiviso un file';
z.string.it.notificationSharedLocation = 'Ha condiviso una posizione';
z.string.it.notificationSharedVideo = 'Ha condiviso un video';
z.string.it.notificationVoiceChannelActivate = 'Chiamata in corso';
z.string.it.notificationVoiceChannelDeactivate = 'Ha chamato';

z.string.it.tooltipConversationAllVerified = 'Tutte le impronte digitali sono state verificate';
z.string.it.tooltipConversationCall = 'Chiama';
z.string.it.tooltipConversationEphemeral = 'Messaggio a tempo';
z.string.it.tooltipConversationFile = 'Aggiungi file';
z.string.it.tooltipConversationInputPlaceholder = 'Digita un messaggio';
z.string.it.tooltipConversationPeople = 'Persone ({{shortcut}})';
z.string.it.tooltipConversationPicture = 'Aggiungi immagine';
z.string.it.tooltipConversationPing = 'Trillo ({{shortcut}})';
z.string.it.tooltipConversationSearch = 'Cerca';
z.string.it.tooltipConversationVideoCall = 'Videochiama';

z.string.it.tooltipConversationsArchive = 'Archivio ({{shortcut}})';
z.string.it.tooltipConversationsArchived = 'Mostra archivio ({{number}})';
z.string.it.tooltipConversationsMore = 'Altro';
z.string.it.tooltipConversationsNotify = 'Riattiva audio ({{shortcut}})';
z.string.it.tooltipConversationsPreferences = 'Apri le preferenze';
z.string.it.tooltipConversationsSilence = 'Silenzia ({{shortcut}})';
z.string.it.tooltipConversationsStart = 'Avviare conversazione ({{shortcut}})';

z.string.it.tooltipConversationDetailsRename = 'Cambia il nome della conversazione';

z.string.it.tooltipPreferencesContactsGmail = 'Accedi al tuo account Gmail per condividere i contatti';
z.string.it.tooltipPreferencesContactsMacos = 'Condividi tutti i tuoi contatti dall’app Contatti di macOS';
z.string.it.tooltipPreferencesPassword = 'Apri un altro sito per reimpostare la password';
z.string.it.tooltipPreferencesPicture = 'Cambia la tua foto…';
z.string.it.tooltipPreferencesRename = 'Cambia il tuo nome';

z.string.it.tooltipSearchClose = 'Chiudi (Esc)';

z.string.it.initReceivedSelfUser = 'Ciao, {{user}}.';
z.string.it.initValidatedClient = 'Caricamento delle tue connessioni e conversazioni';
z.string.it.initReceivedUserData = 'Controllo nuovi messaggi';
z.string.it.initDecryption = 'Decriptare i messaggi';
z.string.it.initEvents = 'Caricamento messaggi';

z.string.it.ephemeralUnitsNone = 'Off';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.lt.wire = 'Wire';
z.string.lt.wireMacos = 'Wire, skirta macOS';
z.string.lt.wireWindows = 'Wire, skirta Windows';
z.string.lt.wireLinux = 'Wire, skirta Linux';
z.string.lt.nonexistentUser = 'Ištrintas naudotojas';
z.string.lt.and = 'ir';
z.string.lt.enumerationAnd = ', ir ';

//=Įkeliama
z.string.lt.authAccountCountryCode = 'Šalies kodas';
z.string.lt.authAccountPasswordForgot = 'Pamiršau slaptažodį';
z.string.lt.authAccountPublicComputer = 'Tai yra viešas kompiuteris';
z.string.lt.authAccountSignIn = 'Prisijungti';
z.string.lt.authAccountSignInPhone = 'Telefonas';

z.string.lt.authBlockedCookies = 'Aktyvuokite slapukus, kad galėtumėte prisijungti prie „Wire“.';
z.string.lt.authBlockedDatabase = 'Norint rodyti žinutes, Wire reikia prieigos prie jūsų vietinės saugyklos. Vietinė saugykla nėra prieinama privačioje veiksenoje.';
z.string.lt.authBlockedTabs = 'Wire jau yra atverta kitoje kortelėje.';
z.string.lt.authBlockedTabsAction = 'Naudoti šią kortelę';

z.string.lt.authVerifyAccountAdd = 'Pridėti';
z.string.lt.authVerifyAccountDetail = 'Tai leidžia jums naudoti „Wire“ keliuose įrenginiuose.';
z.string.lt.authVerifyAccountHeadline = 'Pridėkite el. pašto adresą ir slaptažodį.';
z.string.lt.authVerifyAccountLogout = 'Atsijungti';
z.string.lt.authVerifyCodeDescription = 'Įveskite patvirtinimo kodą,\nkurį mes išsiuntėme į {{number}}.';
z.string.lt.authVerifyCodeResend = 'Negaunate kodo?';
z.string.lt.authVerifyCodeResendDetail = 'Siųsti iš naujo';
z.string.lt.authVerifyCodeResendTimer = 'Jūs galite užklausti naują kodą {{expiration}}.';
z.string.lt.authVerifyCodeChangePhone = 'Pakeisti telefono numerį';
z.string.lt.authVerifyPasswordHeadline = 'Įveskite savo slaptažodį';

z.string.lt.authLimitDevicesHeadline = 'Įrenginiai';
z.string.lt.authLimitDescription = 'Norėdami pradėti naudoti Wire šiame įrenginyje, pašalinkite vieną iš savo kitų įrenginių.';
z.string.lt.authLimitButtonManage = 'Tvarkyti įrenginius';
z.string.lt.authLimitButtonSignOut = 'Atsijungti';
z.string.lt.authLimitDevicesCurrent = '(Esamas)';

z.string.lt.authHistoryHeadline = 'Pirmą kartą naudojate „Wire“ šiame įrenginyje.';
z.string.lt.authHistoryDescription = 'Privatumo sumetimais, jūsų pokalbio istorija čia nebus rodoma.';
z.string.lt.authHistoryReuseHeadline = 'Naudojote „Wire“ šiame įrenginyje.';
z.string.lt.authHistoryReuseDescription = 'Per tą laikotarpį išsiųstos žinutės, čia nebus rodomos.';
z.string.lt.authHistoryButton = 'GERAI';

z.string.lt.authPostedResend = 'Siųsti iš naujo į {{email}}';
z.string.lt.authPostedResendAction = 'Negaunate el. laiško?';
z.string.lt.authPostedResendDetail = 'Patikrinkite savo el. paštą ir sekite nurodymus.';
z.string.lt.authPostedResendHeadline = 'Jūs gavote laišką.';

z.string.lt.authPlaceholderEmail = 'El. paštas';
z.string.lt.authPlaceholderPasswordPut = 'Slaptažodis';
z.string.lt.authPlaceholderPasswordSet = 'Slaptažodis (bent 8 simboliai)';
z.string.lt.authPlaceholderPhone = 'Telefono numeris';

z.string.lt.authErrorCode = 'Neteisingas kodas';
z.string.lt.authErrorCountryCodeInvalid = 'Neteisingas šalies kodas';
z.string.lt.authErrorEmailExists = 'El. pašto adresas jau užimtas';
z.string.lt.authErrorEmailForbidden = 'Atleiskite. Šis el. pašto adresas yra uždraustas.';
z.string.lt.authErrorEmailMalformed = 'Įveskite taisyklingą el. pašto adresą.';
z.string.lt.authErrorEmailMissing = 'Įrašykite el. pašto adresą.';
z.string.lt.authErrorMisc = 'Problemos su ryšiu. Banbykite dar kartą.';
z.string.lt.authErrorNameShort = 'Įveskite bent 2 simbolių vardą';
z.string.lt.authErrorOffline = 'Nėra interneto ryšio';
z.string.lt.authErrorPasswordShort = 'Pasirinkite bent 8 simbolių slaptažodį.';
z.string.lt.authErrorPasswordWrong = 'Neteisingas slaptažodis. Bandykite dar kartą.';
z.string.lt.authErrorPending = 'Paskyra dar nepatvirtinta';
z.string.lt.authErrorPhoneNumberBudget = 'Jūs prisijungėte pernelyg dažnai. Pabandykite vėliau dar kartą.';
z.string.lt.authErrorPhoneNumberForbidden = 'Atleiskite. Šis telefono numeris yra uždraustas.';
z.string.lt.authErrorPhoneNumberInvalid = 'Neteisingas telefono numeris';
z.string.lt.authErrorPhoneNumberUnknown = 'Nežinomas telefono numeris';
z.string.lt.authErrorSuspended = 'Ši paskyra daugiau nebeturi įgaliojimų prisijungti.';
z.string.lt.authErrorSignIn = 'Patvirtinkite savo duomenis ir bandykite dar kartą.';

z.string.lt.callStateOutgoing = 'Kviečiama…';
z.string.lt.callStateConnecting = 'Sujungiama…';
z.string.lt.callStateIncoming = 'Skambinama…';
z.string.lt.callStateIncomingGroup = '{{user}} jums skambina';
z.string.lt.callDecline = 'Atmesti';
z.string.lt.callAccept = 'Priimti';
z.string.lt.callJoin = 'Prisijungti';
z.string.lt.callChooseSharedScreen = 'Pasirinkite ekraną, kurį bendrinti';
z.string.lt.callParticipants = '{{number}} kalba';
z.string.lt.callNoCameraAccess = 'Nėra galimybės naudotis kamera';

z.string.lt.videoCallOverlayFitVideoLabel = 'Spustelėkite dukart ir vaizdas bus įtalpintas arba užpildytas';
z.string.lt.videoCallOverlayConversations = 'Susirašinėjimai';
z.string.lt.videoCallOverlayMute = 'Išjungti susirašinėjimo pranešimus';
z.string.lt.videoCallOverlayVideo = 'Vaizdas';
z.string.lt.videoCallOverlayShareScreen = 'Siųsti ekrano vaizdą';
z.string.lt.videoCallOverlayHangUp = 'Užbaigti';
z.string.lt.videoCallPaused = 'Vaizdas pristabdytas';
z.string.lt.videoCallScreenShareNotSupported = 'Ši naršykle nepalaiko ekrano rodymo';

z.string.lt.modalAcknowledgeAction = 'Gerai';
z.string.lt.modalAcknowledgeHeadline = 'Kažkas nutiko';
z.string.lt.modalConfirmSecondary = 'Atsisakyti';
z.string.lt.modalOptionSecondary = 'Atsisakyti';

z.string.lt.modalAccountCreateAction = 'GERAI';
z.string.lt.modalAccountCreateHeadline = 'Kurti abonementą?';
z.string.lt.modalAccountCreateMessage = 'Sukūrę paskyrą prarasite bendravimo praeitį šiame svečių kambaryje.';

z.string.lt.modalAccountDeletionAction = 'Ištrinti';
z.string.lt.modalAccountDeletionHeadline = 'Ištrinti paskyrą';
z.string.lt.modalAccountDeletionMessage = 'Mes išsiųsime jums pranešimą el. paštu arba SMS žinute. Pereikite nuorodos adresu, kad visiems laikams ištrintumėte savo paskyrą.';

z.string.lt.modalAccountLeaveGuestRoomAction = 'Išeiti';
z.string.lt.modalAccountLeaveGuestRoomHeadline = 'Išeiti iš svečių kambario?';
z.string.lt.modalAccountLeaveGuestRoomMessage = 'Bendravimo praeitis bus ištrinta. Norėdami išsaugoti, kitą kartą susikurkite paskyrą.';

z.string.lt.modalAccountLogoutAction = 'Atsijungti';
z.string.lt.modalAccountLogoutHeadline = 'Išvalyti duomenis?';
z.string.lt.modalAccountLogoutOption = 'Ištrinti visą jūsų asmeninę informaciją ir pokalbius šiame įrenginyje.';

z.string.lt.modalAccountNewDevicesSecondary = 'Tvarkyti įrenginius';
z.string.lt.modalAccountNewDevicesHeadline = 'Jūsų paskyra buvo naudota:';
z.string.lt.modalAccountNewDevicesFrom = 'Iš:';
z.string.lt.modalAccountNewDevicesMessage = 'Jeigu jūs to nedarėte, pašalinkite įrenginį ir atstatykite savo slaptažodį.';

z.string.lt.modalAccountRemoveDeviceAction = 'Šalinti įrenginį';
z.string.lt.modalAccountRemoveDeviceHeadline = 'Šalinti "{{device}}"';
z.string.lt.modalAccountRemoveDeviceMessage = 'Norint pašalinti įrenginį, reikalingas jūsų slaptažodis.';
z.string.lt.modalAccountRemoveDevicePlaceholder = 'Slaptažodis';

z.string.lt.modalAssetTooLargeHeadline = 'Failas per didelis';
z.string.lt.modalAssetTooLargeMessage = 'Jūs galite siųsti failus iki {{number}}';

z.string.lt.modalAssetParallelUploadsHeadline = 'Per daug failų vienu metu';
z.string.lt.modalAssetParallelUploadsMessage = 'Jūs vienu metu galite siųsti iki {{number}} failų.';

z.string.lt.modalCallEmptyConversationHeadline = 'Nėra kam skambinti';
z.string.lt.modalCallEmptyConversationMessage = 'Čia daugiau nieko nėra.';

z.string.lt.modalCallEmptyLogHeadline = 'Skambučių nebuvo';
z.string.lt.modalCallEmptyLogMessage = 'Nebuvo skambučių, pagal kuriuos galėtume sugeneruoti ataskaitą.';

z.string.lt.modalCallNoGroupVideoHeadline = 'Vaizdo skambučiai grupėse nepalaikomi';
z.string.lt.modalCallNoGroupVideoMessage = 'Vaizdo skambučiai grupės pokalbiuose yra neprieinami.';

z.string.lt.modalCallNoMicrophoneAction = 'Paaiškinkite kaip';
z.string.lt.modalCallNoMicrophoneMessage = 'Norint skambinti, jūsų naršyklei reikia prieigos prie jūsų mikrofono.';
z.string.lt.modalCallNoMicrophoneHeadline = 'Nepavyksta skambinti be mikrofono';

z.string.lt.modalCallSecondIncomingAction = 'Atsiliepti';
z.string.lt.modalCallSecondIncomingHeadline = 'Atsiliepti į skambutį?';
z.string.lt.modalCallSecondIncomingMessage = 'Jūsų dabartinis skambutis bus užbaigtas.';

z.string.lt.modalCallSecondOngoingAction = 'Užbaigti';
z.string.lt.modalCallSecondOngoingHeadline = 'Užbaigti skambutį kitame įrenginyje?';
z.string.lt.modalCallSecondOngoingMessage = 'Jūs vienu metu galite dalyvauti tik viename skambutyje.';

z.string.lt.modalCallSecondOutgoingAction = 'Užbaigti';
z.string.lt.modalCallSecondOutgoingHeadline = 'Užbaigti esamą skambutį?';
z.string.lt.modalCallSecondOutgoingMessage = 'Jūs vienu metu galite dalyvauti tik viename skambutyje.';

z.string.lt.modalConnectCancelAction = 'Taip';
z.string.lt.modalConnectCancelHeadline = 'Atsisakyti užklausos?';
z.string.lt.modalConnectCancelMessage = 'Šalinti kontakto užmezgimo su {{user}} užklausą.';
z.string.lt.modalConnectCancelSecondary = 'Ne';

z.string.lt.modalConnectAcceptAction = 'Užmegzti kontaktą';
z.string.lt.modalConnectAcceptHeadline = 'Priimti?';
z.string.lt.modalConnectAcceptMessage = 'Tai užmegs kontaktą ir atvers pokalbį su {{user}}.';
z.string.lt.modalConnectAcceptSecondary = 'Nepaisyti';

z.string.lt.modalConversationClearAction = 'Ištrinti';
z.string.lt.modalConversationClearHeadline = 'Ištrinti turinį?';
z.string.lt.modalConversationClearMessage = 'Tai išvalys bendravimo praeitį visuose jūsų įrenginiuose.';
z.string.lt.modalConversationClearOption = 'Taip pat išeiti iš pokalbio';

z.string.lt.modalConversationDeleteMessageAction = 'Ištrinti';
z.string.lt.modalConversationDeleteMessageHeadline = 'Ištrinti tik man?';
z.string.lt.modalConversationDeleteMessageMessage = 'To negalima bus atšaukti.';

z.string.lt.modalConversationDeleteMessageEveryoneAction = 'Ištrinti';
z.string.lt.modalConversationDeleteMessageEveryoneHeadline = 'Ištrinti visiems?';
z.string.lt.modalConversationDeleteMessageEveryoneMessage = 'To negalima bus atšaukti.';

z.string.lt.modalConversationLeaveAction = 'Išeiti';
z.string.lt.modalConversationLeaveHeadline = 'Išeiti iš susirašinėjimo „{{name}}“?';
z.string.lt.modalConversationLeaveMessage = 'Jūs daugiau nebegalėsite gauti ar siųsti žinutes šiame pokalbyje.';

z.string.lt.modalConversationMessageTooLongHeadline = 'Žinutė pernelyg ilga';
z.string.lt.modalConversationMessageTooLongMessage = 'Jūs galite siųsti žinutes iki {{number}} simbolių ilgio.';

z.string.lt.modalConversationNewDeviceAction = 'Vis tiek siųsti';
z.string.lt.modalConversationNewDeviceHeadlineOne = '{{user}} pradėjo naudoti naują įrenginį';
z.string.lt.modalConversationNewDeviceHeadlineMany = '{{user}}s pradėjo naudoti naujus įrenginius';
z.string.lt.modalConversationNewDeviceHeadlineYou = '{{user}} pradėjo naudoti naują įrenginį';
z.string.lt.modalConversationNewDeviceIncomingCallAction = 'Priimti skambutį';
z.string.lt.modalConversationNewDeviceIncomingCallMessage = 'Ar vis dar norite priimti skambutį?';
z.string.lt.modalConversationNewDeviceMessage = 'Ar vis dar norite išsiųsti savo žinutes?';
z.string.lt.modalConversationNewDeviceOutgoingCallAction = 'Vis tiek skambinti';
z.string.lt.modalConversationNewDeviceOutgoingCallMessage = 'Ar vis dar norite atlikti skambutį?';

z.string.lt.modalConversationNotConnectedHeadline = 'Susirašinėjime nieko nėra';
z.string.lt.modalConversationNotConnectedMessageOne = '{{name}} nenori būti susirašinėjimuose.';
z.string.lt.modalConversationNotConnectedMessageMany = 'Vienas iš pasirinktų žmonių nenori būti susirašinėjimuose.';

z.string.lt.modalConversationRemoveAction = 'Šalinti';
z.string.lt.modalConversationRemoveHeadline = 'Šalinti?';
z.string.lt.modalConversationRemoveMessage = '{{user}} negalės siųsti ir gauti žinutes šiame pokalbyje.';

z.string.lt.modalConversationRemoveGuestsAction = 'Pašalinti svečius';
z.string.lt.modalConversationRemoveGuestsHeadline = 'Išjungiate prisijungimą svečiams?';
z.string.lt.modalConversationRemoveGuestsMessage = 'Dabartiniai svečiai bus pašalinti iš susirašinėjimo. Nauji svečiai prisijungi negalės.';

z.string.lt.modalConversationRevokeLinkAction = 'Naikinti nuorodą';
z.string.lt.modalConversationRevokeLinkHeadline = 'Panaikinti nuorodą?';
z.string.lt.modalConversationRevokeLinkMessage = 'Nauji svečiai negalės prisijungti spustelėję nuorodą. Dabartiniai svečiai liks prisijungę.';

z.string.lt.modalConversationGuestOptionsAllowGuestMessage = 'Nepavyko leisti svečių. Pabandykite dar kartą.';
z.string.lt.modalConversationGuestOptionsDisableGuestMessage = 'Nepavyko pašalinti svečių. Pabandykite dar kartą.';
z.string.lt.modalConversationGuestOptionsGetCodeMessage = 'Nepavyko gauti prisijungimo nuorodos.';
z.string.lt.modalConversationGuestOptionsRequestCodeMessage = 'Nepavyko gauti prisijungimo nuorodos. Pabandykite dar kartą.';
z.string.lt.modalConversationGuestOptionsRevokeCodeMessage = 'Nepavyko panaikinti nuorodos. Bandykite dar kartą.';
z.string.lt.modalConversationGuestOptionsToggleGuestsMessage = 'Nepavyko pakeisti svečio būsenos.';

z.string.lt.modalConversationTooManyMembersHeadline = 'Balso kanalas perpildytas';
z.string.lt.modalConversationTooManyMembersMessage = 'Prie pokalbio gali prisijungti iki {{number1}} žmonių. Šiuo metu yra vietos tik dar {{number2}} žmonėms.';

z.string.lt.modalGifTooLargeHeadline = 'Pasirinkta animacija per didelė';
z.string.lt.modalGifTooLargeMessage = 'Didžiausias dydis yra {{number}} MB.';

z.string.lt.modalIntegrationUnavailableHeadline = 'Šiuo metu robotai negalimi';
z.string.lt.modalIntegrationUnavailableMessage = 'Dėkojame, kad domitės robotais. Paslauga šiuo metu yra pristabdyta tol, kol mes ruošiame kitą versiją. Sekite naujienas.';

z.string.lt.modalPictureFileFormatHeadline = 'Negalite naudoti šio paveikslėlio';
z.string.lt.modalPictureFileFormatMessage = 'Pasirinkite „PNG“ arba „JPEG“ failą.';

z.string.lt.modalPictureTooLargeHeadline = 'Pasirinktas paveikslėlis per didelis';
z.string.lt.modalPictureTooLargeMessage = 'Galite naudoti iki {{number}} MB dydžio paveikslėlį.';

z.string.lt.modalPictureTooSmallHeadline = 'Paveikslėlis per mažas';
z.string.lt.modalPictureTooSmallMessage = 'Pasirinkite bent 320 x 320 px dydžio paveikslėlį.';

z.string.lt.modalImproveWireAction = 'Priimti';
z.string.lt.modalImproveWireSecondary = 'Ne dabar';
z.string.lt.modalImproveWireHeadline = 'Pagerinkite „Wire“';
z.string.lt.modalImproveWireMessage = 'Siųsdami anoniminę naudojimosi ir trikčių ataskaitą padedate mums pagerinti produktus ir paslaugas. Šios informacijos daugiau niekur nenaudojame.';

z.string.lt.modalServiceUnavailableHeadline = 'Paslaugos pridėjimas negalimas';
z.string.lt.modalServiceUnavailableMessage = 'Paslauga šiuo metu negalima.';

z.string.lt.modalSessionResetHeadline = 'Seansas buvo atstatytas';
z.string.lt.modalSessionResetMessage1 = 'Jeigu problema neišspręsta,';
z.string.lt.modalSessionResetMessageLink = 'susisiekite';
z.string.lt.modalSessionResetMessage2 = 'su mumis.';

z.string.lt.modalUploadContactsAction = 'Bandyti dar kartą';
z.string.lt.modalUploadContactsMessage = 'Mes negavome jūsų informacijos. Bandykite importuoti savo kontaktus dar kartą.';

z.string.lt.modalUserBlockAction = 'Užblokuoti';
z.string.lt.modalUserBlockHeadline = 'Užblokuoti {{user}}?';
z.string.lt.modalUserBlockMessage = '{{user}} negalės su jumis susisiekti ar pridėti jus į grupės pokalbius.';

z.string.lt.modalUserUnblockAction = 'Atblokuoti';
z.string.lt.modalUserUnblockHeadline = 'Atblokuoti?';
z.string.lt.modalUserUnblockMessage = '{{user}} galės ir vėl su jumis susisiekti ar pridėti jus į grupės pokalbius.';

z.string.lt.modalNoCameraTitle = 'Nėra galimybės naudotis kamera';
z.string.lt.modalNoCameraMessage = '„Wire“ neturi galimybės prisijungti prie kameros.[br][faqLink]Perskaitykite šį pagalbos straipsnį[/faqLink] ir sužinosite, kaip tai sutvarkyti.';

z.string.lt.connectionRequestConnect = 'Užmegzti kontaktą';
z.string.lt.connectionRequestIgnore = 'Nepaisyti';

z.string.lt.conversationGuestIndicator = 'Svečias';
z.string.lt.userRemainingTimeHours = 'Liko {{time}} val.';
z.string.lt.userRemainingTimeMinutes = 'Liko mažiau nei {{time}} min.';

z.string.lt.conversationYouNominative = 'jūs';
z.string.lt.conversationYouDative = 'jūs';
z.string.lt.conversationYouAccusative = 'jūs';

z.string.lt.conversationConnectionAccepted = 'Kontaktas užmegztas';
z.string.lt.conversationConnectionBlocked = 'Užblokuotas(-a)';
z.string.lt.conversationConnectionCancelRequest = 'Atsisakyti kontakto užmezgimo užklausos';
z.string.lt.conversationCreateTemporary = 'Prisijungėte prie susirašinėjimo';
z.string.lt.conversationCreateWith = 'su {{users}}';
z.string.lt.conversationDeviceStartedUsingOne = ' pradėjo naudoti';
z.string.lt.conversationDeviceStartedUsingMany = ' pradėjo naudoti';
z.string.lt.conversationDeviceUnverified = ' panaikinote patvirtinimą vieno iš';
z.string.lt.conversationDeviceYourDevices = ' savo įrenginių';
z.string.lt.conversationDeviceUserDevices = ' {{user}} įrenginių';
z.string.lt.conversationDeviceNewDeviceOne = ' naują įrenginį';
z.string.lt.conversationDeviceNewDeviceMany = ' naujus įrenginius';
z.string.lt.conversationDeviceNewPeopleJoined = 'Prisijungė nauji žmonės.';
z.string.lt.conversationDeviceNewPeopleJoinedVerify = ' patvirtinkite įrenginius';
z.string.lt.conversationJustNow = 'Ką tik';
z.string.lt.conversationLocationLink = 'Atverti žemėlapį';
z.string.lt.conversationCreated = '[bold]{{name}}[/bold] pradėjo susirašinėjimą su {{users}}';
z.string.lt.conversationCreatedMore = '[bold]{{name}}[/bold] pradėjo susirašinėjimą su {{users}}, ir dar [showmore]{{count}} [/showmore]';
z.string.lt.conversationCreatedName = '[bold]{{name}}[/bold] pradėjo susirašinėjimą';
z.string.lt.conversationCreatedNameYou = '[bold]Jūs[/bold] pradėjote susirašnėjimą';
z.string.lt.conversationCreatedYou = 'Jūs pradėjote susirašinėjimą su {{users}}';
z.string.lt.conversationCreatedYouMore = 'Jūs pradėjote susirašinėjimą su {{users}}, ir dar [showmore]{{count}}[/showmore]';
z.string.lt.conversationCreateWithMore = 'su {{users}}, ir dar [showmore]{{count}}[/showmore]';
z.string.lt.conversationCreateTeam = 'su [showmore]visais, esančiais komandoje[/showmore]';
z.string.lt.conversationCreateTeamGuest = 'su [showmore]visais, esančiais komandoje ir svečiu[/showmore]';
z.string.lt.conversationCreateTeamGuests = 'su [showmore]visais, esančiais komandoje ir {{count}} svečiais[/showmore]';
z.string.lt.conversationMemberJoined = '[bold]{{name}}[/bold] pridėjo {{users}} prie susirašinėjimo';
z.string.lt.conversationMemberJoinedYou = '[bold]Jūs[/bold] pridėjote {{users}} prie susirašinėjimo';
z.string.lt.conversationMemberJoinedMore = '[bold]{{name}}[/bold] pridėjo {{users}}, ir dar [showmore]{{count}}[/showmore] prie susirašinėjimo';
z.string.lt.conversationMemberJoinedYouMore = '[bold]Jūs[/bold] pridėjote {{users}}, ir dar[showmore]{{count}}[/showmore] prie susirašinėjimo';
z.string.lt.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] prisijungė';
z.string.lt.conversationMemberJoinedSelfYou = '[bold]Jūs[/bold] prisijungėte';
z.string.lt.conversationMemberLeft = '[bold]{{name}}[/bold] išėjo';
z.string.lt.conversationMemberLeftYou = '[bold]Jūs[/bold] išėjote';
z.string.lt.conversationMemberRemoved = '[bold]{{name}}[/bold] pašalino {{users}}';
z.string.lt.conversationMemberRemovedYou = '[bold]Jūs[/bold] pašalinote {{users}}';
z.string.lt.conversationTeamLeft = '[bold]{{name}}[/bold] buvo pašalintas (-a) iš komandos';
z.string.lt.conversationMessageDelivered = 'Pristatyta';
z.string.lt.conversationRename = ' pervadino pokalbį';
z.string.lt.conversationRenameYou = ' pervadino pokalbį';
z.string.lt.conversationUpdatedTimer = ' nustatė žinutė laikmatį į {{time}}';
z.string.lt.conversationUpdatedTimerYou = ' nustatėte žinučių laikmatį į {{time}}';
z.string.lt.conversationResetTimer = ' išjungė žinutė laikmatį';
z.string.lt.conversationResetTimerYou = ' išjungėte žinučių laikmatį';
z.string.lt.conversationResume = 'Pradėti pokalbį su {{users}}';
z.string.lt.conversationPing = ' patikrino ryšį';
z.string.lt.conversationPingYou = ' patikrinote ryšį';
z.string.lt.conversationToday = 'šiandien';
z.string.lt.conversationVoiceChannelDeactivate = ' skambino';
z.string.lt.conversationVoiceChannelDeactivateYou = ' skambino';
z.string.lt.conversationYesterday = 'Vakar';
z.string.lt.conversationUnableToDecrypt1 = 'žinutė nuo {{user}} nebuvo gauta.';
z.string.lt.conversationUnableToDecrypt2 = 'Pasikeitė {{user}} įrenginio tapatybė. Žinutė nepristatyta.';
z.string.lt.conversationUnableToDecryptLink = 'Kodėl?';
z.string.lt.conversationUnableToDecryptErrorMessage = 'Klaida';
z.string.lt.conversationUnableToDecryptResetSession = 'Atstatyti seansą';
z.string.lt.conversationMissedMessages = 'Jūs kurį laiką nenaudojote šio įrenginio. Kai kurios žinutės čia gali neatsirasti.';
z.string.lt.conversationAssetUploading = 'Įkeliama…';
z.string.lt.conversationAssetDownloading = 'Atsiunčiama…';
z.string.lt.conversationAssetUploadFailed = 'Įkėlimas nepavyko';
z.string.lt.conversationPlaybackError = 'Nepavyko atkurti';
z.string.lt.conversationContextMenuCopy = 'Kopijuoti';
z.string.lt.conversationContextMenuEdit = 'Taisyti';
z.string.lt.conversationContextMenuDelete = 'Ištrinti man';
z.string.lt.conversationContextMenuDeleteEveryone = 'Ištrinti visiems';
z.string.lt.conversationContextMenuDownload = 'Atsisiųsti';
z.string.lt.conversationContextMenuLike = 'Patinka';
z.string.lt.conversationContextMenuUnlike = 'Nebepatinka';
z.string.lt.conversationDeleteTimestamp = 'Ištrinta: {{date}}';
z.string.lt.conversationEditTimestamp = 'Taisyta: {{date}}';
z.string.lt.conversationLikesCaption = '{{number}} žmonėms';
z.string.lt.conversationSendPastedFile = 'Paveikslas įdėtas {{date}}';
z.string.lt.conversationSomeone = 'Kažkas';
z.string.lt.conversationTweetAuthor = ' socialiniame tinkle Twitter';
z.string.lt.conversationServicesWarning = 'Tarnybos turi galimybę prisijungti prie šio susirašinėjimo turinio';

z.string.lt.groupCreationPreferencesAction = 'Kitas';
z.string.lt.groupCreationPreferencesErrorNameShort = 'Bent 1 simbolis';
z.string.lt.groupCreationPreferencesErrorNameLong = 'Per daug simbolių';
z.string.lt.groupCreationPreferencesHeader = 'Nauja grupė';
z.string.lt.groupCreationPreferencesPlaceholder = 'Grupės pavadinimas';
z.string.lt.groupCreationParticipantsActionCreate = 'Atlikta';
z.string.lt.groupCreationParticipantsActionSkip = 'Praleisti';
z.string.lt.groupCreationParticipantsHeader = 'Pridėti žmonių';
z.string.lt.groupCreationParticipantsHeaderWithCounter = 'Pridėti žmonių ({{number}})';
z.string.lt.groupCreationParticipantsPlaceholder = 'Ieškokite pagal vardą';
z.string.lt.groupSizeInfo = 'Prie pokalbio gali prisijungti iki {{count}} pašnekovų. Vaizdo skambučiai veikai grupėse iki 4 pašnekovų.';

z.string.lt.guestRoomConversationName = 'Svečio kambarys';
z.string.lt.guestRoomToggleName = 'Leisti svečius';
z.string.lt.guestRoomToggleInfo = 'Leiskite žmonėms nesantiems jūsų komandoje prisijungti.';
z.string.lt.guestRoomToggleInfoExtended = 'Leiskite žmonėms nesantiems jūsų komandoje prisijungti. Bet kada galėsite tai pakeisti.';

z.string.lt.guestRoomConversationBadge = 'Yra svečių';
z.string.lt.guestRoomConversationBadgeService = 'Tarnybos aktyvios';
z.string.lt.guestRoomConversationBadgeGuestAndService = 'Yra svečių ir tarnybų';

z.string.lt.guestRoomConversationHead = 'Žmonės nesantys jūsų komandoje gali prisijungti prie susirašinėjimo.';
z.string.lt.guestRoomConversationButton = 'Kviesti žmonių';

z.string.lt.collectionShowAll = 'Rodyti visus {{number}}';
z.string.lt.collectionSectionLinks = 'Nuorodos';
z.string.lt.collectionSectionImages = 'Paveikslai';
z.string.lt.collectionSectionFiles = 'Failai';
z.string.lt.collectionSectionAudio = 'Garso žinutės';

z.string.lt.fullsearchPlaceholder = 'Ieškoti tekstinėse žinutėse';
z.string.lt.fullsearchNoResults = 'Rezultatų nėra.';

z.string.lt.archiveHeader = 'Archyvuoti';

z.string.lt.conversationsAllArchived = 'Viskas užarchyvuota';
z.string.lt.conversationsContacts = 'Kontaktai';
z.string.lt.conversationsConnectionRequestMany = 'Laukia {{number}} žmonės';
z.string.lt.conversationsConnectionRequestOne = '1 asmuo laukia';
z.string.lt.conversationsEmptyConversation = 'Grupės pokalbis';
z.string.lt.conversationsNoConversations = 'Kol kas nėra pokalbių';
z.string.lt.conversationsPopoverArchive = 'Archyvuoti susirašinėjimą';
z.string.lt.conversationsPopoverBlock = 'Blokuoti kontaktą…';
z.string.lt.conversationsPopoverCancel = 'Atsisakyti užklausos';
z.string.lt.conversationsPopoverClear = 'Trinti turinį…';
z.string.lt.conversationsPopoverLeave = 'Išeiti iš grupės…';
z.string.lt.conversationsPopoverNotify = 'Įjungti susirašinėjimo pranešimus';
z.string.lt.conversationsPopoverSilence = 'Išjungti susirašinėjimo pranešimus';
z.string.lt.conversationsPopoverUnarchive = 'Išimti susirašinėjimą iš archyvo';

z.string.lt.conversationsSecondaryLineEphemeralMessage = 'Išsiuntė jums žinutę';
z.string.lt.conversationsSecondaryLineIncomingCall = '{{user}} jums skambina';
z.string.lt.conversationsSecondaryLinePeopleLeft = '{{number}} žmonių išėjo';
z.string.lt.conversationsSecondaryLinePersonLeft = '{{user}} išėjo';
z.string.lt.conversationsSecondaryLinePersonRemoved = '{{user}} buvo pašalinta(-s)';
z.string.lt.conversationsSecondaryLinePersonRemovedTeam = '{{user}} buvo pašalintas iš komandos';
z.string.lt.conversationsSecondaryLinePeopleAdded = 'Buvo pridėta {{user}} žmonių';
z.string.lt.conversationsSecondaryLinePersonAdded = '{{user}} buvo pridėta(-s)';
z.string.lt.conversationsSecondaryLinePersonAddedSelf = '{{user}} prisijungė';
z.string.lt.conversationsSecondaryLinePersonAddedYou = '{{user}} pridėjo jus';
z.string.lt.conversationsSecondaryLineRenamed = '{{user}} pervadino pokalbį';
z.string.lt.conversationsSecondaryLineYouLeft = 'Jūs išėjote';
z.string.lt.conversationsSecondaryLineYouWereRemoved = 'Jūs buvote pašalinti';

z.string.lt.takeoverSub = 'Užsirezervuokite savo unikalų Wire vardą.';
z.string.lt.takeoverLink = 'Sužinoti daugiau';
z.string.lt.takeoverButtonChoose = 'Pasirinkti savo asmeninį';
z.string.lt.takeoverButtonKeep = 'Palikti šį';

z.string.lt.inviteMetaKeyMac = 'Cmd';
z.string.lt.inviteMetaKeyPc = 'Ctrl';
z.string.lt.inviteHintSelected = 'Spustelėję {{metaKey}} ir C nukopijuosite';
z.string.lt.inviteHintUnselected = 'Pažymėkite ir spustelėkite {{metaKey}} ir C';
z.string.lt.inviteHeadline = 'Pakvieskite žmones į Wire';
z.string.lt.inviteMessage = 'Aš naudoju Wire. Ieškokite manęs kaip {{username}} arba apsilankykite get.wire.com.';
z.string.lt.inviteMessageNoEmail = 'Aš naudoju Wire. Apsilankyk get.wire.com , kad su manimi susisiektum.';

z.string.lt.extensionsBubbleButtonGif = 'Gif';

z.string.lt.extensionsGiphyButtonOk = 'Siųsti';
z.string.lt.extensionsGiphyButtonMore = 'Pabandyti kitą';
z.string.lt.extensionsGiphyMessage = '{{tag}} • per giphy.com';
z.string.lt.extensionsGiphyNoGifs = 'Oi, nėra gif';
z.string.lt.extensionsGiphyRandom = 'Atsitiktinis';

z.string.lt.addParticipantsConfirmLabel = 'Pridėti';
z.string.lt.addParticipantsHeader = 'Pridėti žmonių';
z.string.lt.addParticipantsHeaderWithCounter = 'Pridėti žmonių ({{number}})';
z.string.lt.addParticipantsManageServices = 'Valdyti tarnybas';
z.string.lt.addParticipantsManageServicesNoResults = 'Valdyti tarnybas';
z.string.lt.addParticipantsNoServicesManager = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eigą.';
z.string.lt.addParticipantsNoServicesMember = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eigą. Norėdami jomis naudotis, prašykite savo administratoriaus.';
z.string.lt.addParticipantsSearchPlaceholder = 'Ieškokite pagal vardą';
z.string.lt.addParticipantsServiceConfirmButton = 'Pridėti paslaugą';
z.string.lt.addParticipantsTabsPeople = 'Žmonės';
z.string.lt.addParticipantsTabsServices = 'Paslaugos';

z.string.lt.conversationDetailsActionArchive = 'Archyvuoti susirašinėjimą';
z.string.lt.conversationDetailsActionAddParticipants = 'Pridėti dalyvių';
z.string.lt.conversationDetailsActionBlock = 'Blokuoti kontaktą';
z.string.lt.conversationDetailsActionCancelRequest = 'Atsisakyti užklausos';
z.string.lt.conversationDetailsActionClear = 'Trinti turinį';
z.string.lt.conversationDetailsActionConversationParticipants = 'Rodyti visus ({{number}})';
z.string.lt.conversationDetailsActionCreateGroup = 'Nauja grupė';
z.string.lt.conversationDetailsActionDevices = 'Įrenginiai';
z.string.lt.conversationDetailsActionGuestOptions = 'Svečių nustatymai';
z.string.lt.conversationDetailsActionTimedMessages = 'Laikinos žinutės';
z.string.lt.conversationDetailsActionNotifications = 'Pranešimai';
z.string.lt.conversationDetailsActionLeave = 'Išeiti iš grupės';
z.string.lt.conversationDetailsGuestsOff = 'Išjungta';
z.string.lt.conversationDetailsGuestsOn = 'Įjungti';
z.string.lt.conversationDetailsOptions = 'Parinktys';
z.string.lt.conversationDetailsParticipantsServicesOne = 'Paslauga';
z.string.lt.conversationDetailsParticipantsServicesMany = 'Paslaugos';
z.string.lt.conversationDetailsParticipantsUsersOne = 'Asmuo';
z.string.lt.conversationDetailsParticipantsUsersMany = 'Žmonės';
z.string.lt.conversationDetailsPeople = 'Žmonės';
z.string.lt.conversationDetailsServices = 'Paslaugos';

z.string.lt.conversationParticipantsTitle = 'Žmonės';
z.string.lt.conversationParticipantsSearchPlaceholder = 'Ieškokite pagal vardą';

z.string.lt.groupParticipantActionBlock = 'Blokuoti kontaktą';
z.string.lt.groupParticipantActionCancelRequest = 'Atsisakyti užklausos…';
z.string.lt.groupParticipantActionDevices = 'Įrenginiai';
z.string.lt.groupParticipantActionIgnoreRequest = 'Nepaisyti užklausos';
z.string.lt.groupParticipantActionIncomingRequest = 'Patvirtinti užklausą';
z.string.lt.groupParticipantActionLeave = 'Išeiti iš grupės…';
z.string.lt.groupParticipantActionOpenConversation = 'Atverti susirašinėjimą';
z.string.lt.groupParticipantActionPending = 'Laukia';
z.string.lt.groupParticipantActionRemove = 'Šalinti iš grupės';
z.string.lt.groupParticipantActionSelfProfile = 'Atverti profilį';
z.string.lt.groupParticipantActionSendRequest = 'Užmegzti kontaktą';
z.string.lt.groupParticipantActionUnblock = 'Atblokuoti…';

z.string.lt.guestOptionsCopyLink = 'Kopijuoti nuorodą';
z.string.lt.guestOptionsCopyLinkDone = 'Nuoroda nukopijuota!';
z.string.lt.guestOptionsCreateLink = 'Kurti nuorodą';
z.string.lt.guestOptionsInfoHeader = 'Kviesti kitus naudojant nuorodą';
z.string.lt.guestOptionsInfoText = 'Bet kas turintis nuorodą gali prisijungti prie susirašinėjimo 24 valandoms, net jei neturi „Wire“.';
z.string.lt.guestOptionsRevokeLink = 'Atšaukti nuorodą';
z.string.lt.guestOptionsTitle = 'Svečių nustatymai';

z.string.lt.notificationSettingsTitle = 'Pranešimai';

z.string.lt.timedMessagesTitle = 'Laikinos žinutės';
z.string.lt.timedMessageDisclaimer = 'Laikinos žinutės bus įjungtos visiems šio pokalbio dalyviams.';

z.string.lt.participantDevicesDetailHeadline = 'Įsitikinkite, kad šis kontrolinis kodas yra toks pats, kaip ir įrenginyje, kurį naudoja {{html1}}{{user}}{{html2}}.';
z.string.lt.participantDevicesDetailHowTo = 'Kaip tai padaryti?';
z.string.lt.participantDevicesDetailResetSession = 'Atstatyti seansą';
z.string.lt.participantDevicesDetailShowMyDevice = 'Rodyti mano įrenginio kontrolinį kodą';
z.string.lt.participantDevicesDetailVerify = 'Patvirtintas';

z.string.lt.participantDevicesHeader = 'Įrenginiai';
z.string.lt.participantDevicesHeadline = 'Wire kiekvienam įrenginiui suteikia unikalų kontrolinį kodą. Palyginkite juos su {{user}} ir patvirtinkite savo pokalbį.';
z.string.lt.participantDevicesLearnMore = 'Sužinoti daugiau';
z.string.lt.participantDevicesWhyVerify = 'Kam patvirtinti pokalbį?';
z.string.lt.participantDevicesOutdatedClientMessage = '{{user}} naudoja seną Wire versiją. Čia nerodomi jokie įrenginiai.';

z.string.lt.participantDevicesSelfAllDevices = 'Rodyti visus mano įrenginius';
z.string.lt.participantDevicesSelfFingerprint = 'Įrenginio kontrolinis kodas';

z.string.lt.userProfileButtonConnect = 'Užmegzti kontaktą';
z.string.lt.userProfileButtonIgnore = 'Nepaisyti';
z.string.lt.userProfileButtonUnblock = 'Atblokuoti';

z.string.lt.preferencesAbout = 'Apie';
z.string.lt.preferencesAccount = 'Paskyra';
z.string.lt.preferencesAV = 'Garsas / Vaizdas';
z.string.lt.preferencesDeviceDetails = 'Išsamesnė įrenginio informacija';
z.string.lt.preferencesDevices = 'Įrenginiai';
z.string.lt.preferencesHeadline = 'Nuostatos';
z.string.lt.preferencesOptions = 'Parinktys';

z.string.lt.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.lt.preferencesAboutPrivacyPolicy = 'Privatumo politika';
z.string.lt.preferencesAboutSupport = 'Palaikymas';
z.string.lt.preferencesAboutSupportWebsite = 'Palaikymo svetainė';
z.string.lt.preferencesAboutSupportContact = 'Susisiekti su palaikymu';
z.string.lt.preferencesAboutTermsOfUse = 'Naudojimosi sąlygos';
z.string.lt.preferencesAboutVersion = 'Versija {{version}}';
z.string.lt.preferencesAboutWebsite = 'Wire svetainė';

z.string.lt.preferencesAccountAvaibilityUnset = 'Pasirinkite būseną';
z.string.lt.preferencesAccountCreateTeam = 'Sukurti komandą';
z.string.lt.preferencesAccountData = 'Duomenų naudojimo leidimas';
z.string.lt.preferencesAccountDataCheckbox = 'Siųsti anoniminę informaciją';
z.string.lt.preferencesAccountDataDetail = 'Pagerinkite „Wire“ siųsdami anoniminę naudojimosi ir trikčių ataskaitą.';
z.string.lt.preferencesAccountDelete = 'Ištrinti paskyrą';
z.string.lt.preferencesAccountLeaveGuestRoom = 'Išeiti iš svečių kambario';
z.string.lt.preferencesAccountLeaveGuestRoomDescription = 'Nebegalėsite matyti šio susirašinėjimo žinučių.';
z.string.lt.preferencesAccountLogOut = 'Atsijungti';
z.string.lt.preferencesAccountManageTeam = 'Tvarkyti komandą';
z.string.lt.preferencesAccountMarketingConsentCheckbox = 'Gaukite naujienlaiškį';
z.string.lt.preferencesAccountMarketingConsentDetail = 'Gaukite naujienas ir produktų pakeitimo informaciją iš „Wire“ el. paštu.';
z.string.lt.preferencesAccountResetPassword = 'Atstatyti slaptažodį';
z.string.lt.preferencesAccountTeam = 'komandoje {{name}}';
z.string.lt.preferencesAccountUsernamePlaceholder = 'Jūsų vardas ir pavardė';
z.string.lt.preferencesAccountUsernameHint = 'Bent 2 simboliai. Tik a—z, 0—9 ir _.';
z.string.lt.preferencesAccountUsernameAvailable = 'Prieinamas';
z.string.lt.preferencesAccountUsernameErrorTaken = 'Jau užimtas';

z.string.lt.preferencesAVCamera = 'Kamera';
z.string.lt.preferencesAVMicrophone = 'Mikrofonas';
z.string.lt.preferencesAVPermissionDetail = 'Įjunkite savo naršyklės nuostatose';
z.string.lt.preferencesAVSpeakers = 'Garsiakalbiai';
z.string.lt.preferencesAVTemporaryDisclaimer = 'Svečiai negali pradėti vaizdo konferencijų. Pasirinkite norimą kamerą jei prisijungiate.';
z.string.lt.preferencesAVNoCamera = '„Wire“ neturi galimybės prisijungti prie kameros.[br][faqLink]Perskaitykite šį pagalbos straipsnį[/faqLink] ir sužinosite, kaip tai sutvarkyti.';
z.string.lt.preferencesAVTryAgain = 'Bandykite dar kartą';

z.string.lt.preferencesDevicesActivatedOn = 'Aktyvuotas {{date}}';
z.string.lt.preferencesDevicesActive = 'Aktyvus';
z.string.lt.preferencesDevicesActiveDetail = 'Jeigu jūs neatpažįstate aukščiau esančio įrenginio, pašalinkite jį ir atstatykite savo slaptažodį.';
z.string.lt.preferencesDevicesCurrent = 'Esamas';
z.string.lt.preferencesDevicesFingerprint = 'Rakto kontrolinis kodas';
z.string.lt.preferencesDevicesFingerprintDetail = 'Wire kiekvienam įrenginiui suteikia unikalų kontrolinį kodą. Palyginkite juos ir patvirtinkite savo įrenginius ir pokalbius.';
z.string.lt.preferencesDevicesId = 'ID: ';
z.string.lt.preferencesDevicesRemove = 'Išimti…';
z.string.lt.preferencesDevicesRemoveCancel = 'Atsisakyti';
z.string.lt.preferencesDevicesRemoveDetail = 'Jeigu nebenaudojate šį įrenginį, pašalinkite jį. Jūs būsite nedelsiant atjungti iš šio įrenginio.';
z.string.lt.preferencesDevicesSessionConfirmation = 'Seansas buvo atstatytas.';
z.string.lt.preferencesDevicesSessionDetail = 'Jeigu kontroliniai kodai nesutampa, atstatykite seansą, kad abiejose pusėse būtų sugeneruoti nauji šifravimo raktai.';
z.string.lt.preferencesDevicesSessionReset = 'Atstatyti seansą';
z.string.lt.preferencesDevicesSessionOngoing = 'Atstatomas seansas…';
z.string.lt.preferencesDevicesVerification = 'Patvirtintas';

z.string.lt.preferencesOptionsAudio = 'Garso signalai';
z.string.lt.preferencesOptionsAudioAll = 'Visi';
z.string.lt.preferencesOptionsAudioAllDetail = 'Visi garsai';
z.string.lt.preferencesOptionsAudioNone = 'Jokių';
z.string.lt.preferencesOptionsAudioNoneDetail = 'Ša!';
z.string.lt.preferencesOptionsAudioSome = 'Kai kurie';
z.string.lt.preferencesOptionsAudioSomeDetail = 'Ryšio tikrinimai ir skambučiai';
z.string.lt.preferencesOptionsContacts = 'Kontaktai';
z.string.lt.preferencesOptionsContactsGmail = 'Importuoti iš Gmail';
z.string.lt.preferencesOptionsContactsMacos = 'Importuoti iš kontaktų';
z.string.lt.preferencesOptionsContactsDetail = 'Mes naudojame jūsų kontaktinius duomenis tam, kad padėtume jums užmegzti kontaktą su kitais. Mes padarome visą informaciją anoniminę ir su niekuo ja nesidaliname.';
z.string.lt.preferencesOptionsPopular = 'Pagal populiarias užklausas';
z.string.lt.preferencesOptionsEmojiReplaceCheckbox = 'Pakeisti rašomus jaustukus jausmaženkliais';
z.string.lt.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.lt.preferencesOptionsPreviewsSendCheckbox = 'Rodyti jūsų siunčiamų nuorodų peržiūras';
z.string.lt.preferencesOptionsPreviewsSendDetail = 'Kitų žmonių siunčiamų nuorodų peržiūros vis dar gali būti rodomos.';
z.string.lt.preferencesOptionsNotifications = 'Pranešimai';
z.string.lt.preferencesOptionsNotificationsNone = 'Išjungta';
z.string.lt.preferencesOptionsNotificationsObfuscate = 'Slėpti išsamesnę informaciją';
z.string.lt.preferencesOptionsNotificationsObfuscateMessage = 'Rodyti siuntėją';
z.string.lt.preferencesOptionsNotificationsOn = 'Rodyti siuntėją ir žinutę';
z.string.lt.preferencesOptionsCallLogs = 'Trikčių šalinimas';
z.string.lt.preferencesOptionsCallLogsGet = 'Išsaugoti skambučių derinimo ataskaitą';
z.string.lt.preferencesOptionsCallLogsDetail = 'Ši informacija padeda „Wire“ pagalbos centrui išspręsti skambinimo nesklandumus.';

z.string.lt.preferencesOptionsBackupHeader = 'Praeitis';
z.string.lt.preferencesOptionsBackupExportHeadline = 'Kurti susirašinėjimų atsarginę kopiją';
z.string.lt.preferencesOptionsBackupExportSecondary = 'Kurkite atsarginę kopiją, kad išsaugotumėte susirašinėjimo praeitį. Jei prarasite savo kompiuterį arba pasikeisite nauju, kopiją galėsite panaudoti praeities atkūrimui.\nAtsarginės kopijos failas nėra apsaugotas „Wire“ kodavimo, dėl to jūs turite parinkti jam saugią vietą.';
z.string.lt.preferencesOptionsBackupImportHeadline = 'Atkurti iš atsarginės kopijos';
z.string.lt.preferencesOptionsBackupImportSecondary = 'Atkurti praeitį iš atsarginės kopijos galite tik toje pačioje platformoje. Atsarginė kopija pakeis visus susirašinėjimus, kuriuos šiame įrenginyje turite.';

z.string.lt.backupExportGenericErrorHeadline = 'Failo išsaugoti nepavyko';
z.string.lt.backupExportGenericErrorSecondary = 'Atsarginės kopijos kūrimas nebuvo sėkmingas.';
z.string.lt.backupExportProgressHeadline = 'Ruošiama…';
z.string.lt.backupExportProgressSecondary = 'Kuriame atsarginė kopija · {{processed}} iš {{total}} — {{progress}}%';
z.string.lt.backupExportProgressCompressing = 'Ruošiamas atsarginės kopijos failas';
z.string.lt.backupExportSaveFileAction = 'Išsaugoti failą';
z.string.lt.backupExportSuccessHeadline = 'Atsarginis kopijavimas baigtas';
z.string.lt.backupExportSuccessSecondary = 'Jei prarasite savo kompiuterį arba pasikeisite nauju, kopiją galėsite panaudoti praeities atkūrimui.';
z.string.lt.backupImportGenericErrorHeadline = 'Kažkas nutiko';
z.string.lt.backupImportGenericErrorSecondary = 'Praeities atkurti nepavyko.';
z.string.lt.backupImportAccountErrorHeadline = 'Netinkama atsarginė kopija';
z.string.lt.backupImportAccountErrorSecondary = 'Atkurti kitos paskyros atsarginės kopijos nepavyks.';
z.string.lt.backupImportVersionErrorHeadline = 'Nesuderinama atsarginė kopija';
z.string.lt.backupImportVersionErrorSecondary = 'Ši atsarginė kopija buvo sukurta naudojant arba naujesnę arba senesnę „Wire“ versiją, ir negali būti naudojama atkūrimui.';
z.string.lt.backupImportIncompatibleErrorHeadline = 'Netinkama atsarginė kopija';
z.string.lt.backupImportIncompatibleErrorSecondary = 'Atkurti kitos paskyros atsarginės kopijos nepavyks.';
z.string.lt.backupImportOutdatedErrorHeadline = 'Nesuderinama atsarginė kopija';
z.string.lt.backupImportOutdatedErrorSecondary = 'Ši atsarginė kopija buvo sukurta naudojant arba naujesnę arba senesnę „Wire“ versiją, ir negali būti naudojama atkūrimui.';
z.string.lt.backupImportProgressHeadline = 'Ruošiama…';
z.string.lt.backupImportProgressSecondary = 'Atkuriama praeitis · {{processed}} iš {{total}} — {{progress}}%';
z.string.lt.backupImportSuccessHeadline = 'Praeitis atkurta.';
z.string.lt.backupCancel = 'Atsisakyti';
z.string.lt.backupTryAgain = 'Bandykite dar kartą';

z.string.lt.searchConnect = 'Užmegzti kontaktą';
z.string.lt.searchConnections = 'Kontaktai';
z.string.lt.searchContacts = 'Kontaktai';
z.string.lt.searchCreateGroup = 'Sukurti grupę';
z.string.lt.searchCreateGuestRoom = 'Kurti svečio kambarį';
z.string.lt.searchGroups = 'Grupės';
z.string.lt.searchPeople = 'Žmonės';
z.string.lt.searchPlaceholder = 'Ieškokite pagal vardą ar naudotojo vardą';
z.string.lt.searchServicePlaceholder = 'Ieškokite pagal vardą';
z.string.lt.searchServices = 'Paslaugos';
z.string.lt.searchManageServices = 'Valdyti tarnybas';
z.string.lt.searchManageServicesNoResults = 'Valdyti tarnybas';
z.string.lt.searchNoServicesManager = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eigą.';
z.string.lt.searchNoServicesMember = 'Tarnybos yra pagalbininkai, kurie padeda pagerinti darbo eigą. Norėdami jomis naudotis, prašykite savo administratoriaus.';
z.string.lt.searchTeamGroups = 'Komandos pokalbiai';
z.string.lt.searchTeamMembers = 'Komandos dalyviai';
z.string.lt.searchTopPeople = 'Svarbiausi žmonės';
z.string.lt.searchTrySearch = 'Raskite žmones pagal vardą arba naudotojo vardą';
z.string.lt.searchNoContactsOnWire = 'Jūs neturite Wire kontaktų.\nPabandykite rasti žmones pagal\nvardą arba naudotojo vardą.';
z.string.lt.searchMemberInvite = 'Kvieskite žmonių prisijungti prie komandos';
z.string.lt.searchOthers = 'Užmegzti kontaktą';

z.string.lt.searchInvite = 'Pakvieskite žmones į Wire';
z.string.lt.searchInviteDetail = 'Dalinimasis kontaktais padeda jums užmegzti kontaktą su kitais žmonėmis. Mes padarome visą informaciją anoniminę ir su niekuo ja nesidaliname.';
z.string.lt.searchInviteButtonContacts = 'Iš kontaktų';
z.string.lt.searchInviteButtonGmail = 'Iš Gmail';
z.string.lt.searchInviteHeadline = 'Pasikvieskite savo draugus';
z.string.lt.searchInviteShare = 'Dalintis kontaktais';

z.string.lt.searchServiceConfirmButton = 'Pridėti paslaugą';

z.string.lt.searchListEveryoneParticipates = 'Visi, su kuo esate\nužmezgę kontaktą, jau yra\nšiame pokalbyje.';
z.string.lt.searchListNoMatches = 'Nėra atitinkančių rezultatų.\nPabandykite įvesti kitą vardą.';

z.string.lt.temporaryGuestCta = 'Kurti paskyrą';
z.string.lt.temporaryGuestDescription = 'Apsaugokite savo verslą susirašinėdami ir kalbėdami konferenciniu būdu šifruojant.';
z.string.lt.temporaryGuestTimeRemaining = ' liko šiam svečių kambariui';

z.string.lt.temporaryGuestJoinMessage = 'Šiame susirašinėjime galėsite dalyvauti 24 valandas.';
z.string.lt.temporaryGuestJoinDescription = 'Jei puslapį uždarysite arba perkrausite iš naujo, prisijungti nebegalėsite.';

z.string.lt.temporaryGuestLeaveMessage = ' išėjo iš šio susirašinėjimo.';
z.string.lt.temporaryGuestLeaveDescription = 'Jei puslapį uždarysite arba perkrausite iš naujo, susirašinėjimo praeities matyti nebegalėsite.';

z.string.lt.uploadGoogleHeadline = 'Raskite žmones\nsu kuriais pasikalbėti.';
z.string.lt.uploadGoogleMessage = 'Mes naudojame jūsų kontaktinius duomenis tam, kad padėtume jums užmegzti kontaktą su kitais. Mes padarome visą informaciją anoniminę ir su niekuo ja nesidaliname.';

z.string.lt.warningCallUnsupportedIncoming = 'Skambina {{user}}. Jūsų naršyklė nepalaiko skambučių.';
z.string.lt.warningCallUnsupportedOutgoing = 'Jūs negalite skambinti, nes jūsų naršyklė nepalaiko skambučių.';
z.string.lt.warningCallIssues = 'Ši „Wire“ versija negali dalyvauti pokalbyje. Naudokite';
z.string.lt.warningCallUpgradeBrowser = 'Norėdami skambinti, atnaujinkite „Google Chrome“.';
z.string.lt.warningConnectivityConnectionLost = 'Bandoma prisijungti. Gali būti, kad Wire negalės pristatyti žinučių.';
z.string.lt.warningConnectivityNoInternet = 'Nėra interneto. Jūs negalėsite siųsti ir gauti žinutes.';
z.string.lt.warningLearnMore = 'Sužinoti daugiau';
z.string.lt.warningLifecycleUpdate = 'Išleista nauja „Wire“ versija.';
z.string.lt.warningLifecycleUpdateNotes = 'Kas naujo';
z.string.lt.warningLifecycleUpdateLink = 'Atnaujinti dabar';
z.string.lt.warningNotFoundCamera = 'Jūs negalite skambinti, nes jūsų kompiuteryje nėra kameros.';
z.string.lt.warningNotFoundMicrophone = 'Jūs negalite skambinti, nes jūsų kompiuteryje nėra mikrofono.';
z.string.lt.warningPermissionDeniedCamera = 'Jūs negalite skambinti, nes jūsų naršyklė neturi prieigos prie kameros.';
z.string.lt.warningPermissionDeniedMicrophone = 'Jūs negalite skambinti, nes jūsų naršyklė neturi prieigos prie mikrofono.';
z.string.lt.warningPermissionDeniedScreen = 'Norint bendrinti ekraną, jūsų naršyklei reikia leidimų.';
z.string.lt.warningPermissionRequestCamera = '{{icon}} Leisti prieigą prie kameros';
z.string.lt.warningPermissionRequestMicrophone = '{{icon}} Leisti prieigą prie mikrofono';
z.string.lt.warningPermissionRequestNotification = '{{icon}} Leisti pranešimus';
z.string.lt.warningPermissionRequestScreen = '{{icon}} Leisti prieigą prie ekrano';

z.string.lt.userAvailabilityAvailable = 'Prieinamas';
z.string.lt.userAvailabilityAway = 'Pasišalinęs';
z.string.lt.userAvailabilityBusy = 'Užsiėmęs';
z.string.lt.userAvailabilityNone = 'Jokių';

z.string.lt.notificationAssetAdd = 'Pasidalino paveikslu';
z.string.lt.notificationConnectionAccepted = 'Priėmė jūsų kontakto užmezgimo užklausą';
z.string.lt.notificationConnectionConnected = 'Dabar esate užmezgę kontaktą';
z.string.lt.notificationConnectionRequest = 'Nori užmegzti kontaktą';
z.string.lt.notificationConversationCreate = '{{user}} pradėjo pokalbį';
z.string.lt.notificationConversationMessageTimerUpdate = '{{user}} nustatė žinučių laikmatį į {{time}}';
z.string.lt.notificationConversationMessageTimerReset = '{{user}} išjungė žinučių laikmatį';
z.string.lt.notificationConversationRename = '{{user}} pervadino pokalbį į {{name}}';
z.string.lt.notificationMemberJoinMany = '{{user}} pridėjo {{number}} žmones(-ių) į pokalbį';
z.string.lt.notificationMemberJoinSelf = '{{user}} prisijungė prie susirašinėjimo';
z.string.lt.notificationMemberJoinOne = '{{user1}} pridėjo {{user2}} į pokalbį';
z.string.lt.notificationMemberLeaveRemovedYou = '{{user}} pašalino jus iš pokalbio';
z.string.lt.notificationObfuscated = 'Išsiuntė jums žinutę';
z.string.lt.notificationObfuscatedTitle = 'Kažkas';
z.string.lt.notificationPing = 'Patikrino ryšį';
z.string.lt.notificationReaction = '{{reaction}} jūsų žinutė';
z.string.lt.notificationSharedAudio = 'Pasidalino garso žinute';
z.string.lt.notificationSharedFile = 'Pasidalino failu';
z.string.lt.notificationSharedLocation = 'Pasidalino vieta';
z.string.lt.notificationSharedVideo = 'Pasidalino vaizdo įrašu';
z.string.lt.notificationTitleGroup = '{{user}} susirašinėjime {{conversation}}';
z.string.lt.notificationVoiceChannelActivate = 'Skambina';
z.string.lt.notificationVoiceChannelDeactivate = 'Skambino';

z.string.lt.tooltipConversationAllVerified = 'Visi kontroliniai kodai patvirtinti';
z.string.lt.tooltipConversationCall = 'Skambutis';
z.string.lt.tooltipConversationEphemeral = 'Laikina žinutė';
z.string.lt.tooltipConversationFile = 'Pridėti failą';
z.string.lt.tooltipConversationInputPlaceholder = 'Rašykite žinutę';
z.string.lt.tooltipConversationInputPlaceholderAvailable = '{{user}} yra prisijungęs';
z.string.lt.tooltipConversationInputPlaceholderAway = '{{user}} yra pasišalinęs';
z.string.lt.tooltipConversationInputPlaceholderBusy = '{{user}} yra užsiėmęs';
z.string.lt.tooltipConversationPeople = 'Žmonės ({{shortcut}})';
z.string.lt.tooltipConversationPicture = 'Pridėti paveikslą';
z.string.lt.tooltipConversationPing = 'Tikrinti ryšį ({{shortcut}})';
z.string.lt.tooltipConversationSearch = 'Ieškoti';
z.string.lt.tooltipConversationVideoCall = 'Vaizdo skambutis';

z.string.lt.tooltipConversationsArchive = 'Archyvuoti ({{shortcut}})';
z.string.lt.tooltipConversationsArchived = 'Rodyti archyvą ({{number}})';
z.string.lt.tooltipConversationsMore = 'Daugiau';
z.string.lt.tooltipConversationsNotify = 'Įjungti pranešimus ({{shortcut}})';
z.string.lt.tooltipConversationsPreferences = 'Atverti nuostatas';
z.string.lt.tooltipConversationsSilence = 'Išjungti pranešimus ({{shortcut}})';
z.string.lt.tooltipConversationsStart = 'Pradėti pokalbį ({{shortcut}})';

z.string.lt.tooltipConversationDetailsAddPeople = 'Pridėti dalyvių prie susirašinėjimo ({{shortcut}})';
z.string.lt.tooltipConversationDetailsRename = 'Pakeisti pokalbio pavadinimą';

z.string.lt.tooltipPreferencesContactsGmail = 'Prisijunkite prie savo Gmail paskyros, norėdami bendrinti kontaktus';
z.string.lt.tooltipPreferencesContactsMacos = 'Bendrinti visus savo kontaktus iš macOS Kontaktų programos';
z.string.lt.tooltipPreferencesPassword = 'Atverti kitą svetainę, skirtą slaptažodžio atstatymui';
z.string.lt.tooltipPreferencesPicture = 'Pakeisti savo paveikslą…';
z.string.lt.tooltipPreferencesRename = 'Pakeisti savo vardą';

z.string.lt.tooltipSearchClose = 'Užverti (Esc)';

z.string.lt.initReceivedSelfUser = 'Sveiki, {{user}}.';
z.string.lt.initValidatedClient = 'Gaunami jūsų kontaktai ir pokalbiai';
z.string.lt.initReceivedUserData = 'Tikrinama ar yra naujų žinučių';
z.string.lt.initDecryption = 'Iššifruojamos žinutės';
z.string.lt.initEvents = 'Įkeliamos žinutės';
z.string.lt.initUpdatedFromNotifications = 'Beveik baigta – mėgaukitės „Wire“';
z.string.lt.initProgress = ' — {{number1}} iš {{number2}}';

z.string.lt.ephemeralUnitsNone = 'Išjungta';
z.string.lt.ephemeralUnitsSecond = 'sek.';
z.string.lt.ephemeralUnitsSeconds = 'sek.';
z.string.lt.ephemeralUnitsMinute = 'min.';
z.string.lt.ephemeralUnitsMinutes = 'min.';
z.string.lt.ephemeralUnitsHour = 'val.';
z.string.lt.ephemeralUnitsHours = 'val.';
z.string.lt.ephemeralUnitsDay = 'd.';
z.string.lt.ephemeralUnitsDays = 'd.';
z.string.lt.ephemeralUnitsWeek = 'sav.';
z.string.lt.ephemeralUnitsWeeks = 'sav.';
z.string.lt.ephemeralUnitsYear = 'm.';
z.string.lt.ephemeralUnitsYears = 'm.';
z.string.lt.ephemeralRemaining = 'liko';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.nl.wire = 'Wire';
z.string.nl.wireMacos = 'Wire voor macOS';
z.string.nl.wireWindows = 'Wire voor Windows';
z.string.nl.wireLinux = 'Wire voor Linux';
z.string.nl.nonexistentUser = 'Verwijderde gebruiker';
z.string.nl.and = 'en';
z.string.nl.enumerationAnd = ', en ';

z.string.nl.authAccountCountryCode = 'Landcode';
z.string.nl.authAccountPasswordForgot = 'Wachtwoord vergeten';
z.string.nl.authAccountPublicComputer = 'Dit is een publieke computer';
z.string.nl.authAccountSignIn = 'Inloggen';
z.string.nl.authAccountSignInPhone = 'Telefoonnummer';

z.string.nl.authBlockedCookies = 'Zet je cookies aan om in te loggen in Wire.';
z.string.nl.authBlockedDatabase = 'Wire heeft toegang nodig tot lokale opslag om je berichten te kunnen laten zien, maar dit is niet mogelijk in privémodus.';
z.string.nl.authBlockedTabs = 'Wire is al open in een ander tabblad.';

z.string.nl.authVerifyAccountAdd = 'Toevoegen';
z.string.nl.authVerifyAccountDetail = 'Dit zorgt ervoor dat je Wire op meerdere apparaten kunt gebruiken.';
z.string.nl.authVerifyAccountHeadline = 'E-mailadres en wachtwoord toevoegen.';
z.string.nl.authVerifyAccountLogout = 'Uitloggen';
z.string.nl.authVerifyCodeDescription = 'Voer de verificatiecode in die\nwe naar {{number}} hebben gestuurd.';
z.string.nl.authVerifyCodeResend = 'Geen code ontvangen?';
z.string.nl.authVerifyCodeResendDetail = 'Opnieuw sturen';
z.string.nl.authVerifyCodeResendTimer = 'Je kunt een nieuwe code aanvragen {{expiration}}.';
z.string.nl.authVerifyCodeChangePhone = 'Telefoonnummer wijzigen';
z.string.nl.authVerifyPasswordHeadline = 'Voer je wachtwoord in';

z.string.nl.authLimitDevicesHeadline = 'Apparaten';
z.string.nl.authLimitDescription = 'Verwijder een van je andere apparaten om Wire op dit apparaat te gebruiken.';
z.string.nl.authLimitButtonManage = 'Beheer apparaten';
z.string.nl.authLimitButtonSignOut = 'Uitloggen';
z.string.nl.authLimitDevicesCurrent = '(Huidig)';

z.string.nl.authHistoryHeadline = 'Het is de eerste keer dat je Wire op dit apparaat gebruikt.';
z.string.nl.authHistoryDescription = 'Om privacyredenen wordt je gespreksgeschiedenis hier niet getoond.';
z.string.nl.authHistoryReuseHeadline = 'Je hebt Wire eerder op dit apparaat gebruikt.';
z.string.nl.authHistoryReuseDescription = 'Berichten die in de tussentijd worden verzonden worden niet weergegeven.';
z.string.nl.authHistoryButton = 'OK';

z.string.nl.authPostedResend = 'Opnieuw verzenden naar {{email}}';
z.string.nl.authPostedResendAction = 'Geen e-mail ontvangen?';
z.string.nl.authPostedResendDetail = 'Controleer je inbox en volg de instructies.';
z.string.nl.authPostedResendHeadline = 'Je hebt e-mail ontvangen.';

z.string.nl.authPlaceholderEmail = 'E-mail';
z.string.nl.authPlaceholderPasswordPut = 'Wachtwoord';
z.string.nl.authPlaceholderPasswordSet = 'Wachtwoord (minimaal 8 tekens)';
z.string.nl.authPlaceholderPhone = 'Telefoonnummer';

z.string.nl.authErrorCode = 'Ongeldige code';
z.string.nl.authErrorCountryCodeInvalid = 'Ongeldige landscode';
z.string.nl.authErrorEmailExists = 'Email adres word algebruikt';
z.string.nl.authErrorEmailForbidden = 'Sorry. Dit e-mailadres is verboden.';
z.string.nl.authErrorEmailMalformed = 'Voer alsjeblieft een geldig e-mailadres in.';
z.string.nl.authErrorEmailMissing = 'Voer alsjeblieft een e-mailadres in.';
z.string.nl.authErrorMisc = 'Problemen met de verbinding. Probeer het opnieuw.';
z.string.nl.authErrorNameShort = 'Voer een naam met ten minste 2 karakters';
z.string.nl.authErrorOffline = 'Geen internet connectie';
z.string.nl.authErrorPasswordShort = 'Kies een wachtwoord van minimaal 8 tekens.';
z.string.nl.authErrorPasswordWrong = 'Fout wachtwoord. Probeer opnieuw.';
z.string.nl.authErrorPending = 'Account is nog niet geverifieerd';
z.string.nl.authErrorPhoneNumberBudget = 'Je vaak ingelogd. Probeer het later opnieuw.';
z.string.nl.authErrorPhoneNumberForbidden = 'Sorry. Dit telefoon nummer is verboden.';
z.string.nl.authErrorPhoneNumberInvalid = 'Ongeldig Telefoonnummer';
z.string.nl.authErrorPhoneNumberUnknown = 'Onbekend Telefoon Nummer';
z.string.nl.authErrorSuspended = 'Dit account is niet langer geautoriseerd om in te loggen.';
z.string.nl.authErrorSignIn = 'Controleer je gegevens en probeer het nog eens.';

z.string.nl.callStateOutgoing = 'Bellen…';
z.string.nl.callStateConnecting = 'Verbinden…';
z.string.nl.callStateIncoming = 'Bellen…';
z.string.nl.callDecline = 'Leg op';
z.string.nl.callAccept = 'Neem op';
z.string.nl.callJoin = 'Deelnemen';
z.string.nl.callChooseSharedScreen = 'Kies een scherm om te delen';
z.string.nl.callParticipants = '{{number}} bellen';

z.string.nl.videoCallOverlayMute = 'Dempen';
z.string.nl.videoCallOverlayHangUp = 'Ophangen';

z.string.nl.modalAcknowledgeAction = 'Ok';
z.string.nl.modalConfirmSecondary = 'Annuleer';
z.string.nl.modalOptionSecondary = 'Annuleer';

z.string.nl.modalAccountCreateAction = 'OK';

z.string.nl.modalAccountDeletionAction = 'Verwijderen';
z.string.nl.modalAccountDeletionHeadline = 'Verwijder account';
z.string.nl.modalAccountDeletionMessage = 'We vesturen je een bericht via email of SMS. Volg de instructies op in de link om je account te verwijderen.';

z.string.nl.modalAccountLeaveGuestRoomAction = 'Verlaten';

z.string.nl.modalAccountLogoutAction = 'Uitloggen';
z.string.nl.modalAccountLogoutHeadline = 'Gegevens wissen?';
z.string.nl.modalAccountLogoutOption = 'Verwijder al je persoonlijke gegevens en gesprekken op dit apparaat.';

z.string.nl.modalAccountNewDevicesSecondary = 'Beheer apparaten';
z.string.nl.modalAccountNewDevicesHeadline = 'Je account werd gebruikt op:';
z.string.nl.modalAccountNewDevicesFrom = 'Van:';
z.string.nl.modalAccountNewDevicesMessage = 'Als je dit niet zelf was, verwijder dan het apparaat en stel je wachtwoord opnieuw in.';

z.string.nl.modalAccountRemoveDeviceAction = 'Verwijder apparaat';
z.string.nl.modalAccountRemoveDeviceHeadline = 'Verwijder "{{device}}"';
z.string.nl.modalAccountRemoveDeviceMessage = 'Je wachtwoord is nodig om dit apparaat te verwijderen.';
z.string.nl.modalAccountRemoveDevicePlaceholder = 'Wachtwoord';

z.string.nl.modalAssetTooLargeMessage = 'U kunt bestanden versturen tot {{number}}';

z.string.nl.modalAssetParallelUploadsMessage = 'Je kan tot {{number}} bestanden tegelijk versturen.';

z.string.nl.modalCallEmptyConversationHeadline = 'Niemand om te bellen';
z.string.nl.modalCallEmptyConversationMessage = 'Er is hier niemand meer.';

z.string.nl.modalCallNoGroupVideoHeadline = 'Geen video bellen in groepen';
z.string.nl.modalCallNoGroupVideoMessage = 'Video berichten zijn niet beschikbaar in groep gesprekken.';

z.string.nl.modalCallNoMicrophoneAction = 'Vertel me meer';
z.string.nl.modalCallNoMicrophoneMessage = 'Uw browser heeft toegang nodig tot de microfoon om te bellen.';
z.string.nl.modalCallNoMicrophoneHeadline = 'Je kan niet bellen zonder microfoon';

z.string.nl.modalCallSecondIncomingAction = 'Beantwoord';
z.string.nl.modalCallSecondIncomingHeadline = 'Oproep beantwoorden?';
z.string.nl.modalCallSecondIncomingMessage = 'Uw huidige gesprek zal worden beëindigd.';

z.string.nl.modalCallSecondOngoingAction = 'Ophangen';
z.string.nl.modalCallSecondOngoingHeadline = 'Hang gesprek op op andere apparaat?';
z.string.nl.modalCallSecondOngoingMessage = 'Je kunt maar één gesprek tegelijk voeren.';

z.string.nl.modalCallSecondOutgoingAction = 'Ophangen';
z.string.nl.modalCallSecondOutgoingHeadline = 'Huidige gesprek ophangen?';
z.string.nl.modalCallSecondOutgoingMessage = 'Je kunt maar één gesprek tegelijk voeren.';

z.string.nl.modalConnectCancelAction = 'Ja';
z.string.nl.modalConnectCancelHeadline = 'Verzoek annuleren?';
z.string.nl.modalConnectCancelMessage = 'Verwijder verzoek aan {{user}}.';
z.string.nl.modalConnectCancelSecondary = 'Nee';

z.string.nl.modalConnectAcceptAction = 'Verbind';
z.string.nl.modalConnectAcceptHeadline = 'Accepteren?';
z.string.nl.modalConnectAcceptMessage = 'Dit zal een verbinding met {{user}} maken en een gesprek openen.';
z.string.nl.modalConnectAcceptSecondary = 'Negeer';

z.string.nl.modalConversationClearAction = 'Verwijderen';
z.string.nl.modalConversationClearHeadline = 'Inhoud verwijderen?';
z.string.nl.modalConversationClearOption = 'Ook het gesprek verlaten';

z.string.nl.modalConversationDeleteMessageAction = 'Verwijderen';
z.string.nl.modalConversationDeleteMessageHeadline = 'Alleen voor mij verwijderen?';
z.string.nl.modalConversationDeleteMessageMessage = 'Dit kan niet ongedaan gemaakt worden.';

z.string.nl.modalConversationDeleteMessageEveryoneAction = 'Verwijderen';
z.string.nl.modalConversationDeleteMessageEveryoneHeadline = 'Voor iedereen verwijderen?';
z.string.nl.modalConversationDeleteMessageEveryoneMessage = 'Dit kan niet ongedaan gemaakt worden.';

z.string.nl.modalConversationLeaveAction = 'Verlaten';
z.string.nl.modalConversationLeaveMessage = 'Je zal niet in staat zijn om berichten in deze conversatie te verzenden of te ontvangen.';

z.string.nl.modalConversationMessageTooLongHeadline = 'Bericht te lang';
z.string.nl.modalConversationMessageTooLongMessage = 'Je kan berichten verzenden van maximaal {{number}} tekens.';

z.string.nl.modalConversationNewDeviceHeadlineOne = '{{user}} gebruikt een nieuw apparaat';
z.string.nl.modalConversationNewDeviceHeadlineMany = '{{users}} gebruiken nieuwe apparaten';
z.string.nl.modalConversationNewDeviceHeadlineYou = '{{user}} gebruikt een nieuw apparaat';
z.string.nl.modalConversationNewDeviceIncomingCallAction = 'Gesprek aannemen';
z.string.nl.modalConversationNewDeviceIncomingCallMessage = 'Wil je het gesprek nog steeds accepteren?';
z.string.nl.modalConversationNewDeviceMessage = 'Wil je het bericht nog steeds versturen?';
z.string.nl.modalConversationNewDeviceOutgoingCallAction = 'Toch bellen';
z.string.nl.modalConversationNewDeviceOutgoingCallMessage = 'Wil je het gesprek nog steeds voeren?';

z.string.nl.modalConversationNotConnectedHeadline = 'Niemand toegevoegd tot conversatie';
z.string.nl.modalConversationNotConnectedMessageOne = '{{name}} wil niet toegevoegd worden aan gesprekken.';
z.string.nl.modalConversationNotConnectedMessageMany = 'Een van de mensen die je hebt geselecteerd wil niet worden toegevoegd aan gesprekken.';

z.string.nl.modalConversationRemoveAction = 'Verwijderen';
z.string.nl.modalConversationRemoveHeadline = 'Verwijder?';
z.string.nl.modalConversationRemoveMessage = '{{user}} zal geen berichten kunnen versturen of ontvangen in dit gesprek.';

z.string.nl.modalConversationRemoveGuestsAction = 'Verwijderen';

z.string.nl.modalConversationTooManyMembersHeadline = 'Full house';

z.string.nl.modalIntegrationUnavailableHeadline = 'Bots zijn nu niet beschikbaar';
z.string.nl.modalIntegrationUnavailableMessage = 'Dank je voor je intress voor bots. De service is nu gestopt, terwijl we nu werken aan een volgende versie.';


z.string.nl.modalImproveWireAction = 'Neem op';
z.string.nl.modalImproveWireSecondary = 'Nee';

z.string.nl.modalServiceUnavailableHeadline = 'Toevoegen van de service niet mogelijk';
z.string.nl.modalServiceUnavailableMessage = 'De service is op dit moment niet beschikbaar.';

z.string.nl.modalSessionResetHeadline = 'De sessie is gereset';
z.string.nl.modalSessionResetMessage1 = 'Als het probleem niet is opgelost, ';
z.string.nl.modalSessionResetMessageLink = 'contact';
z.string.nl.modalSessionResetMessage2 = 'ons.';

z.string.nl.modalUploadContactsAction = 'Probeer opnieuw';
z.string.nl.modalUploadContactsMessage = 'We hebben geen informatie ontvangen. Probeer opnieuw je contacten te importeren.';

z.string.nl.modalUserBlockAction = 'Blokkeren';
z.string.nl.modalUserBlockHeadline = '{{user}} blokkeren?';
z.string.nl.modalUserBlockMessage = '{{user}} zal niet in staat zijn je te contacteren of toe te voegen aan een groepsgesprek.';

z.string.nl.modalUserUnblockAction = 'Deblokkeer';
z.string.nl.modalUserUnblockHeadline = 'Deblokkeer?';
z.string.nl.modalUserUnblockMessage = '{{user}} zal weer in staat zijn je te contacteren en je toe te voegen aan een groepsgesprek.';

z.string.nl.connectionRequestConnect = 'Verbind';
z.string.nl.connectionRequestIgnore = 'Negeer';

z.string.nl.conversationGuestIndicator = 'Gast';

z.string.nl.conversationYouNominative = 'jij';
z.string.nl.conversationYouDative = 'jij';
z.string.nl.conversationYouAccusative = 'jij';

z.string.nl.conversationConnectionAccepted = 'Verbonden';
z.string.nl.conversationConnectionBlocked = 'Geblokkeerd';
z.string.nl.conversationConnectionCancelRequest = 'Stop verzoek tot connectie';
z.string.nl.conversationCreateWith = 'met {{users}}';
z.string.nl.conversationDeviceStartedUsingOne = ' begon met het gebruik van';
z.string.nl.conversationDeviceStartedUsingMany = ' begon met het gebruik van';
z.string.nl.conversationDeviceUnverified = ' unverified een van';
z.string.nl.conversationDeviceYourDevices = ' jou apparaten';
z.string.nl.conversationDeviceUserDevices = '{{user}}´s apparaten';
z.string.nl.conversationDeviceNewDeviceOne = ' een nieuw apparaat';
z.string.nl.conversationDeviceNewDeviceMany = ' nieuw apparaaten';
z.string.nl.conversationDeviceNewPeopleJoinedVerify = ' controleer apparaten';
z.string.nl.conversationJustNow = 'Zojuist';
z.string.nl.conversationLocationLink = 'Open kaart';
z.string.nl.conversationMessageDelivered = 'Afgeleverd';
z.string.nl.conversationRename = ' je hebt de conversatie hernoemt';
z.string.nl.conversationRenameYou = ' je hebt de conversatie hernoemt';
z.string.nl.conversationResume = 'Begin een gesprek met {{users}}';
z.string.nl.conversationPing = ' pinged';
z.string.nl.conversationPingYou = ' pinged';
z.string.nl.conversationToday = 'vandaag';
z.string.nl.conversationVoiceChannelDeactivate = ' belde';
z.string.nl.conversationVoiceChannelDeactivateYou = ' belde';
z.string.nl.conversationYesterday = 'Gisteren';
z.string.nl.conversationUnableToDecrypt1 = 'een bericht van {{user}} is niet ontvangen.';
z.string.nl.conversationUnableToDecrypt2 = '{{user}}’s apparaatidentiteit is veranderd. Het bericht is niet afgeleverd.';
z.string.nl.conversationUnableToDecryptLink = 'Waarom?';
z.string.nl.conversationUnableToDecryptErrorMessage = 'Fout';
z.string.nl.conversationUnableToDecryptResetSession = 'Reset session';
z.string.nl.conversationMissedMessages = 'Je hebt dit apparaat een tijdje niet gebruikt. Sommige berichten worden hier niet getoond.';
z.string.nl.conversationAssetDownloading = 'Downloaden…';
z.string.nl.conversationAssetUploadFailed = 'Uploaden mislukt';
z.string.nl.conversationPlaybackError = 'Niet in staat om te af te spelen';
z.string.nl.conversationContextMenuCopy = 'Kopiëren';
z.string.nl.conversationContextMenuEdit = 'Bewerken';
z.string.nl.conversationContextMenuDelete = 'Verwijderen voor mij';
z.string.nl.conversationContextMenuDeleteEveryone = 'Verwijderen voor iedereen';
z.string.nl.conversationContextMenuDownload = 'Download';
z.string.nl.conversationContextMenuLike = 'Vind ik leuk';
z.string.nl.conversationContextMenuUnlike = 'Vind ik niet leuk';
z.string.nl.conversationDeleteTimestamp = 'Verwijderd op {{date}}';
z.string.nl.conversationEditTimestamp = 'Bewerkt op {{date}}';
z.string.nl.conversationLikesCaption = '{{number}} mensen';
z.string.nl.conversationSendPastedFile = 'Afbeelding geplakt op {{date}}';
z.string.nl.conversationSomeone = 'Iemand';
z.string.nl.conversationTweetAuthor = ' op Twitter';

z.string.nl.groupCreationPreferencesAction = 'Volgende';
z.string.nl.groupCreationPreferencesErrorNameShort = 'Minimaal 1 teken';
z.string.nl.groupCreationPreferencesErrorNameLong = 'Te veel tekens';
z.string.nl.groupCreationPreferencesHeader = 'Nieuwe groep';
z.string.nl.groupCreationPreferencesPlaceholder = 'Groepsnaam';
z.string.nl.groupCreationParticipantsActionCreate = 'Klaar';
z.string.nl.groupCreationParticipantsActionSkip = 'Sla over';
z.string.nl.groupCreationParticipantsHeader = 'Personen toevoegen';
z.string.nl.groupCreationParticipantsPlaceholder = 'Zoeken op naam';


z.string.nl.collectionShowAll = 'Toon alle {{number}}';
z.string.nl.collectionSectionLinks = 'Links';
z.string.nl.collectionSectionImages = 'Afbeeldingen';
z.string.nl.collectionSectionFiles = 'Bestanden';
z.string.nl.collectionSectionAudio = 'Audio berichten';

z.string.nl.fullsearchPlaceholder = 'Zoek tekst berichten';
z.string.nl.fullsearchNoResults = 'Geen resultaten.';

z.string.nl.archiveHeader = 'Archiveren';

z.string.nl.conversationsAllArchived = 'Alles gearchiveerd';
z.string.nl.conversationsContacts = 'Contacten';
z.string.nl.conversationsConnectionRequestMany = '{{number}} personen wachten';
z.string.nl.conversationsConnectionRequestOne = '1 persoon wacht';
z.string.nl.conversationsEmptyConversation = 'Groepsgesprek';
z.string.nl.conversationsNoConversations = 'Nog geen gesprekken';
z.string.nl.conversationsPopoverArchive = 'Archiveren';
z.string.nl.conversationsPopoverCancel = 'Annuleer verzoek';
z.string.nl.conversationsPopoverNotify = 'Dempen opheffen';
z.string.nl.conversationsPopoverSilence = 'Dempen';
z.string.nl.conversationsPopoverUnarchive = 'Terugzetten';

z.string.nl.conversationsSecondaryLineEphemeralMessage = 'Stuurde je een bericht';
z.string.nl.conversationsSecondaryLinePeopleLeft = '{{number}} personen verlieten dit gesprek';
z.string.nl.conversationsSecondaryLinePersonLeft = '{{user}} verliet dit gesprek';
z.string.nl.conversationsSecondaryLinePersonRemoved = '{{user}} is verwijderd';
z.string.nl.conversationsSecondaryLinePeopleAdded = '{{user}} personen zijn toegevoegd';
z.string.nl.conversationsSecondaryLinePersonAdded = '{{user}} is toegevoegd';
z.string.nl.conversationsSecondaryLinePersonAddedYou = '{{user}} heeft jou toegevoegd';
z.string.nl.conversationsSecondaryLineRenamed = '{{user}} hernoemde de conversatie';
z.string.nl.conversationsSecondaryLineYouLeft = 'Je hebt het gesprek verlaten';
z.string.nl.conversationsSecondaryLineYouWereRemoved = 'Je bent verwijderd';

z.string.nl.takeoverSub = 'Claim je unieke gebruikers naam op Wire.';
z.string.nl.takeoverLink = 'Leer meer';
z.string.nl.takeoverButtonChoose = 'Kies je eigen';
z.string.nl.takeoverButtonKeep = 'Behoud deze';

z.string.nl.inviteMetaKeyMac = 'Cmd';
z.string.nl.inviteMetaKeyPc = 'Ctrl';
z.string.nl.inviteHeadline = 'Nodig anderen uit voor Wire';
z.string.nl.inviteMessage = 'Ik gebruik Wire, zoek naar {{username}} of bezoek get.wire.com.';
z.string.nl.inviteMessageNoEmail = 'Ik gebruik Wire. Ga naar get.wire.com om met mij te verbinden.';

z.string.nl.extensionsBubbleButtonGif = 'Gif';

z.string.nl.extensionsGiphyButtonOk = 'Stuur';
z.string.nl.extensionsGiphyButtonMore = 'Probeer een andere';
z.string.nl.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.nl.extensionsGiphyNoGifs = 'Oeps, geen gifjes';
z.string.nl.extensionsGiphyRandom = 'Random';

z.string.nl.addParticipantsConfirmLabel = 'Toevoegen';
z.string.nl.addParticipantsHeader = 'Personen toevoegen';
z.string.nl.addParticipantsSearchPlaceholder = 'Zoeken op naam';
z.string.nl.addParticipantsServiceConfirmButton = 'Service toevoegen';
z.string.nl.addParticipantsTabsPeople = 'Deelnemers';
z.string.nl.addParticipantsTabsServices = 'Services';

z.string.nl.conversationDetailsActionArchive = 'Archiveren';
z.string.nl.conversationDetailsActionAddParticipants = 'Personen toevoegen';
z.string.nl.conversationDetailsActionCancelRequest = 'Annuleer verzoek';
z.string.nl.conversationDetailsActionCreateGroup = 'Nieuwe groep';
z.string.nl.conversationDetailsActionDevices = 'Apparaten';
z.string.nl.conversationDetailsActionNotifications = 'Meldingen';
z.string.nl.conversationDetailsGuestsOff = 'Uit';
z.string.nl.conversationDetailsOptions = 'Opties';
z.string.nl.conversationDetailsParticipantsServicesMany = 'Services';
z.string.nl.conversationDetailsParticipantsUsersMany = 'Deelnemers';
z.string.nl.conversationDetailsPeople = 'Deelnemers';
z.string.nl.conversationDetailsServices = 'Services';

z.string.nl.conversationParticipantsTitle = 'Deelnemers';
z.string.nl.conversationParticipantsSearchPlaceholder = 'Zoeken op naam';

z.string.nl.groupParticipantActionCancelRequest = 'Annuleer verzoek';
z.string.nl.groupParticipantActionDevices = 'Apparaten';
z.string.nl.groupParticipantActionPending = 'In behandeling';
z.string.nl.groupParticipantActionSendRequest = 'Verbind';

z.string.nl.notificationSettingsTitle = 'Meldingen';

z.string.nl.participantDevicesDetailHeadline = 'Verifieer dat deze digitale vingerafdruk overeenkomt met {{html1}}{{user}}’s apparaat{{html2}}.';
z.string.nl.participantDevicesDetailHowTo = 'Hoe doe ik dat?';
z.string.nl.participantDevicesDetailResetSession = 'Reset session';
z.string.nl.participantDevicesDetailShowMyDevice = 'Toon de digitale vingerafdruk van mijn apparaat';
z.string.nl.participantDevicesDetailVerify = 'Geverifieerd';

z.string.nl.participantDevicesHeader = 'Apparaten';
z.string.nl.participantDevicesHeadline = 'Wire geeft elk apparaat een unieke vingerafdruk. Vergelijk deze met {{user}} en verifieer het gesprek.';
z.string.nl.participantDevicesLearnMore = 'Leer meer';
z.string.nl.participantDevicesWhyVerify = 'Waarom gesprekken verifiëren?';
z.string.nl.participantDevicesOutdatedClientMessage = '{{user}} gebruikt een oude versie van Wire. Er worden daarom geen apparaten getoond.';

z.string.nl.participantDevicesSelfAllDevices = 'Toon al mijn apparaten';
z.string.nl.participantDevicesSelfFingerprint = 'Digitale vingerafdruk';

z.string.nl.userProfileButtonConnect = 'Verbind';
z.string.nl.userProfileButtonIgnore = 'Negeer';
z.string.nl.userProfileButtonUnblock = 'Deblokkeer';

z.string.nl.preferencesAbout = 'Over ons';
z.string.nl.preferencesAccount = 'Profiel';
z.string.nl.preferencesAV = 'Geluid/ film';
z.string.nl.preferencesDeviceDetails = 'Apparaat Details';
z.string.nl.preferencesDevices = 'Apparaten';
z.string.nl.preferencesHeadline = 'Voorkeuren';
z.string.nl.preferencesOptions = 'Opties';

z.string.nl.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.nl.preferencesAboutPrivacyPolicy = 'Privacy Policy';
z.string.nl.preferencesAboutSupport = 'Ondersteuning';
z.string.nl.preferencesAboutSupportWebsite = 'Support Website';
z.string.nl.preferencesAboutSupportContact = 'Contact Support';
z.string.nl.preferencesAboutTermsOfUse = 'Gebruikersvoorwaarden';
z.string.nl.preferencesAboutVersion = 'Versie {{version}}';
z.string.nl.preferencesAboutWebsite = 'Wire Website';

z.string.nl.preferencesAccountAvaibilityUnset = 'Een status instellen';
z.string.nl.preferencesAccountCreateTeam = 'Maak een team';
z.string.nl.preferencesAccountDelete = 'Verwijder account';
z.string.nl.preferencesAccountLogOut = 'Uitloggen';
z.string.nl.preferencesAccountManageTeam = 'Beheer team';
z.string.nl.preferencesAccountResetPassword = 'Reset wachtwoord';
z.string.nl.preferencesAccountTeam = 'in {{name}}';
z.string.nl.preferencesAccountUsernamePlaceholder = 'Je volledige naam';
z.string.nl.preferencesAccountUsernameHint = 'Ten minste 2 tekens. a—z, 0—9, en _ alleen.';
z.string.nl.preferencesAccountUsernameAvailable = 'Beschikbaar';
z.string.nl.preferencesAccountUsernameErrorTaken = 'Al in gebruik';

z.string.nl.preferencesAVCamera = 'Camera';
z.string.nl.preferencesAVMicrophone = 'Microfoon';
z.string.nl.preferencesAVPermissionDetail = 'Schakel in vanuit je browser instellingen';
z.string.nl.preferencesAVSpeakers = 'Luidsprekers';

z.string.nl.preferencesDevicesActivatedOn = 'Eerste keer gebruikt op {{date}}';
z.string.nl.preferencesDevicesActive = 'Actief';
z.string.nl.preferencesDevicesActiveDetail = 'Als je een van de bovengenoemde apparaten niet kent, verwijder deze dan en wijzig je wachtwoord.';
z.string.nl.preferencesDevicesCurrent = 'Huidig';
z.string.nl.preferencesDevicesFingerprint = 'Digitale vingerafdruk';
z.string.nl.preferencesDevicesFingerprintDetail = 'Wire geeft elk apparaat een eigen vingerafdruk. Vergelijk deze en verifieer je apparaten en gesprekken.';
z.string.nl.preferencesDevicesId = 'ID: ';
z.string.nl.preferencesDevicesRemoveCancel = 'Annuleer';
z.string.nl.preferencesDevicesRemoveDetail = 'Verwijder dit apparaat als je het niet meer gebruikt. Je berichtengeschiedenis wordt verwijderd op dit apparaat en je wordt uitgelogd.';
z.string.nl.preferencesDevicesSessionConfirmation = 'De sessie is gereset.';
z.string.nl.preferencesDevicesSessionDetail = 'Als de digitale vingerafdruk niet overeenkomt, herstart dan de sessie om nieuwe encryptiesleutels aan te maken op beide apparaten.';
z.string.nl.preferencesDevicesSessionReset = 'Reset session';
z.string.nl.preferencesDevicesSessionOngoing = 'Sessie resetten…';
z.string.nl.preferencesDevicesVerification = 'Geverifieerd';

z.string.nl.preferencesOptionsAudio = 'Geluidswaarschuwing';
z.string.nl.preferencesOptionsAudioAll = 'Alle';
z.string.nl.preferencesOptionsAudioAllDetail = 'Alle Geluiden';
z.string.nl.preferencesOptionsAudioNone = 'Geen';
z.string.nl.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.nl.preferencesOptionsAudioSome = 'Sommige';
z.string.nl.preferencesOptionsAudioSomeDetail = 'Pings en oproepen';
z.string.nl.preferencesOptionsContacts = 'Contacten';
z.string.nl.preferencesOptionsContactsGmail = 'Importeren uit Gmail';
z.string.nl.preferencesOptionsContactsMacos = 'Importeren uit contacten';
z.string.nl.preferencesOptionsContactsDetail = 'Dit helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';
z.string.nl.preferencesOptionsPopular = 'Op veler verzoek';
z.string.nl.preferencesOptionsEmojiReplaceCheckbox = 'Getypte emoticons vervangen door emojis';
z.string.nl.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.nl.preferencesOptionsPreviewsSendCheckbox = 'Maak linkvoorbeelden voor links die jij verstuurt';
z.string.nl.preferencesOptionsPreviewsSendDetail = 'Linkvoorbeelden kunnen nog steeds getoond worden voor links van andere mensen.';
z.string.nl.preferencesOptionsNotifications = 'Meldingen';
z.string.nl.preferencesOptionsNotificationsNone = 'Uit';
z.string.nl.preferencesOptionsNotificationsObfuscate = 'Details verbergen';
z.string.nl.preferencesOptionsNotificationsObfuscateMessage = 'Toon zender';
z.string.nl.preferencesOptionsNotificationsOn = 'Toon verzender en bericht';

z.string.nl.backupCancel = 'Annuleer';

z.string.nl.searchConnect = 'Verbind';
z.string.nl.searchConnections = 'Contacten';
z.string.nl.searchContacts = 'Contacten';
z.string.nl.searchCreateGroup = 'Maak groep';
z.string.nl.searchGroups = 'Groepen';
z.string.nl.searchPeople = 'Deelnemers';
z.string.nl.searchPlaceholder = 'Zoek op naam of gebruikersnaam';
z.string.nl.searchServicePlaceholder = 'Zoeken op naam';
z.string.nl.searchServices = 'Services';
z.string.nl.searchTeamGroups = 'Teamgesprekken';
z.string.nl.searchTeamMembers = 'Teamleden';
z.string.nl.searchTopPeople = 'Frequente personen';
z.string.nl.searchTrySearch = 'Vind mensen met hun \nnaam of gebruikersnaam';
z.string.nl.searchNoContactsOnWire = 'Je hebt geen contacten op Wire\nProbeer mensen te vinden met hun\nnaam of gebruikersnaam.';
z.string.nl.searchMemberInvite = 'Nodig andere mensen uit voor het team';
z.string.nl.searchOthers = 'Verbind';

z.string.nl.searchInvite = 'Nodig andere mensen uit voor Wire';
z.string.nl.searchInviteDetail = 'Het delen van je contacten helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';
z.string.nl.searchInviteButtonContacts = 'Van contacten';
z.string.nl.searchInviteButtonGmail = 'Van Gmail';
z.string.nl.searchInviteHeadline = 'Nodig je vrienden uit';
z.string.nl.searchInviteShare = 'Contacten delen';

z.string.nl.searchServiceConfirmButton = 'Service toevoegen';

z.string.nl.searchListEveryoneParticipates = 'Iedereen met wie je contact hebt zit al in dit gesprek.';
z.string.nl.searchListNoMatches = 'Geen overeenkomende resultaten.\nProbeer een andere gebruikersnaam.';

z.string.nl.temporaryGuestCta = 'Een account aanmaken';

z.string.nl.uploadGoogleHeadline = 'Zoek mensen \nom mee te praten.';
z.string.nl.uploadGoogleMessage = 'Dit helpt je om met anderen te verbinden. We anonimiseren alle informatie en delen deze niet met iemand anders.';

z.string.nl.warningCallUnsupportedIncoming = '{{user}} belt, maar je browser ondersteund geen gesprekken.';
z.string.nl.warningCallUnsupportedOutgoing = 'Je kan niet bellen omdat jou browser dit niet ondersteund.';
z.string.nl.warningCallIssues = 'Deze versie kan niet deelnemen met het bellen. Gebruik alsjeblieft';
z.string.nl.warningCallUpgradeBrowser = 'Update Google Chrome om te kunnen bellen.';
z.string.nl.warningConnectivityConnectionLost = 'Wire kan misschien geen berichten versturen. ';
z.string.nl.warningConnectivityNoInternet = 'Geen internet. Je kan nu geen berichten versturen of ontvangen.';
z.string.nl.warningLearnMore = 'Leer meer';
z.string.nl.warningLifecycleUpdate = 'Er is een nieuwe versie van Wire beschikbaar.';
z.string.nl.warningLifecycleUpdateNotes = 'Wat is er nieuw';
z.string.nl.warningLifecycleUpdateLink = 'Nu bijwerken';
z.string.nl.warningNotFoundCamera = 'Je kan niet bellen omdat je computer geen toegang heeft tot je camera.';
z.string.nl.warningNotFoundMicrophone = 'Je kan niet bellen omdat je computer geen toegang heeft tot je microfoon.';
z.string.nl.warningPermissionDeniedCamera = 'Je kan niet bellen omdat je browser geen toegang heeft tot de camera.';
z.string.nl.warningPermissionDeniedMicrophone = 'Je kan niet bellen omdat je browser geen toegang heeft tot de microfoon.';
z.string.nl.warningPermissionDeniedScreen = 'Je browser heeft permissie nodig om je scherm te delen.';
z.string.nl.warningPermissionRequestCamera = '{{icon}} Toegang tot camera toestaan';
z.string.nl.warningPermissionRequestMicrophone = '{{icon}} Toegang tot de microfoon toestaan';
z.string.nl.warningPermissionRequestNotification = '{{icon}} Meldingen toestaan';
z.string.nl.warningPermissionRequestScreen = '{{icon}} Toegang tot scherm toestaan';

z.string.nl.userAvailabilityAvailable = 'Beschikbaar';
z.string.nl.userAvailabilityAway = 'Afwezig';
z.string.nl.userAvailabilityBusy = 'Bezet';
z.string.nl.userAvailabilityNone = 'Geen';

z.string.nl.notificationAssetAdd = 'Deelde een foto';
z.string.nl.notificationConnectionAccepted = 'Accepteer connectie aanvraag';
z.string.nl.notificationConnectionConnected = 'Zijn nu verbonden';
z.string.nl.notificationConnectionRequest = 'Wil met jou verbinden';
z.string.nl.notificationConversationCreate = '{{user}} is een gesprek begonnen';
z.string.nl.notificationConversationRename = '{{user}} heeft het gesprek naar {{name}} hernoemd';
z.string.nl.notificationMemberJoinMany = '{{user}} heeft {{number}} mensen aan het gesprek toegevoegd';
z.string.nl.notificationMemberJoinOne = '{{user1}} heeft {{user2}} aan het gesprek toegevoegd';
z.string.nl.notificationMemberLeaveRemovedYou = '{{user}} verwijderde je uit dit gesprek';
z.string.nl.notificationObfuscated = 'Stuurde je een bericht';
z.string.nl.notificationObfuscatedTitle = 'Iemand';
z.string.nl.notificationPing = 'Gepinged';
z.string.nl.notificationReaction = '{{reaction}} je bericht';
z.string.nl.notificationSharedAudio = 'Deelde een audio bericht';
z.string.nl.notificationSharedFile = 'Deelde een bestand';
z.string.nl.notificationSharedLocation = 'Deel een locatie';
z.string.nl.notificationSharedVideo = 'Deelde een video';
z.string.nl.notificationVoiceChannelActivate = 'Bellen';
z.string.nl.notificationVoiceChannelDeactivate = 'Heeft gebeld';

z.string.nl.tooltipConversationAllVerified = 'Alle vingerafdrukken zijn geverifieerd';
z.string.nl.tooltipConversationCall = 'Oproep';
z.string.nl.tooltipConversationEphemeral = 'Tijdelijk bericht';
z.string.nl.tooltipConversationFile = 'Bestand toevoegen';
z.string.nl.tooltipConversationInputPlaceholder = 'Typ een bericht';
z.string.nl.tooltipConversationInputPlaceholderAvailable = '{{user}} is beschikbaar';
z.string.nl.tooltipConversationInputPlaceholderAway = '{{user}} is afwezig';
z.string.nl.tooltipConversationInputPlaceholderBusy = '{{user}} is bezet';
z.string.nl.tooltipConversationPeople = 'Mensen ({{shortcut}})';
z.string.nl.tooltipConversationPicture = 'Voeg foto toe';
z.string.nl.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.nl.tooltipConversationSearch = 'Zoeken';
z.string.nl.tooltipConversationVideoCall = 'Video-oproep';

z.string.nl.tooltipConversationsArchive = 'Archief ({{shortcut}})';
z.string.nl.tooltipConversationsArchived = 'Toon archief ({{number}})';
z.string.nl.tooltipConversationsMore = 'Meer';
z.string.nl.tooltipConversationsNotify = 'Dempen uit ({{shortcut}})';
z.string.nl.tooltipConversationsPreferences = 'Open instelllingen';
z.string.nl.tooltipConversationsSilence = 'Dempen ({{shortcut}})';
z.string.nl.tooltipConversationsStart = 'Start gesprek ({{shortcut}})';

z.string.nl.tooltipConversationDetailsRename = 'Verander gesprek naam';

z.string.nl.tooltipPreferencesContactsGmail = 'Log in op je Gmail account om je contacten te delen';
z.string.nl.tooltipPreferencesContactsMacos = 'Deel al je contacten van de macOS Contact app';
z.string.nl.tooltipPreferencesPassword = 'Open andere website om je wachtwoord te resetten';
z.string.nl.tooltipPreferencesPicture = 'Verander je foto…';
z.string.nl.tooltipPreferencesRename = 'Wijzig je naam';

z.string.nl.tooltipSearchClose = 'Sluiten (esc)';

z.string.nl.initReceivedSelfUser = 'Hallo {{user}}!';
z.string.nl.initValidatedClient = 'Je gesprekken en connecties worden opgehaald';
z.string.nl.initReceivedUserData = 'Controleer voor nieuwe berichten';
z.string.nl.initDecryption = 'Berichten ontsleutelen';
z.string.nl.initEvents = 'Berichten laden';
z.string.nl.initUpdatedFromNotifications = 'Bijna klaar - Geniet van Wire';
z.string.nl.initProgress = ' — {{number1}} van {{number2}}';

z.string.nl.ephemeralUnitsNone = 'Uit';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.pl.wireMacos = 'Wire dla macOS';
z.string.pl.wireWindows = 'Wire dla Windows';
z.string.pl.wireLinux = 'Wire dla Linuksa';
z.string.pl.nonexistentUser = 'Użytkownik usunięty';
z.string.pl.and = 'oraz';
z.string.pl.enumerationAnd = ', i ';

z.string.pl.authAccountCountryCode = 'Kierunkowy kraju';
z.string.pl.authAccountPasswordForgot = 'Zapomniałem hasła';
z.string.pl.authAccountPublicComputer = 'To jest komputer publiczny';
z.string.pl.authAccountSignIn = 'Zaloguj się';
z.string.pl.authAccountSignInPhone = 'Numer telefonu';

z.string.pl.authBlockedCookies = 'Włącz ciasteczka do zalogowania się do Wire.';
z.string.pl.authBlockedDatabase = 'Wire potrzebuje dostępu do pamięci lokalnej, by wyświetlać wiadomości. Pamięć lokalna nie jest dostępna w trybie prywatnym.';
z.string.pl.authBlockedTabs = 'Wire jest już otwarty w innej zakładce.';

z.string.pl.authVerifyAccountAdd = 'Dodaj';
z.string.pl.authVerifyAccountDetail = 'To pozwala Ci używać Wire na więcej niż jednym urządzeniu.';
z.string.pl.authVerifyAccountHeadline = 'Dodaj adres e-mail i hasło.';
z.string.pl.authVerifyAccountLogout = 'Wyloguj się';
z.string.pl.authVerifyCodeDescription = 'Wpisz kod weryfikacyjny, który wysłaliśmy do {{number}}.';
z.string.pl.authVerifyCodeResend = 'Nie otrzymałeś(aś) kodu?';
z.string.pl.authVerifyCodeResendDetail = 'Wyślij ponownie';
z.string.pl.authVerifyCodeResendTimer = 'Możesz poprosić o nowy kod {{expiration}}.';
z.string.pl.authVerifyCodeChangePhone = 'Zmień numer telefonu';
z.string.pl.authVerifyPasswordHeadline = 'Wprowadź hasło';

z.string.pl.authLimitDevicesHeadline = 'Urządzenia';
z.string.pl.authLimitDescription = 'Żeby dodać to urządzenie, usuń jedno z poprzednich.';
z.string.pl.authLimitButtonManage = 'Zarządzaj urządzeniami';
z.string.pl.authLimitButtonSignOut = 'Wyloguj się';
z.string.pl.authLimitDevicesCurrent = '(Używane urządzenie)';

z.string.pl.authHistoryHeadline = 'Uruchomiłeś Wire na tym urządzeniu po raz pierwszy.';
z.string.pl.authHistoryDescription = 'Ze względu na prywatność, poprzednie rozmowy nie będą tutaj widoczne.';
z.string.pl.authHistoryReuseHeadline = 'Używałeś wcześniej Wire na tym urządzeniu.';
z.string.pl.authHistoryReuseDescription = 'Wiadomości wysłane w międzyczasie nie pojawią się.';
z.string.pl.authHistoryButton = 'OK';

z.string.pl.authPostedResend = 'Wyślij ponownie na {{email}}';
z.string.pl.authPostedResendAction = 'Nie otrzymałeś e-maila?';
z.string.pl.authPostedResendDetail = 'Sprawdź swoją skrzynkę e-mail i postępuj zgodnie z instrukcjami.';
z.string.pl.authPostedResendHeadline = 'Masz wiadomość.';

z.string.pl.authPlaceholderEmail = 'Adres e-mail';
z.string.pl.authPlaceholderPasswordPut = 'Hasło';
z.string.pl.authPlaceholderPasswordSet = 'Hasło (musi mieć przynajmniej 8 znaków)';
z.string.pl.authPlaceholderPhone = 'Numer telefonu';

z.string.pl.authErrorCode = 'Nieprawidłowy kod';
z.string.pl.authErrorCountryCodeInvalid = 'Błędy kierunkowy kraju';
z.string.pl.authErrorEmailExists = 'Adres e-mail już istnieje';
z.string.pl.authErrorEmailForbidden = 'Przepraszamy. Ten adres e-mail został zabroniony.';
z.string.pl.authErrorEmailMalformed = 'Wpisz proszę prawidłowy adres e-mail.';
z.string.pl.authErrorEmailMissing = 'Podaj adres e-mail.';
z.string.pl.authErrorMisc = 'Problemy z połączeniem. Proszę spróbować ponownie.';
z.string.pl.authErrorNameShort = 'Wprowadź nazwę - musi mieć co najmniej 2 znaki';
z.string.pl.authErrorOffline = 'Brak połączenia z Internetem';
z.string.pl.authErrorPasswordShort = 'Wybierz hasło - musi mieć co najmniej 8 znaków.';
z.string.pl.authErrorPasswordWrong = 'Niewłaściwe hasło, proszę spróbować ponownie.';
z.string.pl.authErrorPending = 'Konto niezweryfikowane';
z.string.pl.authErrorPhoneNumberBudget = 'Zbyt wiele prób logowania. Odczekaj chwilę i spróbuj ponownie.';
z.string.pl.authErrorPhoneNumberForbidden = 'Przepraszamy. Ten numer telefonu został zabroniony.';
z.string.pl.authErrorPhoneNumberInvalid = 'Nieprawidłowy numer telefonu';
z.string.pl.authErrorPhoneNumberUnknown = 'Nieznany numer telefonu';
z.string.pl.authErrorSuspended = 'To konto jest już uprawnione do zalogowania się.';
z.string.pl.authErrorSignIn = 'Proszę sprawdzić swoje dane i spróbować ponownie.';

z.string.pl.callStateOutgoing = 'Dzwoni…';
z.string.pl.callStateConnecting = 'Łączenie…';
z.string.pl.callStateIncoming = 'Dzwoni…';
z.string.pl.callDecline = 'Odrzuć';
z.string.pl.callAccept = 'Odbierz';
z.string.pl.callJoin = 'Dołącz';
z.string.pl.callChooseSharedScreen = 'Wybierz ekran do współdzielenia';
z.string.pl.callParticipants = '{{number}} uczestników';

z.string.pl.videoCallOverlayMute = 'Wycisz';
z.string.pl.videoCallOverlayHangUp = 'Rozłącz';

z.string.pl.modalAcknowledgeAction = 'OK';
z.string.pl.modalAcknowledgeHeadline = 'Coś poszło nie tak';
z.string.pl.modalConfirmSecondary = 'Anuluj';
z.string.pl.modalOptionSecondary = 'Anuluj';

z.string.pl.modalAccountCreateAction = 'OK';
z.string.pl.modalAccountCreateHeadline = 'Utwórz konto';

z.string.pl.modalAccountDeletionAction = 'Usuń';
z.string.pl.modalAccountDeletionHeadline = 'Usuń konto';
z.string.pl.modalAccountDeletionMessage = 'Wyślemy wiadomość poprzez e-mail lub SMS. Proszę użyć tego odnośnika, żeby trwale usunąć konto.';

z.string.pl.modalAccountLeaveGuestRoomAction = 'Opuść';
z.string.pl.modalAccountLeaveGuestRoomHeadline = 'Opuść pokój gości.';
z.string.pl.modalAccountLeaveGuestRoomMessage = 'Historia konwersacji zostanie usunięta. Żeby ją zatrzymać, następnym razem utwórz konto.';

z.string.pl.modalAccountLogoutAction = 'Wyloguj się';
z.string.pl.modalAccountLogoutHeadline = 'Usunąć dane?';
z.string.pl.modalAccountLogoutOption = 'Usuń wszystkie informacje osobiste i historię rozmów na tym urządzeniu.';

z.string.pl.modalAccountNewDevicesSecondary = 'Zarządzaj urządzeniami';
z.string.pl.modalAccountNewDevicesHeadline = 'Twoje konto było ostatnio użyte:';
z.string.pl.modalAccountNewDevicesFrom = 'Z:';
z.string.pl.modalAccountNewDevicesMessage = 'Jeżeli nie rozpoznajesz tego, usuń urządzenie z listy i zmień swoje hasło.';

z.string.pl.modalAccountRemoveDeviceAction = 'Usuń urządzenie';
z.string.pl.modalAccountRemoveDeviceHeadline = 'Usuń {{device}}';
z.string.pl.modalAccountRemoveDeviceMessage = 'Aby usunąć to urządzenie wymagane jest hasło.';
z.string.pl.modalAccountRemoveDevicePlaceholder = 'Hasło';

z.string.pl.modalAssetTooLargeHeadline = 'Plik jest zbyt duży';
z.string.pl.modalAssetTooLargeMessage = 'Plik jest za duży. Maksymalny rozmiar pliku to {{number}}';

z.string.pl.modalAssetParallelUploadsHeadline = 'Za dużo plików naraz';
z.string.pl.modalAssetParallelUploadsMessage = 'Jednorazowo możesz wysłać maksymalnie {{number}} plików.';

z.string.pl.modalCallEmptyConversationHeadline = 'Brak rozmówcy';
z.string.pl.modalCallEmptyConversationMessage = 'Nikogo tutaj nie ma.';

z.string.pl.modalCallEmptyLogHeadline = 'Nie ma połączeń';

z.string.pl.modalCallNoGroupVideoHeadline = 'Grupowe połączenia video nie są możliwe';
z.string.pl.modalCallNoGroupVideoMessage = 'Grupowe połączenia wideo nie są możliwe.';

z.string.pl.modalCallNoMicrophoneAction = 'Powiedz mi jak';
z.string.pl.modalCallNoMicrophoneMessage = 'Aby wykonywać połączenia, Twoja przeglądarka musi mieć dostęp do mikrofonu.';
z.string.pl.modalCallNoMicrophoneHeadline = 'Nie można dzwonić bez mikrofonu';

z.string.pl.modalCallSecondIncomingAction = 'Odbierz';
z.string.pl.modalCallSecondIncomingHeadline = 'Odebrać połączenie?';
z.string.pl.modalCallSecondIncomingMessage = 'Bieżące połączenie zostanie zakończone.';

z.string.pl.modalCallSecondOngoingAction = 'Rozłącz';
z.string.pl.modalCallSecondOngoingHeadline = 'Zakończyć połączenie na innym urządzeniu?';
z.string.pl.modalCallSecondOngoingMessage = 'Tylko jedno połączenie na raz jest możliwe.';

z.string.pl.modalCallSecondOutgoingAction = 'Rozłącz';
z.string.pl.modalCallSecondOutgoingHeadline = 'Zakończyć bieżące połączenie?';
z.string.pl.modalCallSecondOutgoingMessage = 'Tylko jedno połączenie na raz jest możliwe.';

z.string.pl.modalConnectCancelAction = 'Tak';
z.string.pl.modalConnectCancelHeadline = 'Anuluj żądanie?';
z.string.pl.modalConnectCancelMessage = 'Usuń żądanie połączenia z {{user}}.';
z.string.pl.modalConnectCancelSecondary = 'Nie';

z.string.pl.modalConnectAcceptAction = 'Połącz';
z.string.pl.modalConnectAcceptHeadline = 'Zaakceptować?';
z.string.pl.modalConnectAcceptMessage = 'Ta akcja doda użytkownika {{user}} do listy kontaktów i rozpocznie rozmowę.';
z.string.pl.modalConnectAcceptSecondary = 'Ignoruj';

z.string.pl.modalConversationClearAction = 'Usuń';
z.string.pl.modalConversationClearHeadline = 'Usunąć zawartość?';
z.string.pl.modalConversationClearMessage = 'To wyczyści historię rozmowy na wszystkich Twoich urządzeniach.';
z.string.pl.modalConversationClearOption = 'Również opuść rozmowę';

z.string.pl.modalConversationDeleteMessageAction = 'Usuń';
z.string.pl.modalConversationDeleteMessageHeadline = 'Usuń tylko dla mnie?';
z.string.pl.modalConversationDeleteMessageMessage = 'Tego nie można cofnąć.';

z.string.pl.modalConversationDeleteMessageEveryoneAction = 'Usuń';
z.string.pl.modalConversationDeleteMessageEveryoneHeadline = 'Usunąć dla wszystkich?';
z.string.pl.modalConversationDeleteMessageEveryoneMessage = 'Tego nie można cofnąć.';

z.string.pl.modalConversationLeaveAction = 'Opuść';
z.string.pl.modalConversationLeaveHeadline = 'Opuścić rozmowę {{name}}?';
z.string.pl.modalConversationLeaveMessage = 'Nie będziesz mógł wysyłać ani odbierać wiadomości w tej rozmowie.';

z.string.pl.modalConversationMessageTooLongHeadline = 'Wiadomość jest zbyt długa';
z.string.pl.modalConversationMessageTooLongMessage = 'Możesz wysyłać wiadomości nie dłuższe niż {{number}} znaków.';

z.string.pl.modalConversationNewDeviceAction = 'Wyślij mimo wszystko';
z.string.pl.modalConversationNewDeviceHeadlineOne = '{{user}} zaczął korzystać z nowego urządzenia';
z.string.pl.modalConversationNewDeviceHeadlineMany = '{{users}} zaczęli korzystać z nowych urządzeń';
z.string.pl.modalConversationNewDeviceHeadlineYou = '{{user}} zaczął korzystać z nowego urządzenia';
z.string.pl.modalConversationNewDeviceIncomingCallAction = 'Zaakceptuj połączenie';
z.string.pl.modalConversationNewDeviceIncomingCallMessage = 'Czy nadal chcesz odebrać połączenie?';
z.string.pl.modalConversationNewDeviceMessage = 'Czy nadal chcesz wysłać wiadomości?';
z.string.pl.modalConversationNewDeviceOutgoingCallAction = 'Dzwoń mimo to';
z.string.pl.modalConversationNewDeviceOutgoingCallMessage = 'Czy nadal chcesz nawiązać połączenie?';

z.string.pl.modalConversationNotConnectedHeadline = 'Nikt nie został dodany do rozmowy';
z.string.pl.modalConversationNotConnectedMessageOne = '{{name}} nie chce być dodany do rozmowy.';
z.string.pl.modalConversationNotConnectedMessageMany = 'Jedna z osób, którą wybrałeś, nie chce być dodana do rozmowy.';

z.string.pl.modalConversationRemoveAction = 'Usuń';
z.string.pl.modalConversationRemoveHeadline = 'Usunąć?';
z.string.pl.modalConversationRemoveMessage = '{{user}} nie będzie mógł wysyłać, ani odbierać wiadomości w tej rozmowie.';

z.string.pl.modalConversationRemoveGuestsAction = 'Usuń gości';
z.string.pl.modalConversationRemoveGuestsHeadline = 'Wyłączyć dostęp dla gości?';

z.string.pl.modalConversationTooManyMembersHeadline = 'Zbyt wielu uczestników rozmowy';

z.string.pl.modalGifTooLargeMessage = 'Maksymalny rozmiar to {{number}} MB.';

z.string.pl.modalIntegrationUnavailableHeadline = 'Boty są obecnie niedostępne';
z.string.pl.modalIntegrationUnavailableMessage = 'Dziękujemy za zainteresowanie naszymi botami. Usługa jest obecnie zawieszona, ponieważ pracujemy nad następną wersją. Bądź na bieżąco.';

z.string.pl.modalPictureFileFormatHeadline = 'Nie można użyć tego obrazu';
z.string.pl.modalPictureFileFormatMessage = 'Proszę wybrać plik PNG lub JPEG.';

z.string.pl.modalPictureTooLargeHeadline = 'Wybrany obraz jest za duży';

z.string.pl.modalPictureTooSmallHeadline = 'Obrazek jest zbyt mały';

z.string.pl.modalImproveWireAction = 'Odbierz';
z.string.pl.modalImproveWireSecondary = 'Nie teraz';
z.string.pl.modalImproveWireHeadline = 'Pomóż nam ulepszyć Wire';

z.string.pl.modalServiceUnavailableHeadline = 'Dodanie usługi jest niemożliwe';

z.string.pl.modalSessionResetHeadline = 'Sesja została zresetowana';
z.string.pl.modalSessionResetMessage1 = 'Jeśli problem nie zostanie rozwiązany,';
z.string.pl.modalSessionResetMessageLink = 'kontakt';
z.string.pl.modalSessionResetMessage2 = 'nas.';

z.string.pl.modalUploadContactsAction = 'Spróbuj ponownie';
z.string.pl.modalUploadContactsMessage = 'Nie otrzymaliśmy Twoich informacji. Spróbuj ponownie zaimportować swoje kontakty.';

z.string.pl.modalUserBlockAction = 'Zablokuj';
z.string.pl.modalUserBlockHeadline = 'Zablokować {{user}}?';
z.string.pl.modalUserBlockMessage = '{{user}} nie będzie mógł się z Tobą skontaktować, ani dodać do rozmowy grupowej.';

z.string.pl.modalUserUnblockAction = 'Odblokuj';
z.string.pl.modalUserUnblockHeadline = 'Odblokować?';
z.string.pl.modalUserUnblockMessage = '{{user}} będzie mógł się z Tobą skontaktować oraz dodać do rozmowy grupowej.';

z.string.pl.connectionRequestConnect = 'Połącz';
z.string.pl.connectionRequestIgnore = 'Ignoruj';

z.string.pl.conversationGuestIndicator = 'Gość';
z.string.pl.userRemainingTimeHours = 'Zostało {{time}}h';
z.string.pl.userRemainingTimeMinutes = 'Zostało mniej, niż {{time}}min';

z.string.pl.conversationYouNominative = 'ty';
z.string.pl.conversationYouDative = 'ty';
z.string.pl.conversationYouAccusative = 'ty';

z.string.pl.conversationConnectionAccepted = 'Połączony';
z.string.pl.conversationConnectionBlocked = 'Zablokowano';
z.string.pl.conversationConnectionCancelRequest = 'Anuluj żądanie połączenia';
z.string.pl.conversationCreateTemporary = 'Dołączyłeś do konwersacji';
z.string.pl.conversationCreateWith = 'z {{users}}';
z.string.pl.conversationDeviceStartedUsingOne = ' rozpoczęto korzystanie';
z.string.pl.conversationDeviceStartedUsingMany = ' rozpoczęto korzystanie';
z.string.pl.conversationDeviceUnverified = ' %@ nie zweryfikował jednego z %@';
z.string.pl.conversationDeviceYourDevices = ' twoje urządzenia';
z.string.pl.conversationDeviceUserDevices = ' urządzenia użytkownika {{user}}';
z.string.pl.conversationDeviceNewDeviceOne = ' nowe urządzenie';
z.string.pl.conversationDeviceNewDeviceMany = ' nowe urządzenia';
z.string.pl.conversationDeviceNewPeopleJoinedVerify = ' sprawdzenie urządzenia';
z.string.pl.conversationJustNow = 'Przed chwilą';
z.string.pl.conversationLocationLink = 'Otwórz mapę';
z.string.pl.conversationMessageDelivered = 'Dostarczono';
z.string.pl.conversationRename = ' %@ zmienił nazwę konwersacji';
z.string.pl.conversationRenameYou = ' %@ zmienił nazwę konwersacji';
z.string.pl.conversationResume = 'Rozpoczął rozmowę z {{users}}';
z.string.pl.conversationPing = ' zaczepił/a';
z.string.pl.conversationPingYou = ' zaczepił/a';
z.string.pl.conversationToday = 'dzisiaj';
z.string.pl.conversationVoiceChannelDeactivate = ' połączono';
z.string.pl.conversationVoiceChannelDeactivateYou = ' połączono';
z.string.pl.conversationYesterday = 'Wczoraj';
z.string.pl.conversationUnableToDecrypt1 = 'wiadomość od {{user}} nie została dostarczona.';
z.string.pl.conversationUnableToDecrypt2 = 'Użytkownik {{user}} zmienił urządzenie. Wiadomość nie została dostarczona.';
z.string.pl.conversationUnableToDecryptLink = 'Dlaczego?';
z.string.pl.conversationUnableToDecryptErrorMessage = 'Błąd';
z.string.pl.conversationUnableToDecryptResetSession = 'Resetowanie sesji';
z.string.pl.conversationMissedMessages = 'Dość długo nie używałeś tego urządzenia. Niektóre wiadomości mogą nie być widoczne.';
z.string.pl.conversationAssetDownloading = 'Pobieranie…';
z.string.pl.conversationAssetUploadFailed = 'Błąd wysyłania';
z.string.pl.conversationPlaybackError = 'Nie można odtworzyć';
z.string.pl.conversationContextMenuCopy = 'Kopiuj';
z.string.pl.conversationContextMenuEdit = 'Edycja';
z.string.pl.conversationContextMenuDelete = 'Usuń dla mnie';
z.string.pl.conversationContextMenuDeleteEveryone = 'Usuń dla wszystkich';
z.string.pl.conversationContextMenuDownload = 'Pobierz';
z.string.pl.conversationContextMenuLike = 'Polub';
z.string.pl.conversationContextMenuUnlike = 'Przestań lubić';
z.string.pl.conversationDeleteTimestamp = 'Usunięty: {{date}}';
z.string.pl.conversationEditTimestamp = 'Edytowany: {{date}}';
z.string.pl.conversationLikesCaption = '{{number}} uczestników';
z.string.pl.conversationSendPastedFile = 'Wklejono obraz {{date}}';
z.string.pl.conversationSomeone = 'Ktoś';
z.string.pl.conversationTweetAuthor = ' na Twitterze';

z.string.pl.groupCreationPreferencesAction = 'Dalej';
z.string.pl.groupCreationParticipantsActionCreate = 'Zakończono';
z.string.pl.groupCreationParticipantsPlaceholder = 'Szukaj według nazwy';


z.string.pl.collectionShowAll = 'Pokaż wszystkie {{number}}';
z.string.pl.collectionSectionLinks = 'Linki';
z.string.pl.collectionSectionImages = 'Zdjęcia';
z.string.pl.collectionSectionFiles = 'Pliki';
z.string.pl.collectionSectionAudio = 'Wiadomości audio';

z.string.pl.fullsearchPlaceholder = 'Wyszukiwanie wiadomości';
z.string.pl.fullsearchNoResults = 'Brak wyników.';

z.string.pl.archiveHeader = 'Archiwizuj';

z.string.pl.conversationsAllArchived = 'Wszystko zarchiwizowane';
z.string.pl.conversationsContacts = 'Kontakty';
z.string.pl.conversationsConnectionRequestMany = '{{number}} osób oczekujących';
z.string.pl.conversationsConnectionRequestOne = '1 osoba czeka';
z.string.pl.conversationsEmptyConversation = 'Rozmowa grupowa';
z.string.pl.conversationsNoConversations = 'Brak jeszcze konwersacji';
z.string.pl.conversationsPopoverArchive = 'Archiwizuj';
z.string.pl.conversationsPopoverCancel = 'Anuluj żądanie';
z.string.pl.conversationsPopoverNotify = 'Włącz dźwięk';
z.string.pl.conversationsPopoverSilence = 'Wycisz';
z.string.pl.conversationsPopoverUnarchive = 'Przywróć z archiwum';

z.string.pl.conversationsSecondaryLineEphemeralMessage = 'Wysłał(a) ci wiadomość';
z.string.pl.conversationsSecondaryLinePeopleLeft = '{{number}} osoby/ób opuściły/o rozmowę';
z.string.pl.conversationsSecondaryLinePersonLeft = '{{user}} wyszedł';
z.string.pl.conversationsSecondaryLinePersonRemoved = '{{user}} został usunięty';
z.string.pl.conversationsSecondaryLinePeopleAdded = 'dodanych osób: {{user}}';
z.string.pl.conversationsSecondaryLinePersonAdded = '{{user}} został dodany';
z.string.pl.conversationsSecondaryLinePersonAddedYou = '{{user}} dodał Cię';
z.string.pl.conversationsSecondaryLineRenamed = '{{user}} zmieniono nazwę konwersacji';
z.string.pl.conversationsSecondaryLineYouLeft = 'Opuściłeś/aś';
z.string.pl.conversationsSecondaryLineYouWereRemoved = 'Zostałeś usunięty/Zostałaś usunięta';

z.string.pl.takeoverSub = 'Wybierz swoją unikalną nazwę w Wire.';
z.string.pl.takeoverLink = 'Więcej informacji';
z.string.pl.takeoverButtonChoose = 'Wybierz swój własny';
z.string.pl.takeoverButtonKeep = 'Zachowaj wybrany';

z.string.pl.inviteMetaKeyMac = 'Cmd';
z.string.pl.inviteMetaKeyPc = 'Ctrl';
z.string.pl.inviteHeadline = 'Zaproś innych do Wire';
z.string.pl.inviteMessage = 'Jestem na Wire. Odszukaj {{username}}, lub odwiedź get.wire.com.';
z.string.pl.inviteMessageNoEmail = 'Używam Wire. Wejdź na get.wire.com aby się ze mną połączyć.';

z.string.pl.extensionsBubbleButtonGif = 'Gif';

z.string.pl.extensionsGiphyButtonOk = 'Wyślij';
z.string.pl.extensionsGiphyButtonMore = 'Spróbuj użyć innego';
z.string.pl.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.pl.extensionsGiphyNoGifs = 'Ups, nie ma plików Gif';
z.string.pl.extensionsGiphyRandom = 'Losowa kolejność';

z.string.pl.addParticipantsConfirmLabel = 'Dodaj';
z.string.pl.addParticipantsSearchPlaceholder = 'Szukaj według nazwy';
z.string.pl.addParticipantsTabsPeople = 'Osoby';
z.string.pl.addParticipantsTabsServices = 'Usługi';

z.string.pl.conversationDetailsActionArchive = 'Archiwizuj';
z.string.pl.conversationDetailsActionCancelRequest = 'Anuluj żądanie';
z.string.pl.conversationDetailsActionDevices = 'Urządzenia';
z.string.pl.conversationDetailsActionNotifications = 'Powiadomienia';
z.string.pl.conversationDetailsGuestsOff = 'Wyłącz';
z.string.pl.conversationDetailsOptions = 'Opcje';
z.string.pl.conversationDetailsParticipantsServicesMany = 'Usługi';
z.string.pl.conversationDetailsParticipantsUsersMany = 'Osoby';
z.string.pl.conversationDetailsPeople = 'Osoby';
z.string.pl.conversationDetailsServices = 'Usługi';

z.string.pl.conversationParticipantsTitle = 'Osoby';
z.string.pl.conversationParticipantsSearchPlaceholder = 'Szukaj według nazwy';

z.string.pl.groupParticipantActionCancelRequest = 'Anuluj żądanie';
z.string.pl.groupParticipantActionDevices = 'Urządzenia';
z.string.pl.groupParticipantActionPending = 'W toku';
z.string.pl.groupParticipantActionSendRequest = 'Połącz';

z.string.pl.notificationSettingsTitle = 'Powiadomienia';

z.string.pl.participantDevicesDetailHeadline = 'Sprawdź, czy to odpowiada kluczowi widocznemu na {{html1}}{{user}} urządzenia {{html2}}.';
z.string.pl.participantDevicesDetailHowTo = 'Jak to zrobić?';
z.string.pl.participantDevicesDetailResetSession = 'Resetowanie sesji';
z.string.pl.participantDevicesDetailShowMyDevice = 'Pokaż kody zabezpieczeń moich urządzeń';
z.string.pl.participantDevicesDetailVerify = 'Zweryfikowano';

z.string.pl.participantDevicesHeader = 'Urządzenia';
z.string.pl.participantDevicesHeadline = 'Wire nadaje każdemu urządzeniu unikatowy odcisk palca. Porównaj go z listą urządzeń użytkownika {{user}} i sprawdź swoje rozmowy.';
z.string.pl.participantDevicesLearnMore = 'Więcej informacji';
z.string.pl.participantDevicesWhyVerify = 'Dlaczego weryfikować konwersacje?';
z.string.pl.participantDevicesOutdatedClientMessage = '{{user}} używa starszej wersji Wire. Brak urządzeń do wyświetlenia.';

z.string.pl.participantDevicesSelfAllDevices = 'Pokaż wszystkie moje urządzenia';
z.string.pl.participantDevicesSelfFingerprint = 'Odcisk palca urządzenia';

z.string.pl.userProfileButtonConnect = 'Połącz';
z.string.pl.userProfileButtonIgnore = 'Ignoruj';
z.string.pl.userProfileButtonUnblock = 'Odblokuj';

z.string.pl.preferencesAbout = 'O programie';
z.string.pl.preferencesAccount = 'Konto';
z.string.pl.preferencesAV = 'Dźwięk / Wideo';
z.string.pl.preferencesDeviceDetails = 'Szczegóły Urządzenia';
z.string.pl.preferencesDevices = 'Urządzenia';
z.string.pl.preferencesHeadline = 'Ustawienia';
z.string.pl.preferencesOptions = 'Opcje';

z.string.pl.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.pl.preferencesAboutPrivacyPolicy = 'Polityka prywatności';
z.string.pl.preferencesAboutSupport = 'Wsparcie';
z.string.pl.preferencesAboutSupportWebsite = 'Witryna pomocy technicznej';
z.string.pl.preferencesAboutSupportContact = 'Kontakt z pomocą techniczną';
z.string.pl.preferencesAboutTermsOfUse = 'Regulamin';
z.string.pl.preferencesAboutVersion = 'Wersja {{version}}';
z.string.pl.preferencesAboutWebsite = 'Strona internetowa Wire';

z.string.pl.preferencesAccountCreateTeam = 'Utwórz nowy zespół';
z.string.pl.preferencesAccountDelete = 'Usuń konto';
z.string.pl.preferencesAccountLogOut = 'Wyloguj się';
z.string.pl.preferencesAccountManageTeam = 'Zarządzaj zespołem';
z.string.pl.preferencesAccountResetPassword = 'Zresetuj hasło';
z.string.pl.preferencesAccountTeam = 'w {{name}}';
z.string.pl.preferencesAccountUsernamePlaceholder = 'Twoje pełne imię i nazwisko';
z.string.pl.preferencesAccountUsernameHint = 'Co najmniej 2 znaki. Tylko a-z, 0-9, _.';
z.string.pl.preferencesAccountUsernameAvailable = '&Dostępny(a)';
z.string.pl.preferencesAccountUsernameErrorTaken = 'Jest już w użyciu';

z.string.pl.preferencesAVCamera = 'Aparat';
z.string.pl.preferencesAVMicrophone = 'Mikrofon';
z.string.pl.preferencesAVPermissionDetail = 'Włącz w Preferencjach Twojej przeglądarki';
z.string.pl.preferencesAVSpeakers = 'Głośniki';

z.string.pl.preferencesDevicesActivatedOn = 'Aktywowano {{date}}';
z.string.pl.preferencesDevicesActive = 'Aktywne';
z.string.pl.preferencesDevicesActiveDetail = 'Jeśli nie rozpoznajesz urządzenia poniżej, usuń je i zresetuj hasło.';
z.string.pl.preferencesDevicesCurrent = 'Aktualny';
z.string.pl.preferencesDevicesFingerprint = 'Unikalny odcisk palca';
z.string.pl.preferencesDevicesFingerprintDetail = 'Wire daje każdemu urządzeniowi unikalny odcisk palca. Porównaj i sprawdź swoje urządzenia oraz konwersacje.';
z.string.pl.preferencesDevicesId = 'ID: ';
z.string.pl.preferencesDevicesRemoveCancel = 'Anuluj';
z.string.pl.preferencesDevicesRemoveDetail = 'Usuń urządzenie, jeśli przestałeś je używać. Będziesz natychmiast wylogowany z tego urządzenia.';
z.string.pl.preferencesDevicesSessionConfirmation = 'Sesja została zresetowana.';
z.string.pl.preferencesDevicesSessionDetail = 'Jeśli odciski palca nie pasują, zresetuj sesję, aby wygenerować nowe klucze po obu stronach.';
z.string.pl.preferencesDevicesSessionReset = 'Resetowanie sesji';
z.string.pl.preferencesDevicesSessionOngoing = 'Resetowanie sesji…';
z.string.pl.preferencesDevicesVerification = 'Zweryfikowano';

z.string.pl.preferencesOptionsAudio = 'Alarm dźwiękowy';
z.string.pl.preferencesOptionsAudioAll = 'Wszystko';
z.string.pl.preferencesOptionsAudioAllDetail = 'Wszystkie dźwięki';
z.string.pl.preferencesOptionsAudioNone = 'Żaden';
z.string.pl.preferencesOptionsAudioNoneDetail = 'Csiiii!';
z.string.pl.preferencesOptionsAudioSome = 'Niektóre';
z.string.pl.preferencesOptionsAudioSomeDetail = 'Pingi i połączenia';
z.string.pl.preferencesOptionsContacts = 'Kontakty';
z.string.pl.preferencesOptionsContactsGmail = 'Import z Gmail';
z.string.pl.preferencesOptionsContactsMacos = 'Import z Kontaktów';
z.string.pl.preferencesOptionsContactsDetail = 'Wykorzystujemy Twoje dane kontaktowe do łączenia Cię z innymi. Wszystkie informacje są anonimowe i nie dzielimy ich z nikim innym.';
z.string.pl.preferencesOptionsPopular = 'Różne';
z.string.pl.preferencesOptionsEmojiReplaceCheckbox = 'Zastępuj tekstowe emotikony ikonkami';
z.string.pl.preferencesOptionsPreviewsSendCheckbox = 'Twórz podglądy wysyłanych linków';
z.string.pl.preferencesOptionsPreviewsSendDetail = 'Podglądy linków otrzymanych od innych osób mogą być nadal wyświetlane.';
z.string.pl.preferencesOptionsNotifications = 'Powiadomienia';
z.string.pl.preferencesOptionsNotificationsNone = 'Wyłącz';
z.string.pl.preferencesOptionsNotificationsObfuscate = 'Ukryj szczegóły';
z.string.pl.preferencesOptionsNotificationsObfuscateMessage = 'Pokaż nadawcę';
z.string.pl.preferencesOptionsNotificationsOn = 'Pokaż nadawcę i wiadomości';

z.string.pl.backupImportGenericErrorHeadline = 'Coś poszło nie tak';
z.string.pl.backupCancel = 'Anuluj';

z.string.pl.searchConnect = 'Połącz';
z.string.pl.searchConnections = 'Połączenia';
z.string.pl.searchContacts = 'Kontakty';
z.string.pl.searchCreateGroup = 'Stwórz grupę';
z.string.pl.searchGroups = 'Grupy';
z.string.pl.searchPeople = 'Osoby';
z.string.pl.searchPlaceholder = 'Szukaj według nazwy lub nazwy użytkownika';
z.string.pl.searchServicePlaceholder = 'Szukaj według nazwy';
z.string.pl.searchServices = 'Usługi';
z.string.pl.searchTeamGroups = 'Grupowe rozmowy';
z.string.pl.searchTeamMembers = 'Członkowie zespołu';
z.string.pl.searchTopPeople = 'Osoby';
z.string.pl.searchTrySearch = 'Znajdź osoby według nazwy lub nazwy użytkownika';
z.string.pl.searchNoContactsOnWire = 'Nie masz dodanych żadnych kontaktów Spróbuj wyszukać osoby według nazwy lub nazwy użytkownika.';
z.string.pl.searchOthers = 'Połącz';

z.string.pl.searchInvite = 'Zaproś innych do Wire';
z.string.pl.searchInviteDetail = 'Udostępnianie kontaktów pomaga połączyć się z innymi. Wszystkie informacje są anonimowe i nie udostępniamy ich nikomu.';
z.string.pl.searchInviteButtonContacts = 'Z kontaktów';
z.string.pl.searchInviteButtonGmail = 'Z Gmaila';
z.string.pl.searchInviteHeadline = 'Zaproś znajomych';
z.string.pl.searchInviteShare = 'Udostępnij kontakty';

z.string.pl.searchListEveryoneParticipates = 'Wszyscy, z którymi masz połączenie są już w tej konwersacji.';
z.string.pl.searchListNoMatches = 'Brak wyników. Spróbuj wprowadzić inną nazwę.';

z.string.pl.temporaryGuestCta = 'Utwórz konto';

z.string.pl.uploadGoogleHeadline = 'Znajdź osoby do rozmowy.';
z.string.pl.uploadGoogleMessage = 'Wykorzystujemy Twoje dane kontaktowe do łączenia Cię z innymi. Wszystkie informacje są anonimowe i nie dzielimy ich z nikim innym.';

z.string.pl.warningCallUnsupportedIncoming = 'Dzwoni {{user}}. Twoja przeglądarka nie obsługuje rozmów.';
z.string.pl.warningCallUnsupportedOutgoing = 'Nie możesz zadzwonić, ponieważ Twoja przeglądarka nie obsługuje rozmów.';
z.string.pl.warningCallIssues = 'Ta wersja Wire nie może brać udziału w rozmowie. Proszę użyj';
z.string.pl.warningCallUpgradeBrowser = 'Uaktualnij Google Chrome aby zadzwonić.';
z.string.pl.warningConnectivityConnectionLost = 'Próbuje się połączyć. Wire może nie być w stanie dostarczyć wiadomości.';
z.string.pl.warningConnectivityNoInternet = 'Brak internetu. Wire nie będzie w stanie wysyłać i odbierać wiadomości.';
z.string.pl.warningLearnMore = 'Więcej informacji';
z.string.pl.warningLifecycleUpdate = 'Nowa wersja "%@" już dostępna.';
z.string.pl.warningLifecycleUpdateNotes = 'Co nowego';
z.string.pl.warningLifecycleUpdateLink = 'Aktualizuj teraz';
z.string.pl.warningNotFoundCamera = 'Nie możesz zadzwonić ponieważ Twój komputer nie ma kamery.';
z.string.pl.warningNotFoundMicrophone = 'Nie możesz zadzwonić ponieważ Twój komputer nie ma mikrofonu.';
z.string.pl.warningPermissionDeniedCamera = 'Nie możesz zadzwonić ponieważ przeglądarka nie ma dostępu do kamery.';
z.string.pl.warningPermissionDeniedMicrophone = 'Nie możesz zadzwonić ponieważ przeglądarka nie ma dostępu do mikrofonu.';
z.string.pl.warningPermissionDeniedScreen = 'Twoja przeglądarka potrzebuje pozwolenia aby pokazać pulpit.';
z.string.pl.warningPermissionRequestCamera = '{{icon}} Zezwól na dostęp do aparatu';
z.string.pl.warningPermissionRequestMicrophone = '{{icon}} Zezwól na dostęp do mikrofonu';
z.string.pl.warningPermissionRequestNotification = '{{icon}} Zezwól na powiadomienia';
z.string.pl.warningPermissionRequestScreen = '{{icon}} zezwól na dostęp do ekranu';

z.string.pl.userAvailabilityAvailable = '&Dostępny(a)';
z.string.pl.userAvailabilityNone = 'Żaden';

z.string.pl.notificationAssetAdd = 'Udostępnił obrazek';
z.string.pl.notificationConnectionAccepted = 'Zaakceptowane żądania połączenia';
z.string.pl.notificationConnectionConnected = 'Jesteś już połączony';
z.string.pl.notificationConnectionRequest = '%@ chce się połączyć';
z.string.pl.notificationConversationCreate = '{{user}} rozpoczął rozmowę';
z.string.pl.notificationConversationRename = '{{user}} zmienił nazwę konwersacji na {{name}}';
z.string.pl.notificationMemberJoinMany = '{{user}} dodał(a) {{number}} nowych osób do rozmowy';
z.string.pl.notificationMemberJoinOne = '{{user1}} dodał(a) {{user2}} do rozmowy';
z.string.pl.notificationMemberLeaveRemovedYou = '{{user}} usunął cię z rozmowy';
z.string.pl.notificationObfuscated = 'Wysłał(a) ci wiadomość';
z.string.pl.notificationObfuscatedTitle = 'Ktoś';
z.string.pl.notificationPing = 'Zaczepił/a';
z.string.pl.notificationReaction = '{{reaction}} na Twoją wiadomość';
z.string.pl.notificationSharedAudio = 'Udostępnij wiadomość audio';
z.string.pl.notificationSharedFile = 'Udostępnił/a plik';
z.string.pl.notificationSharedLocation = 'Udostępniana lokalizacja';
z.string.pl.notificationSharedVideo = 'Udostępniane wideo';
z.string.pl.notificationVoiceChannelActivate = 'Łączenie';
z.string.pl.notificationVoiceChannelDeactivate = 'Dzwonił';

z.string.pl.tooltipConversationAllVerified = 'Wszystkie odciski palców są zweryfikowane';
z.string.pl.tooltipConversationCall = 'Zadzwoń';
z.string.pl.tooltipConversationEphemeral = 'Wiadomość tymczasowa';
z.string.pl.tooltipConversationFile = 'Dodaj plik';
z.string.pl.tooltipConversationInputPlaceholder = 'Wpisz wiadomość';
z.string.pl.tooltipConversationPeople = 'Użytkownicy ({{shortcut}})';
z.string.pl.tooltipConversationPicture = 'Dodaj zdjęcie';
z.string.pl.tooltipConversationPing = 'Zaczep ({{shortcut}})';
z.string.pl.tooltipConversationSearch = 'Wyszukaj';
z.string.pl.tooltipConversationVideoCall = 'Połączenie video';

z.string.pl.tooltipConversationsArchive = 'Archiwum ({{shortcut}})';
z.string.pl.tooltipConversationsArchived = 'Pokaż archiwum ({{number}})';
z.string.pl.tooltipConversationsMore = 'Więcej';
z.string.pl.tooltipConversationsNotify = 'Wyłącz wyciszenie ({{shortcut}})';
z.string.pl.tooltipConversationsPreferences = 'Ustawienia';
z.string.pl.tooltipConversationsSilence = 'Wycisz ({{shortcut}})';
z.string.pl.tooltipConversationsStart = 'Zacznij rozmowę ({{shortcut}})';

z.string.pl.tooltipConversationDetailsRename = 'Zmień nazwę konwersacji';

z.string.pl.tooltipPreferencesContactsGmail = 'Zaloguj się do swojego konta Gmail i udostępniaj kontakty';
z.string.pl.tooltipPreferencesContactsMacos = 'Udostępnij wszystkie kontakty z aplikacji Kontakty macOS';
z.string.pl.tooltipPreferencesPassword = 'Otwórz stronę resetowania hasła';
z.string.pl.tooltipPreferencesPicture = 'Zmień swój obraz…';
z.string.pl.tooltipPreferencesRename = 'Zmień swoją nazwę';

z.string.pl.tooltipSearchClose = 'Zamknij (Esc)';

z.string.pl.initReceivedSelfUser = 'Cześć, {{user}}.';
z.string.pl.initValidatedClient = 'Pobieranie Twoich kontaktów i rozmów';
z.string.pl.initReceivedUserData = 'Sprawdzanie nowych wiadomości';
z.string.pl.initDecryption = 'Odszyfrowywanie wiadomości';
z.string.pl.initEvents = 'Ładowanie wiadomości';
z.string.pl.initUpdatedFromNotifications = 'Prawie skończone - miłego korzystania z Wire';
z.string.pl.initProgress = ' — {{number1}} z {{number2}}';

z.string.pl.ephemeralUnitsNone = 'Wyłącz';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.pt.wireMacos = 'Wire para macOS';
z.string.pt.wireWindows = 'Wire para Windows';
z.string.pt.wireLinux = 'Wire para Linux';
z.string.pt.nonexistentUser = 'Utilizador eliminado';
z.string.pt.and = 'e';

z.string.pt.authAccountCountryCode = 'Código de País';
z.string.pt.authAccountPasswordForgot = 'Esqueci a palavra-passe';
z.string.pt.authAccountPublicComputer = 'Este computador é publico';
z.string.pt.authAccountSignIn = 'Iniciar sessão';
z.string.pt.authAccountSignInPhone = 'Telefone';

z.string.pt.authBlockedCookies = 'Ative os cookies para iniciar sessão no Wire.';
z.string.pt.authBlockedDatabase = 'O Wire necessita de acesso ao armazenamento local para mostrar as suas mensagens. O armazenamento local não está disponível no modo privado.';
z.string.pt.authBlockedTabs = 'O Wire já está aberto noutro separador.';

z.string.pt.authVerifyAccountAdd = 'Adicionar';
z.string.pt.authVerifyAccountDetail = 'Permite que use o Wire em vários dispositivos.';
z.string.pt.authVerifyAccountHeadline = 'Adicionar o endereço de e-mail e palavra-passe.';
z.string.pt.authVerifyAccountLogout = 'Terminar sessão';
z.string.pt.authVerifyCodeDescription = 'Introduza o código de verificação que foi enviado para o {{number}}.';
z.string.pt.authVerifyCodeResend = 'Não chegou o código?';
z.string.pt.authVerifyCodeResendDetail = 'Reenviar';
z.string.pt.authVerifyCodeResendTimer = 'Pode solicitar um novo código {{expiration}}.';
z.string.pt.authVerifyCodeChangePhone = 'Alterar o número de telefone';
z.string.pt.authVerifyPasswordHeadline = 'Insira a sua palavra-passe';

z.string.pt.authLimitDevicesHeadline = 'Dispositivos';
z.string.pt.authLimitDescription = 'Remova um dos seus outros dispositivos para começar a usar o Wire neste.';
z.string.pt.authLimitButtonManage = 'Gerir dispositivos';
z.string.pt.authLimitButtonSignOut = 'Terminar sessão';
z.string.pt.authLimitDevicesCurrent = '(Atual)';

z.string.pt.authHistoryHeadline = 'É a primeira vez que está a usar o Wire neste dispositivo.';
z.string.pt.authHistoryDescription = 'Por razões de privacidade, o seu histórico de conversa não será mostrado aqui.';
z.string.pt.authHistoryReuseHeadline = 'Você já usou o Wire neste dispositivo.';
z.string.pt.authHistoryReuseDescription = 'As mensagens entretanto enviadas não aparecerão aqui.';
z.string.pt.authHistoryButton = 'OK';

z.string.pt.authPostedResend = 'Reenviar para {{email}}';
z.string.pt.authPostedResendAction = 'Não chegou a mensagem?';
z.string.pt.authPostedResendDetail = 'Verifique sua caixa de correio eletrónico e siga as instruções.';
z.string.pt.authPostedResendHeadline = 'Recebeu email.';

z.string.pt.authPlaceholderEmail = 'E-mail';
z.string.pt.authPlaceholderPasswordPut = 'Palavra-passe';
z.string.pt.authPlaceholderPasswordSet = 'Palavra-passe (pelo menos 8 caracteres)';
z.string.pt.authPlaceholderPhone = 'Telefone';

z.string.pt.authErrorCode = 'Código inválido';
z.string.pt.authErrorCountryCodeInvalid = 'Código de País Inválido';
z.string.pt.authErrorEmailExists = 'O endereço de correio eletrónico já está a ser utilizado';
z.string.pt.authErrorEmailForbidden = 'Este endereço de e-mail não é permitido.';
z.string.pt.authErrorEmailMalformed = 'Por favor, introduza um endereço de email válido.';
z.string.pt.authErrorEmailMissing = 'Por favor insera um endereço de email.';
z.string.pt.authErrorMisc = 'Problemas com a ligação. Tente de novo.';
z.string.pt.authErrorNameShort = 'Introduza um nome com pelo menos 2 caracteres';
z.string.pt.authErrorOffline = 'Sem ligação à Internet';
z.string.pt.authErrorPasswordShort = 'Escolha uma palavra-passe com pelo menos 8 caracteres.';
z.string.pt.authErrorPasswordWrong = 'Palavra-passe incorreta. Por favor, tente de novo.';
z.string.pt.authErrorPending = 'A conta ainda não está verificada';
z.string.pt.authErrorPhoneNumberBudget = 'Iniciou sessão demasiadas vezes. Tente novamente mais tarde.';
z.string.pt.authErrorPhoneNumberForbidden = 'Este numero de telefone não é permitido.';
z.string.pt.authErrorPhoneNumberInvalid = 'Número de telefone inválido';
z.string.pt.authErrorPhoneNumberUnknown = 'Número de telefone desconhecido';
z.string.pt.authErrorSuspended = 'Esta conta já não está autorizada a iniciar sessão.';
z.string.pt.authErrorSignIn = 'Por favor verifique os seus detalhes e tente de novo.';

z.string.pt.callStateOutgoing = 'A tocar…';
z.string.pt.callStateConnecting = 'A ligar…';
z.string.pt.callStateIncoming = 'A chamar…';
z.string.pt.callDecline = 'Rejeitar';
z.string.pt.callAccept = 'Aceitar';
z.string.pt.callJoin = 'Juntar-se';
z.string.pt.callChooseSharedScreen = 'Escolher um ecrã para partilhar';
z.string.pt.callParticipants = '{{number}} na chamada';

z.string.pt.videoCallOverlayMute = 'Desativar som';
z.string.pt.videoCallOverlayHangUp = 'Desligar';

z.string.pt.modalAcknowledgeAction = 'Ok';
z.string.pt.modalConfirmSecondary = 'Cancelar';
z.string.pt.modalOptionSecondary = 'Cancelar';

z.string.pt.modalAccountCreateAction = 'OK';

z.string.pt.modalAccountDeletionAction = 'Eliminar';
z.string.pt.modalAccountDeletionHeadline = 'Eliminar conta';
z.string.pt.modalAccountDeletionMessage = 'Será enviada uma mensagem ou SMS. Siga a ligação para apagar a conta de forma permanente.';

z.string.pt.modalAccountLeaveGuestRoomAction = 'Sair';

z.string.pt.modalAccountLogoutAction = 'Terminar sessão';
z.string.pt.modalAccountLogoutHeadline = 'Limpar Dados?';
z.string.pt.modalAccountLogoutOption = 'Eliminar a sua informação pessoal e conversas neste dispositivo.';

z.string.pt.modalAccountNewDevicesSecondary = 'Gerir dispositivos';
z.string.pt.modalAccountNewDevicesHeadline = 'A sua conta foi usada em:';
z.string.pt.modalAccountNewDevicesFrom = 'De:';
z.string.pt.modalAccountNewDevicesMessage = 'Se não fez isto, remova o dispositivo da conta e altere a sua palavra-passe.';

z.string.pt.modalAccountRemoveDeviceAction = 'Remover o dispositivo';
z.string.pt.modalAccountRemoveDeviceHeadline = 'Remover "{{device}}"';
z.string.pt.modalAccountRemoveDeviceMessage = 'A palavra-passe é necessária para remover o dispositivo.';
z.string.pt.modalAccountRemoveDevicePlaceholder = 'Palavra-passe';

z.string.pt.modalAssetTooLargeMessage = 'Pode enviar até {{number}} ficheiros';

z.string.pt.modalAssetParallelUploadsMessage = 'Pode enviar até {{number}} ficheiros de cada vez.';

z.string.pt.modalCallEmptyConversationHeadline = 'Ninguém para ligar';
z.string.pt.modalCallEmptyConversationMessage = 'Não há mais ninguém aqui.';

z.string.pt.modalCallNoGroupVideoHeadline = 'Não há chamadas de vídeo em grupos';
z.string.pt.modalCallNoGroupVideoMessage = 'As chamadas de vídeo não estão disponíveis em conversas do grupo.';

z.string.pt.modalCallNoMicrophoneAction = 'Diga-me agora';
z.string.pt.modalCallNoMicrophoneMessage = 'Seu navegador precisa de aceder ao microfone para fazer chamadas.';
z.string.pt.modalCallNoMicrophoneHeadline = 'Não é possível telefonar sem microfone';

z.string.pt.modalCallSecondIncomingAction = 'Atender';
z.string.pt.modalCallSecondIncomingHeadline = 'Atender a chamada?';
z.string.pt.modalCallSecondIncomingMessage = 'Sua chamada atual vai acabar.';

z.string.pt.modalCallSecondOngoingAction = 'Desligar';
z.string.pt.modalCallSecondOngoingHeadline = 'Desligar a chamada noutro dispositivo?';
z.string.pt.modalCallSecondOngoingMessage = 'Só pode fazer uma chamada de cada vez.';

z.string.pt.modalCallSecondOutgoingAction = 'Desligar';
z.string.pt.modalCallSecondOutgoingHeadline = 'Desligar a chamada atual?';
z.string.pt.modalCallSecondOutgoingMessage = 'Só pode fazer uma chamada de cada vez.';

z.string.pt.modalConnectCancelAction = 'Sim';
z.string.pt.modalConnectCancelHeadline = 'Cancelar pedido?';
z.string.pt.modalConnectCancelMessage = 'Remover o pedido de ligação a {{user}}.';
z.string.pt.modalConnectCancelSecondary = 'Não';

z.string.pt.modalConnectAcceptAction = 'Ligar';
z.string.pt.modalConnectAcceptHeadline = 'Aceitar?';
z.string.pt.modalConnectAcceptMessage = 'Isto irá ligá-lo e criar uma conversa com {{user}}.';
z.string.pt.modalConnectAcceptSecondary = 'Ignorar';

z.string.pt.modalConversationClearAction = 'Eliminar';
z.string.pt.modalConversationClearHeadline = 'Apagar conteúdo?';
z.string.pt.modalConversationClearOption = 'Também abandona a conversa';

z.string.pt.modalConversationDeleteMessageAction = 'Eliminar';
z.string.pt.modalConversationDeleteMessageHeadline = 'Eliminar apenas para mim?';
z.string.pt.modalConversationDeleteMessageMessage = 'Não pode ser desfeito.';

z.string.pt.modalConversationDeleteMessageEveryoneAction = 'Eliminar';
z.string.pt.modalConversationDeleteMessageEveryoneHeadline = 'Eliminar para todos?';
z.string.pt.modalConversationDeleteMessageEveryoneMessage = 'Não pode ser desfeito.';

z.string.pt.modalConversationLeaveAction = 'Sair';
z.string.pt.modalConversationLeaveMessage = 'Não será capaz de enviar ou receber mensagens nesta conversa.';

z.string.pt.modalConversationMessageTooLongHeadline = 'A mensagem é demasiado longa';
z.string.pt.modalConversationMessageTooLongMessage = 'Pode enviar mensagens com o máximo de {{number}} caracteres.';

z.string.pt.modalConversationNewDeviceHeadlineOne = '{{user}} começou a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceHeadlineMany = '{{users}} começaram a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceHeadlineYou = '{{user}} começou a usar um novo dispositivo';
z.string.pt.modalConversationNewDeviceIncomingCallAction = 'Aceitar chamada';
z.string.pt.modalConversationNewDeviceIncomingCallMessage = 'Ainda quer aceitar a chamada?';
z.string.pt.modalConversationNewDeviceMessage = 'Ainda quer enviar as suas mensagens?';
z.string.pt.modalConversationNewDeviceOutgoingCallAction = 'Telefonar assim mesmo';
z.string.pt.modalConversationNewDeviceOutgoingCallMessage = 'Ainda quer fazer a chamada?';

z.string.pt.modalConversationNotConnectedHeadline = 'Ninguém foi adicionado à conversa';
z.string.pt.modalConversationNotConnectedMessageOne = '{{name}} não quer ser adicionado a qualquer conversa.';
z.string.pt.modalConversationNotConnectedMessageMany = 'Uma das pessoas selecionadas não quer ser adicionada a qualquer conversa.';

z.string.pt.modalConversationRemoveAction = 'Remover';
z.string.pt.modalConversationRemoveHeadline = 'Remover?';
z.string.pt.modalConversationRemoveMessage = '{{user}} não será capaz de enviar ou receber mensagens nesta conversa.';

z.string.pt.modalConversationRemoveGuestsAction = 'Remover';

z.string.pt.modalConversationTooManyMembersHeadline = 'Casa cheia';

z.string.pt.modalIntegrationUnavailableHeadline = 'Atualmente os "bots" não estão disponíveis';
z.string.pt.modalIntegrationUnavailableMessage = 'Obrigado pelo seu interesse nos "bots". Atualmente o serviço está suspenso enquanto preparamos a nova versão. Fique atento.';


z.string.pt.modalImproveWireAction = 'Aceitar';
z.string.pt.modalImproveWireSecondary = 'Não';

z.string.pt.modalSessionResetHeadline = 'A sessão foi reposta';
z.string.pt.modalSessionResetMessage1 = 'Se o problema não está resolvido,';
z.string.pt.modalSessionResetMessageLink = 'contacto';
z.string.pt.modalSessionResetMessage2 = 'nós.';

z.string.pt.modalUploadContactsAction = 'Tente de novo';
z.string.pt.modalUploadContactsMessage = 'Não recebemos a sua informação. Por favor, tente importar seus contactos de novo.';

z.string.pt.modalUserBlockAction = 'Bloquear';
z.string.pt.modalUserBlockHeadline = 'Bloquear {{user}}?';
z.string.pt.modalUserBlockMessage = '{{user}} não será capaz de o contactar ou adicioná-lo para conversas em grupo.';

z.string.pt.modalUserUnblockAction = 'Desbloquear';
z.string.pt.modalUserUnblockHeadline = 'Desbloquear?';
z.string.pt.modalUserUnblockMessage = '{{user}} será capaz de o contactar e adicioná-lo para conversas em grupo.';

z.string.pt.connectionRequestConnect = 'Ligar';
z.string.pt.connectionRequestIgnore = 'Ignorar';

z.string.pt.conversationGuestIndicator = 'Convidado';

z.string.pt.conversationYouNominative = 'você';
z.string.pt.conversationYouDative = 'você';
z.string.pt.conversationYouAccusative = 'você';

z.string.pt.conversationConnectionAccepted = 'Ligado';
z.string.pt.conversationConnectionBlocked = 'Bloqueado';
z.string.pt.conversationConnectionCancelRequest = 'Cancelar pedido de ligação';
z.string.pt.conversationDeviceStartedUsingOne = ' começou a usar';
z.string.pt.conversationDeviceStartedUsingMany = ' começou a usar';
z.string.pt.conversationDeviceUnverified = ' retirou a verificação de um de';
z.string.pt.conversationDeviceYourDevices = ' seus dispositivos';
z.string.pt.conversationDeviceUserDevices = ' dispositivos de {{user}}';
z.string.pt.conversationDeviceNewDeviceOne = ' novo dispositivo';
z.string.pt.conversationDeviceNewDeviceMany = ' novos dispositivos';
z.string.pt.conversationDeviceNewPeopleJoinedVerify = ' verificar dispositivos';
z.string.pt.conversationJustNow = 'Agora mesmo';
z.string.pt.conversationLocationLink = 'Abrir Mapa';
z.string.pt.conversationMessageDelivered = 'Entregue';
z.string.pt.conversationRename = ' renomeou a conversa';
z.string.pt.conversationRenameYou = ' renomeou a conversa';
z.string.pt.conversationResume = 'Iniciar uma conversa com {{users}}';
z.string.pt.conversationPing = ' pingou';
z.string.pt.conversationPingYou = ' pingou';
z.string.pt.conversationToday = 'hoje';
z.string.pt.conversationVoiceChannelDeactivate = ' ligou';
z.string.pt.conversationVoiceChannelDeactivateYou = ' ligou';
z.string.pt.conversationYesterday = 'Ontem';
z.string.pt.conversationUnableToDecrypt1 = 'não foi recebida uma mensagem de {{user}}.';
z.string.pt.conversationUnableToDecrypt2 = 'A identidade do dispositivo de {{user}} foi alterada. A mensagem não foi entregue.';
z.string.pt.conversationUnableToDecryptLink = 'Porquê?';
z.string.pt.conversationUnableToDecryptErrorMessage = 'Erro';
z.string.pt.conversationUnableToDecryptResetSession = 'Redefinir sessão';
z.string.pt.conversationMissedMessages = 'Não usou este dispositivo durante algum tempo. Algumas mensagens podem não ser mostradas.';
z.string.pt.conversationAssetDownloading = 'A descarregar…';
z.string.pt.conversationAssetUploadFailed = 'O carregamento falhou';
z.string.pt.conversationPlaybackError = 'Incapaz de reproduzir';
z.string.pt.conversationContextMenuCopy = 'Copiar';
z.string.pt.conversationContextMenuEdit = 'Editar';
z.string.pt.conversationContextMenuDelete = 'Eliminar para mim';
z.string.pt.conversationContextMenuDeleteEveryone = 'Eliminar para todos';
z.string.pt.conversationContextMenuDownload = 'Descarregar';
z.string.pt.conversationContextMenuLike = 'Gosto';
z.string.pt.conversationContextMenuUnlike = 'Não gosto';
z.string.pt.conversationDeleteTimestamp = 'Eliminado em {{date}}';
z.string.pt.conversationEditTimestamp = 'Editado em {{date}}';
z.string.pt.conversationLikesCaption = '{{number}} pessoas';
z.string.pt.conversationSendPastedFile = 'Imagem colada em {{date}}';
z.string.pt.conversationSomeone = 'Alguém';
z.string.pt.conversationTweetAuthor = ' no Twitter';

z.string.pt.groupCreationPreferencesAction = 'Seguinte';
z.string.pt.groupCreationParticipantsActionCreate = 'Pronto';
z.string.pt.groupCreationParticipantsPlaceholder = 'Pesquisar por nome';


z.string.pt.collectionShowAll = 'Mostrar todos os {{number}}';
z.string.pt.collectionSectionLinks = 'Ligações';
z.string.pt.collectionSectionImages = 'Fotografias';
z.string.pt.collectionSectionFiles = 'Ficheiros';
z.string.pt.collectionSectionAudio = 'Mensagens de áudio';

z.string.pt.fullsearchPlaceholder = 'Procurar mensagens de texto';
z.string.pt.fullsearchNoResults = 'Sem resultados.';

z.string.pt.archiveHeader = 'Arquivar';

z.string.pt.conversationsAllArchived = 'Foi tudo arquivado';
z.string.pt.conversationsContacts = 'Contactos';
z.string.pt.conversationsConnectionRequestMany = '{{number}} pessoas em espera';
z.string.pt.conversationsConnectionRequestOne = '1 pessoa em espera';
z.string.pt.conversationsEmptyConversation = 'Conversa em grupo';
z.string.pt.conversationsNoConversations = 'Ainda não existem conversas';
z.string.pt.conversationsPopoverArchive = 'Arquivar';
z.string.pt.conversationsPopoverCancel = 'Cancelar pedido';
z.string.pt.conversationsPopoverNotify = 'Activar som';
z.string.pt.conversationsPopoverSilence = 'Desativar som';
z.string.pt.conversationsPopoverUnarchive = 'Retirar do arquivo';

z.string.pt.conversationsSecondaryLineEphemeralMessage = 'Enviou-lhe uma mensagem';
z.string.pt.conversationsSecondaryLinePeopleLeft = 'saíram {{number}} pessoas';
z.string.pt.conversationsSecondaryLinePersonLeft = '{{user}} saiu';
z.string.pt.conversationsSecondaryLinePersonRemoved = '{{user}} foi removido';
z.string.pt.conversationsSecondaryLinePeopleAdded = 'Foram adicionadas {{user}} pessoas';
z.string.pt.conversationsSecondaryLinePersonAdded = '{{user}} foi adicionado';
z.string.pt.conversationsSecondaryLinePersonAddedYou = '{{user}} adicionou-o';
z.string.pt.conversationsSecondaryLineRenamed = '{{user}} renomeou a conversa';
z.string.pt.conversationsSecondaryLineYouLeft = 'Você deixou';
z.string.pt.conversationsSecondaryLineYouWereRemoved = 'Você foram removido';

z.string.pt.takeoverSub = 'Reivindicar seu nome exclusivo no Wire.';
z.string.pt.takeoverLink = 'Saber mais';
z.string.pt.takeoverButtonChoose = 'Escolha a sua';
z.string.pt.takeoverButtonKeep = 'Manter esta';

z.string.pt.inviteMetaKeyMac = 'Cmd';
z.string.pt.inviteMetaKeyPc = 'Ctrl';
z.string.pt.inviteHeadline = 'Convidar pessoas para aderir ao Wire';
z.string.pt.inviteMessage = 'Eu estou no Wire, pesquise por {{username}} ou visite get.wire.com.';
z.string.pt.inviteMessageNoEmail = 'Estou no Wire. Visite get.wire.com para se ligar a mim.';

z.string.pt.extensionsBubbleButtonGif = 'Gif';

z.string.pt.extensionsGiphyButtonOk = 'Enviar';
z.string.pt.extensionsGiphyButtonMore = 'Tente outra';
z.string.pt.extensionsGiphyMessage = '• {{tag}} através de giphy.com';
z.string.pt.extensionsGiphyNoGifs = 'Oops, sem gifs';
z.string.pt.extensionsGiphyRandom = 'Aleatório';

z.string.pt.addParticipantsConfirmLabel = 'Adicionar';
z.string.pt.addParticipantsSearchPlaceholder = 'Pesquisar por nome';
z.string.pt.addParticipantsTabsPeople = 'Pessoas';
z.string.pt.addParticipantsTabsServices = 'Serviços';

z.string.pt.conversationDetailsActionArchive = 'Arquivar';
z.string.pt.conversationDetailsActionCancelRequest = 'Cancelar pedido';
z.string.pt.conversationDetailsActionDevices = 'Dispositivos';
z.string.pt.conversationDetailsActionNotifications = 'Notificações';
z.string.pt.conversationDetailsGuestsOff = 'Desligado';
z.string.pt.conversationDetailsOptions = 'Opções';
z.string.pt.conversationDetailsParticipantsServicesMany = 'Serviços';
z.string.pt.conversationDetailsParticipantsUsersMany = 'Pessoas';
z.string.pt.conversationDetailsPeople = 'Pessoas';
z.string.pt.conversationDetailsServices = 'Serviços';

z.string.pt.conversationParticipantsTitle = 'Pessoas';
z.string.pt.conversationParticipantsSearchPlaceholder = 'Pesquisar por nome';

z.string.pt.groupParticipantActionCancelRequest = 'Cancelar pedido';
z.string.pt.groupParticipantActionDevices = 'Dispositivos';
z.string.pt.groupParticipantActionPending = 'Pendente';
z.string.pt.groupParticipantActionSendRequest = 'Ligar';

z.string.pt.notificationSettingsTitle = 'Notificações';

z.string.pt.participantDevicesDetailHeadline = 'Verifique se corresponde à impressão digital mostrada dispositivo {{html2}} do {{html1}}{{user}}.';
z.string.pt.participantDevicesDetailHowTo = 'Como posso fazer isto?';
z.string.pt.participantDevicesDetailResetSession = 'Redefinir sessão';
z.string.pt.participantDevicesDetailShowMyDevice = 'Mostrar impressão digital do meu dispositivo';
z.string.pt.participantDevicesDetailVerify = 'Verificado';

z.string.pt.participantDevicesHeader = 'Dispositivos';
z.string.pt.participantDevicesHeadline = 'O Wire gera em cada dispositivo uma impressão digital única. Compare-os com {{user}} e verifique a sua conversa.';
z.string.pt.participantDevicesLearnMore = 'Saber mais';
z.string.pt.participantDevicesWhyVerify = 'Porquê verificar as conversas?';
z.string.pt.participantDevicesOutdatedClientMessage = '{{user}} está a usar uma versão antiga do Wire. Os dispositivos não são mostrados aqui.';

z.string.pt.participantDevicesSelfAllDevices = 'Mostrar todos os meus dispositivos';
z.string.pt.participantDevicesSelfFingerprint = 'Impressão digital do dispositivo';

z.string.pt.userProfileButtonConnect = 'Ligar';
z.string.pt.userProfileButtonIgnore = 'Ignorar';
z.string.pt.userProfileButtonUnblock = 'Desbloquear';

z.string.pt.preferencesAbout = 'Sobre';
z.string.pt.preferencesAccount = 'Conta';
z.string.pt.preferencesAV = 'Áudio / vídeo';
z.string.pt.preferencesDeviceDetails = 'Detalhes do Dispositivo';
z.string.pt.preferencesDevices = 'Dispositivos';
z.string.pt.preferencesHeadline = 'Preferências';
z.string.pt.preferencesOptions = 'Opções';

z.string.pt.preferencesAboutPrivacyPolicy = 'Política de privacidade';
z.string.pt.preferencesAboutSupport = 'Suporte';
z.string.pt.preferencesAboutSupportWebsite = 'Página de suporte';
z.string.pt.preferencesAboutSupportContact = 'Contactar o Suporte';
z.string.pt.preferencesAboutTermsOfUse = 'Condições de Utilização';
z.string.pt.preferencesAboutVersion = 'Versão {{version}}';
z.string.pt.preferencesAboutWebsite = 'Site do Wire';

z.string.pt.preferencesAccountAvaibilityUnset = 'Definir estado';
z.string.pt.preferencesAccountCreateTeam = 'Criar uma equipa';
z.string.pt.preferencesAccountDelete = 'Eliminar conta';
z.string.pt.preferencesAccountLogOut = 'Terminar sessão';
z.string.pt.preferencesAccountManageTeam = 'Gerir equipa';
z.string.pt.preferencesAccountResetPassword = 'Alterar a palavra-passe';
z.string.pt.preferencesAccountTeam = 'em {{name}}';
z.string.pt.preferencesAccountUsernamePlaceholder = 'O seu nome completo';
z.string.pt.preferencesAccountUsernameHint = 'Pelo menos 2 caracteres. a-z, 0-9 e _ apenas.';
z.string.pt.preferencesAccountUsernameAvailable = 'Disponível';
z.string.pt.preferencesAccountUsernameErrorTaken = 'Já está ocupado';

z.string.pt.preferencesAVCamera = 'Câmera';
z.string.pt.preferencesAVMicrophone = 'Microfone';
z.string.pt.preferencesAVPermissionDetail = 'Permitir a partir das definições seu navegador';
z.string.pt.preferencesAVSpeakers = 'Altifalantes';

z.string.pt.preferencesDevicesActivatedOn = 'Ativado em {{date}}';
z.string.pt.preferencesDevicesActive = 'Ativo';
z.string.pt.preferencesDevicesActiveDetail = 'Se não reconhecer um dispositivo acima, remova-o e altere a sua palavra-passe.';
z.string.pt.preferencesDevicesCurrent = 'Atual';
z.string.pt.preferencesDevicesFingerprint = 'Impressão digital da chave';
z.string.pt.preferencesDevicesFingerprintDetail = 'O Wire gera em cada dispositivo uma impressão digital única. Compare-os e verifique se seus dispositivos e conversas.';
z.string.pt.preferencesDevicesId = 'ID: ';
z.string.pt.preferencesDevicesRemoveCancel = 'Cancelar';
z.string.pt.preferencesDevicesRemoveDetail = 'Remove este dispositivo se tiver parado de o usar. Terminará a sua sessão neste dispositivo imediatamente.';
z.string.pt.preferencesDevicesSessionConfirmation = 'A sessão foi reposta.';
z.string.pt.preferencesDevicesSessionDetail = 'Se as impressões digitais não corresponderem, redefina a sessão para gerar novas chaves de criptografia em ambos os lados.';
z.string.pt.preferencesDevicesSessionReset = 'Redefinir sessão';
z.string.pt.preferencesDevicesSessionOngoing = 'A redefinir a sessão…';
z.string.pt.preferencesDevicesVerification = 'Verificado';

z.string.pt.preferencesOptionsAudio = 'Alerta sonoro';
z.string.pt.preferencesOptionsAudioAll = 'Todos';
z.string.pt.preferencesOptionsAudioAllDetail = 'Todos os sons';
z.string.pt.preferencesOptionsAudioNone = 'Nenhum';
z.string.pt.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.pt.preferencesOptionsAudioSome = 'Alguns';
z.string.pt.preferencesOptionsAudioSomeDetail = 'Pings e chamadas';
z.string.pt.preferencesOptionsContacts = 'Contactos';
z.string.pt.preferencesOptionsContactsGmail = 'Importar do Gmail';
z.string.pt.preferencesOptionsContactsMacos = 'Importar dos Contactos';
z.string.pt.preferencesOptionsContactsDetail = 'Usamos seus dados de contacto para liga-lo aos outros. Nós anonimizamos toda a informação e não a partilhamos com outras entidades.';
z.string.pt.preferencesOptionsPopular = 'A pedido popular';
z.string.pt.preferencesOptionsEmojiReplaceCheckbox = 'Substituir emoticons por emojis';
z.string.pt.preferencesOptionsPreviewsSendCheckbox = 'Criar pré-visualizações para ligações que enviar';
z.string.pt.preferencesOptionsPreviewsSendDetail = 'Antevisões ainda podem mostradas para ligações de outras pessoas.';
z.string.pt.preferencesOptionsNotifications = 'Notificações';
z.string.pt.preferencesOptionsNotificationsNone = 'Desligado';
z.string.pt.preferencesOptionsNotificationsObfuscate = 'Ocultar detalhes';
z.string.pt.preferencesOptionsNotificationsObfuscateMessage = 'Mostrar remetente';
z.string.pt.preferencesOptionsNotificationsOn = 'Mostrar o remetente e a mensagem';

z.string.pt.backupCancel = 'Cancelar';

z.string.pt.searchConnect = 'Ligar';
z.string.pt.searchConnections = 'Ligações';
z.string.pt.searchContacts = 'Contactos';
z.string.pt.searchCreateGroup = 'Criar grupo';
z.string.pt.searchGroups = 'Grupos';
z.string.pt.searchPeople = 'Pessoas';
z.string.pt.searchPlaceholder = 'Pesquisar por nome ou nome de utilizador';
z.string.pt.searchServicePlaceholder = 'Pesquisar por nome';
z.string.pt.searchServices = 'Serviços';
z.string.pt.searchTeamGroups = 'Conversas da equipa';
z.string.pt.searchTeamMembers = 'Membros da equipa';
z.string.pt.searchTopPeople = 'Pessoas mais contactadas';
z.string.pt.searchTrySearch = 'Encontrar pessoas pelo nome ou nome de utilizador';
z.string.pt.searchNoContactsOnWire = 'Não tem qualquer contacto no Wire. Tente encontrar pessoas pelo nome ou nome de utilizador.';
z.string.pt.searchOthers = 'Ligar';

z.string.pt.searchInvite = 'Convidar pessoas para aderir ao Wire';
z.string.pt.searchInviteDetail = 'Partilhar os seus contacto ajuda a ligar-se aos outros. Anonimizamos toda a informação e não a partilhamos com ninguém.';
z.string.pt.searchInviteButtonContacts = 'Dos contactos';
z.string.pt.searchInviteButtonGmail = 'Do Gmail';
z.string.pt.searchInviteHeadline = 'Traga os seus amigos';
z.string.pt.searchInviteShare = 'Partilhar Contactos';

z.string.pt.searchListEveryoneParticipates = 'Todas as pessoas a que está ligado já estão nesta conversa.';
z.string.pt.searchListNoMatches = 'Sem resultados. Tente um nome diferente.';


z.string.pt.uploadGoogleHeadline = 'Encontre pessoas para conversar.';
z.string.pt.uploadGoogleMessage = 'Usamos seus dados de contacto para liga-lo aos outros. Nós anonimizamos toda a informação e não a partilhamos com outras entidades.';

z.string.pt.warningCallUnsupportedIncoming = '{{user}} está a chamar. O seu navegador não suporta chamadas.';
z.string.pt.warningCallUnsupportedOutgoing = 'Não pode telefonar porque o seu navegador não suporta chamadas.';
z.string.pt.warningCallIssues = 'Esta versão do Wire não pode participar na chamada. Por favor, use';
z.string.pt.warningCallUpgradeBrowser = 'Para telefonar, atualize o Google Chrome.';
z.string.pt.warningConnectivityConnectionLost = 'A tentar ligar. O Wire pode não ser capaz de entregar mensagens.';
z.string.pt.warningConnectivityNoInternet = 'Sem Internet. Não será capaz de enviar ou receber mensagens.';
z.string.pt.warningLearnMore = 'Saber mais';
z.string.pt.warningLifecycleUpdate = 'Está disponível uma versão nova do Wire.';
z.string.pt.warningLifecycleUpdateNotes = 'O que há de novo';
z.string.pt.warningLifecycleUpdateLink = 'Actualizar agora';
z.string.pt.warningNotFoundCamera = 'Não pode telefonar porque o seu computador não tem uma câmara.';
z.string.pt.warningNotFoundMicrophone = 'Não pode telefonar porque o seu computador não tem um microfone.';
z.string.pt.warningPermissionDeniedCamera = 'Não pode telefonar porque o seu navegador não tem acesso à câmara.';
z.string.pt.warningPermissionDeniedMicrophone = 'Não pode telefonar porque o seu navegador não tem acesso ao microfone.';
z.string.pt.warningPermissionDeniedScreen = 'O seu navegador precisa de permissão para partilhar o ecrã.';
z.string.pt.warningPermissionRequestCamera = '{{icon}} Permitir o acesso a câmara';
z.string.pt.warningPermissionRequestMicrophone = '{{icon}} Permitir o acesso ao microfone';
z.string.pt.warningPermissionRequestNotification = '{{icon}} Permitir notificações';
z.string.pt.warningPermissionRequestScreen = '{{icon}} Permitir o acesso ao ecrã';

z.string.pt.userAvailabilityAvailable = 'Disponível';
z.string.pt.userAvailabilityAway = 'Ausente';
z.string.pt.userAvailabilityBusy = 'Ocupado';
z.string.pt.userAvailabilityNone = 'Nenhum';

z.string.pt.notificationAssetAdd = 'Partilhou uma foto';
z.string.pt.notificationConnectionAccepted = 'Aceitou o seu pedido de ligação';
z.string.pt.notificationConnectionConnected = 'Já está ligado';
z.string.pt.notificationConnectionRequest = 'Quer ligar-se';
z.string.pt.notificationConversationCreate = '{{user}} começou uma conversa';
z.string.pt.notificationConversationRename = '{{user}} renomeou a conversa para {{name}}';
z.string.pt.notificationMemberJoinMany = '{{user}} adicionou {{number}} pessoas à conversa';
z.string.pt.notificationMemberJoinOne = '{{user1}} adicionou {{user2}} à conversa';
z.string.pt.notificationMemberLeaveRemovedYou = '{{user}} removeu-o da conversação';
z.string.pt.notificationObfuscated = 'Enviou-lhe uma mensagem';
z.string.pt.notificationObfuscatedTitle = 'Alguém';
z.string.pt.notificationPing = 'Pingado';
z.string.pt.notificationReaction = '{{reaction}} a sua mensagem';
z.string.pt.notificationSharedAudio = 'Partilhou uma mensagem áudio';
z.string.pt.notificationSharedFile = 'Partilhou um ficheiro';
z.string.pt.notificationSharedLocation = 'Partilhou a localização';
z.string.pt.notificationSharedVideo = 'Partilhou um vídeo';
z.string.pt.notificationVoiceChannelActivate = 'A chamar';
z.string.pt.notificationVoiceChannelDeactivate = 'Ligou';

z.string.pt.tooltipConversationAllVerified = 'Todas as impressões digitais estão verificadas';
z.string.pt.tooltipConversationCall = 'Chamada';
z.string.pt.tooltipConversationEphemeral = 'Mensagem agendada';
z.string.pt.tooltipConversationFile = 'Adicionar ficheiro';
z.string.pt.tooltipConversationInputPlaceholder = 'Escreva uma mensagem';
z.string.pt.tooltipConversationInputPlaceholderAvailable = '{{user}} está disponível';
z.string.pt.tooltipConversationInputPlaceholderAway = '{{user}} está ausente';
z.string.pt.tooltipConversationInputPlaceholderBusy = '{{user}} está ocupado';
z.string.pt.tooltipConversationPeople = 'Pessoas ({{shortcut}})';
z.string.pt.tooltipConversationPicture = 'Adicionar imagem';
z.string.pt.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.pt.tooltipConversationSearch = 'Procurar';
z.string.pt.tooltipConversationVideoCall = 'Chamada de Vídeo';

z.string.pt.tooltipConversationsArchive = 'Arquivar ({{shortcut}})';
z.string.pt.tooltipConversationsArchived = 'Mostrar ficheiro ({{number}})';
z.string.pt.tooltipConversationsMore = 'Mais';
z.string.pt.tooltipConversationsNotify = 'Desligar "silenciar" ({{shortcut}})';
z.string.pt.tooltipConversationsPreferences = 'Abrir preferências';
z.string.pt.tooltipConversationsSilence = 'Silenciar ({{shortcut}})';
z.string.pt.tooltipConversationsStart = 'Iniciar conversa ({{shortcut}})';

z.string.pt.tooltipConversationDetailsRename = 'Alterar nome da conversa';

z.string.pt.tooltipPreferencesContactsGmail = 'Iniciar sessão na sua conta do Gmail para partilhar contactos';
z.string.pt.tooltipPreferencesContactsMacos = 'Partilhe os contatos da aplicação de contactos macOS';
z.string.pt.tooltipPreferencesPassword = 'Abrir um outro site para alterar a sua palavra-passe';
z.string.pt.tooltipPreferencesPicture = 'Mude sua fotografia…';
z.string.pt.tooltipPreferencesRename = 'Mudar o seu nome';

z.string.pt.tooltipSearchClose = 'Fechar (Esc)';

z.string.pt.initReceivedSelfUser = 'Olá {{user}}.';
z.string.pt.initValidatedClient = 'A descarregar as suas ligações e conversas';
z.string.pt.initReceivedUserData = 'A verificar por novas mensagens';
z.string.pt.initDecryption = 'A desencriptar mensagens';
z.string.pt.initEvents = 'A carregar mensagens';
z.string.pt.initUpdatedFromNotifications = 'Quase pronto - Desfrute do Wire';
z.string.pt.initProgress = ' — {{number1}} de {{number2}}';

z.string.pt.ephemeralUnitsNone = 'Desligado';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.ro.wire = 'Wire';
z.string.ro.wireMacos = 'Wire pentru macOS';
z.string.ro.wireWindows = 'Wire pentru Windows';
z.string.ro.wireLinux = 'Wire pentru Linux';
z.string.ro.nonexistentUser = 'Utilizator șters';
z.string.ro.and = 'și';
z.string.ro.enumerationAnd = ', și ';

z.string.ro.authAccountCountryCode = 'Codul țării';
z.string.ro.authAccountPasswordForgot = 'Am uitat parola';
z.string.ro.authAccountPublicComputer = 'Acesta este un calculator public';
z.string.ro.authAccountSignIn = 'Autentificare';
z.string.ro.authAccountSignInPhone = 'Telefon';

z.string.ro.authBlockedCookies = 'Activează cookie-urile pentru intra în Wire.';
z.string.ro.authBlockedDatabase = 'Wire are nevoie de acces la stocarea locală pentru a afișa mesaje. Stocarea locală nu este disponibilă în modul privat.';
z.string.ro.authBlockedTabs = 'Wire este deja deschis în altă filă.';
z.string.ro.authBlockedTabsAction = 'Folosește această filă în loc';

z.string.ro.authVerifyAccountAdd = 'Adaugă';
z.string.ro.authVerifyAccountDetail = 'Aceasta îți permite să folosești Wire pe mai multe dispozitive.';
z.string.ro.authVerifyAccountHeadline = 'Adaugă o adresă de e-mail și o parolă.';
z.string.ro.authVerifyAccountLogout = 'Deconectare';
z.string.ro.authVerifyCodeDescription = 'Introdu codul de verificare\nl-am trimis la {{number}}.';
z.string.ro.authVerifyCodeResend = 'Nu e afișat niciun cod?';
z.string.ro.authVerifyCodeResendDetail = 'Retrimite';
z.string.ro.authVerifyCodeResendTimer = 'Poți cere un nou cod de {{expiration}}.';
z.string.ro.authVerifyCodeChangePhone = 'Schimbă numărul de telefon';
z.string.ro.authVerifyPasswordHeadline = 'Introdu parola ta';

z.string.ro.authLimitDevicesHeadline = 'Dispozitive';
z.string.ro.authLimitDescription = 'Șterge unul din celelalte dispozitive pentru a folosi Wire pe acesta.';
z.string.ro.authLimitButtonManage = 'Gestionare dispozitive';
z.string.ro.authLimitButtonSignOut = 'Deconectare';
z.string.ro.authLimitDevicesCurrent = '(Curent)';

z.string.ro.authHistoryHeadline = 'Folosești Wire pentru prima dată pe acest dispozitiv.';
z.string.ro.authHistoryDescription = 'Din motive de confidențialitate, istoricul conversației nu va apărea aici.';
z.string.ro.authHistoryReuseHeadline = 'Ai mai folosit Wire pe acest dispozitiv.';
z.string.ro.authHistoryReuseDescription = 'Mesajele trimise între timp nu vor apărea aici.';
z.string.ro.authHistoryButton = 'OK';

z.string.ro.authPostedResend = 'Retrimite la {{email}}';
z.string.ro.authPostedResendAction = 'Nu a apărut nici un e-mail?';
z.string.ro.authPostedResendDetail = 'Verifică e-mailul și urmează instrucțiunile.';
z.string.ro.authPostedResendHeadline = 'Ai primit un mesaj.';

z.string.ro.authPlaceholderEmail = 'E-mail';
z.string.ro.authPlaceholderPasswordPut = 'Parolă';
z.string.ro.authPlaceholderPasswordSet = 'Parolă (minim 8 caractere)';
z.string.ro.authPlaceholderPhone = 'Număr de telefon';

z.string.ro.authErrorCode = 'Cod nevalid';
z.string.ro.authErrorCountryCodeInvalid = 'Cod de țară nevalid';
z.string.ro.authErrorEmailExists = 'Adresa de e-mail este deja folosită';
z.string.ro.authErrorEmailForbidden = 'Ne pare rău. Această adresa de e-mail este interzisă.';
z.string.ro.authErrorEmailMalformed = 'Te rugăm să introduci o adresă de e-mail validă.';
z.string.ro.authErrorEmailMissing = 'Introdu o adresă de e-mail.';
z.string.ro.authErrorMisc = 'Ai probleme cu conexiunea. Reîncearcă.';
z.string.ro.authErrorNameShort = 'Introdu un nume de cel puțin 2 caractere';
z.string.ro.authErrorOffline = 'Lipsește conexiunea la internet';
z.string.ro.authErrorPasswordShort = 'Alege o parolă de cel puțin 8 caractere.';
z.string.ro.authErrorPasswordWrong = 'Parolă greșită. Reîncearcă.';
z.string.ro.authErrorPending = 'Cont neverificat';
z.string.ro.authErrorPhoneNumberBudget = 'Te conectezi prea des. Încearcă din nou mai târziu.';
z.string.ro.authErrorPhoneNumberForbidden = 'Ne pare rău. Acest număr de telefon este interzis.';
z.string.ro.authErrorPhoneNumberInvalid = 'Număr de telefon nevalid';
z.string.ro.authErrorPhoneNumberUnknown = 'Număr de telefon necunoscut';
z.string.ro.authErrorSuspended = 'Acest cont nu mai este autorizat pentru autentificare.';
z.string.ro.authErrorSignIn = 'Te rugăm să verifici detaliile și să reîncerci.';

z.string.ro.callStateOutgoing = 'Se sună…';
z.string.ro.callStateConnecting = 'Se conectează…';
z.string.ro.callStateIncoming = 'Se apelează…';
z.string.ro.callDecline = 'Refuză';
z.string.ro.callAccept = 'Acceptă';
z.string.ro.callJoin = 'Alătură-te';
z.string.ro.callChooseSharedScreen = 'Alege un ecran pentru a partaja';
z.string.ro.callParticipants = '{{number}} în apel';

z.string.ro.videoCallOverlayMute = 'Mutizează';
z.string.ro.videoCallOverlayHangUp = 'Închide';

z.string.ro.modalAcknowledgeAction = 'Ok';
z.string.ro.modalAcknowledgeHeadline = 'Ceva nu a mers bine';
z.string.ro.modalConfirmSecondary = 'Renunță';
z.string.ro.modalOptionSecondary = 'Renunță';

z.string.ro.modalAccountCreateAction = 'OK';
z.string.ro.modalAccountCreateHeadline = 'Dorești să creezi un cont?';
z.string.ro.modalAccountCreateMessage = 'Prin crearea unui cont vei pierde istoricul conversațiilor din această cameră de oaspeți.';

z.string.ro.modalAccountDeletionAction = 'Șterge';
z.string.ro.modalAccountDeletionHeadline = 'Șterge contul';
z.string.ro.modalAccountDeletionMessage = 'Îți vom trimite un mesaj pe e-mail sau SMS. Urmează linkul pentru a șterge permanent contul tău.';

z.string.ro.modalAccountLeaveGuestRoomAction = 'Ieși';
z.string.ro.modalAccountLeaveGuestRoomHeadline = 'Ieși din camera de oaspeți?';
z.string.ro.modalAccountLeaveGuestRoomMessage = 'Istoricul conversațiilor va fi șters. Poți păstra istoricul doar prin crearea unui cont.';

z.string.ro.modalAccountLogoutAction = 'Deconectare';
z.string.ro.modalAccountLogoutHeadline = 'Curăță datele?';
z.string.ro.modalAccountLogoutOption = 'Șterge toate informațiile personale și conversațiile de pe acest dispozitiv.';

z.string.ro.modalAccountNewDevicesSecondary = 'Gestionare dispozitive';
z.string.ro.modalAccountNewDevicesHeadline = 'Contul tău a fost folosit în data de:';
z.string.ro.modalAccountNewDevicesFrom = 'De la:';
z.string.ro.modalAccountNewDevicesMessage = 'Dacă nu ai făcut asta, elimină dispozitivul și resetează parola.';

z.string.ro.modalAccountRemoveDeviceAction = 'Scoate dispozitivul';
z.string.ro.modalAccountRemoveDeviceHeadline = 'Scoate „{{device}}”';
z.string.ro.modalAccountRemoveDeviceMessage = 'Este necesară parola pentru a elimina acest dispozitiv.';
z.string.ro.modalAccountRemoveDevicePlaceholder = 'Parolă';

z.string.ro.modalAssetTooLargeHeadline = 'Fișierul este prea mare';
z.string.ro.modalAssetTooLargeMessage = 'Poți trimite fișiere până la {{number}}';

z.string.ro.modalAssetParallelUploadsHeadline = 'Prea multe fișiere de încărcat';
z.string.ro.modalAssetParallelUploadsMessage = 'Poți trimite maxim {{number}} fișiere simultan.';

z.string.ro.modalCallEmptyConversationHeadline = 'Nu ai pe cine apela';
z.string.ro.modalCallEmptyConversationMessage = 'Nu a mai rămas nimeni aici.';

z.string.ro.modalCallNoGroupVideoHeadline = 'Nu poți face apeluri video în grupuri';
z.string.ro.modalCallNoGroupVideoMessage = 'Apelurile video nu sunt disponibile în conversațiile de grup.';

z.string.ro.modalCallNoMicrophoneAction = 'Spune-mi cum';
z.string.ro.modalCallNoMicrophoneMessage = 'Browserul tău are nevoie de acces la microfon pentru a face apeluri.';
z.string.ro.modalCallNoMicrophoneHeadline = 'Nu se poate apela fără microfon';

z.string.ro.modalCallSecondIncomingAction = 'Răspunde';
z.string.ro.modalCallSecondIncomingHeadline = 'Răspunde la apel?';
z.string.ro.modalCallSecondIncomingMessage = 'Apelul curent se va termina.';

z.string.ro.modalCallSecondOngoingAction = 'Închide';
z.string.ro.modalCallSecondOngoingHeadline = 'Închide apelul pe un alt dispozitiv?';
z.string.ro.modalCallSecondOngoingMessage = 'Nu poți fi decât într-un singur apel la un moment dat.';

z.string.ro.modalCallSecondOutgoingAction = 'Închide';
z.string.ro.modalCallSecondOutgoingHeadline = 'Închide apelul curent?';
z.string.ro.modalCallSecondOutgoingMessage = 'Nu poți fi decât într-un singur apel la un moment dat.';

z.string.ro.modalConnectCancelAction = 'Da';
z.string.ro.modalConnectCancelHeadline = 'Anulează solicitarea?';
z.string.ro.modalConnectCancelMessage = 'Șterge solicitarea de conectare cu {{user}}.';
z.string.ro.modalConnectCancelSecondary = 'Nu';

z.string.ro.modalConnectAcceptAction = 'Conectare';
z.string.ro.modalConnectAcceptHeadline = 'Acceptă?';
z.string.ro.modalConnectAcceptMessage = 'Aceasta te va conecta și va deschide o conversație cu {{user}}.';
z.string.ro.modalConnectAcceptSecondary = 'Ignoră';

z.string.ro.modalConversationClearAction = 'Șterge';
z.string.ro.modalConversationClearHeadline = 'Ștergeți conținutul?';
z.string.ro.modalConversationClearOption = 'Părăsește conversația';

z.string.ro.modalConversationDeleteMessageAction = 'Șterge';
z.string.ro.modalConversationDeleteMessageHeadline = 'Șterge doar pentru mine?';
z.string.ro.modalConversationDeleteMessageMessage = 'Operațiunea nu poate fi anulată.';

z.string.ro.modalConversationDeleteMessageEveryoneAction = 'Șterge';
z.string.ro.modalConversationDeleteMessageEveryoneHeadline = 'Șterge pentru toată lumea?';
z.string.ro.modalConversationDeleteMessageEveryoneMessage = 'Operațiunea nu poate fi anulată.';

z.string.ro.modalConversationLeaveAction = 'Ieși';
z.string.ro.modalConversationLeaveMessage = 'Nu vei mai putea trimite sau primi mesaje în această conversație.';

z.string.ro.modalConversationMessageTooLongHeadline = 'Mesajul este prea lung';
z.string.ro.modalConversationMessageTooLongMessage = 'Nu poți trimite mesaje mai lungi de {{number}} caractere.';

z.string.ro.modalConversationNewDeviceHeadlineOne = '{{user}} a început să folosească un nou dispozitiv';
z.string.ro.modalConversationNewDeviceHeadlineMany = '{{user}}s au început să folosească dispozitive noi';
z.string.ro.modalConversationNewDeviceHeadlineYou = '{{user}} a început să folosească un nou dispozitiv';
z.string.ro.modalConversationNewDeviceIncomingCallAction = 'Acceptă apelul';
z.string.ro.modalConversationNewDeviceIncomingCallMessage = 'Încă mai dorești acest apel?';
z.string.ro.modalConversationNewDeviceMessage = 'Încă dorești să fie trimise mesajele?';
z.string.ro.modalConversationNewDeviceOutgoingCallAction = 'Sună oricum';
z.string.ro.modalConversationNewDeviceOutgoingCallMessage = 'Încă mai dorești să faci apelul?';

z.string.ro.modalConversationNotConnectedHeadline = 'Nimeni nu a fost adăugat la conversație';
z.string.ro.modalConversationNotConnectedMessageOne = '{{name}} nu dorește să fie adăugat la conversații.';
z.string.ro.modalConversationNotConnectedMessageMany = 'Unul din cei pe care i-ai selectat nu dorește să fie adăugat la conversații.';

z.string.ro.modalConversationRemoveAction = 'Șterge';
z.string.ro.modalConversationRemoveHeadline = 'Șterge?';
z.string.ro.modalConversationRemoveMessage = '{{user}} nu va mai putea trimite sau primi mesaje în această conversație.';

z.string.ro.modalConversationRemoveGuestsAction = 'Șterge';

z.string.ro.modalConversationTooManyMembersHeadline = 'Canalul este plin';

z.string.ro.modalIntegrationUnavailableHeadline = 'Roboții nu sunt momentan disponibili';
z.string.ro.modalIntegrationUnavailableMessage = 'Mulțumim că ești interesat de roboți. Acest serviciu este momentan suspendat în timp ce lucrăm la următoarea versiune. Fii pe fază.';


z.string.ro.modalImproveWireAction = 'Acceptă';
z.string.ro.modalImproveWireSecondary = 'Nu';

z.string.ro.modalServiceUnavailableHeadline = 'Adăugarea serviciului nu este posibilă';
z.string.ro.modalServiceUnavailableMessage = 'Acest serviciu este indisponibil momentan.';

z.string.ro.modalSessionResetHeadline = 'Sesiunea a fost resetată';
z.string.ro.modalSessionResetMessage1 = 'Dacă problema nu este rezolvată,';
z.string.ro.modalSessionResetMessageLink = 'contactează-';
z.string.ro.modalSessionResetMessage2 = 'ne.';

z.string.ro.modalUploadContactsAction = 'Reîncearcă';
z.string.ro.modalUploadContactsMessage = 'Nu am primit nicio informație. Încearcă importarea contactelor din nou.';

z.string.ro.modalUserBlockAction = 'Blochează';
z.string.ro.modalUserBlockHeadline = 'Blochează pe {{user}}?';
z.string.ro.modalUserBlockMessage = '{{user}} nu te va putea contacta sau adăuga la conversații de grup.';

z.string.ro.modalUserUnblockAction = 'Deblochează';
z.string.ro.modalUserUnblockHeadline = 'Deblochează?';
z.string.ro.modalUserUnblockMessage = '{{user}} te va putea contacta și adăuga din nou la conversații de grup.';

z.string.ro.connectionRequestConnect = 'Conectare';
z.string.ro.connectionRequestIgnore = 'Ignoră';

z.string.ro.conversationGuestIndicator = 'Vizitator';

z.string.ro.conversationYouNominative = 'tu';
z.string.ro.conversationYouDative = 'tu';
z.string.ro.conversationYouAccusative = 'tu';

z.string.ro.conversationConnectionAccepted = 'Conectat';
z.string.ro.conversationConnectionBlocked = 'Blocat';
z.string.ro.conversationConnectionCancelRequest = 'Anulează cererea de conectare';
z.string.ro.conversationCreateWith = 'grosime {{users}}';
z.string.ro.conversationDeviceStartedUsingOne = ' a început să folosească';
z.string.ro.conversationDeviceStartedUsingMany = ' a început să folosească';
z.string.ro.conversationDeviceUnverified = ' unul dintre dispozitivele';
z.string.ro.conversationDeviceYourDevices = ' tale neverificate';
z.string.ro.conversationDeviceUserDevices = ' dispozitivele lui {{user}}';
z.string.ro.conversationDeviceNewDeviceOne = ' un nou dispozitiv';
z.string.ro.conversationDeviceNewDeviceMany = ' dispozitive noi';
z.string.ro.conversationDeviceNewPeopleJoinedVerify = ' verifică dispozitivele';
z.string.ro.conversationJustNow = 'Chiar acum';
z.string.ro.conversationLocationLink = 'Deschide harta';
z.string.ro.conversationMessageDelivered = 'Livrat';
z.string.ro.conversationRename = ' ai redenumit conversația';
z.string.ro.conversationRenameYou = ' ai redenumit conversația';
z.string.ro.conversationResume = 'Începe o conversație cu {{users}}';
z.string.ro.conversationPing = ' pinguit';
z.string.ro.conversationPingYou = ' pinguit';
z.string.ro.conversationToday = 'azi';
z.string.ro.conversationVoiceChannelDeactivate = ' sunat';
z.string.ro.conversationVoiceChannelDeactivateYou = ' sunat';
z.string.ro.conversationYesterday = 'ieri';
z.string.ro.conversationUnableToDecrypt1 = 'ai primit un mesaj de la {{user}}.';
z.string.ro.conversationUnableToDecrypt2 = 'identitatea dispozitivului lui {{user}} s-a schimbat. Mesajul nu a fost livrat.';
z.string.ro.conversationUnableToDecryptLink = 'De ce?';
z.string.ro.conversationUnableToDecryptErrorMessage = 'Eroare';
z.string.ro.conversationUnableToDecryptResetSession = 'Resetează sesiunea';
z.string.ro.conversationMissedMessages = 'Nu ai folosit acest dispozitiv de ceva timp. Unele mesaje ar putea să nu apară aici.';
z.string.ro.conversationAssetUploading = 'Se încarcă…';
z.string.ro.conversationAssetDownloading = 'Se descarcă…';
z.string.ro.conversationAssetUploadFailed = 'Încărcarea a eșuat';
z.string.ro.conversationPlaybackError = 'Nu se poate reda';
z.string.ro.conversationContextMenuCopy = 'Copiază';
z.string.ro.conversationContextMenuEdit = 'Editează';
z.string.ro.conversationContextMenuDelete = 'Șterge pentru mine';
z.string.ro.conversationContextMenuDeleteEveryone = 'Șterge pentru toată lumea';
z.string.ro.conversationContextMenuDownload = 'Descarcă';
z.string.ro.conversationContextMenuLike = 'Apreciază';
z.string.ro.conversationContextMenuUnlike = 'Nu-mi mai place';
z.string.ro.conversationDeleteTimestamp = 'A fost șters la {{date}}';
z.string.ro.conversationEditTimestamp = 'A fost editat la {{date}}';
z.string.ro.conversationLikesCaption = '{{number}} persoane';
z.string.ro.conversationSendPastedFile = 'A postat o imagine pe {{date}}';
z.string.ro.conversationSomeone = 'Cineva';
z.string.ro.conversationTweetAuthor = ' pe Twitter';

z.string.ro.groupCreationPreferencesAction = 'Mai departe';
z.string.ro.groupCreationPreferencesErrorNameShort = 'Cel puțin un caracter';
z.string.ro.groupCreationPreferencesErrorNameLong = 'Prea multe caractere';
z.string.ro.groupCreationPreferencesHeader = 'Grup nou';
z.string.ro.groupCreationPreferencesPlaceholder = 'Nume grup';
z.string.ro.groupCreationParticipantsActionCreate = 'Gata';
z.string.ro.groupCreationParticipantsHeader = 'Adaugă persoane';
z.string.ro.groupCreationParticipantsPlaceholder = 'Caută după nume';


z.string.ro.collectionShowAll = 'Arată toate {{number}}';
z.string.ro.collectionSectionLinks = 'Legături';
z.string.ro.collectionSectionImages = 'Imagini';
z.string.ro.collectionSectionFiles = 'Fișiere';
z.string.ro.collectionSectionAudio = 'Mesaje audio';

z.string.ro.fullsearchPlaceholder = 'Caută prin mesaje text';
z.string.ro.fullsearchNoResults = 'Fără rezultate.';

z.string.ro.archiveHeader = 'Arhivă';

z.string.ro.conversationsAllArchived = 'Totul a fost arhivat';
z.string.ro.conversationsContacts = 'Contacte';
z.string.ro.conversationsConnectionRequestMany = '{{number}} persoane așteaptă';
z.string.ro.conversationsConnectionRequestOne = '1 persoană așteaptă';
z.string.ro.conversationsEmptyConversation = 'Conversație de grup';
z.string.ro.conversationsNoConversations = 'Nu sunt încă conversații';
z.string.ro.conversationsPopoverArchive = 'Arhivă';
z.string.ro.conversationsPopoverCancel = 'Anulează cererea';
z.string.ro.conversationsPopoverNotify = 'Demutizează';
z.string.ro.conversationsPopoverSilence = 'Mutizează';
z.string.ro.conversationsPopoverUnarchive = 'Dezarhivează';

z.string.ro.conversationsSecondaryLineEphemeralMessage = 'Ți-a trimis un mesaj';
z.string.ro.conversationsSecondaryLinePeopleLeft = '{{number}} persoane au plecat';
z.string.ro.conversationsSecondaryLinePersonLeft = '{{user}} a ieșit';
z.string.ro.conversationsSecondaryLinePersonRemoved = '{{user}} a fost scos din conversație';
z.string.ro.conversationsSecondaryLinePeopleAdded = '{{user}} persoane au fost adăugate';
z.string.ro.conversationsSecondaryLinePersonAdded = '{{user}} a fost adăugat';
z.string.ro.conversationsSecondaryLinePersonAddedYou = '{{user}} te-a adăugat';
z.string.ro.conversationsSecondaryLineRenamed = '{{user}} a redenumit conversația';
z.string.ro.conversationsSecondaryLineYouLeft = 'Ai ieșit';
z.string.ro.conversationsSecondaryLineYouWereRemoved = 'Ai fost scos din conversație';

z.string.ro.takeoverSub = 'Obține numele tău unic pe Wire.';
z.string.ro.takeoverLink = 'Află mai multe';
z.string.ro.takeoverButtonChoose = 'Alege propriul nume';
z.string.ro.takeoverButtonKeep = 'Păstrează acest nume';

z.string.ro.inviteMetaKeyMac = 'Cmd';
z.string.ro.inviteMetaKeyPc = 'Ctrl';
z.string.ro.inviteHeadline = 'Invită persoane pe Wire';
z.string.ro.inviteMessage = 'Bună, sunt pe Wire. Caută-mă cu numele {{username}} sau vizitează get.wire.com.';
z.string.ro.inviteMessageNoEmail = 'Sunt pe Wire. Vizitează get.wire.com pentru a te conecta cu mine.';

z.string.ro.extensionsBubbleButtonGif = 'Gif';

z.string.ro.extensionsGiphyButtonOk = 'Trimite';
z.string.ro.extensionsGiphyButtonMore = 'Încearcă altul';
z.string.ro.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.ro.extensionsGiphyNoGifs = 'Ups, nu sunt gif-uri';
z.string.ro.extensionsGiphyRandom = 'La întâmplare';

z.string.ro.addParticipantsConfirmLabel = 'Adaugă';
z.string.ro.addParticipantsHeader = 'Adaugă persoane';
z.string.ro.addParticipantsSearchPlaceholder = 'Caută după nume';
z.string.ro.addParticipantsServiceConfirmButton = 'Adaugă serviciu';
z.string.ro.addParticipantsTabsPeople = 'Persoane';
z.string.ro.addParticipantsTabsServices = 'Servicii';

z.string.ro.conversationDetailsActionArchive = 'Arhivă';
z.string.ro.conversationDetailsActionAddParticipants = 'Adaugă persoane';
z.string.ro.conversationDetailsActionCancelRequest = 'Anulează cererea';
z.string.ro.conversationDetailsActionCreateGroup = 'Grup nou';
z.string.ro.conversationDetailsActionDevices = 'Dispozitive';
z.string.ro.conversationDetailsActionNotifications = 'Notificări';
z.string.ro.conversationDetailsGuestsOff = 'Închis';
z.string.ro.conversationDetailsOptions = 'Opțiuni';
z.string.ro.conversationDetailsParticipantsServicesMany = 'Servicii';
z.string.ro.conversationDetailsParticipantsUsersMany = 'Persoane';
z.string.ro.conversationDetailsPeople = 'Persoane';
z.string.ro.conversationDetailsServices = 'Servicii';

z.string.ro.conversationParticipantsTitle = 'Persoane';
z.string.ro.conversationParticipantsSearchPlaceholder = 'Caută după nume';

z.string.ro.groupParticipantActionCancelRequest = 'Anulează cererea';
z.string.ro.groupParticipantActionDevices = 'Dispozitive';
z.string.ro.groupParticipantActionPending = 'În așteptare';
z.string.ro.groupParticipantActionSendRequest = 'Conectare';

z.string.ro.notificationSettingsTitle = 'Notificări';

z.string.ro.participantDevicesDetailHeadline = 'Verifică dacă aceasta se potrivește cu amprenta arătată în {{html1}}dispozitivul al lui {{user}}{{html2}}.';
z.string.ro.participantDevicesDetailHowTo = 'Cum fac asta?';
z.string.ro.participantDevicesDetailResetSession = 'Resetează sesiunea';
z.string.ro.participantDevicesDetailShowMyDevice = 'Arată amprenta dispozitivului';
z.string.ro.participantDevicesDetailVerify = 'Verificat';

z.string.ro.participantDevicesHeader = 'Dispozitive';
z.string.ro.participantDevicesHeadline = 'Wire oferă fiecărui dispozitiv o amprentă unică. Compară amprentele cu {{user}} și verifică conversația.';
z.string.ro.participantDevicesLearnMore = 'Află mai multe';
z.string.ro.participantDevicesWhyVerify = 'De ce să verific această conversație?';
z.string.ro.participantDevicesOutdatedClientMessage = '{{user}} folosește o versiune veche de Wire. Nu sunt afișate dispozitive.';

z.string.ro.participantDevicesSelfAllDevices = 'Arată toate dispozitivele mele';
z.string.ro.participantDevicesSelfFingerprint = 'Amprentă dispozitiv';

z.string.ro.userProfileButtonConnect = 'Conectare';
z.string.ro.userProfileButtonIgnore = 'Ignoră';
z.string.ro.userProfileButtonUnblock = 'Deblochează';

z.string.ro.preferencesAbout = 'Despre';
z.string.ro.preferencesAccount = 'Cont';
z.string.ro.preferencesAV = 'Audio / video';
z.string.ro.preferencesDeviceDetails = 'Detalii dispozitiv';
z.string.ro.preferencesDevices = 'Dispozitive';
z.string.ro.preferencesHeadline = 'Preferințe';
z.string.ro.preferencesOptions = 'Opțiuni';

z.string.ro.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.ro.preferencesAboutPrivacyPolicy = 'Politică de confidențialitate';
z.string.ro.preferencesAboutSupport = 'Suport';
z.string.ro.preferencesAboutSupportWebsite = 'Site de suport';
z.string.ro.preferencesAboutSupportContact = 'Contactează echipa de asistență';
z.string.ro.preferencesAboutTermsOfUse = 'Termeni de folosire';
z.string.ro.preferencesAboutVersion = 'Versiune {{version}}';
z.string.ro.preferencesAboutWebsite = 'Site web Wire';

z.string.ro.preferencesAccountAvaibilityUnset = 'Stabilește o stare';
z.string.ro.preferencesAccountCreateTeam = 'Creează o echipă';
z.string.ro.preferencesAccountDelete = 'Șterge contul';
z.string.ro.preferencesAccountLogOut = 'Deconectare';
z.string.ro.preferencesAccountManageTeam = 'Gestionează o echipă';
z.string.ro.preferencesAccountResetPassword = 'Resetează parola';
z.string.ro.preferencesAccountTeam = 'în {{name}}';
z.string.ro.preferencesAccountUsernamePlaceholder = 'Numele tău complet';
z.string.ro.preferencesAccountUsernameHint = 'Cel puțin două caractere. Doar a—z, 0—9 și _ sunt permise.';
z.string.ro.preferencesAccountUsernameAvailable = 'Disponibil';
z.string.ro.preferencesAccountUsernameErrorTaken = 'Deja folosit';

z.string.ro.preferencesAVCamera = 'Cameră';
z.string.ro.preferencesAVMicrophone = 'Microfon';
z.string.ro.preferencesAVPermissionDetail = 'Activează din preferințele browserului';
z.string.ro.preferencesAVSpeakers = 'Difuzoare';

z.string.ro.preferencesDevicesActivatedOn = 'Activat la {{date}}';
z.string.ro.preferencesDevicesActive = 'Activ';
z.string.ro.preferencesDevicesActiveDetail = 'Dacă nu recunoști un dispozitiv de mai sus, elimină-l și resetează parola.';
z.string.ro.preferencesDevicesCurrent = 'Curent';
z.string.ro.preferencesDevicesFingerprint = 'Amprentă cheie';
z.string.ro.preferencesDevicesFingerprintDetail = 'Wire generează câte o amprentă unică pentru fiecare dispozitiv. Compară-le și verifică dispozitivele și conversațiile tale.';
z.string.ro.preferencesDevicesId = 'ID: ';
z.string.ro.preferencesDevicesRemoveCancel = 'Renunță';
z.string.ro.preferencesDevicesRemoveDetail = 'Elimină acest dispozitiv dacă nu-l mai folosești. Vei fi deconectat de pe acest dispozitiv imediat.';
z.string.ro.preferencesDevicesSessionConfirmation = 'Sesiunea a fost resetată.';
z.string.ro.preferencesDevicesSessionDetail = 'Dacă amprentele nu se potrivesc, resetează sesiunea pentru a genera un nou set de chei de criptare pentru ambele părți.';
z.string.ro.preferencesDevicesSessionReset = 'Resetează sesiunea';
z.string.ro.preferencesDevicesSessionOngoing = 'Se resetează sesiunea…';
z.string.ro.preferencesDevicesVerification = 'Verificat';

z.string.ro.preferencesOptionsAudio = 'Alerte sonore';
z.string.ro.preferencesOptionsAudioAll = 'Toate';
z.string.ro.preferencesOptionsAudioAllDetail = 'Toate sunetele';
z.string.ro.preferencesOptionsAudioNone = 'Niciunul';
z.string.ro.preferencesOptionsAudioNoneDetail = 'Psst!';
z.string.ro.preferencesOptionsAudioSome = 'Unele';
z.string.ro.preferencesOptionsAudioSomeDetail = 'Bipuri și apeluri';
z.string.ro.preferencesOptionsContacts = 'Contacte';
z.string.ro.preferencesOptionsContactsGmail = 'Importă din Gmail';
z.string.ro.preferencesOptionsContactsMacos = 'Importă din contacte';
z.string.ro.preferencesOptionsContactsDetail = 'Vom folosi datele tale de contact pentru a te conecta cu alții. Vom anonimiza toate informațiile și nu le vom împărtăși cu altcineva.';
z.string.ro.preferencesOptionsPopular = 'În urma cererilor populare';
z.string.ro.preferencesOptionsEmojiReplaceCheckbox = 'Înlocuiește emoticoanele cu emoji';
z.string.ro.preferencesOptionsPreviewsSendCheckbox = 'Creează previzualizări pentru linkurile pe care le trimiți';
z.string.ro.preferencesOptionsPreviewsSendDetail = 'Previzualizările mai pot fi arătate pentru linkuri din partea altor persoane.';
z.string.ro.preferencesOptionsNotifications = 'Notificări';
z.string.ro.preferencesOptionsNotificationsNone = 'Închis';
z.string.ro.preferencesOptionsNotificationsObfuscate = 'Ascunde detaliile';
z.string.ro.preferencesOptionsNotificationsObfuscateMessage = 'Arată expeditorul';
z.string.ro.preferencesOptionsNotificationsOn = 'Arată expeditorul și mesajul';

z.string.ro.backupImportGenericErrorHeadline = 'Ceva nu a mers bine';
z.string.ro.backupCancel = 'Renunță';

z.string.ro.searchConnect = 'Conectare';
z.string.ro.searchConnections = 'Conexiuni';
z.string.ro.searchContacts = 'Contacte';
z.string.ro.searchCreateGroup = 'Creează grup';
z.string.ro.searchGroups = 'Grupuri';
z.string.ro.searchPeople = 'Persoane';
z.string.ro.searchPlaceholder = 'Caută după nume sau nume utilizator';
z.string.ro.searchServicePlaceholder = 'Caută după nume';
z.string.ro.searchServices = 'Servicii';
z.string.ro.searchTeamGroups = 'Conversații de echipă';
z.string.ro.searchTeamMembers = 'Membrii echipei';
z.string.ro.searchTopPeople = 'Top persoane';
z.string.ro.searchTrySearch = 'Caută oameni după\nnume sau nume utilizator';
z.string.ro.searchNoContactsOnWire = 'Nu ai contacte pe Wire.\nÎncearcă să găsește oameni după\nnume sau nume utilizator.';
z.string.ro.searchMemberInvite = 'Invită oameni în echipă';
z.string.ro.searchOthers = 'Conectare';

z.string.ro.searchInvite = 'Invită persoane pe Wire';
z.string.ro.searchInviteDetail = 'Împărtășirea contactelor ne ajută să te conectăm cu alții. Noi anonimizăm toate informațiile și nu le împărtășim cu terți.';
z.string.ro.searchInviteButtonContacts = 'Din Contacte';
z.string.ro.searchInviteButtonGmail = 'Din Gmail';
z.string.ro.searchInviteHeadline = 'Invită prietenii';
z.string.ro.searchInviteShare = 'Împărtășește contacte';

z.string.ro.searchServiceConfirmButton = 'Adaugă serviciu';

z.string.ro.searchListEveryoneParticipates = 'Toată lumea cu care\nești conectat este deja\nîn această conversație.';
z.string.ro.searchListNoMatches = 'Nu s-a găsit nimic.\nÎncearcă să scrii un alt nume.';


z.string.ro.uploadGoogleHeadline = 'Caută persoane\ncu care să vorbești.';
z.string.ro.uploadGoogleMessage = 'Vom folosi datele tale de contact pentru a te conecta cu alții. Vom anonimiza toate informațiile și nu le vom împărtăși cu altcineva.';

z.string.ro.warningCallUnsupportedIncoming = '{{user}} te sună. Browserul tău nu suportă apelurile.';
z.string.ro.warningCallUnsupportedOutgoing = 'Nu poți suna pentru că browserul tău nu suportă apelurile.';
z.string.ro.warningCallIssues = 'Această versiune de Wire nu poate participa într-un apel. Te rugăm să folosești';
z.string.ro.warningCallUpgradeBrowser = 'Pentru a suna, te rugăm să actualizezi Google Chrome.';
z.string.ro.warningConnectivityConnectionLost = 'Se încearcă conectarea. Wire ar putea să nu trimită mesaje în acest timp.';
z.string.ro.warningConnectivityNoInternet = 'Nu este conexiune la internet. Nu vei putea trimite sau primi mesaje.';
z.string.ro.warningLearnMore = 'Află mai multe';
z.string.ro.warningLifecycleUpdate = 'Este disponibilă o nouă versiune de Wire.';
z.string.ro.warningLifecycleUpdateNotes = 'Ce mai e nou';
z.string.ro.warningLifecycleUpdateLink = 'Actualizează acum';
z.string.ro.warningNotFoundCamera = 'Nu poți suna pentru că acest dispozitiv nu are o cameră.';
z.string.ro.warningNotFoundMicrophone = 'Nu poți suna pentru că acest dispozitiv nu are un microfon.';
z.string.ro.warningPermissionDeniedCamera = 'Nu poți suna pentru că browserul tău nu are acces la cameră.';
z.string.ro.warningPermissionDeniedMicrophone = 'Nu poți suna pentru că browserul tău nu are acces la microfon.';
z.string.ro.warningPermissionDeniedScreen = 'Browserul tău are nevoie de permisiuni pentru a partaja ecranul.';
z.string.ro.warningPermissionRequestCamera = '{{icon}} permite accesul la cameră';
z.string.ro.warningPermissionRequestMicrophone = '{{icon}} permit accesul la microfon';
z.string.ro.warningPermissionRequestNotification = '{{icon}} permite notificările';
z.string.ro.warningPermissionRequestScreen = '{{icon}} permite accesul la ecran';

z.string.ro.userAvailabilityAvailable = 'Disponibil';
z.string.ro.userAvailabilityAway = 'Departe';
z.string.ro.userAvailabilityBusy = 'Ocupat';
z.string.ro.userAvailabilityNone = 'Niciunul';

z.string.ro.notificationAssetAdd = 'A împărtășit o imagine';
z.string.ro.notificationConnectionAccepted = 'A acceptat cererea de conectare a ta';
z.string.ro.notificationConnectionConnected = 'Acum ești conectat';
z.string.ro.notificationConnectionRequest = 'Așteaptă conectarea';
z.string.ro.notificationConversationCreate = '{{user}} a început o conversație';
z.string.ro.notificationConversationRename = '{{user}} a redenumit conversația în {{name}}';
z.string.ro.notificationMemberJoinMany = '{{user}} a adăugat {{number}} persoane la conversație';
z.string.ro.notificationMemberJoinOne = '{{user1}} a adăugat pe {{user2}} la conversație';
z.string.ro.notificationMemberLeaveRemovedYou = '{{user}} te-a scos din conversație';
z.string.ro.notificationObfuscated = 'Ți-a trimis un mesaj';
z.string.ro.notificationObfuscatedTitle = 'Cineva';
z.string.ro.notificationPing = 'Pinguit';
z.string.ro.notificationReaction = '{{reaction}} la mesajul tău';
z.string.ro.notificationSharedAudio = 'A împărtășit un mesaj audio';
z.string.ro.notificationSharedFile = 'A distribuit un fișier';
z.string.ro.notificationSharedLocation = 'A distribuit o locație';
z.string.ro.notificationSharedVideo = 'A distribuit un video';
z.string.ro.notificationVoiceChannelActivate = 'Se sună';
z.string.ro.notificationVoiceChannelDeactivate = 'Apel în curs';

z.string.ro.tooltipConversationAllVerified = 'Toate amprentele sunt verificate';
z.string.ro.tooltipConversationCall = 'Sună';
z.string.ro.tooltipConversationEphemeral = 'Mesaj temporizat';
z.string.ro.tooltipConversationFile = 'Adaugă fișier';
z.string.ro.tooltipConversationInputPlaceholder = 'Scrie un mesaj';
z.string.ro.tooltipConversationInputPlaceholderAvailable = '{{user}} este disponibil';
z.string.ro.tooltipConversationInputPlaceholderAway = '{{user}} este plecat';
z.string.ro.tooltipConversationInputPlaceholderBusy = '{{user}} este ocupat';
z.string.ro.tooltipConversationPeople = 'Persoane ({{shortcut}})';
z.string.ro.tooltipConversationPicture = 'Adaugă poză';
z.string.ro.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.ro.tooltipConversationSearch = 'Caută';
z.string.ro.tooltipConversationVideoCall = 'Apel video';

z.string.ro.tooltipConversationsArchive = 'Arhivează ({{shortcut}})';
z.string.ro.tooltipConversationsArchived = 'Arată arhiva ({{number}})';
z.string.ro.tooltipConversationsMore = 'Mai multe';
z.string.ro.tooltipConversationsNotify = 'Demutizează ({{shortcut}})';
z.string.ro.tooltipConversationsPreferences = 'Deschide preferințele';
z.string.ro.tooltipConversationsSilence = 'Mutizează ({{shortcut}})';
z.string.ro.tooltipConversationsStart = 'Începe conversația ({{shortcut}})';

z.string.ro.tooltipConversationDetailsRename = 'Schimbă numele conversației';

z.string.ro.tooltipPreferencesContactsGmail = 'Autentifică-te în conturile Gmail pentru a partaja contacte';
z.string.ro.tooltipPreferencesContactsMacos = 'Partajează toate contactele de pe aplicația Contacts din macOS';
z.string.ro.tooltipPreferencesPassword = 'Deschide un alt site web pentru a reseta parola';
z.string.ro.tooltipPreferencesPicture = 'Schimbă poza de profil…';
z.string.ro.tooltipPreferencesRename = 'Schimbă numele tău';

z.string.ro.tooltipSearchClose = 'Închide (Esc)';

z.string.ro.initReceivedSelfUser = 'Bună, {{user}}.';
z.string.ro.initValidatedClient = 'Se încarcă conexiunile și conversațiile tale';
z.string.ro.initReceivedUserData = 'Verifică dacă sunt mesaje noi';
z.string.ro.initDecryption = 'Se decriptează mesaje';
z.string.ro.initEvents = 'Se încarcă mesaje';
z.string.ro.initUpdatedFromNotifications = 'Aproape gata - Bucură-te de Wire';
z.string.ro.initProgress = ' — {{number1}} din {{number2}}';

z.string.ro.ephemeralUnitsNone = 'Închis';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.ru.wire = 'Wire';
z.string.ru.wireMacos = 'Wire для macOS';
z.string.ru.wireWindows = 'Wire для Windows';
z.string.ru.wireLinux = 'Wire для Linux';
z.string.ru.nonexistentUser = 'Удаленный пользователь';
z.string.ru.and = 'и';
z.string.ru.enumerationAnd = ', и ';

//=Загрузка приложения
z.string.ru.authAccountCountryCode = 'Код страны';
z.string.ru.authAccountPasswordForgot = 'Восстановление пароля';
z.string.ru.authAccountPublicComputer = 'Это общедоступный компьютер';
z.string.ru.authAccountSignIn = 'Вход';
z.string.ru.authAccountSignInPhone = 'Вход с номером телефона';

z.string.ru.authBlockedCookies = 'Включите файлы cookie, чтобы войти в Wire.';
z.string.ru.authBlockedDatabase = 'Для отображения сообщений Wire необходим доступ к локальному хранилищу. Локальное хранилище недоступно в приватном режиме.';
z.string.ru.authBlockedTabs = 'Wire уже открыт в другой вкладке.';
z.string.ru.authBlockedTabsAction = 'Вместо этого использовать данную вкладку';

z.string.ru.authVerifyAccountAdd = 'Добавить';
z.string.ru.authVerifyAccountDetail = 'Это позволит использовать Wire на нескольких устройствах.';
z.string.ru.authVerifyAccountHeadline = 'Добавить email и пароль.';
z.string.ru.authVerifyAccountLogout = 'Выход';
z.string.ru.authVerifyCodeDescription = 'Введите код подтверждения,\nкоторый мы отправили на {{number}}.';
z.string.ru.authVerifyCodeResend = 'Не приходит код?';
z.string.ru.authVerifyCodeResendDetail = 'Отправить повторно';
z.string.ru.authVerifyCodeResendTimer = 'Вы можете запросить новый код {{expiration}}.';
z.string.ru.authVerifyCodeChangePhone = 'Изменить номер телефона';
z.string.ru.authVerifyPasswordHeadline = 'Введите свой пароль';

z.string.ru.authLimitDevicesHeadline = 'Устройства';
z.string.ru.authLimitDescription = 'Удалите одно из ваших устройств, чтобы начать использовать Wire на этом.';
z.string.ru.authLimitButtonManage = 'Управление';
z.string.ru.authLimitButtonSignOut = 'Выход';
z.string.ru.authLimitDevicesCurrent = '(Текущее)';

z.string.ru.authHistoryHeadline = 'Вы впервые используете Wire на этом устройстве.';
z.string.ru.authHistoryDescription = 'История разговоров не отображается из соображений конфиденциальности.';
z.string.ru.authHistoryReuseHeadline = 'Вы уже использовали Wire на этом устройстве.';
z.string.ru.authHistoryReuseDescription = 'Сообщения, отправленные в течение этого периода, не отображаются.';
z.string.ru.authHistoryButton = 'OK';

z.string.ru.authPostedResend = 'Отправить снова на {{email}}';
z.string.ru.authPostedResendAction = 'Не приходит письмо?';
z.string.ru.authPostedResendDetail = 'Проверьте свой почтовый ящик и следуйте инструкциям.';
z.string.ru.authPostedResendHeadline = 'Вам письмо.';

z.string.ru.authPlaceholderEmail = 'Email';
z.string.ru.authPlaceholderPasswordPut = 'Пароль';
z.string.ru.authPlaceholderPasswordSet = 'Пароль (минимум 8 символов)';
z.string.ru.authPlaceholderPhone = 'Номер телефона';

z.string.ru.authErrorCode = 'Неверный код';
z.string.ru.authErrorCountryCodeInvalid = 'Неверный код страны';
z.string.ru.authErrorEmailExists = 'Email уже используется';
z.string.ru.authErrorEmailForbidden = 'Извините, этот адрес email запрещен.';
z.string.ru.authErrorEmailMalformed = 'Пожалуйста, введите правильный email.';
z.string.ru.authErrorEmailMissing = 'Пожалуйста, введите email.';
z.string.ru.authErrorMisc = 'Проблемы с подключением. Пожалуйста, попробуйте еще раз.';
z.string.ru.authErrorNameShort = 'Введите имя длиной не менее 2 символов';
z.string.ru.authErrorOffline = 'Отсутствует подключение к интернету';
z.string.ru.authErrorPasswordShort = 'Выберите пароль длиной не менее 8 символов.';
z.string.ru.authErrorPasswordWrong = 'Неправильный пароль. Пожалуйста, попробуйте еще раз.';
z.string.ru.authErrorPending = 'Аккаунт пока не верифицирован';
z.string.ru.authErrorPhoneNumberBudget = 'Вы сделали слишком много попыток входа Попробуйте позже.';
z.string.ru.authErrorPhoneNumberForbidden = 'Извините, этот номер телефона запрещен.';
z.string.ru.authErrorPhoneNumberInvalid = 'Некорректный номер телефона';
z.string.ru.authErrorPhoneNumberUnknown = 'Неизвестный номер телефона';
z.string.ru.authErrorSuspended = 'Эта учетная запись заблокирована.';
z.string.ru.authErrorSignIn = 'Проверьте введенные данные и повторите попытку.';

z.string.ru.callStateOutgoing = 'Вызываем…';
z.string.ru.callStateConnecting = 'Подключение…';
z.string.ru.callStateIncoming = 'Вызывает…';
z.string.ru.callStateIncomingGroup = '{{user}} вызывает';
z.string.ru.callDecline = 'Отклонить';
z.string.ru.callAccept = 'Принять';
z.string.ru.callJoin = 'Присоединиться';
z.string.ru.callChooseSharedScreen = 'Выберите экран для совместного использования';
z.string.ru.callParticipants = '{{number}} участников';
z.string.ru.callNoCameraAccess = 'Нет доступа к камере';

z.string.ru.videoCallOverlayFitVideoLabel = 'Дважды щелкните чтобы вписать или заполнить видео в кадре';
z.string.ru.videoCallOverlayConversations = 'Разговоры';
z.string.ru.videoCallOverlayMute = 'Беззвучный';
z.string.ru.videoCallOverlayVideo = 'Видео';
z.string.ru.videoCallOverlayShareScreen = 'Поделиться экраном';
z.string.ru.videoCallOverlayHangUp = 'Завершить вызов';
z.string.ru.videoCallPaused = 'Видео приостановлено';
z.string.ru.videoCallScreenShareNotSupported = 'Ваш браузер не поддерживает совместное использование экрана';

z.string.ru.modalAcknowledgeAction = 'Ok';
z.string.ru.modalAcknowledgeHeadline = 'Что-то пошло не так';
z.string.ru.modalConfirmSecondary = 'Отмена';
z.string.ru.modalOptionSecondary = 'Отмена';

z.string.ru.modalAccountCreateAction = 'OK';
z.string.ru.modalAccountCreateHeadline = 'Создать аккаунт?';
z.string.ru.modalAccountCreateMessage = 'Создав учетную запись, вы потеряете историю разговоров в этой гостевой комнате.';

z.string.ru.modalAccountDeletionAction = 'Удалить';
z.string.ru.modalAccountDeletionHeadline = 'Удалить аккаунт';
z.string.ru.modalAccountDeletionMessage = 'Мы отправим вам сообщение по email или SMS. Перейдите по ссылке, чтобы окончательно удалить свой аккаунт.';

z.string.ru.modalAccountLeaveGuestRoomAction = 'Покинуть';
z.string.ru.modalAccountLeaveGuestRoomHeadline = 'Покинуть гостевую комнату?';
z.string.ru.modalAccountLeaveGuestRoomMessage = 'История беседы будет удалена. В следующий раз создайте учетную запись, если хотите чтобы она сохранялась.';

z.string.ru.modalAccountLogoutAction = 'Выход';
z.string.ru.modalAccountLogoutHeadline = 'Очистить данные?';
z.string.ru.modalAccountLogoutOption = 'Удалить всю личную информацию и разговоры на этом устройстве.';

z.string.ru.modalAccountNewDevicesSecondary = 'Управление';
z.string.ru.modalAccountNewDevicesHeadline = 'Ваш аккаунт использовался:';
z.string.ru.modalAccountNewDevicesFrom = 'На:';
z.string.ru.modalAccountNewDevicesMessage = 'Если вы этого не делали, удалите это устройство и измените пароль.';

z.string.ru.modalAccountRemoveDeviceAction = 'Удалить устройство';
z.string.ru.modalAccountRemoveDeviceHeadline = 'Удалить "{{device}}"';
z.string.ru.modalAccountRemoveDeviceMessage = 'Для удаления устройства требуется ввести пароль.';
z.string.ru.modalAccountRemoveDevicePlaceholder = 'Пароль';

z.string.ru.modalAssetTooLargeHeadline = 'Файл слишком большой';
z.string.ru.modalAssetTooLargeMessage = 'Вы можете отправлять файлы размером до {{number}}';

z.string.ru.modalAssetParallelUploadsHeadline = 'Слишком много файлов одновременно';
z.string.ru.modalAssetParallelUploadsMessage = 'Вы можете отправить до {{number}} файлов за раз.';

z.string.ru.modalCallEmptyConversationHeadline = 'Некому звонить';
z.string.ru.modalCallEmptyConversationMessage = 'Здесь никого не осталось.';

z.string.ru.modalCallEmptyLogHeadline = 'Вызовов нет';
z.string.ru.modalCallEmptyLogMessage = 'Для создания отчета об отладке нет ни одного вызова.';

z.string.ru.modalCallNoGroupVideoHeadline = 'В группах нет видеовызовов';
z.string.ru.modalCallNoGroupVideoMessage = 'Видеовызовы недоступны в групповых разговорах.';

z.string.ru.modalCallNoMicrophoneAction = 'Скажите мне, как';
z.string.ru.modalCallNoMicrophoneMessage = 'Для выполнения вызовов вашему браузеру необходим доступ к микрофону.';
z.string.ru.modalCallNoMicrophoneHeadline = 'Не удается позвонить без доступа к микрофону';

z.string.ru.modalCallSecondIncomingAction = 'Ответить';
z.string.ru.modalCallSecondIncomingHeadline = 'Ответить на вызов?';
z.string.ru.modalCallSecondIncomingMessage = 'Ваш текущий вызов будет завершен.';

z.string.ru.modalCallSecondOngoingAction = 'Завершить вызов';
z.string.ru.modalCallSecondOngoingHeadline = 'Завершить вызов на другом устройстве?';
z.string.ru.modalCallSecondOngoingMessage = 'Вы можете установить не более одного вызова.';

z.string.ru.modalCallSecondOutgoingAction = 'Позвонить';
z.string.ru.modalCallSecondOutgoingHeadline = 'Завершить текущий вызов?';
z.string.ru.modalCallSecondOutgoingMessage = 'Уже есть активный вызов в другом разговоре. Он будет завершен, если вы начнете новый.';

z.string.ru.modalConnectCancelAction = 'Да';
z.string.ru.modalConnectCancelHeadline = 'Отменить запрос?';
z.string.ru.modalConnectCancelMessage = 'Удалить запрос на добавление {{user}}.';
z.string.ru.modalConnectCancelSecondary = 'Нет';

z.string.ru.modalConnectAcceptAction = 'Связаться';
z.string.ru.modalConnectAcceptHeadline = 'Принять?';
z.string.ru.modalConnectAcceptMessage = 'Это свяжет вас с {{user}} и откроет разговор.';
z.string.ru.modalConnectAcceptSecondary = 'Игнорировать';

z.string.ru.modalConversationClearAction = 'Удалить';
z.string.ru.modalConversationClearHeadline = 'Удалить контент?';
z.string.ru.modalConversationClearMessage = 'Это очистит историю разговоров на всех ваших устройствах.';
z.string.ru.modalConversationClearOption = 'Также покинуть разговор';

z.string.ru.modalConversationDeleteMessageAction = 'Удалить';
z.string.ru.modalConversationDeleteMessageHeadline = 'Удалить только у меня?';
z.string.ru.modalConversationDeleteMessageMessage = 'Действие не может быть отменено.';

z.string.ru.modalConversationDeleteMessageEveryoneAction = 'Удалить';
z.string.ru.modalConversationDeleteMessageEveryoneHeadline = 'Удалить у всех?';
z.string.ru.modalConversationDeleteMessageEveryoneMessage = 'Действие не может быть отменено.';

z.string.ru.modalConversationLeaveAction = 'Покинуть';
z.string.ru.modalConversationLeaveHeadline = 'Покинуть разговор {{name}}?';
z.string.ru.modalConversationLeaveMessage = 'Вы не сможете отправлять и получать сообщения в этом разговоре.';

z.string.ru.modalConversationMessageTooLongHeadline = 'Сообщение слишком длинное';
z.string.ru.modalConversationMessageTooLongMessage = 'Вы можете отправлять сообщения длиной до {{number}} символов.';

z.string.ru.modalConversationNewDeviceAction = 'Отправить';
z.string.ru.modalConversationNewDeviceHeadlineOne = '{{user}} начал(а) использовать новое устройство';
z.string.ru.modalConversationNewDeviceHeadlineMany = '{{users}} начали использовать новые устройства';
z.string.ru.modalConversationNewDeviceHeadlineYou = '{{user}} начали использовать новое устройство';
z.string.ru.modalConversationNewDeviceIncomingCallAction = 'Принять вызов';
z.string.ru.modalConversationNewDeviceIncomingCallMessage = 'Вы действительно хотите принять вызов?';
z.string.ru.modalConversationNewDeviceMessage = 'Вы все еще хотите отправить ваше сообщение?';
z.string.ru.modalConversationNewDeviceOutgoingCallAction = 'Позвонить';
z.string.ru.modalConversationNewDeviceOutgoingCallMessage = 'Вы действительно хотите позвонить?';

z.string.ru.modalConversationNotConnectedHeadline = 'Никто не был добавлен в разговор';
z.string.ru.modalConversationNotConnectedMessageOne = '{{name}} не хочет, чтобы его добавляли в разговоры.';
z.string.ru.modalConversationNotConnectedMessageMany = 'Один из выбранных вами контактов не хочет, чтобы его добавляли в разговоры.';

z.string.ru.modalConversationRemoveAction = 'Удалить';
z.string.ru.modalConversationRemoveHeadline = 'Удалить?';
z.string.ru.modalConversationRemoveMessage = '{{user}} больше не сможет отправлять и получать сообщения в этом разговоре.';

z.string.ru.modalConversationRemoveGuestsAction = 'Удалить';
z.string.ru.modalConversationRemoveGuestsHeadline = 'Отключить доступ?';
z.string.ru.modalConversationRemoveGuestsMessage = 'Все гости и сервисы будут удалены из разговора. Новые гости и сервисы допущены не будут.';

z.string.ru.modalConversationRevokeLinkAction = 'Отозвать ссылку';
z.string.ru.modalConversationRevokeLinkHeadline = 'Отозвать эту ссылку?';
z.string.ru.modalConversationRevokeLinkMessage = 'Новые гости не смогут присоединиться по этой ссылке. На доступ текущих гостей это не повлияет.';

z.string.ru.modalConversationGuestOptionsAllowGuestMessage = 'Не удалось разрешить гостей и сервисы. Попробуйте снова.';
z.string.ru.modalConversationGuestOptionsDisableGuestMessage = 'Не удалось удалить гостей и сервисы. Попробуйте снова.';
z.string.ru.modalConversationGuestOptionsGetCodeMessage = 'Не удалось получить доступ по ссылке.';
z.string.ru.modalConversationGuestOptionsRequestCodeMessage = 'Не удалось запросить ссылку на доступ. Попробуйте снова.';
z.string.ru.modalConversationGuestOptionsRevokeCodeMessage = 'Не удалось отменить ссылку на доступ. Попробуйте снова.';
z.string.ru.modalConversationGuestOptionsToggleGuestsMessage = 'Не удалось изменить статус гостей.';

z.string.ru.modalConversationTooManyMembersHeadline = 'Эта группа заполнена';
z.string.ru.modalConversationTooManyMembersMessage = 'К разговору может присоединиться до {{number1}} человек. На текущий момент в комнате есть места еще для {{number2}} человек.';

z.string.ru.modalGifTooLargeHeadline = 'Выбранная анимация слишком большая';
z.string.ru.modalGifTooLargeMessage = 'Максимальный размер {{number}} МБ.';

z.string.ru.modalIntegrationUnavailableHeadline = 'Боты в настоящее время недоступны';
z.string.ru.modalIntegrationUnavailableMessage = 'Благодарим вас за интерес к ботам. В настоящее время сервис приостановлен, пока мы работаем над следующей версией. Следите за обновлениями.';

z.string.ru.modalPictureFileFormatHeadline = 'Не удается использовать это изображение';
z.string.ru.modalPictureFileFormatMessage = 'Выберите файл PNG или JPEG.';

z.string.ru.modalPictureTooLargeHeadline = 'Выбранное изображение слишком большое';
z.string.ru.modalPictureTooLargeMessage = 'Вы можете использовать изображения размером до {{number}} МБ.';

z.string.ru.modalPictureTooSmallHeadline = 'Изображение слишком маленькое';
z.string.ru.modalPictureTooSmallMessage = 'Выберите изображение размером не менее 320 x 320 пикселей.';

z.string.ru.modalImproveWireAction = 'Принять';
z.string.ru.modalImproveWireSecondary = 'Нет';
z.string.ru.modalImproveWireHeadline = 'Помогите нам сделать Wire лучше';
z.string.ru.modalImproveWireMessage = 'Я согласен с тем, что Wire может создавать и использовать анонимные отчеты об использовании и ошибках для улучшения приложения Wire. Я могу отозвать свое согласие в любое время.';

z.string.ru.modalServiceUnavailableHeadline = 'Добавление сервиса невозможно';
z.string.ru.modalServiceUnavailableMessage = 'В данный момент этот сервис недоступен.';

z.string.ru.modalSessionResetHeadline = 'Сессия была сброшена';
z.string.ru.modalSessionResetMessage1 = 'Если проблема не решена,';
z.string.ru.modalSessionResetMessageLink = 'cвяжитесь';
z.string.ru.modalSessionResetMessage2 = 'с нами.';

z.string.ru.modalUploadContactsAction = 'Повторить';
z.string.ru.modalUploadContactsMessage = 'Мы не получили вашу информацию. Повторите попытку импорта своих контактов.';

z.string.ru.modalUserBlockAction = 'Заблокировать';
z.string.ru.modalUserBlockHeadline = 'Заблокировать {{user}}?';
z.string.ru.modalUserBlockMessage = '{{user}} больше не сможет связаться с вами или добавить вас в групповые разговоры.';

z.string.ru.modalUserUnblockAction = 'Разблокировать';
z.string.ru.modalUserUnblockHeadline = 'Разблокировать?';
z.string.ru.modalUserUnblockMessage = '{{user}} вновь сможет связаться с вами и добавить вас в групповые разговоры.';

z.string.ru.modalNoCameraTitle = 'Нет доступа к камере';
z.string.ru.modalNoCameraMessage = 'У Wire нет доступа к камере.[br][faqLink]Прочтите эту статью[/faqLink], чтобы узнать, как это исправить.';

z.string.ru.connectionRequestConnect = 'Связаться';
z.string.ru.connectionRequestIgnore = 'Игнорировать';

z.string.ru.conversationGuestIndicator = 'Гость';
z.string.ru.userRemainingTimeHours = 'Осталось {{time}} час.';
z.string.ru.userRemainingTimeMinutes = 'Осталось менее {{time}} мин.';

z.string.ru.conversationYouNominative = 'вы';
z.string.ru.conversationYouDative = 'вы';
z.string.ru.conversationYouAccusative = 'вы';

z.string.ru.conversationConnectionAccepted = 'Добавлен(а)';
z.string.ru.conversationConnectionBlocked = 'Заблокирован(а)';
z.string.ru.conversationConnectionCancelRequest = 'Отменить запрос';
z.string.ru.conversationCreateTemporary = 'Вы присоединились к разговору';
z.string.ru.conversationCreateWith = ' с {{users}}';
z.string.ru.conversationDeviceStartedUsingOne = ' начал(а) использовать';
z.string.ru.conversationDeviceStartedUsingMany = ' начали использовать';
z.string.ru.conversationDeviceUnverified = ' деверифицировали одно из';
z.string.ru.conversationDeviceYourDevices = ' ваши устройства';
z.string.ru.conversationDeviceUserDevices = ' устройства {{user}}';
z.string.ru.conversationDeviceNewDeviceOne = ' новое устройство';
z.string.ru.conversationDeviceNewDeviceMany = ' новые устройства';
z.string.ru.conversationDeviceNewPeopleJoined = 'Присоединились новые участники.';
z.string.ru.conversationDeviceNewPeopleJoinedVerify = 'Верифицируйте устройства';
z.string.ru.conversationJustNow = 'Только что';
z.string.ru.conversationLocationLink = 'Открыть карту';
z.string.ru.conversationCreated = '[bold]{{name}}}[/bold] начал(а) разговор с {{users}}';
z.string.ru.conversationCreatedMore = '[bold]{{name}}[/bold] начал(а) разговор с {{users}} и еще [showmore]{{count}} [/showmore]';
z.string.ru.conversationCreatedName = '[bold]{{name}}[/bold] начал(а) разговор';
z.string.ru.conversationCreatedNameYou = '[bold]Вы[/bold] начали разговор';
z.string.ru.conversationCreatedYou = 'Вы начали разговор с {{users}}';
z.string.ru.conversationCreatedYouMore = 'Вы начали разговор с {{users}} и еще [showmore]{{count}}[/showmore]';
z.string.ru.conversationCreateWithMore = 'с {{users}}, и еще [showmore]{{count}}[/showmore]';
z.string.ru.conversationCreateTeam = 'со [showmore]всеми участниками команды[/showmore]';
z.string.ru.conversationCreateTeamGuest = 'со [showmore]всеми участниками команды и одним гостем[/showmore]';
z.string.ru.conversationCreateTeamGuests = 'со [showmore]всеми участниками команды и {{count}} гостями[/showmore]';
z.string.ru.conversationMemberJoined = '[bold]{{name}}[/bold] добавлен(а) {{users}} в разговор';
z.string.ru.conversationMemberJoinedYou = '[bold]Вы[/bold] добавлены {{users}} в разговор';
z.string.ru.conversationMemberJoinedMore = '[bold]{{name}}[/bold] добавил(а) к разговору {{users}} и еще [showmore]{{count}}[/showmore]';
z.string.ru.conversationMemberJoinedYouMore = '[bold]Вы[/bold] добавили к разговору {{users}} и еще [showmore]{{count}}[/showmore]';
z.string.ru.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] присоединился(-лась)';
z.string.ru.conversationMemberJoinedSelfYou = '[bold]Вы[/bold] присоединились';
z.string.ru.conversationMemberLeft = '[bold]{{name}}[/bold] покинул(а)';
z.string.ru.conversationMemberLeftYou = '[bold]Вы[/bold] покинули';
z.string.ru.conversationMemberRemoved = '[bold]{{name}}[/bold] удален(а) {{users}}';
z.string.ru.conversationMemberRemovedYou = '[bold]Вы[/bold] удалены {{users}}';
z.string.ru.conversationTeamLeft = '[bold]{{name}}[/bold] был удален из команды';
z.string.ru.conversationMessageDelivered = 'Доставлено';
z.string.ru.conversationRename = ' переименовал(а) разговор';
z.string.ru.conversationRenameYou = ' переименовали разговор';
z.string.ru.conversationUpdatedTimer = ' установил(а) таймер сообщения на {{time}}';
z.string.ru.conversationUpdatedTimerYou = ' установили таймер сообщения на {{time}}';
z.string.ru.conversationResetTimer = ' отключил(а) таймер сообщения';
z.string.ru.conversationResetTimerYou = ' отключили таймер сообщения';
z.string.ru.conversationResume = 'Начать разговор с {{users}}';
z.string.ru.conversationPing = ' отправил(а) пинг';
z.string.ru.conversationPingYou = ' отправили пинг';
z.string.ru.conversationToday = 'сегодня';
z.string.ru.conversationVoiceChannelDeactivate = ' звонил(а)';
z.string.ru.conversationVoiceChannelDeactivateYou = ' звонили';
z.string.ru.conversationYesterday = 'Вчера';
z.string.ru.conversationUnableToDecrypt1 = 'Сообщение от [highlight]{{user}}[/highlight] не было получено.';
z.string.ru.conversationUnableToDecrypt2 = 'Идентификатор устройства [highlight]{{user}}[/highlight] изменился. Сообщение не доставлено.';
z.string.ru.conversationUnableToDecryptLink = 'Почему?';
z.string.ru.conversationUnableToDecryptErrorMessage = 'Ошибка';
z.string.ru.conversationUnableToDecryptResetSession = 'Сбросить сессию';
z.string.ru.conversationMissedMessages = 'Вы не использовали это устройство продолжительное время. Некоторые сообщения могут не отображаться.';
z.string.ru.conversationAssetUploading = 'Загрузка…';
z.string.ru.conversationAssetDownloading = 'Загрузка…';
z.string.ru.conversationAssetUploadFailed = 'Ошибка отправки';
z.string.ru.conversationPlaybackError = 'Невозможно воспроизвести';
z.string.ru.conversationContextMenuCopy = 'Скопировать';
z.string.ru.conversationContextMenuEdit = 'Правка';
z.string.ru.conversationContextMenuDelete = 'Удалить у меня…';
z.string.ru.conversationContextMenuDeleteEveryone = 'Удалить у всех…';
z.string.ru.conversationContextMenuDownload = 'Загрузить';
z.string.ru.conversationContextMenuLike = 'Нравится';
z.string.ru.conversationContextMenuReply = 'Ответить';
z.string.ru.conversationContextMenuUnlike = 'Не нравится';
z.string.ru.conversationDeleteTimestamp = 'Удалено: {{date}}';
z.string.ru.conversationEditTimestamp = 'Изменено: {{date}}';
z.string.ru.conversationLikesCaption = '{{number}} участникам';
z.string.ru.conversationSendPastedFile = 'Изображение добавлено {{date}}';
z.string.ru.conversationSomeone = 'Кто-то';
z.string.ru.conversationTweetAuthor = ' в Twitter';
z.string.ru.conversationServicesWarning = 'Сервисы имеют доступ к содержимому этого разговора';

z.string.ru.groupCreationPreferencesAction = 'Вперед';
z.string.ru.groupCreationPreferencesErrorNameShort = 'Не менее 1 символа';
z.string.ru.groupCreationPreferencesErrorNameLong = 'Слишком много символов';
z.string.ru.groupCreationPreferencesHeader = 'Создать группу';
z.string.ru.groupCreationPreferencesPlaceholder = 'Имя группы';
z.string.ru.groupCreationParticipantsActionCreate = 'Готово';
z.string.ru.groupCreationParticipantsActionSkip = 'Пропустить';
z.string.ru.groupCreationParticipantsHeader = 'Добавить участников';
z.string.ru.groupCreationParticipantsHeaderWithCounter = 'Добавить участников ({{number}})';
z.string.ru.groupCreationParticipantsPlaceholder = 'Поиск по имени';
z.string.ru.groupSizeInfo = 'К групповому разговору может присоединиться до {{count}} участников. Видеовызовы возможны между вами и еще тремя участниками.';

z.string.ru.guestRoomConversationName = 'Гостевая комната';
z.string.ru.guestRoomToggleName = 'Разрешить гостей и сервисы';
z.string.ru.guestRoomToggleInfo = 'Открыть этот разговор для сервисов и людей не из вашей команды.';
z.string.ru.guestRoomToggleInfoExtended = 'Открыть этот разговор для сервисов и пользователей не из вашей команды. Вы всегда сможете изменить это позже.';

z.string.ru.guestRoomConversationBadge = 'Присутствуют гости';
z.string.ru.guestRoomConversationBadgeService = 'Сервисы активны';
z.string.ru.guestRoomConversationBadgeGuestAndService = 'Присутствуют гости и сервисы';

z.string.ru.guestRoomConversationHead = 'Участники не из вашей команды смогут присоединиться к этому разговору.';
z.string.ru.guestRoomConversationButton = 'Пригласить участников';

z.string.ru.collectionShowAll = 'Показать все {{number}}';
z.string.ru.collectionSectionLinks = 'Ссылки';
z.string.ru.collectionSectionImages = 'Изображения';
z.string.ru.collectionSectionFiles = 'Файлы';
z.string.ru.collectionSectionAudio = 'Аудиосообщения';

z.string.ru.fullsearchPlaceholder = 'Поиск текстовых сообщений';
z.string.ru.fullsearchNoResults = 'Ничего не найдено.';

z.string.ru.archiveHeader = 'Архивировать';

z.string.ru.conversationsAllArchived = 'Отправлено в архив';
z.string.ru.conversationsContacts = 'Контакты';
z.string.ru.conversationsConnectionRequestMany = '{{number}} ожидающих';
z.string.ru.conversationsConnectionRequestOne = '1 контакт ожидает';
z.string.ru.conversationsEmptyConversation = 'Групповой разговор';
z.string.ru.conversationsNoConversations = 'Начните разговор или создайте группу.';
z.string.ru.conversationsPopoverArchive = 'Архивировать';
z.string.ru.conversationsPopoverBlock = 'Блокировать…';
z.string.ru.conversationsPopoverCancel = 'Отменить запрос…';
z.string.ru.conversationsPopoverClear = 'Удалить контент…';
z.string.ru.conversationsPopoverLeave = 'Покинуть группу…';
z.string.ru.conversationsPopoverNotificationSettings = 'Уведомления…';
z.string.ru.conversationsPopoverNotify = 'Включить уведомления';
z.string.ru.conversationsPopoverSilence = 'Отключить уведомления';
z.string.ru.conversationsPopoverUnarchive = 'Разархивировать';

z.string.ru.conversationsSecondaryLineEphemeralMention = 'Вас упомянули';
z.string.ru.conversationsSecondaryLineEphemeralMentionGroup = 'Кто-то упомянул вас';
z.string.ru.conversationsSecondaryLineEphemeralMessage = 'Отправил(а) вам сообщение';
z.string.ru.conversationsSecondaryLineEphemeralMessageGroup = 'Кто-то прислал сообщение';
z.string.ru.conversationsSecondaryLineEphemeralReply = 'Ответил(а) вам';
z.string.ru.conversationsSecondaryLineEphemeralReplyGroup = 'Вам ответили';
z.string.ru.conversationsSecondaryLineIncomingCall = '{{user}} вызывает';
z.string.ru.conversationsSecondaryLinePeopleLeft = '{{number}} участник покинул';
z.string.ru.conversationsSecondaryLinePersonLeft = '{{user}} покинул(а)';
z.string.ru.conversationsSecondaryLinePersonRemoved = '{{user}} был удален(а)';
z.string.ru.conversationsSecondaryLinePersonRemovedTeam = '{{user}} был удален из команды';
z.string.ru.conversationsSecondaryLinePeopleAdded = '{{user}} участников были добавлены';
z.string.ru.conversationsSecondaryLinePersonAdded = '{{user}} был(а) добавлен(а)';
z.string.ru.conversationsSecondaryLinePersonAddedSelf = '{{user}} присоединился';
z.string.ru.conversationsSecondaryLinePersonAddedYou = '{{user}} добавил вас';
z.string.ru.conversationsSecondaryLineRenamed = '{{user}} переименовал разговор';
z.string.ru.conversationsSecondaryLineSummaryMessage = '{{number}} сообщение';
z.string.ru.conversationsSecondaryLineSummaryMessages = '{{number}} сообщений';
z.string.ru.conversationsSecondaryLineSummaryMention = '{{number}} упоминание';
z.string.ru.conversationsSecondaryLineSummaryMentions = '{{number}} упоминаний';
z.string.ru.conversationsSecondaryLineSummaryMissedCall = '{{number}} пропущенный вызов';
z.string.ru.conversationsSecondaryLineSummaryMissedCalls = '{{number}} пропущенных вызова';
z.string.ru.conversationsSecondaryLineSummaryPing = '{{number}} пинг';
z.string.ru.conversationsSecondaryLineSummaryPings = '{{number}} пингов'
z.string.ru.conversationsSecondaryLineSummaryReply = '{{number}} ответ';
z.string.ru.conversationsSecondaryLineSummaryReplies = '{{number}} ответов';
z.string.ru.conversationsSecondaryLineYouLeft = 'Вы покинули';
z.string.ru.conversationsSecondaryLineYouWereRemoved = 'Вы были удалены';

z.string.ru.takeoverSub = 'Зарегистрируйте свое уникальное имя в Wire.';
z.string.ru.takeoverLink = 'Подробнее';
z.string.ru.takeoverButtonChoose = 'Выбрать свое';
z.string.ru.takeoverButtonKeep = 'Оставить это';

z.string.ru.inviteMetaKeyMac = 'Cmd';
z.string.ru.inviteMetaKeyPc = 'Ctrl';
z.string.ru.inviteHintSelected = 'Нажмите {{metaKey}} + C для копирования';
z.string.ru.inviteHintUnselected = 'Выберите и нажмите {{metaKey}} + C';
z.string.ru.inviteHeadline = 'Пригласите друзей в Wire';
z.string.ru.inviteMessage = 'Я использую Wire. Ищи меня там по нику {{username}} или зайди на сайт get.wire.com.';
z.string.ru.inviteMessageNoEmail = 'Я использую Wire. Перейди на get.wire.com, чтобы связаться со мной.';

z.string.ru.extensionsBubbleButtonGif = 'Gif';

z.string.ru.extensionsGiphyButtonOk = 'Отправить';
z.string.ru.extensionsGiphyButtonMore = 'Еще';
z.string.ru.extensionsGiphyMessage = '{{tag}} • через giphy.com';
z.string.ru.extensionsGiphyNoGifs = 'Упс, нет GIF-ок';
z.string.ru.extensionsGiphyRandom = 'Случайно';

z.string.ru.addParticipantsConfirmLabel = 'Добавить';
z.string.ru.addParticipantsHeader = 'Добавить участников';
z.string.ru.addParticipantsHeaderWithCounter = 'Добавить участников ({{number}})';
z.string.ru.addParticipantsManageServices = 'Управление сервисами';
z.string.ru.addParticipantsManageServicesNoResults = 'Управление сервисами';
z.string.ru.addParticipantsNoServicesManager = 'Сервисы - это помощники, которые могут улучшить ваш рабочий процесс.';
z.string.ru.addParticipantsNoServicesMember = 'Сервисы - это помощники, которые могут улучшить ваш рабочий процесс. Чтобы включить их, обратитесь к администратору.';
z.string.ru.addParticipantsSearchPlaceholder = 'Поиск по имени';
z.string.ru.addParticipantsServiceConfirmButton = 'Добавить сервис';
z.string.ru.addParticipantsTabsPeople = 'Участники';
z.string.ru.addParticipantsTabsServices = 'Сервисы';

z.string.ru.conversationDetailsActionArchive = 'Архивировать';
z.string.ru.conversationDetailsActionAddParticipants = 'Добавить участников';
z.string.ru.conversationDetailsActionBlock = 'Блокировать…';
z.string.ru.conversationDetailsActionCancelRequest = 'Отменить запрос…';
z.string.ru.conversationDetailsActionClear = 'Удалить контент…';
z.string.ru.conversationDetailsActionConversationParticipants = 'Показать все ({{number}})';
z.string.ru.conversationDetailsActionCreateGroup = 'Создать группу';
z.string.ru.conversationDetailsActionDevices = 'Устройства';
z.string.ru.conversationDetailsActionGuestOptions = 'Гости и сервисы';
z.string.ru.conversationDetailsActionTimedMessages = 'Временные сообщения';
z.string.ru.conversationDetailsActionNotifications = 'Уведомления';
z.string.ru.conversationDetailsActionLeave = 'Покинуть группу';
z.string.ru.conversationDetailsGuestsOff = 'Выключены';
z.string.ru.conversationDetailsGuestsOn = 'Вкл.';
z.string.ru.conversationDetailsOptions = 'Настройки';
z.string.ru.conversationDetailsParticipantsServicesOne = 'Сервис';
z.string.ru.conversationDetailsParticipantsServicesMany = 'Сервисы';
z.string.ru.conversationDetailsParticipantsUsersOne = 'Участник';
z.string.ru.conversationDetailsParticipantsUsersMany = 'Участники';
z.string.ru.conversationDetailsPeople = 'Участники';
z.string.ru.conversationDetailsServices = 'Сервисы';

z.string.ru.conversationParticipantsTitle = 'Участники';
z.string.ru.conversationParticipantsSearchPlaceholder = 'Поиск по имени';

z.string.ru.groupParticipantActionBlock = 'Блокировать…';
z.string.ru.groupParticipantActionCancelRequest = 'Отменить запрос…';
z.string.ru.groupParticipantActionDevices = 'Устройства';
z.string.ru.groupParticipantActionIgnoreRequest = 'Игнорировать запрос';
z.string.ru.groupParticipantActionIncomingRequest = 'Принять запрос';
z.string.ru.groupParticipantActionLeave = 'Покинуть группу…';
z.string.ru.groupParticipantActionOpenConversation = 'Открыть разговор';
z.string.ru.groupParticipantActionPending = 'Ожидает';
z.string.ru.groupParticipantActionRemove = 'Удалить из группы';
z.string.ru.groupParticipantActionSelfProfile = 'Открыть профиль';
z.string.ru.groupParticipantActionSendRequest = 'Связаться';
z.string.ru.groupParticipantActionUnblock = 'Разблокировать…';

z.string.ru.guestOptionsCopyLink = 'Копировать ссылку';
z.string.ru.guestOptionsCopyLinkDone = 'Ссылка скопирована!';
z.string.ru.guestOptionsCreateLink = 'Создать ссылку';
z.string.ru.guestOptionsInfoHeader = 'Пригласить других пользователей ссылкой';
z.string.ru.guestOptionsInfoText = 'Любой, у кого есть ссылка, может присоединиться к разговору в течение 24 часов, даже если у них нет Wire.';
z.string.ru.guestOptionsRevokeLink = 'Отозвать ссылку…';
z.string.ru.guestOptionsTitle = 'Гости и сервисы';

z.string.ru.notificationSettingsTitle = 'Уведомления';
z.string.ru.notificationSettingsDisclaimer = 'Вы можете получать уведомления обо всем (включая аудио- и видеозвонки) или только когда кто-то упоминает вас или отвечает на одно из ваших сообщений.';
z.string.ru.notificationSettingsEverything = 'Все';
z.string.ru.notificationSettingsMentionsAndReplies = 'Упоминания и ответы';
z.string.ru.notificationSettingsNothing = 'Ничего';

z.string.ru.timedMessagesTitle = 'Временные сообщения';
z.string.ru.timedMessageDisclaimer = 'Временные сообщения будут включены для всех участников этого разговора.';

z.string.ru.participantDevicesDetailHeadline = 'Убедитесь, что этот отпечаток соответствует отпечатку, показанному на устройстве {{html1}}{{user}}{{html2}}.';
z.string.ru.participantDevicesDetailHowTo = 'Как это сделать?';
z.string.ru.participantDevicesDetailResetSession = 'Сбросить сессию';
z.string.ru.participantDevicesDetailShowMyDevice = 'Показать отпечаток моего устройства';
z.string.ru.participantDevicesDetailVerify = 'Верифицировано';

z.string.ru.participantDevicesHeader = 'Устройства';
z.string.ru.participantDevicesHeadline = 'Wire дает каждому устройству уникальный отпечаток. Сравните их с {{user}} и верифицируйте ваш разговор.';
z.string.ru.participantDevicesLearnMore = 'Подробнее';
z.string.ru.participantDevicesWhyVerify = 'Зачем верифицировать разговоры?';
z.string.ru.participantDevicesOutdatedClientMessage = '{{user}} использует устаревшую версию Wire. Устройства не отображаются.';

z.string.ru.participantDevicesSelfAllDevices = 'Показать все мои устройства';
z.string.ru.participantDevicesSelfFingerprint = 'Отпечаток устройства';

z.string.ru.userProfileButtonConnect = 'Связаться';
z.string.ru.userProfileButtonIgnore = 'Игнорировать';
z.string.ru.userProfileButtonUnblock = 'Разблокировать';

z.string.ru.preferencesAbout = 'О программе';
z.string.ru.preferencesAccount = 'Аккаунт';
z.string.ru.preferencesAV = 'Аудио / Видео';
z.string.ru.preferencesDeviceDetails = 'Сведения об устройстве';
z.string.ru.preferencesDevices = 'Устройства';
z.string.ru.preferencesHeadline = 'Параметры';
z.string.ru.preferencesOptions = 'Настройки';

z.string.ru.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.ru.preferencesAboutPrivacyPolicy = 'Политика конфиденциальности';
z.string.ru.preferencesAboutSupport = 'Поддержка';
z.string.ru.preferencesAboutSupportWebsite = 'Сайт поддержки';
z.string.ru.preferencesAboutSupportContact = 'Связаться с поддержкой';
z.string.ru.preferencesAboutTermsOfUse = 'Условия использования';
z.string.ru.preferencesAboutVersion = 'Версия {{version}}';
z.string.ru.preferencesAboutWebsite = 'Веб-сайт Wire';

z.string.ru.preferencesAccountAvaibilityUnset = 'Установить статус';
z.string.ru.preferencesAccountCreateTeam = 'Создать команду';
z.string.ru.preferencesAccountData = 'Разрешения на использование данных';
z.string.ru.preferencesAccountDataCheckbox = 'Отправлять анонимные данные';
z.string.ru.preferencesAccountDataDetail = 'Помогите сделать Wire лучше, отправляя анонимные отчеты об использовании и сбоях.';
z.string.ru.preferencesAccountDelete = 'Удалить аккаунт';
z.string.ru.preferencesAccountLeaveGuestRoom = 'Покинуть гостевую комнату';
z.string.ru.preferencesAccountLeaveGuestRoomDescription = 'Вы больше не сможете получить доступ к сообщениям в этом разговоре.';
z.string.ru.preferencesAccountLogOut = 'Выйти';
z.string.ru.preferencesAccountManageTeam = 'Управлять командой';
z.string.ru.preferencesAccountMarketingConsentCheckbox = 'Получать рассылку';
z.string.ru.preferencesAccountMarketingConsentDetail = 'Получать новости и обновления продуктов от Wire по электронной почте.';
z.string.ru.preferencesAccountResetPassword = 'Сбросить пароль';
z.string.ru.preferencesAccountTeam = 'в {{name}}';
z.string.ru.preferencesAccountUsernamePlaceholder = 'Ваше полное имя';
z.string.ru.preferencesAccountUsernameHint = 'Не менее 2 символов. Только a—z, 0—9 и _';
z.string.ru.preferencesAccountUsernameAvailable = 'Доступно';
z.string.ru.preferencesAccountUsernameErrorTaken = 'Уже занято';

z.string.ru.preferencesAVCamera = 'Камера';
z.string.ru.preferencesAVMicrophone = 'Микрофон';
z.string.ru.preferencesAVPermissionDetail = 'Включите в настройках вашего браузера';
z.string.ru.preferencesAVSpeakers = 'Динамики';
z.string.ru.preferencesAVTemporaryDisclaimer = 'Гости не могут начинать видеоконференции. Выберите камеру, которая будет использоваться если вы к ней присоединитесь.';
z.string.ru.preferencesAVNoCamera = 'У Wire нет доступа к камере.[br][faqLink]Прочтите эту статью[/faqLink], чтобы узнать, как это исправить.';
z.string.ru.preferencesAVTryAgain = 'Повторить попытку';

z.string.ru.preferencesDevicesActivatedOn = 'Активировано {{date}}';
z.string.ru.preferencesDevicesActive = 'Активные';
z.string.ru.preferencesDevicesActiveDetail = 'Если вам не знакомо какое-либо из устройств, удалите его и измените пароль.';
z.string.ru.preferencesDevicesCurrent = 'Текущее';
z.string.ru.preferencesDevicesFingerprint = 'Отпечаток ключа';
z.string.ru.preferencesDevicesFingerprintDetail = 'Wire присваивает каждому устройству уникальный отпечаток. Сравните их и верифицируйте ваши устройства и разговоры.';
z.string.ru.preferencesDevicesId = 'ID: ';
z.string.ru.preferencesDevicesRemove = 'Удалить…';
z.string.ru.preferencesDevicesRemoveCancel = 'Отмена';
z.string.ru.preferencesDevicesRemoveDetail = 'Удалите это устройство, если вы перестали им пользоваться. На этом устройстве сразу же будет осуществлен выход из аккаунта.';
z.string.ru.preferencesDevicesSessionConfirmation = 'Сессия была сброшена.';
z.string.ru.preferencesDevicesSessionDetail = 'Если отпечатки не совпадают, сбросьте сессию для создания новых ключей шифрования на обеих сторонах.';
z.string.ru.preferencesDevicesSessionReset = 'Сбросить сессию';
z.string.ru.preferencesDevicesSessionOngoing = 'Сброс сессии…';
z.string.ru.preferencesDevicesVerification = 'Верифицировано';

z.string.ru.preferencesOptionsAudio = 'Звуковые уведомления';
z.string.ru.preferencesOptionsAudioAll = 'Все';
z.string.ru.preferencesOptionsAudioAllDetail = 'Все звуки';
z.string.ru.preferencesOptionsAudioNone = 'Отключены';
z.string.ru.preferencesOptionsAudioNoneDetail = 'Тсссс!';
z.string.ru.preferencesOptionsAudioSome = 'Некоторые';
z.string.ru.preferencesOptionsAudioSomeDetail = 'Пинги и вызовы';
z.string.ru.preferencesOptionsContacts = 'Контакты';
z.string.ru.preferencesOptionsContactsGmail = 'Импортировать из Gmail';
z.string.ru.preferencesOptionsContactsMacos = 'Импортировать из Контактов';
z.string.ru.preferencesOptionsContactsDetail = 'Мы используем ваши контактные данные для связи с другими пользователями. Мы анонимизируем всю информацию и не делимся ею с кем-либо еще.';
z.string.ru.preferencesOptionsPopular = 'По многочисленным просьбам';
z.string.ru.preferencesOptionsEmojiReplaceCheckbox = 'Заменять текстовые смайлы на эмодзи';
z.string.ru.preferencesOptionsEmojiReplaceDetail = ':-) → [icon]';
z.string.ru.preferencesOptionsPreviewsSendCheckbox = 'Показывать предпросмотр отправляемых вами ссылок';
z.string.ru.preferencesOptionsPreviewsSendDetail = 'Эта опция не влияет на предварительный просмотр ссылок от других пользователей.';
z.string.ru.preferencesOptionsNotifications = 'Уведомления';
z.string.ru.preferencesOptionsNotificationsNone = 'Выключены';
z.string.ru.preferencesOptionsNotificationsObfuscate = 'Скрыть детали';
z.string.ru.preferencesOptionsNotificationsObfuscateMessage = 'Показать отправителя';
z.string.ru.preferencesOptionsNotificationsOn = 'Показать отправителя и сообщение';
z.string.ru.preferencesOptionsCallLogs = 'Устранение неполадок';
z.string.ru.preferencesOptionsCallLogsGet = 'Сохранить технический отчет о вызове';
z.string.ru.preferencesOptionsCallLogsDetail = 'Эта информация помогает службе поддержки Wire диагностировать проблемы, связанные с вызовами.';

z.string.ru.preferencesOptionsBackupHeader = 'История';
z.string.ru.preferencesOptionsBackupExportHeadline = 'Резервная копия разговоров';
z.string.ru.preferencesOptionsBackupExportSecondary = 'Создайте резервную копию, чтобы сохранить историю разговоров. Вы можете использовать ее для восстановления истории в случае потери или замены компьютера.\nФайл резервной копии не защищен сквозным шифрованием, поэтому храните его в надежном месте.';
z.string.ru.preferencesOptionsBackupImportHeadline = 'Восстановить из резервной копии';
z.string.ru.preferencesOptionsBackupImportSecondary = 'Восстановить историю можно только из резервной копии одной и той же платформы. Резервная копия перезапишет разговоры на этом устройстве.';

z.string.ru.backupExportGenericErrorHeadline = 'Не удалось сохранить файл';
z.string.ru.backupExportGenericErrorSecondary = 'Резервное копирование не завершено.';
z.string.ru.backupExportProgressHeadline = 'Подготовка…';
z.string.ru.backupExportProgressSecondary = 'Резервное копирование · {{processed}} из {{total}} — {{progress}}%';
z.string.ru.backupExportProgressCompressing = 'Подготовка файла резервной копии';
z.string.ru.backupExportSaveFileAction = 'Сохранить файл';
z.string.ru.backupExportSuccessHeadline = 'Резервная копия создана';
z.string.ru.backupExportSuccessSecondary = 'Это пригодится для восстановления истории в случае потери или замены компьютера.';
z.string.ru.backupImportGenericErrorHeadline = 'Что-то пошло не так';
z.string.ru.backupImportGenericErrorSecondary = 'Ваша история не может быть восстановлена.';
z.string.ru.backupImportAccountErrorHeadline = 'Несовместимая резервная копия';
z.string.ru.backupImportAccountErrorSecondary = 'Вы не можете восстановить историю из другой учетной записи.';
z.string.ru.backupImportVersionErrorHeadline = 'Несовместимая резервная копия';
z.string.ru.backupImportVersionErrorSecondary = 'Эта резервная копия была создана в более новой или устаревшей версии Wire и не может быть восстановлена.';
z.string.ru.backupImportIncompatibleErrorHeadline = 'Несовместимая резервная копия';
z.string.ru.backupImportIncompatibleErrorSecondary = 'Вы не можете восстановить историю из другой учетной записи.';
z.string.ru.backupImportOutdatedErrorHeadline = 'Несовместимая резервная копия';
z.string.ru.backupImportOutdatedErrorSecondary = 'Эта резервная копия была создана в более новой или устаревшей версии Wire и не может быть восстановлена.';
z.string.ru.backupImportProgressHeadline = 'Подготовка…';
z.string.ru.backupImportProgressSecondary = 'Восстановление истории · {{processed}} из {{total}} — {{progress}}%';
z.string.ru.backupImportSuccessHeadline = 'История восстановлена.';
z.string.ru.backupCancel = 'Отмена';
z.string.ru.backupTryAgain = 'Повторить попытку';

z.string.ru.searchConnect = 'Связаться';
z.string.ru.searchConnections = 'Контакты';
z.string.ru.searchContacts = 'Контакты';
z.string.ru.searchCreateGroup = 'Создать группу';
z.string.ru.searchCreateGuestRoom = 'Создать гостевую комнату';
z.string.ru.searchGroups = 'Группы';
z.string.ru.searchPeople = 'Участники';
z.string.ru.searchPlaceholder = 'Поиск по имени или нику';
z.string.ru.searchServicePlaceholder = 'Поиск по имени';
z.string.ru.searchServices = 'Сервисы';
z.string.ru.searchManageServices = 'Управление сервисами';
z.string.ru.searchManageServicesNoResults = 'Управление сервисами';
z.string.ru.searchNoServicesManager = 'Сервисы - это помощники, которые могут улучшить ваш рабочий процесс.';
z.string.ru.searchNoServicesMember = 'Сервисы - это помощники, которые могут улучшить ваш рабочий процесс. Чтобы включить их, обратитесь к администратору.';
z.string.ru.searchTeamGroups = 'Разговоры команды';
z.string.ru.searchTeamMembers = 'Участники команды';
z.string.ru.searchTopPeople = 'Топ-контакты';
z.string.ru.searchTrySearch = 'Ищите людей по\nимени или нику';
z.string.ru.searchNoContactsOnWire = 'У вас нет контактов в Wire.\nПопробуйте найти людей\nпо имени или нику.';
z.string.ru.searchMemberInvite = 'Пригласите пользователей в команду';
z.string.ru.searchOthers = 'Связаться';

z.string.ru.searchInvite = 'Пригласите друзей в Wire';
z.string.ru.searchInviteDetail = 'Доступ к контактам поможет установить связь с другими пользователями. Мы анонимизируем всю информацию и не делимся ею с кем-либо еще.';
z.string.ru.searchInviteButtonContacts = 'Из Контактов';
z.string.ru.searchInviteButtonGmail = 'Из Gmail';
z.string.ru.searchInviteHeadline = 'Приведи своих друзей';
z.string.ru.searchInviteShare = 'Пригласить друзей';

z.string.ru.searchServiceConfirmButton = 'Добавить сервис';

z.string.ru.searchListEveryoneParticipates = 'Все ваши контакты \nуже участвуют\nв этом разговоре.';
z.string.ru.searchListNoMatches = 'Совпадений не найдено.\nПопробуйте ввести другое имя.';

z.string.ru.temporaryGuestCta = 'Создать аккаунт';
z.string.ru.temporaryGuestDescription = 'Защитите свой бизнес зашифрованными групповыми сообщениями и вызовами.';
z.string.ru.temporaryGuestTimeRemaining = ' осталось в этой гостевой комнате';

z.string.ru.temporaryGuestJoinMessage = 'Этот разговор будет вам доступен в течение 24 часов.';
z.string.ru.temporaryGuestJoinDescription = 'Если вы закроете или обновите эту страницу, то потеряете доступ.';

z.string.ru.temporaryGuestLeaveMessage = ' больше не участвуете в этом разговоре.';
z.string.ru.temporaryGuestLeaveDescription = 'Если вы закроете или обновите эту страницу, то потеряете доступ к истории разговоров.';

z.string.ru.uploadGoogleHeadline = 'Найти людей с которыми\nможно поговорить.';
z.string.ru.uploadGoogleMessage = 'Мы используем ваши контактные данные для связи с другими пользователями. Мы анонимизируем всю информацию и не делимся ею с кем-либо еще.';

z.string.ru.urlSupportRoot = '/';
z.string.ru.urlSupportArticles = '/hc/ru/articles/';
z.string.ru.urlSupportRequests = '/hc/ru/requests/';
z.string.ru.urlWebappRoot = '/';
z.string.ru.urlWebsiteRoot = '/';
z.string.ru.urlWebsiteCreateTeam = '/ru/create-team/';
z.string.ru.urlWebsitePrivacy = '/ru/privacy';
z.string.ru.warningCallUnsupportedIncoming = '{{user}} вызывает. Ваш браузер не поддерживает вызовы.';
z.string.ru.warningCallUnsupportedOutgoing = 'Вы не можете позвонить, так как ваш браузер не поддерживает вызовы.';
z.string.ru.warningCallIssues = 'Эта версия Wire не может участвовать в вызове. Пожалуйста, используйте';
z.string.ru.warningCallUpgradeBrowser = 'Для совершения вызовов обновите Google Chrome.';
z.string.ru.warningConnectivityConnectionLost = 'Пытаемся подключиться. У Wire может не получиться доставить сообщения.';
z.string.ru.warningConnectivityNoInternet = 'Отсутствует подключение к интернету. Вы не можете отправлять и получать сообщения.';
z.string.ru.warningLearnMore = 'Подробнее';
z.string.ru.warningLifecycleUpdate = 'Доступна новая версия Wire.';
z.string.ru.warningLifecycleUpdateNotes = 'Что нового';
z.string.ru.warningLifecycleUpdateLink = 'Обновить сейчас';
z.string.ru.warningNotFoundCamera = 'Вы не можете позвонить, так как ваш компьютер нет имеет камеры.';
z.string.ru.warningNotFoundMicrophone = 'Вы не можете позвонить, так как ваш компьютер нет имеет микрофона.';
z.string.ru.warningPermissionDeniedCamera = 'Вы не можете позвонить, потому что ваш браузер не имеет доступа к камере.';
z.string.ru.warningPermissionDeniedMicrophone = 'Вы не можете позвонить, так как ваш браузер не имеет доступа к микрофону.';
z.string.ru.warningPermissionDeniedScreen = 'Вашему браузеру требуется разрешение для демонстрации экрана.';
z.string.ru.warningPermissionRequestCamera = '[icon] Разрешить доступ к камере';
z.string.ru.warningPermissionRequestMicrophone = '[icon] Разрешить доступ к микрофону';
z.string.ru.warningPermissionRequestNotification = '[icon] Разрешить уведомления';
z.string.ru.warningPermissionRequestScreen = '[icon] Разрешить доступ к экрану';

z.string.ru.userAvailabilityAvailable = 'Доступно';
z.string.ru.userAvailabilityAway = 'Отошел';
z.string.ru.userAvailabilityBusy = 'Занят';
z.string.ru.userAvailabilityNone = 'Нет';

z.string.ru.notificationAssetAdd = 'Поделился(-лась) картинкой';
z.string.ru.notificationConnectionAccepted = 'Принял(а) ваш запрос на добавление';
z.string.ru.notificationConnectionConnected = 'Теперь в списке контактов';
z.string.ru.notificationConnectionRequest = 'Хочет связаться';
z.string.ru.notificationConversationCreate = '{{user}} начал разговор';
z.string.ru.notificationConversationMessageTimerUpdate = '{{user}} установил(а) таймер сообщения на {{time}}';
z.string.ru.notificationConversationMessageTimerReset = '{{user}} отключил таймер сообщения';
z.string.ru.notificationConversationRename = '{{user}} переименовал разговор на {{name}}';
z.string.ru.notificationMemberJoinMany = '{{user}} добавил(а) {{number}} участник(ов) в разговор';
z.string.ru.notificationMemberJoinSelf = '{{user}} присоединился к разговору';
z.string.ru.notificationMemberJoinOne = '{{user1}} добавил(а) в разговор {{user2}}';
z.string.ru.notificationMemberLeaveRemovedYou = '{{user}} удалил(а) вас из разговора';
z.string.ru.notificationMention = 'Упоминание: {{text}}';
z.string.ru.notificationObfuscated = 'Отправил(а) вам сообщение';
z.string.ru.notificationObfuscatedMention = 'Вас упомянули';
z.string.ru.notificationObfuscatedReply = 'Ответил(а) вам';
z.string.ru.notificationObfuscatedTitle = 'Кто-то';
z.string.ru.notificationPing = 'Отправил(а) пинг';
z.string.ru.notificationReaction = '{{reaction}} ваше сообщение';
z.string.ru.notificationReply = 'Ответ: {{text}}';
z.string.ru.notificationSharedAudio = 'Поделился(-лась) аудиосообщением';
z.string.ru.notificationSharedFile = 'Поделился(-лась) файлом';
z.string.ru.notificationSharedLocation = 'Поделился(-лась) местоположением';
z.string.ru.notificationSharedVideo = 'Поделился(-лась) видео';
z.string.ru.notificationTitleGroup = '{{user}} в {{conversation}}';
z.string.ru.notificationVoiceChannelActivate = 'Вызывает';
z.string.ru.notificationVoiceChannelDeactivate = 'Звонил(а)';

z.string.ru.tooltipConversationAllVerified = 'Все отпечатки верифицированы';
z.string.ru.tooltipConversationCall = 'Вызов';
z.string.ru.tooltipConversationEphemeral = 'Временное сообщение';
z.string.ru.tooltipConversationFile = 'Добавить файл';
z.string.ru.tooltipConversationInputPlaceholder = 'Введите сообщение';
z.string.ru.tooltipConversationInputPlaceholderAvailable = '{{user}} доступен';
z.string.ru.tooltipConversationInputPlaceholderAway = '{{user}} отошел';
z.string.ru.tooltipConversationInputPlaceholderBusy = '{{user}} занят';
z.string.ru.tooltipConversationPeople = 'Участники ({{shortcut}})';
z.string.ru.tooltipConversationPicture = 'Добавить изображение';
z.string.ru.tooltipConversationPing = 'Пинг ({{shortcut}})';
z.string.ru.tooltipConversationSearch = 'Поиск';
z.string.ru.tooltipConversationVideoCall = 'Видеовызов';

z.string.ru.tooltipConversationsArchive = 'Архивировать ({{shortcut}})';
z.string.ru.tooltipConversationsArchived = 'Показать архив ({{number}})';
z.string.ru.tooltipConversationsMore = 'Больше';
z.string.ru.tooltipConversationsNotifications = 'Открыть настройки уведомлений ({{shortcut}})';
z.string.ru.tooltipConversationsNotify = 'Включить уведомления ({{shortcut}})';
z.string.ru.tooltipConversationsPreferences = 'Открыть настройки';
z.string.ru.tooltipConversationsSilence = 'Отключить уведомления ({{shortcut}})';
z.string.ru.tooltipConversationsStart = 'Начать разговор ({{shortcut}})';

z.string.ru.tooltipConversationDetailsAddPeople = 'Добавить участников в разговор ({{shortcut}})';
z.string.ru.tooltipConversationDetailsRename = 'Изменить название разговора';

z.string.ru.tooltipPreferencesContactsGmail = 'Войдите в свой аккаунт Gmail, чтобы поделиться контактами';
z.string.ru.tooltipPreferencesContactsMacos = 'Поделитесь своими контактами из приложения macOS Контакты';
z.string.ru.tooltipPreferencesPassword = 'Открыть страницу сброса пароля';
z.string.ru.tooltipPreferencesPicture = 'Изменить свое фото…';
z.string.ru.tooltipPreferencesRename = 'Изменить свое имя';

z.string.ru.tooltipSearchClose = 'Закрыть (Esc)';

z.string.ru.initReceivedSelfUser = 'Здравствуйте, {{user}}.';
z.string.ru.initValidatedClient = 'Получение ваших контактов и разговоров';
z.string.ru.initReceivedUserData = 'Проверка новых сообщений';
z.string.ru.initDecryption = 'Расшифровка сообщений';
z.string.ru.initEvents = 'Загрузка сообщений';
z.string.ru.initUpdatedFromNotifications = 'Почти готово - наслаждайтесь Wire';
z.string.ru.initProgress = ' — {{number1}} из {{number2}}';

z.string.ru.ephemeralUnitsNone = 'Выключены';
z.string.ru.ephemeralUnitsSecond = 'сек.';
z.string.ru.ephemeralUnitsSeconds = 'сек.';
z.string.ru.ephemeralUnitsMinute = 'мин.';
z.string.ru.ephemeralUnitsMinutes = 'мин.';
z.string.ru.ephemeralUnitsHour = 'час';
z.string.ru.ephemeralUnitsHours = 'час.';
z.string.ru.ephemeralUnitsDay = 'день';
z.string.ru.ephemeralUnitsDays = 'дн.';
z.string.ru.ephemeralUnitsWeek = 'нед.';
z.string.ru.ephemeralUnitsWeeks = 'нед.';
z.string.ru.ephemeralUnitsYear = 'г.';
z.string.ru.ephemeralUnitsYears = 'г.';
z.string.ru.ephemeralRemaining = 'осталось';

z.string.ru.replyAudioMessage = 'Аудиосообщение';
z.string.ru.replyQuoteError = 'Вы не можете увидеть это сообщение.';
z.string.ru.replyQuoteShowMore = 'Развернуть';
z.string.ru.replyQuoteShowLess = 'Свернуть';
z.string.ru.replyQuoteTimeStampDate = 'Исходное сообщение от {{date}}';
z.string.ru.replyQuoteTimeStampTime = 'Исходное сообщение от {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.sk.wire = 'Wire';
z.string.sk.wireMacos = 'Wire pre macOS';
z.string.sk.wireWindows = 'Wire pre Windows';
z.string.sk.wireLinux = 'Wire pre Linux';
z.string.sk.nonexistentUser = 'Odstránený používateľ';
z.string.sk.and = 'a';

z.string.sk.authAccountCountryCode = 'Kód krajiny';
z.string.sk.authAccountPasswordForgot = 'Zabudnuté heslo';
z.string.sk.authAccountPublicComputer = 'Toto je verejný počítač';
z.string.sk.authAccountSignIn = 'Prihlásenie';
z.string.sk.authAccountSignInPhone = 'Telefón';

z.string.sk.authBlockedCookies = 'Povoľte cookies na prihlásenie k Wire.';
z.string.sk.authBlockedDatabase = 'Pre zobrazenie Vašich správ potrebuje Wire prístup k lokálnemu úložisku. Lokálne úložisko nie je dostupné v privátnom režime.';
z.string.sk.authBlockedTabs = 'Wire je už otvorený na inej karte.';

z.string.sk.authVerifyAccountAdd = 'Pridať';
z.string.sk.authVerifyAccountDetail = 'To vám umožní používať Wire na viacerých zariadeniach.';
z.string.sk.authVerifyAccountHeadline = 'Pridať e-mailovú adresu a heslo.';
z.string.sk.authVerifyAccountLogout = 'Odhlásenie';
z.string.sk.authVerifyCodeDescription = 'Zadajte overovací kód, ktorý sme zaslali na {{number}}.';
z.string.sk.authVerifyCodeResend = 'Žiadny kód sa neukázal?';
z.string.sk.authVerifyCodeResendDetail = 'Poslať znovu';
z.string.sk.authVerifyCodeResendTimer = 'Môžete požiadať o nový kód {{expiration}}.';
z.string.sk.authVerifyCodeChangePhone = 'Zmeniť telefónne číslo';
z.string.sk.authVerifyPasswordHeadline = 'Zadajte Vaše heslo';

z.string.sk.authLimitDevicesHeadline = 'Zariadenia';
z.string.sk.authLimitDescription = 'Odstráňte jedno z Vašich iných zariadení aby ste mohli používať Wire na tomto.';
z.string.sk.authLimitButtonManage = 'Správa zariadení';
z.string.sk.authLimitButtonSignOut = 'Odhlásenie';
z.string.sk.authLimitDevicesCurrent = '(Aktuálne)';

z.string.sk.authHistoryHeadline = 'Je to prvýkrát čo používate Wire na tomto zariadení.';
z.string.sk.authHistoryDescription = 'Z dôvodu ochrany osobných údajov sa tu Vaše rozhovory nezobrazia.';
z.string.sk.authHistoryReuseHeadline = 'Použili ste Wire na tomto zariadení.';
z.string.sk.authHistoryReuseDescription = 'Medzičasom odoslané správy sa tu nezobrazia.';
z.string.sk.authHistoryButton = 'OK';

z.string.sk.authPostedResend = 'Znovu odoslať na {{email}}';
z.string.sk.authPostedResendAction = 'Žiadny e-mail sa nezobrazil?';
z.string.sk.authPostedResendDetail = 'Skontrolujte Vašu e-mailovú schránku a postupujte podľa pokynov.';
z.string.sk.authPostedResendHeadline = 'Máte e-mail.';

z.string.sk.authPlaceholderEmail = 'E-mail';
z.string.sk.authPlaceholderPasswordPut = 'Heslo';
z.string.sk.authPlaceholderPasswordSet = 'Heslo (minimálne 8 znakov)';
z.string.sk.authPlaceholderPhone = 'Telefónne číslo';

z.string.sk.authErrorCode = 'Neplatný kód';
z.string.sk.authErrorCountryCodeInvalid = 'Neplatný kód krajiny';
z.string.sk.authErrorEmailExists = 'E-mailová adresa sa už používa';
z.string.sk.authErrorEmailForbidden = 'Prepáčte. Táto emailová adresa je zakázaná.';
z.string.sk.authErrorEmailMalformed = 'Prosím, zadajte platnú e-mailovú adresu.';
z.string.sk.authErrorEmailMissing = 'Zdajte e-mailovú adresu.';
z.string.sk.authErrorMisc = 'Problémy s pripojením. Prosím skúste to znova.';
z.string.sk.authErrorNameShort = 'Zadajte meno s minimálne 2 znakmi';
z.string.sk.authErrorOffline = 'Žiadne internetové pripojenie';
z.string.sk.authErrorPasswordShort = 'Heslo musí obsahovať minimálne 8 znakov.';
z.string.sk.authErrorPasswordWrong = 'Zlé heslo, prosím skúste to znova.';
z.string.sk.authErrorPhoneNumberBudget = 'Prihlasujete sa príliš často. Skúste znova neskôr.';
z.string.sk.authErrorPhoneNumberForbidden = 'Prepáčte. Toto telefónne číslo je zakázané.';
z.string.sk.authErrorPhoneNumberInvalid = 'Neplatné telefónne číslo';
z.string.sk.authErrorPhoneNumberUnknown = 'Neznáme telefónne číslo';
z.string.sk.authErrorSuspended = 'Toto konto už nemá povolené prihlásenie.';
z.string.sk.authErrorSignIn = 'Prosím, skontrolujte svoje údaje a skúste to znova.';

z.string.sk.callStateOutgoing = 'Zvoní…';
z.string.sk.callStateConnecting = 'Pripájanie…';
z.string.sk.callStateIncoming = 'Volanie…';
z.string.sk.callDecline = 'Odmietnuť';
z.string.sk.callAccept = 'Prijať';
z.string.sk.callJoin = 'Pripojiť';
z.string.sk.callChooseSharedScreen = 'Vybrať obrazovku pre zdieľanie';
z.string.sk.callParticipants = '{{number}} je dostupné';

z.string.sk.videoCallOverlayMute = 'Stlmiť';
z.string.sk.videoCallOverlayHangUp = 'Ukončiť';

z.string.sk.modalAcknowledgeAction = 'OK';
z.string.sk.modalConfirmSecondary = 'Zrušiť';
z.string.sk.modalOptionSecondary = 'Zrušiť';

z.string.sk.modalAccountCreateAction = 'OK';

z.string.sk.modalAccountDeletionAction = 'Zmazať';
z.string.sk.modalAccountDeletionHeadline = 'Vymazať účet';
z.string.sk.modalAccountDeletionMessage = 'Zašleme Vám e-mail, alebo SMS. Použite odkaz pre trvalé zmazanie Vášho účtu.';

z.string.sk.modalAccountLeaveGuestRoomAction = 'Opustiť';

z.string.sk.modalAccountLogoutAction = 'Odhlásenie';
z.string.sk.modalAccountLogoutHeadline = 'Vymazať údaje?';
z.string.sk.modalAccountLogoutOption = 'Odstrániť všetky vaše osobné údaje a rozhovory na tomto zariadení.';

z.string.sk.modalAccountNewDevicesSecondary = 'Správa zariadení';
z.string.sk.modalAccountNewDevicesHeadline = 'Váš účet bol použitý:';
z.string.sk.modalAccountNewDevicesFrom = 'Od:';
z.string.sk.modalAccountNewDevicesMessage = 'Ak ste to neboli Vy, odpojte zariadenie a zmeňte si heslo.';

z.string.sk.modalAccountRemoveDeviceAction = 'Odstrániť zariadenie';
z.string.sk.modalAccountRemoveDeviceHeadline = 'Odstrániť "{{device}}"';
z.string.sk.modalAccountRemoveDeviceMessage = 'Na odstránenie zariadenia je potrebné Vaše heslo.';
z.string.sk.modalAccountRemoveDevicePlaceholder = 'Heslo';

z.string.sk.modalAssetTooLargeMessage = 'Môžete posielať súbory až do {{number}}';

z.string.sk.modalAssetParallelUploadsMessage = 'Súčasne môžete poslať až {{number}} súborov.';

z.string.sk.modalCallEmptyConversationHeadline = 'Nie je koho zavolať';
z.string.sk.modalCallEmptyConversationMessage = 'Už tu nikto nezostal.';

z.string.sk.modalCallNoGroupVideoHeadline = 'Žiadne video hovory v skupinách';
z.string.sk.modalCallNoGroupVideoMessage = 'Videohovory nie sú k dispozícii v skupinovom rozhovore.';

z.string.sk.modalCallNoMicrophoneAction = 'Povedz mi, ako';
z.string.sk.modalCallNoMicrophoneMessage = 'Pre volanie potrebuje Váš prehliadač prístup k mikrofónu.';
z.string.sk.modalCallNoMicrophoneHeadline = 'Nemôžete volať bez mikrofónu';

z.string.sk.modalCallSecondIncomingAction = 'Odpovedať';
z.string.sk.modalCallSecondIncomingHeadline = 'Prijať hovor?';
z.string.sk.modalCallSecondIncomingMessage = 'Váš aktuálny hovor sa ukončí.';

z.string.sk.modalCallSecondOngoingAction = 'Ukončiť';
z.string.sk.modalCallSecondOngoingHeadline = 'Ukončiť hovor na inom zariadení?';
z.string.sk.modalCallSecondOngoingMessage = 'Súčasne môžete viesť len jeden hovor.';

z.string.sk.modalCallSecondOutgoingAction = 'Ukončiť';
z.string.sk.modalCallSecondOutgoingHeadline = 'Ukončiť aktuálny hovor?';
z.string.sk.modalCallSecondOutgoingMessage = 'Súčasne môžete viesť len jeden hovor.';

z.string.sk.modalConnectCancelAction = 'Áno';
z.string.sk.modalConnectCancelHeadline = 'Zrušiť požiadavku?';
z.string.sk.modalConnectCancelMessage = 'Odstrániť požiadavku na pripojenie k {{user}}.';
z.string.sk.modalConnectCancelSecondary = 'Nie';

z.string.sk.modalConnectAcceptAction = 'Pripojiť';
z.string.sk.modalConnectAcceptHeadline = 'Prijať?';
z.string.sk.modalConnectAcceptMessage = 'Toto Vás spojí a otvorí rozhovor s {{user}}.';
z.string.sk.modalConnectAcceptSecondary = 'Ignorovať';

z.string.sk.modalConversationClearAction = 'Zmazať';
z.string.sk.modalConversationClearHeadline = 'Vymazať obsah?';
z.string.sk.modalConversationClearOption = 'Opustiť tiež rozhovor';

z.string.sk.modalConversationDeleteMessageAction = 'Zmazať';
z.string.sk.modalConversationDeleteMessageHeadline = 'Zmazať iba pre mňa?';
z.string.sk.modalConversationDeleteMessageMessage = 'Táto akcia sa nedá vrátiť.';

z.string.sk.modalConversationDeleteMessageEveryoneAction = 'Zmazať';
z.string.sk.modalConversationDeleteMessageEveryoneHeadline = 'Zmazať pre všetkých?';
z.string.sk.modalConversationDeleteMessageEveryoneMessage = 'Táto akcia sa nedá vrátiť.';

z.string.sk.modalConversationLeaveAction = 'Opustiť';
z.string.sk.modalConversationLeaveMessage = 'Nebudete môcť odosielať ani prijímať správy v tomto rozhovore.';

z.string.sk.modalConversationMessageTooLongHeadline = 'Správa je príliš dlhá';
z.string.sk.modalConversationMessageTooLongMessage = 'Môžete odosielať správy až do {{number}} znakov.';

z.string.sk.modalConversationNewDeviceHeadlineOne = '{{user}} začal používať nové zariadenie';
z.string.sk.modalConversationNewDeviceHeadlineMany = '{{user}}s začali používať nové zariadenie';
z.string.sk.modalConversationNewDeviceHeadlineYou = '{{user}} začal používať nové zariadenie';
z.string.sk.modalConversationNewDeviceIncomingCallAction = 'Prijať hovor';
z.string.sk.modalConversationNewDeviceIncomingCallMessage = 'Stále chcete prijať hovor?';
z.string.sk.modalConversationNewDeviceMessage = 'Stále chcete odoslať Vaše správy?';
z.string.sk.modalConversationNewDeviceOutgoingCallAction = 'Aj tak zavolať';
z.string.sk.modalConversationNewDeviceOutgoingCallMessage = 'Stále chcete zavolať?';

z.string.sk.modalConversationNotConnectedHeadline = 'Nikto nebol pridaný do konverzácie';
z.string.sk.modalConversationNotConnectedMessageOne = '{{name}} nechce byť pridaný do konverzácií.';
z.string.sk.modalConversationNotConnectedMessageMany = 'Jeden z ľudí, ktorých ste vybrali, nechce byť pridaný do konverzácií.';

z.string.sk.modalConversationRemoveAction = 'Odstrániť';
z.string.sk.modalConversationRemoveHeadline = 'Odstrániť?';
z.string.sk.modalConversationRemoveMessage = '{{user}} nebude môcť odosielať ani prijímať správy v tomto rozhovore.';

z.string.sk.modalConversationRemoveGuestsAction = 'Odstrániť';

z.string.sk.modalConversationTooManyMembersHeadline = 'Priveľa účastníkov';

z.string.sk.modalIntegrationUnavailableHeadline = 'Boti sú momentálne nedostupní';
z.string.sk.modalIntegrationUnavailableMessage = 'Ďakujeme o Váš záujem o Botov. Služba je momentálne pozastavená kvôli práci na novej verzii.';


z.string.sk.modalImproveWireAction = 'Prijať';
z.string.sk.modalImproveWireSecondary = 'Nie';

z.string.sk.modalSessionResetHeadline = 'Relácia bola obnovená';
z.string.sk.modalSessionResetMessage1 = 'Ak problém nebol vyriešený,';
z.string.sk.modalSessionResetMessageLink = 'kontakt';
z.string.sk.modalSessionResetMessage2 = 'nás.';

z.string.sk.modalUploadContactsAction = 'Skúsiť znova';
z.string.sk.modalUploadContactsMessage = 'Neprijali sme Vaše informácie. Skúste prosím znovu importovať Vaše kontakty.';

z.string.sk.modalUserBlockAction = 'Blokovať';
z.string.sk.modalUserBlockHeadline = 'Blokovať {{user}}?';
z.string.sk.modalUserBlockMessage = '{{user}} Vás nebude môcť kontaktovať, alebo Vás pozvať do skupinového rozhovoru.';

z.string.sk.modalUserUnblockAction = 'Odblokovať';
z.string.sk.modalUserUnblockHeadline = 'Odblokovať?';
z.string.sk.modalUserUnblockMessage = '{{user}} Vás bude môcť kontaktovať, alebo Vás pozvať do skupinového rozhovoru.';

z.string.sk.connectionRequestConnect = 'Pripojiť';
z.string.sk.connectionRequestIgnore = 'Ignorovať';

z.string.sk.conversationGuestIndicator = 'Hosť';

z.string.sk.conversationYouNominative = 'Vy';
z.string.sk.conversationYouDative = 'Vy';
z.string.sk.conversationYouAccusative = 'Vy';

z.string.sk.conversationConnectionAccepted = 'Pripojené';
z.string.sk.conversationConnectionBlocked = 'Blokované';
z.string.sk.conversationConnectionCancelRequest = 'Zrušiť požiadavku na pripojenie';
z.string.sk.conversationDeviceStartedUsingOne = ' začal používať';
z.string.sk.conversationDeviceStartedUsingMany = ' začal používať';
z.string.sk.conversationDeviceUnverified = ' neoverený jeden z';
z.string.sk.conversationDeviceYourDevices = ' Vaše zariadenia';
z.string.sk.conversationDeviceUserDevices = ' {{user}}´s zariadenia';
z.string.sk.conversationDeviceNewDeviceOne = ' nové zariadenie';
z.string.sk.conversationDeviceNewDeviceMany = ' nové zariadenia';
z.string.sk.conversationDeviceNewPeopleJoinedVerify = ' overiť zariadenia';
z.string.sk.conversationJustNow = 'Práve teraz';
z.string.sk.conversationLocationLink = 'Otvoriť mapu';
z.string.sk.conversationMessageDelivered = 'Doručená';
z.string.sk.conversationRename = ' premenoval rozhovor';
z.string.sk.conversationRenameYou = ' premenoval rozhovor';
z.string.sk.conversationResume = 'Začať rozhovor s {{users}}';
z.string.sk.conversationPing = ' pingol';
z.string.sk.conversationPingYou = ' pingol';
z.string.sk.conversationToday = 'dnes';
z.string.sk.conversationVoiceChannelDeactivate = ' volaný';
z.string.sk.conversationVoiceChannelDeactivateYou = ' volaný';
z.string.sk.conversationYesterday = 'Včera';
z.string.sk.conversationUnableToDecrypt1 = 'správa od {{user}} nebola prijatá.';
z.string.sk.conversationUnableToDecrypt2 = '{{user}}´s zariadenie sa zmenilo. Nedoručená správa.';
z.string.sk.conversationUnableToDecryptLink = 'Prečo?';
z.string.sk.conversationUnableToDecryptErrorMessage = 'Chyba';
z.string.sk.conversationUnableToDecryptResetSession = 'Obnovenie spojenia';
z.string.sk.conversationMissedMessages = 'Na chvíľu ste nepoužili toto zariadenie. Niektoré správy sa nemusia zobraziť.';
z.string.sk.conversationAssetDownloading = 'Sťahovanie…';
z.string.sk.conversationAssetUploadFailed = 'Nahrávanie zlyhalo';
z.string.sk.conversationPlaybackError = 'Prehrávanie sa nepodarilo';
z.string.sk.conversationContextMenuCopy = 'Kopírovať';
z.string.sk.conversationContextMenuEdit = 'Upraviť';
z.string.sk.conversationContextMenuDelete = 'Vymazať pre mňa';
z.string.sk.conversationContextMenuDeleteEveryone = 'Vymazať pre všetkých';
z.string.sk.conversationContextMenuDownload = 'Stiahnuť';
z.string.sk.conversationContextMenuLike = 'Páči sa';
z.string.sk.conversationContextMenuUnlike = 'Nepáči sa';
z.string.sk.conversationDeleteTimestamp = 'Odstránené {{date}}';
z.string.sk.conversationEditTimestamp = 'Upravené {{date}}';
z.string.sk.conversationLikesCaption = '{{number}} ľudí';
z.string.sk.conversationSendPastedFile = 'Vložený obrázok {{date}}';
z.string.sk.conversationSomeone = 'Niekto';
z.string.sk.conversationTweetAuthor = ' na Twitteri';

z.string.sk.groupCreationParticipantsPlaceholder = 'Vyhľadať podľa mena';


z.string.sk.collectionShowAll = 'Zobraziť všetky {{number}}';
z.string.sk.collectionSectionLinks = 'Odkazy';
z.string.sk.collectionSectionImages = 'Obrázky';
z.string.sk.collectionSectionFiles = 'Súbory';
z.string.sk.collectionSectionAudio = 'Zvukové správy';

z.string.sk.fullsearchPlaceholder = 'Vyhľadať textové správy';
z.string.sk.fullsearchNoResults = 'Žiadne výsledky.';

z.string.sk.archiveHeader = 'Archív';

z.string.sk.conversationsAllArchived = 'Všetko archivované';
z.string.sk.conversationsContacts = 'Kontakty';
z.string.sk.conversationsConnectionRequestMany = '{{number}} ľudí čaká';
z.string.sk.conversationsConnectionRequestOne = '1 osoba čaká';
z.string.sk.conversationsEmptyConversation = 'Skupinová konverzácia';
z.string.sk.conversationsNoConversations = 'Zatiaľ žiadne konverzácie';
z.string.sk.conversationsPopoverArchive = 'Archív';
z.string.sk.conversationsPopoverCancel = 'Zrušiť požiadavku';
z.string.sk.conversationsPopoverNotify = 'Zapnúť zvuk';
z.string.sk.conversationsPopoverSilence = 'Stlmiť';
z.string.sk.conversationsPopoverUnarchive = 'Zrušiť archiváciu';

z.string.sk.conversationsSecondaryLineEphemeralMessage = 'Poslal Vám správu';
z.string.sk.conversationsSecondaryLinePeopleLeft = '{{number}} ľudí zostáva';
z.string.sk.conversationsSecondaryLinePersonLeft = '{{user}} zostáva';
z.string.sk.conversationsSecondaryLinePersonRemoved = '{{user}} bol odstránený';
z.string.sk.conversationsSecondaryLinePeopleAdded = '{{user}} ľudia boli pridaní';
z.string.sk.conversationsSecondaryLinePersonAdded = '{{user}} bol pridaný';
z.string.sk.conversationsSecondaryLinePersonAddedYou = '{{user}} Vás pridal';
z.string.sk.conversationsSecondaryLineRenamed = '{{user}} premenoval konverzáciu';
z.string.sk.conversationsSecondaryLineYouLeft = 'Odišli ste';
z.string.sk.conversationsSecondaryLineYouWereRemoved = 'Boli ste odstránený';

z.string.sk.takeoverSub = 'Potvrďte Vaše jednoznačné meno pre Wire.';
z.string.sk.takeoverLink = 'Zistiť viac';
z.string.sk.takeoverButtonChoose = 'Vybrať vlastné';
z.string.sk.takeoverButtonKeep = 'Ponechať tento';

z.string.sk.inviteMetaKeyMac = 'Cmd';
z.string.sk.inviteMetaKeyPc = 'Ctrl';
z.string.sk.inviteHeadline = 'Pozvať ľudí do Wire';
z.string.sk.inviteMessage = 'Používam Wire, hľadajte {{username}} alebo navštívte get.wire.com.';
z.string.sk.inviteMessageNoEmail = 'Používam Wire. Ak sa chcete so mnou spojiť navštívte get.wire.com.';

z.string.sk.extensionsBubbleButtonGif = 'Gif';

z.string.sk.extensionsGiphyButtonOk = 'Poslať';
z.string.sk.extensionsGiphyButtonMore = 'Skúste iný';
z.string.sk.extensionsGiphyMessage = '{{tag}} • cez giphy.com';
z.string.sk.extensionsGiphyNoGifs = 'Ej, žiadne gify';
z.string.sk.extensionsGiphyRandom = 'Náhodný';

z.string.sk.addParticipantsConfirmLabel = 'Pridať';
z.string.sk.addParticipantsSearchPlaceholder = 'Vyhľadať podľa mena';
z.string.sk.addParticipantsTabsPeople = 'Ľudia';
z.string.sk.addParticipantsTabsServices = 'Služby';

z.string.sk.conversationDetailsActionArchive = 'Archív';
z.string.sk.conversationDetailsActionCancelRequest = 'Zrušiť požiadavku';
z.string.sk.conversationDetailsActionDevices = 'Zariadenia';
z.string.sk.conversationDetailsActionNotifications = 'Notifikácie';
z.string.sk.conversationDetailsGuestsOff = 'Vypnúť';
z.string.sk.conversationDetailsOptions = 'Možnosti';
z.string.sk.conversationDetailsParticipantsServicesMany = 'Služby';
z.string.sk.conversationDetailsParticipantsUsersMany = 'Ľudia';
z.string.sk.conversationDetailsPeople = 'Ľudia';
z.string.sk.conversationDetailsServices = 'Služby';

z.string.sk.conversationParticipantsTitle = 'Ľudia';
z.string.sk.conversationParticipantsSearchPlaceholder = 'Vyhľadať podľa mena';

z.string.sk.groupParticipantActionCancelRequest = 'Zrušiť požiadavku';
z.string.sk.groupParticipantActionDevices = 'Zariadenia';
z.string.sk.groupParticipantActionPending = 'Čaká sa';
z.string.sk.groupParticipantActionSendRequest = 'Pripojiť';

z.string.sk.notificationSettingsTitle = 'Notifikácie';

z.string.sk.participantDevicesDetailHeadline = 'Overte, že to zodpovedá identifikátoru zobrazenému na {{html1}}zariadení {{user}}{{html2}}.';
z.string.sk.participantDevicesDetailHowTo = 'Ako to urobiť?';
z.string.sk.participantDevicesDetailResetSession = 'Obnovenie spojenia';
z.string.sk.participantDevicesDetailShowMyDevice = 'Zobraziť identifikátor môjho zariadenia';
z.string.sk.participantDevicesDetailVerify = 'Overený';

z.string.sk.participantDevicesHeader = 'Zariadenia';
z.string.sk.participantDevicesHeadline = 'Wire dáva každému zariadeniu jedinečný identifikátor. Porovnajte ich s {{user}} a overte Vaše rozhovory.';
z.string.sk.participantDevicesLearnMore = 'Zistiť viac';
z.string.sk.participantDevicesWhyVerify = 'Prečo overiť rozhovor?';
z.string.sk.participantDevicesOutdatedClientMessage = '{{user}} používa staršiu verziu Wire. Žiadne zariadenia sa tu nezobrazujú.';

z.string.sk.participantDevicesSelfAllDevices = 'Zobraziť všetky moje zariadenia';
z.string.sk.participantDevicesSelfFingerprint = 'Identifikátor zaradenia';

z.string.sk.userProfileButtonConnect = 'Pripojiť';
z.string.sk.userProfileButtonIgnore = 'Ignorovať';
z.string.sk.userProfileButtonUnblock = 'Odblokovať';

z.string.sk.preferencesAbout = 'O aplikácií';
z.string.sk.preferencesAccount = 'Účet';
z.string.sk.preferencesAV = 'Audio / Video';
z.string.sk.preferencesDeviceDetails = 'Podrobnosti o zariadení';
z.string.sk.preferencesDevices = 'Zariadenia';
z.string.sk.preferencesHeadline = 'Nastavenia';
z.string.sk.preferencesOptions = 'Možnosti';

z.string.sk.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.sk.preferencesAboutPrivacyPolicy = 'Pravidlá ochrany súkromia';
z.string.sk.preferencesAboutSupport = 'Podpora';
z.string.sk.preferencesAboutSupportWebsite = 'Webová lokalita podpory';
z.string.sk.preferencesAboutSupportContact = 'Kontaktovať podporu';
z.string.sk.preferencesAboutTermsOfUse = 'Podmienky používania';
z.string.sk.preferencesAboutVersion = 'Verzia {{version}}';
z.string.sk.preferencesAboutWebsite = 'Webová stránka Wire';

z.string.sk.preferencesAccountCreateTeam = 'Vytvoriť tím';
z.string.sk.preferencesAccountDelete = 'Vymazať účet';
z.string.sk.preferencesAccountLogOut = 'Odhlásenie';
z.string.sk.preferencesAccountManageTeam = 'Správa tímu';
z.string.sk.preferencesAccountResetPassword = 'Reset hesla';
z.string.sk.preferencesAccountTeam = 'v {{name}}';
z.string.sk.preferencesAccountUsernamePlaceholder = 'Vaše celé meno';
z.string.sk.preferencesAccountUsernameHint = 'Aspoň 2 znaky. A výhradne a-z, 0-9.';
z.string.sk.preferencesAccountUsernameAvailable = 'Dostupné';
z.string.sk.preferencesAccountUsernameErrorTaken = 'Už obsadené';

z.string.sk.preferencesAVCamera = 'Kamera';
z.string.sk.preferencesAVMicrophone = 'Mikrofón';
z.string.sk.preferencesAVPermissionDetail = 'Povoliť v nastaveniach prehliadača';
z.string.sk.preferencesAVSpeakers = 'Reproduktory';

z.string.sk.preferencesDevicesActivatedOn = 'Aktivované {{date}}';
z.string.sk.preferencesDevicesActive = 'Aktívne';
z.string.sk.preferencesDevicesActiveDetail = 'Ak nepoznáte zariadenie vyššie, odstráňte ho a nastavte nové heslo.';
z.string.sk.preferencesDevicesCurrent = 'Aktuálny';
z.string.sk.preferencesDevicesFingerprint = 'Identifikátor kľúča';
z.string.sk.preferencesDevicesFingerprintDetail = 'Wire dáva každému zariadeniu jedinečný identifikátor. Porovnajte ich a overte Vaše zariadenia a rozhovory.';
z.string.sk.preferencesDevicesId = 'ID: ';
z.string.sk.preferencesDevicesRemoveCancel = 'Zrušiť';
z.string.sk.preferencesDevicesRemoveDetail = 'Odstráňte toto zariadenie, ak ste ho prestali používať. Budete z neho ihneď odhlásený.';
z.string.sk.preferencesDevicesSessionConfirmation = 'Relácia bola obnovená.';
z.string.sk.preferencesDevicesSessionDetail = 'Ak sa identifikátory nezhodujú, začnite novú reláciu pre vygenerovanie nových kľúčov na oboch stranách.';
z.string.sk.preferencesDevicesSessionReset = 'Obnovenie spojenia';
z.string.sk.preferencesDevicesSessionOngoing = 'Obnovovanie relácie…';
z.string.sk.preferencesDevicesVerification = 'Overený';

z.string.sk.preferencesOptionsAudio = 'Zvukové upozornenia';
z.string.sk.preferencesOptionsAudioAll = 'Všetko';
z.string.sk.preferencesOptionsAudioAllDetail = 'Všetky zvuky';
z.string.sk.preferencesOptionsAudioNone = 'Žiadne';
z.string.sk.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.sk.preferencesOptionsAudioSome = 'Niektoré';
z.string.sk.preferencesOptionsAudioSomeDetail = 'Pingy a hovory';
z.string.sk.preferencesOptionsContacts = 'Kontakty';
z.string.sk.preferencesOptionsContactsGmail = 'Import z Gmailu';
z.string.sk.preferencesOptionsContactsMacos = 'Import z Kontaktov';
z.string.sk.preferencesOptionsContactsDetail = 'Vaše údaje o kontaktoch používame na pripojenie k iným užívateľom. Všetky informácie anonymizujeme a nezdieľame ich s nikým iným.';
z.string.sk.preferencesOptionsPopular = 'Populárnej požiadavky';
z.string.sk.preferencesOptionsEmojiReplaceCheckbox = 'Nahradiť emotikony pomocou emojis';
z.string.sk.preferencesOptionsPreviewsSendCheckbox = 'Vytvoriť náhľady pre odkazy ktoré odosielate';
z.string.sk.preferencesOptionsPreviewsSendDetail = 'Náhľady môžu byť stále zobrazené pre odkazy od iných ľudí.';
z.string.sk.preferencesOptionsNotifications = 'Notifikácie';
z.string.sk.preferencesOptionsNotificationsNone = 'Vypnúť';
z.string.sk.preferencesOptionsNotificationsObfuscate = 'Skryť detaily';
z.string.sk.preferencesOptionsNotificationsObfuscateMessage = 'Zobraziť odosielateľa';
z.string.sk.preferencesOptionsNotificationsOn = 'Zobraziť odosielateľa a správu';

z.string.sk.backupCancel = 'Zrušiť';

z.string.sk.searchConnect = 'Pripojiť';
z.string.sk.searchConnections = 'Pripojenia';
z.string.sk.searchContacts = 'Kontakty';
z.string.sk.searchCreateGroup = 'Vytvoriť skupinu';
z.string.sk.searchGroups = 'Skupiny';
z.string.sk.searchPeople = 'Ľudia';
z.string.sk.searchPlaceholder = 'Vyhľadať podľa mena, alebo užívateľského mena';
z.string.sk.searchServicePlaceholder = 'Vyhľadať podľa mena';
z.string.sk.searchServices = 'Služby';
z.string.sk.searchTeamGroups = 'Tímové konverzácie';
z.string.sk.searchTeamMembers = 'Členovia tímu';
z.string.sk.searchTopPeople = 'Top kontakty';
z.string.sk.searchTrySearch = 'Nájsť ľudí podľa názvu, alebo užívateľského mena';
z.string.sk.searchNoContactsOnWire = 'Nemáte žiadne kontakty Wire. Skúste nájsť ľudí podľa názvu alebo užívateľského mena.';
z.string.sk.searchOthers = 'Pripojiť';

z.string.sk.searchInvite = 'Pozvať ľudí do Wire';
z.string.sk.searchInviteDetail = 'Zdieľanie kontaktov Vám pomôže spojiť sa s ostatnými. Anonymizujeme všetky informácie a nezdieľame ich s nikým iným.';
z.string.sk.searchInviteButtonContacts = 'Z kontaktov';
z.string.sk.searchInviteButtonGmail = 'Z Gmailu';
z.string.sk.searchInviteHeadline = 'Pozvať priateľov';
z.string.sk.searchInviteShare = 'Zdieľať kontakty';

z.string.sk.searchListEveryoneParticipates = 'Všetci pripojení sú už v tomto rozhovore.';
z.string.sk.searchListNoMatches = 'Žiadne výsledky. Skúste zadať iné meno.';


z.string.sk.uploadGoogleHeadline = 'Nájsť ľudí\npre rozhovor.';
z.string.sk.uploadGoogleMessage = 'Vaše údaje o kontaktoch používame na pripojenie k iným užívateľom. Všetky informácie anonymizujeme a nezdieľame ich s nikým iným.';

z.string.sk.warningCallUnsupportedIncoming = 'Volá {{user}}. Váš prehliadač nepodporuje hovory.';
z.string.sk.warningCallUnsupportedOutgoing = 'Nemôžete volať, pretože Váš prehliadač nepodporuje hovory.';
z.string.sk.warningCallIssues = 'Táto verzia Wire sa nemôže zúčastniť volania. Prosím použite';
z.string.sk.warningCallUpgradeBrowser = 'Pre volanie, prosím aktualizujte Google Chrome.';
z.string.sk.warningConnectivityConnectionLost = 'Prebieha pokus o pripojenie. Wire nemusí byť schopný doručiť správy.';
z.string.sk.warningConnectivityNoInternet = 'Bez prístupu na internet. Nebudete môcť odosielať ani prijímať správy.';
z.string.sk.warningLearnMore = 'Zistiť viac';
z.string.sk.warningLifecycleUpdate = 'Je dostupná nová verzia programu.';
z.string.sk.warningLifecycleUpdateNotes = 'Čo je nové';
z.string.sk.warningLifecycleUpdateLink = 'Aktualizovať';
z.string.sk.warningNotFoundCamera = 'Nemôžete volať, pretože Váš počítač nemá kameru.';
z.string.sk.warningNotFoundMicrophone = 'Nemôžete volať, pretože Váš počítač nemá mikrofón.';
z.string.sk.warningPermissionDeniedCamera = 'Nemôžete volať, pretože Váš prehliadač nemá prístup ku kamere.';
z.string.sk.warningPermissionDeniedMicrophone = 'Nemôžete volať, pretože Váš prehliadač nemá prístup k mikrofónu.';
z.string.sk.warningPermissionDeniedScreen = 'Váš prehliadač potrebuje povolenie pre zdieľanie obrazovky.';
z.string.sk.warningPermissionRequestCamera = '{{icon}} Povoliť prístup ku kamere';
z.string.sk.warningPermissionRequestMicrophone = '{{icon}} Povoliť prístup k mikrofónu';
z.string.sk.warningPermissionRequestNotification = '{{icon}} Povoliť oznámenia';
z.string.sk.warningPermissionRequestScreen = '{{icon}} Povoliť prístup k obrazovke';

z.string.sk.userAvailabilityAvailable = 'Dostupné';
z.string.sk.userAvailabilityNone = 'Žiadne';

z.string.sk.notificationAssetAdd = 'Zdieľať obrázok';
z.string.sk.notificationConnectionAccepted = 'Prijal Vašu požiadavku na pripojenie';
z.string.sk.notificationConnectionConnected = 'Teraz ste pripojení';
z.string.sk.notificationConnectionRequest = 'Chce sa pripojiť';
z.string.sk.notificationConversationCreate = '{{user}} začal rozhovor';
z.string.sk.notificationConversationRename = '{{user}} premenoval rozhovor na {{name}}';
z.string.sk.notificationMemberJoinMany = '{{user}} pridal {{number}} ľudí do rozhovoru';
z.string.sk.notificationMemberJoinOne = '{{user1}} pridal {{user2}} do rozhovoru';
z.string.sk.notificationMemberLeaveRemovedYou = '{{user}} Vás odstránil z konverzácie';
z.string.sk.notificationObfuscated = 'Poslal Vám správu';
z.string.sk.notificationObfuscatedTitle = 'Niekto';
z.string.sk.notificationPing = 'Pingnuté';
z.string.sk.notificationReaction = '{{reaction}} Vašu správu';
z.string.sk.notificationSharedAudio = 'Zdieľal zvukovú správu';
z.string.sk.notificationSharedFile = 'Zdieľal súbor';
z.string.sk.notificationSharedLocation = 'Zdieľal umiestnenie';
z.string.sk.notificationSharedVideo = 'Zdieľal video';
z.string.sk.notificationVoiceChannelActivate = 'Volá';
z.string.sk.notificationVoiceChannelDeactivate = 'Volal';

z.string.sk.tooltipConversationAllVerified = 'Všetky identifikátory sú overené';
z.string.sk.tooltipConversationCall = 'Volať';
z.string.sk.tooltipConversationEphemeral = 'Časovaná správa';
z.string.sk.tooltipConversationFile = 'Pridať súbor';
z.string.sk.tooltipConversationInputPlaceholder = 'Napísať správu';
z.string.sk.tooltipConversationPeople = 'Ľudia ({{shortcut}})';
z.string.sk.tooltipConversationPicture = 'Pridať obrázok';
z.string.sk.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.sk.tooltipConversationSearch = 'Hladať';
z.string.sk.tooltipConversationVideoCall = 'Videohovor';

z.string.sk.tooltipConversationsArchive = 'Archív ({{shortcut}})';
z.string.sk.tooltipConversationsArchived = 'Zobraziť archív ({{number}})';
z.string.sk.tooltipConversationsMore = 'Viac';
z.string.sk.tooltipConversationsNotify = 'Zrušiť stlmenie ({{shortcut}})';
z.string.sk.tooltipConversationsPreferences = 'Otvoriť predvoľby';
z.string.sk.tooltipConversationsSilence = 'Stlmiť ({{shortcut}})';
z.string.sk.tooltipConversationsStart = 'Začať rozhovor ({{shortcut}})';

z.string.sk.tooltipConversationDetailsRename = 'Zmeniť názov rozhovoru';

z.string.sk.tooltipPreferencesContactsGmail = 'Pre zdieľanie kontaktov sa prihláste do svojho Gmail účtu';
z.string.sk.tooltipPreferencesContactsMacos = 'Zdieľať všetky svoje kontakty z aplikácie kontaktov systému macOS';
z.string.sk.tooltipPreferencesPassword = 'Pre zmenu hesla otvorte ďalšiu webovú stránku';
z.string.sk.tooltipPreferencesPicture = 'Zmeniť obrázok…';
z.string.sk.tooltipPreferencesRename = 'Zmeniť Vaše meno';

z.string.sk.tooltipSearchClose = 'Zavrieť (Esc)';

z.string.sk.initReceivedSelfUser = 'Ahoj, {{user}}.';
z.string.sk.initValidatedClient = 'Získavanie pripojení a konverzácií';
z.string.sk.initReceivedUserData = 'Kontrola nových správ';
z.string.sk.initDecryption = 'Dešifrovať správy';
z.string.sk.initEvents = 'Načítavam správy';

z.string.sk.ephemeralUnitsNone = 'Vypnúť';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.sl.wire = 'Wire';
z.string.sl.wireMacos = 'Wire za macOS';
z.string.sl.wireWindows = 'Wire za Windows';
z.string.sl.wireLinux = 'Wire za Linux';
z.string.sl.nonexistentUser = 'Izbrisan uporabnik';
z.string.sl.and = 'in';

z.string.sl.authAccountCountryCode = 'Koda države';
z.string.sl.authAccountPasswordForgot = 'Pozabljeno geslo';
z.string.sl.authAccountPublicComputer = 'To je javni računalnik';
z.string.sl.authAccountSignIn = 'Prijava';
z.string.sl.authAccountSignInPhone = 'Telefon';

z.string.sl.authBlockedDatabase = 'Wire potrebuje dostop do lokalnega pomnilnika za prikaz sporočil. Lokalni pomnilnik ni na voljo v privatnem načinu.';
z.string.sl.authBlockedTabs = 'Wire je že odprt v drugem oknu.';

z.string.sl.authVerifyAccountAdd = 'Dodaj';
z.string.sl.authVerifyAccountDetail = 'To vam omogoča uporabo Wire na večih napravah.';
z.string.sl.authVerifyAccountHeadline = 'Dodajte e-poštni naslov in geslo.';
z.string.sl.authVerifyAccountLogout = 'Odjava';
z.string.sl.authVerifyCodeDescription = 'Vnesite verifikacijsko kodo,\nki smo jo poslali na {{number}}.';
z.string.sl.authVerifyCodeResend = 'Koda ni prispela?';
z.string.sl.authVerifyCodeResendDetail = 'Ponovno pošlji';
z.string.sl.authVerifyCodeResendTimer = 'Lahko zahtevate novo kodo {{expiration}}.';
z.string.sl.authVerifyCodeChangePhone = 'Spremeni telefonsko številko';
z.string.sl.authVerifyPasswordHeadline = 'Vnesite vaše geslo';

z.string.sl.authLimitDevicesHeadline = 'Naprave';
z.string.sl.authLimitDescription = 'Odstranite eno izmed vaših naprav za začetek uporabe Wire na tej.';
z.string.sl.authLimitButtonManage = 'Upravljanje naprav';
z.string.sl.authLimitButtonSignOut = 'Odjava';
z.string.sl.authLimitDevicesCurrent = '(Trenutna)';

z.string.sl.authHistoryHeadline = 'Prvič uporabljate Wire na tej napravi.';
z.string.sl.authHistoryDescription = 'Zaradi zasebnosti se vaša zgodovina pogovorov ne bo pojavila tukaj.';
z.string.sl.authHistoryReuseHeadline = 'Na tej napravi si že uporabljal(-a) Wire.';
z.string.sl.authHistoryReuseDescription = 'Sporočila poslana medtem tukaj ne bodo prikazana.';
z.string.sl.authHistoryButton = 'V redu';

z.string.sl.authPostedResend = 'Ponovno pošlji na {{email}}';
z.string.sl.authPostedResendAction = 'E-pošta ni prispela?';
z.string.sl.authPostedResendDetail = 'Preverite vašo e-pošto in sledite navodilom.';
z.string.sl.authPostedResendHeadline = 'Imate pošto.';

z.string.sl.authPlaceholderEmail = 'E-pošta';
z.string.sl.authPlaceholderPasswordPut = 'Geslo';
z.string.sl.authPlaceholderPasswordSet = 'Geslo (vsaj 8 znakov)';
z.string.sl.authPlaceholderPhone = 'Telefonska številka';

z.string.sl.authErrorCode = 'Neveljavna koda';
z.string.sl.authErrorCountryCodeInvalid = 'Neveljavna koda države';
z.string.sl.authErrorEmailExists = 'E-poštni naslov je že zaseden';
z.string.sl.authErrorEmailForbidden = 'Se opravičujemo. Ta e-poštni naslov je prepovedan.';
z.string.sl.authErrorEmailMalformed = 'Prosimo, vnesite veljaven e-poštni naslov.';
z.string.sl.authErrorEmailMissing = 'Prosimo, vnesite e-poštni naslov.';
z.string.sl.authErrorMisc = 'Težave s povezavo. Prosimo poizkusite znova.';
z.string.sl.authErrorNameShort = 'Vnesite ime z vsaj 2 znakoma';
z.string.sl.authErrorOffline = 'Ni spletne povezave';
z.string.sl.authErrorPasswordShort = 'Izberite geslo z vsaj 8 znaki.';
z.string.sl.authErrorPasswordWrong = 'Napačno geslo. Poizkusite znova.';
z.string.sl.authErrorPhoneNumberBudget = 'Da prijavljeni prepogosto. Poskusite znova pozneje.';
z.string.sl.authErrorPhoneNumberForbidden = 'Se opravičujemo. Ta telefonska številka je prepovedana.';
z.string.sl.authErrorPhoneNumberInvalid = 'Neveljavna telefonska številka';
z.string.sl.authErrorPhoneNumberUnknown = 'Neznana telefonska številka';
z.string.sl.authErrorSignIn = 'Prosimo preverite vaše podatke in poizkusite ponovno.';

z.string.sl.callStateOutgoing = 'Zvonjenje…';
z.string.sl.callStateConnecting = 'Povezovanje…';
z.string.sl.callStateIncoming = 'Klicanje…';
z.string.sl.callDecline = 'Zavrni';
z.string.sl.callAccept = 'Sprejmi';
z.string.sl.callJoin = 'Pridruži';
z.string.sl.callChooseSharedScreen = 'Izberite zaslon za deljenje';

z.string.sl.videoCallOverlayMute = 'Utišaj';
z.string.sl.videoCallOverlayHangUp = 'Odloži';

z.string.sl.modalAcknowledgeAction = 'V redu';
z.string.sl.modalConfirmSecondary = 'Prekliči';
z.string.sl.modalOptionSecondary = 'Prekliči';

z.string.sl.modalAccountCreateAction = 'V redu';

z.string.sl.modalAccountDeletionAction = 'Izbriši';
z.string.sl.modalAccountDeletionHeadline = 'Izbriši račun';
z.string.sl.modalAccountDeletionMessage = 'Poslali bomo sporočilo preko e-pošte ali SMS. Sledite povezavi za trajni izbris vašega računa.';

z.string.sl.modalAccountLeaveGuestRoomAction = 'Zapusti';

z.string.sl.modalAccountLogoutAction = 'Odjava';
z.string.sl.modalAccountLogoutHeadline = 'Počisti podatke?';
z.string.sl.modalAccountLogoutOption = 'Izbriši vse vaše osebne podatke in pogovore na tej napravi.';

z.string.sl.modalAccountNewDevicesSecondary = 'Upravljanje naprav';
z.string.sl.modalAccountNewDevicesHeadline = 'Vaš račun je bil uporabljen na:';
z.string.sl.modalAccountNewDevicesFrom = 'Od:';
z.string.sl.modalAccountNewDevicesMessage = 'Če tega niste storili, odstranite napravo in ponastavite vaše geslo.';

z.string.sl.modalAccountRemoveDeviceAction = 'Odstrani napravo';
z.string.sl.modalAccountRemoveDeviceHeadline = 'Odstrani "{{device}}"';
z.string.sl.modalAccountRemoveDeviceMessage = 'Za odstranitev naprave je potrebno vaše geslo.';
z.string.sl.modalAccountRemoveDevicePlaceholder = 'Geslo';

z.string.sl.modalAssetTooLargeMessage = 'Lahko pošljete zbirke do {{number}}';

z.string.sl.modalAssetParallelUploadsMessage = 'Lahko pošljete do {{number}} zbirk naenkrat.';

z.string.sl.modalCallEmptyConversationHeadline = 'Ni nikogar za klic';
z.string.sl.modalCallEmptyConversationMessage = 'Nikogar ni več tukaj.';

z.string.sl.modalCallNoGroupVideoHeadline = 'Nobenih videoklicev v skupinah';
z.string.sl.modalCallNoGroupVideoMessage = 'Videoklici niso na voljo v skupinskih pogovorih.';

z.string.sl.modalCallNoMicrophoneAction = 'Povej mi kako';
z.string.sl.modalCallNoMicrophoneMessage = 'Vaš brskalnik potrebuje dostop do mikrofona za klicanje.';
z.string.sl.modalCallNoMicrophoneHeadline = 'Klic ni mogoč brez mikrofona';

z.string.sl.modalCallSecondIncomingAction = 'Sprejmi';
z.string.sl.modalCallSecondIncomingHeadline = 'Sprejmi klic?';
z.string.sl.modalCallSecondIncomingMessage = 'Vaš trenuten klic se bo končal.';

z.string.sl.modalCallSecondOngoingAction = 'Odloži';
z.string.sl.modalCallSecondOngoingHeadline = 'Odloži klic na drugi napravi?';
z.string.sl.modalCallSecondOngoingMessage = 'Naenkrat ste lahko samo v enem klicu.';

z.string.sl.modalCallSecondOutgoingAction = 'Odloži';
z.string.sl.modalCallSecondOutgoingHeadline = 'Odloži trenutni klic?';
z.string.sl.modalCallSecondOutgoingMessage = 'Naenkrat ste lahko samo v enem klicu.';

z.string.sl.modalConnectCancelAction = 'Da';
z.string.sl.modalConnectCancelHeadline = 'Prekliči zahtevo?';
z.string.sl.modalConnectCancelMessage = 'Odstrani zahtevo za povezavo do {{user}}.';
z.string.sl.modalConnectCancelSecondary = 'Ne';

z.string.sl.modalConnectAcceptAction = 'Poveži';
z.string.sl.modalConnectAcceptHeadline = 'Sprejmi?';
z.string.sl.modalConnectAcceptMessage = 'To vas bo povezalo in odprlo pogovor s/z {{user}}.';
z.string.sl.modalConnectAcceptSecondary = 'Ignoriraj';

z.string.sl.modalConversationClearAction = 'Izbriši';
z.string.sl.modalConversationClearHeadline = 'Izbriši vsebino?';
z.string.sl.modalConversationClearOption = 'Tudi zapusti pogovor';

z.string.sl.modalConversationDeleteMessageAction = 'Izbriši';
z.string.sl.modalConversationDeleteMessageHeadline = 'Izbriši le zame?';
z.string.sl.modalConversationDeleteMessageMessage = 'To dejanje ne more biti razveljavljeno.';

z.string.sl.modalConversationDeleteMessageEveryoneAction = 'Izbriši';
z.string.sl.modalConversationDeleteMessageEveryoneHeadline = 'Izbriši za vse?';
z.string.sl.modalConversationDeleteMessageEveryoneMessage = 'To dejanje ne more biti razveljavljeno.';

z.string.sl.modalConversationLeaveAction = 'Zapusti';
z.string.sl.modalConversationLeaveMessage = 'Ne boste mogli pošiljati ali prejeti sporočila v tem pogovoru.';

z.string.sl.modalConversationMessageTooLongHeadline = 'Sporočilo je predolgo';
z.string.sl.modalConversationMessageTooLongMessage = 'Lahko pošljete sporočila do {{number}} znakov.';

z.string.sl.modalConversationNewDeviceHeadlineOne = '{{user}} je začel(-a) z uporabo nove naprave';
z.string.sl.modalConversationNewDeviceHeadlineMany = '{{user}}s so začeli z uporabo novih naprav';
z.string.sl.modalConversationNewDeviceHeadlineYou = '{{user}} je začel(-a) z uporabo nove naprave';
z.string.sl.modalConversationNewDeviceIncomingCallAction = 'Sprejmi klic';
z.string.sl.modalConversationNewDeviceIncomingCallMessage = 'Ali še vedno želite sprejeti klic?';
z.string.sl.modalConversationNewDeviceMessage = 'Ali še vedno želite poslati vaša sporočila?';
z.string.sl.modalConversationNewDeviceOutgoingCallAction = 'Vseeno pokliči';
z.string.sl.modalConversationNewDeviceOutgoingCallMessage = 'Ali še vedno želite klicati?';

z.string.sl.modalConversationNotConnectedMessageOne = '{{name}} ne želi biti dodan k pogovorom.';
z.string.sl.modalConversationNotConnectedMessageMany = 'Ena izmed oseb, ki ste jo izbrali, ne želi biti dodana k pogovorom.';

z.string.sl.modalConversationRemoveAction = 'Odstrani';
z.string.sl.modalConversationRemoveHeadline = 'Odstrani?';
z.string.sl.modalConversationRemoveMessage = '{{user}} ne bo mogel pošiljati ali prejeti sporočila v tem pogovoru.';

z.string.sl.modalConversationRemoveGuestsAction = 'Odstrani';

z.string.sl.modalConversationTooManyMembersHeadline = 'Polna hiša';



z.string.sl.modalImproveWireAction = 'Sprejmi';
z.string.sl.modalImproveWireSecondary = 'Ne';

z.string.sl.modalSessionResetHeadline = 'Seja je bila ponastavljena';
z.string.sl.modalSessionResetMessage1 = 'Če težave niste odpravili,';
z.string.sl.modalSessionResetMessageLink = 'kontaktirajte';
z.string.sl.modalSessionResetMessage2 = 'nas.';

z.string.sl.modalUploadContactsAction = 'Poskusite ponovno';
z.string.sl.modalUploadContactsMessage = 'Nismo prejeli vaših podatkov. Prosimo poizkusite ponovno uvoziti stike.';

z.string.sl.modalUserBlockAction = 'Blokiraj';
z.string.sl.modalUserBlockHeadline = 'Blokiraj {{user}}?';
z.string.sl.modalUserBlockMessage = '{{user}} vas ne bo mogel kontaktirati ali dodati v skupinske pogovore.';

z.string.sl.modalUserUnblockAction = 'Odblokiraj';
z.string.sl.modalUserUnblockHeadline = 'Odblokiraj?';
z.string.sl.modalUserUnblockMessage = '{{user}} vas ne bo mogel kontaktirati ali ponovno dodati v skupinske pogovore.';

z.string.sl.connectionRequestConnect = 'Poveži';
z.string.sl.connectionRequestIgnore = 'Ignoriraj';

z.string.sl.conversationYouNominative = 'ti';
z.string.sl.conversationYouDative = 'ti';
z.string.sl.conversationYouAccusative = 'ti';

z.string.sl.conversationConnectionAccepted = 'Povezan';
z.string.sl.conversationConnectionBlocked = 'Blokiran';
z.string.sl.conversationConnectionCancelRequest = 'Prekliči zahtevo za povezavo';
z.string.sl.conversationDeviceStartedUsingOne = ' začel(-a) uporabljati';
z.string.sl.conversationDeviceStartedUsingMany = ' začel(-a) uporabljati';
z.string.sl.conversationDeviceUnverified = ' odstranil(-a) preveritev ene izmed';
z.string.sl.conversationDeviceYourDevices = ' vaših naprav';
z.string.sl.conversationDeviceUserDevices = ' Naprave od {{user}}';
z.string.sl.conversationDeviceNewDeviceOne = ' nova naprava';
z.string.sl.conversationDeviceNewDeviceMany = ' nove naprave';
z.string.sl.conversationDeviceNewPeopleJoinedVerify = ' preverite naprave';
z.string.sl.conversationJustNow = 'Pravkar';
z.string.sl.conversationLocationLink = 'Odpri zemljevid';
z.string.sl.conversationMessageDelivered = 'Dostavljeno';
z.string.sl.conversationRename = ' je preimenoval(-a) pogovor';
z.string.sl.conversationRenameYou = ' je preimenoval(-a) pogovor';
z.string.sl.conversationResume = 'Začni pogovor s/z {{users}}';
z.string.sl.conversationPing = ' je pingal(-a)';
z.string.sl.conversationPingYou = ' je pingal(-a)';
z.string.sl.conversationToday = 'danes';
z.string.sl.conversationVoiceChannelDeactivate = ' je klical(-a)';
z.string.sl.conversationVoiceChannelDeactivateYou = ' je klical(-a)';
z.string.sl.conversationYesterday = 'Včeraj';
z.string.sl.conversationUnableToDecrypt1 = 'sporočilo od {{user}} ni bilo prejeto.';
z.string.sl.conversationUnableToDecrypt2 = 'Identita naprave od {{user}} je bila spremenjena. Sporočilo ni dostavljeno.';
z.string.sl.conversationUnableToDecryptLink = 'Zakaj?';
z.string.sl.conversationUnableToDecryptErrorMessage = 'Napaka';
z.string.sl.conversationUnableToDecryptResetSession = 'Ponastavi sejo';
z.string.sl.conversationMissedMessages = 'Te naprave nekaj časa niste uporabljali. Nekatera sporočila se morda tukaj ne bodo pojavila.';
z.string.sl.conversationAssetDownloading = 'Prenašanje…';
z.string.sl.conversationAssetUploadFailed = 'Nalaganje ni uspelo';
z.string.sl.conversationPlaybackError = 'Ni možno predvajati';
z.string.sl.conversationContextMenuCopy = 'Kopiraj';
z.string.sl.conversationContextMenuEdit = 'Uredi';
z.string.sl.conversationContextMenuDelete = 'Izbriši zame';
z.string.sl.conversationContextMenuDeleteEveryone = 'Izbriši za vse';
z.string.sl.conversationContextMenuDownload = 'Prenos';
z.string.sl.conversationContextMenuLike = 'Všeč mi je';
z.string.sl.conversationContextMenuUnlike = 'Ni mi všeč';
z.string.sl.conversationDeleteTimestamp = 'Izbrisan ob {{date}}';
z.string.sl.conversationEditTimestamp = 'Urejen ob {{date}}';
z.string.sl.conversationLikesCaption = '{{number}} oseb';
z.string.sl.conversationSendPastedFile = 'Prilepljena slika ob {{date}}';
z.string.sl.conversationSomeone = 'Nekdo';
z.string.sl.conversationTweetAuthor = ' na Twitterju';

z.string.sl.groupCreationParticipantsPlaceholder = 'Iskanje po imenu';


z.string.sl.collectionShowAll = 'Prikaži vse {{number}}';
z.string.sl.collectionSectionLinks = 'Povezave';
z.string.sl.collectionSectionImages = 'Slike';
z.string.sl.collectionSectionFiles = 'Zbirke';
z.string.sl.collectionSectionAudio = 'Zvočna sporočila';

z.string.sl.fullsearchPlaceholder = 'Išči po sporočilih';
z.string.sl.fullsearchNoResults = 'Ni rezultatov.';

z.string.sl.archiveHeader = 'Arhiviraj';

z.string.sl.conversationsAllArchived = 'Vse je arhivirano';
z.string.sl.conversationsContacts = 'Stiki';
z.string.sl.conversationsConnectionRequestMany = '{{number}} ljudi, ki čakajo';
z.string.sl.conversationsConnectionRequestOne = '1 oseba čaka';
z.string.sl.conversationsEmptyConversation = 'Skupinski pogovor';
z.string.sl.conversationsNoConversations = 'Še ni pogovorov';
z.string.sl.conversationsPopoverArchive = 'Arhiviraj';
z.string.sl.conversationsPopoverCancel = 'Prekliči prošnjo';
z.string.sl.conversationsPopoverNotify = 'Povrni glasnost';
z.string.sl.conversationsPopoverSilence = 'Utišaj';
z.string.sl.conversationsPopoverUnarchive = 'Dearhiviraj';

z.string.sl.conversationsSecondaryLineEphemeralMessage = 'Vam je poslal(-a) sporočilo';
z.string.sl.conversationsSecondaryLinePeopleLeft = '{{number}} oseb je zapustilo pogovor';
z.string.sl.conversationsSecondaryLinePersonLeft = '{{user}} je zapustil(-a)';
z.string.sl.conversationsSecondaryLinePersonRemoved = '{{user}} je bil(-a) odstranjen(-a)';
z.string.sl.conversationsSecondaryLinePeopleAdded = '{{user}} oseb je bilo dodanih';
z.string.sl.conversationsSecondaryLinePersonAdded = '{{user}} je bil(-a) dodan(-a)';
z.string.sl.conversationsSecondaryLinePersonAddedYou = '{{user}} te je dodal(-a)';
z.string.sl.conversationsSecondaryLineRenamed = '{{user}} preimenoval(-a) pogovor';
z.string.sl.conversationsSecondaryLineYouLeft = 'Si zapustil(-a)';
z.string.sl.conversationsSecondaryLineYouWereRemoved = 'Bil(-a) si odstranjen(-a)';

z.string.sl.takeoverSub = 'Zavzemite vaše unikatno ime na Wire.';
z.string.sl.takeoverLink = 'Nauči se več';
z.string.sl.takeoverButtonChoose = 'Izberi svojo';
z.string.sl.takeoverButtonKeep = 'Obdrži to';

z.string.sl.inviteMetaKeyMac = 'Cmd';
z.string.sl.inviteMetaKeyPc = 'Ctrl';
z.string.sl.inviteHeadline = 'Povabite osebe na Wire';
z.string.sl.inviteMessage = 'Sem na Wire, poišči {{username}} ali obišči get.wire.com.';
z.string.sl.inviteMessageNoEmail = 'Sem na Wire. Obišči get.wire.com za povezavo z mano.';

z.string.sl.extensionsBubbleButtonGif = 'Gif';

z.string.sl.extensionsGiphyButtonOk = 'Pošlji';
z.string.sl.extensionsGiphyButtonMore = 'Poizkusi drugega';
z.string.sl.extensionsGiphyMessage = '{{tag}} • preko giphy.com';
z.string.sl.extensionsGiphyNoGifs = 'Ups, ni najdenih gifov';
z.string.sl.extensionsGiphyRandom = 'Naključno';

z.string.sl.addParticipantsConfirmLabel = 'Dodaj';
z.string.sl.addParticipantsSearchPlaceholder = 'Iskanje po imenu';
z.string.sl.addParticipantsTabsPeople = 'Osebe';
z.string.sl.addParticipantsTabsServices = 'Storitve';

z.string.sl.conversationDetailsActionArchive = 'Arhiviraj';
z.string.sl.conversationDetailsActionCancelRequest = 'Prekliči prošnjo';
z.string.sl.conversationDetailsActionDevices = 'Naprave';
z.string.sl.conversationDetailsActionNotifications = 'Obvestila';
z.string.sl.conversationDetailsGuestsOff = 'Izklopljeno';
z.string.sl.conversationDetailsOptions = 'Možnosti';
z.string.sl.conversationDetailsParticipantsServicesMany = 'Storitve';
z.string.sl.conversationDetailsParticipantsUsersMany = 'Osebe';
z.string.sl.conversationDetailsPeople = 'Osebe';
z.string.sl.conversationDetailsServices = 'Storitve';

z.string.sl.conversationParticipantsTitle = 'Osebe';
z.string.sl.conversationParticipantsSearchPlaceholder = 'Iskanje po imenu';

z.string.sl.groupParticipantActionCancelRequest = 'Prekliči prošnjo';
z.string.sl.groupParticipantActionDevices = 'Naprave';
z.string.sl.groupParticipantActionPending = 'V teku';
z.string.sl.groupParticipantActionSendRequest = 'Poveži';

z.string.sl.notificationSettingsTitle = 'Obvestila';

z.string.sl.participantDevicesDetailHeadline = 'Preveri, da se to ujema s prstnim odtisom na {{html1}}napravi od {{user}}{{html2}}.';
z.string.sl.participantDevicesDetailHowTo = 'Kako to storim?';
z.string.sl.participantDevicesDetailResetSession = 'Ponastavi sejo';
z.string.sl.participantDevicesDetailShowMyDevice = 'Prikaži prstni odtis moje naprave';
z.string.sl.participantDevicesDetailVerify = 'Preverjena';

z.string.sl.participantDevicesHeader = 'Naprave';
z.string.sl.participantDevicesHeadline = 'Wire dodeli vsaki napravi edinstven prstni odtis. Primerjajte jih z {{user}} in preverite vaš pogovor.';
z.string.sl.participantDevicesLearnMore = 'Nauči se več';
z.string.sl.participantDevicesWhyVerify = 'Zakaj preveriti pogovore?';
z.string.sl.participantDevicesOutdatedClientMessage = '{{user}} uporablja starejšo različico Wire. Nobenih naprav tukaj ni prikazano.';

z.string.sl.participantDevicesSelfAllDevices = 'Prikaži vse moje naprave';
z.string.sl.participantDevicesSelfFingerprint = 'Prstni odtis naprave';

z.string.sl.userProfileButtonConnect = 'Poveži';
z.string.sl.userProfileButtonIgnore = 'Ignoriraj';
z.string.sl.userProfileButtonUnblock = 'Odblokiraj';

z.string.sl.preferencesAbout = 'O aplikaciji';
z.string.sl.preferencesAccount = 'Račun';
z.string.sl.preferencesAV = 'Avdio / Video';
z.string.sl.preferencesDeviceDetails = 'Podrobnosti naprave';
z.string.sl.preferencesDevices = 'Naprave';
z.string.sl.preferencesHeadline = 'Možnosti';
z.string.sl.preferencesOptions = 'Možnosti';

z.string.sl.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.sl.preferencesAboutPrivacyPolicy = 'Politika zasebnosti';
z.string.sl.preferencesAboutSupport = 'Podpora';
z.string.sl.preferencesAboutSupportWebsite = 'Spletna stran Wire podpore';
z.string.sl.preferencesAboutSupportContact = 'Kontaktiraj podporo';
z.string.sl.preferencesAboutTermsOfUse = 'Pogoji uporabe';
z.string.sl.preferencesAboutVersion = 'Različica {{version}}';
z.string.sl.preferencesAboutWebsite = 'Wire spletna stran';

z.string.sl.preferencesAccountCreateTeam = 'Ustvari novo ekipo';
z.string.sl.preferencesAccountDelete = 'Izbriši račun';
z.string.sl.preferencesAccountLogOut = 'Odjava';
z.string.sl.preferencesAccountManageTeam = 'Uredi nalogo';
z.string.sl.preferencesAccountResetPassword = 'Resetiraj geslo';
z.string.sl.preferencesAccountTeam = 'v {{name}}';
z.string.sl.preferencesAccountUsernamePlaceholder = 'Vaše polno ime';
z.string.sl.preferencesAccountUsernameHint = 'Vsaj 2 znaka. Le a—z, 0—9 in _.';
z.string.sl.preferencesAccountUsernameAvailable = 'Na voljo';
z.string.sl.preferencesAccountUsernameErrorTaken = 'Že zasedeno';

z.string.sl.preferencesAVCamera = 'Kamera';
z.string.sl.preferencesAVMicrophone = 'Mikrofon';
z.string.sl.preferencesAVPermissionDetail = 'Omogoči iz nastavitev vašega brskalnika';
z.string.sl.preferencesAVSpeakers = 'Zvočniki';

z.string.sl.preferencesDevicesActivatedOn = 'Aktiviran ob {{date}}';
z.string.sl.preferencesDevicesActive = 'Aktivno';
z.string.sl.preferencesDevicesActiveDetail = 'Če ne prepoznate zgornje naprave, jo odstranite in ponastavite vaše geslo.';
z.string.sl.preferencesDevicesCurrent = 'Trenutna';
z.string.sl.preferencesDevicesFingerprint = 'Ključ prstnega odtisa naprave';
z.string.sl.preferencesDevicesFingerprintDetail = 'Wire dodeli vsaki napravi edinstven prstni odtis. Primerjajte jih, preverite vaše naprave in pogovore.';
z.string.sl.preferencesDevicesId = 'ID: ';
z.string.sl.preferencesDevicesRemoveCancel = 'Prekliči';
z.string.sl.preferencesDevicesRemoveDetail = 'Odstrani to napravo, če ste jo prenehali uporabljati. Takoj boste iz nje odjavljeni.';
z.string.sl.preferencesDevicesSessionConfirmation = 'Seja je bila ponastavljena.';
z.string.sl.preferencesDevicesSessionDetail = 'Če se prstni odtisi naprav ne ujemajo, ponastavite sejo za ustvaritev novih šifrirnih ključev na obeh straneh.';
z.string.sl.preferencesDevicesSessionReset = 'Ponastavi sejo';
z.string.sl.preferencesDevicesSessionOngoing = 'Ponastavljanje seje…';
z.string.sl.preferencesDevicesVerification = 'Preverjena';

z.string.sl.preferencesOptionsAudio = 'Zvočna opozorila';
z.string.sl.preferencesOptionsAudioAll = 'Vsi';
z.string.sl.preferencesOptionsAudioAllDetail = 'Vsi zvoki';
z.string.sl.preferencesOptionsAudioNone = 'Nič';
z.string.sl.preferencesOptionsAudioNoneDetail = 'Pssst!';
z.string.sl.preferencesOptionsAudioSome = 'Nekateri';
z.string.sl.preferencesOptionsAudioSomeDetail = 'Pingi in klici';
z.string.sl.preferencesOptionsContacts = 'Stiki';
z.string.sl.preferencesOptionsContactsGmail = 'Uvozi iz Gmail';
z.string.sl.preferencesOptionsContactsMacos = 'Uvozi iz imenika stikov';
z.string.sl.preferencesOptionsContactsDetail = 'Uporabljamo vaše podatke stikov pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';
z.string.sl.preferencesOptionsPopular = 'Po priljubljenosti';
z.string.sl.preferencesOptionsEmojiReplaceCheckbox = 'Zamenjaj čustvene simbole z emojiji';
z.string.sl.preferencesOptionsPreviewsSendCheckbox = 'Ustvari predogled za povezave, ki jih pošiljate';
z.string.sl.preferencesOptionsPreviewsSendDetail = 'Predogledi se še vedno lahko prikazujejo za povezave drugih ljudi.';
z.string.sl.preferencesOptionsNotifications = 'Obvestila';
z.string.sl.preferencesOptionsNotificationsNone = 'Izklopljeno';
z.string.sl.preferencesOptionsNotificationsObfuscate = 'Skrij podrobnosti';
z.string.sl.preferencesOptionsNotificationsObfuscateMessage = 'Pokaži pošiljatelja';
z.string.sl.preferencesOptionsNotificationsOn = 'Pokaži pošiljatelja in sporočilo';

z.string.sl.backupCancel = 'Prekliči';

z.string.sl.searchConnect = 'Poveži';
z.string.sl.searchConnections = 'Povezave';
z.string.sl.searchContacts = 'Stiki';
z.string.sl.searchCreateGroup = 'Ustvari skupino';
z.string.sl.searchGroups = 'Skupine';
z.string.sl.searchPeople = 'Osebe';
z.string.sl.searchPlaceholder = 'Iskanje po imenu ali uporabniškem imenu';
z.string.sl.searchServicePlaceholder = 'Iskanje po imenu';
z.string.sl.searchServices = 'Storitve';
z.string.sl.searchTeamGroups = 'Ekipni pogovori';
z.string.sl.searchTeamMembers = 'Člani ekipe';
z.string.sl.searchTopPeople = 'Top osebe';
z.string.sl.searchTrySearch = 'Najdi osebe po imenu ali uporabniškem imenu';
z.string.sl.searchNoContactsOnWire = 'Nimate nobenih stikov na Wire.\nPoizkusite najti osebe po imenu\nali uporabniškem imenu.';
z.string.sl.searchOthers = 'Poveži';

z.string.sl.searchInvite = 'Povabi ostale osebe na Wire';
z.string.sl.searchInviteDetail = 'Deljenje vaših stikov pomaga pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';
z.string.sl.searchInviteButtonContacts = 'Iz imenika stikov';
z.string.sl.searchInviteButtonGmail = 'Iz Gmail';
z.string.sl.searchInviteHeadline = 'Pripeljite vaše prijatelje';
z.string.sl.searchInviteShare = 'Deli Stike';

z.string.sl.searchListEveryoneParticipates = 'Vsi \ns katerimi ste povezani,\nso že v tem pogovoru.';
z.string.sl.searchListNoMatches = 'Brez ujemanja rezultatov. \nPoizkusite vnesti drugo ime.';


z.string.sl.uploadGoogleHeadline = 'Poiščite osebe\nza pogovor.';
z.string.sl.uploadGoogleMessage = 'Uporabljamo vaše podatke stikov pri povezovanju z drugimi. Vse informacije anonimiziramo in ne delimo z drugimi.';

z.string.sl.warningCallUnsupportedIncoming = '{{user}} kliče. Vaš brskalnik ne podpira klicev.';
z.string.sl.warningCallUnsupportedOutgoing = 'Ne morete klicati, ker vaš brskalnik ne podpira klicev.';
z.string.sl.warningCallIssues = 'Ta različica Wire ne more sodelovati v klicu. Prosimo uporabite';
z.string.sl.warningCallUpgradeBrowser = 'Če želite klicati, posodobite Google Chrome.';
z.string.sl.warningConnectivityConnectionLost = 'Poizkus povezave. Wire morda ne bo mogel dostaviti sporočila.';
z.string.sl.warningConnectivityNoInternet = 'Ni spletne povezave. Ne boste mogli pošiljati ali prejemati sporočil.';
z.string.sl.warningLearnMore = 'Nauči se več';
z.string.sl.warningLifecycleUpdate = 'Na voljo je nova različica Wire.';
z.string.sl.warningLifecycleUpdateNotes = 'Kaj je novega';
z.string.sl.warningLifecycleUpdateLink = 'Posodobi zdaj';
z.string.sl.warningNotFoundCamera = 'Ne morete klicati, ker vaš računalnik nima kamere.';
z.string.sl.warningNotFoundMicrophone = 'Ne morete klicati, ker vaš računalnik nima mikrofona.';
z.string.sl.warningPermissionDeniedCamera = 'Ne morete klicati, ker vaš brskalnik nima dostopa do kamere.';
z.string.sl.warningPermissionDeniedMicrophone = 'Klicati ni mogoče, ker vaš brskalnik nima dostopa do mikrofona.';
z.string.sl.warningPermissionDeniedScreen = 'Vaš brskalnik potrebuje dovoljenje za deljenje vašega zaslona.';
z.string.sl.warningPermissionRequestCamera = '{{icon}} Dovoli dostop do kamere';
z.string.sl.warningPermissionRequestMicrophone = '{{icon}} Dovoli dostop do mikrofona';
z.string.sl.warningPermissionRequestNotification = '{{icon}} Dovoli obvestila';
z.string.sl.warningPermissionRequestScreen = '{{icon}} Dovoli dostop do zaslona';

z.string.sl.userAvailabilityAvailable = 'Na voljo';
z.string.sl.userAvailabilityNone = 'Nič';

z.string.sl.notificationAssetAdd = 'Je delil(-a) sliko';
z.string.sl.notificationConnectionAccepted = 'Je sprejel(-a) vašo zahtevo po povezavi';
z.string.sl.notificationConnectionConnected = 'Zdaj ste povezani';
z.string.sl.notificationConnectionRequest = 'Si želi povezati';
z.string.sl.notificationConversationCreate = '{{user}} je začel(-a) pogovor';
z.string.sl.notificationConversationRename = '{{user}} je preimenoval(-a) pogovor v {{name}}';
z.string.sl.notificationMemberJoinMany = '{{user}} je dodal(-a) {{number}} oseb v pogovor';
z.string.sl.notificationMemberJoinOne = '{{user1}} je dodal(-a) {{user2}} v pogovor';
z.string.sl.notificationMemberLeaveRemovedYou = '{{user}} te je odstranil(-a) iz pogovora';
z.string.sl.notificationObfuscated = 'Vam je poslal(-a) sporočilo';
z.string.sl.notificationObfuscatedTitle = 'Nekdo';
z.string.sl.notificationPing = 'Je pingal(-a)';
z.string.sl.notificationReaction = '{{reaction}} vaše sporočilo';
z.string.sl.notificationSharedAudio = 'Je delil(-a) zvočno sporočilo';
z.string.sl.notificationSharedFile = 'Je delil(-a) zbirko';
z.string.sl.notificationSharedLocation = 'Je delil(-a) lokacijo';
z.string.sl.notificationSharedVideo = 'Je delil(-a) video';
z.string.sl.notificationVoiceChannelActivate = 'Klicanje';
z.string.sl.notificationVoiceChannelDeactivate = 'Je klical(-a)';

z.string.sl.tooltipConversationAllVerified = 'Vsi prstni odtisi naprav so preverjeni';
z.string.sl.tooltipConversationCall = 'Klic';
z.string.sl.tooltipConversationEphemeral = 'Časovno sporočilo';
z.string.sl.tooltipConversationFile = 'Dodaj zbirko';
z.string.sl.tooltipConversationInputPlaceholder = 'Napiši sporočilo';
z.string.sl.tooltipConversationPeople = 'Osebe ({{shortcut}})';
z.string.sl.tooltipConversationPicture = 'Dodaj sliko';
z.string.sl.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.sl.tooltipConversationSearch = 'Iščite';
z.string.sl.tooltipConversationVideoCall = 'Videoklic';

z.string.sl.tooltipConversationsArchive = 'Arhiviraj ({{shortcut}})';
z.string.sl.tooltipConversationsArchived = 'Prikaži arhiv ({{number}})';
z.string.sl.tooltipConversationsMore = 'Več';
z.string.sl.tooltipConversationsNotify = 'Povrni zvok ({{shortcut}})';
z.string.sl.tooltipConversationsPreferences = 'Odpri nastavitve';
z.string.sl.tooltipConversationsSilence = 'Utišaj ({{shortcut}})';
z.string.sl.tooltipConversationsStart = 'Začni pogovor ({{shortcut}})';

z.string.sl.tooltipConversationDetailsRename = 'Spremeni ime pogovora';

z.string.sl.tooltipPreferencesContactsGmail = 'Prijavite se v vaš Gmail račun za deljenje stikov';
z.string.sl.tooltipPreferencesContactsMacos = 'Deli vse vaše stike iz macOS aplikacije Contacts';
z.string.sl.tooltipPreferencesPassword = 'Odpri drugo spletno stran za ponastavitev gesla';
z.string.sl.tooltipPreferencesPicture = 'Spremenite vašo sliko…';
z.string.sl.tooltipPreferencesRename = 'Spremenite vaše ime';

z.string.sl.tooltipSearchClose = 'Zapri (Esc)';

z.string.sl.initReceivedSelfUser = 'Hej, {{user}}.';
z.string.sl.initValidatedClient = 'Pridobivam vaše povezave in pogovore';
z.string.sl.initReceivedUserData = 'Preverjanje za morebitna nova sporočila';
z.string.sl.initEvents = 'Nalagam sporočila';

z.string.sl.ephemeralUnitsNone = 'Izklopljeno';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.tr.wireMacos = 'MacOS için Wire';
z.string.tr.wireWindows = 'Windows için Wire';
z.string.tr.wireLinux = 'Linux için Wire';
z.string.tr.nonexistentUser = 'Silinmiş Kullanıcı';
z.string.tr.and = 've';

z.string.tr.authAccountCountryCode = 'Ülke Kodu';
z.string.tr.authAccountPasswordForgot = 'Şifremi unuttum';
z.string.tr.authAccountPublicComputer = 'Bu ortak bir bilgisayar';
z.string.tr.authAccountSignIn = 'Giriş yap';
z.string.tr.authAccountSignInPhone = 'Telefon';

z.string.tr.authBlockedCookies = 'Wire’a giriş yapabilmek için çerezleri etkinleştirin.';
z.string.tr.authBlockedDatabase = 'Wire’ın mesajları gösterebilmek için yerel diske erişmesi lazım. Gizli modda yerel disk kullanılamaz.';
z.string.tr.authBlockedTabs = 'Wire zaten başka bir sekmede açık.';

z.string.tr.authVerifyAccountAdd = 'Ekle';
z.string.tr.authVerifyAccountDetail = 'Bu sizin Wire’ı birden fazla cihazda kullanmanıza olanak sağlar.';
z.string.tr.authVerifyAccountHeadline = 'Bir e-posta adresi ve şifre ekleyin.';
z.string.tr.authVerifyAccountLogout = 'Çıkış yap';
z.string.tr.authVerifyCodeDescription = '{{number}} gönderdiğimiz doğrulama kodunu girin.';
z.string.tr.authVerifyCodeResend = 'Kod gelmedi mi?';
z.string.tr.authVerifyCodeResendDetail = 'Tekrar gönder';
z.string.tr.authVerifyCodeResendTimer = '{{expiration}} içerisinde yeni bir kod isteyebilirsiniz.';
z.string.tr.authVerifyCodeChangePhone = 'Telefon numarasını değiştir';
z.string.tr.authVerifyPasswordHeadline = 'Şifrenizi girin';

z.string.tr.authLimitDevicesHeadline = 'Cihazlar';
z.string.tr.authLimitDescription = 'Bu cihazda Wire’ı kullanabilmek için diğer cihazlarınızdan birini kaldırınız.';
z.string.tr.authLimitButtonManage = 'Cihazları yönet';
z.string.tr.authLimitButtonSignOut = 'Çıkış yap';
z.string.tr.authLimitDevicesCurrent = '(Mevcut)';

z.string.tr.authHistoryHeadline = 'Wire’ı bu cihazda ilk kez kullanıyorsunuz.';
z.string.tr.authHistoryDescription = 'Gizlilik sebeplerinden ötürü, mesaj geçmişiniz burada gösterilmemektedir.';
z.string.tr.authHistoryReuseHeadline = 'Bu cihazdan daha önce Wire kullanmışsınız.';
z.string.tr.authHistoryReuseDescription = 'Bu sırada gönderilen mesajlar burada görünmeyecektir.';
z.string.tr.authHistoryButton = 'TAMAM';

z.string.tr.authPostedResend = '{{email}}’a tekrar gönder';
z.string.tr.authPostedResendAction = 'E-posta gelmedi mi?';
z.string.tr.authPostedResendDetail = 'E-posta gelen kutunuzu kontrol edin ve talimatları izleyin.';
z.string.tr.authPostedResendHeadline = 'E-posta geldi.';

z.string.tr.authPlaceholderEmail = 'E-posta';
z.string.tr.authPlaceholderPasswordPut = 'Şifre';
z.string.tr.authPlaceholderPasswordSet = 'Şifre (en az 8 karakter)';
z.string.tr.authPlaceholderPhone = 'Telefon Numarası';

z.string.tr.authErrorCode = 'Geçersiz Kod';
z.string.tr.authErrorCountryCodeInvalid = 'Geçersiz Ülke Kodu';
z.string.tr.authErrorEmailExists = 'E-posta adresi zaten kullanımda';
z.string.tr.authErrorEmailForbidden = 'Üzgünüz. Bu e-posta adresi yasaklı.';
z.string.tr.authErrorEmailMalformed = 'Lütfen geçerli bir e-posta adresi girin.';
z.string.tr.authErrorEmailMissing = 'Lütfen bir e-posta adresi girin.';
z.string.tr.authErrorMisc = 'Bağlantı sorunları mevcut. Lütfen tekrar deneyin.';
z.string.tr.authErrorNameShort = 'En az 2 karakterlik bir isim girin';
z.string.tr.authErrorOffline = 'İnternet bağlantısı yok';
z.string.tr.authErrorPasswordShort = 'En az 8 karakterlik bir şifre seçin.';
z.string.tr.authErrorPasswordWrong = 'Yanlış şifre. Lütfen tekrar deneyin.';
z.string.tr.authErrorPending = 'Hesap doğrulanamadı';
z.string.tr.authErrorPhoneNumberBudget = 'Çok sık giriş yaptınız. Tekrardan deneyin.';
z.string.tr.authErrorPhoneNumberForbidden = 'Üzgünüz. Bu telefon numarası yasaklı.';
z.string.tr.authErrorPhoneNumberInvalid = 'Geçersiz Telefon Numarası';
z.string.tr.authErrorPhoneNumberUnknown = 'Bilinmeyen Telefon Numarası';
z.string.tr.authErrorSuspended = 'Bu hesap artık giriş yapmak için yeterli yetkiye sahip değil.';
z.string.tr.authErrorSignIn = 'Lütfen bilgilerinizi doğrulayıp öyle tekrar deneyiniz.';

z.string.tr.callStateOutgoing = 'Çalıyor…';
z.string.tr.callStateConnecting = 'Bağlanıyor…';
z.string.tr.callStateIncoming = 'Arıyor…';
z.string.tr.callDecline = 'Reddet';
z.string.tr.callAccept = 'Kabul et';
z.string.tr.callJoin = 'Katıl';
z.string.tr.callChooseSharedScreen = 'Paylaşmak için bir ekran seçin';
z.string.tr.callParticipants = '{{number}} çağrıda';

z.string.tr.videoCallOverlayMute = 'Sustur';
z.string.tr.videoCallOverlayHangUp = 'Kapat';

z.string.tr.modalAcknowledgeAction = 'Tamam';
z.string.tr.modalConfirmSecondary = 'İptal';
z.string.tr.modalOptionSecondary = 'İptal';

z.string.tr.modalAccountCreateAction = 'TAMAM';

z.string.tr.modalAccountDeletionAction = 'Sil';
z.string.tr.modalAccountDeletionHeadline = 'Hesabı Sil';
z.string.tr.modalAccountDeletionMessage = 'Size kısa mesaj veya e-posta aracılığıyla bir mesaj göndereceğiz. Mesajdaki bağlantıyı takip ederek hesabınızı kalıcı olarak silebilirsiniz.';

z.string.tr.modalAccountLeaveGuestRoomAction = 'Ayrıl';

z.string.tr.modalAccountLogoutAction = 'Çıkış yap';
z.string.tr.modalAccountLogoutHeadline = 'Veriyi Temizle?';
z.string.tr.modalAccountLogoutOption = 'Bu cihazdaki tüm kişisel bilgileriniz ve görüşme kayıtlarınızı silin.';

z.string.tr.modalAccountNewDevicesSecondary = 'Cihazları yönet';
z.string.tr.modalAccountNewDevicesHeadline = 'Hesabınız şurada kullanılmış:';
z.string.tr.modalAccountNewDevicesFrom = 'Cihaz:';
z.string.tr.modalAccountNewDevicesMessage = 'Eğer bunu yapan siz değilseniz, cihazı kaldırın ben şifrenizi sıfırlayın.';

z.string.tr.modalAccountRemoveDeviceAction = 'Cihazı kaldır';
z.string.tr.modalAccountRemoveDeviceHeadline = '"{{device}}" cihazını kaldır';
z.string.tr.modalAccountRemoveDeviceMessage = 'Cihazı kaldırmak için şifreniz gereklidir.';
z.string.tr.modalAccountRemoveDevicePlaceholder = 'Şifre';

z.string.tr.modalAssetTooLargeMessage = 'En fazla {{number}} büyüklüğünde dosyalar gönderebilirsiniz';

z.string.tr.modalAssetParallelUploadsMessage = 'Tek seferde en fazla {{number}} boyutunda dosya gönderebilirsiniz.';

z.string.tr.modalCallEmptyConversationHeadline = 'Arayacak kimse yok';
z.string.tr.modalCallEmptyConversationMessage = 'Burada kimse kalmadı.';

z.string.tr.modalCallNoGroupVideoHeadline = 'Gruplarda görüntülü konuşma yok';
z.string.tr.modalCallNoGroupVideoMessage = 'Görüntülü konuşma, grup konuşmalarında yapılamıyor.';

z.string.tr.modalCallNoMicrophoneAction = 'Anlat bana';
z.string.tr.modalCallNoMicrophoneMessage = 'Sesli aramalar yapmak için tarayıcınızın mikrofona erişim izni alması gerekir.';
z.string.tr.modalCallNoMicrophoneHeadline = 'Mikrofon olmadan arama yapılamaz';

z.string.tr.modalCallSecondIncomingAction = 'Cevapla';
z.string.tr.modalCallSecondIncomingHeadline = 'Aramayı cevapla?';
z.string.tr.modalCallSecondIncomingMessage = 'Mevcut aramanız sonlanacak.';

z.string.tr.modalCallSecondOngoingAction = 'Kapat';
z.string.tr.modalCallSecondOngoingHeadline = 'Aramayı başka bir cihazda kapa?';
z.string.tr.modalCallSecondOngoingMessage = 'Aynı anda tek bir aramada bulunabilirsiniz.';

z.string.tr.modalCallSecondOutgoingAction = 'Kapat';
z.string.tr.modalCallSecondOutgoingHeadline = 'Mevcut konuşmayı sonlandır?';
z.string.tr.modalCallSecondOutgoingMessage = 'Aynı anda tek bir aramada bulunabilirsiniz.';

z.string.tr.modalConnectCancelAction = 'Evet';
z.string.tr.modalConnectCancelHeadline = 'İsteği İptal et?';
z.string.tr.modalConnectCancelMessage = '{{user}}’e olan bağlantı isteğini iptal et.';
z.string.tr.modalConnectCancelSecondary = 'Hayır';

z.string.tr.modalConnectAcceptAction = 'Bağlan';
z.string.tr.modalConnectAcceptHeadline = 'Kabul et?';
z.string.tr.modalConnectAcceptMessage = 'Bu sizi {{user}} ile bağlayacak ve bir konuşma başlatacak.';
z.string.tr.modalConnectAcceptSecondary = 'Görmezden gel';

z.string.tr.modalConversationClearAction = 'Sil';
z.string.tr.modalConversationClearHeadline = 'İçerik silinsin?';
z.string.tr.modalConversationClearOption = 'Ayrıca konuşmadan da ayrıl';

z.string.tr.modalConversationDeleteMessageAction = 'Sil';
z.string.tr.modalConversationDeleteMessageHeadline = 'Sadece benim için sil?';
z.string.tr.modalConversationDeleteMessageMessage = 'Bu işlem geri alınamaz.';

z.string.tr.modalConversationDeleteMessageEveryoneAction = 'Sil';
z.string.tr.modalConversationDeleteMessageEveryoneHeadline = 'Herkes için sil?';
z.string.tr.modalConversationDeleteMessageEveryoneMessage = 'Bu işlem geri alınamaz.';

z.string.tr.modalConversationLeaveAction = 'Ayrıl';
z.string.tr.modalConversationLeaveMessage = 'Bu konuşmada, artık mesaj gönderemeyecek ve mesaj alamayacaksınız.';

z.string.tr.modalConversationMessageTooLongHeadline = 'Mesaj çok uzun';
z.string.tr.modalConversationMessageTooLongMessage = 'En fazla {{number}} karakterlik mesajlar gönderebilirsiniz.';

z.string.tr.modalConversationNewDeviceHeadlineOne = '{{user}} yeni bir cihaz kullanmaya başladı';
z.string.tr.modalConversationNewDeviceHeadlineMany = '{{user}}s yeni cihazlar kullanmaya başladılar';
z.string.tr.modalConversationNewDeviceHeadlineYou = '{{user}} yeni bir cihaz kullanmaya başladı';
z.string.tr.modalConversationNewDeviceIncomingCallAction = 'Aramayı kabul et';
z.string.tr.modalConversationNewDeviceIncomingCallMessage = 'Hala aramayı kabul etmek istiyor musunuz?';
z.string.tr.modalConversationNewDeviceMessage = 'Hâlâ mesajlarınızı göndermek istiyor musunuz?';
z.string.tr.modalConversationNewDeviceOutgoingCallAction = 'Yine de ara';
z.string.tr.modalConversationNewDeviceOutgoingCallMessage = 'Hala aramayı istiyor musunuz?';

z.string.tr.modalConversationNotConnectedHeadline = 'Hiç kimseye konuşmaya katılmadı';
z.string.tr.modalConversationNotConnectedMessageOne = '{{name}} sohbetlere eklenmek istemiyor.';
z.string.tr.modalConversationNotConnectedMessageMany = 'Seçtiğin kişilerden biri sohbetlere eklenmek istemiyor.';

z.string.tr.modalConversationRemoveAction = 'Çıkart';
z.string.tr.modalConversationRemoveHeadline = 'Çıkar?';
z.string.tr.modalConversationRemoveMessage = '{{user}} bu konuşmaya mesaj gönderemeyecek ve bu konuşmadan mesaj alamayacak.';

z.string.tr.modalConversationRemoveGuestsAction = 'Çıkart';

z.string.tr.modalConversationTooManyMembersHeadline = 'Dolup taşmış';

z.string.tr.modalIntegrationUnavailableHeadline = 'Botlar şuanda kullanılabilir değil';
z.string.tr.modalIntegrationUnavailableMessage = 'Botlara ilginiz için teşekkür ederiz. Bir bir sonraki sürüm üzerinde çalışırken hizmet askıya alınmış. Beklemede kalın.';


z.string.tr.modalImproveWireAction = 'Kabul et';
z.string.tr.modalImproveWireSecondary = 'Hayır';

z.string.tr.modalSessionResetHeadline = 'Oturum sıfırlandı';
z.string.tr.modalSessionResetMessage1 = 'Eğer sorun çözülmemişse,';
z.string.tr.modalSessionResetMessageLink = 'iletişime geç';
z.string.tr.modalSessionResetMessage2 = 'biz.';

z.string.tr.modalUploadContactsAction = 'Tekrar deneyin';
z.string.tr.modalUploadContactsMessage = 'Bilgilerinzi alamadık. Lütfen kişileriniz yeniden içe aktarmayı deneyin.';

z.string.tr.modalUserBlockAction = 'Engelle';
z.string.tr.modalUserBlockHeadline = '{{user}} engellensin mi?';
z.string.tr.modalUserBlockMessage = '{{user}} sizinle iletişim kuramayacak ve sizi grup konuşmalarına ekleyemeyecek.';

z.string.tr.modalUserUnblockAction = 'Engeli kaldır';
z.string.tr.modalUserUnblockHeadline = 'Engeli kaldır?';
z.string.tr.modalUserUnblockMessage = '{{user}} sizinle tekrardan iletişim kurabilecek ve sizi grup konuşmalarına ekleyebilecek.';

z.string.tr.connectionRequestConnect = 'Bağlan';
z.string.tr.connectionRequestIgnore = 'Görmezden gel';

z.string.tr.conversationGuestIndicator = 'Misafir';

z.string.tr.conversationYouNominative = 'sen';
z.string.tr.conversationYouDative = 'sen';
z.string.tr.conversationYouAccusative = 'sen';

z.string.tr.conversationConnectionAccepted = 'Bağlanıldı';
z.string.tr.conversationConnectionBlocked = 'Engellendi';
z.string.tr.conversationConnectionCancelRequest = 'Bağlantı isteğini iptal et';
z.string.tr.conversationDeviceStartedUsingOne = ' kullanmaya başladı';
z.string.tr.conversationDeviceStartedUsingMany = ' kullanmaya başladı';
z.string.tr.conversationDeviceUnverified = ' doğrulanmamışlardan bir tane';
z.string.tr.conversationDeviceYourDevices = ' cihazların';
z.string.tr.conversationDeviceUserDevices = ' {{user}} ’in cihazları';
z.string.tr.conversationDeviceNewDeviceOne = ' yeni bir cihaz';
z.string.tr.conversationDeviceNewDeviceMany = ' yeni cihazlar';
z.string.tr.conversationDeviceNewPeopleJoinedVerify = ' cihazları doğrula';
z.string.tr.conversationJustNow = 'Şimdi';
z.string.tr.conversationLocationLink = 'Haritayı Aç';
z.string.tr.conversationMessageDelivered = 'Teslim edildi';
z.string.tr.conversationRename = ' konuşmayı yeniden adlandırdı';
z.string.tr.conversationRenameYou = ' konuşmayı yeniden adlandırdı';
z.string.tr.conversationResume = '{{users}} ile bir görüşme başlat';
z.string.tr.conversationPing = ' pingledi';
z.string.tr.conversationPingYou = ' pingledi';
z.string.tr.conversationToday = 'bugün';
z.string.tr.conversationVoiceChannelDeactivate = ' aradı';
z.string.tr.conversationVoiceChannelDeactivateYou = ' aradı';
z.string.tr.conversationYesterday = 'Dün';
z.string.tr.conversationUnableToDecrypt1 = '{{user}}’den gelen bir mesaj alınamadı.';
z.string.tr.conversationUnableToDecrypt2 = '{{user}}’nin cihaz kimliği değişti. Teslim edilmemiş mesaj.';
z.string.tr.conversationUnableToDecryptLink = 'Neden?';
z.string.tr.conversationUnableToDecryptErrorMessage = 'Hata';
z.string.tr.conversationUnableToDecryptResetSession = 'Oturumu Sıfırla';
z.string.tr.conversationMissedMessages = 'Bir süredir bu cihazı kullanmıyorsun. Bazı mesajlar gösterilmeyebilir.';
z.string.tr.conversationAssetDownloading = 'İndiriliyor…';
z.string.tr.conversationAssetUploadFailed = 'Karşıya Yükleme Başarısız';
z.string.tr.conversationPlaybackError = 'Oynatılamıyor';
z.string.tr.conversationContextMenuCopy = 'Kopyala';
z.string.tr.conversationContextMenuEdit = 'Düzenle';
z.string.tr.conversationContextMenuDelete = 'Benim için sil';
z.string.tr.conversationContextMenuDeleteEveryone = 'Herkes için sil';
z.string.tr.conversationContextMenuDownload = 'İndir';
z.string.tr.conversationContextMenuLike = 'Beğen';
z.string.tr.conversationContextMenuUnlike = 'Beğenme';
z.string.tr.conversationDeleteTimestamp = '{{date}} ’da silinmiş';
z.string.tr.conversationEditTimestamp = '{{date}} ’da düzenlenmiş';
z.string.tr.conversationLikesCaption = '{{number}} kişi';
z.string.tr.conversationSendPastedFile = 'Yapıştırılmış resim, {{date}} ’de';
z.string.tr.conversationSomeone = 'Birisi';
z.string.tr.conversationTweetAuthor = ' Twitter’da';

z.string.tr.groupCreationPreferencesAction = 'İleri';
z.string.tr.groupCreationParticipantsActionCreate = 'Yapıldı';
z.string.tr.groupCreationParticipantsPlaceholder = 'İsme göre ara';


z.string.tr.collectionShowAll = '{{number}}’nun tümünü göster';
z.string.tr.collectionSectionLinks = 'Bağlantılar';
z.string.tr.collectionSectionImages = 'Resimler';
z.string.tr.collectionSectionFiles = 'Dosyalar';
z.string.tr.collectionSectionAudio = 'Sesli mesajlar';

z.string.tr.fullsearchPlaceholder = 'Metin mesajlarında ara';
z.string.tr.fullsearchNoResults = 'Sonuç yok.';

z.string.tr.archiveHeader = 'Arşivle';

z.string.tr.conversationsAllArchived = 'Her şey arşivlendi';
z.string.tr.conversationsContacts = 'Kişiler';
z.string.tr.conversationsConnectionRequestMany = '{{number}} kişi bekliyor';
z.string.tr.conversationsConnectionRequestOne = 'Bir kişi bekliyor';
z.string.tr.conversationsEmptyConversation = 'Grup sohbeti';
z.string.tr.conversationsNoConversations = 'Hiç konuşma yok';
z.string.tr.conversationsPopoverArchive = 'Arşivle';
z.string.tr.conversationsPopoverCancel = 'İsteği iptal et';
z.string.tr.conversationsPopoverNotify = 'Susturmayı Aç';
z.string.tr.conversationsPopoverSilence = 'Sustur';
z.string.tr.conversationsPopoverUnarchive = 'Arşivden Çıkar';

z.string.tr.conversationsSecondaryLineEphemeralMessage = 'Size bir mesaj gönderdi';
z.string.tr.conversationsSecondaryLinePeopleLeft = '{{number}} kişi ayrıldı';
z.string.tr.conversationsSecondaryLinePersonLeft = '{{user}} ayrıldı';
z.string.tr.conversationsSecondaryLinePersonRemoved = '{{user}} çıkartıldı';
z.string.tr.conversationsSecondaryLinePeopleAdded = '{{user}} kişi eklendi';
z.string.tr.conversationsSecondaryLinePersonAdded = '{{user}} eklendi';
z.string.tr.conversationsSecondaryLinePersonAddedYou = '{{user}} seni ekledi';
z.string.tr.conversationsSecondaryLineRenamed = '{{user}} konuşmayı yeniden adlandırdı';
z.string.tr.conversationsSecondaryLineYouLeft = 'Ayrıldın';
z.string.tr.conversationsSecondaryLineYouWereRemoved = 'Çıkartıldınız';

z.string.tr.takeoverSub = 'Wire üzerinden size özel isminizi hemen alın.';
z.string.tr.takeoverLink = 'Daha fazla bilgi';
z.string.tr.takeoverButtonChoose = 'Kendininkini seç';
z.string.tr.takeoverButtonKeep = 'Bunu sakla';

z.string.tr.inviteMetaKeyMac = 'Cmd';
z.string.tr.inviteMetaKeyPc = 'Ctrl';
z.string.tr.inviteHeadline = 'İnsanların Wire’a davet et';
z.string.tr.inviteMessage = 'Wire’dayım, {{username}} olarak arat ya da get.wire.com adresini ziyaret et.';
z.string.tr.inviteMessageNoEmail = 'Wire’dayım. get.wire.com ’u ziyaret ederek bana bağlanabilirsin.';

z.string.tr.extensionsBubbleButtonGif = 'Gif';

z.string.tr.extensionsGiphyButtonOk = 'Gönder';
z.string.tr.extensionsGiphyButtonMore = 'Başkasını Dene';
z.string.tr.extensionsGiphyMessage = '{{tag}} • giphy.com aracılığıyla';
z.string.tr.extensionsGiphyNoGifs = 'Olamaz, hiç Gif yok';
z.string.tr.extensionsGiphyRandom = 'Rastgele';

z.string.tr.addParticipantsConfirmLabel = 'Ekle';
z.string.tr.addParticipantsSearchPlaceholder = 'İsme göre ara';
z.string.tr.addParticipantsTabsPeople = 'İnsanlar';
z.string.tr.addParticipantsTabsServices = 'Servisler';

z.string.tr.conversationDetailsActionArchive = 'Arşivle';
z.string.tr.conversationDetailsActionCancelRequest = 'İsteği iptal et';
z.string.tr.conversationDetailsActionDevices = 'Cihazlar';
z.string.tr.conversationDetailsActionNotifications = 'Bildirimler';
z.string.tr.conversationDetailsGuestsOff = 'Yok';
z.string.tr.conversationDetailsOptions = 'Ayarlar';
z.string.tr.conversationDetailsParticipantsServicesMany = 'Servisler';
z.string.tr.conversationDetailsParticipantsUsersMany = 'İnsanlar';
z.string.tr.conversationDetailsPeople = 'İnsanlar';
z.string.tr.conversationDetailsServices = 'Servisler';

z.string.tr.conversationParticipantsTitle = 'İnsanlar';
z.string.tr.conversationParticipantsSearchPlaceholder = 'İsme göre ara';

z.string.tr.groupParticipantActionCancelRequest = 'İsteği iptal et';
z.string.tr.groupParticipantActionDevices = 'Cihazlar';
z.string.tr.groupParticipantActionPending = 'Beklemede';
z.string.tr.groupParticipantActionSendRequest = 'Bağlan';

z.string.tr.notificationSettingsTitle = 'Bildirimler';

z.string.tr.participantDevicesDetailHeadline = 'Bunun {{html1}}{{user}}s’in aygıtında gösterilen{{html2}} parmak iziyle eşleştiğini doğrulayın.';
z.string.tr.participantDevicesDetailHowTo = 'Bunu nasıl yapıyoruz?';
z.string.tr.participantDevicesDetailResetSession = 'Oturumu Sıfırla';
z.string.tr.participantDevicesDetailShowMyDevice = 'Cihaz parmak izimi göster';
z.string.tr.participantDevicesDetailVerify = 'Doğrulanmış';

z.string.tr.participantDevicesHeader = 'Cihazlar';
z.string.tr.participantDevicesHeadline = 'Wire her cihaza eşsiz bir parmak izi verir. {{user}} ile karşılaştırın ve konuşmayı doğrulayın.';
z.string.tr.participantDevicesLearnMore = 'Daha fazla bilgi';
z.string.tr.participantDevicesWhyVerify = 'Neden konuşmaları doğrulamalıyız?';
z.string.tr.participantDevicesOutdatedClientMessage = '{{user}}, Wire’ın eski bir versiyonunu kullanıyor. Hiçbir cihaz burada gösterilmiyor.';

z.string.tr.participantDevicesSelfAllDevices = 'Tüm cihazlarımı göster';
z.string.tr.participantDevicesSelfFingerprint = 'Cihaz parmak izi';

z.string.tr.userProfileButtonConnect = 'Bağlan';
z.string.tr.userProfileButtonIgnore = 'Görmezden gel';
z.string.tr.userProfileButtonUnblock = 'Engeli kaldır';

z.string.tr.preferencesAbout = 'Hakkında';
z.string.tr.preferencesAccount = 'Hesap';
z.string.tr.preferencesAV = 'Ses / Görüntü';
z.string.tr.preferencesDeviceDetails = 'Cihaz Detayları';
z.string.tr.preferencesDevices = 'Cihazlar';
z.string.tr.preferencesHeadline = 'Seçenekler';
z.string.tr.preferencesOptions = 'Ayarlar';

z.string.tr.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.tr.preferencesAboutPrivacyPolicy = 'Gizlilik Politikası';
z.string.tr.preferencesAboutSupport = 'Destek';
z.string.tr.preferencesAboutSupportWebsite = 'Destek İnternet Sitesi';
z.string.tr.preferencesAboutSupportContact = 'Destekle İletişime Geç';
z.string.tr.preferencesAboutTermsOfUse = 'Kullanım Şartları';
z.string.tr.preferencesAboutVersion = 'Sürüm: {{version}}';
z.string.tr.preferencesAboutWebsite = 'Wire İnternet Sitesi';

z.string.tr.preferencesAccountAvaibilityUnset = 'Bir durum ayarlayın';
z.string.tr.preferencesAccountCreateTeam = 'Bir takım oluştur';
z.string.tr.preferencesAccountDelete = 'Hesabı Sil';
z.string.tr.preferencesAccountLogOut = 'Çıkış yap';
z.string.tr.preferencesAccountManageTeam = 'Takım yönet';
z.string.tr.preferencesAccountResetPassword = 'Şifreni sıfırla';
z.string.tr.preferencesAccountTeam = '{{name}}’de';
z.string.tr.preferencesAccountUsernamePlaceholder = 'Tam adınız';
z.string.tr.preferencesAccountUsernameHint = 'En az 2 karakter. a—z, 0—9, ve yalnızca _.';
z.string.tr.preferencesAccountUsernameAvailable = 'Alınabilir';
z.string.tr.preferencesAccountUsernameErrorTaken = 'Çoktan alınmış';

z.string.tr.preferencesAVCamera = 'Kamera';
z.string.tr.preferencesAVMicrophone = 'Mikrofon';
z.string.tr.preferencesAVPermissionDetail = 'Tarayıcı Seçeneklerinizden aktifleştirin';
z.string.tr.preferencesAVSpeakers = 'Hoparlörler';

z.string.tr.preferencesDevicesActivatedOn = '{{date}} ’da aktif edildi';
z.string.tr.preferencesDevicesActive = 'Aktif';
z.string.tr.preferencesDevicesActiveDetail = 'Eğer yukarıdaki cihazı tanımıyorsanız, cihazı kaldırın ve şifrenizi sıfırlayın.';
z.string.tr.preferencesDevicesCurrent = 'Mevcut';
z.string.tr.preferencesDevicesFingerprint = 'Anahtar Parmak İzi';
z.string.tr.preferencesDevicesFingerprintDetail = 'Wire her cihaza kendine has bir parmak izi verir. Cihazlarınızı ve konuşmalarınızı doğrulamak için parmak izlerinizi karşılaştırın.';
z.string.tr.preferencesDevicesId = 'ID: ';
z.string.tr.preferencesDevicesRemoveCancel = 'İptal';
z.string.tr.preferencesDevicesRemoveDetail = 'Eğer bu cihazı kullanmayı bıraktıysanız, cihazı kaldırın. Ardından cihazdan otomatik olarak çıkış yapılacaktır.';
z.string.tr.preferencesDevicesSessionConfirmation = 'Oturum sıfırlandı.';
z.string.tr.preferencesDevicesSessionDetail = 'Parmak izleri eşleşmezse, her iki tarafta da yeni şifreleme anahtarları oluşturmak için oturumu sıfırlayın.';
z.string.tr.preferencesDevicesSessionReset = 'Oturumu Sıfırla';
z.string.tr.preferencesDevicesSessionOngoing = 'Oturum sıfırlanıyor…';
z.string.tr.preferencesDevicesVerification = 'Doğrulanmış';

z.string.tr.preferencesOptionsAudio = 'Sesli uyarılar';
z.string.tr.preferencesOptionsAudioAll = 'Hepsi';
z.string.tr.preferencesOptionsAudioAllDetail = 'Tüm Sesler';
z.string.tr.preferencesOptionsAudioNone = 'Hiçbiri';
z.string.tr.preferencesOptionsAudioNoneDetail = 'Şüşşş!';
z.string.tr.preferencesOptionsAudioSome = 'Bazıları';
z.string.tr.preferencesOptionsAudioSomeDetail = 'Pingler ve aramalar';
z.string.tr.preferencesOptionsContacts = 'Kişiler';
z.string.tr.preferencesOptionsContactsGmail = 'Gmail’den içe aktar';
z.string.tr.preferencesOptionsContactsMacos = 'Kişilerden içe aktar';
z.string.tr.preferencesOptionsContactsDetail = 'İletişim verilerinizi sizi başkalarıyla bağlayabilmek için kullanıyoruz. Tüm bilgilerinizi gizler ve kimseyle paylaşmayız.';
z.string.tr.preferencesOptionsPopular = 'Yoğun istek üzerine';
z.string.tr.preferencesOptionsEmojiReplaceCheckbox = 'Yazı halindeki emojileri, gerçek emojiler ile değiştir';
z.string.tr.preferencesOptionsPreviewsSendCheckbox = 'Gönderdiğin bağlantılar için ön izlemeler oluştur';
z.string.tr.preferencesOptionsPreviewsSendDetail = 'Ön izlemeler hala başkalarından gelen bağlantılar için görüntülenebilir olabilir.';
z.string.tr.preferencesOptionsNotifications = 'Bildirimler';
z.string.tr.preferencesOptionsNotificationsNone = 'Yok';
z.string.tr.preferencesOptionsNotificationsObfuscate = 'Ayrıntıyı gizle';
z.string.tr.preferencesOptionsNotificationsObfuscateMessage = 'Göndereni göster';
z.string.tr.preferencesOptionsNotificationsOn = 'Göndereni ve mesajı göster';

z.string.tr.backupCancel = 'İptal';

z.string.tr.searchConnect = 'Bağlan';
z.string.tr.searchConnections = 'Bağlantılar';
z.string.tr.searchContacts = 'Kişiler';
z.string.tr.searchCreateGroup = 'Grup oluştur';
z.string.tr.searchGroups = 'Gruplar';
z.string.tr.searchPeople = 'İnsanlar';
z.string.tr.searchPlaceholder = 'İsim veya kullanıcı adına göre ara';
z.string.tr.searchServicePlaceholder = 'İsme göre ara';
z.string.tr.searchServices = 'Servisler';
z.string.tr.searchTeamGroups = 'Takım Konuşmaları';
z.string.tr.searchTeamMembers = 'Takım Üyeleri';
z.string.tr.searchTopPeople = 'Enler';
z.string.tr.searchTrySearch = 'İnsanları isimlerine veya kullanıcı adlarına göre bul';
z.string.tr.searchNoContactsOnWire = 'Wire’da hiç kişiniz yok. İnsanları isimlerine veya kullanıcı adlarına göre bulmayı deneyin.';
z.string.tr.searchOthers = 'Bağlan';

z.string.tr.searchInvite = 'İnsanları Wire’a katılmaya davet edin';
z.string.tr.searchInviteDetail = 'Kişileriniz paylaşmak, başkalarıyla bağlanmanızı kolaylaştırır. Tüm bilgilerinizi gizler ve kimseyle paylaşmayız.';
z.string.tr.searchInviteButtonContacts = 'Kişilerden';
z.string.tr.searchInviteButtonGmail = 'Gmail’den';
z.string.tr.searchInviteHeadline = 'Arkadaşlarınızı getirin';
z.string.tr.searchInviteShare = 'Kişileri Paylaş';

z.string.tr.searchListEveryoneParticipates = 'Bağlantıda olduğun herkes zaten bu görüşme içerisinde.';
z.string.tr.searchListNoMatches = 'Eşleşen sonuç yok.\nBaşka bir isim girmeyi deneyin.';

z.string.tr.temporaryGuestCta = 'Bir hesap oluştur';

z.string.tr.uploadGoogleHeadline = 'Konuşmak için\ninsanları bul.';
z.string.tr.uploadGoogleMessage = 'İletişim verilerinizi sizi başkalarıyla bağlayabilmek için kullanıyoruz. Tüm bilgilerinizi gizler ve kimseyle paylaşmayız.';

z.string.tr.warningCallUnsupportedIncoming = '{{user}} arıyor. Ancak tarayıcınız sesli aramaları desteklemiyor.';
z.string.tr.warningCallUnsupportedOutgoing = 'Arama yapamazsınız çünkü tarayıcınız sesli aramaları desteklemiyor.';
z.string.tr.warningCallIssues = 'Wire’ın bu versiyonu aramalara katılamaz. Lütfen kullanın';
z.string.tr.warningCallUpgradeBrowser = 'Arama yapmak için, Google Chrome’u güncelleyin.';
z.string.tr.warningConnectivityConnectionLost = 'Bağlanmaya çalışılıyor. Wire mesajlarınızı teslim etmekte sorun yaşayabilir.';
z.string.tr.warningConnectivityNoInternet = 'İnternet bağlantısı yok. Mesaj gönderemez veya mesaj alamazsınız.';
z.string.tr.warningLearnMore = 'Daha fazla bilgi';
z.string.tr.warningLifecycleUpdate = 'Wire’ın yeni bir versiyonu mevcut.';
z.string.tr.warningLifecycleUpdateNotes = 'Neler yeni';
z.string.tr.warningLifecycleUpdateLink = 'Şimdi güncelle';
z.string.tr.warningNotFoundCamera = 'Arama yapamıyorsunuz çünkü bilgisayarınızda bir kamera bulunmamaktadır.';
z.string.tr.warningNotFoundMicrophone = 'Arama yapamıyorsunuz çünkü bilgisayarınızda bir mikrofon bulunmamaktadır.';
z.string.tr.warningPermissionDeniedCamera = 'Arama yapamıyorsunuz çünkü tarayıcınızın kameraya erişim izni bulunmamaktadır.';
z.string.tr.warningPermissionDeniedMicrophone = 'Arama yapamıyorsunuz çünkü tarayıcınızın mikrofona erişim izni bulunmamaktadır.';
z.string.tr.warningPermissionDeniedScreen = 'Tarayıcınız ekranınızı paylaşmak için gerekli izinleri sağlamalıdır.';
z.string.tr.warningPermissionRequestCamera = '{{icon}} Kameraya erişime izin ver';
z.string.tr.warningPermissionRequestMicrophone = '{{icon}} Mikrofona erişime izin ver';
z.string.tr.warningPermissionRequestNotification = '{{icon}} Bildirimlere izin ver';
z.string.tr.warningPermissionRequestScreen = '{{icon}} Ekrana erişime izin ver';

z.string.tr.userAvailabilityAvailable = 'Alınabilir';
z.string.tr.userAvailabilityAway = 'Uzakta';
z.string.tr.userAvailabilityBusy = 'Meşgul';
z.string.tr.userAvailabilityNone = 'Hiçbiri';

z.string.tr.notificationAssetAdd = 'Bir resim paylaştı';
z.string.tr.notificationConnectionAccepted = 'Bağlantı isteğinizi kabul etti';
z.string.tr.notificationConnectionConnected = 'Şu anda bağlısınız';
z.string.tr.notificationConnectionRequest = 'Bağlanmak istiyor';
z.string.tr.notificationConversationCreate = '{{user}} bir konuşma başlattı';
z.string.tr.notificationConversationRename = '{{user}}, konuşma ismini {{name}} olarak değiştirdi';
z.string.tr.notificationMemberJoinMany = '{{user}}, konuşmaya {{number}} kişi ekledi';
z.string.tr.notificationMemberJoinOne = '{{user1}}, {{user2}}’i konuşmaya ekledi';
z.string.tr.notificationMemberLeaveRemovedYou = '{{user}} sizi konuşmadan çıkardı';
z.string.tr.notificationObfuscated = 'Size bir mesaj gönderdi';
z.string.tr.notificationObfuscatedTitle = 'Birisi';
z.string.tr.notificationPing = 'Pingledi';
z.string.tr.notificationReaction = 'mesajınızı {{reaction}}';
z.string.tr.notificationSharedAudio = 'Bir sesli mesaj paylaştı';
z.string.tr.notificationSharedFile = 'Bir dosya paylaştı';
z.string.tr.notificationSharedLocation = 'Bir konum paylaştı';
z.string.tr.notificationSharedVideo = 'Bir video paylaştı';
z.string.tr.notificationVoiceChannelActivate = 'Arıyor';
z.string.tr.notificationVoiceChannelDeactivate = 'Aradı';

z.string.tr.tooltipConversationAllVerified = 'Tüm parmak izleri doğrulanmış';
z.string.tr.tooltipConversationCall = 'Ara';
z.string.tr.tooltipConversationEphemeral = 'Süreli Mesaj';
z.string.tr.tooltipConversationFile = 'Dosya Ekle';
z.string.tr.tooltipConversationInputPlaceholder = 'Bir mesaj yazın';
z.string.tr.tooltipConversationInputPlaceholderAvailable = '{{user}} müsait';
z.string.tr.tooltipConversationInputPlaceholderAway = '{{user}} uzakta';
z.string.tr.tooltipConversationInputPlaceholderBusy = '{{user}} meşgul';
z.string.tr.tooltipConversationPeople = 'İnsanlar ({{shortcut}})';
z.string.tr.tooltipConversationPicture = 'Resim ekle';
z.string.tr.tooltipConversationPing = 'Pingle ({{shortcut}})';
z.string.tr.tooltipConversationSearch = 'Arama';
z.string.tr.tooltipConversationVideoCall = 'Görüntülü Ara';

z.string.tr.tooltipConversationsArchive = 'Arşivle ({{shortcut}})';
z.string.tr.tooltipConversationsArchived = 'Arşivi göster ({{number}})';
z.string.tr.tooltipConversationsMore = 'Daha';
z.string.tr.tooltipConversationsNotify = 'Sesi aç ({{shortcut}})';
z.string.tr.tooltipConversationsPreferences = 'Seçenekleri aç';
z.string.tr.tooltipConversationsSilence = 'Sessize al ({{shortcut}})';
z.string.tr.tooltipConversationsStart = 'Konuşma başlat ({{shortcut}})';

z.string.tr.tooltipConversationDetailsRename = 'Konuşma adını değiştir';

z.string.tr.tooltipPreferencesContactsGmail = 'Kişilerinizi paylaşmak için Gmail hesabınıza giriş yapınız';
z.string.tr.tooltipPreferencesContactsMacos = 'MacOS Kişiler uygulaması aracılığıyla tüm kişilerinizi paylaşın';
z.string.tr.tooltipPreferencesPassword = 'Şifreyi sıfırlamak için yeni bir pencere aç';
z.string.tr.tooltipPreferencesPicture = 'Resminizi değiştirin…';
z.string.tr.tooltipPreferencesRename = 'İsminizi değiştirin';

z.string.tr.tooltipSearchClose = 'Kapat (Esc)';

z.string.tr.initReceivedSelfUser = 'Merhaba, {{user}}.';
z.string.tr.initValidatedClient = 'Bağlantılarınız ve konuşmalarınız alınıyor';
z.string.tr.initReceivedUserData = 'Yeni mesajlar kontrol ediliyor';
z.string.tr.initDecryption = 'Mesajların şifresini çöz';
z.string.tr.initEvents = 'İletiler yükleniyor';
z.string.tr.initUpdatedFromNotifications = 'Neredeyse bitti - Wire’ın keyfini çıkarın';
z.string.tr.initProgress = ' — {{number2}}’de/da {{number1}}';

z.string.tr.ephemeralUnitsNone = 'Yok';


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

z.string.uk.wire = 'Wire';
z.string.uk.wireMacos = 'Wire для macOS';
z.string.uk.wireWindows = 'Wire для Windows';
z.string.uk.wireLinux = 'Wire для Linux';
z.string.uk.nonexistentUser = 'Видалений користувач';
z.string.uk.and = 'і';
z.string.uk.enumerationAnd = ', і ';

//=Додаток завантажується
z.string.uk.authAccountCountryCode = 'Код країни';
z.string.uk.authAccountPasswordForgot = 'Забули пароль?';
z.string.uk.authAccountPublicComputer = 'Це загальнодоступний комп’ютер';
z.string.uk.authAccountSignIn = 'Увійти';
z.string.uk.authAccountSignInPhone = 'Вхід з номером телефону';

z.string.uk.authBlockedCookies = 'Увімкніть файли cookie, щоб увійти в Wire.';
z.string.uk.authBlockedDatabase = 'Wire потребує доступу до локальної бази даних для відображення повідомлень. Локальна база даних недоступна в приватному режимі.';
z.string.uk.authBlockedTabs = 'Wire уже відкрито в іншій вкладці браузера.';
z.string.uk.authBlockedTabsAction = 'Використовувати цю вкладку';

z.string.uk.authVerifyAccountAdd = 'Додати';
z.string.uk.authVerifyAccountDetail = 'Це дасть змогу використовувати Wire на різних пристроях.';
z.string.uk.authVerifyAccountHeadline = 'Додайте email та пароль.';
z.string.uk.authVerifyAccountLogout = 'Вийти';
z.string.uk.authVerifyCodeDescription = 'Введіть код верифікації,\nякий ми вислали на номер {{number}}.';
z.string.uk.authVerifyCodeResend = 'SMS так і не прийшло?';
z.string.uk.authVerifyCodeResendDetail = 'Надіслати ще раз';
z.string.uk.authVerifyCodeResendTimer = 'Ви можете надіслати запит запит на новий код {{expiration}}.';
z.string.uk.authVerifyCodeChangePhone = 'Змінити номер телефону';
z.string.uk.authVerifyPasswordHeadline = 'Введіть свій пароль';

z.string.uk.authLimitDevicesHeadline = 'Пристрої';
z.string.uk.authLimitDescription = 'Видаліть один з ваших пристроїв, щоб почати використовувати Wire на цьому.';
z.string.uk.authLimitButtonManage = 'Керування пристроями';
z.string.uk.authLimitButtonSignOut = 'Вийти';
z.string.uk.authLimitDevicesCurrent = '(Поточний)';

z.string.uk.authHistoryHeadline = 'Це перший раз, коли ви використовуєте Wire на цьому пристрої.';
z.string.uk.authHistoryDescription = 'З міркувань конфіденційності, історія ваших розмов тут не показується.';
z.string.uk.authHistoryReuseHeadline = 'Ви уже використовували Wire на цьому пристрої раніше.';
z.string.uk.authHistoryReuseDescription = 'Повідомлення, надіслані в той час, коли ви вийшли з Wire, не відображатимуться.';
z.string.uk.authHistoryButton = 'OK';

z.string.uk.authPostedResend = 'Надіслати повторно на {{email}}';
z.string.uk.authPostedResendAction = 'Не показується email?';
z.string.uk.authPostedResendDetail = 'Перевірте вашу поштову скриньку і дотримуйтесь надісланих інструкцій.';
z.string.uk.authPostedResendHeadline = 'Ви отримали нового листа.';

z.string.uk.authPlaceholderEmail = 'Email';
z.string.uk.authPlaceholderPasswordPut = 'Пароль';
z.string.uk.authPlaceholderPasswordSet = 'Пароль (не менше 8 символів)';
z.string.uk.authPlaceholderPhone = 'Номер телефону';

z.string.uk.authErrorCode = 'Невірний код';
z.string.uk.authErrorCountryCodeInvalid = 'Невірний код країни';
z.string.uk.authErrorEmailExists = 'Email вже використовується';
z.string.uk.authErrorEmailForbidden = 'Вибачте. Ця електронна адреса не дозволена для використання.';
z.string.uk.authErrorEmailMalformed = 'Будь ласка, введіть дійсний email.';
z.string.uk.authErrorEmailMissing = 'Будь ласка, введіть адресу електронної пошти.';
z.string.uk.authErrorMisc = 'Неполадки з підключенням. Будь ласка, спробуйте ще раз.';
z.string.uk.authErrorNameShort = 'Введіть ім’я довжиною не менше 2 символи';
z.string.uk.authErrorOffline = 'Відсутнє підключення до Інтернету';
z.string.uk.authErrorPasswordShort = 'Виберіть пароль довжиною від 6 до 20 символів.';
z.string.uk.authErrorPasswordWrong = 'Невірний пароль. Будь ласка, спробуйте ще раз.';
z.string.uk.authErrorPending = 'Акаунт поки що не підтверджений';
z.string.uk.authErrorPhoneNumberBudget = 'Ви входите в систему занадто часто. Спробуте пізніше.';
z.string.uk.authErrorPhoneNumberForbidden = 'Вибачте. Використання цього номеру телефону заборонено.';
z.string.uk.authErrorPhoneNumberInvalid = 'Невірний номер телефону';
z.string.uk.authErrorPhoneNumberUnknown = 'Невідомий номер телефону';
z.string.uk.authErrorSuspended = 'Даний акаунт був заблокований.';
z.string.uk.authErrorSignIn = 'Будь ласка, перевірте ваші дані та повторіть спробу.';

z.string.uk.callStateOutgoing = 'Дзвінок…';
z.string.uk.callStateConnecting = 'Підключення…';
z.string.uk.callStateIncoming = 'Дзвінок…';
z.string.uk.callStateIncomingGroup = '{{user}} дзвонить';
z.string.uk.callDecline = 'Скасувати';
z.string.uk.callAccept = 'Прийняти';
z.string.uk.callJoin = 'Приєднатись';
z.string.uk.callChooseSharedScreen = 'Оберіть робочий стіл, скріншотами якого ви хочете поділитися';
z.string.uk.callParticipants = '{{number}} учасників';
z.string.uk.callNoCameraAccess = 'Відсутній доступ до камери';

z.string.uk.videoCallOverlayFitVideoLabel = 'Подвійний клік, щоб припасувати розмір відео до контейнера';
z.string.uk.videoCallOverlayConversations = 'Розмови';
z.string.uk.videoCallOverlayMute = 'Вимк. звук';
z.string.uk.videoCallOverlayVideo = 'Відео';
z.string.uk.videoCallOverlayShareScreen = 'Показати свій екран';
z.string.uk.videoCallOverlayHangUp = 'Завершити';
z.string.uk.videoCallPaused = 'Відео призупинене';
z.string.uk.videoCallScreenShareNotSupported = 'Ваш браузер не підтримує спільний доступ до екрану';

z.string.uk.modalAcknowledgeAction = 'ОК';
z.string.uk.modalAcknowledgeHeadline = 'Щось пішло не так';
z.string.uk.modalConfirmSecondary = 'Скасувати';
z.string.uk.modalOptionSecondary = 'Скасувати';

z.string.uk.modalAccountCreateAction = 'OK';
z.string.uk.modalAccountCreateHeadline = 'Створити акаунт?';
z.string.uk.modalAccountCreateMessage = 'Створивши акаунт, ви втратите історію розмов у цій гостьовій кімнаті.';

z.string.uk.modalAccountDeletionAction = 'Видалити';
z.string.uk.modalAccountDeletionHeadline = 'Видалити акаунт';
z.string.uk.modalAccountDeletionMessage = 'Ми надішлемо вам повідомлення електронною поштою або через SMS. Перейдіть за посиланням, щоб остаточно видалити свій акаунт.';

z.string.uk.modalAccountLeaveGuestRoomAction = 'Вийти з розмови';
z.string.uk.modalAccountLeaveGuestRoomHeadline = 'Вийти з гостьової кімнати?';
z.string.uk.modalAccountLeaveGuestRoomMessage = 'Історію розмови буде видалено. Створіть акаунт, щоб зберегти її наступного разу.';

z.string.uk.modalAccountLogoutAction = 'Вийти';
z.string.uk.modalAccountLogoutHeadline = 'Очистити дані?';
z.string.uk.modalAccountLogoutOption = 'Видалити всі ваші особисті дані та розмови на цьому пристрої.';

z.string.uk.modalAccountNewDevicesSecondary = 'Керування пристроями';
z.string.uk.modalAccountNewDevicesHeadline = 'Ваш акаунт використовується на:';
z.string.uk.modalAccountNewDevicesFrom = 'Від:';
z.string.uk.modalAccountNewDevicesMessage = 'Якщо ви не робили цього, видаліть пристрій і змініть пароль.';

z.string.uk.modalAccountRemoveDeviceAction = 'Видалити пристрій';
z.string.uk.modalAccountRemoveDeviceHeadline = 'Видалити "{{device}}"';
z.string.uk.modalAccountRemoveDeviceMessage = 'Для видалення пристрою необхідно ввести ваш пароль.';
z.string.uk.modalAccountRemoveDevicePlaceholder = 'Пароль';

z.string.uk.modalAssetTooLargeHeadline = 'Файл завеликий';
z.string.uk.modalAssetTooLargeMessage = 'Ви можете надсилати файли до {{number}}';

z.string.uk.modalAssetParallelUploadsHeadline = 'Занадто багато файлів за один раз';
z.string.uk.modalAssetParallelUploadsMessage = 'Ви можете надіслати до {{number}} файлів за один раз.';

z.string.uk.modalCallEmptyConversationHeadline = 'Нікому дзвонити';
z.string.uk.modalCallEmptyConversationMessage = 'Тут більше нікого немає.';

z.string.uk.modalCallEmptyLogHeadline = 'Дзвінки відсутні';
z.string.uk.modalCallEmptyLogMessage = 'Не відбулося жодного дзвінка, на основі якого було би можливо згенерувати звіт.';

z.string.uk.modalCallNoGroupVideoHeadline = 'Відеодзвінки в групах не підтримуються';
z.string.uk.modalCallNoGroupVideoMessage = 'Відеодзвінки недоступні в групових розмовах.';

z.string.uk.modalCallNoMicrophoneAction = 'Скажіть мені як';
z.string.uk.modalCallNoMicrophoneMessage = 'Надайте вашому браузеру доступ до мікрофону, щоб робити дзвінки.';
z.string.uk.modalCallNoMicrophoneHeadline = 'Неможливо здійснити дзвінок без доступу до мікрофону';

z.string.uk.modalCallSecondIncomingAction = 'Відповісти';
z.string.uk.modalCallSecondIncomingHeadline = 'Відповісти на дзвінок?';
z.string.uk.modalCallSecondIncomingMessage = 'Поточний дзвінок буде завершено.';

z.string.uk.modalCallSecondOngoingAction = 'Завершити';
z.string.uk.modalCallSecondOngoingHeadline = 'Припинити дзвінок на іншому пристрої?';
z.string.uk.modalCallSecondOngoingMessage = 'Ви можете здійснювати тільки один дзвінок за один раз.';

z.string.uk.modalCallSecondOutgoingAction = 'Завершити';
z.string.uk.modalCallSecondOutgoingHeadline = 'Завершити поточний дзвінок?';
z.string.uk.modalCallSecondOutgoingMessage = 'Ви можете здійснювати тільки один дзвінок за один раз.';

z.string.uk.modalConnectCancelAction = 'Так';
z.string.uk.modalConnectCancelHeadline = 'Скасувати запит?';
z.string.uk.modalConnectCancelMessage = 'Видалити запит на додавання {{user}} до контактів.';
z.string.uk.modalConnectCancelSecondary = 'Ні';

z.string.uk.modalConnectAcceptAction = 'Додати до контактів';
z.string.uk.modalConnectAcceptHeadline = 'Прийняти?';
z.string.uk.modalConnectAcceptMessage = 'Це додасть {{user}} до ваших контактів та відкриє розмову.';
z.string.uk.modalConnectAcceptSecondary = 'Ігнорувати';

z.string.uk.modalConversationClearAction = 'Видалити';
z.string.uk.modalConversationClearHeadline = 'Видалити вміст?';
z.string.uk.modalConversationClearMessage = 'Це очистить історію розмови на всіх ваших пристроях.';
z.string.uk.modalConversationClearOption = 'Також вийти з розмови';

z.string.uk.modalConversationDeleteMessageAction = 'Видалити';
z.string.uk.modalConversationDeleteMessageHeadline = 'Видалити тільки для мене?';
z.string.uk.modalConversationDeleteMessageMessage = 'Цю дію неможливо скасувати.';

z.string.uk.modalConversationDeleteMessageEveryoneAction = 'Видалити';
z.string.uk.modalConversationDeleteMessageEveryoneHeadline = 'Видалити для всіх?';
z.string.uk.modalConversationDeleteMessageEveryoneMessage = 'Цю дію неможливо скасувати.';

z.string.uk.modalConversationLeaveAction = 'Вийти з розмови';
z.string.uk.modalConversationLeaveHeadline = 'Вийти з розмови {{name}}?';
z.string.uk.modalConversationLeaveMessage = 'Ви більше не зможете надсилати або отримувати повідомлення в цій розмові.';

z.string.uk.modalConversationMessageTooLongHeadline = 'Повідомлення занадто довге';
z.string.uk.modalConversationMessageTooLongMessage = 'Можна надсилати повідомлення довжиною до {{number}} символів.';

z.string.uk.modalConversationNewDeviceAction = 'Все одно надіслати';
z.string.uk.modalConversationNewDeviceHeadlineOne = '{{user}} почав(-ла) використовувати новий пристрій';
z.string.uk.modalConversationNewDeviceHeadlineMany = '{{user}}s почали використовувати нові пристрої';
z.string.uk.modalConversationNewDeviceHeadlineYou = '{{user}} почав(-ла) використовувати новий пристрій';
z.string.uk.modalConversationNewDeviceIncomingCallAction = 'Прийняти виклик';
z.string.uk.modalConversationNewDeviceIncomingCallMessage = 'Ви все ще хочете прийняти дзвінок?';
z.string.uk.modalConversationNewDeviceMessage = 'Все одно надіслати ваші повідомлення?';
z.string.uk.modalConversationNewDeviceOutgoingCallAction = 'Подзвонити все-одно';
z.string.uk.modalConversationNewDeviceOutgoingCallMessage = 'Ви все ще хочете здійснити дзвінок?';

z.string.uk.modalConversationNotConnectedHeadline = 'Жоден контакт не був доданий до розмови';
z.string.uk.modalConversationNotConnectedMessageOne = '{{name}} не хоче, щоб його додавали до розмови.';
z.string.uk.modalConversationNotConnectedMessageMany = 'Один з контактів, яких ви вибрали, не хоче, щоб його додавали до розмови.';

z.string.uk.modalConversationRemoveAction = 'Видалити';
z.string.uk.modalConversationRemoveHeadline = 'Видалити?';
z.string.uk.modalConversationRemoveMessage = '{{user}} більше не зможе надсилати або отримувати повідомлення в цій розмові.';

z.string.uk.modalConversationRemoveGuestsAction = 'Видалити гостей';
z.string.uk.modalConversationRemoveGuestsHeadline = 'Вимкнути гостьовий доступ?';
z.string.uk.modalConversationRemoveGuestsMessage = 'Поточні гості та сервіси будуть вилучені з розмови. Нові гості та сервіси не матимуть доступу до неї.';

z.string.uk.modalConversationRevokeLinkAction = 'Відкликати лінк';
z.string.uk.modalConversationRevokeLinkHeadline = 'Відкликати лінк?';
z.string.uk.modalConversationRevokeLinkMessage = 'Нові гості не зможуть приєднатися з цим лінком. Поточні гості все ще матимуть доступ.';

z.string.uk.modalConversationGuestOptionsAllowGuestMessage = 'Не вдалося активувати доступ для гостей та сервісів. Будь ласка, спробуйте пізніше.';
z.string.uk.modalConversationGuestOptionsDisableGuestMessage = 'Не вдалося видалити гостей та сервіси. Будь ласка, спробуйте пізніше.';
z.string.uk.modalConversationGuestOptionsGetCodeMessage = 'Не вдалося отримати доступ до лінка.';
z.string.uk.modalConversationGuestOptionsRequestCodeMessage = 'Не вдалося видправити запит на генерацію лінка. Будь ласка, спробуйте ще раз.';
z.string.uk.modalConversationGuestOptionsRevokeCodeMessage = 'Не вдалося видправити запит на видкликання лінка. Будь ласка, спробуйте ще раз.';
z.string.uk.modalConversationGuestOptionsToggleGuestsMessage = 'Не вдалося змінити гостьові налаштування.';

z.string.uk.modalConversationTooManyMembersHeadline = 'Розмова переповнена';
z.string.uk.modalConversationTooManyMembersMessage = 'До розмови може приєднатися до {{number1}} учаснків. В даний час є місце тільки для {{number2}} учасників.';

z.string.uk.modalGifTooLargeHeadline = 'Вибрана анімація завелика';
z.string.uk.modalGifTooLargeMessage = 'Максимальний розмір повідомлення - {{number}} МБ.';

z.string.uk.modalIntegrationUnavailableHeadline = 'Боти в даний час недоступні';
z.string.uk.modalIntegrationUnavailableMessage = 'Дякуємо вам за інтерес, проявлений до ботів. В даний час ця функціональність заморожена, але ми працюємо над тим, щоб активувати її в наступній версії. Слідкуйте за оновленнями.';

z.string.uk.modalPictureFileFormatHeadline = 'Ця картинка недоступна для використання';
z.string.uk.modalPictureFileFormatMessage = 'Будь ласка, оберіть PNG- або JPEG-файл.';

z.string.uk.modalPictureTooLargeHeadline = 'Вибрана картинка завелика';
z.string.uk.modalPictureTooLargeMessage = 'Ви можете використовувати картинки розміром до {{number}} МБ.';

z.string.uk.modalPictureTooSmallHeadline = 'Картинка замала';
z.string.uk.modalPictureTooSmallMessage = 'Будь ласка, виберіть картинка з роздільною здатністю принаймні 320x320 пікселів.';

z.string.uk.modalImproveWireAction = 'Прийняти';
z.string.uk.modalImproveWireSecondary = 'Ні';
z.string.uk.modalImproveWireHeadline = 'Допоможіть нам зробити Wire кращим';
z.string.uk.modalImproveWireMessage = 'Я згоден(-а) з тим, що Wire може створювати та використовувати анонімні звіти про використання програми та збої в роботі для покращення якості додатку. Я можу відкликати мою згоду в будь-який час.';

z.string.uk.modalServiceUnavailableHeadline = 'Неможливо додати сервіс';
z.string.uk.modalServiceUnavailableMessage = 'Даний сервіс наразі недоступний.';

z.string.uk.modalSessionResetHeadline = 'Сесія була скинута';
z.string.uk.modalSessionResetMessage1 = 'Якщо проблема не вирішена,';
z.string.uk.modalSessionResetMessageLink = 'зв’яжіться';
z.string.uk.modalSessionResetMessage2 = 'з нами.';

z.string.uk.modalUploadContactsAction = 'Спробувати ще раз';
z.string.uk.modalUploadContactsMessage = 'Ми не отримали вашу інформацію. Будь ласка, повторіть імпорт контактів.';

z.string.uk.modalUserBlockAction = 'Заблокувати';
z.string.uk.modalUserBlockHeadline = 'Заблокувати {{user}}?';
z.string.uk.modalUserBlockMessage = '{{user}} не буде мати можливості зв’язатися з вами або додати вас до групових розмов.';

z.string.uk.modalUserUnblockAction = 'Розблокувати';
z.string.uk.modalUserUnblockHeadline = 'Розблокувати?';
z.string.uk.modalUserUnblockMessage = '{{user}} не буде мати можливості зв’язатися з вами або додати вас до групових розмов.';

z.string.uk.modalNoCameraTitle = 'Відсутній доступ до камери';
z.string.uk.modalNoCameraMessage = 'Відсутній доступ до камери.[br][faqLink]Прочитати статтю[/faqLink] про те, як це можна виправити.';

z.string.uk.connectionRequestConnect = 'Додати до контактів';
z.string.uk.connectionRequestIgnore = 'Ігнорувати';

z.string.uk.conversationGuestIndicator = 'Гість';
z.string.uk.userRemainingTimeHours = 'Залишилось {{time}} год';
z.string.uk.userRemainingTimeMinutes = 'Залишилось менше {{time}} хв';

z.string.uk.conversationYouNominative = 'ви';
z.string.uk.conversationYouDative = 'ви';
z.string.uk.conversationYouAccusative = 'ви';

z.string.uk.conversationConnectionAccepted = 'Доданий(-а) до контактів';
z.string.uk.conversationConnectionBlocked = 'Заблокований(-на)';
z.string.uk.conversationConnectionCancelRequest = 'Скасувати запит на додавання до контактів';
z.string.uk.conversationCreateTemporary = 'Ви приєдналися до розмови';
z.string.uk.conversationCreateWith = 'з {{users}}';
z.string.uk.conversationDeviceStartedUsingOne = ' почав(-ла) використовувати';
z.string.uk.conversationDeviceStartedUsingMany = ' почав(-ла) використовувати';
z.string.uk.conversationDeviceUnverified = ' скасував(-ла) верифікацію одного з';
z.string.uk.conversationDeviceYourDevices = ' ваші пристрої';
z.string.uk.conversationDeviceUserDevices = ' пристрої {{user}}';
z.string.uk.conversationDeviceNewDeviceOne = ' новий пристрій';
z.string.uk.conversationDeviceNewDeviceMany = ' нові пристрої';
z.string.uk.conversationDeviceNewPeopleJoined = 'Приєдналися нові учасники.';
z.string.uk.conversationDeviceNewPeopleJoinedVerify = 'Верифікувати пристрої';
z.string.uk.conversationJustNow = 'Щойно';
z.string.uk.conversationLocationLink = 'Відкрити карту';
z.string.uk.conversationCreated = '[bold]{{name}}[/bold] почав(-ла) розмову з {{users}}';
z.string.uk.conversationCreatedMore = '[bold]{{name}}[/bold] почав(-ла) розмову з {{users}} та ще [showmore]{{count}} [/showmore]';
z.string.uk.conversationCreatedName = '[bold]{{name}}[/bold] почав(-ла) розмову';
z.string.uk.conversationCreatedNameYou = '[bold]Ви[/bold] почали розмову';
z.string.uk.conversationCreatedYou = 'Ви почали розмову з {{users}}';
z.string.uk.conversationCreatedYouMore = 'Ви почали розмову з {{users}} та ще [showmore]{{count}}[/showmore]';
z.string.uk.conversationCreateWithMore = 'з {{users}}, та ще [showmore]{{count}}[/showmore]';
z.string.uk.conversationCreateTeam = 'з [showmore]усіма учасниками команди[/showmore]';
z.string.uk.conversationCreateTeamGuest = 'з [showmore]усіма учасниками команди та одним гостем[/showmore]';
z.string.uk.conversationCreateTeamGuests = 'з [showmore]усіма учасниками команди та {{count}} гостями[/showmore]';
z.string.uk.conversationMemberJoined = '[bold]{{name}}[/bold] додав(-ла) до розмови {{users}}';
z.string.uk.conversationMemberJoinedYou = '[bold]Ви[/bold] додали до розмови {{users}}';
z.string.uk.conversationMemberJoinedMore = '[bold]{{name}}[/bold] додали до розмови {{users}} та ще [showmore]{{count}}[/showmore]';
z.string.uk.conversationMemberJoinedYouMore = '[bold]Ви[/bold] додали до розмови {{users}} та ще [showmore]{{count}}[/showmore]';
z.string.uk.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] приєднався(-лась) до розмови';
z.string.uk.conversationMemberJoinedSelfYou = '[bold]Ви[/bold] приєднались до розмови';
z.string.uk.conversationMemberLeft = '[bold]{{name}}[/bold] вийшов(-ла) з розмови';
z.string.uk.conversationMemberLeftYou = '[bold]Ви[/bold] вийшли з розмови';
z.string.uk.conversationMemberRemoved = '[bold]{{name}}[/bold] видалив(-ла) {{users}}';
z.string.uk.conversationMemberRemovedYou = '[bold]Ви[/bold] видалили {{users}}';
z.string.uk.conversationTeamLeft = '[bold]{{name}}[/bold] був(-ла) видалений(-а) з команди';
z.string.uk.conversationMessageDelivered = 'Доставлене';
z.string.uk.conversationRename = ' перейменував(-ла) розмову';
z.string.uk.conversationRenameYou = ' перейменував(-ла) розмову';
z.string.uk.conversationUpdatedTimer = ' встановив(-ла) таймер повідомлень на {{time}}';
z.string.uk.conversationUpdatedTimerYou = ' встановив(-ла) таймер повідомлень на {{time}}';
z.string.uk.conversationResetTimer = ' вимкнув(-ла) таймер повідомлень';
z.string.uk.conversationResetTimerYou = ' вимкнув(-ла) таймер повідомлень';
z.string.uk.conversationResume = 'Почав(-ла) розмову з {{users}}';
z.string.uk.conversationPing = ' відправив(-ла) пінг';
z.string.uk.conversationPingYou = ' відправив(-ла) пінг';
z.string.uk.conversationToday = 'сьогодні';
z.string.uk.conversationVoiceChannelDeactivate = ' дзвонив(-ла)';
z.string.uk.conversationVoiceChannelDeactivateYou = ' дзвонив(-ла)';
z.string.uk.conversationYesterday = 'Вчора';
z.string.uk.conversationUnableToDecrypt1 = 'Повідомлення від [highlight]{{user}}[/highlight] не отримане.';
z.string.uk.conversationUnableToDecrypt2 = 'Ідентифікатор пристрою [highlight]{{user}}[/highlight] змінився. Повідомлення не доставлене.';
z.string.uk.conversationUnableToDecryptLink = 'Чому?';
z.string.uk.conversationUnableToDecryptErrorMessage = 'Помилка';
z.string.uk.conversationUnableToDecryptResetSession = 'Скидання сесії';
z.string.uk.conversationMissedMessages = 'Ви не користувались цим простроєм протягом певного часу. Деякі повідомлення можуть не відображатися тут.';
z.string.uk.conversationAssetUploading = 'Завантаження…';
z.string.uk.conversationAssetDownloading = 'Скачування…';
z.string.uk.conversationAssetUploadFailed = 'Не вдалося завантажити';
z.string.uk.conversationPlaybackError = 'Неможливо відтворити';
z.string.uk.conversationContextMenuCopy = 'Скопіювати';
z.string.uk.conversationContextMenuEdit = 'Редагування';
z.string.uk.conversationContextMenuDelete = 'Видалити для мене…';
z.string.uk.conversationContextMenuDeleteEveryone = 'Видалити для всіх…';
z.string.uk.conversationContextMenuDownload = 'Скачати';
z.string.uk.conversationContextMenuLike = 'Подобається';
z.string.uk.conversationContextMenuReply = 'Відповісти';
z.string.uk.conversationContextMenuUnlike = 'Не подобається';
z.string.uk.conversationDeleteTimestamp = 'Видалене: {{date}}';
z.string.uk.conversationEditTimestamp = 'Відредаговане: {{date}}';
z.string.uk.conversationLikesCaption = '{{number}} учасників';
z.string.uk.conversationSendPastedFile = 'Надіслав(-ла) зображення {{date}}';
z.string.uk.conversationSomeone = 'Хтось';
z.string.uk.conversationTweetAuthor = ' в Twitter';
z.string.uk.conversationServicesWarning = 'Сервіси мають доступ до вмісту цієї розмови';

z.string.uk.groupCreationPreferencesAction = 'Далі';
z.string.uk.groupCreationPreferencesErrorNameShort = 'Не менше 1 символу';
z.string.uk.groupCreationPreferencesErrorNameLong = 'Занадто багато символів';
z.string.uk.groupCreationPreferencesHeader = 'Нова група';
z.string.uk.groupCreationPreferencesPlaceholder = 'Ім’я групи';
z.string.uk.groupCreationParticipantsActionCreate = 'Готово';
z.string.uk.groupCreationParticipantsActionSkip = 'Пропустити';
z.string.uk.groupCreationParticipantsHeader = 'Додати учасників';
z.string.uk.groupCreationParticipantsHeaderWithCounter = 'Додати учасників ({{number}})';
z.string.uk.groupCreationParticipantsPlaceholder = 'Пошук за іменем';
z.string.uk.groupSizeInfo = 'Групова розмова може містити до {{count}} учасників. Відеодзвінки працюють тільки в групах з 4-ма або менше учасниками.';

z.string.uk.guestRoomConversationName = 'Гостьова кімната';
z.string.uk.guestRoomToggleName = 'Дозволити присутність гостей та сервісів';
z.string.uk.guestRoomToggleInfo = 'Зробити цю розмову лоступною для серівсів та людей поза межами вашої команди.';
z.string.uk.guestRoomToggleInfoExtended = 'Зробити розмову доступною для людей поза межами вашої команди та сервісів. Це налаштування завжди можна змінити пізніше.';

z.string.uk.guestRoomConversationBadge = 'Присутні гості';
z.string.uk.guestRoomConversationBadgeService = 'Сервіси активовані';
z.string.uk.guestRoomConversationBadgeGuestAndService = 'Присутні гості та сервіси';

z.string.uk.guestRoomConversationHead = 'Люди за межами вашої команди можуть приєднатися до цієї розмови.';
z.string.uk.guestRoomConversationButton = 'Запросити людей';

z.string.uk.collectionShowAll = 'Показати всі {{number}}';
z.string.uk.collectionSectionLinks = 'Посилання';
z.string.uk.collectionSectionImages = 'Картинки';
z.string.uk.collectionSectionFiles = 'Файли';
z.string.uk.collectionSectionAudio = 'Аудіоповідомлення';

z.string.uk.fullsearchPlaceholder = 'Шукайте текстові повідомлення';
z.string.uk.fullsearchNoResults = 'Нічого не знайдено.';

z.string.uk.archiveHeader = 'Архівувати';

z.string.uk.conversationsAllArchived = 'Усі розмови заархівовано';
z.string.uk.conversationsContacts = 'Контакти';
z.string.uk.conversationsConnectionRequestMany = '{{number}} людей очікують';
z.string.uk.conversationsConnectionRequestOne = '1 людина очікує';
z.string.uk.conversationsEmptyConversation = 'Групова розмова';
z.string.uk.conversationsNoConversations = 'Розпочніть розмову або створіть групу.';
z.string.uk.conversationsPopoverArchive = 'Заархівувати';
z.string.uk.conversationsPopoverBlock = 'Заблокувати…';
z.string.uk.conversationsPopoverCancel = 'Скасувати запит…';
z.string.uk.conversationsPopoverClear = 'Видалити вміст…';
z.string.uk.conversationsPopoverLeave = 'Вийти з групи…';
z.string.uk.conversationsPopoverNotificationSettings = 'Нотифікації…';
z.string.uk.conversationsPopoverNotify = 'Увімк. звук';
z.string.uk.conversationsPopoverSilence = 'Вимк. звук';
z.string.uk.conversationsPopoverUnarchive = 'Розархівувати';

z.string.uk.conversationsSecondaryLineEphemeralMention = 'Згадав вас';
z.string.uk.conversationsSecondaryLineEphemeralMentionGroup = 'Хтось згадав вас';
z.string.uk.conversationsSecondaryLineEphemeralMessage = 'Надіслав повідомлення';
z.string.uk.conversationsSecondaryLineEphemeralMessageGroup = 'Хтось надіслав повідомлення';
z.string.uk.conversationsSecondaryLineEphemeralReply = 'Відповів(-ла) вам';
z.string.uk.conversationsSecondaryLineEphemeralReplyGroup = 'Хтось відповів вам';
z.string.uk.conversationsSecondaryLineIncomingCall = '{{user}} дзвонить';
z.string.uk.conversationsSecondaryLinePeopleLeft = '{{number}} учасників вийшло';
z.string.uk.conversationsSecondaryLinePersonLeft = '{{user}} вийшов(-ла)';
z.string.uk.conversationsSecondaryLinePersonRemoved = '{{user}} був(-ла) видалений(-а)';
z.string.uk.conversationsSecondaryLinePersonRemovedTeam = '{{user}} був(-ла) видалений(-а) з команди';
z.string.uk.conversationsSecondaryLinePeopleAdded = '{{user}} учасників було додано';
z.string.uk.conversationsSecondaryLinePersonAdded = '{{user}} був(-ла) доданий(-а)';
z.string.uk.conversationsSecondaryLinePersonAddedSelf = '{{user}} приєднався(-лася)';
z.string.uk.conversationsSecondaryLinePersonAddedYou = '{{user}} додав(-ла) вас';
z.string.uk.conversationsSecondaryLineRenamed = '{{user}} перейменував(-ла) розмову';
z.string.uk.conversationsSecondaryLineSummaryMessage = '{{number}} повідомлення';
z.string.uk.conversationsSecondaryLineSummaryMessages = '{{number}} повідомлень';
z.string.uk.conversationsSecondaryLineSummaryMention = '{{number}} згадка';
z.string.uk.conversationsSecondaryLineSummaryMentions = '{{number}} згадок';
z.string.uk.conversationsSecondaryLineSummaryMissedCall = '{{number}} пропущений дзвінок';
z.string.uk.conversationsSecondaryLineSummaryMissedCalls = '{{number}} пропущених дзвінків';
z.string.uk.conversationsSecondaryLineSummaryPing = '{{number}} пінг';
z.string.uk.conversationsSecondaryLineSummaryPings = '{{number}} пінгів'
z.string.uk.conversationsSecondaryLineSummaryReply = '{{number}} відповідь';
z.string.uk.conversationsSecondaryLineSummaryReplies = '{{number}} відповідей';
z.string.uk.conversationsSecondaryLineYouLeft = 'Ви вийшли';
z.string.uk.conversationsSecondaryLineYouWereRemoved = 'Вас видалили';

z.string.uk.takeoverSub = 'Зарезервуйте свій унікальний нік в Wire.';
z.string.uk.takeoverLink = 'Дізнатися більше';
z.string.uk.takeoverButtonChoose = 'Вибрати власний';
z.string.uk.takeoverButtonKeep = 'Залишити цей';

z.string.uk.inviteMetaKeyMac = 'Cmd';
z.string.uk.inviteMetaKeyPc = 'Ctrl';
z.string.uk.inviteHintSelected = 'Натисніть {{metaKey}} + C, щоб скопіювати';
z.string.uk.inviteHintUnselected = 'Виділіть та натисніть {{metaKey}} + C';
z.string.uk.inviteHeadline = 'Запросити людей в Wire';
z.string.uk.inviteMessage = 'Я в Wire. Шукайте мене як {{username}} або відвідайте get.wire.com.';
z.string.uk.inviteMessageNoEmail = 'Я уже в Wire. Відвідайте get.wire.com, щоб додати мене.';

z.string.uk.extensionsBubbleButtonGif = 'Gif';

z.string.uk.extensionsGiphyButtonOk = 'Надіслати';
z.string.uk.extensionsGiphyButtonMore = 'Спробувати іншу';
z.string.uk.extensionsGiphyMessage = '{{tag}} • через giphy.com';
z.string.uk.extensionsGiphyNoGifs = 'Упс, анімацій не знайдено';
z.string.uk.extensionsGiphyRandom = 'Випадкова';

z.string.uk.addParticipantsConfirmLabel = 'Додати';
z.string.uk.addParticipantsHeader = 'Додати учасників';
z.string.uk.addParticipantsHeaderWithCounter = 'Додати учасників ({{number}})';
z.string.uk.addParticipantsManageServices = 'Керування сервісами';
z.string.uk.addParticipantsManageServicesNoResults = 'Керування сервісами';
z.string.uk.addParticipantsNoServicesManager = 'Сервіси та помічники, які можуть поліпшити ваш робочий процес.';
z.string.uk.addParticipantsNoServicesMember = 'Сервіси та помічники, які можуть поліпшити ваш робочий процес. Щоб увімкнути їх, зверніться до адміністратора вашої команди.';
z.string.uk.addParticipantsSearchPlaceholder = 'Пошук за іменем';
z.string.uk.addParticipantsServiceConfirmButton = 'Додати сервіс';
z.string.uk.addParticipantsTabsPeople = 'Список контактів';
z.string.uk.addParticipantsTabsServices = 'Сервіси';

z.string.uk.conversationDetailsActionArchive = 'Заархівувати';
z.string.uk.conversationDetailsActionAddParticipants = 'Додати учасників';
z.string.uk.conversationDetailsActionBlock = 'Заблокувати…';
z.string.uk.conversationDetailsActionCancelRequest = 'Скасувати запит…';
z.string.uk.conversationDetailsActionClear = 'Видалити вміст…';
z.string.uk.conversationDetailsActionConversationParticipants = 'Показати всі ({{number}})';
z.string.uk.conversationDetailsActionCreateGroup = 'Створити групу';
z.string.uk.conversationDetailsActionDevices = 'Пристрої';
z.string.uk.conversationDetailsActionGuestOptions = 'Гості та сервіси';
z.string.uk.conversationDetailsActionTimedMessages = 'Тимчасові повідомлення';
z.string.uk.conversationDetailsActionNotifications = 'Сповіщення';
z.string.uk.conversationDetailsActionLeave = 'Вийти з групи…';
z.string.uk.conversationDetailsGuestsOff = 'Вимкнений';
z.string.uk.conversationDetailsGuestsOn = 'Увімк.';
z.string.uk.conversationDetailsOptions = 'Налаштування';
z.string.uk.conversationDetailsParticipantsServicesOne = 'Сервіс';
z.string.uk.conversationDetailsParticipantsServicesMany = 'Сервіси';
z.string.uk.conversationDetailsParticipantsUsersOne = 'Учасник';
z.string.uk.conversationDetailsParticipantsUsersMany = 'Список контактів';
z.string.uk.conversationDetailsPeople = 'Список контактів';
z.string.uk.conversationDetailsServices = 'Сервіси';

z.string.uk.conversationParticipantsTitle = 'Список контактів';
z.string.uk.conversationParticipantsSearchPlaceholder = 'Пошук за іменем';

z.string.uk.groupParticipantActionBlock = 'Заблокувати…';
z.string.uk.groupParticipantActionCancelRequest = 'Скасувати запит…';
z.string.uk.groupParticipantActionDevices = 'Пристрої';
z.string.uk.groupParticipantActionIgnoreRequest = 'Ігнорувати запит';
z.string.uk.groupParticipantActionIncomingRequest = 'Прийняти запит';
z.string.uk.groupParticipantActionLeave = 'Вийти з групи…';
z.string.uk.groupParticipantActionOpenConversation = 'Відкрити розмову';
z.string.uk.groupParticipantActionPending = 'Очікує підтвердження';
z.string.uk.groupParticipantActionRemove = 'Видалити з групи…';
z.string.uk.groupParticipantActionSelfProfile = 'Відкрити профіль';
z.string.uk.groupParticipantActionSendRequest = 'Додати до контактів';
z.string.uk.groupParticipantActionUnblock = 'Розблокувати…';

z.string.uk.guestOptionsCopyLink = 'Скопіювати лінк';
z.string.uk.guestOptionsCopyLinkDone = 'Лінк скопійовано!';
z.string.uk.guestOptionsCreateLink = 'Створити лінк';
z.string.uk.guestOptionsInfoHeader = 'Запросити інших користувачів за допомогою лінка';
z.string.uk.guestOptionsInfoText = 'З цим лінком кожен може приєднатися до розмови протягом 24 годин, навіть якщо він або вона не зареєстровані в Wire.';
z.string.uk.guestOptionsRevokeLink = 'Відкликати лінк…';
z.string.uk.guestOptionsTitle = 'Гості та сервіси';

z.string.uk.notificationSettingsTitle = 'Сповіщення';
z.string.uk.notificationSettingsDisclaimer = 'Ви можете отримувати нотифікації про всі події (включаючи аудіо та відеодзвінки), або тільки тоді, коли вас згадують.';
z.string.uk.notificationSettingsEverything = 'Все';
z.string.uk.notificationSettingsMentionsAndReplies = 'Згадки та відповіді';
z.string.uk.notificationSettingsNothing = 'Нічого';

z.string.uk.timedMessagesTitle = 'Тимчасові повідомлення';
z.string.uk.timedMessageDisclaimer = 'Тимчасові повідомлення будуть увімкнені для всіх учасників цієї розмови.';

z.string.uk.participantDevicesDetailHeadline = 'Переконайтеся, що цей ідентифікатор такий самий, як і ідентифікатор на пристрої, що належить {{html1}}{{user}}{{html2}}.';
z.string.uk.participantDevicesDetailHowTo = 'Як це зробити?';
z.string.uk.participantDevicesDetailResetSession = 'Скидання сесії';
z.string.uk.participantDevicesDetailShowMyDevice = 'Показати ідентиф. мого пристрою';
z.string.uk.participantDevicesDetailVerify = 'Верифікований';

z.string.uk.participantDevicesHeader = 'Пристрої';
z.string.uk.participantDevicesHeadline = 'Wire присвоює кожному пристроєві унікальний ідентифікатор. Порівняйте його з ідентифікатором на пристрої контакту {{user}} та верифікуйте вашу розмову.';
z.string.uk.participantDevicesLearnMore = 'Дізнатися більше';
z.string.uk.participantDevicesWhyVerify = 'Навіщо верифікувати розмови?';
z.string.uk.participantDevicesOutdatedClientMessage = '{{user}} використовує стару версію Wire, тому не показується жоден пристрій.';

z.string.uk.participantDevicesSelfAllDevices = 'Показати всі мої пристрої';
z.string.uk.participantDevicesSelfFingerprint = 'Ідентифікатор пристрою';

z.string.uk.userProfileButtonConnect = 'Додати до контактів';
z.string.uk.userProfileButtonIgnore = 'Ігнорувати';
z.string.uk.userProfileButtonUnblock = 'Розблокувати';

z.string.uk.preferencesAbout = 'Про програму';
z.string.uk.preferencesAccount = 'Акаунт';
z.string.uk.preferencesAV = 'Аудіо / Відео';
z.string.uk.preferencesDeviceDetails = 'Подробиці пристрою';
z.string.uk.preferencesDevices = 'Пристрої';
z.string.uk.preferencesHeadline = 'Параметри';
z.string.uk.preferencesOptions = 'Налаштування';

z.string.uk.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.uk.preferencesAboutPrivacyPolicy = 'Політика конфіденційності';
z.string.uk.preferencesAboutSupport = 'Підтримка';
z.string.uk.preferencesAboutSupportWebsite = 'Сайт підтримки';
z.string.uk.preferencesAboutSupportContact = 'Звернутися до служби підтримки';
z.string.uk.preferencesAboutTermsOfUse = 'Умови використання';
z.string.uk.preferencesAboutVersion = 'Версія {{version}}';
z.string.uk.preferencesAboutWebsite = 'Веб-сайт Wire';

z.string.uk.preferencesAccountAvaibilityUnset = 'Встановити статус';
z.string.uk.preferencesAccountCreateTeam = 'Створити команду';
z.string.uk.preferencesAccountData = 'Дозвіл на використання даних';
z.string.uk.preferencesAccountDataCheckbox = 'Надсилати анонімну статистику';
z.string.uk.preferencesAccountDataDetail = 'Допоможіть зробити Wire кращим, відправляючи анонімні звіти про використання та збої в роботі.';
z.string.uk.preferencesAccountDelete = 'Видалити акаунт';
z.string.uk.preferencesAccountLeaveGuestRoom = 'Вийти з гостьової кімнати';
z.string.uk.preferencesAccountLeaveGuestRoomDescription = 'Ви більше не зможете отримати доступ до повідомлень в цій розмові.';
z.string.uk.preferencesAccountLogOut = 'Вийти';
z.string.uk.preferencesAccountManageTeam = 'Керування командою';
z.string.uk.preferencesAccountMarketingConsentCheckbox = 'Отримувати новини';
z.string.uk.preferencesAccountMarketingConsentDetail = 'Отримувати новини та інформацію про оновлення Wire по електронній пошті.';
z.string.uk.preferencesAccountResetPassword = 'Виконати скидання паролю';
z.string.uk.preferencesAccountTeam = 'в {{name}}';
z.string.uk.preferencesAccountUsernamePlaceholder = 'Ваше повне ім’я';
z.string.uk.preferencesAccountUsernameHint = 'Мінімум 2 символи з множини a—z, 0—9, та _.';
z.string.uk.preferencesAccountUsernameAvailable = 'Доступний';
z.string.uk.preferencesAccountUsernameErrorTaken = 'Уже зарезервований';

z.string.uk.preferencesAVCamera = 'Камера';
z.string.uk.preferencesAVMicrophone = 'Мікрофон';
z.string.uk.preferencesAVPermissionDetail = 'Увімкніть в налаштуваннях свого браузера';
z.string.uk.preferencesAVSpeakers = 'Гучномовець';
z.string.uk.preferencesAVTemporaryDisclaimer = 'Гості не можуть розпочинати відеоконференції. Оберіть, яку з камер ви хотіли б використовувати при підключенні до відеоконференції.';
z.string.uk.preferencesAVNoCamera = 'Відсутній доступ до камери.[br][faqLink]Прочитати статтю[/faqLink] про те, як це можна виправити.';
z.string.uk.preferencesAVTryAgain = 'Спробувати ще раз';

z.string.uk.preferencesDevicesActivatedOn = 'Активований: {{date}}';
z.string.uk.preferencesDevicesActive = 'Активні';
z.string.uk.preferencesDevicesActiveDetail = 'Якщо ви не впізнаєте пристрою вище, видаліть його і виконайте скидання паролю.';
z.string.uk.preferencesDevicesCurrent = 'Поточний';
z.string.uk.preferencesDevicesFingerprint = 'Ідентифікатор';
z.string.uk.preferencesDevicesFingerprintDetail = 'Wire присвоює кожному пристроєві унікальний ідентифікатор. Порівняйте їх, щоб зверифікувати ваші пристрої та розмови.';
z.string.uk.preferencesDevicesId = 'Ідентифікатор: ';
z.string.uk.preferencesDevicesRemove = 'Видалити…';
z.string.uk.preferencesDevicesRemoveCancel = 'Скасувати';
z.string.uk.preferencesDevicesRemoveDetail = 'Видаліть цей пристрій, якщо ви припинили його використовувати. Ви вийдете відразу, як тільки пристрій буде видалено.';
z.string.uk.preferencesDevicesSessionConfirmation = 'Сесія була скинута.';
z.string.uk.preferencesDevicesSessionDetail = 'Якщо ідентифікатори не збігаються, виконайте скидання сесії, щоб згенерувати нові ключі шифрування з обидвох сторін.';
z.string.uk.preferencesDevicesSessionReset = 'Скидання сесії';
z.string.uk.preferencesDevicesSessionOngoing = 'Скидання сесії…';
z.string.uk.preferencesDevicesVerification = 'Верифікований';

z.string.uk.preferencesOptionsAudio = 'Звукові сповіщення';
z.string.uk.preferencesOptionsAudioAll = 'Всі';
z.string.uk.preferencesOptionsAudioAllDetail = 'Всі звуки';
z.string.uk.preferencesOptionsAudioNone = 'Все вимкнено';
z.string.uk.preferencesOptionsAudioNoneDetail = 'Тихенько!';
z.string.uk.preferencesOptionsAudioSome = 'Деякі';
z.string.uk.preferencesOptionsAudioSomeDetail = 'Пінги та дзвінки';
z.string.uk.preferencesOptionsContacts = 'Контакти';
z.string.uk.preferencesOptionsContactsGmail = 'Імпорт з Gmail';
z.string.uk.preferencesOptionsContactsMacos = 'Імпорт з Контактів';
z.string.uk.preferencesOptionsContactsDetail = 'Ми використовуємо дані про ваші контакти, щоб ви могли знайти людей, яких ви знаєте. Ми анонімізуємо всю інформацію та не передаємо її третім особам.';
z.string.uk.preferencesOptionsPopular = 'У відповідь на численні прохання';
z.string.uk.preferencesOptionsEmojiReplaceCheckbox = 'Замінювати текстові смайлики іконками';
z.string.uk.preferencesOptionsEmojiReplaceDetail = ':-) → {{icon}}';
z.string.uk.preferencesOptionsPreviewsSendCheckbox = 'Генерувати попередній перегляд для надісланих лінків';
z.string.uk.preferencesOptionsPreviewsSendDetail = 'Дана опція не впливає на попередній перегляд лінків від інших людей.';
z.string.uk.preferencesOptionsNotifications = 'Сповіщення';
z.string.uk.preferencesOptionsNotificationsNone = 'Вимкнений';
z.string.uk.preferencesOptionsNotificationsObfuscate = 'Приховати деталі';
z.string.uk.preferencesOptionsNotificationsObfuscateMessage = 'Показувати відправника';
z.string.uk.preferencesOptionsNotificationsOn = 'Показувати відправника та повідомлення';
z.string.uk.preferencesOptionsCallLogs = 'Усунення проблем';
z.string.uk.preferencesOptionsCallLogsGet = 'Зберегти технічний звіт про дзвінок';
z.string.uk.preferencesOptionsCallLogsDetail = 'Ця інформація допомагає відділу підтримки Wire діагностувати проблеми, пов’язані з дзвінками.';

z.string.uk.preferencesOptionsBackupHeader = 'Історія';
z.string.uk.preferencesOptionsBackupExportHeadline = 'Зробити резервну копію розмов';
z.string.uk.preferencesOptionsBackupExportSecondary = 'Створіть резервну копію для збереження історії ваших розмов. Ви можете використовувати її, щоб відновити історію, якщо ваш комп’ютер вийде з ладу або ви почнете використовувати новий. \nФайл резервної копії не захищений скрізним криптуванням Wire, тому зберігайте його в безпечному місці.';
z.string.uk.preferencesOptionsBackupImportHeadline = 'Відновити з резервної копії';
z.string.uk.preferencesOptionsBackupImportSecondary = 'Історію розмов можна відновити тільки з резервної копії, зробленої на тій же платформі. Резервна копія перезапише розмови, які ви, можливо, уже маєте на цьому пристрої.';

z.string.uk.backupExportGenericErrorHeadline = 'Не вдалося зберегти файл';
z.string.uk.backupExportGenericErrorSecondary = 'Резервне копіювання не завершено.';
z.string.uk.backupExportProgressHeadline = 'Підготовка…';
z.string.uk.backupExportProgressSecondary = 'Резервне копіювання · {{processed}} з {{total}} — {{progress}}%';
z.string.uk.backupExportProgressCompressing = 'Підготовка файлу резевної копії';
z.string.uk.backupExportSaveFileAction = 'Зберегти файл';
z.string.uk.backupExportSuccessHeadline = 'Резервна копія готова';
z.string.uk.backupExportSuccessSecondary = 'Даний функціонал може бути корисним, якщо ваш комп’ютер вийде з ладу або ви почнете використовувати новий.';
z.string.uk.backupImportGenericErrorHeadline = 'Щось пішло не так';
z.string.uk.backupImportGenericErrorSecondary = 'Ваша історія не може бути відновлена.';
z.string.uk.backupImportAccountErrorHeadline = 'Несумісна резервна копія';
z.string.uk.backupImportAccountErrorSecondary = 'Ви не можете відновити історію з іншого акаунту.';
z.string.uk.backupImportVersionErrorHeadline = 'Несумісний файл резервної копії';
z.string.uk.backupImportVersionErrorSecondary = 'Цю резервну копію було створено новішою або застарілою версією Wire, тому її неможливо відновити.';
z.string.uk.backupImportIncompatibleErrorHeadline = 'Несумісна резервна копія';
z.string.uk.backupImportIncompatibleErrorSecondary = 'Ви не можете відновити історію з іншого акаунту.';
z.string.uk.backupImportOutdatedErrorHeadline = 'Несумісний файл резервної копії';
z.string.uk.backupImportOutdatedErrorSecondary = 'Цю резервну копію було створено новішою або застарілою версією Wire, тому її неможливо відновити.';
z.string.uk.backupImportProgressHeadline = 'Підготовка…';
z.string.uk.backupImportProgressSecondary = 'Відновлення історії розмов · {{processed}} з {{total}} — {{progress}}%';
z.string.uk.backupImportSuccessHeadline = 'Історію розмов відновлено.';
z.string.uk.backupCancel = 'Скасувати';
z.string.uk.backupTryAgain = 'Спробувати ще раз';

z.string.uk.searchConnect = 'Додати до контактів';
z.string.uk.searchConnections = 'Контакти';
z.string.uk.searchContacts = 'Контакти';
z.string.uk.searchCreateGroup = 'Створити групу';
z.string.uk.searchCreateGuestRoom = 'Створити гостьову кімнату';
z.string.uk.searchGroups = 'Групи';
z.string.uk.searchPeople = 'Список контактів';
z.string.uk.searchPlaceholder = 'Пошук за іменем або ніком';
z.string.uk.searchServicePlaceholder = 'Пошук за іменем';
z.string.uk.searchServices = 'Сервіси';
z.string.uk.searchManageServices = 'Керування сервісами';
z.string.uk.searchManageServicesNoResults = 'Керування сервісами';
z.string.uk.searchNoServicesManager = 'Сервіси та помічники, які можуть поліпшити ваш робочий процес.';
z.string.uk.searchNoServicesMember = 'Сервіси та помічники, які можуть поліпшити ваш робочий процес. Щоб увімкнути їх, зверніться до адміністратора вашої команди.';
z.string.uk.searchTeamGroups = 'Розмови в команді';
z.string.uk.searchTeamMembers = 'Учасники команди';
z.string.uk.searchTopPeople = 'Топ-контакти';
z.string.uk.searchTrySearch = 'Шукайте людай\nза іменем або ніком';
z.string.uk.searchNoContactsOnWire = 'У вас поки що немає контактів в Wire.\nСпробуйте знайти людей\nза їхніми іменами або ніками.';
z.string.uk.searchMemberInvite = 'Запросіть колег приєднатися до команди';
z.string.uk.searchOthers = 'Додати до контактів';

z.string.uk.searchInvite = 'Запросіть людей в Wire';
z.string.uk.searchInviteDetail = 'Поділившись контактами, ви зможете зв’язатись в Wire з людьми, з якими ви, можливо, знайомі. Вся інформація анонімна та не передається третім особам.';
z.string.uk.searchInviteButtonContacts = 'З контактів';
z.string.uk.searchInviteButtonGmail = 'З Gmail';
z.string.uk.searchInviteHeadline = 'Приведіть друзів';
z.string.uk.searchInviteShare = 'Поділитись контактами';

z.string.uk.searchServiceConfirmButton = 'Додати сервіс';

z.string.uk.searchListEveryoneParticipates = 'Всі ваші контакти\nуже присутні\nв даній групі.';
z.string.uk.searchListNoMatches = 'Співпадіння відсутні.\nСпробуйте ввести інше ім’я.';

z.string.uk.temporaryGuestCta = 'Створити акаунт';
z.string.uk.temporaryGuestDescription = 'Захистіть ваш бізнес за допомогою закриптованих групових розмов та конференц-дзвінків.';
z.string.uk.temporaryGuestTimeRemaining = ' залишилось в цій гостьовій кімнаті';

z.string.uk.temporaryGuestJoinMessage = 'Ця розмова буде доступна для вас протягом 24 годин.';
z.string.uk.temporaryGuestJoinDescription = 'Закривши чи оновивши цю сторінку, ви втратите доступ до розмови.';

z.string.uk.temporaryGuestLeaveMessage = ' більше не є учасниками цієї розмови.';
z.string.uk.temporaryGuestLeaveDescription = 'Закривши чи оновивши цю сторінку, ви втратите доступ до історії розмови.';

z.string.uk.uploadGoogleHeadline = 'Знайдіть людей,\nщоб порозмовляти.';
z.string.uk.uploadGoogleMessage = 'Ми використовуємо дані про ваші контакти, щоб ви могли знайти людей, яких ви знаєте. Ми анонімізуємо всю інформацію та не передаємо її третім особам.';

z.string.uk.urlSupportRoot = '/';
z.string.uk.urlSupportArticles = '/hc/en-us/articles/';
z.string.uk.urlSupportRequests = '/hc/en-us/requests/';
z.string.uk.urlWebappRoot = '/';
z.string.uk.urlWebsiteRoot = '/';
z.string.uk.urlWebsiteCreateTeam = '/create-team/';
z.string.uk.urlWebsitePrivacy = '/privacy';
z.string.uk.warningCallUnsupportedIncoming = '{{user}} дзвонить. Ваш браузер не підтримує дзвінки.';
z.string.uk.warningCallUnsupportedOutgoing = 'Ви не можете подзвонити, тому що ваш браузер не підтримує дзвінків.';
z.string.uk.warningCallIssues = 'Ця версія Wire не може брати участь у дзвінку. Будь ласка, використовуйте';
z.string.uk.warningCallUpgradeBrowser = 'Щоб подзвонити, будь ласка, оновіть Google Chrome.';
z.string.uk.warningConnectivityConnectionLost = 'Намагаюся підключитись. Wire, можливо, не зможе доставляти повідомлення.';
z.string.uk.warningConnectivityNoInternet = 'Відсутнє підключення до Internet. Ви не зможете надсилати чи отримувати повідомлення.';
z.string.uk.warningLearnMore = 'Дізнатися більше';
z.string.uk.warningLifecycleUpdate = 'Доступна нова версія Wire.';
z.string.uk.warningLifecycleUpdateNotes = 'Що нового';
z.string.uk.warningLifecycleUpdateLink = 'Оновити зараз';
z.string.uk.warningNotFoundCamera = 'Ви не можете подзвонити, тому що камера не підключена до вашого комп’ютера.';
z.string.uk.warningNotFoundMicrophone = 'Ви не можете подзвонити, тому що мікрофон не підключений до вашого комп’ютера.';
z.string.uk.warningPermissionDeniedCamera = 'Ви не можете подзвонити, тому що ви не надали доступу до камери для вашого браузера.';
z.string.uk.warningPermissionDeniedMicrophone = 'Ви не можете подзвонити, тому що ви не надали доступу до мікрофона для вашого браузера.';
z.string.uk.warningPermissionDeniedScreen = 'Для Wire необхідний дозвіл, щоб ви могли поділитись скріншотами робочого столу.';
z.string.uk.warningPermissionRequestCamera = '[icon] Дозволити доступ до камери';
z.string.uk.warningPermissionRequestMicrophone = '[icon] Дозволити доступ до мікрофону';
z.string.uk.warningPermissionRequestNotification = '[icon] Дозволити нотифікації';
z.string.uk.warningPermissionRequestScreen = '[icon] Дозволити доступ до обміну скріншотами робочого столу';

z.string.uk.userAvailabilityAvailable = 'Доступний';
z.string.uk.userAvailabilityAway = 'Не на місці';
z.string.uk.userAvailabilityBusy = 'Не турбувати';
z.string.uk.userAvailabilityNone = 'Все вимкнено';

z.string.uk.notificationAssetAdd = 'Поділився(-лась) картинкою';
z.string.uk.notificationConnectionAccepted = 'Прийняв(-ла) ваш запит на додавання до контактів';
z.string.uk.notificationConnectionConnected = 'Тепер ви підключені';
z.string.uk.notificationConnectionRequest = 'Хоче бути доданим(-ою) до ваших контактів';
z.string.uk.notificationConversationCreate = '{{user}} почав(-ла) розмову';
z.string.uk.notificationConversationMessageTimerUpdate = '{{user}} встановив(-ла) таймер повідомлень на {{time}}';
z.string.uk.notificationConversationMessageTimerReset = '{{user}} вимкнув(-ла) таймер повідомлень';
z.string.uk.notificationConversationRename = '{{user}} перейменував(-ла) розмову на {{name}}';
z.string.uk.notificationMemberJoinMany = '{{user}} додав(-ла) {{number}} учасників до розмови';
z.string.uk.notificationMemberJoinSelf = '{{user}} прєднався(-лася) до розмови';
z.string.uk.notificationMemberJoinOne = '{{user1}} додав(-ла) {{user2}} до розмови';
z.string.uk.notificationMemberLeaveRemovedYou = '{{user}} видалив(-ла) вас з розмови';
z.string.uk.notificationMention = 'Згадка: {{text}}';
z.string.uk.notificationObfuscated = 'Надіслав повідомлення';
z.string.uk.notificationObfuscatedMention = 'Згадав вас';
z.string.uk.notificationObfuscatedReply = 'Відповів(-ла) вам';
z.string.uk.notificationObfuscatedTitle = 'Хтось';
z.string.uk.notificationPing = 'Надіслав(-ла) пінг';
z.string.uk.notificationReaction = '{{reaction}} ваше повідомлення';
z.string.uk.notificationReply = 'Відповідь: {{text}}';
z.string.uk.notificationSharedAudio = 'Поділився(-лась) аудіоповідомленням';
z.string.uk.notificationSharedFile = 'Поділився(-лась) файлом';
z.string.uk.notificationSharedLocation = 'Поділився(-лась) розташуванням';
z.string.uk.notificationSharedVideo = 'Поділився(-лась) відео';
z.string.uk.notificationTitleGroup = '{{user}} в {{conversation}}';
z.string.uk.notificationVoiceChannelActivate = 'Дзвонить';
z.string.uk.notificationVoiceChannelDeactivate = 'Дзвонив(-ла)';

z.string.uk.tooltipConversationAllVerified = 'Всі ідентифікатори були верифіковані';
z.string.uk.tooltipConversationCall = 'Аудіодзвінок';
z.string.uk.tooltipConversationEphemeral = 'Тимчасове повідомлення';
z.string.uk.tooltipConversationFile = 'Додати файл';
z.string.uk.tooltipConversationInputPlaceholder = 'Напишіть повідомлення';
z.string.uk.tooltipConversationInputPlaceholderAvailable = '{{user}}: онлайн';
z.string.uk.tooltipConversationInputPlaceholderAway = '{{user}}: не на місці';
z.string.uk.tooltipConversationInputPlaceholderBusy = '{{user}}: не турбувати';
z.string.uk.tooltipConversationPeople = 'Учасники ({{shortcut}})';
z.string.uk.tooltipConversationPicture = 'Додати картинку';
z.string.uk.tooltipConversationPing = 'Надіслати пінг ({{shortcut}})';
z.string.uk.tooltipConversationSearch = 'Пошук';
z.string.uk.tooltipConversationVideoCall = 'Відеодзвінок';

z.string.uk.tooltipConversationsArchive = 'Архівувати ({{shortcut}})';
z.string.uk.tooltipConversationsArchived = 'Показати архів ({{number}})';
z.string.uk.tooltipConversationsMore = 'Більше';
z.string.uk.tooltipConversationsNotifications = 'Відкрити налаштування нотифікацій ({{shortcut}})';
z.string.uk.tooltipConversationsNotify = 'Увімкнути звук ({{shortcut}})';
z.string.uk.tooltipConversationsPreferences = 'Відкрити налаштування';
z.string.uk.tooltipConversationsSilence = 'Вимкнути звук ({{shortcut}})';
z.string.uk.tooltipConversationsStart = 'Почати розмову ({{shortcut}})';

z.string.uk.tooltipConversationDetailsAddPeople = 'Додати учасників до розмови ({{shortcut}})';
z.string.uk.tooltipConversationDetailsRename = 'Змінити ім’я розмови';

z.string.uk.tooltipPreferencesContactsGmail = 'Увійдіть у свій обліковий запис Gmail, щоб поділитися контактами';
z.string.uk.tooltipPreferencesContactsMacos = 'Поділіться вашими контактами з додатку Контакти для Mac OS';
z.string.uk.tooltipPreferencesPassword = 'Відкрийте нову вкладку в браузері, щоб змінити ваш пароль';
z.string.uk.tooltipPreferencesPicture = 'Змініть своє фото…';
z.string.uk.tooltipPreferencesRename = 'Змініть своє ім’я';

z.string.uk.tooltipSearchClose = 'Закрити (Esc)';

z.string.uk.initReceivedSelfUser = 'Привіт {{user}}.';
z.string.uk.initValidatedClient = 'Отримую список контактів та розмов';
z.string.uk.initReceivedUserData = 'Перевіряю наявність нових повідомлень';
z.string.uk.initDecryption = 'Дешифрую повідомлення';
z.string.uk.initEvents = 'Завантажую повідомлення';
z.string.uk.initUpdatedFromNotifications = 'Майже завершено - Приємного користування!';
z.string.uk.initProgress = ' — {{number1}} з {{number2}}';

z.string.uk.ephemeralUnitsNone = 'Вимкнений';
z.string.uk.ephemeralUnitsSecond = 'секунда';
z.string.uk.ephemeralUnitsSeconds = 'секунд';
z.string.uk.ephemeralUnitsMinute = 'хвилина';
z.string.uk.ephemeralUnitsMinutes = 'хвилин';
z.string.uk.ephemeralUnitsHour = 'година';
z.string.uk.ephemeralUnitsHours = 'годин';
z.string.uk.ephemeralUnitsDay = 'день';
z.string.uk.ephemeralUnitsDays = 'днів';
z.string.uk.ephemeralUnitsWeek = 'тиждень';
z.string.uk.ephemeralUnitsWeeks = 'тижнів';
z.string.uk.ephemeralUnitsYear = 'рік';
z.string.uk.ephemeralUnitsYears = 'років';
z.string.uk.ephemeralRemaining = 'залишилось';

z.string.uk.replyAudioMessage = 'Аудіоповідомлення';
z.string.uk.replyQuoteError = 'Ви не можете бачити це повідомлення.';
z.string.uk.replyQuoteShowMore = 'Розгорнути';
z.string.uk.replyQuoteShowLess = 'Згорнути';
z.string.uk.replyQuoteTimeStampDate = 'Оригінальне повідомлення від {{date}}';
z.string.uk.replyQuoteTimeStampTime = 'Оригінальне повідомлення від {{time}}'


/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

z.string.wire = 'Wire';
z.string.wireMacos = 'Wire for macOS';
z.string.wireWindows = 'Wire for Windows';
z.string.wireLinux = 'Wire for Linux';
z.string.nonexistentUser = 'Deleted User';
z.string.and = 'and';
z.string.enumerationAnd = ', and ';

// Auth
// Authentication: ACCOUNT section
z.string.authAccountCountryCode = 'Country Code';
z.string.authAccountPasswordForgot = 'Forgot password';
z.string.authAccountPublicComputer = 'This is a public computer';
z.string.authAccountSignIn = 'Log in';
z.string.authAccountSignInPhone = 'Phone Log in';

// Authentication: BLOCKED section
z.string.authBlockedCookies = 'Enable cookies to log in to Wire.';
z.string.authBlockedDatabase = 'Wire needs access to local storage to display your messages. Local storage is not available in private mode.';
z.string.authBlockedTabs = 'Wire is already open in another tab.';
z.string.authBlockedTabsAction = 'Use this tab instead';

// Authentication: VERIFY section
z.string.authVerifyAccountAdd = 'Add';
z.string.authVerifyAccountDetail = 'This lets you use Wire on multiple devices.';
z.string.authVerifyAccountHeadline = 'Add email address and password.';
z.string.authVerifyAccountLogout = 'Log out';
z.string.authVerifyCodeDescription = 'Enter the verification code\nwe sent to {{number}}.';
z.string.authVerifyCodeResend = 'No code showing up?';
z.string.authVerifyCodeResendDetail = 'Resend';
z.string.authVerifyCodeResendTimer = 'You can request a new code {{expiration}}.';
z.string.authVerifyCodeChangePhone = 'Change phone number';
z.string.authVerifyPasswordHeadline = 'Enter your password';

// Authentication: LIMIT section
z.string.authLimitDevicesHeadline = 'Devices';
z.string.authLimitDescription = 'Remove one of your other devices to start using Wire on this one.';
z.string.authLimitButtonManage = 'Manage devices';
z.string.authLimitButtonSignOut = 'Log out';
z.string.authLimitDevicesCurrent = '(Current)';

// Authentication: HISTORY section
z.string.authHistoryHeadline = 'It’s the first time you’re using Wire on this device.';
z.string.authHistoryDescription = 'For privacy reasons, your conversation history will not appear here.';
z.string.authHistoryReuseHeadline = 'You’ve used Wire on this device before.';
z.string.authHistoryReuseDescription = 'Messages sent in the meantime will not appear here.';
z.string.authHistoryButton = 'OK';

// Authentication: POSTED section
z.string.authPostedResend = 'Resend to {{email}}';
z.string.authPostedResendAction = 'No email showing up?';
z.string.authPostedResendDetail = 'Check your email inbox and follow the instructions.';
z.string.authPostedResendHeadline = 'You’ve got mail.';

// Authentication: Misc
z.string.authPlaceholderEmail = 'Email';
z.string.authPlaceholderPasswordPut = 'Password';
z.string.authPlaceholderPasswordSet = 'Password (at least 8 characters)';
z.string.authPlaceholderPhone = 'Phone Number';

// Authentication: Validation errors
z.string.authErrorCode = 'Invalid Code';
z.string.authErrorCountryCodeInvalid = 'Invalid Country Code';
z.string.authErrorEmailExists = 'Email address already taken';
z.string.authErrorEmailForbidden = 'Sorry. This email address is forbidden.';
z.string.authErrorEmailMalformed = 'Please enter a valid email address.';
z.string.authErrorEmailMissing = 'Please enter an email address.';
z.string.authErrorMisc = 'Problems with the connection. Please try again.';
z.string.authErrorNameShort = 'Enter a name with at least 2 characters';
z.string.authErrorOffline = 'No Internet connection';
z.string.authErrorPasswordShort = 'Choose a password with at least 8 characters.';
z.string.authErrorPasswordWrong = 'Wrong password. Please try again.';
z.string.authErrorPending = 'Account is not yet verified';
z.string.authErrorPhoneNumberBudget = 'You logged in too often. Try again later.';
z.string.authErrorPhoneNumberForbidden = 'Sorry. This phone number is forbidden.';
z.string.authErrorPhoneNumberInvalid = 'Invalid Phone Number';
z.string.authErrorPhoneNumberUnknown = 'Unknown Phone Number';
z.string.authErrorSuspended = 'This account is no longer authorized to log in.';
z.string.authErrorSignIn = 'Please verify your details and try again.';

// Call stuff
z.string.callStateOutgoing = 'Ringing…';
z.string.callStateConnecting = 'Connecting…';
z.string.callStateIncoming = 'Calling…';
z.string.callStateIncomingGroup = '{{user}} is calling';
z.string.callDecline = 'Decline';
z.string.callAccept = 'Accept';
z.string.callJoin = 'Join';
z.string.callChooseSharedScreen = 'Choose a screen to share';
z.string.callParticipants = '{{number}} on call';
z.string.callNoCameraAccess = 'No camera access';

z.string.videoCallOverlayFitVideoLabel = 'Double-click to fit or fill video to frame';
z.string.videoCallOverlayConversations = 'Conversations';
z.string.videoCallOverlayMute = 'Mute';
z.string.videoCallOverlayVideo = 'Video';
z.string.videoCallOverlayShareScreen = 'Share Screen';
z.string.videoCallOverlayHangUp = 'Hang Up';
z.string.videoCallPaused = 'Video paused';
z.string.videoCallScreenShareNotSupported = 'Screen sharing is not supported in this browser';

// Modals
// Modals type defaults
z.string.modalAcknowledgeAction = 'Ok';
z.string.modalAcknowledgeHeadline = 'Something went wrong';
z.string.modalConfirmSecondary = 'Cancel';
z.string.modalOptionSecondary = 'Cancel';

// Modals content
z.string.modalAccountCreateAction = 'OK';
z.string.modalAccountCreateHeadline = 'Create an account?';
z.string.modalAccountCreateMessage = 'By creating an account you will lose the conversation history in this guest room.';

z.string.modalAccountDeletionAction = 'Delete';
z.string.modalAccountDeletionHeadline = 'Delete account';
z.string.modalAccountDeletionMessage = 'We will send a message via email or SMS. Follow the link to permanently delete your account.';

z.string.modalAccountLeaveGuestRoomAction = 'Leave';
z.string.modalAccountLeaveGuestRoomHeadline = 'Leave the guest room?';
z.string.modalAccountLeaveGuestRoomMessage = 'Conversation history will be deleted. To keep it, create an account next time.';

z.string.modalAccountLogoutAction = 'Log out';
z.string.modalAccountLogoutHeadline = 'Clear Data?';
z.string.modalAccountLogoutOption = 'Delete all your personal information and conversations on this device.';

z.string.modalAccountNewDevicesSecondary = 'Manage devices';
z.string.modalAccountNewDevicesHeadline = 'Your account was used on:';
z.string.modalAccountNewDevicesFrom = 'From:';
z.string.modalAccountNewDevicesMessage = 'If you didn’t do this, remove the device and reset your password.';

z.string.modalAccountRemoveDeviceAction = 'Remove device';
z.string.modalAccountRemoveDeviceHeadline = 'Remove "{{device}}"';
z.string.modalAccountRemoveDeviceMessage = 'Your password is required to remove the device.';
z.string.modalAccountRemoveDevicePlaceholder = 'Password';

z.string.modalAssetTooLargeHeadline = 'File too large';
z.string.modalAssetTooLargeMessage = 'You can send files up to {{number}}';

z.string.modalAssetParallelUploadsHeadline = 'Too many files at once';
z.string.modalAssetParallelUploadsMessage = 'You can send up to {{number}} files at once.';

z.string.modalCallEmptyConversationHeadline = 'No one to call';
z.string.modalCallEmptyConversationMessage = 'There is no one left here.';

z.string.modalCallEmptyLogHeadline = 'No calls';
z.string.modalCallEmptyLogMessage = 'There were no calls to base the debug report on.';

z.string.modalCallNoGroupVideoHeadline = 'No video calls in groups';
z.string.modalCallNoGroupVideoMessage = 'Video calls are not available in group conversations.';

z.string.modalCallNoMicrophoneAction = 'Tell me how';
z.string.modalCallNoMicrophoneMessage = 'Your browser needs access to the microphone to make calls.';
z.string.modalCallNoMicrophoneHeadline = 'Can’t call without microphone';

z.string.modalCallSecondIncomingAction = 'Answer';
z.string.modalCallSecondIncomingHeadline = 'Answer call?';
z.string.modalCallSecondIncomingMessage = 'Your current call will end.';

z.string.modalCallSecondOngoingAction = 'Hang Up';
z.string.modalCallSecondOngoingHeadline = 'Hang up call on another device?';
z.string.modalCallSecondOngoingMessage = 'You can only be in one call at a time.';

z.string.modalCallSecondOutgoingAction = 'Call Anyway';
z.string.modalCallSecondOutgoingHeadline = 'Hang up current call?';
z.string.modalCallSecondOutgoingMessage = 'A call is active in another conversation. Calling here will hang up the other call.';

z.string.modalConnectCancelAction = 'Yes';
z.string.modalConnectCancelHeadline = 'Cancel Request?';
z.string.modalConnectCancelMessage = 'Remove connection request to {{user}}.';
z.string.modalConnectCancelSecondary = 'No';

z.string.modalConnectAcceptAction = 'Connect';
z.string.modalConnectAcceptHeadline = 'Accept?';
z.string.modalConnectAcceptMessage = 'This will connect you and open the conversation with {{user}}.';
z.string.modalConnectAcceptSecondary = 'Ignore';

z.string.modalConversationClearAction = 'Delete';
z.string.modalConversationClearHeadline = 'Delete content?';
z.string.modalConversationClearMessage = 'This will clear the conversation history on all your devices.';
z.string.modalConversationClearOption = 'Also leave the conversation';

z.string.modalConversationDeleteMessageAction = 'Delete';
z.string.modalConversationDeleteMessageHeadline = 'Delete only for me?';
z.string.modalConversationDeleteMessageMessage = 'This cannot be undone.';

z.string.modalConversationDeleteMessageEveryoneAction = 'Delete';
z.string.modalConversationDeleteMessageEveryoneHeadline = 'Delete for everyone?';
z.string.modalConversationDeleteMessageEveryoneMessage = 'This cannot be undone.';

z.string.modalConversationLeaveAction = 'Leave';
z.string.modalConversationLeaveHeadline = 'Leave {{name}} conversation?';
z.string.modalConversationLeaveMessage = 'You won’t be able to send or receive messages in this conversation.';

z.string.modalConversationMessageTooLongHeadline = 'Message too long';
z.string.modalConversationMessageTooLongMessage = 'You can send messages up to {{number}} characters long.';

z.string.modalConversationNewDeviceAction = 'Send anyway';
z.string.modalConversationNewDeviceHeadlineOne = '{{user}} started using a new device';
z.string.modalConversationNewDeviceHeadlineMany = '{{users}} started using new devices';
z.string.modalConversationNewDeviceHeadlineYou = '{{user}} started using a new device';
z.string.modalConversationNewDeviceIncomingCallAction = 'Accept call';
z.string.modalConversationNewDeviceIncomingCallMessage = 'Do you still want to accept the call?';
z.string.modalConversationNewDeviceMessage = 'Do you still want to send your message?';
z.string.modalConversationNewDeviceOutgoingCallAction = 'Call anyway';
z.string.modalConversationNewDeviceOutgoingCallMessage = 'Do you still want to place the call?';

z.string.modalConversationNotConnectedHeadline = 'No one added to conversation';
z.string.modalConversationNotConnectedMessageOne = '{{name}} does not want to be added to conversations.';
z.string.modalConversationNotConnectedMessageMany = 'One of the people you selected does not want to be added to conversations.';

z.string.modalConversationRemoveAction = 'Remove';
z.string.modalConversationRemoveHeadline = 'Remove?';
z.string.modalConversationRemoveMessage = '{{user}} won’t be able to send or receive messages in this conversation.';

z.string.modalConversationRemoveGuestsAction = 'Remove';
z.string.modalConversationRemoveGuestsHeadline = 'Disable access?';
z.string.modalConversationRemoveGuestsMessage = 'Current guests and services will be removed from the conversation. New guests and services will not be allowed.';

z.string.modalConversationRevokeLinkAction = 'Revoke link';
z.string.modalConversationRevokeLinkHeadline = 'Revoke the link?';
z.string.modalConversationRevokeLinkMessage = 'New guests will not be able to join with this link. Current guests will still have access.';

z.string.modalConversationGuestOptionsAllowGuestMessage = 'Could not allow guests and services. Please try again.';
z.string.modalConversationGuestOptionsDisableGuestMessage = 'Could not remove guests and services. Please try again.';
z.string.modalConversationGuestOptionsGetCodeMessage = 'Could not get access link.';
z.string.modalConversationGuestOptionsRequestCodeMessage = 'Could not request access link. Please try again.';
z.string.modalConversationGuestOptionsRevokeCodeMessage = 'Could not revoke access link. Please try again.';
z.string.modalConversationGuestOptionsToggleGuestsMessage = 'Could not change guests state.';

z.string.modalConversationTooManyMembersHeadline = 'The group is full';
z.string.modalConversationTooManyMembersMessage = 'Up to {{number1}} people can join a conversation. Currently there is only room for {{number2}} more.';

z.string.modalGifTooLargeHeadline = 'Selected animation is too large';
z.string.modalGifTooLargeMessage = 'Maximum size is {{number}} MB.';

z.string.modalIntegrationUnavailableHeadline = 'Bots currently unavailable';
z.string.modalIntegrationUnavailableMessage = 'Thank you for your interest in bots. The service is currently suspended while we work on the next version. Stay tuned.';

z.string.modalPictureFileFormatHeadline = 'Can’t use this picture';
z.string.modalPictureFileFormatMessage = 'Please choose a PNG or JPEG file.';

z.string.modalPictureTooLargeHeadline = 'Selected picture is too large';
z.string.modalPictureTooLargeMessage = 'You can use pictures up to {{number}} MB.';

z.string.modalPictureTooSmallHeadline = 'Picture too small';
z.string.modalPictureTooSmallMessage = 'Please choose a picture that is at least 320 x 320 px.';

z.string.modalImproveWireAction = 'I Agree';
z.string.modalImproveWireSecondary = 'No';
z.string.modalImproveWireHeadline = 'Help us make Wire better';
z.string.modalImproveWireMessage = 'I agree that Wire may create and use anonymous usage and error reports to improve the Wire App. I can revoke this consent at any time.';

z.string.modalServiceUnavailableHeadline = 'Adding service not possible';
z.string.modalServiceUnavailableMessage = 'The service is unavailable at the moment.';

z.string.modalSessionResetHeadline = 'The session has been reset';
z.string.modalSessionResetMessage1 = 'If the problem is not resolved,';
z.string.modalSessionResetMessageLink = 'contact';
z.string.modalSessionResetMessage2 = 'us.';

z.string.modalUploadContactsAction = 'Try again';
z.string.modalUploadContactsMessage = 'We did not receive your information. Please try importing your contacts again.';

z.string.modalUserBlockAction = 'Block';
z.string.modalUserBlockHeadline = 'Block {{user}}?';
z.string.modalUserBlockMessage = '{{user}} won’t be able to contact you or add you to group conversations.';

z.string.modalUserUnblockAction = 'Unblock';
z.string.modalUserUnblockHeadline = 'Unblock?';
z.string.modalUserUnblockMessage = '{{user}} will be able to contact you and add you to group conversations again.';

z.string.modalNoCameraTitle = 'No camera access';
z.string.modalNoCameraMessage = 'Wire doesn’t have access to the camera.[br][faqLink]Read this support article[/faqLink] to find out how to fix it.';

// Connection requests
z.string.connectionRequestConnect = 'Connect';
z.string.connectionRequestIgnore = 'Ignore';

// Guests
z.string.conversationGuestIndicator = 'Guest';
z.string.userRemainingTimeHours = '{{time}}h left';
z.string.userRemainingTimeMinutes = 'Less than {{time}}m left';

// Conversation
z.string.conversationYouNominative = 'you';
z.string.conversationYouDative = 'you';
z.string.conversationYouAccusative = 'you';

z.string.conversationConnectionAccepted = 'Connected';
z.string.conversationConnectionBlocked = 'Blocked';
z.string.conversationConnectionCancelRequest = 'Cancel connection request';
z.string.conversationCreateTemporary = 'You joined the conversation';
z.string.conversationCreateWith = 'with {{users}}';
z.string.conversationDeviceStartedUsingOne = ' started using';
z.string.conversationDeviceStartedUsingMany = ' started using';
z.string.conversationDeviceUnverified = ' unverified one of';
z.string.conversationDeviceYourDevices = ' your devices';
z.string.conversationDeviceUserDevices = ' {{user}}´s devices';
z.string.conversationDeviceNewDeviceOne = ' a new device';
z.string.conversationDeviceNewDeviceMany = ' new devices';
z.string.conversationDeviceNewPeopleJoined = 'New people joined.';
z.string.conversationDeviceNewPeopleJoinedVerify = 'Verify devices';
z.string.conversationJustNow = 'Just now';
z.string.conversationLocationLink = 'Open Map';
z.string.conversationCreated = '[bold]{{name}}[/bold] started a conversation with {{users}}';
z.string.conversationCreatedMore = '[bold]{{name}}[/bold] started a conversation with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreatedName = '[bold]{{name}}[/bold] started the conversation';
z.string.conversationCreatedNameYou = '[bold]You[/bold] started the conversation';
z.string.conversationCreatedYou = 'You started a conversation with {{users}}';
z.string.conversationCreatedYouMore = 'You started a conversation with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreateWithMore = 'with {{users}}, and [showmore]{{count}} more[/showmore]';
z.string.conversationCreateTeam = 'with [showmore]all team members[/showmore]';
z.string.conversationCreateTeamGuest = 'with [showmore]all team members and one guest[/showmore]';
z.string.conversationCreateTeamGuests = 'with [showmore]all team members and {{count}} guests[/showmore]';
z.string.conversationMemberJoined = '[bold]{{name}}[/bold] added {{users}} to the conversation';
z.string.conversationMemberJoinedYou = '[bold]You[/bold] added {{users}} to the conversation';
z.string.conversationMemberJoinedMore = '[bold]{{name}}[/bold] added {{users}}, and [showmore]{{count}} more[/showmore] to the conversation';
z.string.conversationMemberJoinedYouMore = '[bold]You[/bold] added {{users}}, and [showmore]{{count}} more[/showmore] to the conversation';
z.string.conversationMemberJoinedSelf = '[bold]{{name}}[/bold] joined';
z.string.conversationMemberJoinedSelfYou = '[bold]You[/bold] joined';
z.string.conversationMemberLeft = '[bold]{{name}}[/bold] left';
z.string.conversationMemberLeftYou = '[bold]You[/bold] left';
z.string.conversationMemberRemoved = '[bold]{{name}}[/bold] removed {{users}}';
z.string.conversationMemberRemovedYou = '[bold]You[/bold] removed {{users}}';
z.string.conversationTeamLeft = '[bold]{{name}}[/bold] was removed from the team';
z.string.conversationMessageDelivered = 'Delivered';
z.string.conversationRename = ' renamed the conversation';
z.string.conversationRenameYou = ' renamed the conversation';
z.string.conversationUpdatedTimer = ' set the message timer to {{time}}';
z.string.conversationUpdatedTimerYou = ' set the message timer to {{time}}';
z.string.conversationResetTimer = ' turned off the message timer';
z.string.conversationResetTimerYou = ' turned off the message timer';
z.string.conversationResume = 'Start a conversation with {{users}}';
z.string.conversationPing = ' pinged';
z.string.conversationPingYou = ' pinged';
z.string.conversationToday = 'today';
z.string.conversationVoiceChannelDeactivate = ' called';
z.string.conversationVoiceChannelDeactivateYou = ' called';
z.string.conversationYesterday = 'Yesterday';
z.string.conversationUnableToDecrypt1 = 'A message from [highlight]{{user}}[/highlight] was not received.';
z.string.conversationUnableToDecrypt2 = '[highlight]{{user}}[/highlight]´s device identity changed. Undelivered message.';
z.string.conversationUnableToDecryptLink = 'Why?';
z.string.conversationUnableToDecryptErrorMessage = 'Error';
z.string.conversationUnableToDecryptResetSession = 'Reset session';
z.string.conversationMissedMessages = 'You haven’t used this device for a while. Some messages may not appear here.';
z.string.conversationAssetUploading = 'Uploading…';
z.string.conversationAssetDownloading = 'Downloading…';
z.string.conversationAssetUploadFailed = 'Upload Failed';
z.string.conversationPlaybackError = 'Unable to play';
z.string.conversationContextMenuCopy = 'Copy';
z.string.conversationContextMenuEdit = 'Edit';
z.string.conversationContextMenuDelete = 'Delete for Me…';
z.string.conversationContextMenuDeleteEveryone = 'Delete for Everyone…';
z.string.conversationContextMenuDownload = 'Download';
z.string.conversationContextMenuLike = 'Like';
z.string.conversationContextMenuReply = 'Reply';
z.string.conversationContextMenuUnlike = 'Unlike';
z.string.conversationDeleteTimestamp = 'Deleted: {{date}}';
z.string.conversationEditTimestamp = 'Edited: {{date}}';
z.string.conversationLikesCaption = '{{number}} people';
z.string.conversationSendPastedFile = 'Pasted image at {{date}}';
z.string.conversationSomeone = 'Someone';
z.string.conversationTweetAuthor = ' on Twitter';
z.string.conversationServicesWarning = 'Services have access to the content of this conversation';

// Group creation
z.string.groupCreationPreferencesAction = 'Next';
z.string.groupCreationPreferencesErrorNameShort = 'At least 1 character';
z.string.groupCreationPreferencesErrorNameLong = 'Too many characters';
z.string.groupCreationPreferencesHeader = 'Create group';
z.string.groupCreationPreferencesPlaceholder = 'Group name';
z.string.groupCreationParticipantsActionCreate = 'Done';
z.string.groupCreationParticipantsActionSkip = 'Skip';
z.string.groupCreationParticipantsHeader = 'Add people';
z.string.groupCreationParticipantsHeaderWithCounter = 'Add people ({{number}})';
z.string.groupCreationParticipantsPlaceholder = 'Search by name';
z.string.groupSizeInfo = 'Up to {{count}} people can join a group conversation. Video calls work with up to 3 other people and you.';

// Guest room
z.string.guestRoomConversationName = 'Guest room';
z.string.guestRoomToggleName = 'Allow guests and services';
z.string.guestRoomToggleInfo = 'Open this conversation to services and people outside your team.';
z.string.guestRoomToggleInfoExtended = 'Open this conversation to services and people outside your team. You can always change it later.';

z.string.guestRoomConversationBadge = 'Guests are present';
z.string.guestRoomConversationBadgeService = 'Services are active';
z.string.guestRoomConversationBadgeGuestAndService = 'Guests and services are present';

z.string.guestRoomConversationHead = 'People outside your team can join this conversation.';
z.string.guestRoomConversationButton = 'Invite people';

// Collection
z.string.collectionShowAll = 'Show all {{number}}';
z.string.collectionSectionLinks = 'Links';
z.string.collectionSectionImages = 'Pictures';
z.string.collectionSectionFiles = 'Files';
z.string.collectionSectionAudio = 'Audio messages';

// Full Search
z.string.fullsearchPlaceholder = 'Search text messages';
z.string.fullsearchNoResults = 'No results.';

// Archive
z.string.archiveHeader = 'Archive';

// Conversations
z.string.conversationsAllArchived = 'Everything archived';
z.string.conversationsContacts = 'Contacts';
z.string.conversationsConnectionRequestMany = '{{number}} people waiting';
z.string.conversationsConnectionRequestOne = '1 person waiting';
z.string.conversationsEmptyConversation = 'Group conversation';
z.string.conversationsNoConversations = 'Start a conversation or create a group.';
z.string.conversationsPopoverArchive = 'Archive';
z.string.conversationsPopoverBlock = 'Block…';
z.string.conversationsPopoverCancel = 'Cancel request…';
z.string.conversationsPopoverClear = 'Delete content…';
z.string.conversationsPopoverLeave = 'Leave group…';
z.string.conversationsPopoverNotificationSettings = 'Notifications…';
z.string.conversationsPopoverNotify = 'Unmute';
z.string.conversationsPopoverSilence = 'Mute';
z.string.conversationsPopoverUnarchive = 'Unarchive';

// Conversations secondary line
z.string.conversationsSecondaryLineEphemeralMention = 'Mentioned you';
z.string.conversationsSecondaryLineEphemeralMentionGroup = 'Someone mentioned you';
z.string.conversationsSecondaryLineEphemeralMessage = 'Sent a message';
z.string.conversationsSecondaryLineEphemeralMessageGroup = 'Someone sent a message';
z.string.conversationsSecondaryLineEphemeralReply = 'Replied to you';
z.string.conversationsSecondaryLineEphemeralReplyGroup = 'Someone replied to you';
z.string.conversationsSecondaryLineIncomingCall = '{{user}} is calling';
z.string.conversationsSecondaryLinePeopleLeft = '{{number}} people left';
z.string.conversationsSecondaryLinePersonLeft = '{{user}} left';
z.string.conversationsSecondaryLinePersonRemoved = '{{user}} was removed';
z.string.conversationsSecondaryLinePersonRemovedTeam = '{{user}} was removed from the team';
z.string.conversationsSecondaryLinePeopleAdded = '{{user}} people were added';
z.string.conversationsSecondaryLinePersonAdded = '{{user}} was added';
z.string.conversationsSecondaryLinePersonAddedSelf = '{{user}} joined';
z.string.conversationsSecondaryLinePersonAddedYou = '{{user}} added you';
z.string.conversationsSecondaryLineRenamed = '{{user}} renamed conversation';
z.string.conversationsSecondaryLineSummaryMessage = '{{number}} message';
z.string.conversationsSecondaryLineSummaryMessages = '{{number}} messages';
z.string.conversationsSecondaryLineSummaryMention = '{{number}} mention';
z.string.conversationsSecondaryLineSummaryMentions = '{{number}} mentions';
z.string.conversationsSecondaryLineSummaryMissedCall = '{{number}} missed call';
z.string.conversationsSecondaryLineSummaryMissedCalls = '{{number}} missed calls';
z.string.conversationsSecondaryLineSummaryPing = '{{number}} ping';
z.string.conversationsSecondaryLineSummaryPings = '{{number}} pings'
z.string.conversationsSecondaryLineSummaryReply = '{{number}} reply';
z.string.conversationsSecondaryLineSummaryReplies = '{{number}} replies';
z.string.conversationsSecondaryLineYouLeft = 'You left';
z.string.conversationsSecondaryLineYouWereRemoved = 'You were removed';

// Takeover
z.string.takeoverSub = 'Claim your unique name on Wire.';
z.string.takeoverLink = 'Learn more';
z.string.takeoverButtonChoose = 'Choose your own';
z.string.takeoverButtonKeep = 'Keep this one';

// Invites
z.string.inviteMetaKeyMac = 'Cmd';
z.string.inviteMetaKeyPc = 'Ctrl';
z.string.inviteHintSelected = 'Press {{metaKey}} + C to copy';
z.string.inviteHintUnselected = 'Select and Press {{metaKey}} + C';
z.string.inviteHeadline = 'Invite people to Wire';
z.string.inviteMessage = 'I’m on Wire, search for {{username}} or visit get.wire.com.';
z.string.inviteMessageNoEmail = 'I’m on Wire. Visit get.wire.com to connect with me.';

// Extensions
z.string.extensionsBubbleButtonGif = 'Gif';

// Extensions Giphy
z.string.extensionsGiphyButtonOk = 'Send';
z.string.extensionsGiphyButtonMore = 'Try Another';
z.string.extensionsGiphyMessage = '{{tag}} • via giphy.com';
z.string.extensionsGiphyNoGifs = 'Oops, no gifs';
z.string.extensionsGiphyRandom = 'Random';

// Panel
// Panel: Add participants
z.string.addParticipantsConfirmLabel = 'Add';
z.string.addParticipantsHeader = 'Add participants';
z.string.addParticipantsHeaderWithCounter = 'Add participants ({{number}})';
z.string.addParticipantsManageServices = 'Manage services';
z.string.addParticipantsManageServicesNoResults = 'Manage services';
z.string.addParticipantsNoServicesManager = 'Services are helpers that can improve your workflow.';
z.string.addParticipantsNoServicesMember = 'Services are helpers that can improve your workflow. To enable them, ask your administrator.';
z.string.addParticipantsSearchPlaceholder = 'Search by name';
z.string.addParticipantsServiceConfirmButton = 'Add service';
z.string.addParticipantsTabsPeople = 'People';
z.string.addParticipantsTabsServices = 'Services';

// Panel: Conversation details
z.string.conversationDetailsActionArchive = 'Archive';
z.string.conversationDetailsActionAddParticipants = 'Add participants';
z.string.conversationDetailsActionBlock = 'Block…';
z.string.conversationDetailsActionCancelRequest = 'Cancel request…';
z.string.conversationDetailsActionClear = 'Delete content…';
z.string.conversationDetailsActionConversationParticipants = 'Show all ({{number}})';
z.string.conversationDetailsActionCreateGroup = 'Create group';
z.string.conversationDetailsActionDevices = 'Devices';
z.string.conversationDetailsActionGuestOptions = 'Guests and services';
z.string.conversationDetailsActionTimedMessages = 'Timed messages';
z.string.conversationDetailsActionNotifications = 'Notifications';
z.string.conversationDetailsActionLeave = 'Leave group…';
z.string.conversationDetailsGuestsOff = 'Off';
z.string.conversationDetailsGuestsOn = 'On';
z.string.conversationDetailsOptions = 'Options';
z.string.conversationDetailsParticipantsServicesOne = 'Service';
z.string.conversationDetailsParticipantsServicesMany = 'Services';
z.string.conversationDetailsParticipantsUsersOne = 'Person';
z.string.conversationDetailsParticipantsUsersMany = 'People';
z.string.conversationDetailsPeople = 'People';
z.string.conversationDetailsServices = 'Services';

// Panel: Conversation participants
z.string.conversationParticipantsTitle = 'People';
z.string.conversationParticipantsSearchPlaceholder = 'Search by name';

// Panel: Group participant
z.string.groupParticipantActionBlock = 'Block…';
z.string.groupParticipantActionCancelRequest = 'Cancel request…';
z.string.groupParticipantActionDevices = 'Devices';
z.string.groupParticipantActionIgnoreRequest = 'Ignore request';
z.string.groupParticipantActionIncomingRequest = 'Accept request';
z.string.groupParticipantActionLeave = 'Leave group…';
z.string.groupParticipantActionOpenConversation = 'Open conversation';
z.string.groupParticipantActionPending = 'Pending';
z.string.groupParticipantActionRemove = 'Remove from group…';
z.string.groupParticipantActionSelfProfile = 'Open profile';
z.string.groupParticipantActionSendRequest = 'Connect';
z.string.groupParticipantActionUnblock = 'Unblock…';

// Panel: Guest options
z.string.guestOptionsCopyLink = 'Copy link';
z.string.guestOptionsCopyLinkDone = 'Link copied!';
z.string.guestOptionsCreateLink = 'Create link';
z.string.guestOptionsInfoHeader = 'Invite others with a link';
z.string.guestOptionsInfoText = 'Anyone with the link can join the conversation, even if they don’t have Wire.';
z.string.guestOptionsRevokeLink = 'Revoke link…';
z.string.guestOptionsTitle = 'Guests and services';

// Panel: Notifications
z.string.notificationSettingsTitle = 'Notifications';
z.string.notificationSettingsDisclaimer = 'You can be notified about everything (including audio and video calls) or only when someone mentions you or replies to one of your messages.';
z.string.notificationSettingsEverything = 'Everything';
z.string.notificationSettingsMentionsAndReplies = 'Mentions and replies';
z.string.notificationSettingsNothing = 'Nothing';

// Panel: Timed messages
z.string.timedMessagesTitle = 'Timed messages';
z.string.timedMessageDisclaimer = 'Timed messages will be turned on for all the participants in this conversation.';

// Panel: Participant devices
z.string.participantDevicesDetailHeadline = 'Verify that this matches the fingerprint shown on {{html1}}{{user}}’s device{{html2}}.';
z.string.participantDevicesDetailHowTo = 'How do I do that?';
z.string.participantDevicesDetailResetSession = 'Reset session';
z.string.participantDevicesDetailShowMyDevice = 'Show my device fingerprint';
z.string.participantDevicesDetailVerify = 'Verified';

z.string.participantDevicesHeader = 'Devices';
z.string.participantDevicesHeadline = 'Wire gives every device a unique fingerprint. Compare them with {{user}} and verify your conversation.';
z.string.participantDevicesLearnMore = 'Learn more';
z.string.participantDevicesWhyVerify = 'Why verify conversations?';
z.string.participantDevicesOutdatedClientMessage = '{{user}} is using an old version of Wire. No devices are shown here.';

z.string.participantDevicesSelfAllDevices = 'Show all my devices';
z.string.participantDevicesSelfFingerprint = 'Device fingerprint';

// User profile actions
z.string.userProfileButtonConnect = 'Connect';
z.string.userProfileButtonIgnore = 'Ignore';
z.string.userProfileButtonUnblock = 'Unblock';

// Settings
z.string.preferencesAbout = 'About';
z.string.preferencesAccount = 'Account';
z.string.preferencesAV = 'Audio / Video';
z.string.preferencesDeviceDetails = 'Device Details';
z.string.preferencesDevices = 'Devices';
z.string.preferencesHeadline = 'Preferences';
z.string.preferencesOptions = 'Options';

z.string.preferencesAboutCopyright = '© Wire Swiss GmbH';
z.string.preferencesAboutPrivacyPolicy = 'Privacy policy';
z.string.preferencesAboutSupport = 'Support';
z.string.preferencesAboutSupportWebsite = 'Support website';
z.string.preferencesAboutSupportContact = 'Contact Support';
z.string.preferencesAboutTermsOfUse = 'Terms of use';
z.string.preferencesAboutVersion = 'Version {{version}}';
z.string.preferencesAboutWebsite = 'Wire website';

z.string.preferencesAccountAvaibilityUnset = 'Set a status';
z.string.preferencesAccountCreateTeam = 'Create a team';
z.string.preferencesAccountData = 'Data usage permissions';
z.string.preferencesAccountDataCheckbox = 'Send anonymous data';
z.string.preferencesAccountDataDetail = 'Help make Wire better by sending anonymous usage and crash reports.';
z.string.preferencesAccountDelete = 'Delete account';
z.string.preferencesAccountLeaveGuestRoom = 'Leave the guest room';
z.string.preferencesAccountLeaveGuestRoomDescription = 'You will no longer be able to access the messages in this conversation.';
z.string.preferencesAccountLogOut = 'Log out';
z.string.preferencesAccountManageTeam = 'Manage team';
z.string.preferencesAccountMarketingConsentCheckbox = 'Receive newsletter';
z.string.preferencesAccountMarketingConsentDetail = 'Receive news and product updates from Wire via email.';
z.string.preferencesAccountResetPassword = 'Reset password';
z.string.preferencesAccountTeam = 'in {{name}}';
z.string.preferencesAccountUsernamePlaceholder = 'Your full name';
z.string.preferencesAccountUsernameHint = 'At least 2 characters. a—z, 0—9 and _ only.';
z.string.preferencesAccountUsernameAvailable = 'Available';
z.string.preferencesAccountUsernameErrorTaken = 'Already taken';

z.string.preferencesAVCamera = 'Camera';
z.string.preferencesAVMicrophone = 'Microphone';
z.string.preferencesAVPermissionDetail = 'Enable from your browser Preferences';
z.string.preferencesAVSpeakers = 'Speakers';
z.string.preferencesAVTemporaryDisclaimer = 'Guests can’t start video conferences. Select the camera to use if you join one.';
z.string.preferencesAVNoCamera = 'Wire doesn’t have access to the camera.[br][faqLink]Read this support article[/faqLink] to find out how to fix it.';
z.string.preferencesAVTryAgain= 'Try Again';

z.string.preferencesDevicesActivatedOn = 'Activated {{date}}';
z.string.preferencesDevicesActive = 'Active';
z.string.preferencesDevicesActiveDetail = 'If you don’t recognize a device above, remove it and reset your password.';
z.string.preferencesDevicesCurrent = 'Current';
z.string.preferencesDevicesFingerprint = 'Key fingerprint';
z.string.preferencesDevicesFingerprintDetail = 'Wire gives every device a unique fingerprint. Compare them and verify your devices and conversations.';
z.string.preferencesDevicesId = 'ID: ';
z.string.preferencesDevicesRemove = 'Remove…';
z.string.preferencesDevicesRemoveCancel = 'Cancel';
z.string.preferencesDevicesRemoveDetail = 'Remove this device if you have stopped using it. You will be logged out of this device immediately.';
z.string.preferencesDevicesSessionConfirmation = 'The session has been reset.';
z.string.preferencesDevicesSessionDetail = 'If fingerprints don’t match, reset the session to generate new encryption keys on both sides.';
z.string.preferencesDevicesSessionReset = 'Reset session';
z.string.preferencesDevicesSessionOngoing = 'Resetting session…';
z.string.preferencesDevicesVerification = 'Verified';

z.string.preferencesOptionsAudio = 'Sound alerts';
z.string.preferencesOptionsAudioAll = 'All';
z.string.preferencesOptionsAudioAllDetail = 'All sounds';
z.string.preferencesOptionsAudioNone = 'None';
z.string.preferencesOptionsAudioNoneDetail = 'Sshhh!';
z.string.preferencesOptionsAudioSome = 'Some';
z.string.preferencesOptionsAudioSomeDetail = 'Pings and calls';
z.string.preferencesOptionsContacts = 'Contacts';
z.string.preferencesOptionsContactsMacos = 'Import from Contacts';
z.string.preferencesOptionsContactsDetail = 'We use your contact data to connect you with others. We anonymize all information and do not share it with anyone else.';
z.string.preferencesOptionsPopular = 'By popular demand';
z.string.preferencesOptionsEmojiReplaceCheckbox = 'Replace type emoticons with emojis';
z.string.preferencesOptionsEmojiReplaceDetail = ':-) → [icon]';
z.string.preferencesOptionsPreviewsSendCheckbox = 'Create previews for links you send';
z.string.preferencesOptionsPreviewsSendDetail = 'Previews may still be shown for links from other people.';
z.string.preferencesOptionsNotifications = 'Notifications';
z.string.preferencesOptionsNotificationsNone = 'Off';
z.string.preferencesOptionsNotificationsObfuscate = 'Hide details';
z.string.preferencesOptionsNotificationsObfuscateMessage = 'Show sender';
z.string.preferencesOptionsNotificationsOn = 'Show sender and message';
z.string.preferencesOptionsCallLogs = 'Troubleshooting';
z.string.preferencesOptionsCallLogsGet = 'Save the calling debug report';
z.string.preferencesOptionsCallLogsDetail = 'This information helps Wire Support diagnose calling problems.';

z.string.preferencesOptionsBackupHeader = 'History';
z.string.preferencesOptionsBackupExportHeadline = 'Back up conversations';
z.string.preferencesOptionsBackupExportSecondary = 'Create a backup to preserve your conversation history. You can use this to restore history if you lose your computer or switch to a new one.\nThe backup file is not protected by Wire end-to-end encryption, so store it in a safe place.';
z.string.preferencesOptionsBackupImportHeadline = 'Restore from backup';
z.string.preferencesOptionsBackupImportSecondary = 'You can only restore history from a backup of the same platform. Your backup will overwrite the conversations that you may have on this device.';

// History Backup
z.string.backupExportGenericErrorHeadline = 'The file could not be saved';
z.string.backupExportGenericErrorSecondary = 'The backup was not completed.';
z.string.backupExportProgressHeadline = 'Preparing…';
z.string.backupExportProgressSecondary = 'Backing up · {{processed}} of {{total}} — {{progress}}%';
z.string.backupExportProgressCompressing = 'Preparing backup file';
z.string.backupExportSaveFileAction = 'Save file';
z.string.backupExportSuccessHeadline = 'Backup ready';
z.string.backupExportSuccessSecondary = 'You can use this to restore history if you lose your computer or switch to a new one.';
z.string.backupImportGenericErrorHeadline = 'Something went wrong';
z.string.backupImportGenericErrorSecondary = 'Your history could not be restored.';
z.string.backupImportAccountErrorHeadline = 'Wrong backup';
z.string.backupImportAccountErrorSecondary = 'You cannot restore history from a different account.';
z.string.backupImportVersionErrorHeadline = 'Incompatible backup';
z.string.backupImportVersionErrorSecondary = 'This backup was created by a newer or outdated version of Wire and cannot be restored here.';
z.string.backupImportIncompatibleErrorHeadline = 'Wrong backup';
z.string.backupImportIncompatibleErrorSecondary = 'You cannot restore history from a different account.';
z.string.backupImportOutdatedErrorHeadline = 'Incompatible backup';
z.string.backupImportOutdatedErrorSecondary = 'This backup was created by a newer or outdated version of Wire and cannot be restored here.';
z.string.backupImportProgressHeadline = 'Preparing…';
z.string.backupImportProgressSecondary = 'Restoring history · {{processed}} of {{total}} — {{progress}}%';
z.string.backupImportSuccessHeadline = 'History restored.';
z.string.backupCancel = 'Cancel';
z.string.backupTryAgain = 'Try Again';

// Search
z.string.searchConnect = 'Connect';
z.string.searchConnections = 'Connections';
z.string.searchContacts = 'Contacts';
z.string.searchCreateGroup = 'Create group';
z.string.searchCreateGuestRoom = 'Create guest room';
z.string.searchGroups = 'Groups';
z.string.searchPeople = 'People';
z.string.searchPlaceholder = 'Search by name or username';
z.string.searchServicePlaceholder = 'Search by name';
z.string.searchServices = 'Services';
z.string.searchManageServices = 'Manage Services';
z.string.searchManageServicesNoResults = 'Manage services';
z.string.searchNoServicesManager = 'Services are helpers that can improve your workflow.';
z.string.searchNoServicesMember = 'Services are helpers that can improve your workflow. To enable them, ask your administrator.';
z.string.searchTeamGroups = 'Team conversations';
z.string.searchTeamMembers = 'Team members';
z.string.searchTopPeople = 'Top people';
z.string.searchTrySearch = 'Find people by\nname or username';
z.string.searchNoContactsOnWire = 'You have no contacts on Wire.\nTry finding people by\nname or username.';
z.string.searchMemberInvite = 'Invite people to join the team';
z.string.searchOthers = 'Connect';

z.string.searchInvite = 'Invite people to join Wire';
z.string.searchInviteDetail = 'Sharing your contacts helps you connect with others. We anonymize all the information and do not share it with anyone else.';
z.string.searchInviteButtonContacts = 'From Contacts';
z.string.searchInviteHeadline = 'Bring your friends';
z.string.searchInviteShare = 'Share Contacts';

z.string.searchServiceConfirmButton = 'Open Conversation';

// Search list: User list & service list components
z.string.searchListEveryoneParticipates = 'Everyone you’re\nconnected to is already in\nthis conversation.';
z.string.searchListNoMatches = 'No matching results.\nTry entering a different name.';

// Temporary guest experience
z.string.temporaryGuestCta = 'Create an account';
z.string.temporaryGuestDescription = 'Secure your business with encrypted group messaging and conference calls.';
z.string.temporaryGuestTimeRemaining = ' left in this guest room';

z.string.temporaryGuestJoinMessage = 'This conversation will be available to you for 24 hours.';
z.string.temporaryGuestJoinDescription = 'If you close or refresh this page, you will lose access.';

z.string.temporaryGuestLeaveMessage = ' are no longer part of this conversation.';
z.string.temporaryGuestLeaveDescription = 'If you close or refresh this page, you will lose access to the conversation history.';

// URLs & Warnings: Permission requests & permission callbacks
z.string.urlSupportRoot = '/';
z.string.urlSupportArticles = '/hc/en-us/articles/';
z.string.urlSupportRequests = '/hc/en-us/requests/';
z.string.urlWebappRoot = '/';
z.string.urlWebsiteRoot = '/';
z.string.urlWebsiteCreateTeam = '/create-team/';
z.string.urlWebsitePrivacy = '/privacy';
z.string.warningCallUnsupportedIncoming = '{{user}} is calling. Your browser doesn’t support calls.';
z.string.warningCallUnsupportedOutgoing = 'You cannot call because your browser doesn’t support calls.';
z.string.warningCallIssues = 'This version of Wire can not participate in the call. Please use';
z.string.warningCallUpgradeBrowser = 'To call, please update Google Chrome.';
z.string.warningConnectivityConnectionLost = 'Trying to connect. Wire may not be able to deliver messages.';
z.string.warningConnectivityNoInternet = 'No Internet. You won’t be able to send or receive messages.';
z.string.warningLearnMore = 'Learn more';
z.string.warningLifecycleUpdate = 'A new version of Wire is available.';
z.string.warningLifecycleUpdateNotes = 'What’s new';
z.string.warningLifecycleUpdateLink = 'Update now';
z.string.warningNotFoundCamera = 'You cannot call because your computer does not have a camera.';
z.string.warningNotFoundMicrophone = 'You cannot call because your computer does not have a microphone.';
z.string.warningPermissionDeniedCamera = 'You cannot call because your browser does not have access to the camera.';
z.string.warningPermissionDeniedMicrophone = 'You cannot call because your browser does not have access to the microphone.';
z.string.warningPermissionDeniedScreen = 'Your browser needs permission to share your screen.';
z.string.warningPermissionRequestCamera = '[icon] Allow access to camera';
z.string.warningPermissionRequestMicrophone = '[icon] Allow access to microphone';
z.string.warningPermissionRequestNotification = '[icon] Allow notifications';
z.string.warningPermissionRequestScreen = '[icon] Allow access to screen';

// User Availability
z.string.userAvailabilityAvailable = 'Available';
z.string.userAvailabilityAway = 'Away';
z.string.userAvailabilityBusy = 'Busy';
z.string.userAvailabilityNone = 'None';

// Browser notifications
z.string.notificationAssetAdd = 'Shared a picture';
z.string.notificationConnectionAccepted = 'Accepted your connection request';
z.string.notificationConnectionConnected = 'You are now connected';
z.string.notificationConnectionRequest = 'Wants to connect';
z.string.notificationConversationCreate = '{{user}} started a conversation';
z.string.notificationConversationMessageTimerUpdate = '{{user}} set the message timer to {{time}}';
z.string.notificationConversationMessageTimerReset = '{{user}} turned off the message timer';
z.string.notificationConversationRename = '{{user}} renamed the conversation to {{name}}';
z.string.notificationMemberJoinMany = '{{user}} added {{number}} people to the conversation';
z.string.notificationMemberJoinSelf = '{{user}} joined the conversation';
z.string.notificationMemberJoinOne = '{{user1}} added {{user2}} to the conversation';
z.string.notificationMemberLeaveRemovedYou = '{{user}} removed you from the conversation';
z.string.notificationMention = 'Mention: {{text}}';
z.string.notificationObfuscated = 'Sent a message';
z.string.notificationObfuscatedMention = 'Mentioned you';
z.string.notificationObfuscatedReply = 'Replied to you';
z.string.notificationObfuscatedTitle = 'Someone';
z.string.notificationPing = 'Pinged';
z.string.notificationReaction = '{{reaction}} your message';
z.string.notificationReply = 'Reply: {{text}}';
z.string.notificationSharedAudio = 'Shared an audio message';
z.string.notificationSharedFile = 'Shared a file';
z.string.notificationSharedLocation = 'Shared a location';
z.string.notificationSharedVideo = 'Shared a video';
z.string.notificationTitleGroup = '{{user}} in {{conversation}}';
z.string.notificationVoiceChannelActivate = 'Calling';
z.string.notificationVoiceChannelDeactivate = 'Called';

// Tooltips
z.string.tooltipConversationAllVerified = 'All fingerprints are verified';
z.string.tooltipConversationCall = 'Call';
z.string.tooltipConversationEphemeral = 'Timed message';
z.string.tooltipConversationFile = 'Add file';
z.string.tooltipConversationInputPlaceholder = 'Type a message';
z.string.tooltipConversationInputPlaceholderAvailable = '{{user}} is available';
z.string.tooltipConversationInputPlaceholderAway = '{{user}} is away';
z.string.tooltipConversationInputPlaceholderBusy = '{{user}} is busy';
z.string.tooltipConversationPeople = 'People ({{shortcut}})';
z.string.tooltipConversationPicture = 'Add picture';
z.string.tooltipConversationPing = 'Ping ({{shortcut}})';
z.string.tooltipConversationSearch = 'Search';
z.string.tooltipConversationVideoCall = 'Video Call';

z.string.tooltipConversationsArchive = 'Archive ({{shortcut}})';
z.string.tooltipConversationsArchived = 'Show archive ({{number}})';
z.string.tooltipConversationsMore = 'More';
z.string.tooltipConversationsNotifications = 'Open notification settings ({{shortcut}})';
z.string.tooltipConversationsNotify = 'Unmute ({{shortcut}})';
z.string.tooltipConversationsPreferences = 'Open preferences';
z.string.tooltipConversationsSilence = 'Mute ({{shortcut}})';
z.string.tooltipConversationsStart = 'Start conversation ({{shortcut}})';

z.string.tooltipConversationDetailsAddPeople = 'Add participants to conversation ({{shortcut}})';
z.string.tooltipConversationDetailsRename = 'Change conversation name';

z.string.tooltipPreferencesContactsMacos = 'Share all your contacts from the macOS Contacts app';
z.string.tooltipPreferencesPassword = 'Open another website to reset your password';
z.string.tooltipPreferencesPicture = 'Change your picture…';
z.string.tooltipPreferencesRename = 'Change your name';

z.string.tooltipSearchClose = 'Close (Esc)';

// App loading
z.string.initReceivedSelfUser = 'Hello, {{user}}.';
z.string.initValidatedClient = 'Fetching your connections and conversations';
z.string.initReceivedUserData = 'Checking for new messages';
z.string.initDecryption = 'Decrypting messages';
z.string.initEvents = 'Loading messages';
z.string.initUpdatedFromNotifications = 'Almost done - Enjoy Wire';
z.string.initProgress = ' — {{number1}} of {{number2}}';

z.string.ephemeralUnitsNone = 'Off';
z.string.ephemeralUnitsSecond = 'second';
z.string.ephemeralUnitsSeconds = 'seconds';
z.string.ephemeralUnitsMinute = 'minute';
z.string.ephemeralUnitsMinutes = 'minutes';
z.string.ephemeralUnitsHour = 'hour';
z.string.ephemeralUnitsHours = 'hours';
z.string.ephemeralUnitsDay = 'day';
z.string.ephemeralUnitsDays = 'days';
z.string.ephemeralUnitsWeek = 'week';
z.string.ephemeralUnitsWeeks = 'weeks';
z.string.ephemeralUnitsYear = 'year';
z.string.ephemeralUnitsYears = 'years';
z.string.ephemeralRemaining = 'remaining';

// Replies
z.string.replyAudioMessage = 'Audio Message';
z.string.replyQuoteError = 'You cannot see this message.';
z.string.replyQuoteShowMore = 'Show more';
z.string.replyQuoteShowLess = 'Show less';
z.string.replyQuoteTimeStampDate = 'Original message from {{date}}';
z.string.replyQuoteTimeStampTime = 'Original message from {{time}}'

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
z.localization = z.localization || {};

class Localizer {
  constructor() {
    const DEFAULT_LOCALE = 'en';
    const queryParam = z.util.URLUtil.getParameter(z.auth.URLParameter.LOCALE);
    const currentBrowserLocale = navigator.language.substr(0, 2);
    let storedLocale = z.util.StorageUtil.getValue(z.storage.StorageKey.LOCALIZATION.LOCALE);

    if (queryParam) {
      storedLocale = z.util.StorageUtil.setValue(z.storage.StorageKey.LOCALIZATION.LOCALE, queryParam);
    }

    this.locale = storedLocale || currentBrowserLocale || DEFAULT_LOCALE;

    document.getElementsByTagName('html')[0].setAttribute('lang', this.locale);

    moment.locale([this.locale, DEFAULT_LOCALE]);

    if (z.string[this.locale]) {
      Object.assign(z.string, z.string[this.locale]);
    }
  }
}

z.localization.Localizer = new Localizer();

z.l10n = (() => {
  const isStringOrNumber = toTest => _.isString(toTest) || _.isNumber(toTest);

  const replaceSubstitute = (string, regex, substitute) => {
    const replacement = isStringOrNumber(substitute)
      ? substitute
      : (found, content) => (substitute.hasOwnProperty(content) ? substitute[content] : found);
    return string.replace(regex, replacement);
  };

  return {
    safeHtml(value, substitutions = {}) {
      const replace = isStringOrNumber(substitutions) ? substitutions : substitutions.replace;

      const defaultReplacements = {
        '/bold': '</b>',
        '/italic': '</i>',
        bold: '<b>',
        italic: '<i>',
      };

      const replaceDangerously = Object.assign({}, defaultReplacements, substitutions.replaceDangerously);

      let string = ko.unwrap(value);

      if (replace !== undefined) {
        string = replaceSubstitute(string, /{{(.+?)}}/g, replace);
      }

      string = z.util.SanitizationUtil.escapeString(string);

      string = replaceSubstitute(string, /\[(.+?)\]/g, replaceDangerously);

      return string;
    },

    /**
     * Retrieve localized string and replace placeholders
     *
     * This method give you two options to replace placeholders
     *
     * @example using a string as substitute
     * z.l10.text('Hey {{name}}', 'Tod') // returns 'Hey Tod'
     *
     * @example using an object as substitute
     * z.l10.text('{{greeting}} {{name}}', {name: 'Tod', greeting: 'Hey') // returns 'Hey Tod'
     *
     * @param {Observable|string} value - localized string in our case usually z.string.foo
     * @param {string|Object} [substitute] - data to fill all the placeholder with
     * @returns {string} - string with substituted placeholders
     */
    text: (value, substitute) => replaceSubstitute(ko.unwrap(value), /{{(.+?)}}/g, substitute),
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.ConversationType = {
  GROUP: 'group',
  ONE_TO_ONE: 'one_to_one',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.DeleteType = {
  EVERYWHERE: 'everywhere',
  LOCAL: 'local',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.MessageType = {
  FILE: 'file',
  IMAGE: 'image',
  LOCATION: 'location',
  PING: 'ping',
  SYSTEM: 'system',
  TEXT: 'text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.PlatformType = {
  BROWSER_APP: 'web',
  DESKTOP_LINUX: 'linux',
  DESKTOP_MACOS: 'mac',
  DESKTOP_WINDOWS: 'windows',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};
window.z.tracking.attribute = z.tracking.attribute || {};

z.tracking.attribute.UserType = {
  GUEST: 'guest',
  TEMPORARY_GUEST: 'temporary_guest',
  USER: 'user',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

/**
 * Definition of events used for user analytics.
 * @returns {z.tracking.EventName} Event names (defined by Business Intelligence Team)
 */
z.tracking.EventName = {
  CALLING: {
    ENDED_CALL: 'calling.ended_call',
    ENDED_VIDEO_CALL: 'calling.ended_video_call',
    ESTABLISHED_CALL: 'calling.established_call',
    ESTABLISHED_VIDEO_CALL: 'calling.established_video_call',
    FAILED_REQUEST: 'calling.failed_request',
    FAILED_REQUESTING_MEDIA: 'calling.failed_requesting_media',
    FAILED_RTC: 'calling.failed_rtc',
    INITIATED_CALL: 'calling.initiated_call',
    INITIATED_VIDEO_CALL: 'calling.initiated_video_call',
    JOINED_CALL: 'calling.joined_call',
    JOINED_VIDEO_CALL: 'calling.joined_video_call',
    RECEIVED_CALL: 'calling.received_call',
    RECEIVED_VIDEO_CALL: 'calling.received_video_call',
    SHARED_SCREEN: 'calling.shared_screen',
  },
  CONTRIBUTED: 'contributed',
  CONVERSATION: {
    ADD_PARTICIPANTS: 'conversation.add_participants',
    GROUP_CREATION_SUCCEEDED: 'conversation.group_creation_succeeded',
    OPENED_GROUP_CREATION: 'conversation.opened_group_creation',
    OPENED_SELECT_PARTICIPANTS: 'conversation.opened_select_participants',
  },
  E2EE: {
    FAILED_MESSAGE_DECRYPTION: 'e2ee.failed_message_decryption',
  },
  GUEST_ROOMS: {
    ALLOW_GUESTS: 'guest_rooms.allow_guests',
    GUEST_ROOM_CREATION: 'guest_rooms.guest_room_creation',
    LINK_COPIED: 'guest_rooms.link_copied',
    LINK_CREATED: 'guest_rooms.link_created',
    LINK_REVOKED: 'guest_rooms.link_revoked',
  },
  HISTORY: {
    BACKUP_FAILED: 'history.backup_failed',
    BACKUP_SUCCEEDED: 'history.backup_succeeded',
    RESTORE_FAILED: 'history.restore_failed',
    RESTORE_SUCCEEDED: 'history.restore_succeeded',
  },
  INTEGRATION: {
    ADDED_SERVICE: 'integration.added_service',
    REMOVED_SERVICE: 'integration.removed_service',
  },
  SETTINGS: {
    CHANGED_STATUS: 'settings.changed_status',
    OPENED_MANAGE_TEAM: 'settings.opened_manage_team',
    OPTED_IN_TRACKING: 'settings.opted_in_tracking',
    OPTED_OUT_TRACKING: 'settings.opted_out_tracking',
  },
  TELEMETRY: {
    APP_INITIALIZATION: 'telemetry.app_initialization',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

z.tracking.EventTrackingRepository = class EventTrackingRepository {
  static get CONFIG() {
    return {
      ERROR_REPORTING: {
        API_KEY: window.wire.env.RAYGUN_API_KEY,
        REPORTING_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
      },
      USER_ANALYTICS: {
        API_KEY: window.wire.env.ANALYTICS_API_KEY,
        CLIENT_TYPE: 'desktop',
        DISABLED_DOMAINS: ['localhost', 'zinfra.io'],
        DISABLED_EVENTS: [
          z.tracking.EventName.CALLING.FAILED_REQUEST,
          z.tracking.EventName.CALLING.FAILED_REQUESTING_MEDIA,
          z.tracking.EventName.CALLING.FAILED_RTC,
          z.tracking.EventName.TELEMETRY.APP_INITIALIZATION,
        ],
      },
    };
  }

  /**
   * Construct a new repository for user actions and errors reporting.
   *
   * @param {z.team.TeamRepository} teamRepository - Repository that handles teams
   * @param {z.user.UserRepository} userRepository - Repository that handles users
   * @returns {EventTrackingRepository} The new repository for user actions
   */
  constructor(teamRepository, userRepository) {
    this.updatePrivacyPreference = this.updatePrivacyPreference.bind(this);

    this.logger = new z.util.Logger('z.tracking.EventTrackingRepository', z.config.LOGGER.OPTIONS);

    this.teamRepository = teamRepository;
    this.userRepository = userRepository;

    this.providerAPI = undefined;
    this.lastReportTimestamp = undefined;
    this.privacyPreference = undefined;

    this.isErrorReportingActivated = false;
    this.isUserAnalyticsActivated = false;
  }

  /**
   * Init the repository.
   * @param {boolean} privacyPreference - Privacy preference
   * @returns {Promise} Resolves after initialization
   */
  init(privacyPreference) {
    this.privacyPreference = privacyPreference;
    this.logger.info(`Initialize analytics and error reporting: ${this.privacyPreference}`);

    const privacyPromise = this.privacyPreference ? this._enableServices(false) : Promise.resolve();
    return privacyPromise.then(() => {
      amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.PRIVACY, this.updatePrivacyPreference);
    });
  }

  updatePrivacyPreference(privacyPreference) {
    const hasPreferenceChanged = privacyPreference !== this.privacyPreference;
    if (hasPreferenceChanged) {
      this.privacyPreference = privacyPreference;

      return this.privacyPreference ? this._enableServices(true) : this._disableServices();
    }
  }

  _enableServices(isOptIn = false) {
    this._enableErrorReporting();
    return this._isDomainAllowedForAnalytics()
      ? this._enableAnalytics().then(() => {
          if (isOptIn) {
            this._trackEvent(z.tracking.EventName.SETTINGS.OPTED_IN_TRACKING);
          }
        })
      : Promise.resolve();
  }

  _disableServices() {
    this._disableErrorReporting();
    this._trackEvent(z.tracking.EventName.SETTINGS.OPTED_OUT_TRACKING);
    this._disableAnalytics();
  }

  //##############################################################################
  // Analytics
  //##############################################################################

  _disableAnalytics() {
    this.logger.debug('Analytics was disabled due to user preferences');
    this.isUserAnalyticsActivated = false;

    this._unsubscribeFromAnalyticsEvents();

    if (this.providerAPI) {
      // Disable provider API
      this.providerAPI = undefined;
    }
  }

  _enableAnalytics() {
    this.isUserAnalyticsActivated = true;

    // Check if provider API is available and reuse if possible
    const providerPromise = this.providerAPI ? Promise.resolve(this.providerAPI) : this._initAnalytics();
    return providerPromise.then(providerInstance => {
      if (providerInstance) {
        this._setSuperProperties();
        this._subscribeToAnalyticsEvents();
      }
    });
  }

  _initAnalytics() {
    // Initialize provider API
    return Promise.resolve(this.providerAPI);
  }

  _isDomainAllowedForAnalytics() {
    const trackingParameter = z.util.URLUtil.getParameter(z.auth.URLParameter.TRACKING);
    return typeof trackingParameter === 'boolean'
      ? trackingParameter
      : !EventTrackingRepository.CONFIG.USER_ANALYTICS.DISABLED_DOMAINS.some(domain => {
          if (z.util.StringUtil.includes(window.location.hostname, domain)) {
            this.logger.debug(`Analytics is disabled for domain '${window.location.hostname}'`);
            return true;
          }
        });
  }

  _resetSuperProperties() {
    if (this.providerAPI) {
      // Reset super properties on provider API and forget distinct ids
    }
  }

  _subscribeToAnalyticsEvents() {
    amplify.subscribe(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, this, (...args) => {
      if (this.isUserAnalyticsActivated) {
        this._setSuperProperty(...args);
      }
    });

    amplify.subscribe(z.event.WebApp.ANALYTICS.EVENT, this, (...args) => {
      if (this.isUserAnalyticsActivated) {
        this._trackEvent(...args);
      }
    });

    amplify.subscribe(z.event.WebApp.LIFECYCLE.SIGNED_OUT, this._resetSuperProperties.bind(this));
  }

  _setSuperProperties() {
    this._setSuperProperty(z.tracking.SuperProperty.APP, EventTrackingRepository.CONFIG.USER_ANALYTICS.CLIENT_TYPE);
    this._setSuperProperty(z.tracking.SuperProperty.APP_VERSION, z.util.Environment.version(false));
    this._setSuperProperty(z.tracking.SuperProperty.DESKTOP_APP, z.tracking.helpers.getPlatform());
    if (z.util.Environment.desktop) {
      this._setSuperProperty(z.tracking.SuperProperty.WRAPPER_VERSION, z.util.Environment.version(true));
    }

    if (this.userRepository) {
      this._setSuperProperty(z.tracking.SuperProperty.CONTACTS, this.userRepository.number_of_contacts());
      this._setSuperProperty(z.tracking.SuperProperty.TEAM.IN_TEAM, this.teamRepository.isTeam());
      this._setSuperProperty(z.tracking.SuperProperty.TEAM.SIZE, this.teamRepository.teamSize());
    }
  }

  _setSuperProperty(superPropertyName, value) {
    // Set property on provider API
    this.logger.info(`Set super property '${superPropertyName}' to value '${value}'`);
  }

  _trackEvent(eventName, attributes) {
    const isDisabledEvent = EventTrackingRepository.CONFIG.USER_ANALYTICS.DISABLED_EVENTS.includes(eventName);
    if (isDisabledEvent) {
      this.logger.info(`Skipped sending disabled event of type '${eventName}'`);
    } else {
      const logAttributes = attributes ? `with attributes: ${JSON.stringify(attributes)}` : 'without attributes';
      this.logger.info(`Tracking event '${eventName}' ${logAttributes}`);

      // Send event if provider API available
    }
  }

  _unsubscribeFromAnalyticsEvents() {
    amplify.unsubscribeAll(z.event.WebApp.ANALYTICS.SUPER_PROPERTY);
    amplify.unsubscribeAll(z.event.WebApp.ANALYTICS.EVENT);
  }

  //##############################################################################
  // Error reporting
  //##############################################################################

  /**
   * Checks if a Raygun payload should be reported.
   *
   * @see https://github.com/MindscapeHQ/raygun4js#onbeforesend
   * @param {JSON} raygunPayload - Error payload about to be send
   * @returns {JSON|boolean} Payload if error will be reported, otherwise "false"
   */
  _checkErrorPayload(raygunPayload) {
    if (!this.lastReportTimestamp) {
      this.lastReportTimestamp = Date.now();
      return raygunPayload;
    }

    const timeSinceLastReport = Date.now() - this.lastReportTimestamp;
    if (timeSinceLastReport > EventTrackingRepository.CONFIG.ERROR_REPORTING.REPORTING_THRESHOLD) {
      this.lastReportTimestamp = Date.now();
      return raygunPayload;
    }

    return false;
  }

  _disableErrorReporting() {
    this.logger.debug('Disabling Raygun error reporting');
    this.isErrorReportingActivated = false;
    Raygun.detach();
    Raygun.init(EventTrackingRepository.CONFIG.ERROR_REPORTING.API_KEY, {disableErrorTracking: true});
  }

  _enableErrorReporting() {
    this.logger.debug('Enabling Raygun error reporting');
    this.isErrorReportingActivated = true;

    const options = {
      disableErrorTracking: false,
      excludedHostnames: ['localhost', 'wire.ms'],
      ignore3rdPartyErrors: true,
      ignoreAjaxAbort: true,
      ignoreAjaxError: true,
    };

    options.debugMode = !z.util.Environment.frontend.isProduction();

    Raygun.init(EventTrackingRepository.CONFIG.ERROR_REPORTING.API_KEY, options).attach();
    Raygun.disableAutoBreadcrumbs();

    /*
    Adding a version to the Raygun reports to identify which version of the Wire ran into the issue.
    @note We cannot use our own version string as it has to be in a certain format
    @see https://github.com/MindscapeHQ/raygun4js#version-filtering
    */
    if (!z.util.Environment.frontend.isLocalhost()) {
      Raygun.setVersion(z.util.Environment.version(false));
    }
    if (z.util.Environment.desktop) {
      Raygun.withCustomData({electron_version: z.util.Environment.version(true)});
    }
    Raygun.onBeforeSend(this._checkErrorPayload.bind(this));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

z.tracking.helpers = {
  /**
   * Get corresponding tracking attribute for conversation type.
   * @param {z.entity.Conversation} conversationEntity - Conversation to map type of
   * @returns {z.tracking.attribute.ConversationType} Mapped conversation type
   */
  getConversationType(conversationEntity) {
    if (conversationEntity instanceof z.entity.Conversation) {
      return conversationEntity.is1to1()
        ? z.tracking.attribute.ConversationType.ONE_TO_ONE
        : z.tracking.attribute.ConversationType.GROUP;
    }
  },

  getGuestAttributes(conversationEntity) {
    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      const isAllowGuests = !conversationEntity.isTeamOnly();
      const _getUserType = _conversationEntity => {
        if (_conversationEntity.selfUser().isTemporaryGuest()) {
          return z.tracking.attribute.UserType.TEMPORARY_GUEST;
        }

        return _conversationEntity.isGuest() ? z.tracking.attribute.UserType.GUEST : z.tracking.attribute.UserType.USER;
      };

      return {
        is_allow_guests: isAllowGuests,
        user_type: _getUserType(conversationEntity),
      };
    }

    return {
      is_allow_guests: false,
      user_type: z.tracking.attribute.UserType.USER,
    };
  },

  getParticipantTypes(userEntities, countSelf) {
    const initialValue = {guests: 0, temporaryGuests: 0, users: countSelf ? 1 : 0};
    return userEntities.reduce((accumulator, userEntity) => {
      if (userEntity.isTemporaryGuest()) {
        accumulator.temporaryGuests += 1;
      } else if (userEntity.isGuest()) {
        accumulator.guests += 1;
      } else {
        accumulator.users += 1;
      }

      return accumulator;
    }, initialValue);
  },

  /**
   * Get the platform identifier.
   * @returns {z.tracking.attribute.PlatformType} Mapped platform type
   */
  getPlatform() {
    if (!z.util.Environment.desktop) {
      return z.tracking.attribute.PlatformType.BROWSER_APP;
    }

    if (z.util.Environment.os.win) {
      return z.tracking.attribute.PlatformType.DESKTOP_WINDOWS;
    }
    return z.util.Environment.os.mac
      ? z.tracking.attribute.PlatformType.DESKTOP_MACOS
      : z.tracking.attribute.PlatformType.DESKTOP_LINUX;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.tracking = z.tracking || {};

/**
 * Enumeration of properties that should get send with every user tracking call.
 * @returns {z.tracking.SuperProperty} Super property identifier
 */
z.tracking.SuperProperty = {
  APP: 'app',
  APP_VERSION: 'App Version',
  CONTACTS: 'contacts',
  DESKTOP_APP: 'desktop_app',
  TEAM: {
    IN_TEAM: 'team.in_team',
    SIZE: 'team.size',
  },
  WRAPPER_VERSION: 'wrapper_version',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetUploadFailedReason = {
  CANCELLED: 0,
  FAILED: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetURLCache = (() => {
  const _lruCache = new LRUCache.LRUCache(100);

  const _getUrl = identifier => _lruCache.get(identifier);

  const _setUrl = (identifier, url) => {
    const isExistingUrl = _getUrl(identifier);

    if (isExistingUrl) {
      window.URL.revokeObjectURL(url);
      return isExistingUrl;
    }

    const outdatedUrl = _lruCache.set(identifier, url);

    if (outdatedUrl != null) {
      window.URL.revokeObjectURL(outdatedUrl);
    }

    return url;
  };

  return {
    getUrl: _getUrl,
    setUrl: _setUrl,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetRemoteData = class AssetRemoteData {
  /**
   * Use either z.assets.AssetRemoteData.v2 or z.assets.AssetRemoteData.v3 to initialize.
   * @param {Uint8Array} otrKey - Encryption key
   * @param {Uint8Array} sha256 - Checksum
   */
  constructor(otrKey, sha256) {
    this.otrKey = otrKey;
    this.sha256 = sha256;
    this.downloadProgress = ko.observable();
    this.cancelDownload = undefined;
    this.generateUrl = undefined;
    this.identifier = undefined;

    this.loadPromise = undefined;

    this.logger = new z.util.Logger('z.assets.AssetRemoteData', z.config.LOGGER.OPTIONS);
  }

  /**
   * Static initializer for v3 assets.
   *
   * @param {string} assetKey - ID to retrieve asset with
   * @param {Uint8Array} [otrKey] - Encryption key
   * @param {Uint8Array} [sha256] - Checksum
   * @param {string} [assetToken] - Token data
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V3 asset remote data
   */
  static v3(assetKey, otrKey, sha256, assetToken, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData(otrKey, sha256);
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrlV3(assetKey, assetToken, forceCaching);
    remoteData.identifier = `${assetKey}`;
    return remoteData;
  }

  /**
   * Static initializer for v2 assets.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} assetId - ID to retrieve asset with
   * @param {Uint8Array} otrKey - Encryption key
   * @param {Uint8Array} sha256 - Checksum
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V2 asset remote data
   */
  static v2(conversationId, assetId, otrKey, sha256, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData(otrKey, sha256);
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrlV2(assetId, conversationId, forceCaching);
    remoteData.identifier = `${conversationId}${assetId}`;
    return remoteData;
  }

  /**
   * Static initializer for v1 assets.
   *
   * @deprecated
   * @param {string} conversationId - ID of conversation
   * @param {string} assetId - ID to retrieve asset with
   * @param {boolean} [forceCaching=false] - Cache asset in ServiceWorker
   * @returns {z.assets.AssetRemoteData} V1 asset remote data
   */
  static v1(conversationId, assetId, forceCaching = false) {
    const remoteData = new z.assets.AssetRemoteData();
    remoteData.generateUrl = () => wire.app.service.asset.generateAssetUrl(assetId, conversationId, forceCaching);
    remoteData.identifier = `${conversationId}${assetId}`;
    return remoteData;
  }

  /**
   * Get object url for asset remote data. URLs are cached in memory.
   * @returns {Promise<string>} Object URL for asset
   */
  getObjectUrl() {
    const objectUrl = z.assets.AssetURLCache.getUrl(this.identifier);
    return objectUrl
      ? Promise.resolve(objectUrl)
      : this.load().then(blob => {
          if (blob) {
            const url = window.URL.createObjectURL(blob);
            return z.assets.AssetURLCache.setUrl(this.identifier, url);
          }
        });
  }

  /**
   * Loads and decrypts stored asset
   * @returns {Promise<Blob>} Resolves with the decrypted asset data
   */
  load() {
    let type;

    if (this.loadPromise) {
      return this.loadPromise;
    }

    this.loadPromise = this._loadBuffer()
      .then(({buffer, mimeType}) => {
        type = mimeType;
        this.loadPromise = undefined;
        const isEncryptedAsset = this.otrKey && this.sha256;
        return isEncryptedAsset
          ? z.assets.AssetCrypto.decryptAesAsset(buffer, this.otrKey.buffer, this.sha256.buffer)
          : buffer;
      })
      .then(plaintext => new Blob([new Uint8Array(plaintext)], {type}))
      .catch(error => {
        this.loadPromise = undefined;
        const errorMessage = (error && error.message) || '';
        const isAssetNotFound = errorMessage.endsWith(z.error.BackendClientError.STATUS_CODE.NOT_FOUND);
        const isServerError = errorMessage.endsWith(z.error.BackendClientError.STATUS_CODE.INTERNAL_SERVER_ERROR);

        const isExpectedError = isAssetNotFound || isServerError;
        if (!isExpectedError) {
          throw error;
        }
      });

    return this.loadPromise;
  }

  _loadBuffer() {
    return this.generateUrl()
      .then(generatedUrl => {
        return z.util.loadUrlBuffer(generatedUrl, xhr => {
          xhr.onprogress = event => this.downloadProgress(Math.round((event.loaded / event.total) * 100));
          this.cancelDownload = () => xhr.abort.call(xhr);
        });
      })
      .catch(error => {
        const isValidationUtilError = error instanceof z.util.ValidationUtilError;
        const message = isValidationUtilError
          ? `Failed to validate an asset URL (_load_buffer): ${error.message}`
          : `Failed to load asset: ${error.message || error}`;

        this.logger.error(message);

        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetRetentionPolicy = {
  ETERNAL: 'eternal',
  ETERNAL_INFREQUENT_ACCESS: 'eternal-infrequent_access',
  EXPIRING: 'expiring',
  PERSISTENT: 'persistent',
  VOLATILE: 'volatile',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetTransferState = {
  DOWNLOADING: 'downloading',
  UPLOAD_FAILED: 'upload-failed',
  UPLOADED: 'uploaded',
  UPLOADING: 'uploading',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetType = {
  FILE: 'File',
  IMAGE: 'Image',
  LOCATION: 'Location',
  TEXT: 'Text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

// AssetService for all asset handling and the calls to the backend REST API.
z.assets.AssetService = class AssetService {
  /**
   * Construct a new Asset Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.assets.AssetService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Update the user profile image by first making it usable, transforming it and then uploading the asset pair.
   * @param {File|Blob} image - Profile image
   * @returns {Promise} Resolves when profile image has been uploaded
   */
  uploadProfileImage(image) {
    return Promise.all([this._compressProfileImage(image), this._compressImage(image)])
      .then(([{compressedBytes: previewImageBytes}, {compressedBytes: mediumImageBytes}]) => {
        const assetUploadOptions = {public: true, retention: z.assets.AssetRetentionPolicy.ETERNAL};
        return Promise.all([
          this.postAsset(previewImageBytes, assetUploadOptions),
          this.postAsset(mediumImageBytes, assetUploadOptions),
        ]);
      })
      .then(([previewCredentials, mediumCredentials]) => {
        return {mediumImageKey: mediumCredentials.key, previewImageKey: previewCredentials.key};
      });
  }

  /**
   * Upload arbitrary binary data using the new asset api v3.
   * The data is AES encrypted before uploading.
   *
   * @param {Uint8Array} bytes - Asset binary data
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} [xhrAccessorFunction] - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  _uploadAsset(bytes, options, xhrAccessorFunction) {
    return z.assets.AssetCrypto.encryptAesAsset(bytes).then(({cipherText, keyBytes, sha256}) => {
      return this.postAsset(new Uint8Array(cipherText), options, xhrAccessorFunction).then(({key, token}) => ({
        key,
        keyBytes,
        sha256,
        token,
      }));
    });
  }

  /**
   * Upload file using the new asset api v3. Promise will resolve with z.proto.Asset instance.
   * In case of an successful upload the uploaded property is set.
   *
   * @param {Blob|File} file - File asset to be uploaded
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} xhrAccessorFunction - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  uploadAsset(file, options, xhrAccessorFunction) {
    return z.util
      .loadFileBuffer(file)
      .then(buffer => this._uploadAsset(buffer, options, xhrAccessorFunction))
      .then(({key, keyBytes, sha256, token}) => {
        const protoAsset = new z.proto.Asset();
        const assetRemoteData = new z.proto.Asset.RemoteData(keyBytes, sha256, key, token);

        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_UPLOADED, assetRemoteData);
        return protoAsset;
      });
  }

  /**
   * Upload image using the new asset api v3. Promise will resolve with z.proto.Asset instance.
   * In case of an successful upload the uploaded property is set.
   *
   * @param {Blob|File} image - Image asset to be uploaded
   * @param {Object} options - Asset upload options
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @returns {Promise} Resolves when asset has been uploaded
   */
  uploadImageAsset(image, options) {
    return this._compressImage(image).then(({compressedBytes, compressedImage}) => {
      return this._uploadAsset(compressedBytes, options).then(({key, keyBytes, sha256, token}) => {
        const protoAsset = new z.proto.Asset();

        const assetImageMetadata = new z.proto.Asset.ImageMetaData(compressedImage.width, compressedImage.height);
        const assetOriginal = new z.proto.Asset.Original(image.type, compressedBytes.length, null, assetImageMetadata);
        const assetRemoteData = new z.proto.Asset.RemoteData(keyBytes, sha256, key, token);

        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_ORIGINAL, assetOriginal);
        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_UPLOADED, assetRemoteData);
        return protoAsset;
      });
    });
  }

  /**
   * Generates the URL an asset can be downloaded from.
   *
   * @deprecated
   * @param {string} assetId - ID of asset
   * @param {string} conversationId - Conversation ID
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v1 asset
   */
  generateAssetUrl(assetId, conversationId, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.legacy(assetId, conversationId);
      const url = this.backendClient.createUrl(`/assets/${assetId}`);
      const cachingParam = forceCaching ? '&forceCaching=true' : '';
      const conversationIdParam = `&conv_id=${window.encodeURIComponent(conversationId)}`;

      return `${url}?access_token=${this.backendClient.accessToken}${conversationIdParam}${cachingParam}`;
    });
  }

  /**
   * Generates the URL for asset api v2.
   *
   * @deprecated
   * @param {string} assetId - ID of asset
   * @param {string} conversationId - Conversation ID
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v2 asset
   */
  generateAssetUrlV2(assetId, conversationId, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.legacy(assetId, conversationId);
      const url = this.backendClient.createUrl(`/conversations/${conversationId}/otr/assets/${assetId}`);
      const cachingParam = forceCaching ? '&forceCaching=true' : '';

      return `${url}?access_token=${this.backendClient.accessToken}${cachingParam}`;
    });
  }

  /**
   * Generates the URL for asset api v3.
   *
   * @param {string} assetKey - ID of asset
   * @param {string} assetToken - Asset token
   * @param {boolean} forceCaching - Cache asset in ServiceWorker
   * @returns {Promise} Resolves with URL of v3 asset
   */
  generateAssetUrlV3(assetKey, assetToken, forceCaching) {
    return Promise.resolve().then(() => {
      z.util.ValidationUtil.asset.v3(assetKey, assetToken);
      const url = `${this.backendClient.createUrl(`/assets/v3/${assetKey}`)}`;
      const assetTokenParam = assetToken ? `&asset_token=${window.encodeURIComponent(assetToken)}` : '';
      const cachingParam = forceCaching ? '&forceCaching=true' : '';

      return `${url}?access_token=${this.backendClient.accessToken}${assetTokenParam}${cachingParam}`;
    });
  }

  getAssetRetention(userEntity, conversationEntity) {
    const isTeamMember = userEntity.inTeam();
    const isTeamConversation = conversationEntity.inTeam();
    const isTeamUserInConversation = conversationEntity
      .participating_user_ets()
      .some(conversationParticipant => conversationParticipant.inTeam());

    const isEternal = isTeamMember || isTeamConversation || isTeamUserInConversation;
    return isEternal ? z.assets.AssetRetentionPolicy.ETERNAL : z.assets.AssetRetentionPolicy.PERSISTENT;
  }

  /**
   * Post assets.
   *
   * @param {Uint8Array} assetData - Asset data
   * @param {Object} options - Asset metadata
   * @param {boolean} options.public - Flag whether asset is public
   * @param {z.assets.AssetRetentionPolicy} options.retention - Retention duration policy for asset
   * @param {Function} [xhrAccessorFunction] - Function will get a reference to the underlying XMLHTTPRequest
   * @returns {Promise} Resolves when asset has been uploaded
   */
  postAsset(assetData, options, xhrAccessorFunction) {
    return new Promise((resolve, reject) => {
      const BOUNDARY = 'frontier';

      options = Object.assign(
        {
          public: false,
          retention: z.assets.AssetRetentionPolicy.PERSISTENT,
        },
        options
      );

      options = JSON.stringify(options);

      let body = '';
      body += `--${BOUNDARY}\r\n`;
      body += 'Content-Type: application/json; charset=utf-8\r\n';
      body += `Content-length: ${options.length}\r\n`;
      body += '\r\n';
      body += `${options}\r\n`;
      body += `--${BOUNDARY}\r\n`;
      body += 'Content-Type: application/octet-stream\r\n';
      body += `Content-length: ${assetData.length}\r\n`;
      body += `Content-MD5: ${z.util.arrayToMd5Base64(assetData)}\r\n`;
      body += '\r\n';
      const footer = `\r\n--${BOUNDARY}--\r\n`;

      const xhr = new XMLHttpRequest();
      xhr.open('POST', this.backendClient.createUrl('/assets/v3'));
      xhr.setRequestHeader('Content-Type', `multipart/mixed; boundary=${BOUNDARY}`);
      xhr.setRequestHeader('Authorization', `${this.backendClient.accessTokenType} ${this.backendClient.accessToken}`);
      xhr.onload = function(event) {
        return this.status === 201 ? resolve(JSON.parse(this.response)) : reject(event);
      };
      xhr.onerror = reject;

      if (typeof xhrAccessorFunction === 'function') {
        xhrAccessorFunction(xhr);
      }

      xhr.send(new Blob([body, assetData, footer]));
    });
  }

  /**
   * Compress image.
   * @param {File|Blob} image - Image to be compressed in ServiceWorker
   * @returns {Promise} Resolves with the compressed imaged
   */
  _compressImage(image) {
    return this._compressImageWithWorker('worker/image-worker.js', image, () => image.type === 'image/gif');
  }

  /**
   * Compress profile image.
   * @param {File|Blob} image - Profile image to be compressed in ServiceWorker
   * @returns {Promise} Resolves with the compressed profile imaged
   */
  _compressProfileImage(image) {
    return this._compressImageWithWorker('worker/profile-image-worker.js', image);
  }

  /**
   * Compress image using given worker.
   * @param {string} worker - Path to worker file
   * @param {File|Blob} image - Image to be compressed in ServiceWorker
   * @param {Function} filter - Optional filter to be applied
   * @returns {Promise} Resolves with the compressed image
   */
  _compressImageWithWorker(worker, image, filter) {
    return z.util
      .loadFileBuffer(image)
      .then(buffer => {
        if (typeof filter === 'function' ? filter() : undefined) {
          return new Uint8Array(buffer);
        }
        return new z.util.Worker(worker).post(buffer);
      })
      .then(compressedBytes => {
        return z.util
          .loadImage(new Blob([compressedBytes], {type: image.type}))
          .then(compressedImage => ({compressedBytes, compressedImage}));
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetMapper = {
  /**
   * Creates asset entities out of raw asset data.
   *
   * @param {string} userId - the id of the user that will hold the asset
   * @param {Array<Object>} assets - the assets to map
   * @returns {MappedAssets} Object containing the mapped assets
   */
  mapProfileAssets: (userId, assets) => {
    const sizeMap = {
      complete: 'medium',
      preview: 'preview',
    };

    return assets
      .filter(asset => asset.type === 'image')
      .reduce((mappedAssets, asset) => {
        const assetRemoteData = z.assets.AssetRemoteData.v3(asset.key, true);

        return !sizeMap[asset.size]
          ? mappedAssets
          : Object.assign({}, mappedAssets, {[sizeMap[asset.size]]: assetRemoteData});
      }, {});
  },

  /**
   * Creates asset entities out of raw asset data.
   *
   * @param {string} userId - the id of the user that will hold the asset
   * @param {Array<Object>} pictures - the pictures to map
   * @returns {MappedAssets} Object containing the mapped assets
   */
  mapProfileAssetsV1: (userId, pictures) => {
    const [previewPicture, mediumPicture] = pictures;
    const previewAsset = previewPicture ? z.assets.AssetRemoteData.v1(userId, previewPicture.id, true) : undefined;
    const mediumAsset = mediumPicture ? z.assets.AssetRemoteData.v1(userId, mediumPicture.id, true) : undefined;

    return {medium: mediumAsset, preview: previewAsset};
  },

  /**
   * Updates the user entity's assets.
   *
   * @param {z.entity.User} userEntity - the user entity to update
   * @param {MappedAssets} mappedAssets - the assets to add to the user entity
   * @returns {void}
   */
  updateUserEntityAssets(userEntity, mappedAssets = {}) {
    const {preview, medium} = mappedAssets;
    if (preview) {
      userEntity.previewPictureResource(preview);
    }
    if (medium) {
      userEntity.mediumPictureResource(medium);
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

// Builder for creating all kinds of asset metadata
z.assets.AssetMetaDataBuilder = (() => {
  /**
   * Constructs corresponding asset metadata depending on the given file type
   * @param {File|Blob} file - the file to generate metadata for
   * @returns {Promise} Resolves with ImageMetaData, VideoMetaData or AudioMetaData
   */
  const _buildMetadata = file => {
    if (!(file instanceof Blob)) {
      throw new Error('Expected file to be type of Blob');
    }

    if (_isVideo(file)) {
      return _buildMetadataVideo(file);
    }
    if (_isAudio(file)) {
      return _buildMetadataAudio(file);
    }
    if (_isImage(file)) {
      return _buildMetadataImage(file);
    }
    return Promise.resolve();
  };

  const _buildMetadataAudio = audioFile => {
    return z.util
      .loadFileBuffer(audioFile)
      .then(buffer => {
        const audioContext = new AudioContext();
        audioContext.close();
        return audioContext.decodeAudioData(buffer);
      })
      .then(audioBuffer => {
        const durationInMillis = audioBuffer.duration * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        return new z.proto.Asset.AudioMetaData(durationInMillis, _normaliseLoudness(audioBuffer));
      });
  };

  const _buildMetadataImage = imageFile => {
    return new Promise((resolve, reject) => {
      const url = window.URL.createObjectURL(imageFile);
      const image = new Image();
      image.onload = () => {
        resolve(new z.proto.Asset.ImageMetaData(image.width, image.height));
        window.URL.revokeObjectURL(url);
      };
      image.onerror = error => {
        reject(error);
        window.URL.revokeObjectURL(url);
      };
      image.src = url;
    });
  };

  const _buildMetadataVideo = videoFile => {
    return new Promise((resolve, reject) => {
      const url = window.URL.createObjectURL(videoFile);
      const video = document.createElement('video');
      video.onloadedmetadata = () => {
        resolve(new z.proto.Asset.VideoMetaData(video.videoWidth, video.videoHeight, video.duration));
        window.URL.revokeObjectURL(url);
      };
      video.addEventListener(
        'error',
        error => {
          reject(_convertEventToError(error));
          window.URL.revokeObjectURL(url);
        },
        true
      );
      video.src = url;
    });
  };

  /**
   * Convert an error event into a plain error object.
   * This needs to be done because error events are not standardized between browser implementations.
   * @private
   * @param {Event} event - Error event
   * @returns {MediaError} Error object
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/originalTarget
   */
  const _convertEventToError = event => {
    let error = event;

    // Chrome v60
    if (event.path && event.path[0]) {
      error = event.path[0].error;
    }

    // Firefox v55
    if (event.originalTarget) {
      error = error.originalTarget.error;
    }

    return error;
  };

  const _isAudio = file => {
    return file && file.type.startsWith('audio');
  };

  const _isImage = file => {
    return file && file.type.startsWith('image');
  };

  const _isVideo = file => {
    return file && file.type.startsWith('video');
  };

  const _normaliseLoudness = audioBuffer => {
    const MAX_SAMPLES = 200;
    const AMPLIFIER = 700; // in favour of iterating all samples before we interpolate them
    const channel = audioBuffer.getChannelData(0);
    const bucketSize = parseInt(channel.length / MAX_SAMPLES);
    const buckets = z.util.ArrayUtil.chunk(channel, bucketSize);

    const audioPreview = buckets.map(bucket => {
      return z.util.NumberUtil.capToByte(AMPLIFIER * z.util.NumberUtil.rootMeanSquare(bucket));
    });

    return new Uint8Array(audioPreview);
  };

  return {
    buildMetadata: _buildMetadata,
    isAudio: _isAudio,
    isImage: _isImage,
    isVideo: _isVideo,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.assets = z.assets || {};

z.assets.AssetCrypto = (() => {
  /**
   * @param {ArrayBuffer} cipherText - Encrypted plaintext
   * @param {ArrayBuffer} keyBytes - AES key used for encryption
   * @param {ArrayBuffer} referenceSha256 - SHA-256 checksum of the cipherText
   * @returns {Promise} Resolves with the decrypted asset
   */
  const _decryptAesAsset = (cipherText, keyBytes, referenceSha256) => {
    return window.crypto.subtle
      .digest('SHA-256', cipherText)
      .then(computedSha256 => {
        if (_equalHashes(referenceSha256, computedSha256)) {
          return window.crypto.subtle.importKey('raw', keyBytes, 'AES-CBC', false, ['decrypt']);
        }

        throw new Error('Encrypted asset does not match its SHA-256 hash');
      })
      .then(key => {
        const iv = cipherText.slice(0, 16);
        const assetCipherText = cipherText.slice(16);
        return window.crypto.subtle.decrypt({iv: iv, name: 'AES-CBC'}, key, assetCipherText);
      });
  };

  /**
   * @param {ArrayBuffer} plaintext - Plaintext asset to be encrypted
   * @returns {Promise} Resolves with the encrypted asset
   */
  const _encryptAesAsset = plaintext => {
    const iv = _generateRandomBytes(16);
    const rawKeyBytes = _generateRandomBytes(32);
    let key = null;
    let ivCipherText = null;
    let computedSha256 = null;

    return window.crypto.subtle
      .importKey('raw', rawKeyBytes.buffer, 'AES-CBC', true, ['encrypt'])
      .then(ckey => {
        key = ckey;

        return window.crypto.subtle.encrypt({iv: iv.buffer, name: 'AES-CBC'}, key, plaintext);
      })
      .then(cipherText => {
        ivCipherText = new Uint8Array(cipherText.byteLength + iv.byteLength);
        ivCipherText.set(iv, 0);
        ivCipherText.set(new Uint8Array(cipherText), iv.byteLength);

        return window.crypto.subtle.digest('SHA-256', ivCipherText);
      })
      .then(digest => {
        computedSha256 = digest;

        return window.crypto.subtle.exportKey('raw', key);
      })
      .then(keyBytes => ({cipherText: ivCipherText.buffer, keyBytes: keyBytes, sha256: computedSha256}));
  };

  const _equalHashes = (bufferA, bufferB) => {
    const arrayA = new Uint32Array(bufferA);
    const arrayB = new Uint32Array(bufferB);
    return arrayA.length === arrayB.length && arrayA.every((value, index) => value === arrayB[index]);
  };

  const _generateRandomBytes = length => {
    const getRandomValue = () => {
      const buffer = new Uint32Array(1);
      window.crypto.getRandomValues(buffer);
      return buffer[0] >>> 0;
    };

    const randomValues = new Uint32Array(length / 4).map(getRandomValue);
    const randomBytes = new Uint8Array(randomValues.buffer);
    if (randomBytes.length && !randomBytes.every(byte => byte === 0)) {
      return randomBytes;
    }
    throw Error('Failed to initialize iv with random values');
  };

  return {
    decryptAesAsset: _decryptAesAsset,
    encryptAesAsset: _encryptAesAsset,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

window.z = window.z || {};
window.z.backup = z.backup || {};

(module => {
  class ExportError extends Error {
    constructor(message = 'Something went wrong.') {
      super(message);
      Object.setPrototypeOf(this, ExportError.prototype);
    }
  }

  class CancelError extends Error {
    constructor(message = 'Action was cancelled') {
      super(message);
      Object.setPrototypeOf(this, CancelError.prototype);
    }
  }

  class ImportError extends Error {
    constructor(message = 'Something went wrong.') {
      super(message);
      Object.setPrototypeOf(this, ImportError.prototype);
    }
  }

  class InvalidMetaDataError extends ImportError {
    constructor(message = 'Meta data file is corrupt or missing properties.') {
      super(message);
      Object.setPrototypeOf(this, InvalidMetaDataError.prototype);
    }
  }

  class DifferentAccountError extends ImportError {
    constructor(message = 'You cannot restore history from a different account.') {
      super(message);
      Object.setPrototypeOf(this, DifferentAccountError.prototype);
    }
  }

  class IncompatibleBackupError extends ImportError {
    constructor(message = 'Backup created by incompatible database version') {
      super(message);
      Object.setPrototypeOf(this, IncompatibleBackupError.prototype);
    }
  }

  class IncompatiblePlatformError extends ImportError {
    constructor(message = 'Backup created by incompatible platform') {
      super(message);
      Object.setPrototypeOf(this, IncompatiblePlatformError.prototype);
    }
  }

  module.CancelError = CancelError;
  module.DifferentAccountError = DifferentAccountError;
  module.ExportError = ExportError;
  module.ImportError = ImportError;
  module.IncompatibleBackupError = IncompatibleBackupError;
  module.IncompatiblePlatformError = IncompatiblePlatformError;
  module.InvalidMetaDataError = InvalidMetaDataError;
})(z.backup);

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.backup = z.backup || {};

z.backup.BackupRepository = class BackupRepository {
  static get CONFIG() {
    return {
      FILENAME: {
        CONVERSATIONS: 'conversations.json',
        EVENTS: 'events.json',
        METADATA: 'export.json',
      },
      UINT8ARRAY_FIELDS: ['otr_key', 'sha256'],
    };
  }

  /**
   * Construct a new Backup repository.
   * @class z.backup.BackupRepository
   * @param {z.backup.BackupService} backupService - Backup service implementation
   * @param {z.client.ClientRepository} clientRepository - Repository for all client interactions
   * @param {z.connection.ConnectionRepository} connectionRepository - Repository for all connection interactions
   * @param {z.conversation.ConversationRepository} conversationRepository - Repository for all conversation interactions
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(backupService, clientRepository, connectionRepository, conversationRepository, userRepository) {
    this.logger = new z.util.Logger('z.backup.BackupRepository', z.config.LOGGER.OPTIONS);

    this.backupService = backupService;
    this.clientRepository = clientRepository;
    this.connectionRepository = connectionRepository;
    this.conversationRepository = conversationRepository;
    this.userRepository = userRepository;

    this.canceled = false;

    this.CONVERSATIONS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS;
    this.EVENTS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  cancelAction() {
    this.isCanceled = true;
  }

  get isCanceled() {
    return this.canceled;
  }

  set isCanceled(isCanceled) {
    this.canceled = isCanceled;
  }

  createMetaData() {
    return {
      client_id: this.clientRepository.currentClient().id,
      creation_time: new Date().toISOString(),
      platform: 'Web',
      user_id: this.userRepository.self().id,
      version: this.backupService.getDatabaseVersion(),
    };
  }

  /**
   * Gather needed data for the export and generates the history
   *
   * @param {function} progressCallback - called on every step of the export
   * @returns {Promise<JSZip>} The promise that contains all the exported tables
   */
  generateHistory(progressCallback) {
    this.isCanceled = false;

    return Promise.resolve()
      .then(() => this._exportHistory(progressCallback))
      .then(exportedData => this._compressHistoryFiles(exportedData))
      .catch(error => {
        this.logger.error(`Could not export history: ${error.message}`, error);

        const isCancelError = error instanceof z.backup.CancelError;
        throw isCancelError ? error : new z.backup.ExportError();
      });
  }

  _exportHistory(progressCallback) {
    const tables = this.backupService.getTables();
    const tableData = {};

    return Promise.resolve()
      .then(() => this._exportHistoryConversations(tables, progressCallback))
      .then(conversationsData => {
        tableData[this.CONVERSATIONS_STORE_NAME] = conversationsData;
        return this._exportHistoryEvents(tables, progressCallback);
      })
      .then(eventsData => {
        tableData[this.EVENTS_STORE_NAME] = eventsData;
        return tableData;
      });
  }

  _exportHistoryConversations(tables, progressCallback) {
    const conversationsTable = tables.find(table => table.name === this.CONVERSATIONS_STORE_NAME);
    const onProgress = (tableRows, exportedEntitiesCount) => {
      progressCallback(tableRows.length);
      this.logger.log(`Exported '${exportedEntitiesCount}' conversation states from history`);

      tableRows.forEach(conversation => delete conversation.verification_state);
    };

    return this._exportHistoryFromTable(conversationsTable, onProgress);
  }

  _exportHistoryEvents(tables, progressCallback) {
    const eventsTable = tables.find(table => table.name === this.EVENTS_STORE_NAME);
    const onProgress = (tableRows, exportedEntitiesCount) => {
      progressCallback(tableRows.length);
      this.logger.log(`Exported '${exportedEntitiesCount}' events from history`);

      for (let index = tableRows.length - 1; index >= 0; index -= 1) {
        const event = tableRows[index];
        const isTypeVerification = event.type === z.event.Client.CONVERSATION.VERIFICATION;
        if (isTypeVerification) {
          tableRows.splice(index, 1);
        }
      }
    };

    return this._exportHistoryFromTable(eventsTable, onProgress);
  }

  _exportHistoryFromTable(table, onProgress) {
    const tableData = [];
    let exportedEntitiesCount = 0;

    return this.backupService
      .exportTable(table, tableRows => {
        if (this.isCanceled) {
          throw new z.backup.CancelError();
        }
        exportedEntitiesCount += tableRows.length;

        onProgress(tableRows, exportedEntitiesCount);
        tableData.push(tableRows);
      })
      .then(() => [].concat(...tableData));
  }

  _compressHistoryFiles(exportedData) {
    const metaData = this.createMetaData();
    const zip = new JSZip();

    // first write the metadata file
    zip.file(BackupRepository.CONFIG.FILENAME.METADATA, JSON.stringify(metaData));

    // then all the other tables
    Object.keys(exportedData).forEach(tableName => {
      zip.file(`${tableName}.json`, JSON.stringify(exportedData[tableName]));
    });

    return zip;
  }

  getBackupInitData() {
    return this.backupService.getHistoryCount();
  }

  importHistory(archive, initCallback, progressCallback) {
    this.isCanceled = false;
    const files = archive.files;
    if (!files[BackupRepository.CONFIG.FILENAME.METADATA]) {
      throw new z.backup.InvalidMetaDataError();
    }

    return this.verifyMetadata(files)
      .then(() => this._extractHistoryFiles(files))
      .then(fileDescriptors => this._importHistoryData(fileDescriptors, initCallback, progressCallback))
      .catch(error => {
        this.logger.error(`Could not export history: ${error.message}`, error);
        throw error;
      });
  }

  _importHistoryData(fileDescriptors, initCallback, progressCallback) {
    const conversationFileDescriptor = fileDescriptors.find(fileDescriptor => {
      return fileDescriptor.filename === BackupRepository.CONFIG.FILENAME.CONVERSATIONS;
    });

    const eventFileDescriptor = fileDescriptors.find(fileDescriptor => {
      return fileDescriptor.filename === BackupRepository.CONFIG.FILENAME.EVENTS;
    });

    const conversationEntities = JSON.parse(conversationFileDescriptor.content);
    const eventEntities = JSON.parse(eventFileDescriptor.content);
    const entityCount = conversationEntities.length + eventEntities.length;
    initCallback(entityCount);

    return this._importHistoryConversations(conversationEntities, progressCallback)
      .then(importedEntities => this._importHistoryEvents(eventEntities, progressCallback).then(() => importedEntities))
      .then(importedEntities => {
        this.conversationRepository.updateConversations(importedEntities);
        this.conversationRepository.map_connections(this.connectionRepository.connectionEntities());
      });
  }

  _importHistoryConversations(conversationEntities, progressCallback) {
    const entityCount = conversationEntities.length;
    let importedEntities = [];

    const entityChunks = z.util.ArrayUtil.chunk(conversationEntities, z.backup.BackupService.CONFIG.BATCH_SIZE);

    const importConversationChunk = chunk =>
      this.conversationRepository.updateConversationStates(chunk).then(importedConversationEntities => {
        importedEntities = importedEntities.concat(importedConversationEntities);
        this.logger.log(`Imported '${importedEntities.length}' of '${entityCount}' conversation states from backup`);
        progressCallback(chunk.length);
      });

    return this._chunkImport(importConversationChunk, entityChunks).then(() => importedEntities);
  }

  _importHistoryEvents(eventEntities, progressCallback) {
    const entityCount = eventEntities.length;
    let importedEntities = 0;

    const entities = eventEntities.map(entity => this.mapEntityDataType(entity));
    const entityChunks = z.util.ArrayUtil.chunk(entities, z.backup.BackupService.CONFIG.BATCH_SIZE);

    const importEventChunk = chunk =>
      this.backupService.importEntities(this.EVENTS_STORE_NAME, chunk).then(() => {
        importedEntities += chunk.length;
        this.logger.log(`Imported '${importedEntities}' of '${entityCount}' events from backup`);
        progressCallback(chunk.length);
      });

    return this._chunkImport(importEventChunk, entityChunks);
  }

  _chunkImport(importFunction, chunks) {
    return chunks.reduce((promise, chunk) => {
      return promise.then(result => {
        if (this.isCanceled) {
          return Promise.reject(new z.backup.CancelError());
        }
        return importFunction(chunk);
      });
    }, Promise.resolve());
  }

  _extractHistoryFiles(files) {
    const unzipPromises = Object.values(files)
      .filter(zippedFile => zippedFile.name !== BackupRepository.CONFIG.FILENAME.METADATA)
      .map(zippedFile => zippedFile.async('string').then(value => ({content: value, filename: zippedFile.name})));

    return Promise.all(unzipPromises).then(fileDescriptors => {
      this.logger.log('Unzipped files for history import', fileDescriptors);
      return fileDescriptors;
    });
  }

  mapEntityDataType(entity) {
    if (entity.data) {
      BackupRepository.CONFIG.UINT8ARRAY_FIELDS.forEach(field => {
        const dataField = entity.data[field];
        if (dataField) {
          entity.data[field] = new Uint8Array(Object.values(dataField));
        }
      });
    }
    return entity;
  }

  verifyMetadata(files) {
    return files[BackupRepository.CONFIG.FILENAME.METADATA]
      .async('string')
      .then(JSON.parse)
      .then(metadata => this._verifyMetadata(metadata))
      .then(() => this.logger.log('Validated metadata during history import', files));
  }

  _verifyMetadata(archiveMetadata) {
    const localMetadata = this.createMetaData();
    const isExpectedUserId = archiveMetadata.user_id === localMetadata.user_id;
    if (!isExpectedUserId) {
      const fromUserId = archiveMetadata.user_id;
      const toUserId = localMetadata.user_id;
      const message = `History from user "${fromUserId}" cannot be restored for user "${toUserId}".`;
      throw new z.backup.DifferentAccountError(message);
    }

    const isExpectedPlatform = archiveMetadata.platform === localMetadata.platform;
    if (!isExpectedPlatform) {
      const message = `History created from "${archiveMetadata.platform}" device cannot be imported`;
      throw new z.backup.IncompatiblePlatformError(message);
    }

    const isExpectedVersion = archiveMetadata.version === localMetadata.version;
    if (!isExpectedVersion) {
      const message = `History cannot be restored: Database version mismatch`;
      throw new z.backup.IncompatibleBackupError(message);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.backup = z.backup || {};

z.backup.BackupService = class BackupService {
  static get CONFIG() {
    return {
      BATCH_SIZE: 10000,
      SUPPORTED_TABLES: [
        z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS,
        z.storage.StorageSchemata.OBJECT_STORE.EVENTS,
      ],
    };
  }

  constructor(storageService) {
    this.logger = new z.util.Logger('z.backup.BackupService', z.config.LOGGER.OPTIONS);
    this.storageService = storageService;

    this.EVENTS_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  exportTable(table, onProgress) {
    const collection = table.toCollection();
    return table
      .count()
      .then(count => new DexieBatch({batchSize: BackupService.CONFIG.BATCH_SIZE, limit: count}))
      .then(batchDriver => batchDriver.eachBatch(collection, batch => onProgress(batch)))
      .then(count => this.logger.log(`Exported store '${table.name}' in '${count}' batches`));
  }

  getDatabaseVersion() {
    return this.storageService.db.verno;
  }

  getHistoryCount() {
    return Promise.all(this.getTables().map(table => table.count())).then(recordsPerTable => {
      return recordsPerTable.reduce((accumulator, recordCount) => accumulator + recordCount, 0);
    });
  }

  getTables() {
    return this.storageService.getTables(BackupService.CONFIG.SUPPORTED_TABLES);
  }

  importEntities(tableName, entities) {
    // We don't want to set the primaryKey for the events table
    const isEventsTable = tableName === this.EVENTS_STORE_NAME;
    const primaryKeys = isEventsTable ? undefined : entities.map(entity => entity.id);
    return this.storageService.db[tableName].bulkPut(entities, primaryKeys);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.broadcast = z.broadcast || {};

// Broadcast repository for all broadcast interactions with the broadcast service
z.broadcast.BroadcastRepository = class BroadcastRepository {
  /**
   * Construct a new Broadcast Repository.
   *
   * @param {BroadcastService} broadcastService - Backend REST API broadcast service implementation
   * @param {ClientRepository} clientRepository - Repository for client interactions
   * @param {ConversationRepository} conversationRepository - Repository for conversation interactions
   * @param {CryptographyRepository} cryptographyRepository - Repository for all cryptography interactions
   * @param {UserRepository} userRepository - Repository for all user interactions
   */
  constructor(broadcastService, clientRepository, conversationRepository, cryptographyRepository, userRepository) {
    this.broadcastService = broadcastService;
    this.clientRepository = clientRepository;
    this.conversationRepository = conversationRepository;
    this.cryptographyRepository = cryptographyRepository;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.broadcast.BroadcastRepository', z.config.LOGGER.OPTIONS);

    this.clientMismatchHandler = this.conversationRepository.clientMismatchHandler;

    amplify.subscribe(z.event.WebApp.BROADCAST.SEND_MESSAGE, this.broadcastGenericMessage.bind(this));
  }

  broadcastGenericMessage(genericMessage) {
    return this.conversationRepository.sending_queue.push(() => {
      return this._createBroadcastRecipients()
        .then(recipients => this.cryptographyRepository.encryptGenericMessage(recipients, genericMessage))
        .then(payload => {
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage);
          this._sendEncryptedMessage(eventInfoEntity, payload);
        });
    });
  }

  /**
   * Create a user client map for a broadcast message.
   * @private
   * @returns {Promise} Resolves with a user client map
   */
  _createBroadcastRecipients() {
    return Promise.resolve().then(() => {
      const recipients = {};

      for (const userEntity of this.userRepository.teamUsers().concat(this.userRepository.self())) {
        recipients[userEntity.id] = userEntity.devices().map(clientEntity => clientEntity.id);
      }

      return recipients;
    });
  }

  /**
   * Broadcasts an otr message.
   *
   * @private
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event to be broadcasted
   * @param {Object} payload - Payload
   * @returns {Promise} Promise that resolves after sending the encrypted message
   */
  _sendEncryptedMessage(eventInfoEntity, payload) {
    const messageType = eventInfoEntity.getType();
    this.logger.info(`Sending '${messageType}' message as broadcast`, payload);

    const options = eventInfoEntity.options;
    return this.broadcastService
      .postBroadcastMessage(payload, options.precondition)
      .then(response => {
        this.clientMismatchHandler.onClientMismatch(eventInfoEntity, response, payload);
        return response;
      })
      .catch(error => {
        const isUnknownClient = error.label === z.error.BackendClientError.LABEL.UNKNOWN_CLIENT;
        if (isUnknownClient) {
          this.clientRepository.removeLocalClient();
        }

        if (!error.missing) {
          throw error;
        }

        return this.clientMismatchHandler.onClientMismatch(eventInfoEntity, error, payload).then(updatedPayload => {
          this.logger.info(`Updated '${messageType}' message as broadcast`, updatedPayload);
          eventInfoEntity.forceSending();
          return this._sendEncryptedMessage(eventInfoEntity, updatedPayload);
        });
      });
  }

  _getNumberOfClients() {
    return this.userRepository.teamUsers().reduce((accumulator, userEntity) => {
      if (userEntity.devices().length) {
        return accumulator + userEntity.devices().length;
      }
      return accumulator + z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
    }, this.userRepository.self().devices().length);
  }

  /**
   * Estimate whether message should be send as type external.
   *
   * @private
   * @param {z.proto.GenericMessage} genericMessage - Generic message that will be send
   * @returns {boolean} Is payload likely to be too big so that we switch to type external?
   */
  _shouldSendAsExternal(genericMessage) {
    const messageInBytes = new Uint8Array(genericMessage.toArrayBuffer()).length;
    const estimatedPayloadInBytes = this._getNumberOfClients() * messageInBytes;

    return estimatedPayloadInBytes > z.conversation.ConversationRepository.CONFIG.EXTERNAL_MESSAGE_THRESHOLD;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.broadcast = z.broadcast || {};

// Broadcast service for all broadcast calls to the backend REST API.
z.broadcast.BroadcastService = class BroadcastService {
  static get CONFIG() {
    return {
      URL_BROADCAST: '/broadcast',
    };
  }

  /**
   * Construct a new Broadcast Service.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.broadcast.BroadcastService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Post an encrypted message to broadcast it.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrBroadcast
   *
   * @param {Object} payload - Payload to be posted
   * @param {Object} payload.recipients - Map with per-recipient data
   * @param {string} payload.sender - Client ID of the sender
   * @param {Array<string>|boolean} preconditionOption - Level that backend checks for missing clients
   * @returns {Promise} Promise that resolve when the message was sent
   */
  postBroadcastMessage(payload, preconditionOption) {
    let url = `${BroadcastService.CONFIG.URL_BROADCAST}/otr/messages`;
    if (_.isArray(preconditionOption)) {
      url = `${url}?report_missing=${preconditionOption.join(',')}`;
    } else if (preconditionOption) {
      url = `${url}?ignore_missing=true`;
    }

    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: url,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cache = z.cache || {};

/**
 * Cache repository for local storage interactions using amplify.
 *
 * @todo We have to come up with a smart solution to handle "amplify.store quota exceeded"
 *  This happened when doing "@cache_repository.set_entity user_et"
 *
 */
z.cache.CacheRepository = class CacheRepository {
  constructor() {
    this.logger = new z.util.Logger('z.auth.CacheRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Deletes cached data.
   *
   * @param {boolean} [keepConversationInput=false] - Should conversation input be kept
   * @param {Array<string>} [protectedKeyPatterns=[z.storage.StorageKey.AUTH.SHOW_LOGIN]] - Keys which should NOT be deleted from the cache
   * @returns {Array<string>} Keys which have been deleted from the cache
   */
  clearCache(keepConversationInput = false, protectedKeyPatterns = [z.storage.StorageKey.AUTH.SHOW_LOGIN]) {
    const deletedKeys = [];

    if (keepConversationInput) {
      protectedKeyPatterns.push(z.storage.StorageKey.CONVERSATION.INPUT);
    }

    for (const storedKey in amplify.store()) {
      const shouldBeDeleted = !protectedKeyPatterns.some(pattern => storedKey.startsWith(pattern));

      if (shouldBeDeleted) {
        z.util.StorageUtil.resetValue(storedKey);
        deletedKeys.push(storedKey);
      }
    }

    return deletedKeys;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_MESSAGE_TYPE = {
  CANCEL: 'CANCEL',
  GROUP_CHECK: 'GROUPCHECK',
  GROUP_LEAVE: 'GROUPLEAVE',
  GROUP_SETUP: 'GROUPSETUP',
  GROUP_START: 'GROUPSTART',
  HANGUP: 'HANGUP',
  PROP_SYNC: 'PROPSYNC',
  REJECT: 'REJECT',
  SETUP: 'SETUP',
  UPDATE: 'UPDATE',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_STATE = {
  CONNECTING: 'connecting',
  DISCONNECTING: 'disconnecting',
  ENDED: 'ended',
  INCOMING: 'incoming',
  ONGOING: 'ongoing',
  OUTGOING: 'outgoing',
  REJECTED: 'rejected',
  UNKNOWN: 'unknown',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.CALL_STATE_GROUP = {
  CAN_CONNECT: [
    z.calling.enum.CALL_STATE.INCOMING,
    z.calling.enum.CALL_STATE.ONGOING,
    z.calling.enum.CALL_STATE.REJECTED,
  ],
  CAN_JOIN: [z.calling.enum.CALL_STATE.INCOMING, z.calling.enum.CALL_STATE.REJECTED],
  IS_ACTIVE: [
    z.calling.enum.CALL_STATE.CONNECTING,
    z.calling.enum.CALL_STATE.DISCONNECTING,
    z.calling.enum.CALL_STATE.INCOMING,
    z.calling.enum.CALL_STATE.ONGOING,
    z.calling.enum.CALL_STATE.OUTGOING,
  ],
  IS_ENDED: [z.calling.enum.CALL_STATE.ENDED, z.calling.enum.CALL_STATE.UNKNOWN],
  UNANSWERED: [z.calling.enum.CALL_STATE.INCOMING, z.calling.enum.CALL_STATE.OUTGOING],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.PROPERTY_STATE = {
  FALSE: 'false',
  PAUSED: 'paused',
  TRUE: 'true',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.SDP_NEGOTIATION_MODE = {
  DEFAULT: 'default',
  ICE_RESTART: 'iceRestart',
  STATE_COLLISION: 'stateCollision',
  STREAM_CHANGE: 'streamChange',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.SDP_SOURCE = {
  LOCAL: 'local',
  REMOTE: 'remote',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.enum = z.calling.enum || {};

z.calling.enum.TERMINATION_REASON = {
  COMPLETED: 'completed',
  CONCURRENT_CALL: 'concurrent',
  CONNECTION_DROP: 'drop',
  CONNECTION_FAILED: 'failed_ice',
  GROUP_CHECK: 'group_check',
  MEMBER_LEAVE: 'member_leave',
  MISSED: 'missed',
  OTHER_USER: 'other',
  PAGE_NAVIGATION: 'page_navigation',
  RENEGOTIATION: 'renegotiation',
  SDP_FAILED: 'failed_sdp',
  SELF_USER: 'self',
  TIMEOUT: 'timeout',
  UNKNOWN: 'unknown',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// https://w3c.github.io/webrtc-pc/#dom-rtcdatachannelstate
// https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel/readyState
z.calling.rtc.DATA_CHANNEL_STATE = {
  CLOSED: 'closed',
  CLOSING: 'closing',
  CONNECTING: 'connecting',
  OPEN: 'open',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtciceconnectionstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.iceConnectionState#Value
z.calling.rtc.ICE_CONNECTION_STATE = {
  CHECKING: 'checking',
  CLOSED: 'closed',
  COMPLETED: 'completed',
  CONNECTED: 'connected',
  DISCONNECTED: 'disconnected',
  FAILED: 'failed',
  NEW: 'new',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcicegatheringstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.iceGatheringState#Value
z.calling.rtc.ICE_GATHERING_STATE = {
  COMPLETE: 'complete',
  GATHERING: 'gathering',
  NEW: 'new',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcsdptype
// https://developer.mozilla.org/en-US/docs/Web/API/RTCSessionDescription#RTCSdpType
z.calling.rtc.SDP_TYPE = {
  ANSWER: 'answer',
  LOCAL: 'local',
  OFFER: 'offer',
  PROVISIONAL_ANSWER: 'pranswer',
  REMOTE: 'remote',
  ROLLBACK: 'rollback',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// http://www.w3.org/TR/webrtc/#rtcpeerstate-enum
// https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection.signalingState#Value
z.calling.rtc.SIGNALING_STATE = {
  CLOSED: 'closed',
  LOCAL_OFFER: 'have-local-offer',
  LOCAL_PROVISIONAL_ANSWER: 'have-local-pranswer',
  NEW: 'new',
  REMOTE_OFFER: 'have-remote-offer',
  REMOTE_PROVISIONAL_ANSWER: 'have-remote-pranswer',
  STABLE: 'stable',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.rtc = z.calling.rtc || {};

// https://www.w3.org/TR/webrtc/#dom-rtcstatstype
z.calling.rtc.STATS_TYPE = {
  CANDIDATE_PAIR: 'candidate-pair',
  GOOGLE_CANDIDATE_PAIR: 'googCandidatePair',
  INBOUND_RTP: 'inbound-rtp',
  OUTBOUND_RTP: 'outbound-rtp',
  SSRC: 'ssrc',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.CallEntity = class CallEntity {
  static get CONFIG() {
    return {
      GROUP_CHECK: {
        ACTIVITY_TIMEOUT: 2 * 60,
        MAXIMUM_TIMEOUT: 90,
        MINIMUM_TIMEOUT: 60,
      },
      STATE_TIMEOUT: 60 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      TIMER: {
        INIT_THRESHOLD: 100,
        UPDATE_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    };
  }

  /**
   * Construct a new call entity.
   *
   * @class z.calling.entities.Call
   * @param {z.entity.Conversation} conversationEntity - Conversation the call takes place in
   * @param {z.entity.User} creatingUser - Entity of user starting the call
   * @param {string} sessionId - Session ID to identify call
   * @param {z.calling.CallingRepository} callingRepository - Calling Repository
   */
  constructor(conversationEntity, creatingUser, sessionId, callingRepository) {
    this.conversationEntity = conversationEntity;
    this.creatingUser = creatingUser;
    this.sessionId = sessionId;
    this.callingRepository = callingRepository;

    const {id: conversationId, isGroup} = conversationEntity;
    const {mediaStreamHandler, mediaRepository, selfStreamState, telemetry, userRepository} = this.callingRepository;
    this.messageLog = this.callingRepository.messageLog;

    this.id = conversationId;

    const loggerName = 'z.calling.entities.CallEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info(`Created new call entity in conversation ${this.id}`);

    // IDs and references
    this.timings = undefined;

    this.mediaRepository = mediaRepository;
    this.userRepository = userRepository;
    this.selfUser = this.userRepository.self();
    this.selfState = selfStreamState;
    this.telemetry = telemetry;

    // States
    this.callTimerInterval = undefined;
    this.timerStart = undefined;
    this.durationTime = ko.observable(0);
    this.groupCheckTimeoutId = undefined;
    this.terminationReason = undefined;

    this.isConnected = ko.observable(false);
    this.isGroup = isGroup();

    this.selfClientJoined = ko.observable(false);
    this.selfUserJoined = ko.observable(false);
    this.state = ko.observable(z.calling.enum.CALL_STATE.UNKNOWN);
    this.previousState = undefined;

    this.participants = ko.observableArray([]);
    this.interruptedParticipants = ko.observableArray([]);

    // Media
    this.localMediaStream = mediaStreamHandler.localMediaStream;
    this.localMediaType = mediaStreamHandler.localMediaType;
    this.remoteMediaType = ko.observable(z.media.MediaType.NONE);

    // Statistics
    this._resetTimer();

    // Computed values
    this.isConnecting = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.CONNECTING);
    this.isDeclined = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.REJECTED);
    this.isDisconnecting = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.DISCONNECTING);
    this.isIncoming = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.INCOMING);
    this.isOngoing = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.ONGOING);
    this.isOutgoing = ko.pureComputed(() => this.state() === z.calling.enum.CALL_STATE.OUTGOING);

    this.canConnectState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.CAN_CONNECT.includes(this.state()));
    this.canJoinState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.CAN_JOIN.includes(this.state()));
    this.isActiveState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.IS_ACTIVE.includes(this.state()));
    this.isEndedState = ko.pureComputed(() => z.calling.enum.CALL_STATE_GROUP.IS_ENDED.includes(this.state()));

    this.isOngoingOnAnotherClient = ko.pureComputed(() => this.selfUserJoined() && !this.selfClientJoined());
    this.isRemoteScreenSend = ko.pureComputed(() => this.remoteMediaType() === z.media.MediaType.SCREEN);
    this.isRemoteVideoSend = ko.pureComputed(() => this.remoteMediaType() === z.media.MediaType.VIDEO);

    this.isLocalVideoCall = ko.pureComputed(() => this.selfState.screenSend() || this.selfState.videoSend());
    this.isRemoteVideoCall = ko.pureComputed(() => this.isRemoteScreenSend() || this.isRemoteVideoSend());

    this.networkInterruption = ko.pureComputed(() => {
      if (this.isConnected() && !this.isGroup) {
        return this.interruptedParticipants().length > 0;
      }

      return false;
    });

    ko.pureComputed(() => {
      const additionalCount = this.selfClientJoined() ? 1 : 0;
      return this.participants().length + additionalCount;
    }).subscribe(numberOfParticipants => {
      this.telemetry.numberOfParticipantsChanged(numberOfParticipants);
    });

    // Observable subscriptions
    this.wasConnected = false;
    this.isConnected.subscribe(isConnected => {
      if (isConnected) {
        this.wasConnected = true;
        if (this.isGroup) {
          this.scheduleGroupCheck();
        }

        this.telemetry.track_event(z.tracking.EventName.CALLING.ESTABLISHED_CALL, this);
        this.timerStart = Date.now() - CallEntity.CONFIG.TIMER.INIT_THRESHOLD;

        this.callTimerInterval = window.setInterval(() => {
          const durationInSeconds = Math.floor((Date.now() - this.timerStart) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
          this.durationTime(durationInSeconds);
        }, CallEntity.CONFIG.TIMER.UPDATE_INTERVAL);
      }
    });

    this.isDeclined.subscribe(isDeclined => {
      if (isDeclined) {
        this._stopRingTone(true);
      }
    });

    this.networkInterruption.subscribe(isInterrupted => {
      if (isInterrupted) {
        return amplify.publish(z.event.WebApp.AUDIO.PLAY_IN_LOOP, z.audio.AudioType.NETWORK_INTERRUPTION);
      }
      amplify.publish(z.event.WebApp.AUDIO.STOP, z.audio.AudioType.NETWORK_INTERRUPTION);
    });

    this.selfClientJoined.subscribe(isJoined => {
      if (!isJoined) {
        this.isConnected(false);

        if (this.isOngoing() || this.isDisconnecting()) {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.TALK_LATER);
        }

        if (this.terminationReason) {
          this.telemetry.track_duration(this);
        }

        this._resetTimer();
        this._resetFlows();
      }
    });

    this.state.subscribe(state => {
      const logMessage = {
        data: {
          default: [this.id, state],
          obfuscated: [this.callLogger.obfuscate(this.id), state],
        },
        message: `Call state '{0}' changed to '{1}'`,
      };
      this.callLogger.info(logMessage);

      this._clearStateTimeout();

      const hasState = state !== z.calling.enum.CALL_STATE.UNKNOWN;
      if (hasState) {
        const isUnansweredState = z.calling.enum.CALL_STATE_GROUP.UNANSWERED.includes(state);
        if (isUnansweredState) {
          const isIncomingCall = state === z.calling.enum.CALL_STATE.INCOMING;
          this._onStateStartRinging(isIncomingCall);
        } else {
          this._onStateStopRinging();
        }
      }

      const isConnectingCall = state === z.calling.enum.CALL_STATE.CONNECTING;
      if (isConnectingCall) {
        this.telemetry.track_event(z.tracking.EventName.CALLING.JOINED_CALL, this);
      }

      this.previousState = state;
    });

    if (this.isGroup) {
      this.scheduleGroupCheck();
    }

    this.conversationEntity.call(this);
  }

  //##############################################################################
  // Call states
  //##############################################################################

  /**
   * Deactivate the call.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message for deactivation
   * @param {boolean} fromSelf - Deactivation triggered by self user change
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason=z.calling.enum.TERMINATION_REASON.SELF_USER] - Call termination reason
   * @returns {Promise<boolean>} Resolves with a boolean whether the call was deleted
   */
  deactivateCall(callMessageEntity, fromSelf, terminationReason = z.calling.enum.TERMINATION_REASON.SELF_USER) {
    this._clearTimeouts();

    const everyoneLeft = this.participants().length <= 0 + fromSelf ? 1 : 0;
    const onGroupCheck = terminationReason === z.calling.enum.TERMINATION_REASON.GROUP_CHECK;

    const shouldDeleteCall = everyoneLeft || onGroupCheck;
    if (shouldDeleteCall) {
      this.terminationReason = terminationReason;
      this._deleteCall(callMessageEntity, everyoneLeft, onGroupCheck);
      return Promise.resolve(true);
    }

    if (this.isGroup) {
      this.scheduleGroupCheck();
    }

    this.callingRepository.mediaStreamHandler.resetMediaStream();
    return Promise.resolve(false);
  }

  _deleteCall(callMessageEntity, everyoneLeft, onGroupCheck) {
    const reason = !this.wasConnected
      ? z.calling.enum.TERMINATION_REASON.MISSED
      : z.calling.enum.TERMINATION_REASON.COMPLETED;

    if (onGroupCheck && !everyoneLeft) {
      const userIds = this.participants().map(participantEntity => participantEntity.id);
      this.callLogger.warn(`Deactivation on group check with remaining users '${userIds.join(', ')}' on group check`);
    }

    const eventSource = onGroupCheck
      ? z.event.EventRepository.SOURCE.INJECTED
      : z.event.EventRepository.SOURCE.WEB_SOCKET;

    callMessageEntity.userId = this.creatingUser.id;
    this.callingRepository.injectDeactivateEvent(callMessageEntity, eventSource, reason);

    return this.callingRepository.deleteCall(this.id);
  }

  /**
   * Delete the call.
   * @returns {undefined} No return value
   */
  deleteCall() {
    this.state(z.calling.enum.CALL_STATE.ENDED);
    this._resetCall();
  }

  /**
   * Join the call.
   * @param {z.media.MediaType} [mediaType] - Media type of the call
   * @returns {void} No return value
   */
  joinCall(mediaType) {
    if (this.canConnectState()) {
      this.state(z.calling.enum.CALL_STATE.CONNECTING);
    }

    return this.isGroup ? this._joinGroupCall(mediaType) : this._join1to1Call();
  }

  /**
   * Join the 1:1 call.
   * @private
   * @returns {void} No return value
   */
  _join1to1Call() {
    const [remoteUserId] = this.conversationEntity.participating_user_ids();
    this.addOrUpdateParticipant(remoteUserId, true);
  }

  /**
   * Join group call.
   *
   * @private
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type of the call
   * @returns {void} No return value
   */
  _joinGroupCall(mediaType = z.media.MediaType.AUDIO) {
    const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;

    const response = !this.isOutgoing();
    const propSync = z.calling.CallMessageBuilder.createPropSync(this.selfState, additionalPayload, videoSend);

    const callMessageEntity = z.calling.CallMessageBuilder.buildGroupStart(response, this.sessionId, propSync);
    this.sendCallMessage(callMessageEntity);
  }

  /**
   * Leave the call.
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Call termination reason
   * @returns {undefined} No return value
   */
  leaveCall(terminationReason) {
    if (this.isOngoing() && !this.isGroup) {
      this.state(z.calling.enum.CALL_STATE.DISCONNECTING);
    }

    let callMessageEntity = this.isConnected()
      ? z.calling.CallMessageBuilder.buildHangup(false, this.sessionId)
      : z.calling.CallMessageBuilder.buildCancel(false, this.sessionId);

    const eventPromises = this.getFlows().map(({remoteClientId, remoteUserId}) => {
      const payload = z.calling.CallMessageBuilder.createPayload(
        this.id,
        this.selfUser.id,
        remoteUserId,
        remoteClientId
      );
      callMessageEntity.addProperties(payload);
      return this.sendCallMessage(callMessageEntity);
    });

    Promise.all(eventPromises)
      .then(() => Promise.all(this.participants().map(({id}) => this.resetParticipant(id))))
      .then(() => {
        const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);

        if (this.isGroup) {
          callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, this.sessionId, additionalPayload);
          this.sendCallMessage(callMessageEntity);
        } else {
          callMessageEntity.addProperties(additionalPayload);
        }

        this.setSelfState(false, terminationReason);
        return this.deactivateCall(callMessageEntity, true, terminationReason);
      })
      .then(wasDeleted => {
        if (!wasDeleted) {
          this.state(z.calling.enum.CALL_STATE.REJECTED);
        }
      });
  }

  /**
   * Check if group call should continue after participant left.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Last member leaving call
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call participant to leave
   * @returns {undefined} No return value
   */
  participantLeft(callMessageEntity, terminationReason) {
    if (!this.participants().length) {
      return this.selfClientJoined()
        ? this.leaveCall(terminationReason)
        : this.deactivateCall(callMessageEntity, false, terminationReason);
    }
  }

  /**
   * Reject the call.
   * @param {boolean} [shareRejection=false] - Send rejection message to other clients
   * @returns {undefined} No return value
   */
  rejectCall(shareRejection = false) {
    this.state(z.calling.enum.CALL_STATE.REJECTED);
    if (this.isRemoteVideoCall()) {
      this.callingRepository.mediaStreamHandler.resetMediaStream();
    }

    if (shareRejection) {
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
      const callMessageEntity = z.calling.CallMessageBuilder.buildReject(false, this.sessionId, additionalPayload);
      this.sendCallMessage(callMessageEntity);
    }
  }

  /**
   * Schedule the check for group activity.
   * @returns {undefined} No return value
   */
  scheduleGroupCheck() {
    this._clearGroupCheckTimeout();
    return this.isConnected() ? this._setSendGroupCheckTimeout() : this._setVerifyGroupCheckTimeout();
  }

  /**
   * Set the self state.
   * @param {boolean} joinedState - Self joined state
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason] - Call termination reason
   * @returns {undefined} No return value
   */
  setSelfState(joinedState, terminationReason) {
    if (terminationReason && !this.terminationReason) {
      this.terminationReason = terminationReason;
    }
    this.selfClientJoined(joinedState);
    this.selfUserJoined(joinedState);
  }

  /**
   * Toggle media of this call.
   * @param {z.media.MediaType} mediaType - MediaType to toggle
   * @returns {Promise} Resolves when state has been toggled
   */
  toggleMedia(mediaType) {
    const toggledVideo = mediaType === z.media.MediaType.SCREEN && !this.selfState.videoSend();
    const toggledScreen = mediaType === z.media.MediaType.VIDEO && !this.selfState.screenSend();
    if (toggledVideo || toggledScreen) {
      this.telemetry.setAVToggled();
    }

    const callEventPromises = this.getFlows().map(({remoteClientId, remoteUserId}) => {
      const payload = z.calling.CallMessageBuilder.createPayload(
        this.id,
        this.selfUser.id,
        remoteUserId,
        remoteClientId
      );
      const propSyncPayload = z.calling.CallMessageBuilder.createPropSync(this.selfState, payload);

      const callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(false, this.sessionId, propSyncPayload);
      return this.sendCallMessage(callMessageEntity);
    });

    return Promise.all(callEventPromises);
  }

  /**
   * Clear the group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearGroupCheckTimeout() {
    if (this.groupCheckTimeoutId) {
      this.callLogger.debug(`Clear group check timeout with ID '${this.groupCheckTimeoutId}'`);
      window.clearTimeout(this.groupCheckTimeoutId);
      this.groupCheckTimeoutId = undefined;
    }
  }

  /**
   * Clear all timeouts.
   * @private
   * @returns {undefined} No return value
   */
  _clearTimeouts() {
    this.getFlows().map(flowEntity => flowEntity.clearTimeouts());
    this._clearGroupCheckTimeout();
    this._clearStateTimeout();
  }

  /**
   * Leave group call or schedule sending new group check after timeout.
   *
   * @private
   * @param {number} timeout - Random timeout in seconds
   * @returns {undefined} No return value
   */
  _onSendGroupCheckTimeout(timeout) {
    if (this.participants().length) {
      this.callLogger.info(`Sending group check after timeout of '${timeout}s' (ID: ${this.groupCheckTimeoutId})`);
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id);
      const callMessageEntity = z.calling.CallMessageBuilder.buildGroupCheck(true, this.sessionId, additionalPayload);

      this.sendCallMessage(callMessageEntity);
      return this.scheduleGroupCheck();
    }

    this.leaveCall(z.calling.enum.TERMINATION_REASON.OTHER_USER);
  }

  /**
   * Remove group call after timeout.
   * @private
   * @returns {undefined} No return value
   */
  _onVerifyGroupCheckTimeout() {
    this.callLogger.info(`Removing on group check timeout (ID: ${this.groupCheckTimeoutId})`);
    const additionalPayload = z.calling.CallMessageBuilder.createPayload(
      this.id,
      this.selfUser.id,
      this.creatingUser.id
    );
    const callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, this.sessionId, additionalPayload);

    this.deactivateCall(callMessageEntity, false, z.calling.enum.TERMINATION_REASON.GROUP_CHECK);
  }

  /**
   * Set the outgoing group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setSendGroupCheckTimeout() {
    const {MAXIMUM_TIMEOUT, MINIMUM_TIMEOUT} = CallEntity.CONFIG.GROUP_CHECK;
    const timeoutInSeconds = z.util.NumberUtil.getRandomNumber(MINIMUM_TIMEOUT, MAXIMUM_TIMEOUT);

    const timeout = timeoutInSeconds * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    this.groupCheckTimeoutId = window.setTimeout(() => this._onSendGroupCheckTimeout(timeoutInSeconds), timeout);

    const timeoutId = this.groupCheckTimeoutId;
    this.callLogger.debug(`Set sending group check after timeout of '${timeoutInSeconds}s' (ID: ${timeoutId})`);
  }

  /**
   * Set the incoming group check timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setVerifyGroupCheckTimeout() {
    const ACTIVITY_TIMEOUT = CallEntity.CONFIG.GROUP_CHECK.ACTIVITY_TIMEOUT;
    const timeout = ACTIVITY_TIMEOUT * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;

    this.groupCheckTimeoutId = window.setTimeout(() => this._onVerifyGroupCheckTimeout(), timeout);
    this.callLogger.debug(`Set verifying group check after '${ACTIVITY_TIMEOUT}s' (ID: ${this.groupCheckTimeoutId})`);
  }

  //##############################################################################
  // Call states
  //##############################################################################

  /**
   * Confirm an incoming message.
   * @param {z.calling.entities.CallMessageEntity} incomingCallMessageEntity - Incoming call message to be confirmed
   * @returns {Promise} Resolves when message was confirmed
   */
  confirmMessage(incomingCallMessageEntity) {
    const {clientId, type, userId} = incomingCallMessageEntity;
    const payload = z.calling.CallMessageBuilder.createPayload(this.id, this.selfUser.id, userId, clientId);

    let callMessageEntity;
    switch (type) {
      case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP: {
        callMessageEntity = z.calling.CallMessageBuilder.buildHangup(true, this.sessionId, payload);
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        const propSyncPayload = z.calling.CallMessageBuilder.createPropSync(this.selfState, payload);

        callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(true, this.sessionId, propSyncPayload);
        break;
      }

      default: {
        this.callLogger.error(`Tried to confirm call event of wrong type '${type}'`, callMessageEntity);
        return Promise.resolve();
      }
    }

    return this.sendCallMessage(callMessageEntity);
  }

  /**
   * Send call message.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be send
   * @returns {Promise} Resolves when the event has been send
   */
  sendCallMessage(callMessageEntity) {
    return this.callingRepository.sendCallMessage(this.conversationEntity, callMessageEntity);
  }

  /**
   * Set remote version of call
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to get remote version from
   * @returns {undefined} No return value
   */
  setRemoteVersion(callMessageEntity) {
    const rtcSdp = callMessageEntity.sdp;

    if (rtcSdp) {
      this.telemetry.set_remote_version(z.calling.SDPMapper.getToolVersion(rtcSdp));
    }
  }

  /**
   * Clear the state timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearStateTimeout() {
    if (this.stateTimeout) {
      window.clearTimeout(this.stateTimeout);
      this.stateTimeout = undefined;
    }
  }

  /**
   * Start ringing sound.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _onStateStartRinging(isIncoming) {
    this._playRingTone(isIncoming);
    this._setStateTimeout(isIncoming);
  }

  /**
   * Stop ringing sound.
   * @private
   * @returns {undefined} No return value
   */
  _onStateStopRinging() {
    const wasUnanswered = z.calling.enum.CALL_STATE_GROUP.UNANSWERED.includes(this.previousState);
    if (wasUnanswered) {
      const wasIncomingCall = this.previousState === z.calling.enum.CALL_STATE.INCOMING;
      this._stopRingTone(wasIncomingCall);
    }
  }

  /**
   * Play the ring tone.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _playRingTone(isIncoming) {
    const audioId = isIncoming ? z.audio.AudioType.INCOMING_CALL : z.audio.AudioType.OUTGOING_CALL;
    amplify.publish(z.event.WebApp.AUDIO.PLAY_IN_LOOP, audioId);
  }

  /**
   * Set the state timeout.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _setStateTimeout(isIncoming) {
    this.stateTimeout = window.setTimeout(() => {
      this._stopRingTone(isIncoming);

      if (isIncoming) {
        return this.isGroup ? this.rejectCall(false) : amplify.publish(z.event.WebApp.CALL.STATE.DELETE, this.id);
      }

      amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.id, z.calling.enum.TERMINATION_REASON.TIMEOUT);
    }, CallEntity.CONFIG.STATE_TIMEOUT);
  }

  /**
   * Stop the ring tone.
   *
   * @private
   * @param {boolean} isIncoming - Call is incoming
   * @returns {undefined} No return value
   */
  _stopRingTone(isIncoming) {
    const audioId = isIncoming ? z.audio.AudioType.INCOMING_CALL : z.audio.AudioType.OUTGOING_CALL;
    amplify.publish(z.event.WebApp.AUDIO.STOP, audioId);
  }

  /**
   * Update the remote participant state.
   * @private
   * @returns {undefined} No return value
   */
  _updateRemoteState() {
    let mediaTypeChanged = false;

    this.participants().forEach(({activeState}) => {
      if (activeState.screenSend()) {
        this.remoteMediaType(z.media.MediaType.SCREEN);
        mediaTypeChanged = true;
      } else if (activeState.videoSend()) {
        this.remoteMediaType(z.media.MediaType.VIDEO);
        mediaTypeChanged = true;
      }
    });

    if (!mediaTypeChanged) {
      this.remoteMediaType(z.media.MediaType.AUDIO);
    }
  }

  //##############################################################################
  // Participants
  //##############################################################################

  /**
   * Add or update a participant of the call.
   *
   * @param {string} userId - User ID of the call participant
   * @param {boolean} negotiate - Should negotiation be started immediately
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message for participant change
   * @returns {Promise} Resolves with participant entity
   */
  addOrUpdateParticipant(userId, negotiate, callMessageEntity) {
    return this.getParticipantById(userId)
      .then(participantEntity => this._updateParticipant(participantEntity, negotiate, callMessageEntity))
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (isNotFound) {
          return this._addParticipant(userId, negotiate, callMessageEntity);
        }

        throw error;
      });
  }

  /**
   * Remove an participant from the call.
   *
   * @param {string} userId - ID of user to be removed from the call
   * @param {string} clientId - ID of client that requested the removal from the call
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Call termination reason
   * @returns {Promise} Resolves with the call entity
   */
  deleteParticipant(userId, clientId, terminationReason) {
    return this.getParticipantById(userId)
      .then(participantEntity => {
        if (clientId) {
          participantEntity.verifyClientId(clientId);
        }

        participantEntity.resetParticipant();
        this.interruptedParticipants.remove(participantEntity);
        this.participants.remove(participantEntity);

        this._updateRemoteState();
        this.callingRepository.mediaElementHandler.removeMediaElement(userId);

        if (this.selfClientJoined()) {
          switch (terminationReason) {
            case z.calling.enum.TERMINATION_REASON.OTHER_USER: {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.TALK_LATER);
              break;
            }

            case z.calling.enum.TERMINATION_REASON.CONNECTION_DROP:
            case z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE: {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.CALL_DROP);
              break;
            }

            default: {
              break;
            }
          }
        }

        const logMessage = {
          data: {
            default: [participantEntity.user.name()],
            obfuscated: [this.callLogger.obfuscate(participantEntity.user.id)],
          },
          message: `Removed call participant '{0}'`,
        };
        this.callLogger.info(logMessage);
        return this;
      })
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (isNotFound) {
          return this;
        }

        throw error;
      });
  }

  /**
   * Get a call participant by his id.
   * @param {string} userId - User ID of participant to be returned
   * @returns {Promise} Resolves with the call participant that matches given user ID
   */
  getParticipantById(userId) {
    for (const participantEntity of this.participants()) {
      const isExpectedId = participantEntity.id === userId;
      if (isExpectedId) {
        return Promise.resolve(participantEntity);
      }
    }

    return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND, 'No participant found for user ID'));
  }

  /**
   * Remove an participant from the call.
   * @param {string} userId - ID of user to be removed from the call
   * @returns {Promise} Resolves with the call entity
   */
  resetParticipant(userId) {
    return this.getParticipantById(userId).then(participantEntity => {
      participantEntity.resetParticipant();
      this.interruptedParticipants.remove(participantEntity);

      this._updateRemoteState();
      this.callingRepository.mediaElementHandler.removeMediaElement(userId);
    });
  }

  /**
   * Verify call message belongs to call by session id.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity
   * @returns {Promise} Resolves with the Call entity if verification passed
   */
  verifySessionId(callMessageEntity) {
    const {userId, sessionId} = callMessageEntity;

    const isExpectedSessionId = sessionId === this.sessionId;
    if (isExpectedSessionId) {
      return Promise.resolve(this);
    }

    return this.getParticipantById(userId).then(({sessionId: participantSessionId}) => {
      const isExpectedParticipantSessionId = sessionId === participantSessionId;
      if (isExpectedParticipantSessionId) {
        return this;
      }

      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Session IDs not matching');
    });
  }

  /**
   * Add an participant to the call.
   *
   * @param {string} userId - User ID to be added to the call
   * @param {boolean} negotiate - Should negotiation be started immediately
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message entity for participant change
   * @returns {Promise} Resolves with the added participant
   */
  _addParticipant(userId, negotiate, callMessageEntity) {
    const isSelfUser = userId === this.selfUser.id;
    if (isSelfUser) {
      const errorMessage = 'Self user should not be added as call participant';
      return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.WRONG_STATE, errorMessage));
    }

    return this.userRepository.get_user_by_id(userId).then(userEntity => {
      const participantEntity = new z.calling.entities.ParticipantEntity(this, userEntity, this.timings);

      this.participants.push(participantEntity);

      const logMessage = {
        data: {
          default: [userEntity.name()],
          obfuscated: [this.callLogger.obfuscate(userEntity.id)],
        },
        message: `Adding call participant '{0}'`,
      };
      this.callLogger.info(logMessage, participantEntity);

      return this._updateParticipantState(participantEntity, negotiate, callMessageEntity);
    });
  }

  /**
   * Update call participant with call message.
   *
   * @param {z.calling.entities.ParticipantEntity} participantEntity - Participant entity to be updated in the call
   * @param {boolean} negotiate - Should negotiation be started
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to update user with
   * @returns {Promise} Resolves with the updated participant
   */
  _updateParticipant(participantEntity, negotiate, callMessageEntity) {
    if (callMessageEntity && callMessageEntity.clientId) {
      participantEntity.verifyClientId(callMessageEntity.clientId);
    }

    const logMessage = {
      data: {
        default: [participantEntity.user.name()],
        obfuscated: [this.callLogger.obfuscate(participantEntity.user.id)],
      },
      message: `Updating call participant '{0}'`,
    };
    this.callLogger.info(logMessage, callMessageEntity);

    return this._updateParticipantState(participantEntity, negotiate, callMessageEntity);
  }

  /**
   * Update call participant state.
   *
   * @param {z.calling.entities.ParticipantEntity} participantEntity - User ID to be added to the call
   * @param {boolean} negotiate - Should negotiation be started
   * @param {z.calling.entities.CallMessageEntity} [callMessageEntity] - Call message to update user with
   * @returns {Promise} Resolves with the updated participant
   */
  _updateParticipantState(participantEntity, negotiate, callMessageEntity) {
    const updatePromise = callMessageEntity ? participantEntity.updateState(callMessageEntity) : Promise.resolve(false);

    return updatePromise.then(skipNegotiation => {
      if (skipNegotiation) {
        negotiate = false;
      }

      this._updateRemoteState();

      if (negotiate) {
        participantEntity.startNegotiation();
      }

      return participantEntity;
    });
  }

  //##############################################################################
  // Misc
  //##############################################################################

  /**
   * Get all flows of the call.
   * @returns {Array<z.calling.entities.FlowEntity>} Array of flows
   */
  getFlows() {
    return this.participants()
      .filter(participantEntity => participantEntity.flowEntity)
      .map(participantEntity => participantEntity.flowEntity);
  }

  /**
   * Get full flow telemetry report of the call.
   * @returns {Array<Object>} Array of flow telemetry reports for calling service automation
   */
  getFlowTelemetry() {
    return this.getFlows().map(flowEntity => flowEntity.getTelemetry());
  }

  /**
   * Initiate the call telemetry.
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @returns {undefined} No return value
   */
  initiateTelemetry(direction, mediaType = z.media.MediaType.AUDIO) {
    this.telemetry.initiateNewCall(direction, mediaType);
    this.timings = new z.telemetry.calling.CallSetupTimings(this.id);
  }

  /**
   * Calculates the panning (from left to right) to position a user in a group call.
   *
   * @private
   * @param {number} index - Index of a user in a sorted array
   * @param {number} numberOfParticipants - Number of participants
   * @returns {number} Panning in the range of -1 to 1 with -1 on the left
   */
  _calculatePanning(index, numberOfParticipants) {
    const isSingleUser = numberOfParticipants === 1;
    if (isSingleUser) {
      return 0.0;
    }

    const position = -(numberOfParticipants - 1.0) / (numberOfParticipants + 1.0);
    const delta = (-2.0 * position) / (numberOfParticipants - 1.0);

    return position + delta * index;
  }

  /**
   * Sort the call participants by their audio panning.
   *
   * @note The idea is to calculate Jenkins' one-at-a-time hash (JOAAT) for each participant and then
   *  sort all participants in an array by their JOAAT hash. After that the array index of each user
   *  is used to allocate the position with the return value of this function.
   *
   * @returns {undefined} No return value
   */
  _sortParticipantsByPanning() {
    const twoOrMoreParticipants = this.participants().length >= 2;
    if (twoOrMoreParticipants) {
      this.participants()
        .sort((participantA, participantB) => participantA.user.joaatHash - participantB.user.joaatHash)
        .forEach((participantEntity, index) => {
          const panning = this._calculatePanning(index, this.participants().length);

          this.callLogger.debug({
            data: {
              default: [participantEntity.user.name(), panning],
              obfuscated: [this.callLogger.obfuscate(participantEntity.user.id), panning],
            },
            message: `Panning for '{0}' recalculated to '{1}'`,
          });

          participantEntity.panning(panning);
        });

      const panningOrder = this.participants()
        .map(({user}) => user.name())
        .join(', ');

      this.callLogger.info(`New panning order: ${panningOrder}`);
    }
  }

  //##############################################################################
  // Reset
  //##############################################################################

  /**
   * Reset the call states.
   * @private
   * @returns {undefined} No return value
   */
  _resetCall() {
    this.setSelfState(false);
    this.isConnected(false);
    this.sessionId = undefined;
    this.terminationReason = undefined;
    amplify.publish(z.event.WebApp.AUDIO.STOP, z.audio.AudioType.NETWORK_INTERRUPTION);
  }

  /**
   * Reset the call timers.
   * @private
   * @returns {undefined} No return value
   */
  _resetTimer() {
    if (this.callTimerInterval) {
      window.clearInterval(this.callTimerInterval);
      this.timerStart = undefined;
    }
    this.durationTime(0);
  }

  /**
   * Reset all flows of the call.
   * @private
   * @returns {undefined} No return value
   */
  _resetFlows() {
    this.getFlows().forEach(flowEntity => flowEntity.resetFlow());
  }

  needsMediaStream() {
    const hasPreJoinVideo = this.isIncoming() && this.isRemoteVideoCall();
    const hasActiveCall = hasPreJoinVideo || this.selfClientJoined();
    return hasActiveCall && !this.isOngoingOnAnotherClient();
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Log flow status to console.
   * @returns {undefined} No return value
   */
  logStatus() {
    this.getFlows().forEach(flowEntity => flowEntity.logStatus());
  }

  /**
   * Log flow setup step timings to console.
   * @returns {undefined} No return value
   */
  logTimings() {
    this.getFlows().forEach(flowEntity => flowEntity.logTimings());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.CallMessageEntity = class CallMessageEntity {
  static get CONFIG() {
    return {
      PAYLOAD_TYPES: {
        PROPS: [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
          z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
        SDP: [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
        TARGETED: [
          z.calling.enum.CALL_MESSAGE_TYPE.CANCEL,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.UPDATE,
        ],
      },
      SESSION_ID_LENGTH: 4,
      VERSION: '3.0',
    };
  }

  /**
   * Construct a new call message entity.
   *
   * @class z.calling.entities.CallMessageEntity
   * @param {z.calling.enum.CALL_MESSAGE_TYPE} type - Type of call message
   * @param {boolean} [response=false] - Is message a response, defaults to false
   * @param {string} sessionId - Optional session ID
   */
  constructor(type, response = false, sessionId) {
    this.type = type;
    this.response = response;
    this.sessionId = sessionId || this._createSessionId();
  }

  /**
   * Add additional payload to message.
   * @param {Object} [additionalProperties={}] - Optional object containing additional message payload
   * @returns {undefined} No return value
   */
  addProperties(additionalProperties = {}) {
    Object.entries(additionalProperties).forEach(([key, value]) => (this[key] = value));
  }

  /**
   * Cast call message to JSON.
   * @returns {{version: string, resp: boolean, sessid: string, type: z.calling.enum.CALL_MESSAGE_TYPE}} - JSON representation of call message
   */
  toJSON() {
    const json_payload = {
      resp: this.response,
      sessid: this.sessionId,
      type: this.type,
      version: CallMessageEntity.CONFIG.VERSION,
    };

    const isPropsMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.PROPS.includes(this.type);
    if (isPropsMessageType) {
      json_payload.props = this.properties;
      const isTypePropSync = this.type === z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC;
      if (!isTypePropSync) {
        json_payload.sdp = this.sdp;
      }
    }

    const isSdpMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.SDP.includes(this.type);
    if (isSdpMessageType) {
      json_payload.sdp = this.sdp;
    }

    const isTargetedMessageType = CallMessageEntity.CONFIG.PAYLOAD_TYPES.TARGETED.includes(this.type);
    if (isTargetedMessageType) {
      json_payload.dest_clientid = this.remoteClientId;
      json_payload.dest_userid = this.remoteUserId;
    }

    return json_payload;
  }

  /**
   * Cast call message to string.
   * @returns {string} Stringified JSON representation of call message
   */
  toContentString() {
    return JSON.stringify(this.toJSON());
  }

  /**
   * Create a session ID.
   * @private
   * @returns {string} Random char session ID of length CallMessageEntity.CONFIG.SESSION_ID_LENGTH
   */
  _createSessionId() {
    return _.range(CallMessageEntity.CONFIG.SESSION_ID_LENGTH)
      .map(() => z.util.StringUtil.getRandomChar())
      .join('');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.FlowEntity = class FlowEntity {
  static get CONFIG() {
    return {
      DATA_CHANNEL_LABEL: 'calling-3.0',
      MAX_ICE_CANDIDATE_GATHERING_ATTEMPTS: 5,
      NEGOTIATION_THRESHOLD: 0.5 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      RECONNECTION_TIMEOUT: 2.5 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      RENEGOTIATION_TIMEOUT: 30 * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      SDP_SEND_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
    };
  }

  /**
   * Construct a new flow entity.
   *
   * @class z.calling.entities.FlowEntity
   * @param {z.calling.entities.CallEntity} callEntity - Call entity that the flow belongs to
   * @param {z.calling.entities.ParticipantEntity} participantEntity - Participant entity that the flow belongs to
   * @param {CallSetupTimings} timings - Timing statistics of call setup steps
   */
  constructor(callEntity, participantEntity, timings) {
    this.callingRepository = callEntity.callingRepository;

    this.callEntity = callEntity;
    this.participantEntity = participantEntity;

    this.id = this.participantEntity.id;
    this.conversationId = this.callEntity.id;
    this.messageLog = this.participantEntity.messageLog;

    const loggerName = 'z.calling.entities.FlowEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    // States
    this.isAnswer = ko.observable(false);
    this.selfState = this.callEntity.selfState;

    // Users
    this.remoteClientId = undefined;
    this.remoteUser = this.participantEntity.user;
    this.remoteUserId = this.remoteUser.id;
    this.selfUser = this.callEntity.selfUser;
    this.selfUserId = this.selfUser.id;

    // Audio
    this.audio = new z.calling.entities.FlowAudioEntity(this, this.callingRepository.mediaRepository);

    // Telemetry
    this.telemetry = new z.telemetry.calling.FlowTelemetry(this.id, this.remoteUserId, this.callEntity, timings);

    this.callLogger.info({
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Created new flow entity for user {0}`,
    });

    //##############################################################################
    // PeerConnection
    //##############################################################################

    this.peerConnection = undefined;
    /*
      Because Chrome seems to not have the `getConfiguration` method on the peerConnection object when connection is not established,
      we also need to keep track of the configuration we feed the peerConnection.
      It might need reconsideration when Chrome 70 is out https://www.chromestatus.com/feature/5271355306016768
    */
    this.peerConnectionConfiguration = undefined;
    this.iceCandidatesGatheringAttempts = 1;
    this.pcInitialized = ko.observable(false);

    this.mediaStream = this.callEntity.localMediaStream;
    this.dataChannel = undefined;
    this.dataChannelOpened = false;

    this.connectionState = ko.observable(z.calling.rtc.ICE_CONNECTION_STATE.NEW);
    this.gatheringState = ko.observable(z.calling.rtc.ICE_GATHERING_STATE.NEW);
    this.signalingState = ko.observable(z.calling.rtc.SIGNALING_STATE.NEW);

    this.connectionState.subscribe(iceConnectionState => {
      switch (iceConnectionState) {
        case z.calling.rtc.ICE_CONNECTION_STATE.COMPLETED:
        case z.calling.rtc.ICE_CONNECTION_STATE.CONNECTED: {
          this._clearNegotiationTimeout();
          this.negotiationMode(z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT);
          this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED);

          this.callEntity.isConnected(true);
          this.participantEntity.isConnected(true);

          this.callEntity.interruptedParticipants.remove(this.participantEntity);
          this.callEntity.state(z.calling.enum.CALL_STATE.ONGOING);
          this.callEntity.terminationReason = undefined;
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.CLOSED: {
          this.participantEntity.isConnected(false);

          if (this.callEntity.selfClientJoined()) {
            this.callEntity.deleteParticipant(this.participantEntity.id, this.remoteClientId);
          }
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.DISCONNECTED: {
          this._setNegotiationRestartTimeout();
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.FAILED: {
          if (this.callEntity.selfClientJoined()) {
            this._removeDroppedParticipant();
          }
          break;
        }

        case z.calling.rtc.ICE_CONNECTION_STATE.CHECKING:
        default: {
          break;
        }
      }
    });

    this.signalingState.subscribe(signalingState => {
      switch (signalingState) {
        case z.calling.rtc.SIGNALING_STATE.CLOSED: {
          const logMessage = {
            data: {
              default: [this.remoteUser.name()],
              obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
            },
            message: `PeerConnection with '{0}' was closed`,
          };
          this.callLogger.info(logMessage);

          this.callEntity.deleteParticipant(this.participantEntity.id, this.remoteClientId);
          break;
        }

        case z.calling.rtc.SIGNALING_STATE.STABLE: {
          this._clearNegotiationTimeout();
          break;
        }

        default: {
          break;
        }
      }
    });

    this.negotiationMode = ko.observable(z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT);
    this.negotiationNeeded = ko.observable(false);
    this.negotiationTimeout = undefined;

    this.sdpStateChanging = ko.observable(false);

    //##############################################################################
    // Local SDP
    //##############################################################################

    this.localSdpType = ko.observable(undefined);
    this.localSdp = ko.observable(undefined);
    this.localSdp.subscribe((sdp = {}) => {
      this.localSdpType(sdp.type);

      if (sdp.type) {
        if (!this.shouldSendLocalSdp()) {
          this.shouldSendLocalSdp(true);
          this.shouldSetLocalSdp(true);
        }
      }
    });

    this.shouldSendLocalSdp = ko.observable(false);
    this.shouldSetLocalSdp = ko.observable(false);

    this.sendSdpTimeout = undefined;

    this.properLocalSdpState = ko.pureComputed(() => {
      const isAnswer = this.localSdpType() === z.calling.rtc.SDP_TYPE.ANSWER;
      const isOffer = this.localSdpType() === z.calling.rtc.SDP_TYPE.OFFER;
      const inRemoteOfferState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.REMOTE_OFFER;
      const inStableState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;

      const isProperAnswerState = isAnswer && inRemoteOfferState;
      const isProperOfferState = isOffer && inStableState;
      return isProperOfferState || isProperAnswerState;
    });

    this.canSetLocalSdp = ko.pureComputed(() => {
      const inConnectionProgress = this.connectionState() === z.calling.rtc.ICE_CONNECTION_STATE.CHECKING;
      const progressGatheringStates = [
        z.calling.rtc.ICE_GATHERING_STATE.COMPLETE,
        z.calling.rtc.ICE_GATHERING_STATE.GATHERING,
      ];
      const inProgress = inConnectionProgress && progressGatheringStates.includes(this.gatheringState());

      const isProperState = this.localSdp() && this.shouldSetLocalSdp() && this.properLocalSdpState();
      const changeInProgress = inProgress || this.sdpStateChanging();
      return isProperState && !changeInProgress;
    });

    this.canSetLocalSdp.subscribe(canSet => {
      if (canSet) {
        this._setLocalSdp();
      }
    });

    //##############################################################################
    // Remote SDP
    //##############################################################################

    this.remoteSdpType = ko.observable(undefined);
    this.remoteSdp = ko.observable(undefined);
    this.remoteSdp.subscribe((sdp = {}) => {
      this.remoteSdpType(sdp.type);

      if (sdp.type) {
        this.shouldSetRemoteSdp(true);
      }
    });

    this.shouldSetRemoteSdp = ko.observable(false);

    this.properRemoteSdpState = ko.pureComputed(() => {
      const isAnswer = this.remoteSdpType() === z.calling.rtc.SDP_TYPE.ANSWER;
      const isOffer = this.remoteSdpType() === z.calling.rtc.SDP_TYPE.OFFER;
      const inLocalOfferState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.LOCAL_OFFER;
      const inStableState = this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;

      const isProperAnswerState = isAnswer && inLocalOfferState;
      const isProperOfferState = isOffer && inStableState;
      return isProperOfferState || isProperAnswerState;
    });

    this.canSetRemoteSdp = ko.pureComputed(() => {
      const isProperState = this.pcInitialized() && this.shouldSetRemoteSdp() && this.properRemoteSdpState();
      return isProperState && !this.sdpStateChanging();
    });

    this.canSetRemoteSdp.subscribe(canSet => {
      if (canSet) {
        this._setRemoteSdp();
      }
    });

    //##############################################################################
    // Gates
    //##############################################################################

    this.canCreateSdp = ko.pureComputed(() => {
      const isConnectionClosed = this.signalingState() === z.calling.rtc.SIGNALING_STATE.CLOSED;
      const inStateForCreation = this.negotiationNeeded() && !isConnectionClosed;
      return this.pcInitialized() && inStateForCreation;
    });

    this.canCreateSdpAnswer = ko.pureComputed(() => {
      const answerState = this.isAnswer() && this.signalingState() === z.calling.rtc.SIGNALING_STATE.REMOTE_OFFER;
      return this.canCreateSdp() && answerState;
    });

    this.canCreateSdpAnswer.subscribe(canCreate => {
      if (canCreate) {
        this._createSdpAnswer();
      }
    });

    this.canCreateSdpOffer = ko.pureComputed(() => {
      const offerState = !this.isAnswer() && this.signalingState() === z.calling.rtc.SIGNALING_STATE.STABLE;
      return this.canCreateSdp() && offerState;
    });

    this.canCreateSdpOffer.subscribe(canCreate => {
      if (canCreate) {
        this._createSdpOffer();
      }
    });
  }

  /**
   * Restart the peer connection negotiation.
   *
   * @param {z.calling.enum.SDP_NEGOTIATION_MODE} negotiationMode - Mode for renegotiation
   * @param {boolean} isAnswer - Flow is answer
   * @param {MediaStream} [mediaStream] - Local media stream
   * @returns {undefined} No return value
   */
  restartNegotiation(negotiationMode, isAnswer, mediaStream) {
    this.callLogger.info(`Negotiation restart triggered by '${negotiationMode}'`);

    this.clearTimeouts();
    this._closePeerConnection();
    this._closeDataChannel();
    this._resetSignalingStates();
    this.isAnswer(isAnswer);
    this._resetSdp();

    const isModeStateCollision = negotiationMode === z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION;
    if (!isModeStateCollision) {
      this.startNegotiation(negotiationMode, mediaStream);
    }
  }

  /**
   * Set the remote client ID.
   * @param {string} clientId - Remote client ID
   * @returns {Undefined} No return value
   */
  setRemoteClientId(clientId) {
    if (!this.remoteClientId) {
      this.remoteClientId = clientId;
      const logMessage = {
        data: {
          default: [clientId],
          obfuscated: [this.callLogger.obfuscate(clientId)],
        },
        message: `Identified remote client as '{0}'`,
      };
      this.callLogger.info(logMessage);
    }
  }

  /**
   * Start the peer connection negotiation.
   *
   * @param {z.calling.enum.SDP_NEGOTIATION_MODE} [negotiationMode=z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT] - Mode for renegotiation
   * @param {MediaStream} [mediaStream=this.mediaStream()] - Local media stream
   * @returns {undefined} No return value
   */
  startNegotiation(negotiationMode = z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT, mediaStream = this.mediaStream()) {
    const logMessage = {
      data: {
        default: [this.remoteUser.name(), negotiationMode],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id), negotiationMode],
      },
      message: `Start negotiating PeerConnection with '{0}' triggered by '{1}'`,
    };
    this.callLogger.info(logMessage);

    const hadMediaStream = !!mediaStream;
    this._createPeerConnection().then(() => {
      if (!mediaStream) {
        // @todo Remove report after debugging purpose achieved
        const customData = {
          hadMediaStream,
          hasMediaStream: !!mediaStream,
          isAnswer: this.isAnswer(),
          isGroup: this.callEntity.isGroup,
          selfClientJoined: this.callEntity.selfClientJoined(),
          state: this.callEntity.state(),
        };
        Raygun.send(new Error('Media Stream missing when negotiation call'), customData);

        throw new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND);
      }

      this._addMediaStream(mediaStream);
      this.audio.hookup(true);
      this._setSdpStates();
      this.negotiationMode(negotiationMode);
      this.negotiationNeeded(true);
      this.pcInitialized(true);

      const isDefaultNegotiationMode = negotiationMode === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
      this._setNegotiationFailedTimeout(isDefaultNegotiationMode);
    });
  }

  /**
   * Remove the participant from the call
   *
   * @private
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason] - Reason for termination
   * @returns {undefined} No return value
   */
  _removeDroppedParticipant(terminationReason) {
    this.participantEntity.isConnected(false);

    const deletionTerminationReason = z.calling.enum.TERMINATION_REASON.CONNECTION_DROP;
    this.callEntity
      .deleteParticipant(this.participantEntity.id, this.remoteClientId, deletionTerminationReason)
      .then(() => {
        if (!this.callEntity.participants().length) {
          if (!terminationReason) {
            terminationReason = this.callEntity.isConnected()
              ? z.calling.enum.TERMINATION_REASON.CONNECTION_DROP
              : z.calling.enum.TERMINATION_REASON.CONNECTION_FAILED;
          }
          amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.callEntity.id, terminationReason);
        }
      });
  }

  /**
   * Set SDP gate states.
   * @private
   * @returns {undefined} No return value
   */
  _setSdpStates() {
    this.shouldSetRemoteSdp(true);
    this.shouldSetLocalSdp(true);
    this.shouldSendLocalSdp(true);
  }

  //##############################################################################
  // PeerConnection handling
  //##############################################################################

  /**
   * Close the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _closePeerConnection() {
    const peerConnectionInActiveState =
      this.peerConnection && this.peerConnection.signalingState !== z.calling.rtc.SIGNALING_STATE.CLOSED;

    if (!peerConnectionInActiveState) {
      const logMessage = {
        data: {
          default: [this.remoteUser.name()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `PeerConnection with '{0}' was previously closed`,
      };
      this.callLogger.info(logMessage);
      return;
    }

    this.peerConnection.oniceconnectionstatechange = () => {
      this.callLogger.log(this.callLogger.levels.OFF, 'State change ignored - ICE connection');
    };

    this.peerConnection.onsignalingstatechange = event => {
      const peerConnection = event.target;
      const logMessage = `State change ignored - signaling state: ${peerConnection.signalingState}`;
      this.callLogger.log(this.callLogger.levels.OFF, logMessage);
    };

    const connectionMediaStreamTracks = this.peerConnection.getReceivers
      ? this.peerConnection.getReceivers().map(receiver => receiver.track)
      : this.peerConnection.getRemoteStreams().reduce((tracks, stream) => tracks.concat(stream.getTracks()), []);

    amplify.publish(z.event.WebApp.CALL.MEDIA.CONNECTION_CLOSED, connectionMediaStreamTracks);
    this.peerConnection.close();
    this.peerConnection = undefined;

    const logMessage = {
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Closing PeerConnection with '{0}' successful`,
    };
    this.callLogger.info(logMessage);
  }

  /**
   * Create the PeerConnection configuration.
   * @private
   * @returns {Promise} Resolves with the configuration object to initialize PeerConnection
   */
  _createPeerConnectionConfiguration() {
    return this.callingRepository.getConfig().then(({ice_servers}) => {
      return {
        bundlePolicy: 'max-bundle',
        iceServers: ice_servers,
        rtcpMuxPolicy: 'require', // @deprecated Default value beginning Chrome 57
      };
    });
  }

  /**
   * Initialize the PeerConnection for the flow.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration
   * @private
   * @returns {Promise} Resolves when the PeerConnection was created
   */
  _createPeerConnection() {
    return this._createPeerConnectionConfiguration().then(pcConfiguration => {
      this.peerConnection = new window.RTCPeerConnection(pcConfiguration);
      this.peerConnectionConfiguration = pcConfiguration;
      this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED);
      this.signalingState(this.peerConnection.signalingState);

      const logMessage = {
        data: {
          default: [this.remoteUser.name(), this.isAnswer()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id), this.isAnswer()],
        },
        message: `PeerConnection with '{0}' created - isAnswer '{1}'`,
      };
      this.callLogger.debug(logMessage, pcConfiguration);

      this.peerConnection.onaddstream = this._onAddStream.bind(this);
      this.peerConnection.ontrack = this._onTrack.bind(this);
      this.peerConnection.ondatachannel = this._onDataChannel.bind(this);
      this.peerConnection.onicecandidate = this._onIceCandidate.bind(this);
      this.peerConnection.oniceconnectionstatechange = this._onIceConnectionStateChange.bind(this);
      this.peerConnection.onremovestream = this._onRemoveStream.bind(this);
      this.peerConnection.onsignalingstatechange = this._onSignalingStateChange.bind(this);

      this.telemetry.set_peer_connection(this.peerConnection);
    });
  }

  /**
   * A MediaStream was added to the PeerConnection.
   *
   * @deprecated
   * @private
   * @param {MediaStream} mediaStream - MediaStream from event
   * @returns {undefined} No return value
   */
  _onAddStream({stream: mediaStream}) {
    this.callLogger.info('Remote MediaStream added to PeerConnection', {
      audioTracks: mediaStream.getAudioTracks(),
      stream: mediaStream,
      videoTracks: mediaStream.getVideoTracks(),
    });

    const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
    const isTypeAudio = mediaType === z.media.MediaType.AUDIO;
    if (isTypeAudio) {
      mediaStream = this.audio.wrapAudioOutputStream(mediaStream);
    }

    const mediaStreamInfo = new z.media.MediaStreamInfo(
      z.media.MediaStreamSource.REMOTE,
      this.remoteUser.id,
      mediaStream,
      this.callEntity
    );
    amplify.publish(z.event.WebApp.CALL.MEDIA.ADD_STREAM, mediaStreamInfo);
  }

  /**
   * A local ICE candidates is available.
   *
   * @private
   * @param {RTCIceCandidate} iceCandidate - RTCIceCandidate from event
   * @returns {undefined} No return value
   */
  _onIceCandidate({candidate: iceCandidate}) {
    if (!iceCandidate) {
      if (this.shouldSendLocalSdp()) {
        this.callLogger.info('Generation of ICE candidates completed');
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED);
        this.sendLocalSdp();
      }
    }
  }

  /**
   * ICE connection state has changed.
   *
   * @private
   * @param {Object} event - State change event
   * @returns {undefined} No return value
   */
  _onIceConnectionStateChange(event) {
    if (this.callEntity.isActiveState()) {
      const peerConnection = event.target;

      this.callLogger.info('State changed - ICE connection', event);
      const connectionMessage = `ICE connection state: ${peerConnection.iceConnectionState}`;
      this.callLogger.log(this.callLogger.levels.LEVEL_1, connectionMessage);
      const gatheringMessage = `ICE gathering state: ${peerConnection.iceGatheringState}`;
      this.callLogger.log(this.callLogger.levels.LEVEL_1, gatheringMessage);

      this.gatheringState(peerConnection.iceGatheringState);
      this.connectionState(peerConnection.iceConnectionState);
    }
  }

  /**
   * A MediaStream was removed from the PeerConnection.
   *
   * @private
   * @param {MediaStreamEvent} event - Event that a MediaStream has been removed
   * @returns {undefined} No return value
   */
  _onRemoveStream(event) {
    this.callLogger.info('Remote MediaStream removed from PeerConnection', event);
  }

  /**
   * Signaling state has changed.
   *
   * @private
   * @param {Object} event - State change event
   * @returns {undefined} No return value
   */
  _onSignalingStateChange(event) {
    const peerConnection = event.target;
    this.callLogger.info(`State changed - signaling state: ${peerConnection.signalingState}`, event);
    this.signalingState(peerConnection.signalingState);
  }

  /**
   * A MediaStreamTrack was added to the PeerConnection.
   *
   * @private
   * @param {RTCTrackEvent} event - Event that contains the newly added MediaStreamTrack
   * @returns {undefined} No return value
   */
  _onTrack(event) {
    const mediaStreamTrack = event.track;
    this.callLogger.info(`Remote '${mediaStreamTrack.kind}' MediaStreamTrack added to PeerConnection`, event);
  }

  //##############################################################################
  // Data channel handling
  //##############################################################################

  /**
   * Send a call message through the data channel.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be send
   * @returns {undefined} No return value
   */
  sendMessage(callMessageEntity) {
    const {conversationId, response, type} = callMessageEntity;

    if (this.dataChannel && this.dataChannelOpened) {
      try {
        this.dataChannel.send(callMessageEntity.toContentString());

        const logMessage = {
          data: {
            default: [type, conversationId],
            obfuscated: [type, this.callLogger.obfuscate(conversationId)],
          },
          message: `Sending '{0}' message to conversation '{1}' via data channel`,
        };
        this.callLogger.info(logMessage, callMessageEntity.toJSON());
        return;
      } catch (error) {
        if (!response) {
          this.callLogger.warn(`Failed to send calling message via data channel: ${error.name}`, error);
          throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
        }
      }
    }

    throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
  }

  /**
   * Close the data channel.
   * @private
   * @returns {undefined} No return value
   */
  _closeDataChannel() {
    if (this.dataChannel) {
      const isReadyStateOpen = this.dataChannel.readyState === z.calling.rtc.DATA_CHANNEL_STATE.OPEN;
      if (isReadyStateOpen) {
        this.dataChannel.close();
      }
      delete this.dataChannel;
    }
    this.dataChannelOpened = false;
  }

  /**
   * Initialize the data channel.
   * @private
   * @returns {undefined} No return value
   */
  _initializeDataChannel() {
    if (this.peerConnection.createDataChannel && !this.dataChannel) {
      const label = FlowEntity.CONFIG.DATA_CHANNEL_LABEL;
      this._setupDataChannel(this.peerConnection.createDataChannel(label, {ordered: true}));
    }
  }

  /**
   * Set up the data channel.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel object
   * @returns {undefined} No return value
   */
  _setupDataChannel(dataChannel) {
    this.dataChannel = dataChannel;
    dataChannel.onclose = this._onClose.bind(this);
    dataChannel.onerror = this._onError.bind(this);
    dataChannel.onmessage = this._onMessage.bind(this);
    dataChannel.onopen = this._onOpen.bind(this);
  }

  /**
   * A data channel was received on the PeerConnection.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel from event
   * @returns {undefined} No return value
   */
  _onDataChannel({channel: dataChannel}) {
    this._setupDataChannel(dataChannel);
  }

  /**
   * Data channel was closed.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Data channel that was closed
   * @returns {undefined} No return value
   */
  _onClose({target: dataChannel}) {
    this.callLogger.info(`Data channel '${dataChannel.label}' was closed`, dataChannel);

    if (this.dataChannel && this.dataChannel.readyState === z.calling.rtc.DATA_CHANNEL_STATE.CLOSED) {
      delete this.dataChannel;
      this.dataChannelOpened = false;
    }
  }

  /**
   * An error was caught on the data channel.
   *
   * @private
   * @param {Error} error - Error thrown
   * @returns {undefined} No return value
   */
  _onError(error) {
    throw error;
  }

  /**
   * New incoming message on the data channel.
   *
   * @private
   * @param {string} message - Incoming message
   * @returns {undefined} No return value
   */
  _onMessage({data: message}) {
    const callMessage = JSON.parse(message);
    const {resp: response, type} = callMessage;
    const conversationEntity = this.callEntity.conversationEntity;

    const logMessage = response
      ? `Received confirmation for '${type}' message via data channel`
      : `Received '${type}' (response: ${response}) message via data channel`;
    this.callLogger.debug(logMessage, callMessage);

    const callEvent = z.conversation.EventBuilder.buildCalling(
      conversationEntity,
      callMessage,
      this.remoteUserId,
      this.remoteClientId
    );
    amplify.publish(z.event.WebApp.CALL.EVENT_FROM_BACKEND, callEvent, z.event.EventRepository.SOURCE.WEB_SOCKET);
  }

  /**
   * Data channel was successfully opened.
   *
   * @private
   * @param {RTCDataChannel} dataChannel - Opened data channel
   * @returns {undefined} No return value
   */
  _onOpen({target: dataChannel}) {
    this.callLogger.info(`Data channel '${dataChannel.label}' was opened and can be used`, dataChannel);
    this.dataChannelOpened = true;
  }

  //##############################################################################
  // SDP handling
  //##############################################################################

  /**
   * Save the remote SDP received via a call message within the flow.
   *
   * @note The resolving value indicates whether negotiation should be skipped for the current state.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {Promise} Resolves when the remote SDP was saved
   */
  saveRemoteSdp(callMessageEntity) {
    let skipNegotiation = false;

    return z.calling.SDPMapper.mapCallMessageToObject(callMessageEntity)
      .then(rtcSdp => z.calling.SDPMapper.rewriteSdp(rtcSdp, z.calling.enum.SDP_SOURCE.REMOTE, this))
      .then(({sdp: remoteSdp}) => {
        const isRemoteOffer = remoteSdp.type === z.calling.rtc.SDP_TYPE.OFFER;
        if (isRemoteOffer) {
          switch (this.signalingState()) {
            case z.calling.rtc.SIGNALING_STATE.LOCAL_OFFER: {
              if (this._solveCollidingStates()) {
                return true;
              }
              break;
            }

            case z.calling.rtc.SIGNALING_STATE.NEW:
            case z.calling.rtc.SIGNALING_STATE.STABLE: {
              const isUpdate = callMessageEntity.type === z.calling.enum.CALL_MESSAGE_TYPE.UPDATE;

              if (isUpdate) {
                this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STREAM_CHANGE, true);
                skipNegotiation = true;
              }

              this.isAnswer(true);
              break;
            }

            default: {
              break;
            }
          }
        }

        this.remoteSdp(remoteSdp);
        this.callLogger.debug(`Saved remote '${remoteSdp.type}' SDP`, this.remoteSdp());
        return skipNegotiation;
      });
  }

  /**
   * Initiates sending the local RTCSessionDescriptionProtocol to the remote user.
   * @param {boolean} [sendingOnTimeout=false] - SDP sending on timeout
   * @returns {undefined} No return value
   */
  sendLocalSdp(sendingOnTimeout = false) {
    this.callLogger.info(`Sending local SDP${sendingOnTimeout ? ' on timeout' : ''}`);
    this._clearSendSdpTimeout();

    if (!this.peerConnection) {
      this.callLogger.warn('Cannot send local SDP without existing PeerConnection');
      return;
    }

    const mappedSdp = z.calling.SDPMapper.rewriteSdp(
      this.peerConnection.localDescription,
      z.calling.enum.SDP_SOURCE.LOCAL,
      this
    );
    Promise.resolve(mappedSdp)
      .then(({iceCandidates, sdp: localSdp}) => {
        this.localSdp(localSdp);

        const isModeDefault = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
        if (isModeDefault && sendingOnTimeout) {
          const connectionConfig =
            (this.peerConnection.getConfiguration && this.peerConnection.getConfiguration()) ||
            this.peerConnectionConfiguration;
          const isValidGathering = z.util.PeerConnectionUtil.isValidIceCandidatesGathering(
            connectionConfig,
            iceCandidates
          );
          const attempts = this.iceCandidatesGatheringAttempts;
          const hasReachMaxGatheringAttempts = attempts >= FlowEntity.CONFIG.MAX_ICE_CANDIDATE_GATHERING_ATTEMPTS;
          if (!hasReachMaxGatheringAttempts && !isValidGathering) {
            const logMessage = `Not enough ICE candidates gathered (attempt '${attempts}'). Restarting timeout\n${iceCandidates}`;
            this.iceCandidatesGatheringAttempts++;
            this.callLogger.warn(logMessage);
            return this._setSendSdpTimeout();
          }
        }

        const iceCandidateTypes = z.util.PeerConnectionUtil.getIceCandidatesTypes(iceCandidates);

        const iceCandidateTypesLog = Object.keys(iceCandidateTypes)
          .map(candidateType => `${iceCandidateTypes[candidateType]} ${candidateType}`)
          .join(', ');

        const logMessage = {
          data: {
            default: [
              localSdp.type,
              iceCandidates.length,
              iceCandidateTypesLog,
              this.remoteUser.name(),
              this.localSdp().sdp,
            ],
            obfuscated: [
              localSdp.type,
              iceCandidates.length,
              this.callLogger.obfuscate(this.remoteUser.id),
              this.callLogger.obfuscateSdp(this.localSdp().sdp),
            ],
          },
          message: `Sending local '{0}' SDP containing '{1}' ICE candidates ({2}) for flow with '{3}'\n{4}`,
        };
        this.callLogger.debug(logMessage);

        this.shouldSendLocalSdp(false);

        const response = localSdp.type === z.calling.rtc.SDP_TYPE.ANSWER;
        let callMessageEntity;

        const additionalPayload = this._createAdditionalPayload();
        const sessionId = this.callEntity.sessionId;
        const inDefaultMode = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
        if (inDefaultMode) {
          callMessageEntity = this.callEntity.isGroup
            ? z.calling.CallMessageBuilder.buildGroupSetup(response, sessionId, additionalPayload)
            : z.calling.CallMessageBuilder.buildSetup(response, sessionId, additionalPayload);
        } else {
          callMessageEntity = z.calling.CallMessageBuilder.buildUpdate(response, sessionId, additionalPayload);
        }

        return this.callEntity.sendCallMessage(callMessageEntity).then(() => {
          this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND);
          this.callLogger.debug(`Sending local '${localSdp.type}' SDP successful`, this.localSdp());
        });
      })
      .catch(error => {
        this.shouldSendLocalSdp(true);
        throw error;
      });
  }

  /**
   * Clear the negotiation timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearNegotiationTimeout() {
    if (this.negotiationTimeout) {
      window.clearTimeout(this.negotiationTimeout);
      this.negotiationTimeout = undefined;
    }
  }

  /**
   * Clear the SDP send timeout.
   * @private
   * @returns {undefined} No return value
   */
  _clearSendSdpTimeout() {
    if (this.sendSdpTimeout) {
      window.clearTimeout(this.sendSdpTimeout);
      this.sendSdpTimeout = undefined;
    }
  }

  /**
   * Build RTCOfferAnswerOptions for SDP creation
   *
   * @see https://www.w3.org/TR/webrtc/#offer/answer-options
   *
   * @private
   * @param {boolean} iceRestart - Is ICE restart
   * @returns {RTCOfferAnswerOptions} Object containing the RTCOfferAnswerOptions
   */
  _createOfferAnswerOptions(iceRestart) {
    return {iceRestart, voiceActivityDetection: true};
  }

  /**
   * Create a local SDP of type 'answer'.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createAnswer
   * @private
   * @returns {undefined} No return value
   */
  _createSdpAnswer() {
    this.negotiationNeeded(false);

    const logMessage = {
      data: {
        default: [z.calling.rtc.SDP_TYPE.ANSWER, this.remoteUser.name()],
        obfuscated: [z.calling.rtc.SDP_TYPE.ANSWER, this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Creating '{0}' for flow with '{1}'`,
    };
    this.callLogger.debug(logMessage);

    this.peerConnection
      .createAnswer(this._createOfferAnswerOptions())
      .then(rtcSdp => this._createSdpSuccess(rtcSdp))
      .catch(error => this._createSdpFailure(error, z.calling.rtc.SDP_TYPE.ANSWER));
  }

  /**
   * Failed to create local SDP
   *
   * @private
   * @param {Error} error - Error that was thrown
   * @param {z.calling.rtc.SDP_TYPE} sdpType - Type of SDP
   * @returns {undefined} No return value
   */
  _createSdpFailure(error, sdpType) {
    const {message, name} = error;
    this.callLogger.error(`Creating '${sdpType}' failed: ${name} - ${message}`, error);

    const attributes = {cause: name, step: 'create_sdp', type: sdpType};
    this.callEntity.telemetry.track_event(z.tracking.EventName.CALLING.FAILED_RTC, undefined, attributes);

    amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.callEntity.id, z.calling.enum.TERMINATION_REASON.SDP_FAILED);
  }

  /**
   * Creating local SDP succeeded.
   *
   * @private
   * @param {RTCSessionDescription} rctSdp - New local SDP
   * @returns {undefined} No return value
   */
  _createSdpSuccess(rctSdp) {
    this.callLogger.info(`Creating '${rctSdp.type}' successful`, rctSdp);

    const mappedSdp = z.calling.SDPMapper.rewriteSdp(rctSdp, z.calling.enum.SDP_SOURCE.LOCAL, this);
    this.localSdp(mappedSdp.sdp);
  }

  /**
   * Create a local SDP of type 'offer'.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer
   * @private
   * @param {boolean} iceRestart - Is ICE restart negotiation
   * @returns {undefined} No return value
   */
  _createSdpOffer(iceRestart) {
    this.negotiationNeeded(false);
    this._initializeDataChannel();

    const logMessage = {
      data: {
        default: [z.calling.rtc.SDP_TYPE.OFFER, this.remoteUser.name()],
        obfuscated: [z.calling.rtc.SDP_TYPE.OFFER, this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Creating '{0}' for flow with '{1}'`,
    };
    this.callLogger.debug(logMessage);

    this.peerConnection
      .createOffer(this._createOfferAnswerOptions(iceRestart))
      .then(rtcSdp => this._createSdpSuccess(rtcSdp))
      .catch(error => this._createSdpFailure(error, z.calling.rtc.SDP_TYPE.OFFER));
  }

  /**
   * Create the additional payload.
   * @private
   * @returns {Object} Additional payload
   */
  _createAdditionalPayload() {
    const payload = z.calling.CallMessageBuilder.createPayload(
      this.conversationId,
      this.selfUserId,
      this.remoteUserId,
      this.remoteClientId
    );
    const additionalPayload = Object.assign({remoteUser: this.remoteUser, sdp: this.localSdp().sdp}, payload);

    const selfState = this.callEntity.selfState;
    return z.calling.CallMessageBuilder.createPropSync(selfState, additionalPayload);
  }

  /**
   * Sets the local Session Description Protocol on the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _setLocalSdp() {
    this.sdpStateChanging(true);
    const localSdp = this.localSdp();
    this.callLogger.debug(`Setting local '${localSdp.type}' SDP`, localSdp);

    this.peerConnection
      .setLocalDescription(localSdp)
      .then(() => {
        this.callLogger.info(`Setting local '${localSdp.type}' SDP successful`, this.peerConnection.localDescription);
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET);

        this.shouldSetLocalSdp(false);
        this.sdpStateChanging(false);
        this._setSendSdpTimeout();
      })
      .catch(error => this._setSdpFailure(error, z.calling.enum.SDP_SOURCE.LOCAL, localSdp.type));
  }

  /**
   * Sets the remote Session Description Protocol on the PeerConnection.
   * @private
   * @returns {undefined} No return value
   */
  _setRemoteSdp() {
    this.sdpStateChanging(false);
    const remoteSdp = this.remoteSdp();
    this.callLogger.debug(`Setting remote '${remoteSdp.type}' SDP\n${remoteSdp.sdp}`, remoteSdp);

    this.peerConnection
      .setRemoteDescription(remoteSdp)
      .then(() => {
        const logMessage = `Setting remote '${remoteSdp.type}' SDP successful`;
        this.callLogger.info(logMessage, this.peerConnection.remoteDescription);
        this.telemetry.time_step(z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET);

        this.shouldSetRemoteSdp(false);
        this.sdpStateChanging(false);
      })
      .catch(error => this._setSdpFailure(error, z.calling.enum.SDP_SOURCE.REMOTE, remoteSdp.type));
  }

  /**
   * Failed to set SDP.
   *
   * @private
   * @param {Error} error - Error that was thrown
   * @param {z.calling.enum.SDP_SOURCE} sdpSource - Source of SDP
   * @param {z.calling.rtc.SDP_TYPE} sdpType - SDP type
   * @returns {undefined} No return value
   */
  _setSdpFailure(error, sdpSource, sdpType) {
    const {message, name} = error;

    const failedLocalSdp = sdpSource === z.calling.enum.SDP_SOURCE.LOCAL && !this.properLocalSdpState();
    const failedRemoteSdp = sdpSource === z.calling.enum.SDP_SOURCE.REMOTE && !this.properRemoteSdpState();

    const shouldSolveCollision = failedLocalSdp || failedRemoteSdp;
    if (shouldSolveCollision) {
      this._solveCollidingSdps(failedLocalSdp);
      return this.sdpStateChanging(false);
    }

    this.callLogger.error(`Setting ${sdpSource} '${sdpType}' SDP failed: ${name} - ${message}`, error);

    const attributes = {cause: name, location: sdpSource, step: 'set_sdp', type: sdpType};
    this.callEntity.telemetry.track_event(z.tracking.EventName.CALLING.FAILED_RTC, undefined, attributes);

    this._removeDroppedParticipant(z.calling.enum.TERMINATION_REASON.SDP_FAILED);
  }

  /**
   * Set the negotiation failed timeout.
   *
   * @private
   * @param {boolean} isInitialNegotiation - Is negotiation during initial call setup
   * @returns {undefined} No return value
   */
  _setNegotiationFailedTimeout(isInitialNegotiation) {
    const timeout = isInitialNegotiation
      ? z.calling.entities.CallEntity.CONFIG.STATE_TIMEOUT
      : FlowEntity.CONFIG.RENEGOTIATION_TIMEOUT;

    this.negotiationTimeout = window.setTimeout(() => {
      this.callLogger.info('Removing call participant on negotiation timeout');
      this._removeDroppedParticipant(z.calling.enum.TERMINATION_REASON.RENEGOTIATION);
    }, timeout + FlowEntity.CONFIG.NEGOTIATION_THRESHOLD);
  }

  /**
   * Set the negotiation restart timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setNegotiationRestartTimeout() {
    this.negotiationTimeout = window.setTimeout(() => {
      this.callEntity.terminationReason = z.calling.enum.TERMINATION_REASON.CONNECTION_DROP;
      this.participantEntity.isConnected(false);

      this.callEntity.interruptedParticipants.push(this.participantEntity);
      const isModeDefault = this.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.DEFAULT;
      if (isModeDefault) {
        this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.ICE_RESTART, false);
      }
    }, FlowEntity.CONFIG.RECONNECTION_TIMEOUT);
  }

  /**
   * Set the SDP send timeout.
   * @private
   * @returns {undefined} No return value
   */
  _setSendSdpTimeout() {
    this.sendSdpTimeout = window.setTimeout(() => this.sendLocalSdp(true), FlowEntity.CONFIG.SDP_SEND_TIMEOUT);
  }

  //##############################################################################
  // SDP state collision handling
  //##############################################################################

  /**
   * Solve colliding SDP states.
   *
   * @note If we receive a remote offer while we have a local offer, we need to check who needs to switch his SDP type.
   * @private
   * @param {boolean} [forceRenegotiation=false] - Force local renegotiation to switch to
   * @returns {boolean} False if we locally needed to switch sides
   */
  _solveCollidingStates(forceRenegotiation = false) {
    const logMessage = {
      data: {
        default: [this.selfUserId, this.remoteUserId, forceRenegotiation],
        obfuscated: [
          this.callLogger.obfuscate(this.selfUserId),
          this.callLogger.obfuscate(this.remoteUserId),
          forceRenegotiation,
        ],
      },
      message: `Solving state collision: Self user ID '{0}', remote user ID '{1}', forceRenegotiation '{2}'`,
    };
    this.callLogger.debug(logMessage);

    const selfUserIdLooses = this.selfUserId < this.remoteUserId;
    const shouldRenegotiate = selfUserIdLooses || forceRenegotiation;
    if (shouldRenegotiate) {
      const log = {
        data: {
          default: [this.remoteUser.name()],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `We need to switch SDP state of flow with '{0}' to answer.`,
      };
      this.callLogger.warn(log);

      this.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION, true);
      return forceRenegotiation || false;
    }

    const log = {
      data: {
        default: [this.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
      },
      message: `Remote side '{0}' needs to switch SDP state flow to answer.`,
    };
    this.callLogger.warn(log);

    return true;
  }

  /**
   * Solve colliding SDP states when setting SDP failed.
   * @private
   * @param {boolean} failedLocalSdp - Failed to set local SDP
   * @returns {undefined} No return value
   */
  _solveCollidingSdps(failedLocalSdp) {
    const remoteSdp = this.remoteSdp();

    if (!this._solveCollidingStates(failedLocalSdp)) {
      this.remoteSdp(remoteSdp);
    }
  }

  //##############################################################################
  // Media stream handling
  //##############################################################################

  /**
   * Replace the MediaStream attached to the PeerConnection.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Object containing the required MediaStream information
   * @param {MediaStream} outdatedMediaStream - Previous MediaStream
   * @returns {Promise} Resolves when negotiation has been restarted
   */
  replaceMediaStream(mediaStreamInfo, outdatedMediaStream) {
    const mediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    const negotiationMode = z.calling.enum.SDP_NEGOTIATION_MODE.STREAM_CHANGE;

    return Promise.resolve()
      .then(() => this._removeMediaStream(outdatedMediaStream))
      .then(() => this.restartNegotiation(negotiationMode, false, mediaStream))
      .then(() => this.callLogger.debug(`Replaced the '${mediaType}' track`))
      .catch(error => {
        this.callLogger.error(`Failed to replace local MediaStream: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Replace the MediaStreamTrack attached to the MediaStream of the PeerConnection.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Object containing the required MediaStream information
   * @returns {Promise} Resolves when a MediaStreamTrack has been replaced
   */
  replaceMediaTrack(mediaStreamInfo) {
    const mediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    const [mediaStreamTrack] = mediaStream.getTracks();

    return Promise.resolve()
      .then(() => this._getRtcSender(mediaType))
      .then(rtpSender => rtpSender.replaceTrack(mediaStreamTrack))
      .then(() => this.callLogger.debug(`Replaced the MediaStream containing '${mediaType}'`))
      .catch(error => {
        this.callLogger.error(`Failed to replace local MediaStreamTrack: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check for support of MediaStreamTrack replacement.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type to check replacement capability for
   * @returns {Promise<boolean>} Resolves when the replacement capability has been checked
   */
  supportsTrackReplacement(mediaType) {
    return Promise.resolve()
      .then(() => {
        const supportsGetSenders = typeof this.peerConnection.getSenders === 'function';
        return supportsGetSenders ? this._getRtcSender(mediaType) : false;
      })
      .then(rtpSender => !!rtpSender)
      .catch(() => false);
  }

  /**
   * Adds a local MediaStream to the PeerConnection.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to add to the PeerConnection
   * @returns {undefined} No return value
   */
  _addMediaStream(mediaStream) {
    if (mediaStream) {
      const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
      const containsAudio = z.media.MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_AUDIO.includes(mediaType);
      if (containsAudio) {
        mediaStream = this.audio.wrapAudioInputStream(mediaStream);
      }

      if (this.peerConnection.addTrack) {
        mediaStream.getTracks().forEach(mediaStreamTrack => {
          this.peerConnection.addTrack(mediaStreamTrack, mediaStream);

          this.callLogger.debug(`Added local '${mediaStreamTrack.kind}' MediaStreamTrack to PeerConnection`, {
            audioTracks: mediaStream.getAudioTracks(),
            stream: mediaStream,
            videoTracks: mediaStream.getVideoTracks(),
          });
        });
      } else {
        this.peerConnection.addStream(mediaStream);
        this.callLogger.debug(`Added local '${mediaStream.type}' MediaStream to PeerConnection`, {
          audioTracks: mediaStream.getAudioTracks(),
          stream: mediaStream,
          videoTracks: mediaStream.getVideoTracks(),
        });
      }
    } else {
      throw new Error('Failed to add MediaStream: Provided MediaStream undefined');
    }
  }

  /**
   * Get RTC Sender of matching type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested MediaType
   * @returns {RTCRtpSender} Matching RTC Rtp Sender
   */
  _getRtcSender(mediaType) {
    for (const rtpSender of this.peerConnection.getSenders()) {
      const mediaStreamTrack = rtpSender.track;

      const isExpectedType = mediaStreamTrack && mediaStreamTrack.kind === mediaType;
      if (isExpectedType) {
        const supportsReplaceTrack = typeof rtpSender.replaceTrack === 'function';
        if (supportsReplaceTrack) {
          return rtpSender;
        }

        throw new z.error.CallError(z.error.CallError.TYPE.RTP_SENDER_NOT_SUPPORTED);
      }
    }

    throw new z.error.CallError(z.error.CallError.TYPE.NO_REPLACEABLE_TRACK);
  }

  /**
   * Removes a MediaStreamTrack from the PeerConnection.
   *
   * @private
   * @param {string} trackId - ID of MediaStreamTrack
   * @param {z.media.MediaType} mediaType - MediaType of MediaStreamTrack
   * @returns {undefined} No return value
   */
  _removeMediaStreamTrack(trackId, mediaType) {
    for (const rtpSender of this.peerConnection.getSenders()) {
      const mediaStreamTrack = rtpSender.track;

      const isExpectedId = mediaStreamTrack && mediaStreamTrack.id === trackId;
      if (isExpectedId) {
        this.peerConnection.removeTrack(rtpSender);
        this.callLogger.debug(`Removed local '${mediaType}' MediaStreamTrack from PeerConnection`);
        break;
      }
    }
  }

  /**
   * Remove all MediaStreamTracks of a MediaStream from the PeerConnection.
   *
   * @private
   * @param {MediaStream} mediaStream - Local MediaStream to remove from the PeerConnection
   * @returns {undefined} No return value
   */
  _removeMediaStreamTracks(mediaStream) {
    mediaStream
      .getTracks()
      .forEach(({id: trackId, kind: mediaType}) => this._removeMediaStreamTrack(trackId, mediaType));
  }

  /**
   * Remove the MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - Local MediaStream to stop
   * @returns {undefined} No return value
   */
  _removeMediaStream(mediaStream) {
    if (this.peerConnection) {
      const signalingStateStable = this.peerConnection.signalingState === z.calling.rtc.SIGNALING_STATE.STABLE;
      const supportsRemoveTrack = typeof this.peerConnection.removeTrack === 'function';
      if (signalingStateStable && supportsRemoveTrack) {
        return this._removeMediaStreamTracks(mediaStream);
      }

      const isSignalingStateClosed = this.peerConnection.signalingState === z.calling.rtc.SIGNALING_STATE.CLOSED;
      const supportsRemoveStream = typeof this.peerConnection.removeStream === 'function';
      if (!isSignalingStateClosed && supportsRemoveStream) {
        this.peerConnection.removeStream(mediaStream);
        const mediaType = z.media.MediaStreamHandler.detectMediaStreamType(mediaStream);
        this.callLogger.debug(`Removed local '${mediaType}' MediaStream from PeerConnection`, {
          audioTracks: mediaStream.getAudioTracks(),
          stream: mediaStream,
          videoTracks: mediaStream.getVideoTracks(),
        });
      }
    }
  }

  //##############################################################################
  // Reset
  //##############################################################################

  /**
   * Clear the timeouts.
   * @returns {undefined} No return value
   */
  clearTimeouts() {
    this._clearNegotiationTimeout();
    this._clearSendSdpTimeout();
  }

  /**
   * Reset the flow.
   * @returns {undefined} No return value
   */
  resetFlow() {
    if (this.mediaStream()) {
      this._removeMediaStream(this.mediaStream());
    }

    if (this.pcInitialized()) {
      const logMessage = {
        data: {
          default: [this.remoteUser.id],
          obfuscated: [this.callLogger.obfuscate(this.remoteUser.id)],
        },
        message: `Resetting flow with user '{0}'`,
      };
      this.callLogger.debug(logMessage);

      this.remoteClientId = undefined;
      this.telemetry.disconnected();

      this.clearTimeouts();
      this.iceCandidatesGatheringAttempts = 1;
      this._closeDataChannel();
      this._closePeerConnection();
      this._resetSignalingStates();
      this._resetSdp();
      this.pcInitialized(false);
    }
  }

  /**
   * Reset the SDP.
   * @private
   * @returns {undefined} No return value
   */
  _resetSdp() {
    this.localSdp(undefined);
    this.remoteSdp(undefined);
  }

  /**
   * Reset the signaling states.
   * @private
   * @returns {undefined} No return value
   */
  _resetSignalingStates() {
    this.connectionState(z.calling.rtc.ICE_CONNECTION_STATE.NEW);
    this.gatheringState(z.calling.rtc.ICE_GATHERING_STATE.NEW);
    this.signalingState(z.calling.rtc.SIGNALING_STATE.NEW);
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Get full telemetry report for automation.
   * @returns {Object} Automation report
   */
  getTelemetry() {
    return this.telemetry.get_automation_report();
  }

  /**
   * Log flow status to console.
   * @returns {undefined} No return value
   */
  logStatus() {
    this.telemetry.log_status(this.participantEntity);
  }

  /**
   * Log flow setup step timings to console.
   * @returns {undefined} No return value
   */
  logTimings() {
    this.telemetry.log_timings();
  }

  /**
   * Report flow status to Raygun.
   * @returns {undefined} No return value
   */
  reportStatus() {
    this.telemetry.report_status();
  }

  /**
   * Report flow setup step timings to Raygun.
   * @returns {undefined} No return value
   */
  reportTimings() {
    this.telemetry.report_timings();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.FlowAudioEntity = class FlowAudioEntity {
  /**
   * Create a new flow audio.
   *
   * @class z.calling.entities.FlowAudioEntity
   * @param {z.calling.entities.FlowEntity} flowEntity - Flow entity
   * @param {MediaRepository} mediaRepository - Media repository
   */
  constructor(flowEntity, mediaRepository) {
    this.setGainNode = this.setGainNode.bind(this);

    this.flowEntity = flowEntity;
    this.mediaRepository = mediaRepository;

    this.messageLog = this.flowEntity.messageLog;

    const id = this.flowEntity.id;
    const loggerName = 'z.calling.entities.FlowAudio';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info({
      data: {
        default: [this.flowEntity.remoteUser.name()],
        obfuscated: [this.callLogger.obfuscate(this.flowEntity.remoteUser.id)],
      },
      message: `Created new flow audio entity for user {0}`,
    });

    this.audioContext = undefined;

    // Panning
    this.panning = this.flowEntity.participantEntity.panning;
    this.panning.subscribe(updatedPanningValue => {
      this.callLogger.debug({
        data: {
          default: [this.flowEntity.remoteUser.name(), updatedPanningValue],
          obfuscated: [this.callLogger.obfuscate(this.flowEntity.remoteUser.id), updatedPanningValue],
        },
        message: `Panning of {0} changed to '{1}'`,
      });

      this.setPan(updatedPanningValue);
    });

    this.panNode = undefined;
    this.gainNode = undefined;
    this.audioSource = undefined;
    this.audioRemote = undefined;

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.MUTE_AUDIO, this.setGainNode);
  }

  /**
   * Hookup flow audio.
   * @param {boolean} isActive - Whether the flow is active
   * @returns {undefined} No return value
   */
  hookup(isActive) {
    if (isActive) {
      return this._hookupAudio();
    }

    if (this.audioSource) {
      this.audioSource.disconnect();
    }
  }

  /**
   * Set muted state on gain node.
   * @param {boolean} isMuted - Muted state
   * @returns {undefined} No return value
   */
  setGainNode(isMuted) {
    if (this.gainNode) {
      this.gainNode.gain.value = isMuted ? 0 : 1;
      this.callLogger.debug(`Outgoing audio on flow muted '${isMuted}'`);
    }
  }

  /**
   * Set pan value.
   * @param {number} panningValue - Updated panning value
   * @returns {undefined} No return value
   */
  setPan(panningValue) {
    if (this.panNode) {
      this.panNode.pan.value = panningValue;
    }
  }

  /**
   * Wrap audio input stream.
   * @param {MediaStream} mediaStream - MediaStream to wrap
   * @returns {MediaStream} Wrapped MediaStream
   */
  wrapAudioInputStream(mediaStream) {
    const audioContext = this._getAudioContext();

    if (audioContext) {
      this.audioSource = audioContext.createMediaStreamSource(mediaStream);
      this.gainNode = audioContext.createGain();
      this.audioRemote = audioContext.createMediaStreamDestination();
      this._hookupAudio();

      Object.assign(mediaStream, this.audioRemote.stream);
      this.callLogger.debug('Wrapped audio stream from microphone', mediaStream);
    }

    return mediaStream;
  }

  /**
   * Wrap audio output stream.
   * @param {MediaStream} mediaStream - MediaStream to wrap
   * @returns {MediaStream} Wrapped MediaStream
   */
  wrapAudioOutputStream(mediaStream) {
    if (z.util.Environment.browser.firefox) {
      const audioContext = this._getAudioContext();

      if (audioContext) {
        const remoteSource = audioContext.createMediaStreamSource(mediaStream);
        const audioOutputDevice = audioContext.createMediaStreamDestination();

        this.panNode = audioContext.createStereoPanner();
        this.panNode.pan.value = this.panning();

        remoteSource.connect(this.panNode);
        this.panNode.connect(audioOutputDevice);

        Object.assign(mediaStream, audioOutputDevice.stream);
        const logMessage = `Wrapped audio stream to speaker for stereo. Initial panning set to '${this.panning()}'.`;
        this.callLogger.debug(logMessage, mediaStream);
      }
    }

    return mediaStream;
  }

  /**
   * Get running AudioContext.
   * @returns {AudioContext} Active AudioContext
   */
  _getAudioContext() {
    if (!this.audioContext || this.audioContext.state === z.media.MediaRepository.AUDIO_CONTEXT_STATE.CLOSED) {
      this.audioContext = this.mediaRepository.getAudioContext();
    }
    return this.audioContext;
  }

  /**
   * Hookup flow audio.
   * @private
   * @returns {undefined} No return value
   */
  _hookupAudio() {
    if (this.audioSource && this.gainNode) {
      this.audioSource.connect(this.gainNode);
      this.gainNode.connect(this.audioRemote);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};
window.z.calling.entities = z.calling.entities || {};

z.calling.entities.ParticipantEntity = class ParticipantEntity {
  static get CONFIG() {
    return {
      PROPERTY_STATES: {
        ACTIVE: [z.calling.enum.PROPERTY_STATE.PAUSED, z.calling.enum.PROPERTY_STATE.TRUE],
        EXPECTED: [
          z.calling.enum.PROPERTY_STATE.FALSE,
          z.calling.enum.PROPERTY_STATE.PAUSED,
          z.calling.enum.PROPERTY_STATE.TRUE,
        ],
      },
    };
  }
  /**
   * Construct a new participant.
   *
   * @class z.calling.entities.ParticipantEntity
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.entity.User} user - User entity to base the participant on
   * @param {CallSetupTimings} timings - Timing statistics of call setup steps
   */
  constructor(callEntity, user, timings) {
    this.callEntity = callEntity;
    this.user = user;

    this.id = this.user.id;
    this.messageLog = this.callEntity.messageLog;
    this.sessionId = undefined;

    const loggerName = 'z.calling.entities.ParticipantEntity';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, this.id, z.config.LOGGER.OPTIONS, this.messageLog);

    this.callLogger.info(`Created new participant entity for user ${this.id}`);

    this.isConnected = ko.observable(false);
    this.panning = ko.observable(0.0);
    this.wasConnected = false;

    this.state = {
      audioSend: ko.observable(z.calling.enum.PROPERTY_STATE.TRUE),
      screenSend: ko.observable(z.calling.enum.PROPERTY_STATE.FALSE),
      videoSend: ko.observable(z.calling.enum.PROPERTY_STATE.FALSE),
    };

    this.activeState = {
      audioSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.audioSend());
      }),
      screenSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.screenSend());
      }),
      videoSend: ko.pureComputed(() => {
        return ParticipantEntity.CONFIG.PROPERTY_STATES.ACTIVE.includes(this.state.videoSend());
      }),
    };

    this.hasActiveVideo = ko.pureComputed(() => this.activeState.screenSend() || this.activeState.videoSend());

    this.flowEntity = new z.calling.entities.FlowEntity(this.callEntity, this, timings);

    this.isConnected.subscribe(isConnected => {
      if (isConnected && !this.wasConnected) {
        amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.READY_TO_TALK);
        this.wasConnected = true;
      }
    });
  }

  /**
   * Reset the participant.
   * @returns {undefined} No return value
   */
  resetParticipant() {
    if (this.flowEntity) {
      this.flowEntity.resetFlow();
    }
  }

  /**
   * Start negotiating the peer connection.
   * @returns {undefined} No return value
   */
  startNegotiation() {
    this.flowEntity.startNegotiation();
  }

  /**
   * Update the participant state.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to update state from.
   * @returns {Promise} Resolves when the state was updated
   */
  updateState(callMessageEntity) {
    const {clientId, properties, sdp: rtcSdp, sessionId, type} = callMessageEntity;

    return this.updateProperties(properties).then(() => {
      this.sessionId = sessionId;
      this.flowEntity.setRemoteClientId(clientId);

      const isGroupStart = type === z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START;
      if (isGroupStart && this.flowEntity.pcInitialized()) {
        this.flowEntity.restartNegotiation(z.calling.enum.SDP_NEGOTIATION_MODE.STATE_COLLISION, false);
      }

      return rtcSdp ? this.flowEntity.saveRemoteSdp(callMessageEntity) : false;
    });
  }

  /**
   * Update the state properties
   * @param {Object} properties - Properties to update with
   * @returns {Promise} Resolves when the properties have been updated
   */
  updateProperties(properties) {
    return Promise.resolve().then(() => {
      if (properties) {
        const {audiosend, screensend, videosend} = properties;

        const hasAudioSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(audiosend);
        if (hasAudioSend) {
          this.state.audioSend(audiosend);
        }

        const hasScreenSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(screensend);
        if (hasScreenSend) {
          this.state.screenSend(screensend);
        }

        const hasVideoSend = ParticipantEntity.CONFIG.PROPERTY_STATES.EXPECTED.includes(videosend);
        if (hasVideoSend) {
          this.state.videoSend(videosend);
        }
      }
    });
  }

  /**
   * Verify client IDs match.
   * @param {string} clientId - Client ID to match with participant one
   * @returns {undefined} No return value
   */
  verifyClientId(clientId) {
    if (clientId) {
      const connectedClientId = this.flowEntity.remoteClientId;

      const isExpectedId = clientId === connectedClientId;
      const requestedByWrongSender = connectedClientId && !isExpectedId;
      if (requestedByWrongSender) {
        const logMessage = {
          data: {
            default: [clientId, connectedClientId],
            obfuscated: [this.callLogger.obfuscate(clientId), this.callLogger.obfuscate(connectedClientId)],
          },
          message: `State change requested from '{0}' while we are connected to '{1}'`,
        };
        this.callLogger.warn(logMessage, this);
        throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER);
      }

      this.flowEntity.remoteClientId = clientId;
    } else {
      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Sender ID missing');
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallingRepository = class CallingRepository {
  static get CONFIG() {
    return {
      DATA_CHANNEL_MESSAGE_TYPES: [z.calling.enum.CALL_MESSAGE_TYPE.HANGUP, z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC],
      DEFAULT_CONFIG_TTL: 60 * 60, // 60 minutes in seconds
      MAX_FIREFOX_TURN_COUNT: 3,
      MAX_VIDEO_PARTICIPANTS: 4,
      PROTOCOL_VERSION: '3.0',
    };
  }

  /**
   * Extended check for calling support of browser.
   * @returns {boolean} True if calling is supported
   */
  static get supportsCalling() {
    return z.util.Environment.browser.supports.calling;
  }

  /**
   * Extended check for screen sharing support of browser.
   * @returns {boolean} True if screen sharing is supported
   */
  static get supportsScreenSharing() {
    return z.util.Environment.browser.supports.screenSharing;
  }

  /**
   * Construct a new Calling repository.
   *
   * @param {CallingService} callingService -  Backend REST API calling service implementation
   * @param {ClientRepository} clientRepository - Repository for client interactions
   * @param {ConversationRepository} conversationRepository -  Repository for conversation interactions
   * @param {EventRepository} eventRepository -  Repository that handles events
   * @param {MediaRepository} mediaRepository -  Repository for media interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {UserRepository} userRepository -  Repository for all user interactions
   */
  constructor(
    callingService,
    clientRepository,
    conversationRepository,
    eventRepository,
    mediaRepository,
    serverTimeRepository,
    userRepository
  ) {
    this.getConfig = this.getConfig.bind(this);

    this.callingService = callingService;
    this.clientRepository = clientRepository;
    this.conversationRepository = conversationRepository;
    this.eventRepository = eventRepository;
    this.mediaRepository = mediaRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;

    this.messageLog = [];
    const loggerName = 'z.calling.CallingRepository';
    this.callLogger = new z.telemetry.calling.CallLogger(loggerName, null, z.config.LOGGER.OPTIONS, this.messageLog);

    this.selfUserId = ko.pureComputed(() => {
      if (this.userRepository.self()) {
        return this.userRepository.self().id;
      }
    });

    this.callingConfig = undefined;
    this.callingConfigTimeout = undefined;

    // Telemetry
    this.telemetry = new z.telemetry.calling.CallTelemetry();

    // Media Handler
    this.mediaDevicesHandler = this.mediaRepository.devicesHandler;
    this.mediaStreamHandler = this.mediaRepository.streamHandler;
    this.mediaElementHandler = this.mediaRepository.elementHandler;

    this.selfStreamState = this.mediaStreamHandler.selfStreamState;

    this.calls = ko.observableArray([]);
    this.joinedCall = ko.pureComputed(() => {
      for (const callEntity of this.calls()) {
        if (callEntity.selfClientJoined()) {
          return callEntity;
        }
      }
    });

    this.flowStatus = undefined;

    this.shareCallStates();
    this.subscribeToEvents();
    this._enableDebugging();
  }

  /**
   * Share call states with MediaRepository.
   * @returns {undefined} No return value
   */
  shareCallStates() {
    this.calls.subscribe(callEntities => this.mediaStreamHandler.updateCurrentCalls(callEntities));
    this.joinedCall.subscribe(joinedCallEntity => this.mediaStreamHandler.setJoinedCall(joinedCallEntity));
  }

  /**
   * Subscribe to amplify topics.
   * @returns {undefined} No return value
   */
  subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.CALL.EVENT_FROM_BACKEND, this.onCallEvent.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.MEDIA.TOGGLE, this.toggleMedia.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.DELETE, this.deleteCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.JOIN, this.joinCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.LEAVE, this.leaveCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.REJECT, this.rejectCall.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.REMOVE_PARTICIPANT, this.removeParticipant.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.STATE.TOGGLE, this.toggleState.bind(this));
    amplify.subscribe(z.event.WebApp.DEBUG.UPDATE_LAST_CALL_STATUS, this.storeFlowStatus.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.getConfig);
  }

  //##############################################################################
  // Inbound call events
  //##############################################################################

  /**
   * Handle incoming calling events from backend.
   *
   * @param {Object} event - Event payload
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onCallEvent(event, source) {
    const {content: eventContent, time: eventDate, type: eventType} = event;
    const isCall = eventType === z.event.Client.CALL.E_CALL;

    const logObject = {eventJson: JSON.stringify(event), eventObject: event};
    this.callLogger.info(`»» Call Event: '${eventType}' (Source: ${source})`, logObject);

    if (isCall) {
      const isSupportedVersion = eventContent.version === z.calling.entities.CallMessageEntity.CONFIG.VERSION;
      if (!isSupportedVersion) {
        throw new z.error.CallError(z.error.CallError.TYPE.UNSUPPORTED_VERSION);
      }

      const callMessageEntity = z.calling.CallMessageMapper.mapEvent(event);
      this._logMessage(false, callMessageEntity, eventDate);

      this._validateMessageType(callMessageEntity)
        .then(conversationEntity => {
          const isBackendTimestamp = source !== z.event.EventRepository.SOURCE.INJECTED;
          conversationEntity.update_timestamp_server(callMessageEntity.time, isBackendTimestamp);
        })
        .then(() => {
          return z.calling.CallingRepository.supportsCalling
            ? this._onCallEventInSupportedBrowsers(callMessageEntity, source)
            : this._onCallEventInUnsupportedBrowsers(callMessageEntity, source);
        });
    }
  }

  /**
   * Call event handling for browsers supporting calling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Mapped incoming call message entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCallEventInSupportedBrowsers(callMessageEntity, source) {
    const messageType = callMessageEntity.type;

    switch (messageType) {
      case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
        return this._onCancel(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK: {
        return this._onGroupCheck(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE: {
        return this._onGroupLeave(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP: {
        return this._onGroupSetup(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START: {
        return this._onGroupStart(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP: {
        return this._onHangup(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        return this._onPropSync(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.REJECT: {
        return this._onReject(callMessageEntity);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
        return this._onSetup(callMessageEntity, source);
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
        return this._onUpdate(callMessageEntity);
      }

      default: {
        this.callLogger.warn(`Call event of unknown type '${messageType}' was ignored`, callMessageEntity);
      }
    }
  }

  /**
   * Call event handling for browsers not supporting calling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Mapped incoming call message entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCallEventInUnsupportedBrowsers(callMessageEntity, source) {
    const {response, type, userId} = callMessageEntity;

    if (!response) {
      switch (type) {
        case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
          this.injectActivateEvent(callMessageEntity, source);
          this.userRepository.get_user_by_id(userId).then(userEntity => {
            const warningOptions = {name: userEntity.name()};
            const warningType = z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_INCOMING_CALL;

            amplify.publish(z.event.WebApp.WARNING.SHOW, warningType, warningOptions);
          });
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_INCOMING_CALL);
          break;
        }

        default: {
          break;
        }
      }
    }
  }

  /**
   * Call cancel message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.CANCEL
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onCancel(callMessageEntity, source) {
    const {clientId, conversationId, response, userId} = callMessageEntity;

    if (!response) {
      const terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER;
      this.getCallById(conversationId)
        .then(callEntity => callEntity.verifySessionId(callMessageEntity))
        .then(callEntity => callEntity.deleteParticipant(userId, clientId, terminationReason))
        .then(callEntity => {
          const fromSelf = userId === this.selfUserId();
          return callEntity.deactivateCall(callMessageEntity, fromSelf, terminationReason).then(wasDeleted => {
            if (!wasDeleted && fromSelf) {
              callEntity.state(z.calling.enum.CALL_STATE.REJECTED);
            }
          });
        })
        .catch(error => {
          const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
          if (!isNotFound) {
            throw error;
          }
        });
    }
  }

  /**
   * Call group check message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onGroupCheck(callMessageEntity, source) {
    this.getCallById(callMessageEntity.conversationId)
      .then(callEntity => callEntity.scheduleGroupCheck())
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call group leave message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE
   * @param {z.calling.enum.TERMINATION_REASON} [terminationReason=z.calling.enum.TERMINATION_REASON.OTHER_USER] - Reason for participant to leave
   * @returns {undefined} No return value
   */
  _onGroupLeave(callMessageEntity, terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER) {
    const {conversationId, clientId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        if (callEntity.isOutgoing()) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Remote user leaving outgoing call');
        }

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          callEntity.selfUserJoined(false);
          return callEntity;
        }

        return callEntity.deleteParticipant(userId, clientId, terminationReason);
      })
      .then(callEntity => callEntity.participantLeft(callMessageEntity, terminationReason))
      .catch(this._throwMessageError);
  }

  /**
   * Call group setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP
   * @returns {undefined} No return value
   */
  _onGroupSetup(callMessageEntity) {
    const {conversationId, response, userId} = callMessageEntity;

    // @todo Grant message for ongoing call
    this.getCallById(conversationId)
      .then(callEntity => this._validateMessageDestination(callEntity, callMessageEntity))
      .then(callEntity => {
        callEntity.setRemoteVersion(callMessageEntity);
        const shouldNegotiate = response !== true;
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity);
      })
      .catch(this._throwMessageError);
  }

  /**
   * Call group start message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onGroupStart(callMessageEntity, source) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        // @todo Grant message for ongoing call

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          return this._remoteSelfJoin(callEntity, callMessageEntity);
        }

        if (callEntity.isOutgoing()) {
          callEntity.state(z.calling.enum.CALL_STATE.CONNECTING);
        }

        // Add the correct participant, start negotiating
        const shouldNegotiate = callEntity.selfClientJoined();
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity);
      })
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call hangup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.HANGUP
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for the participant to hangup
   * @returns {undefined} No return value
   */
  _onHangup(callMessageEntity, terminationReason = z.calling.enum.TERMINATION_REASON.OTHER_USER) {
    const {conversationId, clientId, response, userId} = callMessageEntity;

    if (!response) {
      this.getCallById(conversationId)
        .then(callEntity => callEntity.verifySessionId(callMessageEntity))
        .then(callEntity => this._confirmCallMessage(callEntity, callMessageEntity))
        .then(callEntity => callEntity.deleteParticipant(userId, clientId, terminationReason))
        .then(callEntity => callEntity.participantLeft(callMessageEntity, terminationReason))
        .catch(this._throwMessageError);
    }
  }

  /**
   * Call prop-sync message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {undefined} No return value
   */
  _onPropSync(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => callEntity.verifySessionId(callMessageEntity))
      .then(callEntity => this._confirmCallMessage(callEntity, callMessageEntity))
      .then(callEntity => callEntity.addOrUpdateParticipant(userId, false, callMessageEntity))
      .catch(this._throwMessageError);
  }

  /**
   * Call reject message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.REJECT
   * @returns {undefined} No return value
   */
  _onReject(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        const isSelfUser = userId !== this.selfUserId();
        if (!isSelfUser) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_SENDER, 'Call rejected by wrong user');
        }

        if (!callEntity.selfClientJoined()) {
          this.callLogger.info(`Rejecting call in conversation '${conversationId}'`, callEntity);
          callEntity.rejectCall(false);
        }
      })
      .catch(this._throwMessageError);
  }

  /**
   * Call setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _onSetup(callMessageEntity, source) {
    const {conversationId, response, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => {
        callEntity.setRemoteVersion(callMessageEntity);

        const isSelfUser = userId === this.selfUserId();
        if (isSelfUser) {
          return this._remoteSelfJoin(callEntity, callMessageEntity);
        }

        const shouldNegotiate = response !== true;
        return callEntity.addOrUpdateParticipant(userId, shouldNegotiate, callMessageEntity).then(() => {
          if (response) {
            callEntity.state(z.calling.enum.CALL_STATE.CONNECTING);
          }
        });
      })
      .catch(error => this._validateIncomingCall(callMessageEntity, source, error));
  }

  /**
   * Call setup message handling.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {undefined} No return value
   */
  _onUpdate(callMessageEntity) {
    const {conversationId, userId} = callMessageEntity;

    this.getCallById(conversationId)
      .then(callEntity => this._validateMessageDestination(callEntity, callMessageEntity))
      .then(callEntity => callEntity.verifySessionId(callMessageEntity))
      .then(callEntity => callEntity.addOrUpdateParticipant(userId, false, callMessageEntity))
      .catch(this._throwMessageError);
  }

  /**
   * Handle remote self join message.
   *
   * @private
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity from remote self client
   * @returns {Promise} Resolves when self join was handled
   */
  _remoteSelfJoin(callEntity, callMessageEntity) {
    const conversationEntity = callEntity.conversationEntity;

    if (callEntity.selfClientJoined()) {
      const logMessage = {
        data: {
          default: [conversationEntity.display_name()],
          obfuscated: [this.callLogger.obfuscate(conversationEntity.id)],
        },
        message: `Attempt to join ongoing call in conversation '{0}' from other device`,
      };

      this.callLogger.warn(logMessage, callEntity);
    } else {
      const logMessage = {
        data: {
          default: [conversationEntity.display_name()],
          obfuscated: [this.callLogger.obfuscate(conversationEntity.id)],
        },
        message: `Call in conversation '{0}' accepted on other device`,
      };
      this.callLogger.info(logMessage, callEntity);

      if (callEntity.isGroup) {
        callEntity.selfUserJoined(true);
        callEntity.wasConnected = true;
        return callEntity.rejectCall(false);
      }

      return this.deleteCall(conversationEntity.id);
    }
  }

  /**
   * Throw error is not expected types.
   *
   * @private
   * @param {z.error.CallError|Error} error - Error thrown during call message handling
   * @returns {undefined} No return value
   */
  _throwMessageError(error) {
    const expectedErrorTypes = [z.error.CallError.TYPE.MISTARGETED_MESSAGE, z.error.CallError.TYPE.NOT_FOUND];
    const isExpectedError = expectedErrorTypes.includes(error.type);

    if (!isExpectedError) {
      throw error;
    }
  }

  /**
   * Verify validity of incoming call.
   *
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.error.CallError|Error} error - Error thrown during call message handling
   * @returns {undefined} No return value
   */
  _validateIncomingCall(callMessageEntity, source, error) {
    this._throwMessageError(error);

    const {conversationId, response, type, userId} = callMessageEntity;

    const isTypeGroupCheck = type === z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK;
    const isSelfUser = userId === this.selfUserId();
    const validMessage = response === isTypeGroupCheck;

    if (!isSelfUser && validMessage) {
      const eventFromStream = source === z.event.EventRepository.SOURCE.STREAM;
      const silentCall = isTypeGroupCheck || eventFromStream;
      const promises = [this._createIncomingCall(callMessageEntity, source, silentCall)];

      if (!eventFromStream) {
        const eventInfoEntity = new z.conversation.EventInfoEntity(undefined, conversationId, {recipients: [userId]});
        eventInfoEntity.setType(z.cryptography.GENERIC_MESSAGE_TYPE.CALLING);
        const consentType = z.conversation.ConversationRepository.CONSENT_TYPE.INCOMING_CALL;
        const grantPromise = this.conversationRepository.grantMessage(eventInfoEntity, consentType);

        promises.push(grantPromise);
      }

      Promise.all(promises)
        .then(([callEntity, grantedCall]) => {
          if (grantedCall) {
            const mediaType = callEntity.isRemoteVideoCall() ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
            this.joinCall(conversationId, mediaType);
          }
        })
        .catch(_error => {
          const isDegraded = _error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
          if (!isDegraded) {
            throw _error;
          }

          this.rejectCall(conversationId);
        });
    }
  }

  /**
   * Validate that content of call message is targeted at local client.
   * @param {z.calling.entities.CallEntity} callEntity - Call the message belongs to
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @returns {CallEntity} Call entity if message is valid
   */
  _validateMessageDestination(callEntity, callMessageEntity) {
    if (callEntity.isGroup) {
      const {destinationClientId: clientId, destinationUserId: userId, type} = callMessageEntity;

      const isSelfUser = userId === this.selfUserId();
      const isCurrentClient = clientId === this.clientRepository.currentClient().id;
      const mistargetedMessage = !isSelfUser || !isCurrentClient;
      if (mistargetedMessage) {
        this.callLogger.log(`Ignored '${type}' call message for targeted at client '${clientId}' of user '${userId}'`);
        throw new z.error.CallError(z.error.CallError.TYPE.MISTARGETED_MESSAGE);
      }
    }

    return callEntity;
  }

  /**
   * Validate that type of call message matches conversation type.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to validate
   * @returns {Promise} Resolves if the message is valid
   */
  _validateMessageType(callMessageEntity) {
    const {conversationId, type} = callMessageEntity;

    return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
      if (conversationEntity.is1to1()) {
        const groupMessageTypes = [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP,
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
        ];

        if (groupMessageTypes.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
        }
      } else if (conversationEntity.isGroup()) {
        const one2oneMessageTypes = [z.calling.enum.CALL_MESSAGE_TYPE.SETUP];

        if (one2oneMessageTypes.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
        }
      } else {
        throw new z.error.CallError(z.error.CallError.TYPE.WRONG_CONVERSATION_TYPE);
      }

      return conversationEntity;
    });
  }

  //##############################################################################
  // Outbound call events
  //##############################################################################

  /**
   * Send a call event.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to send message in
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity
   * @returns {Promise} Resolves when the event has been sent
   */
  sendCallMessage(conversationEntity, callMessageEntity) {
    if (!_.isObject(callMessageEntity)) {
      throw new z.error.CallError(z.error.CallError.TYPE.WRONG_PAYLOAD_FORMAT);
    }

    const {conversationId, remoteUserId, response, type} = callMessageEntity;

    return this.getCallById(conversationId || conversationEntity.id)
      .then(callEntity => {
        if (!CallingRepository.CONFIG.DATA_CHANNEL_MESSAGE_TYPES.includes(type)) {
          throw new z.error.CallError(z.error.CallError.TYPE.NO_DATA_CHANNEL);
        }

        return callEntity.getParticipantById(remoteUserId);
      })
      .then(({flowEntity}) => flowEntity.sendMessage(callMessageEntity))
      .catch(error => {
        const expectedErrorTypes = [z.error.CallError.TYPE.NO_DATA_CHANNEL, z.error.CallError.TYPE.NOT_FOUND];
        const isExpectedError = expectedErrorTypes.includes(error.type);

        if (!isExpectedError) {
          throw error;
        }

        return this._limitMessageRecipients(callMessageEntity).then(({precondition, recipients}) => {
          const isTypeHangup = type === z.calling.enum.CALL_MESSAGE_TYPE.HANGUP;
          if (isTypeHangup) {
            if (response) {
              throw error;
            }

            callMessageEntity.type = z.calling.enum.CALL_MESSAGE_TYPE.CANCEL;
          }

          this._logMessage(true, callMessageEntity);

          const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
          const protoCalling = new z.proto.Calling(callMessageEntity.toContentString());
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CALLING, protoCalling);

          const options = {precondition, recipients};
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id, options);

          return this.conversationRepository.sendCallingMessage(eventInfoEntity, conversationEntity, callMessageEntity);
        });
      });
  }

  /**
   *
   * @private
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {z.calling.entities.CallMessageEntity} incomingCallMessageEntity - Incoming call message
   * @returns {Promise} Resolves with the call
   */
  _confirmCallMessage(callEntity, incomingCallMessageEntity) {
    const response = incomingCallMessageEntity.response;

    const skipConfirmation = response || !callEntity.selfClientJoined();
    return skipConfirmation
      ? Promise.resolve(callEntity)
      : callEntity
          .confirmMessage(incomingCallMessageEntity)
          .catch(error => {
            const isNotDataChannel = error.type === z.error.CallError.TYPE.NO_DATA_CHANNEL;
            if (!isNotDataChannel) {
              throw error;
            }
          })
          .then(() => callEntity);
  }

  /**
   * Limit the message recipients for a call message.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to target at clients
   * @returns {Promise} Resolves with the client user map and precondition option
   */
  _limitMessageRecipients(callMessageEntity) {
    const {remoteClientId, remoteUser, remoteUserId, response, type} = callMessageEntity;
    const recipientsPromise = remoteUserId
      ? this.userRepository.get_user_by_id(remoteUserId)
      : Promise.resolve(remoteUser);

    return recipientsPromise.then(remoteUserEntity => {
      const selfUserEntity = this.userRepository.self();
      let precondition;
      let recipients;

      switch (type) {
        case z.calling.enum.CALL_MESSAGE_TYPE.CANCEL: {
          if (response) {
            // Send to remote client that initiated call
            precondition = true;
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
            };
          } else {
            // Send to all clients of remote user
            precondition = [remoteUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: remoteUserEntity.devices().map(device => device.id),
            };
          }
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP:
        case z.calling.enum.CALL_MESSAGE_TYPE.HANGUP:
        case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC:
        case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
          // Send to remote client that call is connected with
          if (remoteClientId) {
            precondition = true;
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
            };
          }
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.REJECT: {
          // Send to all clients of self user
          precondition = [selfUserEntity.id];
          recipients = {
            [selfUserEntity.id]: selfUserEntity.devices().map(device => device.id),
          };
          break;
        }

        case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
          if (response) {
            // Send to remote client that initiated call and all clients of self user
            precondition = [selfUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: [`${remoteClientId}`],
              [selfUserEntity.id]: selfUserEntity.devices().map(device => device.id),
            };
          } else {
            // Send to all clients of remote user
            precondition = [remoteUserEntity.id];
            recipients = {
              [remoteUserEntity.id]: remoteUserEntity.devices().map(device => device.id),
            };
          }
          break;
        }

        default: {
          break;
        }
      }

      return {precondition, recipients};
    });
  }

  //##############################################################################
  // Call actions
  //##############################################################################

  /**
   * Delete a call.
   * @param {string} conversationId - ID of conversation to delete call from
   * @returns {undefined} No return value
   */
  deleteCall(conversationId) {
    this.getCallById(conversationId)
      .then(callEntity => this._deleteCall(callEntity))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Join a call.
   *
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @returns {undefined} No return value
   */
  joinCall(conversationId, mediaType) {
    this.getCallById(conversationId)
      .then(callEntity => ({callEntity, callState: callEntity.state()}))
      .catch(error => {
        this._handleNotFoundError(error);
        return {callState: z.calling.enum.CALL_STATE.OUTGOING};
      })
      .then(({callEntity, callState}) => this._joinCall(conversationId, mediaType, callState, callEntity))
      .catch(error => this._handleJoinCallError(error, conversationId));
  }

  /**
   * User action to leave a call.
   *
   * @param {string} conversationId - ID of conversation to leave call in
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call termination
   * @returns {undefined} No return value
   */
  leaveCall(conversationId, terminationReason) {
    this.getCallById(conversationId)
      .then(callEntity => {
        const leftConversation = terminationReason === z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE;
        return leftConversation ? this._deleteCall(callEntity) : this._leaveCall(callEntity, terminationReason);
      })
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Remove a participant from a call if he was removed from the group.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} userId - ID of user to be removed
   * @returns {undefined} No return value
   */
  removeParticipant(conversationId, userId) {
    this.getCallById(conversationId)
      .then(callEntity => this._removeParticipant(callEntity, userId))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * User action to reject incoming call.
   * @param {string} conversationId - ID of conversation to ignore call in
   * @param {boolean} shareRejection - Send rejection to other clients
   * @returns {undefined} No return value
   */
  rejectCall(conversationId, shareRejection = true) {
    this.getCallById(conversationId)
      .then(callEntity => this._rejectCall(callEntity, shareRejection))
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * User action to toggle one of the media states of a call.
   *
   * @param {string} conversationId - ID of conversation with call
   * @param {z.media.MediaType} mediaType - MediaType of requested change
   * @returns {undefined} No return value
   */
  toggleMedia(conversationId, mediaType) {
    return this.getCallById(conversationId)
      .then(callEntity => this._toggleMediaState(mediaType).then(() => callEntity))
      .then(callEntity => callEntity.toggleMedia(mediaType))
      .catch(error => {
        const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
        if (!isNotFound) {
          if (mediaType === z.media.MediaType.VIDEO || mediaType === z.media.MediaType.AUDIO_VIDEO) {
            this.mediaRepository.showNoCameraModal();
          }
          this.callLogger.error(`Failed to toggle media of type '${mediaType}'`, error);
        }
      });
  }

  /**
   * User action to toggle the call state.
   *
   * @param {z.media.MediaType} mediaType - Media type of call
   * @param {Conversation} [conversationEntity=this.conversationRepository.active_conversation()] - Conversation for which state will be toggled
   * @returns {undefined} No return value
   */
  toggleState(mediaType, conversationEntity = this.conversationRepository.active_conversation()) {
    if (conversationEntity) {
      const isActiveCall = conversationEntity.id === this._selfClientOnACall();
      return isActiveCall
        ? this.leaveCall(conversationEntity.id, z.calling.enum.TERMINATION_REASON.SELF_USER)
        : this.joinCall(conversationEntity.id, mediaType);
    }
  }

  /**
   * Check whether conversation supports calling.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @param {z.calling.enum.CALL_STATE} callState - Current state of call
   * @returns {Promise} Resolves when conversation supports calling
   */
  _checkCallingSupport(conversationId, mediaType, callState) {
    return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
      const noConversationParticipants = !conversationEntity.participating_user_ids().length;
      if (noConversationParticipants) {
        this._showModal(z.string.modalCallEmptyConversationHeadline, z.string.modalCallEmptyConversationMessage);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }

      const isOutgoingCall = callState === z.calling.enum.CALL_STATE.OUTGOING;
      if (isOutgoingCall && !z.calling.CallingRepository.supportsCalling) {
        amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.UNSUPPORTED_OUTGOING_CALL);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }

      const isVideoCall = mediaType === z.media.MediaType.AUDIO_VIDEO;
      if (isVideoCall && !conversationEntity.supportsVideoCall(isOutgoingCall)) {
        this._showModal(z.string.modalCallNoGroupVideoHeadline, z.string.modalCallNoGroupVideoMessage);
        throw new z.error.CallError(z.error.CallError.TYPE.NOT_SUPPORTED);
      }
    });
  }

  /**
   * Check whether we are actively participating in a call.
   *
   * @private
   * @param {string} newCallId - Conversation ID of call about to be joined
   * @param {z.calling.enum.CALL_STATE} callState - Call state of new call
   * @returns {Promise} Resolves when the new call was joined
   */
  _checkConcurrentJoinedCall(newCallId, callState) {
    return new Promise(resolve => {
      const ongoingCallId = this._selfParticipantOnACall();

      if (!ongoingCallId) {
        resolve();
      } else {
        let actionStringId;
        let messageStringId;
        let titleStringId;

        switch (callState) {
          case z.calling.enum.CALL_STATE.INCOMING:
          case z.calling.enum.CALL_STATE.REJECTED: {
            actionStringId = z.string.modalCallSecondIncomingAction;
            messageStringId = z.string.modalCallSecondIncomingMessage;
            titleStringId = z.string.modalCallSecondIncomingHeadline;
            break;
          }

          case z.calling.enum.CALL_STATE.ONGOING: {
            actionStringId = z.string.modalCallSecondOngoingAction;
            messageStringId = z.string.modalCallSecondOngoingMessage;
            titleStringId = z.string.modalCallSecondOngoingHeadline;
            break;
          }

          case z.calling.enum.CALL_STATE.OUTGOING: {
            actionStringId = z.string.modalCallSecondOutgoingAction;
            messageStringId = z.string.modalCallSecondOutgoingMessage;
            titleStringId = z.string.modalCallSecondOutgoingHeadline;
            break;
          }

          default: {
            this.callLogger.error(`Tried to join second call in unexpected state '${callState}'`);
            throw new z.error.CallError(z.error.CallError.TYPE.WRONG_STATE);
          }
        }

        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            const terminationReason = z.calling.enum.TERMINATION_REASON.CONCURRENT_CALL;
            amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, ongoingCallId, terminationReason);
            window.setTimeout(resolve, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
          },
          close: () => {
            const isIncomingCall = callState === z.calling.enum.CALL_STATE.INCOMING;
            if (isIncomingCall) {
              amplify.publish(z.event.WebApp.CALL.STATE.REJECT, newCallId);
            }
          },
          text: {
            action: z.l10n.text(actionStringId),
            message: z.l10n.text(messageStringId),
            title: z.l10n.text(titleStringId),
          },
        });
        this.callLogger.warn(`You cannot join a second call while calling in conversation '${ongoingCallId}'.`);
      }
    });
  }

  /**
   * Delete a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to delete
   * @returns {undefined} No return value
   */
  _deleteCall(callEntity) {
    const conversationId = callEntity.id;
    this.callLogger.info(`Deleting call in conversation '${conversationId}'`, callEntity);

    callEntity.deleteCall();
    this.calls.remove(call => call.id === conversationId);
    this.mediaStreamHandler.resetMediaStream();
  }

  /**
   * Handle join call errors.
   *
   * @private
   * @param {Error} error - Error to handle
   * @param {string} conversationId - Id of conversation
   * @returns {undefined} No return value
   */
  _handleJoinCallError(error, conversationId) {
    const isNotSupported = error.type === z.error.CallError.TYPE.NOT_SUPPORTED;
    if (!isNotSupported) {
      this.deleteCall(conversationId);
      const isMediaError = error instanceof z.error.MediaError;
      if (!isMediaError) {
        throw error;
      }
    }
  }

  /**
   * Handle not found error.
   *
   * @private
   * @param {Error} error - Error to handle
   * @returns {undefined} No return value
   */
  _handleNotFoundError(error) {
    const isNotFound = error.type === z.error.CallError.TYPE.NOT_FOUND;
    if (!isNotFound) {
      throw error;
    }
  }

  /**
   * Handle error when joining a call.
   *
   * @private
   * @param {string} conversationId - ID of call where joining failed
   * @param {boolean} isOutgoingCall - Was outgoing call
   * @param {Error} joinError - Error that occured
   * @returns {undefined} No return value
   */
  _handleJoinError(conversationId, isOutgoingCall, joinError) {
    this.getCallById(conversationId)
      .then(callEntity => {
        callEntity.setSelfState(false);

        const logMessage = `Failed to join call in '${callEntity.state()}' conversation '${conversationId}'`;
        this.callLogger.warn(logMessage, joinError);

        const accessErrors = [
          z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE,
          z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION,
        ];
        const isAccessError = accessErrors.includes(joinError.type);
        if (isAccessError) {
          this.mediaRepository.showNoCameraModal();
        }

        return isOutgoingCall ? this._deleteCall(callEntity) : this._rejectCall(callEntity, true);
      })
      .catch(error => this._handleNotFoundError(error));
  }

  /**
   * Actively join a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @param {z.media.MediaType} mediaType - Media type of the call
   * @returns {undefined} No return value
   */
  _initiateJoinCall(callEntity, mediaType) {
    callEntity.timings.time_step(z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED);
    callEntity.joinCall(mediaType);
  }

  /**
   * Initiate an outgoing call.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @param {z.calling.enum.CALL_STATE} callState - State of call
   * @returns {Promise} Resolves with a call entity
   */
  _initiateOutgoingCall(conversationId, mediaType, callState) {
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;
    const payload = {conversationId};
    const messagePayload = z.calling.CallMessageBuilder.createPropSync(this.selfStreamState, payload, videoSend);
    const callMessageEntity = z.calling.CallMessageBuilder.buildPropSync(false, undefined, messagePayload);
    return this._createOutgoingCall(callMessageEntity);
  }

  /**
   * Prepare to join a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @returns {undefined} No return value
   */
  _initiatePreJoinCall(callEntity) {
    this.callLogger.info(`Joining call in conversation '${callEntity.id}'`, callEntity);
    callEntity.setSelfState(true);
    return callEntity;
  }

  /**
   * Initiate media stream for call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to be joined
   * @param {z.media.MediaType} mediaType - Media type for this call
   * @returns {Promise} Resolves with the call entity
   */
  _initiateMediaStream(callEntity, mediaType) {
    return this.mediaStreamHandler.localMediaStream()
      ? Promise.resolve(callEntity)
      : this.mediaStreamHandler
          .initiateMediaStream(callEntity.id, mediaType, callEntity.isGroup)
          .then(() => callEntity);
  }

  /**
   * Join a call.
   *
   * @private
   * @param {string} conversationId - ID of conversation to join call in
   * @param {z.media.MediaType} mediaType - Media type of the call
   * @param {z.calling.enum.CALL_STATE} callState - State of call
   * @param {CallEntity} [callEntity] - Retrieved call entity
   * @returns {undefined} No return value
   */
  _joinCall(conversationId, mediaType, callState, callEntity) {
    this._checkCallingSupport(conversationId, mediaType, callState)
      .then(() => this._checkConcurrentJoinedCall(conversationId, callState))
      .then(() => callEntity || this._initiateOutgoingCall(conversationId, mediaType, callState))
      .then(callEntityToJoin => this._initiatePreJoinCall(callEntityToJoin))
      .then(callEntityToJoin => this._initiateMediaStream(callEntityToJoin, mediaType))
      .then(callEntityToJoin => this._initiateJoinCall(callEntityToJoin, mediaType))
      .catch(error => this._handleJoinError(conversationId, !callEntity, error));
  }

  /**
   * Leave a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call to leave
   * @param {z.calling.enum.TERMINATION_REASON} terminationReason - Reason for call termination
   * @returns {undefined} No return value
   */
  _leaveCall(callEntity, terminationReason) {
    const conversationId = callEntity.id;
    const logMessage = `Leaving call in conversation '${conversationId}' triggered by '${terminationReason}'`;
    this.callLogger.info(logMessage, callEntity);

    if (!callEntity.isOngoing()) {
      terminationReason = undefined;
    }

    this.mediaStreamHandler.releaseMediaStream();
    callEntity.leaveCall(terminationReason);
  }

  /**
   * Reject a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call entity to ignore
   * @param {boolean} shareRejection - Share rejection with other clients
   * @returns {undefined} No return value
   */
  _rejectCall(callEntity, shareRejection) {
    this.callLogger.info(`Rejecting call in conversation '${callEntity.id}'`, callEntity);
    callEntity.rejectCall(shareRejection);
  }

  /**
   * Remove a participant from a call.
   *
   * @private
   * @param {CallEntity} callEntity - Call entity
   * @param {string} userId - ID of user to be removed
   * @returns {Promise} Resolves when the participant was found
   */
  _removeParticipant(callEntity, userId) {
    return callEntity.getParticipantById(userId).then(() => {
      const {id, sessionId} = callEntity;
      const additionalPayload = z.calling.CallMessageBuilder.createPayload(id, this.selfUserId(), userId);
      const callMessageEntity = z.calling.CallMessageBuilder.buildGroupLeave(false, sessionId, additionalPayload);

      this._onGroupLeave(callMessageEntity, z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE);
    });
  }

  /**
   * Show acknowledgement warning modal.
   *
   * @private
   * @param {string} titleStringId - String ID for modal title
   * @param {string} messageStringId - String ID for modal message
   * @returns {undefined} No return value
   */
  _showModal(titleStringId, messageStringId) {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: z.l10n.text(messageStringId),
        title: z.l10n.text(titleStringId),
      },
    });
  }

  /**
   * Toggle media state of a call.
   *
   * @param {z.media.MediaType} mediaType - MediaType of requested change
   * @returns {undefined} No return value
   */
  _toggleMediaState(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return this.mediaStreamHandler.toggleAudioSend();
      }

      case z.media.MediaType.SCREEN: {
        return this.mediaStreamHandler.toggleScreenSend();
      }

      case z.media.MediaType.VIDEO: {
        return this.mediaStreamHandler.toggleVideoSend();
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  //##############################################################################
  // call entity creation
  //##############################################################################

  /**
   * Constructs a call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.entity.User} creatingUserEntity - User that created call
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @returns {Promise} Resolves with the new call entity
   */
  _createCall(callMessageEntity, creatingUserEntity, direction) {
    const {conversationId, sessionId, properties} = callMessageEntity;
    const mediaType = this._getMediaTypeFromProperties(properties);

    return this.getCallById(conversationId).catch(() => {
      return this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
        const callEntity = new z.calling.entities.CallEntity(conversationEntity, creatingUserEntity, sessionId, this);

        callEntity.initiateTelemetry(direction, mediaType);
        this.calls.push(callEntity);
        return callEntity;
      });
    });
  }

  /**
   * Constructs an incoming call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {boolean} [silent=false] - Start call in rejected mode
   * @returns {Promise} Resolves with the new call entity
   */
  _createIncomingCall(callMessageEntity, source, silent = false) {
    const {conversationId, properties, userId} = callMessageEntity;

    return this.userRepository
      .get_user_by_id(userId)
      .then(remoteUserEntity => {
        return this._createCall(callMessageEntity, remoteUserEntity, z.calling.enum.CALL_STATE.INCOMING);
      })
      .then(callEntity => {
        const mediaType = this._getMediaTypeFromProperties(properties);
        const conversationName = callEntity.conversationEntity.display_name();

        const logMessage = {
          data: {
            default: [mediaType, conversationName],
            obfuscated: [mediaType, this.callLogger.obfuscate(conversationId)],
          },
          message: `Incoming '{0}' call in conversation '{1}'`,
        };
        this.callLogger.info(logMessage, callEntity);

        callEntity.setRemoteVersion(callMessageEntity);

        if (!callEntity.conversationEntity.showNotificationsEverything()) {
          silent = true;
        }

        const callState = silent ? z.calling.enum.CALL_STATE.REJECTED : z.calling.enum.CALL_STATE.INCOMING;
        callEntity.state(callState);

        return callEntity.addOrUpdateParticipant(userId, false, callMessageEntity).then(() => {
          this.telemetry.track_event(z.tracking.EventName.CALLING.RECEIVED_CALL, callEntity);
          this.injectActivateEvent(callMessageEntity, source);

          const eventFromWebSocket = source === z.event.EventRepository.SOURCE.WEB_SOCKET;
          const hasOtherCalls = this.calls().some(call => call.id !== callEntity.id);
          const hasCallWithoutVideo = hasOtherCalls && !this.mediaStreamHandler.selfStreamState.videoSend();

          if (eventFromWebSocket && callEntity.isRemoteVideoSend() && !hasCallWithoutVideo) {
            const mediaStreamType = z.media.MediaType.AUDIO_VIDEO;
            this.mediaStreamHandler.initiateMediaStream(callEntity.id, mediaStreamType, callEntity.isGroup);
          }

          return callEntity;
        });
      })
      .catch(error => {
        this.deleteCall(conversationId);

        const isMediaError = error instanceof z.error.MediaError;
        if (!isMediaError) {
          throw error;
        }
      });
  }

  /**
   * Constructs an outgoing call entity.
   *
   * @private
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC
   * @returns {Promise} Resolves with the new call entity
   */
  _createOutgoingCall(callMessageEntity) {
    const properties = callMessageEntity.properties;

    const direction = z.calling.enum.CALL_STATE.OUTGOING;
    return this._createCall(callMessageEntity, this.userRepository.self(), direction).then(callEntity => {
      const mediaType = this._getMediaTypeFromProperties(properties);
      const conversationName = callEntity.conversationEntity.display_name();
      const conversationId = callEntity.conversationEntity.id;

      const logMessage = {
        data: {
          default: [mediaType, conversationName],
          obfuscated: [mediaType, this.callLogger.obfuscate(conversationId)],
        },
        message: `Outgoing '{0}' call in conversation '{1}'`,
      };
      this.callLogger.info(logMessage, callEntity);

      callEntity.state(z.calling.enum.CALL_STATE.OUTGOING);

      this.telemetry.track_event(z.tracking.EventName.CALLING.INITIATED_CALL, callEntity);
      return callEntity;
    });
  }

  //##############################################################################
  // Notifications
  //##############################################################################

  /**
   * Inject a call activate event.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to create event from
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  injectActivateEvent(callMessageEntity, source) {
    const event = z.conversation.EventBuilder.buildVoiceChannelActivate(callMessageEntity);
    this.eventRepository.injectEvent(event, source);
  }

  /**
   * Inject a call deactivate event.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to create event from
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.calling.enum.TERMINATION_REASON} [reason] - Reason for call to end
   * @returns {undefined} No return value
   */
  injectDeactivateEvent(callMessageEntity, source, reason) {
    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const event = z.conversation.EventBuilder.buildVoiceChannelDeactivate(callMessageEntity, reason, currentTimestamp);
    this.eventRepository.injectEvent(event, source);
  }

  //##############################################################################
  // Helper functions
  //##############################################################################

  /**
   * Get a call entity for a given conversation ID.
   * @param {string} conversationId - ID of Conversation of requested call
   * @returns {Promise} Resolves with the call entity for conversation ID
   */
  getCallById(conversationId) {
    if (!conversationId) {
      return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NO_CONVERSATION_ID));
    }

    for (const callEntity of this.calls()) {
      const isExpectedId = callEntity.id === conversationId;
      if (isExpectedId) {
        return Promise.resolve(callEntity);
      }
    }

    return Promise.reject(new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND));
  }

  /**
   * Leave a call we are joined immediately in case the browser window is closed.
   * @note Should only used by "window.onbeforeunload".
   * @returns {undefined} No return value
   */
  leaveCallOnUnload() {
    const conversationId = this._selfClientOnACall();

    if (conversationId) {
      this.leaveCall(conversationId, z.calling.enum.TERMINATION_REASON.PAGE_NAVIGATION);
    }
  }

  /**
   * Get the MediaType from given call event properties.
   * @param {Object} properties - call event properties
   * @returns {z.media.MediaType} MediaType of call
   */
  _getMediaTypeFromProperties(properties) {
    const isVideoSend = properties && properties.videosend === z.calling.enum.PROPERTY_STATE.TRUE;
    const isScreenSend = properties && properties.screensend === z.calling.enum.PROPERTY_STATE.TRUE;
    const isTypeVideo = isVideoSend || isScreenSend;
    return isTypeVideo ? z.media.MediaType.VIDEO : z.media.MediaType.AUDIO;
  }

  /**
   * Check if self client is participating in a call.
   * @private
   * @returns {string|boolean} Conversation ID of call or false
   */
  _selfClientOnACall() {
    for (const callEntity of this.calls()) {
      if (callEntity.selfClientJoined()) {
        return callEntity.id;
      }
    }

    return false;
  }

  /**
   * Check if self participant is participating in a call.
   * @private
   * @returns {string|boolean} Conversation ID of call or false
   */
  _selfParticipantOnACall() {
    for (const callEntity of this.calls()) {
      if (callEntity.selfUserJoined()) {
        return callEntity.id;
      }
    }

    return false;
  }

  //##############################################################################
  // Calling config
  //##############################################################################

  /**
   * Get the current calling config.
   * @returns {Promise} Resolves with calling config
   */
  getConfig() {
    if (this.callingConfig) {
      const isExpiredConfig = this.callingConfig.expiration.getTime() < Date.now();

      if (!isExpiredConfig) {
        this.callLogger.debug('Returning local calling configuration. No update needed.', this.callingConfig);
        return Promise.resolve(this.callingConfig);
      }

      this._clearConfig();
    }

    return this._getConfigFromBackend();
  }

  _clearConfig() {
    if (this.callingConfig) {
      const expirationDate = this.callingConfig.expiration.toISOString();
      this.callLogger.debug(`Removing calling configuration with expiration of '${expirationDate}'`);
      this.callingConfig = undefined;
    }
  }

  _clearConfigTimeout() {
    if (this.callingConfigTimeout) {
      window.clearTimeout(this.callingConfigTimeout);
      this.callingConfigTimeout = undefined;
    }
  }

  /**
   * Get the calling config from the backend and store it.
   *
   * @private
   * @returns {Promise} Resolves with the updated calling config
   */
  _getConfigFromBackend() {
    const limit = z.util.Environment.browser.firefox ? CallingRepository.CONFIG.MAX_FIREFOX_TURN_COUNT : undefined;

    return this.callingService.getConfig(limit).then(callingConfig => {
      if (callingConfig) {
        this._clearConfigTimeout();

        const DEFAULT_CONFIG_TTL = CallingRepository.CONFIG.DEFAULT_CONFIG_TTL;
        const ttl = callingConfig.ttl * 0.9 || DEFAULT_CONFIG_TTL;
        const timeout = Math.min(ttl, DEFAULT_CONFIG_TTL) * z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        const expirationDate = new Date(Date.now() + timeout);
        callingConfig.expiration = expirationDate;

        const logMessage = `Updated calling configuration expires on '${expirationDate.toISOString()}'`;
        this.callLogger.info(logMessage, callingConfig);
        this.callingConfig = callingConfig;

        this.callingConfigTimeout = window.setTimeout(() => {
          this._clearConfig();
          this.getConfig();
        }, timeout);

        return this.callingConfig;
      }
    });
  }

  //##############################################################################
  // Logging
  //##############################################################################

  /**
   * Print the call message log.
   * @returns {undefined} No return value
   */
  printLog() {
    this.callLogger.force_log(`Call message log contains '${this.messageLog.length}' events`, this.messageLog);
    this.messageLog.forEach(logMessage => this.callLogger.force_log(logMessage));
  }

  /**
   * Report a call for call analysis.
   * @param {string} conversationId - ID of conversation
   * @returns {undefined} No return value
   */
  reportCall(conversationId) {
    this.getCallById(conversationId)
      .catch(() => {
        for (const callEntity of this.calls()) {
          if (!callEntity.isEndedState()) {
            return callEntity;
          }
        }
      })
      .then(callEntity => {
        if (callEntity) {
          return this._sendReport(callEntity.getFlows().map(flowEntity => flowEntity.reportStatus()));
        }

        if (this.flowStatus) {
          return this._sendReport(this.flowStatus);
        }

        this.callLogger.warn('Could not find flows to report for call analysis');
      });
  }

  /**
   * Set logging on adapter.js.
   * @returns {undefined} No return value
   */
  _enableDebugging() {
    if (window.adapter) {
      window.adapter.disableLog = false;
    } else {
      this.callLogger.warn('WebRTC Adapter not found while trying to enable logging');
    }
  }

  /**
   * Store last flow status.
   * @param {Object} flowStatus - Status to store
   * @returns {undefined} No return value
   */
  storeFlowStatus(flowStatus) {
    if (flowStatus) {
      this.flowStatus = flowStatus;
    }
  }

  /**
   * Log call messages for debugging.
   *
   * @private
   * @param {boolean} isOutgoing - Is message outgoing
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message to be logged in the sequence
   * @param {string} [date] - Date of message as ISO string
   * @returns {undefined} No return value
   */
  _logMessage(isOutgoing, callMessageEntity, date = new Date().toISOString()) {
    const {conversationId, destinationUserId, remoteUserId, response, type, userId} = callMessageEntity;

    let log;
    const target = `conversation '${conversationId}'`;
    if (isOutgoing) {
      const additionalMessage = remoteUserId ? `user '${remoteUserId}' in ${target}` : `${target}`;
      log = `Sending '${type}' message (response: ${response}) to ${additionalMessage}`;
    } else {
      const isSelfUser = destinationUserId === this.selfUserId();
      if (destinationUserId && !isSelfUser) {
        return;
      }

      log = `Received '${type}' message (response: ${response}) from user '${userId}' in ${target}`;
    }

    if (callMessageEntity.properties) {
      log = log.concat(`: ${JSON.stringify(callMessageEntity.properties)}`);
    }

    this.callLogger.info(log, callMessageEntity);
  }

  /**
   * Send Raygun report.
   *
   * @private
   * @param {Object} customData - Information to add to the call report
   * @returns {undefined} No return value
   */
  _sendReport(customData) {
    Raygun.send(new Error('Call failure report'), customData);
    this.callLogger.debug(`Reported status of flow id '${customData.meta.flowId}' for call analysis`, customData);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallingService = class CallingService {
  /**
   * Construct an new CallingService.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
  }

  /**
   * Retrieves a calling config from the backend.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//getCallsConfigV2
   * @see ./documentation/blob/master/topics/web/calling/calling-v3.md#limiting
   *
   * @param {number} [limit] - Limit the number of TURNs servers in the response (range 1, 10)
   * @returns {Promise} Resolves with call config information
   */
  getConfig(limit) {
    return this.backendClient.sendRequest({
      cache: false,
      data: {
        limit,
      },
      type: 'GET',
      url: '/calls/config/v2',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallMessageBuilder = (() => {
  const _buildCallMessage = (type, response, sessionId, additionalPayload) => {
    const callMessageEntity = new z.calling.entities.CallMessageEntity(type, response, sessionId);

    if (additionalPayload) {
      callMessageEntity.addProperties(additionalPayload);
    }

    return callMessageEntity;
  };

  const _buildCancel = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.CANCEL, response, sessionId, additionalPayload);
  };

  const _buildGroupCheck = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_CHECK, response, sessionId, additionalPayload);
  };

  const _buildGroupLeave = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE, response, sessionId, additionalPayload);
  };

  const _buildGroupSetup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP, response, sessionId, additionalPayload);
  };

  const _buildGroupStart = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START, response, sessionId, additionalPayload);
  };

  const _buildHangup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.HANGUP, response, sessionId, additionalPayload);
  };

  const _buildPropSync = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC, response, sessionId, additionalPayload);
  };

  const _buildReject = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.REJECT, response, sessionId, additionalPayload);
  };

  const _buildSetup = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.SETUP, response, sessionId, additionalPayload);
  };

  const _buildUpdate = (response, sessionId, additionalPayload) => {
    return _buildCallMessage(z.calling.enum.CALL_MESSAGE_TYPE.UPDATE, response, sessionId, additionalPayload);
  };

  /**
   * Create additional payload.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} selfUserId - ID of self user
   * @param {string} [remoteUserId] - Optional ID of remote user
   * @param {string} [remoteClientId] - Optional ID of remote client
   * @returns {{conversationId: string, remoteClientId: string, remoteUserId: *, time: string, userId: string}} Additional payload
   */
  const _createPayload = (conversationId, selfUserId, remoteUserId, remoteClientId) => {
    return {conversationId, remoteClientId, remoteUserId, time: new Date().toISOString(), userId: selfUserId};
  };

  /**
   * Create properties payload for call events.
   *
   * @param {Object} selfState - Current self state
   * @param {Object} additionalPayload - Optional additional payload to be added
   * @param {boolean} [videoStateOverwrite] - Forces the videosend property to be this value instead of the one in the selfState
   * @returns {Object} call message props object
   */
  const _createPropSync = (selfState, additionalPayload, videoStateOverwrite) => {
    const payload = {};
    const {audioSend: audioState, videoSend: videoState, screenSend: screenState} = selfState;
    const videoSend = _.isBoolean(videoStateOverwrite) ? videoStateOverwrite : videoState();

    payload.properties = {
      audiosend: `${audioState()}`,
      screensend: `${screenState()}`,
      videosend: `${videoSend}`,
    };

    return additionalPayload ? Object.assign(payload, additionalPayload) : payload;
  };

  return {
    buildCancel: _buildCancel,
    buildGroupCheck: _buildGroupCheck,
    buildGroupLeave: _buildGroupLeave,
    buildGroupSetup: _buildGroupSetup,
    buildGroupStart: _buildGroupStart,
    buildHangup: _buildHangup,
    buildPropSync: _buildPropSync,
    buildReject: _buildReject,
    buildSetup: _buildSetup,
    buildUpdate: _buildUpdate,
    createPayload: _createPayload,
    createPropSync: _createPropSync,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.CallMessageMapper = {
  /**
   * Map incoming call message into entity.
   *
   * @private
   * @param {Object} event - Call event object
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  mapEvent(event) {
    const {content: callMessage, conversation: conversationId, from: userId, sender: clientId, time} = event;

    const additionalProperties = {clientId, conversationId, time, userId};

    let content = undefined;
    switch (callMessage.type) {
      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_SETUP:
      case z.calling.enum.CALL_MESSAGE_TYPE.UPDATE: {
        const {
          dest_clientid: destinationClientId,
          dest_userid: destinationUserId,
          props: properties,
          sdp,
        } = callMessage;

        content = {destinationClientId, destinationUserId, properties, sdp};
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.PROP_SYNC: {
        const properties = callMessage.props;

        content = {properties};
        break;
      }

      case z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START:
      case z.calling.enum.CALL_MESSAGE_TYPE.SETUP: {
        const {props: properties, sdp} = callMessage;

        content = {properties, sdp};
        break;
      }

      default: {
        break;
      }
    }

    if (content) {
      Object.assign(additionalProperties, content);
    }

    const {type, resp: response, sessid: sessionId} = callMessage;
    const callMessageEntity = new z.calling.entities.CallMessageEntity(type, response, sessionId);

    callMessageEntity.addProperties(additionalProperties);

    return callMessageEntity;
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.SDPMapper = {
  CONFIG: {
    AUDIO_BITRATE: '30',
    AUDIO_PTIME: '60',
  },

  /**
   * Get the tool version that generated the SDP
   * @param {string} sdpString - Full SDP string
   * @returns {string} Tool version of SDP
   */
  getToolVersion(sdpString) {
    for (const sdpLine of sdpString.split('\r\n')) {
      if (sdpLine.startsWith('a=tool')) {
        return sdpLine.replace('a=tool:', '');
      }
    }
  },

  /**
   * Map call setup message to RTCSessionDescription.
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Call message entity of type z.calling.enum.CALL_MESSAGE_TYPE.SETUP
   * @returns {Promise} Resolves with a webRTC standard compliant RTCSessionDescription
   */
  mapCallMessageToObject(callMessageEntity) {
    const {response, sdp: sdpString} = callMessageEntity;
    const sdp = {
      sdp: sdpString,
      type: response ? z.calling.rtc.SDP_TYPE.ANSWER : z.calling.rtc.SDP_TYPE.OFFER,
    };

    return Promise.resolve(sdp);
  },

  /**
   * Rewrite the SDP for compatibility reasons.
   *
   * @param {RTCSessionDescription} rtcSdp - Session Description Protocol to be rewritten
   * @param {z.calling.enum.SDP_SOURCE} [sdpSource=z.calling.enum.SDP_SOURCE.REMOTE] - Source of the SDP - local or remote
   * @param {z.calling.entities.FlowEntity} flowEntity - Flow entity
   * @returns {Object} Object containing rewritten Session Description Protocol and number of ICE candidates
   */
  rewriteSdp(rtcSdp, sdpSource = z.calling.enum.SDP_SOURCE.REMOTE, flowEntity) {
    if (!rtcSdp) {
      throw new z.error.CallError(z.error.CallError.TYPE.NOT_FOUND, 'Cannot rewrite undefined SDP');
    }

    const {sdp, type} = rtcSdp;
    const sdpLines = [];
    const iceCandidates = [];
    let sessionDescription;

    const isIceRestart = flowEntity.negotiationMode() === z.calling.enum.SDP_NEGOTIATION_MODE.ICE_RESTART;
    const isLocalSdp = sdpSource === z.calling.enum.SDP_SOURCE.LOCAL;
    const isLocalSdpInGroup = isLocalSdp && flowEntity.isGroup;
    const isOffer = rtcSdp.type === z.calling.rtc.SDP_TYPE.OFFER;

    sessionDescription = isLocalSdp ? sdp.replace('UDP/TLS/', '') : sdp;

    sessionDescription.split('\r\n').forEach(sdpLine => {
      let outline = sdpLine;

      if (sdpLine.startsWith('t=')) {
        if (isLocalSdp) {
          sdpLines.push(sdpLine);

          const browserString = `${z.util.Environment.browser.name} ${z.util.Environment.browser.version}`;
          const webappVersion = z.util.Environment.version(false);

          outline = z.util.Environment.desktop
            ? `a=tool:electron ${z.util.Environment.version(true)} ${webappVersion} (${browserString})`
            : `a=tool:webapp ${webappVersion} (${browserString})`;
        }
      } else if (sdpLine.startsWith('a=candidate')) {
        iceCandidates.push(sdpLine);
      } else if (sdpLine.startsWith('m=')) {
        if (sdpLine.startsWith('m=audio')) {
          // Code to nail in bit-rate and ptime settings for improved performance and experience
          const shouldAddBitRate = isLocalSdpInGroup || isIceRestart;
          if (shouldAddBitRate) {
            sdpLines.push(sdpLine);
            outline = `b=AS:${z.calling.SDPMapper.CONFIG.AUDIO_BITRATE}`;
          }
        } else if (z.util.Environment.browser.firefox && isLocalSdp && isOffer) {
          // Set ports to activate media in outgoing Firefox SDP to ensure enabled media
          outline = sdpLine.replace(/^m=(application|video) 0/, 'm=$1 9');
        }
      } else if (sdpLine.startsWith('a=rtpmap')) {
        const shouldAddPTime = isLocalSdpInGroup || isIceRestart;
        if (shouldAddPTime && z.util.StringUtil.includes(sdpLine, 'opus')) {
          sdpLines.push(sdpLine);
          outline = `a=ptime:${z.calling.SDPMapper.CONFIG.AUDIO_PTIME}`;
        }
      }

      if (outline !== undefined) {
        sdpLines.push(outline);
      }
    });

    sessionDescription = sdpLines.join('\r\n');
    const sdpInit = {sdp: sessionDescription, type};
    return {iceCandidates, sdp: sdpInit};
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.calling = z.calling || {};

z.calling.VideoGridRepository = class VideoGridRepository {
  /**
   * Construct an new VideoGridRepository.
   * @param {CallingRepository} callingRepository - Repository for the calls
   * @param {MediaRepository} mediaRepository - Repository for the media streams
   */
  constructor(callingRepository, mediaRepository) {
    const streamHandler = mediaRepository.streamHandler;
    const streamsInfo = streamHandler.remoteMediaStreamInfoIndex.video;
    const {hasActiveVideo, localMediaStream, selfStreamState} = streamHandler;

    const calls = callingRepository.calls;
    this.grid = ko.observableArray([0, 0, 0, 0]);
    this.thumbnailStream = ko.observable();

    const selfStream = ko.pureComputed(() => {
      const stream = hasActiveVideo() ? localMediaStream() : undefined;
      return {
        audioSend: selfStreamState.audioSend,
        id: stream && stream.id,
        isSelf: true,
        screenSend: selfStreamState.screenSend,
        stream: stream,
        videoSend: selfStreamState.videoSend,
      };
    });

    this.streams = ko.pureComputed(() => {
      const videoParticipants = calls()
        .reduce((participantEntities, callEntity) => participantEntities.concat(callEntity.participants()), [])
        .filter(participantEntity => participantEntity.hasActiveVideo());

      const videoParticipantIds = videoParticipants.map(participant => participant.id);

      const remoteStreams = streamsInfo()
        .filter(mediaStreamInfo => videoParticipantIds.includes(mediaStreamInfo.flowId))
        .map(mediaStreamInfo => {
          const stream = mediaStreamInfo.stream;
          const participant = videoParticipants.find(videoParticipant => {
            return videoParticipant.id === mediaStreamInfo.flowId;
          });

          return {
            id: stream.id,
            picture: participant.user.mediumPictureResource,
            screenSend: participant.state.screenSend,
            stream: stream,
            videoSend: participant.state.videoSend,
          };
        });

      if (remoteStreams.length === 1) {
        this.thumbnailStream(selfStream());
        return remoteStreams;
      }
      this.thumbnailStream(undefined);
      return selfStream().stream ? remoteStreams.concat(selfStream()) : remoteStreams;
    });

    this.streams.subscribe(this.updateGrid.bind(this));
    this.updateGrid(this.streams());
  }

  /**
   * Will compute the next grid layout according to the previous state and the new array of streams
   * The grid will fill according to this pattern
   * - 1 stream : [id, 0, 0, 0]
   * - 2 streams: [id, 0, id, 0]
   * - 3 streams: [id, 0, id, id]
   * - 3 streams: [id, id, 0, id]
   * - 4 streams: [id, id, id, id]
   * @param {Array<string|0>} previousGrid - the previous state of the grid
   * @param {Array<MediaStream>} streams - the new array of streams to dispatch in the grid
   *
   * @returns {Array<string|0>} the new grid
   */
  computeGrid(previousGrid, streams) {
    const previousStreamIds = previousGrid.filter(streamId => streamId !== 0);
    const currentStreamIds = streams.map(stream => stream.id);

    const addedStreamIds = z.util.ArrayUtil.getDifference(previousStreamIds, currentStreamIds);

    const filteredGrid = previousGrid.map(id => (currentStreamIds.includes(id) ? id : 0));

    const streamIds = filteredGrid.filter(streamId => streamId !== 0);
    // Add the new streams at the end
    const newStreamsIds = streamIds.concat(addedStreamIds);
    return newStreamsIds.length === 2
      ? [newStreamsIds[0], 0, newStreamsIds[1], 0]
      : [newStreamsIds[0] || 0, newStreamsIds[3] || 0, newStreamsIds[1] || 0, newStreamsIds[2] || 0];
  }

  updateGrid(streams) {
    const newGrid = this.computeGrid(this.grid(), streams);
    this.grid(newGrid);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectService = class ConnectService {
  /**
   * Construct an new ConnectService.
   * @param {BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.connect.ConnectService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Upload address book data for matching.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/addressbook/onboardingV3
   *
   * @param {z.connect.PhoneBook} phoneBook - Phone book containing the address cards
   * @returns {Promise} Resolves with the matched contacts from the user's phone book
   */
  postOnboarding(phoneBook) {
    return this.backendClient.sendJson({
      data: phoneBook,
      type: 'POST',
      url: '/onboarding/v3',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectRepository = class ConnectRepository {
  constructor(connectService, propertiesRepository) {
    this.connectService = connectService;
    this.propertiesRepository = propertiesRepository;
    this.logger = new z.util.Logger('z.connect.ConnectRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Get user's contacts for matching.
   * @param {z.connect.ConnectSource} source - Source for phone book retrieval
   * @returns {Promise} Resolves with the matched user IDs
   */
  getContacts(source) {
    return this._getMacosContacts().then(phoneBook => this._uploadContacts(phoneBook, source));
  }

  /**
   * Encode phone book
   *
   * @private
   * @param {z.connect.PhoneBook} phoneBook - Object containing un-encoded phone book data
   * @returns {z.connect.PhoneBook} Object containing encoded phone book data
   */
  _encodePhoneBook(phoneBook) {
    const {cards, self} = phoneBook;
    self.forEach((contact, contactIndex) => (self[contactIndex] = z.util.encodeSha256Base64(contact)));

    cards.forEach((card, cardIndex) => {
      card.contact.forEach((contact, contactIndex) => {
        card.contact[contactIndex] = z.util.encodeSha256Base64(contact);
      });
      cards[cardIndex] = card;
    });

    return phoneBook;
  }

  /**
   * Retrieve a user's macOS address book contacts.
   * @private
   * @returns {Promise} Resolves with the user's address book contacts that match on Wire
   */
  _getMacosContacts() {
    return this._parseMacosContacts();
  }

  /**
   * Parse a user's macOS address book Contacts.
   * @private
   * @returns {Promise} Resolves with encoded phone book data
   */
  _parseMacosContacts() {
    return new Promise((resolve, reject) => {
      if (!window.wAddressBook) {
        return reject(new z.error.ConnectError(z.error.ConnectError.TYPE.NOT_SUPPORTED));
      }
      const addressBook = window.wAddressBook;
      const phoneBook = new z.connect.PhoneBook();

      const {numbers: selfNumbers} = addressBook.getMe();
      selfNumbers.forEach(number => phoneBook.self.push(number));

      addressBook.getContacts(
        percentage => {
          this.logger.info('Importing Contacts', percentage);
        },
        contacts => {
          contacts.forEach(({firstName, lastName, numbers}) => {
            const card = {
              card_id: CryptoJS.MD5(`${firstName}${lastName}`).toString(),
              contact: [],
            };

            numbers.forEach(number => card.contact.push(z.util.phoneNumberToE164(number, navigator.language)));

            if (card.contact.length) {
              phoneBook.cards.push(card);
            }
          });

          return resolve(this._encodePhoneBook(phoneBook));
        }
      );
    });
  }

  /**
   * Upload hashed phone booked to backend for matching.
   *
   * @private
   * @param {z.connect.PhoneBook} phoneBook - Encoded phone book data
   * @param {z.connect.ConnectSource} source - Source of phone book data
   * @returns {Promise} Resolves when phone book was uploaded
   */
  _uploadContacts(phoneBook, source) {
    const cards = phoneBook.cards;

    if (!cards.length) {
      this.logger.warn('No contacts found for upload');
      throw new z.error.ConnectError(z.error.ConnectError.TYPE.NO_CONTACTS);
    }

    this.logger.info(`Uploading hashes of '${cards.length}' contacts for matching`, phoneBook);
    return this.connectService
      .postOnboarding(phoneBook)
      .then(({results}) => {
        this.logger.info(`Upload of '${source}' contacts upload successful: ${results.length} matches`, results);
        return results.map(result => result.id);
      })
      .catch(error => {
        switch (error.type) {
          case z.error.ConnectError.TYPE.NO_CONTACTS:
            return {};
          default:
            if (error.code === z.error.BackendClientError.STATUS_CODE.TOO_MANY_REQUESTS) {
              this.logger.error(`Backend refused upload of '${source}' contacts: Endpoint used too frequent`, error);
            } else {
              this.logger.error(`Upload of '${source}' contacts failed`, error);
            }
            throw new z.error.ConnectError(z.error.ConnectError.TYPE.UPLOAD);
        }
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.ConnectSource = {
  ICLOUD: 'icloud',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connect = z.connect || {};

z.connect.PhoneBook = class PhoneBook {
  /**
   * Construct a new Phone book.
   */
  constructor() {
    this.self = [];
    this.cards = [];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionEntity = class ConnectionEntity {
  constructor() {
    this.conversationId = null;
    this.from = null;
    this.lastUpdate = null;
    this.message = null;
    this.status = ko.observable(z.connection.ConnectionStatus.UNKNOWN);
    this.userId = null;

    this.isBlocked = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.BLOCKED);
    this.isCanceled = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.CANCELLED);
    this.isConnected = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.ACCEPTED);
    this.isIgnored = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.IGNORED);
    this.isIncomingRequest = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.PENDING);
    this.isOutgoingRequest = ko.pureComputed(() => this.status() === z.connection.ConnectionStatus.SENT);
    this.isUnknown = ko.pureComputed(() =>
      [z.connection.ConnectionStatus.CANCELLED, z.connection.ConnectionStatus.UNKNOWN].includes(this.status())
    );

    this.isRequest = ko.pureComputed(() => this.isIncomingRequest() || this.isOutgoingRequest());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

/**
 * Connection mapper to convert all server side JSON connections into core connection entities.
 * @class z.connection.ConnectionMapper
 */
z.connection.ConnectionMapper = class ConnectionMapper {
  // Construct a new connection mapper.
  constructor() {
    this.logger = new z.util.Logger('z.connection.ConnectionMapper', z.config.LOGGER.OPTIONS);

    /**
     * Converts JSON connection into connection entity.
     * @param {Object} connectionData - Connection data
     * @returns {z.connection.ConnectionEntity} Mapped connection entity
     */
    this.mapConnectionFromJson = connectionData => {
      const connectionEntitiy = new z.connection.ConnectionEntity();
      return this.updateConnectionFromJson(connectionEntitiy, connectionData);
    };

    /**
     * Convert multiple JSON connections into connection entities.
     * @param {Array<Object>} connectionsData - Connection data
     * @returns {Array<z.connection.ConnectionEntity>} Mapped connection entities
     */
    this.mapConnectionsFromJson = connectionsData => {
      return connectionsData
        .filter(connectionData => connectionData)
        .map(connectionData => this.mapConnectionFromJson(connectionData));
    };

    /**
     * Maps JSON connection into a blank connection entity or updates an existing one.
     * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity that the info shall be mapped to
     * @param {JSON} connectionData - Connection data
     * @returns {z.connection.ConnectionEntity} Mapped connection entity
     */
    this.updateConnectionFromJson = (connectionEntity, connectionData) => {
      const {conversation, from, last_update, message, status, to: remoteUserId} = connectionData;

      connectionEntity.status(status);
      connectionEntity.conversationId = conversation;
      connectionEntity.userId = remoteUserId;
      connectionEntity.from = from;
      connectionEntity.lastUpdate = last_update;
      connectionEntity.message = message;
      return connectionEntity;
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionRepository = class ConnectionRepository {
  static get CONFIG() {
    return {
      SUPPORTED_EVENTS: [z.event.Backend.USER.CONNECTION],
    };
  }
  /**
   * Construct a new Connection repository.
   * @class z.connection.ConnectionRepository
   * @param {z.connection.ConnectionService} connectionService - Backend REST API connection service implementation
   * @param {z.repository.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(connectionService, userRepository) {
    this.connectionService = connectionService;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.connection.ConnectionRepository', z.config.LOGGER.OPTIONS);

    this.connectionMapper = new z.connection.ConnectionMapper();
    this.connectionEntities = ko.observableArray([]);

    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.onUserEvent.bind(this));
  }

  /**
   * Listener for incoming user events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onUserEvent(eventJson, source) {
    const eventType = eventJson.type;

    const isSupportedType = ConnectionRepository.CONFIG.SUPPORTED_EVENTS.includes(eventType);
    if (isSupportedType) {
      const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
      this.logger.info(`»» User Event: '${eventType}' (Source: ${source})`, logObject);

      const isUserConnection = eventType === z.event.Backend.USER.CONNECTION;
      if (isUserConnection) {
        this.onUserConnection(eventJson, source);
      }
    }
  }

  /**
   * Convert a JSON event into an entity and get the matching conversation.
   *
   * @param {Object} eventJson - JSON data of 'user.connection' event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {boolean} [showConversation] - Should the new conversation be opened?
   * @returns {undefined} No return value
   */
  onUserConnection(eventJson, source, showConversation) {
    if (!eventJson) {
      throw new z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }

    const connectionData = eventJson.connection;

    let connectionEntity = this.getConnectionByUserId(connectionData.to);
    let previousStatus = null;

    if (connectionEntity) {
      previousStatus = connectionEntity.status();
      this.connectionMapper.updateConnectionFromJson(connectionEntity, connectionData);
    } else {
      connectionEntity = this.connectionMapper.mapConnectionFromJson(connectionData);
    }

    this.updateConnection(connectionEntity).then(() => {
      const shouldUpdateUser = previousStatus === z.connection.ConnectionStatus.SENT && connectionEntity.isConnected();
      if (shouldUpdateUser) {
        this.userRepository.updateUserById(connectionEntity.userId);
      }
      this._sendNotification(connectionEntity, source, previousStatus);
      amplify.publish(z.event.WebApp.CONVERSATION.MAP_CONNECTION, connectionEntity, showConversation);
    });
  }

  /**
   * Accept a connection request.
   * @param {z.entity.User} userEntity - User to update connection with
   * @param {boolean} [showConversation=false] - Show new conversation on success
   * @returns {Promise} Promise that resolves when the connection request was accepted
   */
  acceptRequest(userEntity, showConversation = false) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.ACCEPTED, showConversation);
  }

  /**
   * Block a user.
   *
   * @param {z.entity.User} userEntity - User to block
   * @param {boolean} [hideConversation=false] - Hide current conversation
   * @param {z.entity.Conversation} [nextConversationEntity] - Conversation to be switched to
   * @returns {Promise} Promise that resolves when the user was blocked
   */
  blockUser(userEntity, hideConversation = false, nextConversationEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.BLOCKED).then(() => {
      if (hideConversation) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEntity);
      }
    });
  }

  /**
   * Cancel a connection request.
   *
   * @param {z.entity.User} userEntity - User to cancel the sent connection request
   * @param {boolean} [hideConversation=false] - Hide current conversation
   * @param {z.entity.Conversation} [nextConversationEntity] - Conversation to be switched to
   * @returns {Promise} Promise that resolves when an outgoing connection request was cancelled
   */
  cancelRequest(userEntity, hideConversation = false, nextConversationEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.CANCELLED).then(() => {
      if (hideConversation) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEntity);
      }
    });
  }

  /**
   * Create a connection request.
   *
   * @param {z.entity.User} userEntity - User to connect to
   * @param {boolean} [showConversation=false] - Should we open the new conversation
   * @returns {Promise} Promise that resolves when the connection request was successfully created
   */
  createConnection(userEntity, showConversation = false) {
    return this.connectionService
      .postConnections(userEntity.id, userEntity.name())
      .then(response => {
        const connectionEvent = {connection: response};
        return this.onUserConnection(connectionEvent, z.event.EventRepository.SOURCE.INJECTED, showConversation);
      })
      .catch(error => {
        this.logger.error(`Failed to send connection request to user '${userEntity.id}': ${error.message}`, error);
      });
  }

  /**
   * Get a connection for a user ID.
   * @param {string} userId - User ID
   * @returns {z.connection.ConnectionEntity} User connection entity
   */
  getConnectionByUserId(userId) {
    return this.connectionEntities().find(connectionEntity => connectionEntity.userId === userId);
  }

  /**
   * Get a connection for a conversation ID.
   * @param {string} conversationId - Conversation ID
   * @returns {z.connection.ConnectionEntity} User connection entity
   */
  getConnectionByConversationId(conversationId) {
    return this.connectionEntities().find(connectionEntity => connectionEntity.conversationId === conversationId);
  }

  /**
   * Retrieve all connections from backend.
   *.
   * @note Initially called by Wire for Web's app start to retrieve connections.
   *
   * @param {number} [limit=500] - Query limit for user connections
   * @param {string} [userId] - User ID of the latest connection
   * @param {Array<z.connection.ConnectionEntity>} [connectionEntities=[]] - Unordered array of user connections
   * @returns {Promise} Promise that resolves when all connections have been retrieved and mapped
   */
  getConnections(limit = 500, userId, connectionEntities = []) {
    return this.connectionService
      .getConnections(limit, userId)
      .then(response => {
        const {connections: connectionData, has_more: hasMore} = response;

        if (connectionData.length) {
          const newConnectionEntities = this.connectionMapper.mapConnectionsFromJson(connectionData);
          connectionEntities = connectionEntities.concat(newConnectionEntities);
        }

        if (hasMore) {
          const lastConnectionEntity = connectionEntities[connectionEntities.length - 1];
          return this.getConnections(limit, lastConnectionEntity.userId, connectionEntities);
        }

        return connectionEntities.length ? this.updateConnections(connectionEntities) : this.connectionEntities();
      })
      .catch(error => {
        this.logger.error(`Failed to retrieve connections from backend: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Ignore connection request.
   * @param {z.entity.User} userEntity - User to ignore the connection request
   * @returns {Promise} Promise that resolves when an incoming connection request was ignored
   */
  ignoreRequest(userEntity) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.IGNORED);
  }

  /**
   * Unblock a user.
   *
   * @param {z.entity.User} userEntity - User to unblock
   * @param {boolean} [showConversation=false] - Show new conversation on success
   * @returns {Promise} Promise that resolves when a user was unblocked
   */
  unblockUser(userEntity, showConversation = true) {
    return this._updateStatus(userEntity, z.connection.ConnectionStatus.ACCEPTED, showConversation);
  }

  /**
   * Update user matching a given connection.
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @returns {Promise} Promise that resolves when the connection have been updated
   */
  updateConnection(connectionEntity) {
    return Promise.resolve()
      .then(() => {
        if (!connectionEntity) {
          throw z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER);
        }

        this.connectionEntities.push(connectionEntity);
        return this.userRepository.get_user_by_id(connectionEntity.userId);
      })
      .then(userEntity => userEntity.connection(connectionEntity));
  }

  /**
   * Update users matching the given connections.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connection entities
   * @returns {Promise<Array<z.connection.ConnectionEntity>>} Promise that resolves when all connections have been updated
   */
  updateConnections(connectionEntities) {
    return Promise.resolve()
      .then(() => {
        if (!connectionEntities.length) {
          throw z.error.ConnectionError(z.error.BaseError.TYPE.INVALID_PARAMETER);
        }

        z.util.koArrayPushAll(this.connectionEntities, connectionEntities);

        return this.userRepository.updateUsersFromConnections(connectionEntities);
      })
      .then(() => this.connectionEntities());
  }

  /**
   * Update the status of a connection.
   * @private
   * @param {z.entity.User} userEntity - User to update connection with
   * @param {string} connectionStatus - Connection status
   * @param {boolean} [showConversation=false] - Show conversation on success
   * @returns {Promise} Promise that resolves when the connection status was updated
   */
  _updateStatus(userEntity, connectionStatus, showConversation = false) {
    if (!userEntity || !connectionStatus) {
      this.logger.error('Missing parameter to update connection');
      return Promise.reject(new z.error.ConnectionError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const currentStatus = userEntity.connection().status();
    if (currentStatus === connectionStatus) {
      this.logger.error(`Connection status change to '${connectionStatus}' for '${userEntity.id}' is no change`);
      return Promise.reject(new z.error.ConnectionError(z.error.BaseError.TYPE.INVALID_PARAMETER));
    }

    return this.connectionService
      .putConnections(userEntity.id, connectionStatus)
      .then(response => {
        const connectionEvent = {connection: response};
        return this.onUserConnection(connectionEvent, z.event.EventRepository.SOURCE.INJECTED, showConversation);
      })
      .catch(error => {
        const logMessage = `Connection change from '${currentStatus}' to '${connectionStatus}' failed`;
        this.logger.error(`${logMessage} for '${userEntity.id}' failed: ${error.message}`, error);

        const customData = {
          currentStatus,
          newStatus: connectionStatus,
          serverError: error,
        };

        Raygun.send(new Error(logMessage), customData);
      });
  }

  /**
   * Send the user connection notification.
   *
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @param {z.connection.ConnectionStatus} previousStatus - Previous connection status
   * @returns {undefined} No return value
   */
  _sendNotification(connectionEntity, source, previousStatus) {
    // We accepted the connection request or unblocked the user
    const expectedPreviousStatus = [z.connection.ConnectionStatus.BLOCKED, z.connection.ConnectionStatus.PENDING];
    const wasExpectedPreviousStatus = expectedPreviousStatus.includes(previousStatus);
    const selfUserAccepted = connectionEntity.isConnected() && wasExpectedPreviousStatus;
    const isWebSocketEvent = source === z.event.EventRepository.SOURCE.WEB_SOCKET;

    const showNotification = isWebSocketEvent && !selfUserAccepted;
    if (showNotification) {
      this.userRepository.get_user_by_id(connectionEntity.userId).then(userEntity => {
        const messageEntity = new z.entity.MemberMessage();
        messageEntity.user(userEntity);

        if (connectionEntity.isConnected()) {
          const statusWasSent = previousStatus === z.connection.ConnectionStatus.SENT;
          messageEntity.memberMessageType = statusWasSent
            ? z.message.SystemMessageType.CONNECTION_ACCEPTED
            : z.message.SystemMessageType.CONNECTION_CONNECTED;
        } else if (connectionEntity.isIncomingRequest()) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_REQUEST;
        }

        amplify.publish(z.event.WebApp.NOTIFICATION.NOTIFY, messageEntity, connectionEntity);
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionService = class ConnectionService {
  static get URL() {
    return {
      CONNECTIONS: '/connections',
    };
  }

  /**
   * Construct a new Connection Service.
   * @class z.connection.ConnectionService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.connection.ConnectionService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Retrieves a list of connections to other users.
   *
   * @note The list is already pre-ordered by the backend, so in order to fetch more connections
   * than the limit, you only have to pass the User ID (which is not from the self user)
   * of the last connection item from the received list.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//connections
   *
   * @param {number} limit - Number of results to return (default 100, max 500)
   * @param {string} userId - User ID to start from
   * @returns {Promise} Promise that resolves with user connections
   */
  getConnections(limit = 500, userId) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: userId,
      },
      type: 'GET',
      url: ConnectionService.URL.CONNECTIONS,
    });
  }

  /**
   * Create a connection request to another user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//createConnection
   *
   * @param {string} userId - User ID of the user to request a connection with
   * @param {string} name - Name of the conversation being initiated (1 - 256 characters)
   * @returns {Promise} Promise that resolves when the connection request was created
   */
  postConnections(userId, name) {
    return this.backendClient.sendJson({
      data: {
        message: ' ',
        name: name,
        user: userId,
      },
      type: 'POST',
      url: ConnectionService.URL.CONNECTIONS,
    });
  }

  /**
   * Updates a connection to another user.
   *
   * @example status: ['accepted', 'blocked', 'pending', 'ignored', 'sent' or 'cancelled']
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//updateConnection
   *
   * @param {string} userId - User ID of the other user
   * @param {z.connection.ConnectionStatus} connectionStatus - New relation status
   * @returns {Promise} Promise that resolves when the status was updated
   */
  putConnections(userId, connectionStatus) {
    return this.backendClient.sendJson({
      data: {
        status: connectionStatus,
      },
      type: 'PUT',
      url: `${ConnectionService.URL.CONNECTIONS}/${userId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.connection = z.connection || {};

z.connection.ConnectionStatus = {
  ACCEPTED: 'accepted',
  BLOCKED: 'blocked',
  CANCELLED: 'cancelled',
  IGNORED: 'ignored',
  PENDING: 'pending',
  SENT: 'sent',
  UNKNOWN: '',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientEntity = class ClientEntity {
  static get CONFIG() {
    return {
      DEFAULT_VALUE: '?',
    };
  }

  constructor(isSelfClient = false) {
    this.isSelfClient = isSelfClient;

    this.class = ClientEntity.CONFIG.DEFAULT_VALUE;
    this.id = '';

    if (this.isSelfClient) {
      this.address = '';
      this.cookie = '';
      this.label = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.location = {};
      this.model = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.time = ClientEntity.CONFIG.DEFAULT_VALUE;
      this.type = z.client.ClientType.TEMPORARY;
    }

    // Metadata maintained by us
    this.meta = {
      isVerified: ko.observable(false),
      primaryKey: undefined,
    };

    this.session = {};
  }

  /**
   * Splits an ID into user ID & client ID.
   * @param {string} id - Client ID to be dismantled
   * @returns {Object} Object containing the user ID & client ID
   */
  static dismantleUserClientId(id) {
    const [userId, clientId] = _.isString(id) ? id.split('@') : [];
    return {clientId, userId};
  }

  /**
   * Returns the ID of a client in a format suitable for UI display in user preferences.
   * @returns {Array<string>} Client ID in pairs of two as an array
   */
  formatId() {
    return z.util.zeroPadding(this.id, 16).match(/.{1,2}/g);
  }

  /**
   * @returns {boolean} True, if the client is the self user's permanent client.
   */
  isPermanent() {
    return this.type === z.client.ClientType.PERMANENT;
  }

  /**
   * @returns {boolean} - True, if it is NOT the client of the self user.
   */
  isRemote() {
    return !this.isPermanent() && !this.isTemporary();
  }

  /**
   * @returns {boolean} - True, if the client is the self user's temporary client.
   */
  isTemporary() {
    return this.type === z.client.ClientType.TEMPORARY;
  }

  /**
   * This method returns a JSON object which can be stored in our local database.
   * @returns {Object} Client data as JSON object
   */
  toJson() {
    const jsonObject = JSON.parse(ko.toJSON(this));
    delete jsonObject.isSelfClient;
    delete jsonObject.session;

    z.client.ClientMapper.CONFIG.CLIENT_PAYLOAD.forEach(name => this._removeDefaultValues(jsonObject, name));

    if (this.isSelfClient) {
      z.client.ClientMapper.CONFIG.SELF_CLIENT_PAYLOAD.forEach(name => this._removeDefaultValues(jsonObject, name));
    }

    jsonObject.meta.is_verified = jsonObject.meta.isVerified;
    delete jsonObject.meta.isVerified;

    if (jsonObject.meta.primaryKey) {
      jsonObject.meta.primary_key = jsonObject.meta.primaryKey;
      delete jsonObject.meta.primaryKey;
    }

    return jsonObject;
  }

  _removeDefaultValues(jsonObject, memberName) {
    if (jsonObject.hasOwnProperty(memberName)) {
      const isDefaultValue = jsonObject[memberName] === ClientEntity.CONFIG.DEFAULT_VALUE;
      if (isDefaultValue) {
        jsonObject[memberName] = '';
      }
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientMapper = class ClientMapper {
  static get CONFIG() {
    return {
      CLIENT_PAYLOAD: ['class', 'id'],
      SELF_CLIENT_PAYLOAD: ['address', 'cookie', 'label', 'location', 'model', 'time', 'type'],
    };
  }

  constructor() {}

  /**
   * Maps a JSON into a Client entity.
   *
   * @param {Object} clientPayload - Client data
   * @param {boolean} isSelfClient - Creating self client
   * @returns {z.client.ClientEntity} Mapped client entity
   */
  mapClient(clientPayload, isSelfClient) {
    const clientEntity = new z.client.ClientEntity(isSelfClient);

    ClientMapper.CONFIG.CLIENT_PAYLOAD.forEach(name => this._mapMember(clientEntity, clientPayload, name));

    if (isSelfClient) {
      ClientMapper.CONFIG.SELF_CLIENT_PAYLOAD.forEach(name => this._mapMember(clientEntity, clientPayload, name));
    }

    if (clientPayload.meta) {
      const {userId} = z.client.ClientEntity.dismantleUserClientId(clientPayload.meta.primary_key);

      clientEntity.meta.isVerified(clientPayload.meta.is_verified);
      clientEntity.meta.primaryKey = clientPayload.meta.primary_key;
      clientEntity.meta.userId = userId;
    }

    return clientEntity;
  }

  /**
   * Maps an object of client IDs with their payloads to client entities.
   *
   * @param {Array<Object>} clientsPayload - Clients data
   * @param {boolean} isSelfClient - Creating self client
   * @returns {Array<z.client.ClientEntity>} - Mapped client entities
   */
  mapClients(clientsPayload, isSelfClient) {
    return clientsPayload.map(clientPayload => this.mapClient(clientPayload, isSelfClient));
  }

  /**
   * Update a client entity or object from JSON.
   *
   * @param {z.client.ClientEntity|Object} clientData - Client data
   * @param {Object} updatePayload - JSON possibly containing updates
   * @returns {Object} Contains the client and whether there was a change
   */
  updateClient(clientData, updatePayload) {
    let containsUpdate = false;

    for (const member in updatePayload) {
      const isDataChange = JSON.stringify(clientData[member]) !== JSON.stringify(updatePayload[member]);

      if (isDataChange) {
        containsUpdate = true;
        clientData[member] = updatePayload[member];
      }
    }

    return {client: clientData, wasUpdated: containsUpdate};
  }

  _mapMember(clientEntity, clientPayload, memberName) {
    const payloadValue = clientPayload[memberName];
    const isMemberUndefined = payloadValue === undefined;
    if (!isMemberUndefined) {
      clientEntity[memberName] = payloadValue;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientRepository = class ClientRepository {
  static get CONFIG() {
    return {
      AVERAGE_NUMBER_OF_CLIENTS: 4,
    };
  }

  static get PRIMARY_KEY_CURRENT_CLIENT() {
    return 'local_identity';
  }

  constructor(clientService, cryptographyRepository) {
    this.clientService = clientService;
    this.cryptographyRepository = cryptographyRepository;
    this.selfUser = ko.observable(undefined);
    this.logger = new z.util.Logger('z.client.ClientRepository', z.config.LOGGER.OPTIONS);

    this.clientMapper = new z.client.ClientMapper();
    this.clients = ko.pureComputed(() => (this.selfUser() ? this.selfUser().devices() : []));
    this.currentClient = ko.observable();

    this.isTemporaryClient = ko.pureComputed(() => this.currentClient() && this.currentClient().isTemporary());

    amplify.subscribe(z.event.WebApp.LIFECYCLE.ASK_TO_CLEAR_DATA, this.logoutClient.bind(this));
    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.onUserEvent.bind(this));
  }

  init(selfUser) {
    this.selfUser(selfUser);
    this.logger.info(`Initialized repository with user ID '${this.selfUser().id}'`);
  }

  //##############################################################################
  // Service interactions
  //##############################################################################

  deleteClientFromDb(userId, clientId) {
    return this.clientService.deleteClientFromDb(this._constructPrimaryKey(userId, clientId));
  }

  /**
   * Delete the temporary client on the backend.
   * @returns {Promise} Resolves when the temporary client was deleted on the backend
   */
  deleteTemporaryClient() {
    return this.clientService.deleteTemporaryClient(this.currentClient().id);
  }

  /**
   * Load all known clients from the database.
   * @returns {Promise} Resolves with all the clients found in the local database
   */
  getAllClientsFromDb() {
    return this.clientService.loadAllClientsFromDb().then(clients => {
      const recipients = {};
      const skippedUserIds = [this.selfUser().id, z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT];

      for (const client of clients) {
        const {userId} = z.client.ClientEntity.dismantleUserClientId(client.meta.primary_key);
        if (userId && !skippedUserIds.includes(userId)) {
          recipients[userId] = recipients[userId] || [];
          recipients[userId].push(this.clientMapper.mapClient(client, false));
        }
      }
      return recipients;
    });
  }

  /**
   * Retrieves meta information about specific client of the self user.
   * @param {string} clientId - ID of client to be retrieved
   * @returns {Promise} Resolves with the retrieved client information
   */
  getClientByIdFromBackend(clientId) {
    return this.clientService.getClientById(clientId).catch(error => {
      const clientNotFoundBackend = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
      if (clientNotFoundBackend) {
        this.logger.warn(`Local client '${clientId}' no longer exists on the backend`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.NO_VALID_CLIENT);
      }

      throw error;
    });
  }

  /**
   * Loads a client from the database (if it exists).
   * @returns {Promise<z.client.ClientEntity>} Resolves with the local client
   */
  getCurrentClientFromDb() {
    return this.clientService
      .loadClientFromDb(z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT)
      .catch(() => {
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(clientPayload => {
        if (_.isString(clientPayload)) {
          this.logger.info('No local client found in database');
          throw new z.error.ClientError(z.error.ClientError.TYPE.NO_VALID_CLIENT);
        }

        const currentClient = this.clientMapper.mapClient(clientPayload, true);
        this.currentClient(currentClient);
        this.logger.info(`Loaded local client '${currentClient.id}'`, this.currentClient());
        return this.currentClient();
      });
  }

  /**
   * Construct the primary key to store clients in database.
   * @private
   *
   * @param {string} userId - User ID from the owner of the client
   * @param {string} clientId - ID of the client
   * @returns {string} Primary key
   */
  _constructPrimaryKey(userId, clientId) {
    if (!userId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_USER_ID);
    }
    if (!clientId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_CLIENT_ID);
    }
    return `${userId}@${clientId}`;
  }

  /**
   * Save the a client into the database.
   *
   * @private
   * @param {string} userId - ID of user client to be stored belongs to
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  saveClientInDb(userId, clientPayload) {
    const primaryKey = this._constructPrimaryKey(userId, clientPayload.id);
    return this.clientService.saveClientInDb(primaryKey, clientPayload);
  }

  /**
   * Updates properties for a client record in database.
   *
   * @todo Merge "meta" property before updating it, Object.assign(payload.meta, changes.meta)
   * @param {string} userId - User ID of the client owner
   * @param {string} clientId - Client ID which needs to get updated
   * @param {string} changes - New values which should be updated on the client
   * @returns {number} Number of updated records
   */
  updateClientInDb(userId, clientId, changes) {
    const primaryKey = this._constructPrimaryKey(userId, clientId);
    // Preserve primary key on update
    changes.meta.primary_key = primaryKey;
    return this.clientService.updateClientInDb(primaryKey, changes);
  }

  /**
   * Change verification state of client.
   *
   * @param {string} userId - User ID of the client owner
   * @param {z.client.ClientEntity} clientEntity - Client which needs to get updated
   * @param {boolean} isVerified - New state to apply
   * @returns {Promise} Resolves when the verification state has been updated
   */
  verifyClient(userId, clientEntity, isVerified) {
    return this.updateClientInDb(userId, clientEntity.id, {meta: {is_verified: isVerified}}).then(() => {
      clientEntity.meta.isVerified(isVerified);
      amplify.publish(z.event.WebApp.CLIENT.VERIFICATION_STATE_CHANGED, userId, clientEntity, isVerified);
    });
  }

  /**
   * Save the local client into the database.
   *
   * @private
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  _saveCurrentClientInDb(clientPayload) {
    clientPayload.meta = {is_verified: true};
    return this.clientService.saveClientInDb(z.client.ClientRepository.PRIMARY_KEY_CURRENT_CLIENT, clientPayload);
  }

  /**
   * Updates a client payload if it does not fit the current database structure.
   *
   * @private
   * @param {string} userId - User ID of the client owner
   * @param {Object} clientPayload - Client data to be stored in database
   * @returns {Promise} Resolves with the record stored in database
   */
  _updateClientSchemaInDb(userId, clientPayload) {
    clientPayload.meta = {
      is_verified: false,
      primary_key: this._constructPrimaryKey(userId, clientPayload.id),
    };
    return this.saveClientInDb(userId, clientPayload);
  }

  //##############################################################################
  // Login and registration
  //##############################################################################

  /**
   * Constructs the value for a cookie label.
   * @param {string} login - Email or phone number of the user
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @returns {string} Cookie label
   */
  constructCookieLabel(login, clientType = this._loadCurrentClientType()) {
    const loginHash = z.util.murmurhash3(login || this.selfUser().id, 42);
    return `webapp@${loginHash}@${clientType}@${Date.now()}`;
  }

  /**
   * Constructs the key for a cookie label.
   * @param {string} login - Email or phone number of the user
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @returns {string} Cookie label key
   */
  constructCookieLabelKey(login, clientType = this._loadCurrentClientType()) {
    const loginHash = z.util.murmurhash3(login || this.selfUser().id, 42);
    return `${z.storage.StorageKey.AUTH.COOKIE_LABEL}@${loginHash}@${clientType}`;
  }

  /**
   * Get and validate the local client.
   * @returns {Promise} Resolve with an observable containing the client if valid
   */
  getValidLocalClient() {
    return this.getCurrentClientFromDb()
      .then(clientEntity => this.getClientByIdFromBackend(clientEntity.id))
      .then(clientPayload => {
        this.logger.info(`Client with ID '${clientPayload.id}' (${clientPayload.type}) validated on backend`);
        return this.currentClient;
      })
      .catch(error => {
        const clientNotValidated = error.type === z.error.ClientError.TYPE.NO_VALID_CLIENT;
        if (!clientNotValidated) {
          this.logger.error(`Getting valid local client failed: ${error.code || error.message}`, error);
        }

        throw error;
      });
  }

  /**
   * Register a new client.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/registerClient
   *
   * @note Password is needed for the registration of a client once 1st client has been registered.
   * @param {string|undefined} password - User password for verification
   * @returns {Promise<z.client.ClientEntity>} Resolve with the newly registered client
   */
  registerClient(password) {
    const clientType = this._loadCurrentClientType();

    return this.cryptographyRepository
      .generateClientKeys()
      .then(keys => this.clientService.postClients(this._createRegistrationPayload(clientType, password, keys)))
      .catch(error => {
        const tooManyClients = error.label === z.error.BackendClientError.LABEL.TOO_MANY_CLIENTS;
        if (tooManyClients) {
          throw new z.error.ClientError(z.error.ClientError.TYPE.TOO_MANY_CLIENTS);
        }
        this.logger.error(`Client registration request failed: ${error.message}`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.REQUEST_FAILURE);
      })
      .then(response => {
        const {cookie, id, type} = response;
        this.logger.info(`Registered '${type}' client '${id}' with cookie label '${cookie}'`, response);
        const currentClient = this.clientMapper.mapClient(response, true);
        this.currentClient(currentClient);
        return this._saveCurrentClientInDb(response);
      })
      .catch(error => {
        const handledErrors = [z.error.ClientError.TYPE.REQUEST_FAILURE, z.error.ClientError.TYPE.TOO_MANY_CLIENTS];

        if (handledErrors.includes(error.type)) {
          throw error;
        }
        this.logger.error(`Failed to save client: ${error.message}`, error);
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(clientPayload => this._transferCookieLabel(clientType, clientPayload.cookie))
      .then(() => this.currentClient)
      .catch(error => {
        this.logger.error(`Client registration failed: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Create payload for client registration.
   *
   * @private
   * @param {z.client.ClientType} clientType - Type of client to be registered
   * @param {string} password - User password
   * @param {string} lastResortKey - Last resort key
   * @param {Array<string>} preKeys - Pre-keys
   * @param {Array<string>} signalingKeys - Signaling keys
   * @returns {Object} - Payload to register client with backend
   */
  _createRegistrationPayload(clientType, password, [lastResortKey, preKeys, signalingKeys]) {
    let deviceLabel = `${platform.os.family}`;

    if (platform.os.version) {
      deviceLabel += ` ${platform.os.version}`;
    }

    let deviceModel = platform.name;

    if (z.util.Environment.desktop) {
      let identifier;
      if (z.util.Environment.os.mac) {
        identifier = z.string.wireMacos;
      } else if (z.util.Environment.os.win) {
        identifier = z.string.wireWindows;
      } else {
        identifier = z.string.wireLinux;
      }
      deviceModel = z.l10n.text(identifier);
      if (!z.util.Environment.frontend.isProduction()) {
        deviceModel = `${deviceModel} (Internal)`;
      }
    } else if (clientType === z.client.ClientType.TEMPORARY) {
      deviceModel = `${deviceModel} (Temporary)`;
    }

    return {
      class: 'desktop',
      cookie: this._getCookieLabelValue(this.selfUser().email() || this.selfUser().phone()),
      label: deviceLabel,
      lastkey: lastResortKey,
      model: deviceModel,
      password: password,
      prekeys: preKeys,
      sigkeys: signalingKeys,
      type: clientType,
    };
  }

  /**
   * Gets the value for a cookie label.
   * @private
   * @param {string} login - Email or phone number of the user
   * @returns {string} Cookie label
   */
  _getCookieLabelValue(login) {
    return z.util.StorageUtil.getValue(this.constructCookieLabelKey(login));
  }

  /**
   * Loads the cookie label value from the Local Storage and saves it into IndexedDB.
   *
   * @private
   * @param {z.client.ClientType} clientType - Temporary or permanent client type
   * @param {string} cookieLabel - Cookie label, something like "webapp@2153234453@temporary@145770538393"
   * @returns {Promise} Resolves with the key of the stored cookie label
   */
  _transferCookieLabel(clientType, cookieLabel) {
    const indexedDbKey = z.storage.StorageKey.AUTH.COOKIE_LABEL;
    const userIdentifier = this.selfUser().email() || this.selfUser().phone();
    const localStorageKey = this.constructCookieLabelKey(userIdentifier, clientType);

    if (cookieLabel === undefined) {
      cookieLabel = this.constructCookieLabel(userIdentifier, clientType);
      this.logger.warn(`Cookie label is in an invalid state. We created a new one: '${cookieLabel}'`);
      z.util.StorageUtil.setValue(localStorageKey, cookieLabel);
    }

    this.logger.info(`Saving cookie label '${cookieLabel}' in IndexedDB`, {
      key: localStorageKey,
      value: cookieLabel,
    });

    return this.cryptographyRepository.storageRepository.saveValue(indexedDbKey, cookieLabel);
  }

  /**
   * Load current client type from amplify store.
   * @private
   * @returns {z.client.ClientType} Type of current client
   */
  _loadCurrentClientType() {
    if (this.currentClient()) {
      return this.currentClient().type;
    }
    const isPermanent = z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.PERSIST);
    const type = isPermanent ? z.client.ClientType.PERMANENT : z.client.ClientType.TEMPORARY;
    return z.util.Environment.electron ? z.client.ClientType.PERMANENT : type;
  }

  //##############################################################################
  // Client handling
  //##############################################################################

  /**
   * Delete client of a user on backend and removes it locally.
   *
   * @param {string} clientId - ID of the client that should be deleted
   * @param {string} password - Password entered by user
   * @returns {Promise} Resolves with the remaining user devices
   */
  deleteClient(clientId, password) {
    return this.clientService
      .deleteClient(clientId, password)
      .then(() => this.deleteClientFromDb(this.selfUser().id, clientId))
      .then(() => {
        this.selfUser().remove_client(clientId);
        amplify.publish(z.event.WebApp.USER.CLIENT_REMOVED, this.selfUser().id, clientId);
        return this.clients();
      })
      .catch(error => {
        this.logger.error(`Unable to delete client '${clientId}': ${error.message}`, error);

        const isForbidden = z.error.BackendClientError.STATUS_CODE.FORBIDDEN;
        const errorType = isForbidden
          ? z.error.ClientError.TYPE.REQUEST_FORBIDDEN
          : z.error.ClientError.TYPE.REQUEST_FAILURE;
        throw new z.error.ClientError(errorType);
      });
  }

  removeLocalClient() {
    this.cryptographyRepository.storageRepository.deleteCryptographyStores().then(() => {
      const shouldClearData = this.currentClient().isTemporary();
      amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.CLIENT_REMOVED, shouldClearData);
    });
  }

  logoutClient() {
    if (this.currentClient()) {
      if (this.isTemporaryClient()) {
        return this.deleteTemporaryClient().then(() =>
          amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.USER_REQUESTED, true)
        );
      }

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.OPTION, {
        action: clearData => {
          return amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.USER_REQUESTED, clearData);
        },
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalAccountLogoutAction),
          option: z.l10n.text(z.string.modalAccountLogoutOption),
          title: z.l10n.text(z.string.modalAccountLogoutHeadline),
        },
        warning: false,
      });
    }
  }

  /**
   * Removes a stored client and the session connected with it.
   *
   * @param {string} userId - ID of user
   * @param {string} clientId - ID of client to be deleted
   * @returns {Promise} Resolves when a client and its session have been deleted
   */
  removeClient(userId, clientId) {
    return this.cryptographyRepository
      .deleteSession(userId, clientId)
      .then(() => this.deleteClientFromDb(userId, clientId));
  }

  /**
   * Retrieves meta information about all the clients of a given user.
   * @note If you want to get very detailed information about the devices from the own user, then use "@getClients"
   *
   * @param {string} userId - User ID to retrieve client information for
   * @returns {Promise} Resolves with an array of client entities
   */
  getClientsByUserId(userId) {
    return this.clientService
      .getClientsByUserId(userId)
      .then(clientsData => this._updateClientsOfUserById(userId, clientsData));
  }

  getClientByUserIdFromDb(requestedUserId) {
    return this.clientService.loadAllClientsFromDb().then(clients => {
      return clients.filter(client => {
        const {userId} = z.client.ClientEntity.dismantleUserClientId(client.meta.primary_key);
        return userId === requestedUserId;
      });
    });
  }

  /**
   * Retrieves meta information about all other locally known clients of the self user.
   * @returns {Promise} Resolves with all locally known clients except the current one
   */
  getClientsForSelf() {
    this.logger.info(`Retrieving all clients of the self user from database`);
    return this.getClientByUserIdFromDb(this.selfUser().id)
      .then(clientsData => this.clientMapper.mapClients(clientsData, true))
      .then(clientEntities => {
        clientEntities.forEach(clientEntity => this.selfUser().add_client(clientEntity));
        return this.selfUser().devices();
      });
  }

  /**
   * Is the current client permanent.
   * @returns {boolean} Type of current client is permanent
   */
  isCurrentClientPermanent() {
    if (!this.currentClient()) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.CLIENT_NOT_SET);
    }
    return z.util.Environment.electron || this.currentClient().isPermanent();
  }

  /**
   * Update clients of the self user.
   * @returns {Promise} Resolves when the clients have been updated
   */
  updateClientsForSelf() {
    return this.clientService
      .getClients()
      .then(clientsData => this._updateClientsOfUserById(this.selfUser().id, clientsData, false));
  }

  /**
   * Update clients of a user with the given backend data.
   * @note This function matches clients retrieved from the backend with the data stored in the local database.
   *   Clients will then be updated with the backend payload in the database and mapped into entities.
   *
   * @private
   * @param {string} userId - ID of user whose clients are updated
   * @param {Object} clientsData - Clients data from backend
   * @param {booelan} [publish=true] - Publish changes clients using amplify
   * @returns {Promise<Array<z.client.Client>>} Resolves with the entities once clients have been updated
   */
  _updateClientsOfUserById(userId, clientsData, publish = true) {
    const clientsFromBackend = {};
    const clientsStoredInDb = [];
    const isSelfUser = userId === this.selfUser().id;

    for (const client of clientsData) {
      clientsFromBackend[client.id] = client;
    }

    // Find clients in database
    return this.getClientByUserIdFromDb(userId)
      .then(clientsFromDatabase => {
        const promises = [];

        for (const databaseClient of clientsFromDatabase) {
          const clientId = databaseClient.id;
          const backendClient = clientsFromBackend[clientId];

          if (backendClient) {
            const {client, wasUpdated} = this.clientMapper.updateClient(databaseClient, backendClient);

            delete clientsFromBackend[clientId];

            if (this.currentClient() && this._isCurrentClient(userId, clientId)) {
              this.logger.warn(`Removing duplicate self client '${clientId}' locally`);
              this.removeClient(userId, clientId);
            }

            // Locally known client changed on backend
            if (wasUpdated) {
              this.logger.info(`Updating client '${clientId}' of user '${userId}' locally`);
              promises.push(this.saveClientInDb(userId, client));
              continue;
            }

            // Locally known client unchanged on backend
            clientsStoredInDb.push(client);
            continue;
          }

          // Locally known client deleted on backend
          this.logger.warn(`Removing client '${clientId}' of user '${userId}' locally`);
          this.removeClient(userId, clientId);
        }

        for (const clientId in clientsFromBackend) {
          const clientPayload = clientsFromBackend[clientId];

          if (this.currentClient() && this._isCurrentClient(userId, clientId)) {
            continue;
          }

          // Locally unknown client new on backend
          this.logger.info(`New client '${clientId}' of user '${userId}' will be stored locally`);
          if (this.selfUser().id === userId) {
            this.onClientAdd({client: clientPayload});
          }
          promises.push(this._updateClientSchemaInDb(userId, clientPayload));
        }

        return Promise.all(promises);
      })
      .then(newRecords => this.clientMapper.mapClients(clientsStoredInDb.concat(newRecords), isSelfUser))
      .then(clientEntities => {
        if (publish) {
          amplify.publish(z.event.WebApp.CLIENT.UPDATE, userId, clientEntities);
        }
        return clientEntities;
      })
      .catch(error => {
        this.logger.error(`Unable to retrieve clients for user '${userId}': ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check if client is current local client.
   *
   * @private
   * @param {string} userId - User ID to be checked
   * @param {string} clientId - ID of client to be checked
   * @returns {boolean} Is the client the current local client
   */
  _isCurrentClient(userId, clientId) {
    if (!this.currentClient()) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.CLIENT_NOT_SET);
    }
    if (!userId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_USER_ID);
    }
    if (!clientId) {
      throw new z.error.ClientError(z.error.ClientError.TYPE.NO_CLIENT_ID);
    }
    return userId === this.selfUser().id && clientId === this.currentClient().id;
  }

  //##############################################################################
  // Conversation Events
  //##############################################################################

  /**
   * Listener for incoming user events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  onUserEvent(eventJson, source) {
    const type = eventJson.type;

    const isClientAdd = type === z.event.Backend.USER.CLIENT_ADD;
    if (isClientAdd) {
      return this.onClientAdd(eventJson);
    }

    const isClientRemove = type === z.event.Backend.USER.CLIENT_REMOVE;
    if (isClientRemove) {
      this.onClientRemove(eventJson);
    }
  }

  /**
   * A client was added by the self user.
   * @param {Object} eventJson - JSON data of 'user.client-add' event
   * @returns {undefined} No return value
   */
  onClientAdd(eventJson) {
    this.logger.info('Client of self user added', eventJson);
    amplify.publish(z.event.WebApp.CLIENT.ADD, this.selfUser().id, eventJson.client, true);
  }

  /**
   * A client was removed by the self user.
   * @param {Object} [eventJson={}] - JSON data of 'user.client-remove' event
   * @returns {Promise} Resolves when the event has been handled
   */
  onClientRemove(eventJson = {}) {
    const clientId = eventJson.client ? eventJson.client.id : undefined;
    if (clientId) {
      const isCurrentClient = clientId === this.currentClient().id;
      if (isCurrentClient) {
        return this.removeLocalClient();
      }

      amplify.publish(z.event.WebApp.CLIENT.REMOVE, this.selfUser().id, clientId);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientService = class ClientService {
  static get URL_CLIENTS() {
    return '/clients';
  }

  static get URL_USERS() {
    return '/users';
  }

  /**
   * Construct a new client service.
   * @param {BackendClient} backendClient - Client for the API calls
   * @param {z.storage.StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.client.ClientService', z.config.LOGGER.OPTIONS);

    this.CLIENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CLIENTS;
  }

  //##############################################################################
  // Backend requests
  //##############################################################################

  /**
   * Deletes a specific client from a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/deleteClient
   *
   * @param {string} clientId - ID of client to be deleted
   * @param {string} password - User password
   * @returns {Promise} Resolves once the deletion of the client is complete
   */
  deleteClient(clientId, password) {
    return this.backendClient.sendJson({
      data: {
        password,
      },
      type: 'DELETE',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Deletes the temporary client of a user.
   * @param {string} clientId - ID of the temporary client to be deleted
   * @returns {Promise} - Resolves once the deletion of the temporary client is complete
   */
  deleteTemporaryClient(clientId) {
    return this.backendClient.sendJson({
      data: {},
      type: 'DELETE',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Retrieves meta information about a specific client.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getClients
   *
   * @param {string} clientId - ID of client to be retrieved
   * @returns {Promise} Resolves with the requested client
   */
  getClientById(clientId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ClientService.URL_CLIENTS}/${clientId}`,
    });
  }

  /**
   * Retrieves meta information about all the clients self user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/listClients
   * @returns {Promise} Resolves with the clients of the self user
   */
  getClients() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: ClientService.URL_CLIENTS,
    });
  }

  /**
   * Retrieves meta information about all the clients of a specific user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getClients
   *
   * @param {string} userId - ID of user to retrieve clients for
   * @returns {Promise} Resolves with the clients of a user
   */
  getClientsByUserId(userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ClientService.URL_USERS}/${userId}${ClientService.URL_CLIENTS}`,
    });
  }

  /**
   * Register a new client.
   * @param {Object} payload - Client payload
   * @returns {Promise} Resolves with the registered client information
   */
  postClients(payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: ClientService.URL_CLIENTS,
    });
  }

  //##############################################################################
  // Database requests
  //##############################################################################

  /**
   * Removes a client from the database.
   * @param {string} primaryKey - Primary key used to find the client for deletion in the database
   * @returns {Promise} Resolves once the client is deleted
   */
  deleteClientFromDb(primaryKey) {
    return this.storageService.delete(this.CLIENT_STORE_NAME, primaryKey);
  }

  /**
   * Load all clients we have stored in the database.
   * @returns {Promise} Resolves with all the clients payloads
   */
  loadAllClientsFromDb() {
    return this.storageService.getAll(this.CLIENT_STORE_NAME);
  }

  /**
   * Loads a persisted client from the database.
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @returns {Promise<JSON|string>} Resolves with the client's payload or the primary key if not found
   */
  loadClientFromDb(primaryKey) {
    return this.storageService.db[this.CLIENT_STORE_NAME]
      .where('meta.primary_key')
      .equals(primaryKey)
      .first()
      .then(clientRecord => {
        if (clientRecord === undefined) {
          this.logger.info(`Client with primary key '${primaryKey}' not found in database`);
          return primaryKey;
        }
        this.logger.info(`Loaded client record from database '${primaryKey}'`, clientRecord);
        return clientRecord;
      });
  }

  /**
   * Persists a client.
   *
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @param {Object} clientPayload - Client payload
   * @returns {Promise<Object>} Resolves with the client payload stored in database
   */
  saveClientInDb(primaryKey, clientPayload) {
    if (!clientPayload.meta) {
      clientPayload.meta = {};
    }

    clientPayload.meta.primary_key = primaryKey;

    return this.storageService.save(this.CLIENT_STORE_NAME, primaryKey, clientPayload).then(() => {
      this.logger.info(`Client '${clientPayload.id}' stored with primary key '${primaryKey}'`, clientPayload);
      return clientPayload;
    });
  }

  /**
   * Updates a persisted client in the database.
   *
   * @param {string} primaryKey - Primary key used to find a client in the database
   * @param {Object} changes - Incremental update changes of the client JSON
   * @returns {Promise<Integer>} Number of updated records (1 if an object was updated, otherwise 0)
   */
  updateClientInDb(primaryKey, changes) {
    return this.storageService.update(this.CLIENT_STORE_NAME, primaryKey, changes);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.client = z.client || {};

z.client.ClientType = {
  PERMANENT: 'permanent',
  TEMPORARY: 'temporary',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

/**
 * @typedef {Object} EventHandlingConfig - Object representing conversation event handlers
 * @property {() => void} [eventId: string] - an event handler function
 */

z.conversation.AbstractConversationEventHandler = class AbstractConversationEventHandler {
  /**
   * Abstract class that represents an entity that can react to a conversation event.
   */
  constructor() {
    this.eventHandlingConfig = {};
  }

  /**
   * Adds an event handling config to the current instance.
   *
   * @param {EventHandlingConfig} eventHandlingConfig - Config containing events name and the associated callback
   * @returns {void} No return value
   */
  setEventHandlingConfig(eventHandlingConfig) {
    this.eventHandlingConfig = eventHandlingConfig;
  }

  /**
   * Handles a conversation event.
   *
   * @param {z.entity.Conversation} conversationEntity - the conversation the event relates to
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  handleConversationEvent(conversationEntity, eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    const handler = this.eventHandlingConfig[eventJson.type] || (() => Promise.resolve());
    return handler.bind(this)(conversationEntity, eventJson);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_MODE = {
  CODE: 'code',
  INVITE: 'invite',
  PRIVATE: 'private',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_ROLE = {
  ACTIVATED: 'activated',
  NON_ACTIVATED: 'non_activated',
  PRIVATE: 'private',
  TEAM: 'team',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ACCESS_STATE = {
  PERSONAL: {
    GROUP: 'z.conversation.ACCESS_STATE.PERSONAL.GROUP',
    ONE2ONE: 'z.conversation.ACCESS_STATE.PERSONAL.ONE2ONE',
  },
  SELF: 'z.conversation.ACCESS_STATE.SELF',
  TEAM: {
    GUEST_ROOM: 'z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM',
    LEGACY: 'z.conversation.ACCESS_STATE.TEAM.LEGACY',
    ONE2ONE: 'z.conversation.ACCESS_STATE.TEAM.ONE2ONE',
    TEAM_ONLY: 'z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY',
  },
  UNKNOWN: 'z.conversation.ACCESS_STATE.UNKNOWN',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ClientMismatchHandler = class ClientMismatchHandler {
  constructor(conversationRepository, cryptographyRepository, eventRepository, serverTimeRepository, userRepository) {
    this.conversationRepository = conversationRepository;
    this.cryptographyRepository = cryptographyRepository;
    this.eventRepository = eventRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.conversation.ClientMismatchHandler', z.config.LOGGER.OPTIONS);
  }

  /**
   * Handle client mismatch response from backend.
   *
   * @note As part of 412 or general response when sending encrypted message
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about message
   * @param {Object} clientMismatch - Client mismatch object containing client user maps for deleted, missing and obsolete clients
   * @param {Object} payload - Initial payload resulting in a 412
   * @returns {Promise} Resolve when mismatch was handled
   */
  onClientMismatch(eventInfoEntity, clientMismatch, payload) {
    const {deleted: deletedClients, missing: missingClients, redundant: redundantClients} = clientMismatch;

    return Promise.resolve()
      .then(() => this._handleClientMismatchRedundant(redundantClients, payload, eventInfoEntity))
      .then(updatedPayload => this._handleClientMismatchDeleted(deletedClients, updatedPayload))
      .then(updatedPayload => this._handleClientMismatchMissing(missingClients, updatedPayload, eventInfoEntity));
  }

  /**
   * Handle the deleted client mismatch.
   *
   * @note Contains clients of which the backend is sure that they should not be recipient of a message and verified they no longer exist.
   * @private
   *
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchDeleted(recipients, payload) {
    if (_.isEmpty(recipients)) {
      return Promise.resolve(payload);
    }
    this.logger.debug(`Message contains deleted clients of '${Object.keys(recipients).length}' users`, recipients);

    const _removeDeletedClient = (userId, clientId) => {
      delete payload.recipients[userId][clientId];
      return this.userRepository.remove_client_from_user(userId, clientId);
    };

    const _removeDeletedUser = userId => {
      const clientIdsOfUser = Object.keys(payload.recipients[userId]);
      const noRemainingClients = !clientIdsOfUser.length;

      if (noRemainingClients) {
        delete payload.recipients[userId];
      }
    };

    return Promise.all(this._mapRecipients(recipients, _removeDeletedClient, _removeDeletedUser)).then(() => {
      this.conversationRepository.verification_state_handler.onClientRemoved();
      return payload;
    });
  }

  /**
   * Handle the missing client mismatch.
   *
   * @private
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchMissing(recipients, payload, eventInfoEntity) {
    const missingUserIds = Object.keys(recipients);
    if (!missingUserIds.length) {
      return Promise.resolve(payload);
    }

    this.logger.debug(`Message is missing clients of '${missingUserIds.length}' users`, recipients);
    const {conversationId, genericMessage, timestamp} = eventInfoEntity;

    const skipParticipantsCheck = !conversationId;
    const participantsCheckPromise = skipParticipantsCheck
      ? Promise.resolve()
      : this.conversationRepository.get_conversation_by_id(conversationId).then(conversationEntity => {
          const knownUserIds = conversationEntity.participating_user_ids();
          const unknownUserIds = z.util.ArrayUtil.getDifference(knownUserIds, missingUserIds);

          if (unknownUserIds.length) {
            return this.conversationRepository.addMissingMember(conversationId, unknownUserIds, timestamp - 1);
          }
        });

    return participantsCheckPromise
      .then(() => this.cryptographyRepository.encryptGenericMessage(recipients, genericMessage, payload))
      .then(updatedPayload => {
        payload = updatedPayload;

        const _addMissingClient = (userId, clientId) => this.userRepository.addClientToUser(userId, {id: clientId});
        return Promise.all(this._mapRecipients(recipients, _addMissingClient));
      })
      .then(() => {
        this.conversationRepository.verification_state_handler.onClientsAdded(Object.keys(recipients));
        return payload;
      });
  }

  /**
   * Handle the redundant client mismatch.

   * @note Contains clients of which the backend is sure that they should not be recipient of a message but cannot say whether they exist.
   *   Normally only contains clients of users no longer participating in a conversation.
   *   Sometimes clients of the self user are listed. Thus we cannot remove the payload for all the clients of a user without checking.
   * @private
   *
   * @param {Object} recipients - User client map containing redundant clients
   * @param {Object} payload - Payload of the request
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves with the updated payload
   */
  _handleClientMismatchRedundant(recipients, payload, eventInfoEntity) {
    if (_.isEmpty(recipients)) {
      return Promise.resolve(payload);
    }
    this.logger.debug(`Message contains redundant clients of '${Object.keys(recipients).length}' users`, recipients);
    const conversationId = eventInfoEntity.conversationId;

    const conversationPromise = conversationId
      ? this.conversationRepository.get_conversation_by_id(conversationId).catch(error => {
          const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
          if (!isConversationNotFound) {
            throw error;
          }
        })
      : Promise.resolve();

    return conversationPromise.then(conversationEntity => {
      const _removeRedundantClient = (userId, clientId) => delete payload.recipients[userId][clientId];

      const _removeRedundantUser = userId => {
        const clientIdsOfUser = Object.keys(payload.recipients[userId]);
        const noRemainingClients = !clientIdsOfUser.length;

        if (noRemainingClients) {
          const isGroupConversation = conversationEntity && conversationEntity.isGroup();
          if (isGroupConversation) {
            const timestamp = this.serverTimeRepository.toServerTimestamp();
            const event = z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, false, timestamp);

            this.eventRepository.injectEvent(event);
          }

          delete payload.recipients[userId];
        }
      };

      return Promise.all(this._mapRecipients(recipients, _removeRedundantClient, _removeRedundantUser)).then(() => {
        if (conversationEntity) {
          this.conversationRepository.updateParticipatingUserEntities(conversationEntity);
        }

        return payload;
      });
    });
  }

  /**
   * Map a function to recipients.
   *
   * @private
   * @param {Object} recipients - User client map
   * @param {Function} clientFn - Function to be executed on clients first
   * @param {Function} [userFn] - Function to be executed on users at the end
   * @returns {Array} Function array
   */
  _mapRecipients(recipients, clientFn, userFn) {
    const result = [];

    Object.entries(recipients).forEach(([userId, clientIds = []]) => {
      if (_.isFunction(clientFn)) {
        clientIds.forEach(clientId => result.push(clientFn(userId, clientId)));
      }

      if (_.isFunction(userFn)) {
        result.push(userFn(userId));
      }
    });

    return result;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationCellState = (() => {
  const ACTIVITY_TYPE = {
    CALL: 'ConversationCellState.ACTIVITY_TYPE.CALL',
    MENTION: 'ConversationCellState.ACTIVITY_TYPE.MENTION',
    MESSAGE: 'ConversationCellState.ACTIVITY_TYPE.MESSAGE',
    PING: 'ConversationCellState.ACTIVITY_TYPE.PING',
    REPLY: 'ConversationCellState.ACTIVITY_TYPE.REPLY',
  };

  const _accumulateSummary = (conversationEntity, prioritizeMentionAndReply) => {
    const {
      calls: unreadCalls,
      otherMessages: unreadOtherMessages,
      pings: unreadPings,
      selfMentions: unreadSelfMentions,
      selfReplies: unreadSelfReplies,
    } = conversationEntity.unreadState();

    // Sorted in order of alert type priority
    const activities = {
      [ACTIVITY_TYPE.MENTION]: unreadSelfMentions.length,
      [ACTIVITY_TYPE.REPLY]: unreadSelfReplies.length,
      [ACTIVITY_TYPE.CALL]: unreadCalls.length,
      [ACTIVITY_TYPE.PING]: unreadPings.length,
      [ACTIVITY_TYPE.MESSAGE]: unreadOtherMessages.length,
    };

    const alertCount = Object.values(activities).reduce((accumulator, value) => accumulator + value, 0);
    const hasSingleAlert = alertCount === 1;
    const hasOnlyReplies = activities[ACTIVITY_TYPE.REPLY] > 0 && alertCount === activities[ACTIVITY_TYPE.REPLY];

    if (prioritizeMentionAndReply && (hasSingleAlert || hasOnlyReplies)) {
      const hasSingleMention = activities[ACTIVITY_TYPE.MENTION] === 1;

      if (hasSingleMention || hasOnlyReplies) {
        const [mentionMessageEntity] = unreadSelfMentions;
        const [replyMessageEntity] = unreadSelfReplies;
        const messageEntity = mentionMessageEntity || replyMessageEntity;

        if (messageEntity.is_ephemeral()) {
          let stringId;

          if (hasSingleMention) {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralMentionGroup
              : z.string.conversationsSecondaryLineEphemeralMention;
          } else {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralReplyGroup
              : z.string.conversationsSecondaryLineEphemeralReply;
          }

          return z.l10n.text(stringId);
        }

        return conversationEntity.isGroup()
          ? `${messageEntity.unsafeSenderName()}: ${messageEntity.get_first_asset().text}`
          : messageEntity.get_first_asset().text;
      }
    }

    return _generateSummaryDescription(activities);
  };

  const _generateSummaryDescription = activities => {
    return Object.entries(activities)
      .map(([activity, activityCount]) => {
        if (activityCount) {
          const activityCountIsOne = activityCount === 1;
          let stringId = undefined;

          switch (activity) {
            case ACTIVITY_TYPE.CALL: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMissedCall
                : z.string.conversationsSecondaryLineSummaryMissedCalls;
              break;
            }

            case ACTIVITY_TYPE.MENTION: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMention
                : z.string.conversationsSecondaryLineSummaryMentions;
              break;
            }

            case ACTIVITY_TYPE.MESSAGE: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryMessage
                : z.string.conversationsSecondaryLineSummaryMessages;
              break;
            }

            case ACTIVITY_TYPE.PING: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryPing
                : z.string.conversationsSecondaryLineSummaryPings;
              break;
            }

            case ACTIVITY_TYPE.REPLY: {
              stringId = activityCountIsOne
                ? z.string.conversationsSecondaryLineSummaryReply
                : z.string.conversationsSecondaryLineSummaryReplies;
              break;
            }

            default:
              throw new z.error.ConversationError();
          }

          return z.l10n.text(stringId, activityCount);
        }
      })
      .filter(activityString => !!activityString)
      .join(', ');
  };

  const _getStateAlert = {
    description: conversationEntity => _accumulateSummary(conversationEntity, true),
    icon: conversationEntity => {
      const {
        calls: unreadCalls,
        pings: unreadPings,
        selfMentions: unreadSelfMentions,
        selfReplies: unreadSelfReplies,
      } = conversationEntity.unreadState();

      if (unreadSelfMentions.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_MENTION;
      }

      if (unreadSelfReplies.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_REPLY;
      }

      if (unreadCalls.length) {
        return z.conversation.ConversationStatusIcon.MISSED_CALL;
      }

      if (unreadPings.length) {
        return z.conversation.ConversationStatusIcon.UNREAD_PING;
      }
    },
    match: conversationEntity => {
      const {
        calls: unreadCalls,
        pings: unreadPings,
        selfMentions: unreadSelfMentions,
        selfReplies: unreadSelfReplies,
      } = conversationEntity.unreadState();

      const hasUnreadActivities =
        unreadCalls.length > 0 ||
        unreadPings.length > 0 ||
        unreadSelfMentions.length > 0 ||
        unreadSelfReplies.length > 0;

      return hasUnreadActivities;
    },
  };

  const _getStateCall = {
    description: conversationEntity => {
      const creatorName = conversationEntity.call().creatingUser.first_name();
      return z.l10n.text(z.string.conversationsSecondaryLineIncomingCall, creatorName);
    },
    icon: () => z.conversation.ConversationStatusIcon.NONE,
    match: conversationEntity => {
      return conversationEntity.call()
        ? conversationEntity.call().canJoinState() && !conversationEntity.call().selfUserJoined()
        : false;
    },
  };

  const _getStateDefault = {
    description: () => '',
    icon: () => z.conversation.ConversationStatusIcon.NONE,
  };

  const _getStateGroupActivity = {
    description: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();

      if (lastMessageEntity.is_member()) {
        const userCount = lastMessageEntity.userEntities().length;
        const hasUserCount = userCount >= 1;

        if (hasUserCount) {
          const userCountIsOne = userCount === 1;

          if (lastMessageEntity.isMemberJoin()) {
            if (userCountIsOne) {
              if (!lastMessageEntity.remoteUserEntities().length) {
                return z.l10n.text(z.string.conversationsSecondaryLinePersonAddedYou, lastMessageEntity.user().name());
              }

              const [remoteUserEntity] = lastMessageEntity.remoteUserEntities();
              const userSelfJoined = lastMessageEntity.user().id === remoteUserEntity.id;
              const stringId = userSelfJoined
                ? z.string.conversationsSecondaryLinePersonAddedSelf
                : z.string.conversationsSecondaryLinePersonAdded;

              return z.l10n.text(stringId, remoteUserEntity.name());
            }

            return z.l10n.text(z.string.conversationsSecondaryLinePeopleAdded, userCount);
          }

          if (lastMessageEntity.isMemberRemoval()) {
            if (userCountIsOne) {
              const [remoteUserEntity] = lastMessageEntity.remoteUserEntities();

              if (remoteUserEntity) {
                if (lastMessageEntity.isTeamMemberLeave()) {
                  const name = lastMessageEntity.name() || remoteUserEntity.name();
                  return z.l10n.text(z.string.conversationsSecondaryLinePersonRemovedTeam, name);
                }

                const userSelfLeft = remoteUserEntity.id === lastMessageEntity.user().id;
                const stringId = userSelfLeft
                  ? z.string.conversationsSecondaryLinePersonLeft
                  : z.string.conversationsSecondaryLinePersonRemoved;

                return z.l10n.text(stringId, remoteUserEntity.name());
              }
            }

            return z.l10n.text(z.string.conversationsSecondaryLinePeopleLeft, userCount);
          }
        }
      }

      const isConversationRename = lastMessageEntity.is_system() && lastMessageEntity.is_conversation_rename();
      if (isConversationRename) {
        return z.l10n.text(z.string.conversationsSecondaryLineRenamed, lastMessageEntity.user().name());
      }
    },
    icon: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isMemberRemoval = lastMessageEntity.is_member() && lastMessageEntity.isMemberRemoval();

      if (isMemberRemoval) {
        return conversationEntity.showNotificationsEverything()
          ? z.conversation.ConversationStatusIcon.UNREAD_MESSAGES
          : z.conversation.ConversationStatusIcon.MUTED;
      }
    },
    match: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isExpectedType = lastMessageEntity ? lastMessageEntity.is_member() || lastMessageEntity.is_system() : false;
      const unreadEvents = conversationEntity.unreadState().allEvents;

      return conversationEntity.isGroup() && unreadEvents.length > 0 && isExpectedType;
    },
  };

  const _getStateMuted = {
    description: conversationEntity => {
      return _accumulateSummary(conversationEntity, conversationEntity.showNotificationsMentionsAndReplies());
    },
    icon: conversationEntity => {
      const hasSelfMentions = conversationEntity.unreadState().selfMentions.length > 0;
      const hasSelfReplies = conversationEntity.unreadState().selfReplies.length > 0;
      const showMentionsIcon = hasSelfMentions && conversationEntity.showNotificationsMentionsAndReplies();
      const showRepliesIcon = hasSelfReplies && conversationEntity.showNotificationsMentionsAndReplies();

      if (showMentionsIcon) {
        return z.conversation.ConversationStatusIcon.UNREAD_MENTION;
      }

      if (showRepliesIcon) {
        return z.conversation.ConversationStatusIcon.UNREAD_REPLY;
      }

      return z.conversation.ConversationStatusIcon.MUTED;
    },
    match: conversationEntity => !conversationEntity.showNotificationsEverything(),
  };

  const _getStateRemoved = {
    description: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const selfUserId = conversationEntity.selfUser().id;

      const isMemberRemoval = lastMessageEntity && lastMessageEntity.is_member() && lastMessageEntity.isMemberRemoval();
      const wasSelfRemoved = isMemberRemoval && lastMessageEntity.userIds().includes(selfUserId);
      if (wasSelfRemoved) {
        const selfLeft = lastMessageEntity.user().id === selfUserId;
        const stringId = selfLeft
          ? z.string.conversationsSecondaryLineYouLeft
          : z.string.conversationsSecondaryLineYouWereRemoved;

        return z.l10n.text(stringId);
      }

      return '';
    },
    icon: () => z.conversation.ConversationStatusIcon.NONE,
    match: conversationEntity => conversationEntity.removed_from_conversation(),
  };

  const _getStateUnreadMessage = {
    description: conversationEntity => {
      const unreadMessages = conversationEntity.unreadState().allMessages;

      for (const messageEntity of unreadMessages) {
        let stringId;

        if (messageEntity.is_ping()) {
          stringId = z.string.notificationPing;
        } else if (messageEntity.has_asset_text()) {
          stringId = true;
        } else if (messageEntity.has_asset()) {
          const assetEntity = messageEntity.get_first_asset();
          const isUploaded = assetEntity.status() === z.assets.AssetTransferState.UPLOADED;

          if (isUploaded) {
            if (assetEntity.is_audio()) {
              stringId = z.string.notificationSharedAudio;
            } else if (assetEntity.is_video()) {
              stringId = z.string.notificationSharedVideo;
            } else {
              stringId = z.string.notificationSharedFile;
            }
          }
        } else if (messageEntity.has_asset_location()) {
          stringId = z.string.notificationSharedLocation;
        } else if (messageEntity.has_asset_image()) {
          stringId = z.string.notificationAssetAdd;
        }

        if (!!stringId) {
          if (messageEntity.is_ephemeral()) {
            stringId = conversationEntity.isGroup()
              ? z.string.conversationsSecondaryLineEphemeralMessageGroup
              : z.string.conversationsSecondaryLineEphemeralMessage;
            return z.l10n.text(stringId);
          }

          const hasStringId = stringId && stringId !== true;
          const stateText = hasStringId ? z.l10n.text(stringId) : messageEntity.get_first_asset().text;
          return conversationEntity.isGroup() ? `${messageEntity.unsafeSenderName()}: ${stateText}` : stateText;
        }
      }
    },
    icon: () => z.conversation.ConversationStatusIcon.UNREAD_MESSAGES,
    match: conversationEntity => conversationEntity.unreadState().allMessages.length > 0,
  };

  const _getStateUserName = {
    description: conversationEntity => {
      const [userEntity] = conversationEntity.participating_user_ets();
      const hasUsername = userEntity && userEntity.username();
      return hasUsername ? `@${userEntity.username()}` : '';
    },
    icon: conversationEntity => {
      if (conversationEntity.isRequest()) {
        return z.conversation.ConversationStatusIcon.PENDING_CONNECTION;
      }
    },
    match: conversationEntity => {
      const lastMessageEntity = conversationEntity.getLastMessage();
      const isMemberJoin = lastMessageEntity && lastMessageEntity.is_member() && lastMessageEntity.isMemberJoin();
      const isEmpty1to1Conversation = conversationEntity.is1to1() && isMemberJoin;

      return conversationEntity.isRequest() || isEmpty1to1Conversation;
    },
  };

  return {
    generate: conversationEntity => {
      const states = [
        _getStateCall,
        _getStateRemoved,
        _getStateMuted,
        _getStateAlert,
        _getStateGroupActivity,
        _getStateUnreadMessage,
        _getStateUserName,
      ];
      const matchingState = states.find(state => state.match(conversationEntity)) || _getStateDefault;

      return {
        description: matchingState.description(conversationEntity),
        icon: matchingState.icon(conversationEntity),
      };
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationEphemeralHandler = class ConversationEphemeralHandler extends z.conversation
  .AbstractConversationEventHandler {
  static get CONFIG() {
    return {
      INTERVAL_TIME: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 0.25,
      TIMER_RANGE: {
        MAX: z.util.TimeUtil.UNITS_IN_MILLIS.YEAR,
        MIN: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
      },
    };
  }

  static validateTimer(messageTimer) {
    const TIMER_RANGE = ConversationEphemeralHandler.CONFIG.TIMER_RANGE;
    const isTimerReset = messageTimer === null;

    return isTimerReset ? messageTimer : z.util.NumberUtil.clamp(messageTimer, TIMER_RANGE.MIN, TIMER_RANGE.MAX);
  }

  constructor(conversationMapper, eventService, eventListeners) {
    super();

    const defaultEventListeners = {onMessageTimeout: z.util.noop};
    this.eventListeners = Object.assign({}, defaultEventListeners, eventListeners);
    this.eventService = eventService;

    this.setEventHandlingConfig({
      [z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE]: this._updateEphemeralTimer.bind(this),
    });

    this.checkMessageTimer = this.checkMessageTimer.bind(this);

    this.conversationMapper = conversationMapper;
    this.logger = new z.util.Logger('z.conversation.ConversationEphemeralHandler', z.config.LOGGER.OPTIONS);

    this.timedMessages = ko.observableArray([]);

    let updateIntervalId = null;
    this.timedMessages.subscribe(messageEntities => {
      const shouldClearInterval = !messageEntities.length && updateIntervalId;
      if (shouldClearInterval) {
        window.clearInterval(updateIntervalId);
        updateIntervalId = null;
        return this.logger.info('Cleared ephemeral message check interval');
      }

      const shouldSetInterval = messageEntities.length && !updateIntervalId;
      if (shouldSetInterval) {
        const INTERVAL_TIME = ConversationEphemeralHandler.CONFIG.INTERVAL_TIME;
        updateIntervalId = window.setInterval(() => this._updateTimedMessages(), INTERVAL_TIME);
        this.logger.info('Started ephemeral message check interval');
      }
    });
  }

  /**
   * Check the remaining lifetime for a given ephemeral message.
   *
   * @param {Message} messageEntity - Message to check
   * @param {number} timeOffset - Approximate time different to backend in milliseconds
   * @returns {undefined} No return value
   */
  checkMessageTimer(messageEntity, timeOffset) {
    const hasHitBackend = messageEntity.status() > z.message.StatusType.SENDING;
    if (!hasHitBackend) {
      return;
    }

    switch (messageEntity.ephemeral_status()) {
      case z.message.EphemeralStatusType.TIMED_OUT: {
        this._timeoutEphemeralMessage(messageEntity);
        break;
      }

      case z.message.EphemeralStatusType.ACTIVE: {
        messageEntity.startMessageTimer(timeOffset);
        break;
      }

      case z.message.EphemeralStatusType.INACTIVE: {
        messageEntity.startMessageTimer(timeOffset);

        const changes = {
          ephemeral_expires: messageEntity.ephemeral_expires(),
          ephemeral_started: messageEntity.ephemeral_started(),
        };

        this.eventService.updateEvent(messageEntity.primary_key, changes);
        break;
      }

      default:
        this.logger.info(this.logger.levels.OFF, `Non-ephemeral message of type: ${messageEntity.type}`);
    }
  }

  validateMessage(messageEntity) {
    const isEphemeralMessage = messageEntity.ephemeral_status() !== z.message.EphemeralStatusType.NONE;
    if (!isEphemeralMessage) {
      return messageEntity;
    }

    const isExpired = !!this._updateTimedMessage(messageEntity);
    if (!isExpired) {
      const {id, conversation_id: conversationId} = messageEntity;
      const matchingMessageEntity = this.timedMessages().find(timedMessageEntity => {
        const {conversation_id: timedConversationId, id: timedMessageId} = timedMessageEntity;
        return timedMessageId === id && timedConversationId === conversationId;
      });

      if (matchingMessageEntity) {
        this.timedMessages.replace(matchingMessageEntity, messageEntity);
      } else {
        this.timedMessages.push(messageEntity);
      }

      return messageEntity;
    }
  }

  validateMessages(messageEntities) {
    return messageEntities
      .map(messageEntity => this.validateMessage(messageEntity))
      .filter(messageEntity => messageEntity);
  }

  _obfuscateAssetMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const changes = {
      data: {
        content_type: assetEntity.file_type,
        meta: {},
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated asset message '${messageEntity.id}'`);
  }

  _obfuscateImageMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const changes = {
      data: {
        info: {
          height: assetEntity.height,
          tag: 'medium',
          width: assetEntity.width,
        },
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated image message '${messageEntity.id}'`);
  }

  _obfuscateMessage(messageEntity) {
    if (messageEntity.has_asset_text()) {
      this._obfuscateTextMessage(messageEntity);
    } else if (messageEntity.has_asset()) {
      this._obfuscateAssetMessage(messageEntity);
    } else if (messageEntity.has_asset_image()) {
      this._obfuscateImageMessage(messageEntity);
    } else {
      this.logger.warn(`Ephemeral message of unsupported type: ${messageEntity.type}`, messageEntity);
    }
  }

  _obfuscateTextMessage(messageEntity) {
    messageEntity.ephemeral_expires(true);

    const assetEntity = messageEntity.get_first_asset();
    const obfuscatedAsset = new z.entity.Text(messageEntity.id);
    const obfuscatedPreviews = assetEntity.previews().map(linkPreview => {
      linkPreview.obfuscate();
      const protoArticle = new z.proto.Article(linkPreview.url, linkPreview.title); // deprecated format
      return new z.proto.LinkPreview(linkPreview.url, 0, protoArticle, linkPreview.url, linkPreview.title).encode64();
    });

    obfuscatedAsset.text = z.util.StringUtil.obfuscate(assetEntity.text);
    obfuscatedAsset.previews(assetEntity.previews());

    messageEntity.assets([obfuscatedAsset]);
    const changes = {
      data: {
        content: obfuscatedAsset.text,
        previews: obfuscatedPreviews,
      },
      ephemeral_expires: true,
    };

    this.eventService.updateEvent(messageEntity.primary_key, changes);
    this.logger.info(`Obfuscated text message '${messageEntity.id}'`);
  }

  _timeoutEphemeralMessage(messageEntity) {
    if (!messageEntity.is_expired()) {
      if (messageEntity.user().is_me) {
        this._obfuscateMessage(messageEntity);
      }

      this.eventListeners.onMessageTimeout(messageEntity);
    }
  }

  /**
   * Updates the ephemeral timer of a conversation when an timer-update message is received.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity which message timer was changed
   * @param {Object} eventJson - JSON data of 'conversation.message-timer-update' event
   * @returns {Promise} Resolves when the event was handled
   */
  _updateEphemeralTimer(conversationEntity, eventJson) {
    const updates = {globalMessageTimer: ConversationEphemeralHandler.validateTimer(eventJson.data.message_timer)};
    this.conversationMapper.updateProperties(conversationEntity, updates);
    return Promise.resolve(conversationEntity);
  }

  _updateTimedMessage(messageEntity) {
    if (_.isString(messageEntity.ephemeral_expires())) {
      const remainingTime = Math.max(0, messageEntity.ephemeral_expires() - Date.now());
      messageEntity.ephemeral_remaining(remainingTime);

      const isExpired = remainingTime === 0;
      if (isExpired) {
        this._timeoutEphemeralMessage(messageEntity);
        return messageEntity;
      }
    }
  }

  _updateTimedMessages() {
    const expiredMessages = this.timedMessages()
      .map(messageEntity => this._updateTimedMessage(messageEntity))
      .filter(messageEntity => messageEntity);

    if (expiredMessages.length) {
      this.timedMessages.remove(messageEntity => {
        for (const expiredMessage of expiredMessages) {
          const {conversation_id: conversationId, id: messageId} = expiredMessage;
          const isExpiredMessage = messageEntity.id === messageId && messageEntity.conversation_id === conversationId;
          if (isExpiredMessage) {
            return true;
          }
        }

        return false;
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

// @ts-check

'use strict';

/**
 * @typedef {object} ConversationBackendData
 * @property {string[]=} access
 * @property {string=} access_role
 * @property {string=} creator
 * @property {string=} id
 * @property {string=} last_event
 * @property {string=} last_event_time
 * @property {ConversationMembers=} members
 * @property {number=} message_timer
 * @property {string=} name
 * @property {string=} team
 * @property {number} type
 */

/**
 * @typedef {object} ConversationMembers
 * @property {OtherMember[]} others
 * @property {Member} self
 */

/**
 * @typedef {object} Member
 * @property {string=} hidden_ref
 * @property {boolean=} hidden
 * @property {string=} id
 * @property {string=} otr_archived_ref
 * @property {boolean=} otr_archived
 * @property {string=} otr_muted_ref
 * @property {boolean=} otr_muted
 * @property {ServiceRef=} service
 */

/**
 * @typedef {object} OtherMember
 * @property {string} id
 * @property {number} status
 */

/**
 * @typedef {object} SelfStatusUpdate
 * @property {number=} archived_timestamp
 * @property {number=} cleared_timestamp
 * @property {number=} ephemeral_timer
 * @property {number=} message_timer
 * @property {number=} last_event_timestamp
 * @property {number=} last_read_timestamp
 * @property {number=} last_server_timestamp
 * @property {boolean=} otr_archived
 * @property {string=} otr_archived_ref
 * @property {boolean=} otr_muted
 * @property {string=} otr_muted_ref
 * @property {boolean=} muted_state
 * @property {number=} status
 * @property {number=} verification_state
 */

/**
 * @typedef {object} ServiceRef
 * @property {string} id
 * @property {string} provider
 */

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation Mapper to convert all server side JSON conversation objects into core entities.
z.conversation.ConversationMapper = class ConversationMapper {
  // Construct a new Conversation Mapper.
  constructor() {
    this.logger = new z.util.Logger('z.conversation.ConversationMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Converts JSON conversations into conversation entities.
   *
   * @param {Array} conversationsData - Conversation data
   * @param {number} [timestamp=1] - Initial timestamp for conversation
   * @returns {Array<Conversation>} Mapped conversation entities
   */
  mapConversations(conversationsData, timestamp = 1) {
    if (conversationsData === undefined) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }
    if (!_.isArray(conversationsData) || !conversationsData.length) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    }
    return conversationsData.map((conversationData, index) => {
      return this._createConversationEntity(conversationData, timestamp + index);
    });
  }

  /**
   * Updates all properties of a conversation specified.
   *
   * @example data: {"name":"ThisIsMyNewConversationName"}
   * @todo make utility?
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {ConversationBackendData} conversationData - Conversation data from backend
   * @returns {Conversation} Updated conversation entity
   */
  updateProperties(conversationEntity, conversationData) {
    Object.entries(conversationData).forEach(([key, value]) => {
      if (key !== 'id') {
        if (value !== undefined && conversationEntity.hasOwnProperty(key)) {
          if (ko.isObservable(conversationEntity[key])) {
            conversationEntity[key](value);
          } else {
            conversationEntity[key] = value;
          }
        }
      }
    });

    return conversationEntity;
  }

  /**
   * Update the membership properties of a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {SelfStatusUpdate} selfState - Conversation self data from the database
   * @param {boolean} [disablePersistence=false] - Disable persistence of state changes during update
   * @returns {Conversation} Updated conversation entity
   */
  updateSelfStatus(conversationEntity, selfState, disablePersistence = false) {
    if (conversationEntity) {
      if (disablePersistence) {
        conversationEntity.setStateChangePersistence(false);
      }

      // Database states
      const {
        archived_timestamp,
        cleared_timestamp,
        ephemeral_timer,
        message_timer,
        last_event_timestamp,
        last_read_timestamp,
        last_server_timestamp,
        muted_timestamp,
        status,
        verification_state,
      } = selfState;

      if (archived_timestamp) {
        conversationEntity.setTimestamp(archived_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.ARCHIVED);
        conversationEntity.archivedState(selfState.archived_state);
      }

      if (cleared_timestamp !== undefined) {
        conversationEntity.setTimestamp(cleared_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.CLEARED, true);
      }

      if (ephemeral_timer !== undefined) {
        conversationEntity.localMessageTimer(ephemeral_timer);
      }

      if (message_timer !== undefined) {
        conversationEntity.globalMessageTimer(message_timer);
      }

      if (last_event_timestamp) {
        conversationEntity.setTimestamp(last_event_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_EVENT);
      }

      if (last_read_timestamp) {
        conversationEntity.setTimestamp(last_read_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ);
      }

      if (last_server_timestamp) {
        conversationEntity.setTimestamp(last_server_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_SERVER);
      }

      if (muted_timestamp) {
        conversationEntity.setTimestamp(muted_timestamp, z.entity.Conversation.TIMESTAMP_TYPE.MUTED);
        conversationEntity.mutedState(selfState.muted_state);
      }

      if (status !== undefined) {
        conversationEntity.status(status);
      }

      if (verification_state !== undefined) {
        conversationEntity.verification_state(verification_state);
      }

      // Backend states
      const {otr_archived, otr_muted} = selfState;

      if (otr_archived !== undefined) {
        const archivedTimestamp = new Date(selfState.otr_archived_ref).getTime();
        conversationEntity.setTimestamp(archivedTimestamp, z.entity.Conversation.TIMESTAMP_TYPE.ARCHIVED);
        conversationEntity.archivedState(otr_archived);
      }

      if (otr_muted !== undefined) {
        const mutedTimestamp = new Date(selfState.otr_muted_ref).getTime();
        conversationEntity.setTimestamp(mutedTimestamp, z.entity.Conversation.TIMESTAMP_TYPE.MUTED);

        const mutedState = this.getMutedState(otr_muted, selfState.otr_muted_status);
        conversationEntity.mutedState(mutedState);
      }

      if (disablePersistence) {
        conversationEntity.setStateChangePersistence(true);
      }

      return conversationEntity;
    }
  }

  /**
   * Creates a conversation entity from backend JSON data.
   *
   * @private
   * @param {Object} conversationData - Either locally stored or backend data
   * @param {number} [initialTimestamp] - Initial timestamp for conversation in milliseconds
   * @returns {Conversation} Mapped conversation entity
   */
  _createConversationEntity(conversationData, initialTimestamp) {
    if (conversationData === undefined) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER);
    }
    if (!_.isObject(conversationData) || !Object.keys(conversationData).length) {
      throw new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    }

    const {creator, id, members, name, others, type} = conversationData;
    let conversationEntity = new z.entity.Conversation(id);

    conversationEntity.creator = creator;
    conversationEntity.type(type);
    conversationEntity.name(name ? name : '');

    const selfState = members ? members.self : conversationData;
    conversationEntity = this.updateSelfStatus(conversationEntity, selfState);

    if (!conversationEntity.last_event_timestamp() && initialTimestamp) {
      conversationEntity.last_event_timestamp(initialTimestamp);
      conversationEntity.last_server_timestamp(initialTimestamp);
    }

    // Active participants from database or backend payload
    const participatingUserIds = others ? others : members.others.map(other => other.id);
    conversationEntity.participating_user_ids(participatingUserIds);

    // Team ID from database or backend payload
    const teamId = conversationData.team_id || conversationData.team;
    if (teamId) {
      conversationEntity.team_id = teamId;
    }

    if (conversationData.is_guest) {
      conversationEntity.isGuest(conversationData.is_guest);
    }

    // Access related data
    const accessModes = conversationData.accessModes || conversationData.access;
    const accessRole = conversationData.accessRole || conversationData.access_role;
    if (accessModes && accessRole) {
      this.mapAccessState(conversationEntity, accessModes, accessRole);
    }

    return conversationEntity;
  }

  /**
   * Get the valid muted state.
   *
   * @param {boolean} mutedState - Outdated muted state
   * @param {z.conversation.NotificationSetting.STATE} [notificationState] - Bit mask based notification setting
   * @returns {z.conversation.NotificationSetting.STATE} validated notification setting
   */
  getMutedState(mutedState, notificationState) {
    const validNotifcationStates = Object.values(z.conversation.NotificationSetting.STATE);
    if (validNotifcationStates.includes(notificationState)) {
      // Ensure bit at offset 0 to be 1 for backwards compatibility of deprecated boolean based state is true
      return mutedState ? notificationState | 0b1 : z.conversation.NotificationSetting.STATE.EVERYTHING;
    }

    return typeof mutedState === 'boolean' ? mutedState : z.conversation.NotificationSetting.STATE.EVERYTHING;
  }

  /**
   * Merge local database records with remote backend payload.
   *
   * @param {Array<Object>} localConversations - Database records
   * @param {Array<Object>} remoteConversations - Backend payload
   * @returns {Array<Object>} Merged conversation data
   */
  mergeConversation(localConversations, remoteConversations) {
    localConversations = localConversations.filter(conversationData => conversationData);

    return remoteConversations.map((remoteConversationData, index) => {
      const conversationId = remoteConversationData.id;
      const localConversationData = localConversations.find(({id}) => id === conversationId) || {id: conversationId};

      const {access, access_role, creator, members, message_timer, name, team, type} = remoteConversationData;
      const {others: othersStates, self: selfState} = members;

      const updates = {
        accessModes: access,
        accessRole: access_role,
        creator,
        message_timer,
        name,
        status: selfState.status,
        team_id: team,
        type,
      };
      const mergedConversation = Object.assign({}, localConversationData, updates);

      const isGroup = type === z.conversation.ConversationType.GROUP;
      const noOthers = !mergedConversation.others || !mergedConversation.others.length;
      if (isGroup || noOthers) {
        mergedConversation.others = othersStates
          .filter(otherState => otherState.status === z.conversation.ConversationStatus.CURRENT_MEMBER)
          .map(otherState => otherState.id);
      }

      // This should ensure a proper order
      if (!mergedConversation.last_event_timestamp) {
        mergedConversation.last_event_timestamp = index + 1;
      }

      // Set initially or correct server timestamp
      const wrongServerTimestamp = mergedConversation.last_server_timestamp < mergedConversation.last_event_timestamp;
      if (!mergedConversation.last_server_timestamp || wrongServerTimestamp) {
        mergedConversation.last_server_timestamp = mergedConversation.last_event_timestamp;
      }

      const isRemoteTimestampNewer = (localTimestamp, remoteTimestamp) => {
        return localTimestamp !== undefined && remoteTimestamp > localTimestamp;
      };

      // Some archived timestamp were not properly stored in the database.
      // To fix this we check if the remote one is newer and update our local timestamp.
      const {archived_state: archivedState, archived_timestamp: archivedTimestamp} = localConversationData;
      const remoteArchivedTimestamp = new Date(selfState.otr_archived_ref).getTime();
      const isRemoteArchivedTimestampNewer = isRemoteTimestampNewer(archivedTimestamp, remoteArchivedTimestamp);

      if (isRemoteArchivedTimestampNewer || archivedState === undefined) {
        mergedConversation.archived_state = selfState.otr_archived;
        mergedConversation.archived_timestamp = remoteArchivedTimestamp;
      }

      const {muted_state: mutedState, muted_timestamp: mutedTimestamp} = localConversationData;
      const remoteMutedTimestamp = new Date(selfState.otr_muted_ref).getTime();
      const isRemoteMutedTimestampNewer = isRemoteTimestampNewer(mutedTimestamp, remoteMutedTimestamp);

      if (isRemoteMutedTimestampNewer || mutedState === undefined) {
        const remoteMutedState = this.getMutedState(selfState.otr_muted, selfState.otr_muted_statu);
        mergedConversation.muted_state = remoteMutedState;
        mergedConversation.muted_timestamp = remoteMutedTimestamp;
      }

      return mergedConversation;
    });
  }

  mapAccessCode(conversationEntity, accessCode) {
    const isTeamConversation = conversationEntity && conversationEntity.team_id;

    if (accessCode.uri && isTeamConversation) {
      conversationEntity.accessCode(accessCode.uri);
    }
  }

  mapAccessState(conversationEntity, accessModes, accessRole) {
    if (conversationEntity.team_id) {
      if (conversationEntity.is1to1()) {
        return conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.ONE2ONE);
      }

      const isTeamRole = accessRole === z.conversation.ACCESS_ROLE.TEAM;

      const includesInviteMode = accessModes.includes(z.conversation.ACCESS_MODE.INVITE);
      const isInviteModeOnly = includesInviteMode && accessModes.length === 1;

      const isTeamOnlyMode = isTeamRole && isInviteModeOnly;
      if (isTeamOnlyMode) {
        return conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY);
      }

      const isNonVerifiedRole = accessRole === z.conversation.ACCESS_ROLE.NON_ACTIVATED;

      const includesCodeMode = accessModes.includes(z.conversation.ACCESS_MODE.CODE);
      const isExpectedModes = includesCodeMode && includesInviteMode && accessModes.length === 2;

      const isGuestRoomMode = isNonVerifiedRole && isExpectedModes;
      return isGuestRoomMode
        ? conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM)
        : conversationEntity.accessState(z.conversation.ACCESS_STATE.TEAM.LEGACY);
    }

    if (conversationEntity.isSelf()) {
      return conversationEntity.accessState(z.conversation.ACCESS_STATE.SELF);
    }

    const personalAccessState = conversationEntity.isGroup()
      ? z.conversation.ACCESS_STATE.PERSONAL.GROUP
      : z.conversation.ACCESS_STATE.PERSONAL.ONE2ONE;
    return conversationEntity.accessState(personalAccessState);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation repository for all conversation interactions with the conversation service
z.conversation.ConversationRepository = class ConversationRepository {
  static get CONFIG() {
    return {
      CONFIRMATION_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      EXTERNAL_MESSAGE_THRESHOLD: 200 * 1024,
      GROUP: {
        MAX_NAME_LENGTH: 64,
        MAX_SIZE: 300,
      },
    };
  }

  static get CONSENT_TYPE() {
    return {
      INCOMING_CALL: 'incoming_call',
      MESSAGE: 'message',
      OUTGOING_CALL: 'outgoing_call',
    };
  }

  /**
   * Construct a new Conversation Repository.
   *
   * @param {ConversationService} conversation_service - Backend REST API conversation service implementation
   * @param {AssetService} asset_service - Backend REST API asset service implementation
   * @param {ClientRepository} client_repository - Repository for client interactions
   * @param {ConnectionRepository} connectionRepository - Repository for all connnection interactions
   * @param {CryptographyRepository} cryptography_repository - Repository for all cryptography interactions
   * @param {EventRepository} eventRepository - Repository that handles events
   * @param {GiphyRepository} giphy_repository - Repository for Giphy GIFs
   * @param {LinkPreviewRepository} link_repository - Repository for link previews
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {TeamRepository} team_repository - Repository for teams
   * @param {UserRepository} user_repository - Repository for all user interactions
   */
  constructor(
    conversation_service,
    asset_service,
    client_repository,
    connectionRepository,
    cryptography_repository,
    eventRepository,
    giphy_repository,
    link_repository,
    serverTimeRepository,
    team_repository,
    user_repository
  ) {
    this.eventRepository = eventRepository;
    this.eventService = eventRepository.eventService;
    this.conversation_service = conversation_service;
    this.asset_service = asset_service;
    this.client_repository = client_repository;
    this.connectionRepository = connectionRepository;
    this.cryptography_repository = cryptography_repository;
    this.giphy_repository = giphy_repository;
    this.link_repository = link_repository;
    this.serverTimeRepository = serverTimeRepository;
    this.team_repository = team_repository;
    this.user_repository = user_repository;
    this.logger = new z.util.Logger('z.conversation.ConversationRepository', z.config.LOGGER.OPTIONS);

    this.conversationMapper = new z.conversation.ConversationMapper();
    this.event_mapper = new z.conversation.EventMapper();
    this.verification_state_handler = new z.conversation.ConversationVerificationStateHandler(
      this,
      this.eventRepository,
      this.serverTimeRepository
    );
    this.clientMismatchHandler = new z.conversation.ClientMismatchHandler(
      this,
      this.cryptography_repository,
      this.eventRepository,
      this.serverTimeRepository,
      this.user_repository
    );

    this.active_conversation = ko.observable();
    this.conversations = ko.observableArray([]);

    this.isTeam = this.team_repository.isTeam;
    this.isTeam.subscribe(() => this.map_guest_status_self());
    this.team = this.team_repository.team;
    this.teamMembers = this.team_repository.teamMembers;

    this.selfUser = this.user_repository.self;

    this.block_event_handling = ko.observable(true);
    this.fetching_conversations = {};
    this.conversationsWithNewEvents = new Map();
    this.block_event_handling.subscribe(eventHandlingState => {
      if (!eventHandlingState) {
        this._checkChangedConversations();
      }
    });

    this.self_conversation = ko.pureComputed(() => {
      if (this.selfUser()) {
        return this._find_conversation_by_id(this.selfUser().id);
      }
    });

    this.filtered_conversations = ko.pureComputed(() => {
      return this.conversations().filter(conversation_et => {
        const states_to_filter = [
          z.connection.ConnectionStatus.BLOCKED,
          z.connection.ConnectionStatus.CANCELLED,
          z.connection.ConnectionStatus.PENDING,
        ];

        if (conversation_et.isSelf() || states_to_filter.includes(conversation_et.connection().status())) {
          return false;
        }

        return !(conversation_et.is_cleared() && conversation_et.removed_from_conversation());
      });
    });

    this.sorted_conversations = ko.pureComputed(() => {
      return this.filtered_conversations().sort(z.util.sortGroupsByLastEvent);
    });

    this.receiving_queue = new z.util.PromiseQueue({name: 'ConversationRepository.Receiving'});
    this.sending_queue = new z.util.PromiseQueue({name: 'ConversationRepository.Sending', paused: true});

    // @note Only use the client request queue as to unblock if not blocked by event handling or the cryptographic order of messages will be ruined and sessions might be deleted
    this.conversation_service.backendClient.queueState.subscribe(queueState => {
      const queueReady = queueState === z.service.QUEUE_STATE.READY;
      this.sending_queue.pause(!queueReady || this.block_event_handling());
    });

    this.conversations_archived = ko.observableArray([]);
    this.conversations_calls = ko.observableArray([]);
    this.conversations_cleared = ko.observableArray([]);
    this.conversations_unarchived = ko.observableArray([]);

    this.init_handled = 0;
    this.init_promise = undefined;
    this.init_total = 0;

    this._init_subscriptions();

    this.stateHandler = new z.conversation.ConversationStateHandler(this.conversation_service, this.conversationMapper);
    this.ephemeralHandler = new z.conversation.ConversationEphemeralHandler(
      this.conversationMapper,
      this.eventService,
      {onMessageTimeout: this.handleMessageExpiration.bind(this)}
    );
  }

  checkMessageTimer(messageEntity) {
    this.ephemeralHandler.checkMessageTimer(messageEntity, this.serverTimeRepository.getTimeOffset());
  }

  _initStateUpdates() {
    ko.computed(() => {
      const conversationsArchived = [];
      const conversationsCalls = [];
      const conversationsCleared = [];
      const conversationsUnarchived = [];

      this.sorted_conversations().forEach(conversationEntity => {
        const conversationWithCall = this.selfUser().isTemporaryGuest()
          ? conversationEntity.hasActiveCall() || conversationEntity.hasJoinableCall()
          : conversationEntity.hasActiveCall();
        if (conversationWithCall) {
          if (conversationEntity.call().isOngoing()) {
            conversationsCalls.unshift(conversationEntity);
          } else {
            conversationsCalls.push(conversationEntity);
          }
        }
        if (conversationEntity.is_cleared()) {
          conversationsCleared.push(conversationEntity);
        } else if (conversationEntity.is_archived()) {
          conversationsArchived.push(conversationEntity);
        } else {
          conversationsUnarchived.push(conversationEntity);
        }
      });

      this.conversations_archived(conversationsArchived);
      this.conversations_calls(conversationsCalls);
      this.conversations_cleared(conversationsCleared);
      this.conversations_unarchived(conversationsUnarchived);
    });
  }

  _init_subscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.ASSET.CANCEL, this.cancel_asset_upload.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.EVENT_FROM_BACKEND, this.onConversationEvent.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MAP_CONNECTION, this.map_connection.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MISSED_EVENTS, this.on_missed_events.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.PERSIST_STATE, this.save_conversation_state_in_db.bind(this));
    amplify.subscribe(
      z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE,
      this.set_notification_handling_state.bind(this)
    );
    amplify.subscribe(z.event.WebApp.TEAM.MEMBER_LEAVE, this.teamMemberLeave.bind(this));
    amplify.subscribe(z.event.WebApp.USER.UNBLOCKED, this.unblocked_user.bind(this));
  }

  /**
   * Remove obsolete conversations locally.
   * @returns {undefined} No return value
   */
  cleanup_conversations() {
    this.conversations().forEach(conversation_et => {
      if (conversation_et.isGroup() && conversation_et.is_cleared() && conversation_et.removed_from_conversation()) {
        this.conversation_service.delete_conversation_from_db(conversation_et.id);
        this.delete_conversation(conversation_et.id);
      }
    });
  }

  //##############################################################################
  // Conversation service interactions
  //##############################################################################

  /**
   * Create a group conversation.
   * @note Do not include the requestor among the users
   *
   * @param {Array<z.entity.User>} userEntities - Users (excluding the requestor) to be part of the conversation
   * @param {string} [groupName] - Name for the conversation
   * @param {string} [accessState] - State for conversation access
   * @returns {Promise} Resolves when the conversation was created
   */
  createGroupConversation(userEntities, groupName, accessState) {
    const userIds = userEntities.map(userEntity => userEntity.id);
    const payload = {
      name: groupName,
      users: userIds,
    };

    if (this.team().id) {
      payload.team = {
        managed: false,
        teamid: this.team().id,
      };

      if (accessState) {
        let accessPayload;

        switch (accessState) {
          case z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM:
            accessPayload = {
              access: [z.conversation.ACCESS_MODE.INVITE, z.conversation.ACCESS_MODE.CODE],
              access_role: z.conversation.ACCESS_ROLE.NON_ACTIVATED,
            };
            break;
          case z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY:
            accessPayload = {
              access: [z.conversation.ACCESS_MODE.INVITE],
              access_role: z.conversation.ACCESS_ROLE.TEAM,
            };
            break;
          default:
            break;
        }

        if (accessPayload) {
          Object.assign(payload, accessPayload);
        }
      }
    }

    return this.conversation_service
      .postConversations(payload)
      .then(response => this._onCreate({conversation: response.id, data: response}))
      .then(({conversationEntity}) => conversationEntity)
      .catch(error => this._handleConversationCreateError(error, userIds));
  }

  /**
   * Create a guest room.
   * @returns {Promise} Resolves with the conversation that was created
   */
  createGuestRoom() {
    const groupName = z.l10n.text(z.string.guestRoomConversationName);
    return this.createGroupConversation([], groupName, z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
  }

  /**
   * Get a conversation from the backend.
   * @param {string} conversation_id - Conversation to be retrieved from the backend
   * @returns {Promise} Resolve with the conversation entity
   */
  fetch_conversation_by_id(conversation_id) {
    if (this.fetching_conversations.hasOwnProperty(conversation_id)) {
      return new Promise((resolve, reject) => {
        this.fetching_conversations[conversation_id].push({reject_fn: reject, resolve_fn: resolve});
      });
    }

    this.fetching_conversations[conversation_id] = [];

    return this.conversation_service
      .get_conversation_by_id(conversation_id)
      .then(response => {
        const conversation_et = this.mapConversations(response);

        this.logger.info(`Fetched conversation '${conversation_id}' from backend`);
        this.save_conversation(conversation_et);

        this.fetching_conversations[conversation_id].forEach(({resolve_fn}) => resolve_fn(conversation_et));
        delete this.fetching_conversations[conversation_id];

        return conversation_et;
      })
      .catch(() => {
        const error = new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);

        this.fetching_conversations[conversation_id].forEach(({reject_fn}) => reject_fn(error));
        delete this.fetching_conversations[conversation_id];

        throw error;
      });
  }

  getConversations() {
    const remoteConversationsPromise = this.conversation_service.getAllConversations().catch(error => {
      this.logger.error(`Failed to get all conversations from backend: ${error.message}`);
      return [];
    });

    return Promise.all([this.conversation_service.load_conversation_states_from_db(), remoteConversationsPromise])
      .then(([localConversations, remoteConversations]) => {
        if (!remoteConversations.length) {
          return localConversations;
        }

        const data = this.conversationMapper.mergeConversation(localConversations, remoteConversations);
        return this.conversation_service.save_conversations_in_db(data);
      })
      .then(conversationsData => this.mapConversations(conversationsData))
      .then(conversationEntities => {
        this.save_conversations(conversationEntities);
        return this.conversations();
      });
  }

  updateConversationStates(conversationsData) {
    const handledConversationEntities = [];

    return Promise.resolve()
      .then(() => {
        const unknownConversations = [];

        conversationsData.forEach(conversationData => {
          const localEntity = this.conversations().find(({id}) => id === conversationData.id);

          if (localEntity) {
            const entity = this.conversationMapper.updateSelfStatus(localEntity, conversationData, true);
            return handledConversationEntities.push(entity);
          }

          unknownConversations.push(conversationData);
        });

        return unknownConversations.length ? this.mapConversations(unknownConversations) : [];
      })
      .then(conversationEntities => {
        if (conversationEntities.length) {
          this.save_conversations(conversationEntities);
        }
        conversationEntities = conversationEntities.concat(handledConversationEntities);

        const handledConversationData = conversationEntities.map(conversationEntity => conversationEntity.serialize());
        this.conversation_service.save_conversations_in_db(handledConversationData);
        return conversationEntities;
      });
  }

  /**
   * Get Message with given ID from the database.
   *
   * @param {Conversation} conversationEntity - Conversation message belongs to
   * @param {string} messageId - ID of message
   * @param {boolean} skipConversationMessages - Don't use message entity from conversation
   * @param {boolean} ensureUser - Make sure message entity has a valid user
   * @returns {Promise} Resolves with the message
   */
  get_message_in_conversation_by_id(
    conversationEntity,
    messageId,
    skipConversationMessages = false,
    ensureUser = false
  ) {
    const messageEntity = !skipConversationMessages && conversationEntity.getMessage(messageId);
    const messagePromise = messageEntity
      ? Promise.resolve(messageEntity)
      : this.eventService.loadEvent(conversationEntity.id, messageId).then(event => {
          if (event) {
            return this.event_mapper.mapJsonEvent(event, conversationEntity);
          }
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
        });

    if (ensureUser) {
      return messagePromise.then(message => {
        if (message.from && !message.user().id) {
          return this.user_repository.get_user_by_id(message.from).then(userEntity => {
            message.user(userEntity);
            return message;
          });
        }
        return message;
      });
    }
    return messagePromise;
  }

  /**
   * Get preceding messages starting with the given message.
   * @param {Conversation} conversationEntity - Respective conversation
   * @returns {Promise} Resolves with the messages
   */
  getPrecedingMessages(conversationEntity) {
    conversationEntity.is_pending(true);

    const firstMessageEntity = conversationEntity.getFirstMessage();
    const upperBound = firstMessageEntity
      ? new Date(firstMessageEntity.timestamp())
      : new Date(conversationEntity.get_latest_timestamp(this.serverTimeRepository.toServerTimestamp()) + 1);

    return this.eventService
      .loadPrecedingEvents(conversationEntity.id, new Date(0), upperBound, z.config.MESSAGES_FETCH_LIMIT)
      .then(events => this._addPrecedingEventsToConversation(events, conversationEntity))
      .then(mappedMessageEntities => {
        conversationEntity.is_pending(false);
        return mappedMessageEntities;
      });
  }

  _addPrecedingEventsToConversation(events, conversationEntity) {
    const hasAdditionalMessages = events.length === z.config.MESSAGES_FETCH_LIMIT;

    return this._addEventsToConversation(events, conversationEntity).then(mappedMessageEntities => {
      conversationEntity.hasAdditionalMessages(hasAdditionalMessages);

      if (!hasAdditionalMessages) {
        const firstMessage = conversationEntity.getFirstMessage();
        const checkCreationMessage = firstMessage && firstMessage.is_member() && firstMessage.isCreation();
        if (checkCreationMessage) {
          const groupCreationMessageIn1to1 = conversationEntity.is1to1() && firstMessage.isGroupCreation();
          const one2oneConnectionMessageInGroup = conversationEntity.isGroup() && firstMessage.isConnection();
          const wrongMessageTypeForConversation = groupCreationMessageIn1to1 || one2oneConnectionMessageInGroup;

          if (wrongMessageTypeForConversation) {
            this.deleteMessage(conversationEntity, firstMessage);
            conversationEntity.hasCreationMessage = false;
          } else {
            conversationEntity.hasCreationMessage = true;
          }
        }

        const addCreationMessage = !conversationEntity.hasCreationMessage;
        if (addCreationMessage) {
          this._addCreationMessage(conversationEntity, this.selfUser().isTemporaryGuest());
        }
      }

      return mappedMessageEntities;
    });
  }

  _addCreationMessage(conversationEntity, isTemporaryGuest, timestamp, eventSource) {
    conversationEntity.hasCreationMessage = true;

    if (conversationEntity.inTeam()) {
      const allTeamMembersParticipate = this.teamMembers().length
        ? this.teamMembers().every(teamMember => conversationEntity.participating_user_ids().includes(teamMember.id))
        : false;

      conversationEntity.withAllTeamMembers(allTeamMembersParticipate);
    }

    const creationEvent = conversationEntity.isGroup()
      ? z.conversation.EventBuilder.buildGroupCreation(conversationEntity, isTemporaryGuest, timestamp)
      : z.conversation.EventBuilder.build1to1Creation(conversationEntity);

    this.eventRepository.injectEvent(creationEvent, eventSource);
  }

  /**
   * Get specified message and load number preceding and subsequent messages defined by padding.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Message} messageEntity - Message entity
   * @param {number} [padding=30] - Number of messages to load around the targeted message
   * @returns {Promise} Resolves with the message
   */
  getMessagesWithOffset(conversationEntity, messageEntity, padding = 30) {
    const messageDate = new Date(messageEntity.timestamp());
    const conversationId = conversationEntity.id;

    conversationEntity.is_pending(true);

    return this.eventService
      .loadPrecedingEvents(conversationId, new Date(0), messageDate, Math.floor(padding / 2))
      .then(precedingMessages => {
        return this.eventService
          .loadFollowingEvents(conversationEntity.id, messageDate, padding - precedingMessages.length)
          .then(followingMessages => precedingMessages.concat(followingMessages));
      })
      .then(messages => this._addEventsToConversation(messages, conversationEntity))
      .then(mappedMessageEntities => {
        conversationEntity.is_pending(false);
        return mappedMessageEntities;
      });
  }

  /**
   * Get subsequent messages starting with the given message.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Message} messageEntity - Message entity
   * @param {boolean} includeMessage - Include given message in the results
   * @returns {Promise} Resolves with the messages
   */
  getSubsequentMessages(conversationEntity, messageEntity, includeMessage) {
    const messageDate = new Date(messageEntity.timestamp());
    conversationEntity.is_pending(true);

    return this.eventService
      .loadFollowingEvents(conversationEntity.id, messageDate, z.config.MESSAGES_FETCH_LIMIT, includeMessage)
      .then(events => this._addEventsToConversation(events, conversationEntity))
      .then(mappedNessageEntities => {
        conversationEntity.is_pending(false);
        return mappedNessageEntities;
      });
  }

  /**
   * Get messages for given category. Category param acts as lower bound.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {MessageCategory} [category=z.message.MessageCategory.NONE] - Message category
   * @returns {Promise} Array of message entities
   */
  get_events_for_category(conversationEntity, category = z.message.MessageCategory.NONE) {
    return this.eventService
      .loadEventsWithCategory(conversationEntity.id, category)
      .then(events => this.event_mapper.mapJsonEvents(events, conversationEntity))
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities));
  }

  /**
   * Search for given text in conversation.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {string} query - Query strings
   * @returns {Promise} Array of message entities
   */
  searchInConversation(conversationEntity, query) {
    if (!conversationEntity || !query.length) {
      return Promise.resolve({});
    }

    return this.conversation_service
      .search_in_conversation(conversationEntity.id, query)
      .then(events => this.event_mapper.mapJsonEvents(events, conversationEntity))
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities))
      .then(messageEntities => ({messageEntities, query}));
  }

  /**
   * Get conversation unread events.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation to start from
   * @returns {undefined} No return value
   */
  _get_unread_events(conversation_et) {
    const first_message = conversation_et.getFirstMessage();
    const lower_bound = new Date(conversation_et.last_read_timestamp());
    const upper_bound = first_message
      ? new Date(first_message.timestamp())
      : new Date(conversation_et.get_latest_timestamp(this.serverTimeRepository.toServerTimestamp()) + 1);

    if (lower_bound < upper_bound) {
      conversation_et.is_pending(true);

      return this.eventService
        .loadPrecedingEvents(conversation_et.id, lower_bound, upper_bound)
        .then(events => {
          if (events.length) {
            this._addEventsToConversation(events, conversation_et);
          }
          conversation_et.is_pending(false);
        })
        .catch(error => {
          this.logger.info(`Could not load unread events for conversation: ${conversation_et.id}`, error);
        });
    }
  }

  /**
   * Update conversation with a user you just unblocked
   * @param {User} user_et - User you unblocked
   * @returns {undefined} No return value
   */
  unblocked_user(user_et) {
    this.get1To1Conversation(user_et).then(conversation_et =>
      conversation_et.status(z.conversation.ConversationStatus.CURRENT_MEMBER)
    );
  }

  /**
   * Update all conversations on app init.
   * @returns {undefined} No return value
   */
  updateConversationsOnAppInit() {
    this.logger.info('Updating group participants');
    this.updateUnarchivedConversations();
    this.sorted_conversations().map(conversationEntity => {
      this.updateParticipatingUserEntities(conversationEntity, true);
    });
  }

  /**
   * Update users and events for archived conversations currently visible.
   * @returns {undefined} No return value
   */
  updateArchivedConversations() {
    this.updateConversations(this.conversations_archived());
  }

  /**
   * Update users and events for all unarchived conversations.
   * @returns {undefined} No return value
   */
  updateUnarchivedConversations() {
    this.updateConversations(this.conversations_unarchived());
  }

  updateConversationFromBackend(conversationEntity) {
    return this.conversation_service.get_conversation_by_id(conversationEntity.id).then(conversationData => {
      const {name, message_timer} = conversationData;
      this.conversationMapper.updateProperties(conversationEntity, {name});
      this.conversationMapper.updateSelfStatus(conversationEntity, {message_timer});
    });
  }

  /**
   * Get users and events for conversations.
   *
   * @note To reduce the number of backend calls we merge the user IDs of all conversations first.
   * @param {Array<Conversation>} conversationEntities - Array of conversation entities to be updated
   * @returns {undefined} No return value
   */
  updateConversations(conversationEntities) {
    const mapOfUserIds = conversationEntities.map(conversationEntity => conversationEntity.participating_user_ids());
    const userIds = _.flatten(mapOfUserIds);

    this.user_repository
      .get_users_by_id(userIds)
      .then(() => conversationEntities.forEach(conversationEntity => this._fetch_users_and_events(conversationEntity)));
  }

  //##############################################################################
  // Repository interactions
  //##############################################################################

  /**
   * Deletes a conversation from the repository.
   * @param {string} conversation_id - ID of conversation to be deleted from the repository
   * @returns {undefined} No return value
   */
  delete_conversation(conversation_id) {
    this.conversations.remove(conversation_et => conversation_et.id === conversation_id);
  }

  /**
   * Find a local conversation by ID.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the conversation entity
   */
  find_conversation_by_id(conversation_id) {
    return Promise.resolve().then(() => {
      if (!conversation_id) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CONVERSATION_ID);
      }

      const conversation_et = this._find_conversation_by_id(conversation_id);
      if (conversation_et) {
        return conversation_et;
      }

      throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
    });
  }

  /**
   * Check for conversation locally.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Conversation} Conversation is locally available
   */
  _find_conversation_by_id(conversation_id) {
    return this.conversations().find(conversation => conversation.id === conversation_id);
  }

  get_all_users_in_conversation(conversation_id) {
    return this.get_conversation_by_id(conversation_id).then(conversation_et =>
      [this.selfUser()].concat(conversation_et.participating_user_ets())
    );
  }

  /**
   * Check for conversation locally and fetch it from the server otherwise.
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the Conversation entity
   */
  get_conversation_by_id(conversation_id) {
    if (!_.isString(conversation_id)) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CONVERSATION_ID));
    }

    return this.find_conversation_by_id(conversation_id)
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (isConversationNotFound) {
          return this.fetch_conversation_by_id(conversation_id);
        }

        throw error;
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          this.logger.error(`Failed to get conversation '${conversation_id}': ${error.message}`, error);
        }

        throw error;
      });
  }

  /**
   * Get group conversations by name.
   *
   * @param {string} query - Query to be searched in group conversation names
   * @param {boolean} isHandle - Query string is handle
   * @returns {Array<Conversation>} Matching group conversations
   */
  getGroupsByName(query, isHandle) {
    return this.sorted_conversations()
      .filter(conversationEntity => {
        if (!conversationEntity.isGroup()) {
          return false;
        }

        const queryString = isHandle ? `@${query}` : query;
        if (z.util.StringUtil.compareTransliteration(conversationEntity.display_name(), queryString)) {
          return true;
        }

        for (const userEntity of conversationEntity.participating_user_ets()) {
          const nameString = isHandle ? userEntity.username() : userEntity.name();
          if (z.util.StringUtil.startsWith(nameString, query)) {
            return true;
          }
        }

        return false;
      })
      .sort((conversationA, conversationB) => {
        return z.util.StringUtil.sortByPriority(conversationA.display_name(), conversationB.display_name(), query);
      })
      .map(conversationEntity => {
        this.updateParticipatingUserEntities(conversationEntity);
        return conversationEntity;
      });
  }

  /**
   * Get the most recent event timestamp from any conversation.
   * @param {boolean} [increment=false] - Increment by one for unique timestamp
   * @returns {number} Timestamp value
   */
  getLatestEventTimestamp(increment = false) {
    const mostRecentConversation = this.getMostRecentConversation(true);
    if (mostRecentConversation) {
      const lastEventTimestamp = mostRecentConversation.last_event_timestamp();
      return lastEventTimestamp + (increment ? 1 : 0);
    }

    return 1;
  }

  /**
   * Get the next unarchived conversation.
   *
   * @param {Conversation} conversation_et - Conversation to start from
   * @returns {Conversation} Next conversation
   */
  get_next_conversation(conversation_et) {
    return z.util.ArrayUtil.getNextItem(this.conversations_unarchived(), conversation_et);
  }

  /**
   * Get unarchived conversation with the most recent event.
   * @param {boolean} [allConversations=false] - Search all conversations
   * @returns {Conversation} Most recent conversation
   */
  getMostRecentConversation(allConversations = false) {
    const [conversation_et] = allConversations ? this.sorted_conversations() : this.conversations_unarchived();
    return conversation_et;
  }

  /**
   * Returns a list of sorted conversation ids based on the number of messages in the last 30 days.
   * @returns {Promise} Resolve with the most active conversations
   */
  get_most_active_conversations() {
    return this.conversation_service.get_active_conversations_from_db().then(conversation_ids => {
      return conversation_ids
        .map(conversation_id => this._find_conversation_by_id(conversation_id))
        .filter(conversation_et => conversation_et);
    });
  }

  /**
   * Get conversation with a user.
   * @param {User} userEntity - User entity for whom to get the conversation
   * @returns {Promise} Resolves with the conversation with requested user
   */
  get1To1Conversation(userEntity) {
    const inCurrentTeam = userEntity.inTeam() && userEntity.isTeamMember();

    if (inCurrentTeam) {
      const matchingConversationEntity = this.conversations().find(conversationEntity => {
        if (!conversationEntity.is1to1()) {
          // Disregard conversations that are not 1:1
          return false;
        }

        const inTeam = userEntity.teamId === conversationEntity.team_id;
        if (!inTeam) {
          // Disregard conversations that are not in the team
          return false;
        }

        const isActiveConversation = !conversationEntity.removed_from_conversation();
        if (!isActiveConversation) {
          // Disregard coversations that self is no longer part of
          return false;
        }

        const [userId] = conversationEntity.participating_user_ids();
        return userEntity.id === userId;
      });

      return matchingConversationEntity
        ? Promise.resolve(matchingConversationEntity)
        : this.createGroupConversation([userEntity]);
    }

    const conversationId = userEntity.connection().conversationId;
    return this.get_conversation_by_id(conversationId)
      .then(conversationEntity => {
        conversationEntity.connection(userEntity.connection());
        return this.updateParticipatingUserEntities(conversationEntity);
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }
      });
  }

  /**
   * Check whether conversation is currently displayed.
   * @param {Conversation} conversation_et - Conversation to be saved
   * @returns {boolean} Is the conversation active
   */
  is_active_conversation(conversation_et) {
    if (this.active_conversation()) {
      return this.active_conversation().id === conversation_et.id;
    }
  }

  /**
   * Check whether message has been read.
   *
   * @param {string} conversation_id - Conversation ID
   * @param {string} message_id - Message ID
   * @returns {Promise} Resolves with true if message is marked as read
   */
  is_message_read(conversation_id, message_id) {
    if (!conversation_id || !message_id) {
      return Promise.resolve(false);
    }

    return this.get_conversation_by_id(conversation_id)
      .then(conversation_et => {
        return this.get_message_in_conversation_by_id(conversation_et, message_id).then(
          message_et => conversation_et.last_read_timestamp() >= message_et.timestamp()
        );
      })
      .catch(error => {
        const messageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (messageNotFound) {
          return true;
        }

        throw error;
      });
  }

  initialize_conversations() {
    this._initStateUpdates();
    this.init_total = this.receiving_queue.getLength();

    if (this.init_total > 5) {
      this.logger.log(`Handling '${this.init_total}' additional messages on app start`);
      return new Promise((resolve, reject) => (this.init_promise = {reject_fn: reject, resolve_fn: resolve}));
    }
  }

  joinConversationWithCode(key, code) {
    return this.conversation_service.postConversationJoin(key, code).then(response => {
      if (response) {
        return this._onCreate(response);
      }
    });
  }

  /**
   * Maps user connection to the corresponding conversation.
   *
   * @note If there is no conversation it will request it from the backend
   * @param {z.connection.ConnectionEntity} connectionEntity - Connections
   * @param {boolean} [show_conversation=false] - Open the new conversation
   * @returns {Promise} Resolves when connection was mapped return value
   */
  map_connection(connectionEntity, show_conversation = false) {
    return this.find_conversation_by_id(connectionEntity.conversationId)
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }

        if (connectionEntity.isConnected() || connectionEntity.isOutgoingRequest()) {
          return this.fetch_conversation_by_id(connectionEntity.conversationId);
        }

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      })
      .then(conversation_et => {
        conversation_et.connection(connectionEntity);

        if (connectionEntity.isConnected()) {
          conversation_et.type(z.conversation.ConversationType.ONE2ONE);
        }

        this.updateParticipatingUserEntities(conversation_et).then(updated_conversation_et => {
          if (show_conversation) {
            amplify.publish(z.event.WebApp.CONVERSATION.SHOW, updated_conversation_et);
          }

          this.conversations.notifySubscribers();
        });

        return conversation_et;
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (!isConversationNotFound) {
          throw error;
        }
      });
  }

  /**
   * Maps user connections to the corresponding conversations.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connections entities
   * @returns {undefined} No return value
   */
  map_connections(connectionEntities) {
    this.logger.info(`Mapping '${connectionEntities.length}' user connection(s) to conversations`, connectionEntities);
    connectionEntities.map(connectionEntity => this.map_connection(connectionEntity));
  }

  /**
   * Map conversation payload.
   *
   * @param {JSON} payload - Payload to map
   * @param {number} [initialTimestamp=this.getLatestEventTimestamp()] - Initial server and event timestamp
   * @returns {z.entity.Conversation|Array<z.entity.Conversation>} Mapped conversation/s
   */
  mapConversations(payload, initialTimestamp = this.getLatestEventTimestamp()) {
    const conversationsData = payload.length ? payload : [payload];

    const entitites = this.conversationMapper.mapConversations(conversationsData, initialTimestamp);
    entitites.forEach(conversationEntity => {
      this._mapGuestStatusSelf(conversationEntity);
      conversationEntity.selfUser(this.selfUser());
      conversationEntity.setStateChangePersistence(true);
    });

    return payload.length ? entitites : entitites[0];
  }

  map_guest_status_self() {
    this.filtered_conversations().forEach(conversation_et => this._mapGuestStatusSelf(conversation_et));

    if (this.isTeam()) {
      this.selfUser().inTeam(true);
      this.selfUser().isTeamMember(true);
    }
  }

  _mapGuestStatusSelf(conversationEntity) {
    const conversationTeamId = conversationEntity.team_id;
    const selfTeamId = this.team() && this.team().id;
    const isConversationGuest = !!(conversationTeamId && (!selfTeamId || selfTeamId !== conversationTeamId));
    conversationEntity.isGuest(isConversationGuest);
  }

  /**
   * Mark conversation as read.
   * @param {Conversation} conversationEntity - Conversation to be marked as read
   * @returns {undefined} No return value
   */
  markAsRead(conversationEntity) {
    if (conversationEntity) {
      const hasUnreadEvents = conversationEntity.last_read_timestamp() < conversationEntity.last_server_timestamp();
      const isNotMarkedAsRead = hasUnreadEvents || conversationEntity.unreadState().allEvents.length;
      if (isNotMarkedAsRead && !this.block_event_handling()) {
        this._updateLastReadTimestamp(conversationEntity);
        amplify.publish(z.event.WebApp.NOTIFICATION.REMOVE_READ);
      }
    }
  }

  /**
   * Save a conversation in the repository.
   * @param {Conversation} conversation_et - Conversation to be saved in the repository
   * @returns {Promise} Resolves when conversation was saved
   */
  save_conversation(conversation_et) {
    return this.find_conversation_by_id(conversation_et.id).catch(error => {
      const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
      if (isConversationNotFound) {
        this.conversations.push(conversation_et);
        return this.save_conversation_state_in_db(conversation_et);
      }

      throw error;
    });
  }

  /**
   * Persists a conversation state in the database.
   * @param {Conversation} conversation_et - Conversation of which the state should be persisted
   * @returns {Promise} Resolves when conversation was saved
   */
  save_conversation_state_in_db(conversation_et) {
    return this.conversation_service.save_conversation_state_in_db(conversation_et);
  }

  /**
   * Save conversations in the repository.
   * @param {Array<Conversation>} conversation_ets - Conversations to be saved in the repository
   * @returns {undefined} No return value
   */
  save_conversations(conversation_ets) {
    z.util.koArrayPushAll(this.conversations, conversation_ets);
  }

  /**
   * Set the notification handling state.
   *
   * @note Temporarily do not unarchive conversations when handling the notification stream
   * @param {z.event.NOTIFICATION_HANDLING_STATE} handling_state - State of the notifications stream handling
   * @returns {undefined} No return value
   */
  set_notification_handling_state(handling_state) {
    const updated_handling_state = handling_state !== z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    if (this.block_event_handling() !== updated_handling_state) {
      this.block_event_handling(updated_handling_state);
      this.sending_queue.pause(this.block_event_handling());
      this.logger.info(`Block handling of conversation events: ${this.block_event_handling()}`);
    }
  }

  /**
   * Update participating users in a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to be updated
   * @param {boolean} [offline=false] - Should we only look for cached contacts
   * @param {boolean} [updateGuests=false] - Update conversation guests
   * @returns {Promise} Resolves when users have been updated
   */
  updateParticipatingUserEntities(conversationEntity, offline = false, updateGuests = false) {
    return this.user_repository
      .get_users_by_id(conversationEntity.participating_user_ids(), offline)
      .then(userEntities => {
        userEntities.sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
        conversationEntity.participating_user_ets(userEntities);

        if (updateGuests) {
          conversationEntity.updateGuests();
        }

        return conversationEntity;
      });
  }

  //##############################################################################
  // Send events
  //##############################################################################

  /**
   * Add users to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add users to
   * @param {Array<z.entity.User>} userEntities - Users to be added to the conversation
   * @returns {Promise} Resolves when members were added
   */
  addMembers(conversationEntity, userEntities) {
    const userIds = userEntities.map(userEntity => userEntity.id);

    return this.conversation_service
      .postMembers(conversationEntity.id, userIds)
      .then(response => {
        if (response) {
          this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        }
      })
      .catch(error => this._handleAddToConversationError(error, conversationEntity, userIds));
  }

  addMissingMember(conversationId, userIds, timestamp) {
    return this.get_conversation_by_id(conversationId).then(conversationEntity => {
      const [sender] = userIds;
      const event = z.conversation.EventBuilder.buildMemberJoin(conversationEntity, sender, userIds, timestamp);
      return this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.INJECTED);
    });
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add service to
   * @param {string} providerId - ID of service provider
   * @param {string} serviceId - ID of service
   * @returns {Promise} Resolves when service was added
   */
  addService(conversationEntity, providerId, serviceId) {
    return this.conversation_service
      .postBots(conversationEntity.id, providerId, serviceId)
      .then(response => {
        const event = response ? response.event : undefined;
        if (event) {
          const logMessage = `Successfully added service to conversation '${conversationEntity.display_name()}'`;
          this.logger.debug(logMessage, response);
          return this.eventRepository.injectEvent(response.event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        }

        return event;
      })
      .catch(error => this._handleAddToConversationError(error, conversationEntity, [serviceId]));
  }

  _handleAddToConversationError(error, conversationEntity, userIds) {
    switch (error.label) {
      case z.error.BackendClientError.LABEL.NOT_CONNECTED: {
        this._handleUsersNotConnected(userIds);
        break;
      }

      case z.error.BackendClientError.LABEL.BAD_GATEWAY:
      case z.error.BackendClientError.LABEL.SERVER_ERROR:
      case z.error.BackendClientError.LABEL.SERVICE_DISABLED:
      case z.error.BackendClientError.LABEL.TOO_MANY_BOTS: {
        const messageText = z.l10n.text(z.string.modalServiceUnavailableMessage);
        const titleText = z.l10n.text(z.string.modalServiceUnavailableHeadline);

        this._showModal(messageText, titleText);
        break;
      }

      case z.error.BackendClientError.LABEL.TOO_MANY_MEMBERS: {
        this._handleTooManyMembersError(conversationEntity.getNumberOfParticipants());
        break;
      }

      default: {
        throw error;
      }
    }
  }

  /**
   * Clear conversation content and archive the conversation.
   *
   * @note According to spec we archive a conversation when we clear it.
   * It will be unarchived once it is opened through search. We use the archive flag to distinguish states.
   *
   * @param {Conversation} conversation_et - Conversation to clear
   * @param {boolean} [leave_conversation=false] - Should we leave the conversation before clearing the content?
   * @returns {undefined} No return value
   */
  clear_conversation(conversation_et, leave_conversation = false) {
    const is_active_conversation = this.is_active_conversation(conversation_et);
    const next_conversation_et = this.get_next_conversation(conversation_et);

    if (leave_conversation) {
      conversation_et.status(z.conversation.ConversationStatus.PAST_MEMBER);
    }

    this._updateClearedTimestamp(conversation_et);
    this._clear_conversation(conversation_et);

    if (leave_conversation) {
      this.removeMember(conversation_et, this.selfUser().id);
    }

    if (is_active_conversation) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, next_conversation_et);
    }
  }

  /**
   * Update cleared of conversation using timestamp.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to update
   * @returns {undefined} No return value
   */
  _updateClearedTimestamp(conversationEntity) {
    const timestamp = conversationEntity.get_last_known_timestamp(this.serverTimeRepository.toServerTimestamp());

    if (timestamp && conversationEntity.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.CLEARED)) {
      const protoCleared = new z.proto.Cleared(conversationEntity.id, timestamp);
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CLEARED, protoCleared);

      const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
      this.sendGenericMessageToConversation(eventInfoEntity).then(() => {
        this.logger.info(`Cleared conversation '${conversationEntity.id}' on '${new Date(timestamp).toISOString()}'`);
      });
    }
  }

  leaveGuestRoom() {
    if (this.selfUser().isTemporaryGuest()) {
      const conversationEntity = this.getMostRecentConversation(true);
      return this.conversation_service.deleteMembers(conversationEntity.id, this.selfUser().id);
    }
  }

  /**
   * Remove member from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove member from
   * @param {string} userId - ID of member to be removed from the conversation
   * @returns {Promise} Resolves when member was removed from the conversation
   */
  removeMember(conversationEntity, userId) {
    return this.conversation_service.deleteMembers(conversationEntity.id, userId).then(response => {
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = !!response
        ? response
        : z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, true, currentTimestamp);

      this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
      return event;
    });
  }

  /**
   * Remove service from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove service from
   * @param {z.entity.User} userId - ID of service user to be removed from the conversation
   * @returns {Promise} Resolves when service was removed from the conversation
   */
  removeService(conversationEntity, userId) {
    return this.conversation_service.deleteBots(conversationEntity.id, userId).then(response => {
      const hasResponse = response && response.event;
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = hasResponse
        ? response.event
        : z.conversation.EventBuilder.buildMemberLeave(conversationEntity, userId, true, currentTimestamp);

      this.eventRepository.injectEvent(event, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
      return event;
    });
  }

  /**
   * Rename conversation.
   *
   * @param {Conversation} conversation_et - Conversation to rename
   * @param {string} name - New conversation name
   * @returns {Promise} Resolves when conversation was renamed
   */
  renameConversation(conversation_et, name) {
    return this.conversation_service.updateConversationName(conversation_et.id, name).then(response => {
      if (response) {
        this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
        return response;
      }
    });
  }

  /**
   * Set the global message timer
   *
   * @param {Conversation} conversationEntity - Conversation to update
   * @param {number} messageTimer - New message timer value
   * @returns {Promise} Resolves when conversation was updated on server side
   */
  updateConversationMessageTimer(conversationEntity, messageTimer) {
    messageTimer = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    return this.conversation_service
      .updateConversationMessageTimer(conversationEntity.id, messageTimer)
      .then(response => {
        if (response) {
          this.eventRepository.injectEvent(response, z.event.EventRepository.SOURCE.BACKEND_RESPONSE);
          return response;
        }
      });
  }

  reset_session(user_id, client_id, conversation_id) {
    this.logger.info(`Resetting session with client '${client_id}' of user '${user_id}'.`);

    return this.cryptography_repository
      .deleteSession(user_id, client_id)
      .then(session_id => {
        if (session_id) {
          this.logger.info(`Deleted session with client '${client_id}' of user '${user_id}'.`);
        } else {
          this.logger.warn('No local session found to delete.');
        }

        return this.sendSessionReset(user_id, client_id, conversation_id);
      })
      .catch(error => {
        const logMessage = `Failed to reset session for client '${client_id}' of user '${user_id}': ${error.message}`;
        this.logger.warn(logMessage, error);
        throw error;
      });
  }

  /**
   * Send a specific GIF to a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to send message in
   * @param {string} url - URL of giphy image
   * @param {string} tag - tag tag used for gif search
   * @returns {Promise} Resolves when the gif was posted
   */
  sendGif(conversationEntity, url, tag) {
    if (!tag) {
      tag = z.l10n.text(z.string.extensionsGiphyRandom);
    }

    return z.util.loadUrlBlob(url).then(blob => {
      const textMessage = z.l10n.text(z.string.extensionsGiphyMessage, tag);
      this.sendText(conversationEntity, textMessage);
      return this.upload_images(conversationEntity, [blob]);
    });
  }

  /**
   * Team member was removed.
   * @param {string} teamId - ID of team that member was removed from
   * @param {string} userId - ID of leaving user
   * @param {Date} isoDate - Date of member removal
   * @returns {undefined} No return value
   */
  teamMemberLeave(teamId, userId, isoDate) {
    this.user_repository.get_user_by_id(userId).then(userEntity => {
      this.conversations()
        .filter(conversationEntity => {
          const conversationInTeam = conversationEntity.team_id === teamId;
          const userIsParticipant = conversationEntity.participating_user_ids().includes(userId);
          return conversationInTeam && userIsParticipant && !conversationEntity.removed_from_conversation();
        })
        .forEach(conversationEntity => {
          const leaveEvent = z.conversation.EventBuilder.buildTeamMemberLeave(conversationEntity, userEntity, isoDate);
          this.eventRepository.injectEvent(leaveEvent);
        });
    });
  }

  /**
   * Set the notification state of a conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to change notification state off
   * @param {z.conversation.NotificationSetting} notificationState - New notification state
   * @returns {Promise} Resolves when the notification stated was change
   */
  setNotificationState(conversationEntity, notificationState) {
    if (!conversationEntity || notificationState === undefined) {
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const validNotificationStates = Object.values(z.conversation.NotificationSetting.STATE);
    if (!validNotificationStates.includes(notificationState)) {
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.INVALID_PARAMETER));
    }

    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const otrMuted = notificationState !== z.conversation.NotificationSetting.STATE.EVERYTHING;
    const payload = {
      otr_muted: otrMuted,
      otr_muted_ref: new Date(conversationEntity.get_last_known_timestamp(currentTimestamp)).toISOString(),
      otr_muted_status: notificationState,
    };

    return this.conversation_service
      .update_member_properties(conversationEntity.id, payload)
      .then(() => {
        const response = {data: payload, from: this.selfUser().id};
        this._onMemberUpdate(conversationEntity, response);

        const {otr_muted: muted, otr_muted_ref: mutedRef, otr_muted_status: mutedStatus} = payload;
        const logMessage = `Changed notification state of conversation to '${muted} | ${mutedStatus}' on '${mutedRef}'`;
        this.logger.info(logMessage);
        return response;
      })
      .catch(error => {
        const log = `Failed to change notification state of conversation '${conversationEntity.id}': ${error.message}`;
        const rejectError = new Error(log);
        this.logger.warn(rejectError.message, error);
        throw rejectError;
      });
  }

  /**
   * Archive a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to rename
   * @returns {Promise} Resolves when the conversation was archived
   */
  archiveConversation(conversationEntity) {
    return this._toggleArchiveConversation(conversationEntity, true).then(() => {
      this.logger.info(`Conversation '${conversationEntity.id}' archived`);
    });
  }

  /**
   * Un-archive a conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to unarchive
   * @param {boolean} [forceChange=false] - Force state change without new message
   * @param {string} trigger - Trigger for unarchive
   * @returns {Promise} Resolves when the conversation was unarchived
   */
  unarchiveConversation(conversationEntity, forceChange = false, trigger = 'unknown') {
    return this._toggleArchiveConversation(conversationEntity, false, forceChange).then(() => {
      this.logger.info(`Conversation '${conversationEntity.id}' unarchived by trigger '${trigger}'`);
    });
  }

  _toggleArchiveConversation(conversationEntity, newState, forceChange) {
    if (!conversationEntity) {
      const error = new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      return Promise.reject(error);
    }

    const stateChange = conversationEntity.is_archived() !== newState;

    const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
    const archiveTimestamp = conversationEntity.get_last_known_timestamp(currentTimestamp);
    const sameTimestamp = conversationEntity.archivedTimestamp() === archiveTimestamp;
    const skipChange = sameTimestamp && !forceChange;

    if (!stateChange && skipChange) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES));
    }

    const payload = {
      otr_archived: newState,
      otr_archived_ref: new Date(archiveTimestamp).toISOString(),
    };

    const conversationId = conversationEntity.id;

    const updatePromise = conversationEntity.removed_from_conversation()
      ? Promise.resolve()
      : this.conversation_service.update_member_properties(conversationId, payload).catch(error => {
          const logMessage = `Failed to change archived state of '${conversationId}' to '${newState}': ${error.code}`;
          this.logger.error(logMessage);

          const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (!isNotFound) {
            throw error;
          }
        });

    return updatePromise.then(() => {
      const response = {
        data: payload,
        from: this.selfUser().id,
      };

      this._onMemberUpdate(conversationEntity, response);
    });
  }

  _checkChangedConversations() {
    this.conversationsWithNewEvents.forEach(conversationEntity => {
      if (conversationEntity.shouldUnarchive()) {
        this.unarchiveConversation(conversationEntity, false, 'event from notification stream');
      }
    });

    this.conversationsWithNewEvents.clear();
  }

  /**
   * Clears conversation content from view and the database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation entity to delete
   * @param {number} [timestamp] - Optional timestamps for which messages to remove
   * @returns {undefined} No return value
   */
  _clear_conversation(conversation_et, timestamp) {
    this._deleteMessages(conversation_et, timestamp);

    if (conversation_et.removed_from_conversation()) {
      this.conversation_service.delete_conversation_from_db(conversation_et.id);
      this.delete_conversation(conversation_et.id);
    }
  }

  _handleConversationCreateError(error, userIds) {
    switch (error.label) {
      case z.error.BackendClientError.LABEL.CLIENT_ERROR:
        this._handleTooManyMembersError();
        break;
      case z.error.BackendClientError.LABEL.NOT_CONNECTED:
        this._handleUsersNotConnected(userIds);
        break;
      default:
        throw error;
    }
  }

  _handleTooManyMembersError(participants = ConversationRepository.CONFIG.GROUP.MAX_SIZE) {
    const openSpots = ConversationRepository.CONFIG.GROUP.MAX_SIZE - participants;
    const substitutions = {number1: ConversationRepository.CONFIG.GROUP.MAX_SIZE, number2: Math.max(0, openSpots)};

    const messageText = z.l10n.text(z.string.modalConversationTooManyMembersMessage, substitutions);
    const titleText = z.l10n.text(z.string.modalConversationTooManyMembersHeadline);
    this._showModal(messageText, titleText);
  }

  _handleUsersNotConnected(userIds = []) {
    const [userID] = userIds;
    const userPromise = userIds.length === 1 ? this.user_repository.get_user_by_id(userID) : Promise.resolve();

    userPromise.then(userEntity => {
      const username = userEntity ? userEntity.first_name() : undefined;
      const messageStringId = username
        ? z.string.modalConversationNotConnectedMessageOne
        : z.string.modalConversationNotConnectedMessageMany;

      const messageText = z.l10n.text(messageStringId, username);
      const titleText = z.l10n.text(z.string.modalConversationNotConnectedHeadline);
      this._showModal(messageText, titleText);
    });
  }

  _showModal(messageText, titleText) {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: messageText,
        title: titleText,
      },
    });
  }

  /**
   * Update last read of conversation using timestamp.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to update
   * @returns {undefined} No return value
   */
  _updateLastReadTimestamp(conversationEntity) {
    const timestamp = conversationEntity.get_last_known_timestamp(this.serverTimeRepository.toServerTimestamp());
    const conversationId = conversationEntity.id;

    if (timestamp && conversationEntity.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ)) {
      const protoLeastRead = new z.proto.LastRead(conversationId, conversationEntity.last_read_timestamp());
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.LAST_READ, protoLeastRead);

      const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
      this.sendGenericMessageToConversation(eventInfoEntity)
        .then(() => {
          this.logger.info(`Marked conversation '${conversationId}' as read on '${new Date(timestamp).toISOString()}'`);
        })
        .catch(error => {
          const errorMessage = 'Failed to update last read timestamp';
          this.logger.error(`${errorMessage}: ${error.message}`, error);
          Raygun.send(new Error(errorMessage), {label: error.label, message: error.message});
        });
    }
  }

  //##############################################################################
  // Send encrypted events
  //##############################################################################

  send_asset_remotedata(conversationEntity, file, messageId) {
    let genericMessage;

    return this.get_message_in_conversation_by_id(conversationEntity, messageId)
      .then(messageEntity => {
        const assetEntity = messageEntity.get_first_asset();
        const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
        const options = {retention};

        assetEntity.uploaded_on_this_client(true);
        return this.asset_service.uploadAsset(file, options, xhr => {
          xhr.upload.onprogress = event => assetEntity.upload_progress(Math.round((event.loaded / event.total) * 100));
          assetEntity.upload_cancel = () => xhr.abort();
        });
      })
      .then(asset => {
        genericMessage = new z.proto.GenericMessage(messageId);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversationEntity.messageTimer()) {
          genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
        }

        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
        return this.sendGenericMessageToConversation(eventInfoEntity);
      })
      .then(payload => {
        const {uploaded: assetData} = conversationEntity.messageTimer()
          ? genericMessage.ephemeral.asset
          : genericMessage.asset;

        const data = {
          key: assetData.asset_id,
          otr_key: assetData.otr_key,
          sha256: assetData.sha256,
          token: assetData.asset_token,
        };

        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const assetAddEvent = z.conversation.EventBuilder.buildAssetAdd(conversationEntity, data, currentTimestamp);

        assetAddEvent.id = messageId;
        assetAddEvent.time = payload.time;

        return this._on_asset_upload_complete(conversationEntity, assetAddEvent);
      });
  }

  /**
   * Send asset metadata message to specified conversation.
   *
   * @param {Conversation} conversation_et - Conversation that should receive the file
   * @param {File} file - File to send
   * @returns {Promise} Resolves when the asset metadata was sent
   */
  send_asset_metadata(conversation_et, file) {
    return z.assets.AssetMetaDataBuilder.buildMetadata(file)
      .catch(error => {
        const logMessage = `Couldn't render asset preview from metadata. Asset might be corrupt: ${error.message}`;
        this.logger.warn(logMessage, error);
        return undefined;
      })
      .then(metadata => {
        const protoAsset = new z.proto.Asset();

        let assetOriginal = undefined;
        if (z.assets.AssetMetaDataBuilder.isAudio(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, null, null, metadata);
        } else if (z.assets.AssetMetaDataBuilder.isVideo(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, null, metadata);
        } else if (z.assets.AssetMetaDataBuilder.isImage(file)) {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name, metadata);
        } else {
          assetOriginal = new z.proto.Asset.Original(file.type, file.size, file.name);
        }
        protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_ORIGINAL, assetOriginal);

        return protoAsset;
      })
      .then(asset => {
        let generic_message = new z.proto.GenericMessage(z.util.createRandomUuid());
        generic_message.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversation_et.messageTimer()) {
          generic_message = this._wrap_in_ephemeral_message(generic_message, conversation_et.messageTimer());
        }

        return this._send_and_inject_generic_message(conversation_et, generic_message);
      })
      .catch(error => {
        const log = `Failed to upload metadata for asset in conversation '${conversation_et.id}': ${error.message}`;
        this.logger.warn(log, error);

        if (error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }
      });
  }

  /**
   * Send asset preview message to specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the preview
   * @param {File} file - File to generate preview from
   * @param {string} messageId - Message ID of the message to generate a preview for
   * @returns {Promise} Resolves when the asset preview was sent
   */
  sendAssetPreview(conversationEntity, file, messageId) {
    return poster(file)
      .then(imageBlob => {
        if (!imageBlob) {
          throw Error('No image available');
        }

        const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
        const options = {retention};

        return this.asset_service.uploadAsset(imageBlob, options).then(uploadedImageAsset => {
          const protoAsset = new z.proto.Asset();
          const assetPreview = new z.proto.Asset.Preview(imageBlob.type, imageBlob.size, uploadedImageAsset.uploaded);
          protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_PREVIEW, assetPreview);

          const genericMessage = new z.proto.GenericMessage(messageId);
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, protoAsset);

          return this._send_and_inject_generic_message(conversationEntity, genericMessage, false);
        });
      })
      .catch(error => {
        const message = `No preview for asset '${messageId}' in conversation '${conversationEntity.id}' uploaded `;
        this.logger.warn(message, error);
      });
  }

  /**
   * Send asset upload failed message to specified conversation.
   *
   * @param {Conversation} conversation_et - Conversation that should receive the file
   * @param {string} messageId - ID of the metadata message
   * @param {z.assets.AssetUploadFailedReason} [reason=z.assets.AssetUploadFailedReason.FAILED] - Cause for the failed upload (optional)
   * @returns {Promise} Resolves when the asset failure was sent
   */
  send_asset_upload_failed(conversation_et, messageId, reason = z.assets.AssetUploadFailedReason.FAILED) {
    const wasCancelled = reason === z.assets.AssetUploadFailedReason.CANCELLED;
    const protoReason = wasCancelled ? z.proto.Asset.NotUploaded.CANCELLED : z.proto.Asset.NotUploaded.FAILED;
    const protoAsset = new z.proto.Asset();
    protoAsset.set(z.cryptography.PROTO_MESSAGE_TYPE.ASSET_NOT_UPLOADED, protoReason);

    const generic_message = new z.proto.GenericMessage(messageId);
    generic_message.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, protoAsset);

    return this._send_and_inject_generic_message(conversation_et, generic_message);
  }

  /**
   * Send confirmation for a content message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that content message was received in
   * @param {Message} messageEntity - Message for which to acknowledge receipt
   * @returns {undefined} No return value
   */
  sendConfirmationStatus(conversationEntity, messageEntity) {
    const otherUserIn1To1 = !messageEntity.user().is_me && conversationEntity.is1to1();
    const CONFIRMATION_THRESHOLD = ConversationRepository.CONFIG.CONFIRMATION_THRESHOLD;
    const withinThreshold = messageEntity.timestamp() >= Date.now() - CONFIRMATION_THRESHOLD;
    const typeToConfirm = z.event.EventTypeHandling.CONFIRM.includes(messageEntity.type);

    const sendConfirmation = otherUserIn1To1 && withinThreshold && typeToConfirm;
    if (sendConfirmation) {
      const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
      const protoConfirmation = new z.proto.Confirmation(z.proto.Confirmation.Type.DELIVERED, messageEntity.id);
      genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CONFIRMATION, protoConfirmation);

      this.sending_queue.push(() => {
        return this.create_recipients(conversationEntity.id, true, [messageEntity.user().id]).then(recipients => {
          const options = {nativePush: false, precondition: [messageEntity.user().id], recipients};
          const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id, options);

          return this._sendGenericMessage(eventInfoEntity);
        });
      });
    }
  }

  /**
   * Send call message in specified conversation.
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event info to be send
   * @param {Conversation} conversationEntity - Conversation to send call message to
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Content for call message
   * @returns {Promise} Resolves when the confirmation was sent
   */
  sendCallingMessage(eventInfoEntity, conversationEntity, callMessageEntity) {
    return this.sending_queue
      .push(() => {
        const options = eventInfoEntity.options;
        const recipientsPromise = options.recipients
          ? Promise.resolve(eventInfoEntity)
          : this.create_recipients(conversationEntity.id, false).then(recipients => {
              eventInfoEntity.updateOptions({recipients});
              return eventInfoEntity;
            });

        return recipientsPromise.then(infoEntity => this._sendGenericMessage(infoEntity));
      })
      .then(() => {
        const initiatingCallMessage = [
          z.calling.enum.CALL_MESSAGE_TYPE.GROUP_START,
          z.calling.enum.CALL_MESSAGE_TYPE.SETUP,
        ];

        const isCallInitiation = initiatingCallMessage.includes(callMessageEntity.type);
        if (isCallInitiation) {
          return this._trackContributed(conversationEntity, eventInfoEntity.genericMessage, callMessageEntity);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }

        amplify.publish(z.event.WebApp.CALL.STATE.DELETE, callMessageEntity.conversationId);
      });
  }

  /**
   * Sends image asset in specified conversation using v3 api.
   *
   * @param {Conversation} conversationEntity - Conversation to send image in
   * @param {File|Blob} image - Image
   * @returns {Promise} Resolves when the image was sent
   */
  send_image_asset(conversationEntity, image) {
    const retention = this.asset_service.getAssetRetention(this.selfUser(), conversationEntity);
    const options = {retention};

    return this.asset_service
      .uploadImageAsset(image, options)
      .then(asset => {
        let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.ASSET, asset);

        if (conversationEntity.messageTimer()) {
          genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
        }

        return this._send_and_inject_generic_message(conversationEntity, genericMessage);
      })
      .catch(error => {
        const message = `Failed to upload otr asset for conversation ${conversationEntity.id}: ${error.message}`;
        this.logger.error(message, error);
        throw error;
      });
  }

  /**
   * Send knock in specified conversation.
   * @param {Conversation} conversationEntity - Conversation to send knock in
   * @returns {Promise} Resolves after sending the knock
   */
  sendKnock(conversationEntity) {
    let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoKnock = new z.proto.Knock(false);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.KNOCK, protoKnock);

    if (conversationEntity.messageTimer()) {
      genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
    }

    return this._send_and_inject_generic_message(conversationEntity, genericMessage).catch(error => {
      if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
        this.logger.error(`Error while sending knock: ${error.message}`, error);
        throw error;
      }
    });
  }

  /**
   * Send link preview in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message that possibly contains link
   * @param {z.proto.GenericMessage} genericMessage - GenericMessage of containing text or edited message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of message
   * @returns {Promise} Resolves after sending the message
   */
  sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities) {
    const conversationId = conversationEntity.id;
    const messageId = genericMessage.message_id;

    return this.link_repository
      .getLinkPreviewFromString(textMessage)
      .then(linkPreview => {
        if (linkPreview) {
          const protoText = this._createTextProto(messageId, textMessage, mentionEntities, undefined, [linkPreview]);
          genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.TEXT, protoText);

          return this.get_message_in_conversation_by_id(conversationEntity, messageId);
        }

        this.logger.debug(`No link preview for message '${messageId}' in conversation '${conversationId}' created`);
      })
      .then(messageEntity => {
        if (messageEntity) {
          const assetEntity = messageEntity.get_first_asset();
          const messageContentUnchanged = assetEntity.text === textMessage;

          if (messageContentUnchanged) {
            this.logger.debug(`Sending link preview for message '${messageId}' in conversation '${conversationId}'`);
            return this._send_and_inject_generic_message(conversationEntity, genericMessage, false);
          }

          this.logger.debug(`Skipped sending link preview as message '${messageId}' in '${conversationId}' changed`);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          this.logger.warn(`Failed sending link preview for message '${messageId}' in '${conversationId}'`);
          throw error;
        }

        this.logger.warn(`Skipped link preview for unknown message '${messageId}' in '${conversationId}'`);
      });
  }

  /**
   * Send location message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {number} longitude - Longitude of the location
   * @param {number} latitude - Latitude of the location
   * @param {string} name - Name of the location
   * @param {number} zoom - Zoom factor for the map (Google Maps)
   * @returns {Promise} Resolves after sending the location
   */
  sendLocation(conversationEntity, longitude, latitude, name, zoom) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoLocation = new z.proto.Location(longitude, latitude, name, zoom);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.LOCATION, protoLocation);

    const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
    return this.sendGenericMessageToConversation(eventInfoEntity);
  }

  /**
   * Send edited message in specified conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation entity
   * @param {string} textMessage - Edited plain text message
   * @param {z.entity.Message} originalMessageEntity - Original message entity
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of the message
   * @returns {Promise} Resolves after sending the message
   */
  sendMessageEdit(conversationEntity, textMessage, originalMessageEntity, mentionEntities) {
    const hasDifferentText = z.util.MessageComparator.isTextDifferent(originalMessageEntity, textMessage);
    const hasDifferentMentions = z.util.MessageComparator.areMentionsDifferent(originalMessageEntity, mentionEntities);
    const wasEdited = hasDifferentText || hasDifferentMentions;

    if (!wasEdited) {
      return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.NO_MESSAGE_CHANGES));
    }

    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoText = this._createTextProto(genericMessage.message_id, textMessage, mentionEntities);
    const protoMessageEdit = new z.proto.MessageEdit(originalMessageEntity.id, protoText);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.EDITED, protoMessageEdit);

    return this._send_and_inject_generic_message(conversationEntity, genericMessage, false)
      .then(() => {
        if (z.util.Environment.desktop) {
          return this.sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          this.logger.error(`Error while editing message: ${error.message}`, error);
          throw error;
        }
      });
  }

  /**
   * Toggle like status of message.
   *
   * @param {Conversation} conversation_et - Conversation entity
   * @param {Message} message_et - Message to react to
   * @param {boolean} button - Source of toggle
   * @returns {undefined} No return value
   */
  toggle_like(conversation_et, message_et, button) {
    if (!conversation_et.removed_from_conversation()) {
      const reaction = message_et.is_liked() ? z.message.ReactionType.NONE : z.message.ReactionType.LIKE;
      message_et.is_liked(!message_et.is_liked());

      window.setTimeout(() => this.sendReaction(conversation_et, message_et, reaction), 100);
    }
  }

  /**
   * Send reaction to a content message in specified conversation.
   * @param {Conversation} conversationEntity - Conversation to send reaction in
   * @param {Message} messageEntity - Message to react to
   * @param {z.message.ReactionType} reaction - Reaction
   * @returns {Promise} Resolves after sending the reaction
   */
  sendReaction(conversationEntity, messageEntity, reaction) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoReaction = new z.proto.Reaction(reaction, messageEntity.id);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.REACTION, protoReaction);

    return this._send_and_inject_generic_message(conversationEntity, genericMessage);
  }

  /**
   * Sending a message to the remote end of a session reset.
   *
   * @note When we reset a session then we must inform the remote client about this action. It sends a ProtocolBuffer message
   *  (which will not be rendered in the view) to the remote client. This message only needs to be sent to the affected
   *  remote client, therefore we force the message sending.
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @param {string} conversationId - Conversation ID
   * @returns {Promise} Resolves after sending the session reset
   */
  sendSessionReset(userId, clientId, conversationId) {
    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.CLIENT_ACTION, z.proto.ClientAction.RESET_SESSION);

    const options = {
      precondition: true,
      recipients: {[userId]: [clientId]},
    };
    const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationId, options);

    return this._sendGenericMessage(eventInfoEntity)
      .then(response => {
        this.logger.info(`Sent info about session reset to client '${clientId}' of user '${userId}'`);
        return response;
      })
      .catch(error => {
        this.logger.error(`Sending conversation reset failed: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Send text message in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions as part of the message
   * @param {z.message.QuoteEntity} [quoteEntity] - Quote as part of the message
   * @returns {Promise} Resolves after sending the message
   */
  sendText(conversationEntity, textMessage, mentionEntities, quoteEntity) {
    let genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoText = this._createTextProto(genericMessage.message_id, textMessage, mentionEntities, quoteEntity);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.TEXT, protoText);

    if (conversationEntity.messageTimer()) {
      genericMessage = this._wrap_in_ephemeral_message(genericMessage, conversationEntity.messageTimer());
    }

    return this._send_and_inject_generic_message(conversationEntity, genericMessage).then(() => genericMessage);
  }

  /**
   * Send text message with link preview in specified conversation.
   *
   * @param {Conversation} conversationEntity - Conversation that should receive the message
   * @param {string} textMessage - Plain text message
   * @param {Array<z.message.MentionEntity>} [mentionEntities] - Mentions part of the message
   * @param {z.message.QuoteEntity} [quoteEntity] - Quoted message
   * @returns {Promise} Resolves after sending the message
   */
  sendTextWithLinkPreview(conversationEntity, textMessage, mentionEntities, quoteEntity) {
    return this.sendText(conversationEntity, textMessage, mentionEntities, quoteEntity)
      .then(genericMessage => {
        if (z.util.Environment.desktop) {
          return this.sendLinkPreview(conversationEntity, textMessage, genericMessage, mentionEntities);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          this.logger.error(`Error while sending text message: ${error.message}`, error);
          throw error;
        }
      });
  }

  _createTextProto(messageId, textMessage, mentionEntities, quoteEntity, linkPreviews) {
    const protoText = new z.proto.Text(textMessage);

    if (mentionEntities && mentionEntities.length) {
      const logMessage = `Adding '${mentionEntities.length}' mentions to message '${messageId}'`;
      this.logger.debug(logMessage, mentionEntities);

      const protoMentions = mentionEntities
        .filter(mentionEntity => {
          if (mentionEntity) {
            try {
              return mentionEntity.validate(textMessage);
            } catch (error) {
              const log = `Removed invalid mention when sending message '${messageId}': ${error.message}`;
              this.logger.warn(log, mentionEntity);
              return false;
            }
          }
        })
        .map(mentionEntity => mentionEntity.toProto());
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.MENTIONS, protoMentions);
    }

    if (quoteEntity) {
      const protoQuote = quoteEntity.toProto();
      this.logger.debug(`Adding quote to message '${messageId}'`, protoQuote);
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.QUOTE, protoQuote);
    }

    if (linkPreviews && linkPreviews.length) {
      this.logger.debug(`Adding link preview to message '${messageId}'`, linkPreviews);
      protoText.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEWS, linkPreviews);
    }

    return protoText;
  }

  /**
   * Wraps generic message in ephemeral message.
   *
   * @param {z.proto.GenericMessage} genericMessage - Message to be wrapped
   * @param {number} millis - Expire time in milliseconds
   * @returns {z.proto.Message} New proto message
   */
  _wrap_in_ephemeral_message(genericMessage, millis) {
    const protoEphemeral = new z.proto.Ephemeral();
    const ephemeralExpiration = z.conversation.ConversationEphemeralHandler.validateTimer(millis);

    protoEphemeral.set(z.cryptography.PROTO_MESSAGE_TYPE.EPHEMERAL_EXPIRATION, ephemeralExpiration);
    protoEphemeral.set(genericMessage.content, genericMessage[genericMessage.content]);

    genericMessage = new z.proto.GenericMessage(genericMessage.message_id);
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL, protoEphemeral);
    return genericMessage;
  }

  //##############################################################################
  // Send Generic Messages
  //##############################################################################

  /**
   * Create a user client map for a given conversation.
   *
   * @param {string} conversation_id - Conversation ID
   * @param {boolean} [skip_own_clients=false] - True, if other own clients should be skipped (to not sync messages on own clients)
   * @param {Array<string>} user_ids - Optionally the intended recipient users
   * @returns {Promise} Resolves with a user client map
   */
  create_recipients(conversation_id, skip_own_clients = false, user_ids) {
    return this.get_all_users_in_conversation(conversation_id).then(user_ets => {
      const recipients = {};

      for (const user_et of user_ets) {
        if (!(skip_own_clients && user_et.is_me)) {
          if (user_ids && !user_ids.includes(user_et.id)) {
            continue;
          }

          recipients[user_et.id] = user_et.devices().map(client_et => client_et.id);
        }
      }

      return recipients;
    });
  }

  sendGenericMessageToConversation(eventInfoEntity) {
    return this.sending_queue.push(() => {
      return this.create_recipients(eventInfoEntity.conversationId).then(recipients => {
        eventInfoEntity.updateOptions({recipients});
        return this._sendGenericMessage(eventInfoEntity);
      });
    });
  }

  _send_and_inject_generic_message(conversationEntity, genericMessage, syncTimestamp = true) {
    return Promise.resolve()
      .then(() => {
        if (conversationEntity.removed_from_conversation()) {
          throw new Error('Cannot send message to conversation you are not part of');
        }

        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const optimisticEvent = z.conversation.EventBuilder.buildMessageAdd(conversationEntity, currentTimestamp);
        return this.cryptography_repository.cryptographyMapper.mapGenericMessage(genericMessage, optimisticEvent);
      })
      .then(mappedEvent => {
        const {KNOCK: TYPE_KNOCK, EPHEMERAL: TYPE_EPHEMERAL} = z.cryptography.GENERIC_MESSAGE_TYPE;
        const isPing = message => message.content === TYPE_KNOCK;
        const isEphemeralPing = message => message.content === TYPE_EPHEMERAL && isPing(message.ephemeral);
        const shouldPlayPingAudio = isPing(genericMessage) || isEphemeralPing(genericMessage);
        if (shouldPlayPingAudio) {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.OUTGOING_PING);
        }

        return mappedEvent;
      })
      .then(mappedEvent => this.eventRepository.injectEvent(mappedEvent))
      .then(injectedEvent => {
        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationEntity.id);
        eventInfoEntity.setTimestamp(injectedEvent.time);
        return this.sendGenericMessageToConversation(eventInfoEntity).then(sentPayload => {
          return {event: injectedEvent, sentPayload};
        });
      })
      .then(({event, sentPayload}) => {
        this._trackContributed(conversationEntity, genericMessage);
        const backendIsoDate = syncTimestamp ? sentPayload.time : '';
        return this._updateMessageAsSent(conversationEntity, event, backendIsoDate).then(() => event);
      });
  }

  /**
   * Update message as sent in db and view.
   *
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {Object} eventJson - Event object
   * @param {string} isoDate - If defined it will update event timestamp
   * @returns {Promise} Resolves when sent status was updated
   */
  _updateMessageAsSent(conversationEntity, eventJson, isoDate) {
    return this.get_message_in_conversation_by_id(conversationEntity, eventJson.id)
      .then(messageEntity => {
        messageEntity.status(z.message.StatusType.SENT);

        const changes = {status: z.message.StatusType.SENT};
        if (isoDate) {
          changes.time = isoDate;

          const timestamp = new Date(isoDate).getTime();
          if (!_.isNaN(timestamp)) {
            messageEntity.timestamp(timestamp);
            conversationEntity.update_timestamp_server(timestamp, true);
            conversationEntity.update_timestamps(messageEntity);
          }
        }

        this.checkMessageTimer(messageEntity);
        if (z.event.EventTypeHandling.STORE.includes(messageEntity.type) || messageEntity.has_asset_image()) {
          return this.eventService.updateEvent(messageEntity.primary_key, changes);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          throw error;
        }
      });
  }

  /**
   * Send encrypted external message
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Event to be send
   * @returns {Promise} Resolves after sending the external message
   */
  _sendExternalGenericMessage(eventInfoEntity) {
    const {genericMessage, options} = eventInfoEntity;
    const messageType = eventInfoEntity.getType();
    this.logger.info(`Sending external message of type '${messageType}'`, genericMessage);

    return z.assets.AssetCrypto.encryptAesAsset(genericMessage.toArrayBuffer())
      .then(({cipherText, keyBytes, sha256}) => {
        const genericMessageExternal = new z.proto.GenericMessage(z.util.createRandomUuid());
        const externalMessage = new z.proto.External(new Uint8Array(keyBytes), new Uint8Array(sha256));
        genericMessageExternal.set(z.cryptography.GENERIC_MESSAGE_TYPE.EXTERNAL, externalMessage);

        return this.cryptography_repository
          .encryptGenericMessage(options.recipients, genericMessageExternal)
          .then(payload => {
            payload.data = z.util.arrayToBase64(cipherText);
            payload.native_push = options.nativePush;
            return this._sendEncryptedMessage(eventInfoEntity, payload);
          });
      })
      .catch(error => {
        this.logger.info('Failed sending external message', error);
        throw error;
      });
  }

  /**
   * Sends a generic message to a conversation.
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {Promise} Resolves when the message was sent
   */
  _sendGenericMessage(eventInfoEntity) {
    return this._grantOutgoingMessage(eventInfoEntity)
      .then(() => this._shouldSendAsExternal(eventInfoEntity))
      .then(sendAsExternal => {
        if (sendAsExternal) {
          return this._sendExternalGenericMessage(eventInfoEntity);
        }

        const {genericMessage, options} = eventInfoEntity;
        return this.cryptography_repository.encryptGenericMessage(options.recipients, genericMessage).then(payload => {
          payload.native_push = options.nativePush;
          return this._sendEncryptedMessage(eventInfoEntity, payload);
        });
      })
      .catch(error => {
        const isRequestTooLarge = error.code === z.error.BackendClientError.STATUS_CODE.REQUEST_TOO_LARGE;
        if (isRequestTooLarge) {
          return this._sendExternalGenericMessage(eventInfoEntity);
        }

        throw error;
      });
  }

  /**
   * Sends otr message to a conversation.
   *
   * @private
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about message to be sent
   * @param {Object} payload - Payload
   * @returns {Promise} Promise that resolves after sending the encrypted message
   */
  _sendEncryptedMessage(eventInfoEntity, payload) {
    const {conversationId, genericMessage, options} = eventInfoEntity;
    const messageId = genericMessage.message_id;
    const messageType = eventInfoEntity.getType();

    const logMessage = `Sending '${messageType}' message '${messageId}' to conversation '${conversationId}'`;
    this.logger.info(logMessage, payload);

    return this.conversation_service
      .post_encrypted_message(conversationId, payload, options.precondition)
      .then(response => {
        this.clientMismatchHandler.onClientMismatch(eventInfoEntity, response, payload);
        return response;
      })
      .catch(error => {
        const isUnknownClient = error.label === z.error.BackendClientError.LABEL.UNKNOWN_CLIENT;
        if (isUnknownClient) {
          return this.client_repository.removeLocalClient();
        }

        if (!error.missing) {
          throw error;
        }

        let updatedPayload;
        return this.clientMismatchHandler
          .onClientMismatch(eventInfoEntity, error, payload)
          .then(payloadWithMissingClients => {
            updatedPayload = payloadWithMissingClients;

            const userIds = Object.keys(error.missing);
            return this._grantOutgoingMessage(eventInfoEntity, userIds);
          })
          .then(() => {
            this.logger.info(`Updated '${messageType}' message for conversation '${conversationId}'`, updatedPayload);
            return this.conversation_service.post_encrypted_message(conversationId, updatedPayload, true);
          });
      });
  }

  _grantOutgoingMessage(eventInfoEntity, userIds) {
    const messageType = eventInfoEntity.getType();
    const allowedMessageTypes = ['cleared', 'confirmation', 'deleted', 'lastRead'];
    if (allowedMessageTypes.includes(messageType)) {
      return Promise.resolve();
    }

    const isCallingMessage = messageType === z.cryptography.GENERIC_MESSAGE_TYPE.CALLING;
    const consentType = isCallingMessage
      ? ConversationRepository.CONSENT_TYPE.OUTGOING_CALL
      : ConversationRepository.CONSENT_TYPE.MESSAGE;

    return this.grantMessage(eventInfoEntity, consentType, userIds);
  }

  grantMessage(eventInfoEntity, consentType, userIds) {
    return this.get_conversation_by_id(eventInfoEntity.conversationId).then(conversationEntity => {
      const verificationState = conversationEntity.verification_state();
      const conversationDegraded = verificationState === z.conversation.ConversationVerificationState.DEGRADED;

      if (!conversationDegraded) {
        return false;
      }

      return new Promise((resolve, reject) => {
        let sendAnyway = false;

        userIds = userIds || conversationEntity.getUsersWithUnverifiedClients().map(userEntity => userEntity.id);

        return this.user_repository
          .get_users_by_id(userIds)
          .then(userEntities => {
            let actionStringId;
            let messageStringId;
            let titleStringId;

            const hasMultipleUsers = userEntities.length > 1;
            if (hasMultipleUsers) {
              titleStringId = z.string.modalConversationNewDeviceHeadlineMany;
            } else {
              const [userEntity] = userEntities;

              if (userEntity) {
                titleStringId = userEntity.is_me
                  ? z.string.modalConversationNewDeviceHeadlineYou
                  : z.string.modalConversationNewDeviceHeadlineOne;
              } else {
                const conversationId = eventInfoEntity.conversationId;
                const type = eventInfoEntity.getType();

                const log = `Missing user IDs to grant '${type}' message in '${conversationId}' (${consentType})`;
                this.logger.error(log);

                const error = new Error('Failed to grant outgoing message');
                const customData = {
                  consentType,
                  messageType: type,
                  participants: conversationEntity.getNumberOfParticipants(false),
                  verificationState,
                };

                Raygun.send(error, customData);

                reject(error);
              }
            }

            const userNames = z.util.LocalizerUtil.joinNames(userEntities, z.string.Declension.NOMINATIVE);
            const titleSubstitutions = z.util.StringUtil.capitalizeFirstChar(userNames);

            switch (consentType) {
              case ConversationRepository.CONSENT_TYPE.INCOMING_CALL: {
                actionStringId = z.string.modalConversationNewDeviceIncomingCallAction;
                messageStringId = z.string.modalConversationNewDeviceIncomingCallMessage;
                break;
              }

              case ConversationRepository.CONSENT_TYPE.OUTGOING_CALL: {
                actionStringId = z.string.modalConversationNewDeviceOutgoingCallAction;
                messageStringId = z.string.modalConversationNewDeviceOutgoingCallMessage;
                break;
              }

              default: {
                actionStringId = z.string.modalConversationNewDeviceAction;
                messageStringId = z.string.modalConversationNewDeviceMessage;
                break;
              }
            }

            amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
              action: () => {
                sendAnyway = true;
                conversationEntity.verification_state(z.conversation.ConversationVerificationState.UNVERIFIED);

                resolve(true);
              },
              close: () => {
                if (!sendAnyway) {
                  const errorType = z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
                  reject(new z.error.ConversationError(errorType));
                }
              },
              text: {
                action: z.l10n.text(actionStringId),
                message: z.l10n.text(messageStringId),
                title: z.l10n.text(titleStringId, titleSubstitutions),
              },
            });
          })
          .catch(reject);
      });
    });
  }

  /**
   * Estimate whether message should be send as type external.
   *
   * @private
   * @param {z.conversation.EventInfoEntity} eventInfoEntity - Info about event
   * @returns {boolean} Is payload likely to be too big so that we switch to type external?
   */
  _shouldSendAsExternal(eventInfoEntity) {
    const {conversationId, genericMessage} = eventInfoEntity;

    return this.get_conversation_by_id(conversationId).then(conversationEntity => {
      const messageInBytes = new Uint8Array(genericMessage.toArrayBuffer()).length;
      const estimatedPayloadInBytes = conversationEntity.getNumberOfClients() * messageInBytes;

      return estimatedPayloadInBytes > ConversationRepository.CONFIG.EXTERNAL_MESSAGE_THRESHOLD;
    });
  }

  /**
   * Post images to a conversation.
   *
   * @param {Conversation} conversation_et - Conversation to post the images
   * @param {Array|FileList} images - Images
   * @returns {undefined} No return value
   */
  upload_images(conversation_et, images) {
    if (this._can_upload_assets_to_conversation(conversation_et)) {
      Array.from(images).forEach(image => this.send_image_asset(conversation_et, image));
    }
  }

  /**
   * Post files to a conversation.
   *
   * @param {Conversation} conversation_et - Conversation to post the files
   * @param {Array|FileList} files - files
   * @returns {undefined} No return value
   */
  upload_files(conversation_et, files) {
    if (this._can_upload_assets_to_conversation(conversation_et)) {
      Array.from(files).forEach(file => this.upload_file(conversation_et, file));
    }
  }

  /**
   * Post file to a conversation using v3
   *
   * @param {Conversation} conversation_et - Conversation to post the file
   * @param {Object} file - File object
   * @returns {Promise} Resolves when file was uploaded
   */
  upload_file(conversation_et, file) {
    let message_id;
    const upload_started = Date.now();

    return this.send_asset_metadata(conversation_et, file)
      .then(({id}) => {
        message_id = id;
        return this.sendAssetPreview(conversation_et, file, message_id);
      })
      .then(() => this.send_asset_remotedata(conversation_et, file, message_id))
      .then(() => {
        const upload_duration = (Date.now() - upload_started) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        this.logger.info(`Finished to upload asset for conversation'${conversation_et.id} in ${upload_duration}`);
      })
      .catch(error => {
        if (error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION) {
          throw error;
        }

        this.logger.error(`Failed to upload asset for conversation '${conversation_et.id}': ${error.message}`, error);
        return this.get_message_in_conversation_by_id(conversation_et, message_id).then(message_et => {
          this.send_asset_upload_failed(conversation_et, message_et.id);
          return this.update_message_as_upload_failed(message_et);
        });
      });
  }

  /**
   * Delete message for everyone.
   *
   * @param {Conversation} conversationEntity - Conversation to delete message from
   * @param {Message} messageEntity - Message to delete
   * @param {Array<string>|boolean} [precondition] - Optional level that backend checks for missing clients
   * @returns {Promise} Resolves when message was deleted
   */
  deleteMessageForEveryone(conversationEntity, messageEntity, precondition) {
    const conversationId = conversationEntity.id;
    const messageId = messageEntity.id;

    return Promise.resolve()
      .then(() => {
        if (!messageEntity.user().is_me && !messageEntity.ephemeral_expires()) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        const protoMessageDelete = new z.proto.MessageDelete(messageId);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.DELETED, protoMessageDelete);

        return this.sending_queue.push(() => {
          return this.create_recipients(conversationId, false, precondition).then(recipients => {
            const options = {precondition, recipients};
            const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, conversationId, options);
            this._sendGenericMessage(eventInfoEntity);
          });
        });
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, messageId, conversationId);
        return this._delete_message_by_id(conversationEntity, messageId);
      })
      .catch(error => {
        const isConversationNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (isConversationNotFound) {
          this.logger.warn(`Conversation '${conversationId}' not found. Deleting message for self user only.`);
          return this.deleteMessage(conversationEntity, messageEntity);
        }
        const message = `Failed to delete message '${messageId}' in conversation '${conversationId}' for everyone`;
        this.logger.info(message, error);
        throw error;
      });
  }

  /**
   * Delete message on your own clients.
   *
   * @param {Conversation} conversationEntity - Conversation to delete message from
   * @param {Message} messageEntity - Message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  deleteMessage(conversationEntity, messageEntity) {
    return Promise.resolve()
      .then(() => {
        const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
        const protoMessageHide = new z.proto.MessageHide(conversationEntity.id, messageEntity.id);
        genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.HIDDEN, protoMessageHide);

        const eventInfoEntity = new z.conversation.EventInfoEntity(genericMessage, this.self_conversation().id);
        return this.sendGenericMessageToConversation(eventInfoEntity);
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, messageEntity.id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, messageEntity.id);
      })
      .catch(error => {
        this.logger.info(
          `Failed to send delete message with id '${messageEntity.id}' for conversation '${conversationEntity.id}'`,
          error
        );
        throw error;
      });
  }

  /**
   * Can user upload assets to conversation.
   * @param {Conversation} conversation_et - Conversation to check
   * @returns {boolean} Can assets be uploaded
   */
  _can_upload_assets_to_conversation(conversation_et) {
    return !!conversation_et && !conversation_et.isRequest() && !conversation_et.removed_from_conversation();
  }

  /**
   * Count number of pending uploads
   * @returns {number} Number of pending uploads
   */
  get_number_of_pending_uploads() {
    return this.conversations().reduce((sum, conversationEntity) => {
      return sum + conversationEntity.get_number_of_pending_uploads();
    }, 0);
  }

  //##############################################################################
  // Event callbacks
  //##############################################################################

  /**
   * Listener for incoming events.
   *
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} [eventSource=z.event.EventRepository.SOURCE.STREAM] - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  onConversationEvent(eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
    const logMessage = `»» Conversation Event: '${eventJson.type}' (Source: ${eventSource})`;
    this.logger.info(logMessage, logObject);

    return this._pushToReceivingQueue(eventJson, eventSource);
  }

  _handleConversationEvent(eventJson, eventSource = z.event.EventRepository.SOURCE.STREAM) {
    if (!eventJson) {
      return Promise.reject(new Error('Conversation Repository Event Handling: Event missing'));
    }

    const {conversation, data: eventData, type} = eventJson;
    const conversationId = (eventData && eventData.conversationId) || conversation;
    this.logger.info(`Handling event '${type}' in conversation '${conversationId}' (Source: ${eventSource})`);

    const inSelfConversation = conversationId === this.self_conversation() && this.self_conversation().id;
    if (inSelfConversation) {
      const typesInSelfConversation = [
        z.event.Backend.CONVERSATION.MEMBER_UPDATE,
        z.event.Client.CONVERSATION.MESSAGE_HIDDEN,
      ];

      const isExpectedType = typesInSelfConversation.includes(type);
      if (!isExpectedType) {
        return Promise.reject(new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION));
      }
    }

    const isConversationCreate = type === z.event.Backend.CONVERSATION.CREATE;
    const onEventPromise = isConversationCreate ? Promise.resolve() : this.get_conversation_by_id(conversationId);
    let previouslyArchived;

    return onEventPromise
      .then(conversationEntity => {
        if (conversationEntity) {
          // Check if conversation was archived
          previouslyArchived = conversationEntity.is_archived();

          const isBackendTimestamp = eventSource !== z.event.EventRepository.SOURCE.INJECTED;
          conversationEntity.update_timestamp_server(eventJson.server_time || eventJson.time, isBackendTimestamp);
        }

        return conversationEntity;
      })
      .then(conversationEntity => this._checkConversationParticipants(conversationEntity, eventJson, eventSource))
      .then(conversationEntity => this._triggerFeatureEventHandlers(conversationEntity, eventJson, eventSource))
      .then(conversationEntity => this._reactToConversationEvent(conversationEntity, eventJson, eventSource))
      .then((entityObject = {}) => this._handleConversationNotification(entityObject, eventSource, previouslyArchived))
      .catch(error => {
        const isMessageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isMessageNotFound) {
          throw error;
        }
      });
  }

  /**
   * Check that sender of received event is a known conversation participant.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when the participant list has been checked
   */
  _checkConversationParticipants(conversationEntity, eventJson, eventSource) {
    // We ignore injected events
    const isInjectedEvent = eventSource === z.event.EventRepository.SOURCE.INJECTED;
    if (isInjectedEvent || !conversationEntity) {
      return conversationEntity;
    }

    const {from: sender, id, type, time} = eventJson;

    if (sender) {
      const allParticipantIds = conversationEntity.participating_user_ids().concat(this.selfUser().id);
      const isFromUnknownUser = !allParticipantIds.includes(sender);

      if (isFromUnknownUser) {
        const leavingEventTypes = [
          z.event.Backend.CONVERSATION.MEMBER_LEAVE,
          z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
        ];
        const isLeaveEvent = leavingEventTypes.includes(eventJson.type);
        if (isLeaveEvent) {
          const isFromLeavingUser = eventJson.data.user_ids.includes(sender);
          if (isFromLeavingUser) {
            // we ignore leave events that are sent by the user actually leaving
            return conversationEntity;
          }
        }

        const message = `Received '${type}' event '${id}' from user '${sender}' unknown in '${conversationEntity.id}'`;
        this.logger.warn(message, eventJson);

        const timestamp = new Date(time).getTime() - 1;
        return this.addMissingMember(conversationEntity.id, [sender], timestamp).then(() => conversationEntity);
      }
    }

    return conversationEntity;
  }

  /**
   * Triggers the methods associated with a specific event.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise<any>} Resolves when the event has been treated
   */
  _reactToConversationEvent(conversationEntity, eventJson, eventSource) {
    switch (eventJson.type) {
      case z.event.Backend.CONVERSATION.CREATE:
        return this._onCreate(eventJson, eventSource);

      case z.event.Backend.CONVERSATION.MEMBER_JOIN:
        return this._onMemberJoin(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MEMBER_LEAVE:
      case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE:
        return this._onMemberLeave(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MEMBER_UPDATE:
        return this._onMemberUpdate(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.RENAME:
        return this._onRename(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.ASSET_ADD:
        return this._onAssetAdd(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.CONFIRMATION:
        return this._on_confirmation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.GROUP_CREATION:
        return this._onGroupCreation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.MESSAGE_DELETE:
        return this._onMessageDeleted(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.MESSAGE_HIDDEN:
        return this._onMessageHidden(eventJson);

      case z.event.Client.CONVERSATION.ONE2ONE_CREATION:
        return this._on1to1Creation(conversationEntity, eventJson);

      case z.event.Client.CONVERSATION.REACTION:
        return this._onReaction(conversationEntity, eventJson);

      case z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE:
      case z.event.Client.CONVERSATION.DELETE_EVERYWHERE:
      case z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:
      case z.event.Client.CONVERSATION.KNOCK:
      case z.event.Client.CONVERSATION.LOCATION:
      case z.event.Client.CONVERSATION.MESSAGE_ADD:
      case z.event.Client.CONVERSATION.MISSED_MESSAGES:
      case z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT:
      case z.event.Client.CONVERSATION.VERIFICATION:
      case z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE:
      case z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE:
        return this._addEventToConversation(conversationEntity, eventJson);
    }
  }

  /**
   * Calls the feature specific event handler on the current event being handled.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation targeted by the event
   * @param {Object} eventJson - JSON data of the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when all the handlers have done their job
   */
  _triggerFeatureEventHandlers(conversationEntity, eventJson, eventSource) {
    const conversationEventHandlers = [this.ephemeralHandler, this.stateHandler];
    const handlePromises = conversationEventHandlers.map(handler =>
      handler.handleConversationEvent(conversationEntity, eventJson, eventSource)
    );
    return Promise.all(handlePromises).then(() => conversationEntity);
  }

  /**
   * Handles conversation update and notification message.
   *
   * @private
   * @param {Object} entityObject - Object containing the conversation and the message that are targeted by the event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @param {boolean} previouslyArchived - true if the previous state of the conversation was archived
   * @returns {Promise} Resolves when the conversation was updated
   */
  _handleConversationNotification(entityObject = {}, eventSource, previouslyArchived) {
    const {conversationEntity, messageEntity} = entityObject;

    if (conversationEntity) {
      const eventFromWebSocket = eventSource === z.event.EventRepository.SOURCE.WEB_SOCKET;
      const eventFromStream = eventSource === z.event.EventRepository.SOURCE.STREAM;

      if (messageEntity) {
        const isRemoteEvent = eventFromStream || eventFromWebSocket;

        if (isRemoteEvent) {
          this.sendConfirmationStatus(conversationEntity, messageEntity);
        }

        if (!eventFromStream) {
          amplify.publish(z.event.WebApp.NOTIFICATION.NOTIFY, messageEntity, undefined, conversationEntity);
        }

        if (conversationEntity.is_cleared()) {
          conversationEntity.cleared_timestamp(0);
        }
      }

      // Check if event needs to be un-archived
      if (previouslyArchived) {
        // Add to check for un-archiving at the end of stream handling
        if (eventFromStream) {
          return this.conversationsWithNewEvents.set(conversationEntity.id, conversationEntity);
        }

        if (eventFromWebSocket && conversationEntity.shouldUnarchive()) {
          return this.unarchiveConversation(conversationEntity, false, 'event from WebSocket');
        }
      }
    }
  }

  /**
   * Push to receiving queue.
   * @param {Object} eventJson - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  _pushToReceivingQueue(eventJson, source) {
    this.receiving_queue
      .push(() => this._handleConversationEvent(eventJson, source))
      .then(() => {
        if (this.init_promise) {
          const eventFromStream = source === z.event.EventRepository.SOURCE.STREAM;
          if (eventFromStream) {
            this.init_handled = this.init_handled + 1;
            if (this.init_handled % 5 === 0 || this.init_handled < 5) {
              const content = {
                handled: this.init_handled,
                total: this.init_total,
              };
              const progress = (this.init_handled / this.init_total) * 20 + 75;

              amplify.publish(z.event.WebApp.APP.UPDATE_PROGRESS, progress, z.string.initEvents, content);
            }
          }

          if (!this.receiving_queue.getLength() || !eventFromStream) {
            this.init_promise.resolve_fn();
            this.init_promise = undefined;
          }
        }
      })
      .catch(error => {
        if (this.init_promise) {
          this.init_promise.reject_fn(error);
          this.init_promise = undefined;
        } else {
          throw error;
        }
      });
  }

  /**
   * Add missed events message to conversations.
   * @returns {undefined} No return value
   */
  on_missed_events() {
    this.filtered_conversations()
      .filter(conversation_et => !conversation_et.removed_from_conversation())
      .forEach(conversation_et => {
        const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
        const missed_event = z.conversation.EventBuilder.buildMissed(conversation_et, currentTimestamp);
        this.eventRepository.injectEvent(missed_event);
      });
  }

  _on1to1Creation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity)
      .then(messageEntity => this._updateMessageUserEntities(messageEntity))
      .then(messageEntity => {
        const userEntity = messageEntity.otherUser();
        const isOutgoingRequest = userEntity && userEntity.isOutgoingRequest();
        if (isOutgoingRequest) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_REQUEST;
        }

        conversationEntity.add_message(messageEntity);
        return {conversationEntity};
      });
  }

  /**
   * An asset was uploaded.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation to add the event to
   * @param {Object} event_json - JSON data of 'conversation.asset-upload-complete' event
   * @returns {Promise} Resolves when the event was handled
   */
  _on_asset_upload_complete(conversation_et, event_json) {
    return this.get_message_in_conversation_by_id(conversation_et, event_json.id)
      .then(message_et => this.update_message_as_upload_complete(conversation_et, message_et, event_json))
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          throw error;
        }

        this.logger.error(`Upload complete: Could not find message with id '${event_json.id}'`, event_json);
      });
  }

  /**
   * Received confirmation of message.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation entity that a message was reacted upon in
   * @param {Object} event_json - JSON data of 'conversation.confirmation' event
   * @returns {Promise} Resolves when the event was handled
   */
  _on_confirmation(conversation_et, event_json) {
    const event_data = event_json.data;

    return this.get_message_in_conversation_by_id(conversation_et, event_data.message_id)
      .then(message_et => {
        const was_updated = message_et.update_status(event_data.status);

        if (was_updated) {
          const changes = {status: message_et.status()};
          return this.eventService.updateEvent(message_et.primary_key, changes);
        }
      })
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND) {
          this.logger.info(
            `Failed to handle status update of a message in conversation '${conversation_et.id}'`,
            error
          );
          throw error;
        }
      });
  }

  /**
   * A conversation was created.
   *
   * @private
   * @param {Object} eventJson - JSON data of 'conversation.create' event
   * @param {z.event.EventRepository.SOURCE} eventSource - Source of event
   * @returns {Promise} Resolves when the event was handled
   */
  _onCreate(eventJson, eventSource) {
    const {conversation: conversationId, data: eventData, time} = eventJson;
    const eventTimestamp = new Date(time).getTime();
    const initialTimestamp = _.isNaN(eventTimestamp) ? this.getLatestEventTimestamp(true) : eventTimestamp;

    return this.find_conversation_by_id(conversationId)
      .then(conversationEntity => {
        if (conversationEntity) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES);
        }
      })
      .catch(error => {
        const isConversationNotFound = error.type === z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND;
        if (isConversationNotFound) {
          return this.mapConversations(eventData, initialTimestamp);
        }

        throw error;
      })
      .then(conversationEntity => this.updateParticipatingUserEntities(conversationEntity))
      .then(conversationEntity => this.save_conversation(conversationEntity))
      .then(conversationEntity => {
        if (conversationEntity) {
          if (conversationEntity.participating_user_ids().length) {
            this._addCreationMessage(conversationEntity, false, initialTimestamp, eventSource);
          }

          this.verification_state_handler.onConversationCreate(conversationEntity);
          return {conversationEntity};
        }
      })
      .catch(error => {
        const isNoChanges = error.type === z.error.ConversationError.TYPE.NO_CHANGES;
        if (!isNoChanges) {
          throw error;
        }
      });
  }

  _onGroupCreation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity)
      .then(messageEntity => {
        const creatorId = conversationEntity.creator;
        const createdByParticipant = !!conversationEntity.participating_user_ids().find(userId => userId === creatorId);
        const createdBySelfUser = this.selfUser().id === creatorId && !conversationEntity.removed_from_conversation();

        const creatorIsParticipant = createdByParticipant || createdBySelfUser;
        if (!creatorIsParticipant) {
          messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_RESUME;
        }

        return this._updateMessageUserEntities(messageEntity);
      })
      .then(messageEntity => {
        if (conversationEntity && messageEntity) {
          conversationEntity.add_message(messageEntity);
        }

        return {conversationEntity, messageEntity};
      });
  }

  /**
   * User were added to a group conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add users to
   * @param {Object} eventJson - JSON data of 'conversation.member-join' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberJoin(conversationEntity, eventJson) {
    // Ignore if we join a 1to1 conversation (accept a connection request)
    const connectionEntity = this.connectionRepository.getConnectionByConversationId(conversationEntity.id);
    const isPendingConnection = connectionEntity && connectionEntity.isIncomingRequest();
    if (isPendingConnection) {
      return Promise.resolve();
    }

    const eventData = eventJson.data;

    eventData.user_ids.forEach(userId => {
      const isSelfUser = userId === this.selfUser().id;
      const isParticipatingUser = conversationEntity.participating_user_ids().includes(userId);
      if (!isSelfUser && !isParticipatingUser) {
        conversationEntity.participating_user_ids.push(userId);
      }
    });

    // Self user joins again
    const selfUserRejoins = eventData.user_ids.includes(this.selfUser().id);
    if (selfUserRejoins) {
      conversationEntity.status(z.conversation.ConversationStatus.CURRENT_MEMBER);
    }

    const updateSequence = selfUserRejoins ? this.updateConversationFromBackend(conversationEntity) : Promise.resolve();

    return updateSequence
      .then(() => this.updateParticipatingUserEntities(conversationEntity, false, true))
      .then(() => this._addEventToConversation(conversationEntity, eventJson))
      .then(({messageEntity}) => {
        this.verification_state_handler.onMemberJoined(conversationEntity, eventData.user_ids);
        return {conversationEntity, messageEntity};
      });
  }

  /**
   * Members of a group conversation were removed or left.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to remove users from
   * @param {Object} eventJson - JSON data of 'conversation.member-leave' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberLeave(conversationEntity, eventJson) {
    const {data: eventData, from} = eventJson;
    const isFromSelf = from === this.selfUser().id;
    const removesSelfUser = eventData.user_ids.includes(this.selfUser().id);
    const selfLeavingClearedConversation = isFromSelf && removesSelfUser && conversationEntity.is_cleared();

    if (removesSelfUser) {
      conversationEntity.status(z.conversation.ConversationStatus.PAST_MEMBER);

      if (conversationEntity.call()) {
        const reason = z.calling.enum.TERMINATION_REASON.MEMBER_LEAVE;
        amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, conversationEntity.id, reason);
      }

      if (this.selfUser().isTemporaryGuest()) {
        eventJson.from = this.selfUser().id;
      }
    }

    if (!selfLeavingClearedConversation) {
      return this._addEventToConversation(conversationEntity, eventJson)
        .then(({messageEntity}) => {
          messageEntity
            .userEntities()
            .filter(userEntity => !userEntity.is_me)
            .forEach(userEntity => {
              conversationEntity.participating_user_ids.remove(userEntity.id);

              if (userEntity.isTemporaryGuest()) {
                userEntity.clearExpirationTimeout();
              }

              if (conversationEntity.call()) {
                amplify.publish(z.event.WebApp.CALL.STATE.REMOVE_PARTICIPANT, conversationEntity.id, userEntity.id);
              }
            });

          return this.updateParticipatingUserEntities(conversationEntity).then(() => messageEntity);
        })
        .then(messageEntity => {
          this.verification_state_handler.onMemberLeft(conversationEntity);

          if (isFromSelf && conversationEntity.removed_from_conversation()) {
            this.archiveConversation(conversationEntity);
          }

          return {conversationEntity, messageEntity};
        });
    }
  }

  /**
   * Membership properties for a conversation were updated.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that will be updated
   * @param {Object} eventJson - JSON data of 'conversation.member-update' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onMemberUpdate(conversationEntity, eventJson) {
    const {conversation: conversationId, data: eventData, from} = eventJson;

    const isBackendEvent = eventData.otr_archived_ref || eventData.otr_muted_ref;
    const inSelfConversation = !this.self_conversation() || conversationId === this.self_conversation().id;
    if (!inSelfConversation && conversationId && !isBackendEvent) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION);
    }

    const isFromSelf = !this.selfUser() || from === this.selfUser().id;
    if (!isFromSelf) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
    }

    const isActiveConversation = this.is_active_conversation(conversationEntity);
    const nextConversationEt = isActiveConversation ? this.get_next_conversation(conversationEntity) : undefined;
    const previouslyArchived = conversationEntity.is_archived();

    this.conversationMapper.updateSelfStatus(conversationEntity, eventData);

    const wasUnarchived = previouslyArchived && !conversationEntity.is_archived();
    if (wasUnarchived) {
      return this._fetch_users_and_events(conversationEntity);
    }

    if (conversationEntity.is_cleared()) {
      this._clear_conversation(conversationEntity, conversationEntity.cleared_timestamp());
    }

    if (!conversationEntity.showNotificationsEverything()) {
      const hasIncomingCall = conversationEntity.call() && conversationEntity.call().isIncoming();
      if (hasIncomingCall) {
        amplify.publish(z.event.WebApp.CALL.STATE.REJECT, conversationEntity.id, false);
      }
    }

    if (isActiveConversation && (conversationEntity.is_archived() || conversationEntity.is_cleared())) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextConversationEt);
    }
  }

  /**
   * An asset received in a conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add the event to
   * @param {Object} event - JSON data of 'conversation.asset-add'
   * @returns {Promise} Resolves when the event was handled
   */
  _onAssetAdd(conversationEntity, event) {
    const fromSelf = event.from === this.selfUser().id;

    const isRemoteFailure = !fromSelf && event.data.status === z.assets.AssetTransferState.UPLOAD_FAILED;
    const isLocalCancel = fromSelf && event.data.reason === z.assets.AssetUploadFailedReason.CANCELLED;

    if (isRemoteFailure || isLocalCancel) {
      return conversationEntity.remove_message_by_id(event.id);
    }

    return this._addEventToConversation(conversationEntity, event).then(({messageEntity}) => {
      const firstAsset = messageEntity.get_first_asset();
      if (firstAsset.is_image() || firstAsset.status() === z.assets.AssetTransferState.UPLOADED) {
        return {conversationEntity, messageEntity};
      }
    });
  }

  /**
   * A hide message received in a conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation to add the event to
   * @param {Object} eventJson - JSON data of 'conversation.message-delete'
   * @returns {Promise} Resolves when the event was handled
   */
  _onMessageDeleted(conversationEntity, eventJson) {
    const {data: eventData, from, id: eventId, time} = eventJson;

    return this.get_message_in_conversation_by_id(conversationEntity, eventData.message_id)
      .then(deletedMessageEntity => {
        if (deletedMessageEntity.ephemeral_expires()) {
          return;
        }

        const isSameSender = from === deletedMessageEntity.from;
        if (!isSameSender) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        const isFromSelf = from === this.selfUser().id;
        if (!isFromSelf) {
          return this._addDeleteMessage(conversationEntity.id, eventId, time, deletedMessageEntity);
        }
      })
      .then(() => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, eventData.message_id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, eventData.message_id);
      })
      .catch(error => {
        const isNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isNotFound) {
          this.logger.info(`Failed to delete message for conversation '${conversationEntity.id}'`, error);
          throw error;
        }
      });
  }

  /**
   * A hide message received in a conversation.
   *
   * @private
   * @param {Object} eventJson - JSON data of 'conversation.message-hidden'
   * @returns {Promise} Resolves when the event was handled
   */
  _onMessageHidden(eventJson) {
    const {conversation: conversationId, data: eventData, from} = eventJson;

    return Promise.resolve()
      .then(() => {
        const inSelfConversation = !this.self_conversation() || conversationId === this.self_conversation().id;
        if (!inSelfConversation) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CONVERSATION);
        }

        const isFromSelf = !this.selfUser() || from === this.selfUser().id;
        if (!isFromSelf) {
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_USER);
        }

        return this.get_conversation_by_id(eventData.conversation_id);
      })
      .then(conversationEntity => {
        amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, eventData.message_id, conversationEntity.id);
        return this._delete_message_by_id(conversationEntity, eventData.message_id);
      })
      .catch(error => {
        this.logger.info(
          `Failed to delete message '${eventData.message_id}' for conversation '${eventData.conversation_id}'`,
          error
        );
        throw error;
      });
  }

  /**
   * Someone reacted to a message.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that a message was reacted upon in
   * @param {Object} eventJson - JSON data of 'conversation.reaction' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onReaction(conversationEntity, eventJson) {
    const conversationId = conversationEntity.id;
    const eventData = eventJson.data;
    const messageId = eventData.message_id;

    return this.get_message_in_conversation_by_id(conversationEntity, messageId)
      .then(messageEntity => {
        if (!messageEntity || !messageEntity.is_content()) {
          const type = messageEntity ? messageEntity.type : 'unknown';

          const log = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationId}'`;
          this.logger.error(log, messageEntity);
          throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_TYPE);
        }

        const changes = messageEntity.update_reactions(eventJson);
        if (changes) {
          const log = `Updating reactions of message '${messageId}' in conversation '${conversationId}'`;
          this.logger.debug(log, {changes, event: eventJson});

          return this._updateMessageUserEntities(messageEntity).then(changedMessageEntity => {
            this.eventService.updateEventSequentially(changedMessageEntity.primary_key, changes);
            return this._prepareReactionNotification(conversationEntity, changedMessageEntity, eventJson);
          });
        }
      })
      .catch(error => {
        const isNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (!isNotFound) {
          const log = `Failed to handle reaction to message '${messageId}' in conversation '${conversationId}'`;
          this.logger.error(log, {error, event: eventJson});
          throw error;
        }
      });
  }

  /**
   * A conversation was renamed.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity that will be renamed
   * @param {Object} eventJson - JSON data of 'conversation.rename' event
   * @returns {Promise} Resolves when the event was handled
   */
  _onRename(conversationEntity, eventJson) {
    return this._addEventToConversation(conversationEntity, eventJson).then(({messageEntity}) => {
      this.conversationMapper.updateProperties(conversationEntity, eventJson.data);
      return {conversationEntity, messageEntity};
    });
  }

  handleMessageExpiration(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, messageEntity);
    const shouldDeleteMessage = !messageEntity.user().is_me || messageEntity.is_ping();
    if (shouldDeleteMessage) {
      this.get_conversation_by_id(messageEntity.conversation_id).then(conversationEntity => {
        const isPingFromSelf = messageEntity.user().is_me && messageEntity.is_ping();
        const deleteForSelf = isPingFromSelf || conversationEntity.removed_from_conversation();
        if (deleteForSelf) {
          return this.deleteMessage(conversationEntity, messageEntity);
        }

        const userIds = conversationEntity.isGroup() ? [this.selfUser().id, messageEntity.from] : undefined;
        this.deleteMessageForEveryone(conversationEntity, messageEntity, userIds);
      });
    }
  }

  //##############################################################################
  // Private
  //##############################################################################

  /**
   * Convert a JSON event into an entity and add it to a given conversation.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity the event will be added to
   * @param {Object} eventJson - Event data
   * @returns {Promise} Promise that resolves with the message entity for the event
   */
  _addEventToConversation(conversationEntity, eventJson) {
    return this.event_mapper
      .mapJsonEvent(eventJson, conversationEntity, true)
      .then(messageEntity => this._updateMessageUserEntities(messageEntity))
      .then(messageEntity => this.ephemeralHandler.validateMessage(messageEntity))
      .then(messageEntity => {
        if (conversationEntity && messageEntity) {
          const replacedEntity = conversationEntity.add_message(messageEntity, true);
          if (replacedEntity) {
            const messages = conversationEntity.messages_unordered();

            const updatedMessages = messages.map(message => {
              const hasEditedQuote =
                message.quote && message.quote() && message.quote().messageId === replacedEntity.id;
              if (hasEditedQuote) {
                const {error, userId} = message.quote();
                const newQuote = new z.message.QuoteEntity({error, messageId: messageEntity.id, userId});
                message.quote(newQuote);
              }
              return message;
            });

            conversationEntity.messages_unordered(updatedMessages);
            amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, replacedEntity.id, messageEntity);
          }
        }
        return {conversationEntity, messageEntity};
      });
  }

  /**
   * Convert multiple JSON events into entities and add them to a given conversation.
   *
   * @private
   * @param {Array} events - Event data
   * @param {Conversation} conversationEntity - Conversation entity the events will be added to
   * @param {boolean} [prepend=true] - Should existing messages be prepended
   * @returns {Promise} Resolves with an array of mapped messages
   */
  _addEventsToConversation(events, conversationEntity, prepend = true) {
    return this.event_mapper
      .mapJsonEvents(events, conversationEntity, true)
      .then(messageEntities => this._updateMessagesUserEntities(messageEntities))
      .then(messageEntities => this.ephemeralHandler.validateMessages(messageEntities))
      .then(messageEntities => {
        if (prepend && conversationEntity.messages().length) {
          conversationEntity.prepend_messages(messageEntities);
        } else {
          conversationEntity.add_messages(messageEntities);
        }
        return messageEntities;
      });
  }

  /**
   * Fetch all unread events and users of a conversation.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation fetch events and users for
   * @returns {undefined} No return value
   */
  _fetch_users_and_events(conversation_et) {
    if (!conversation_et.is_loaded() && !conversation_et.is_pending()) {
      this.updateParticipatingUserEntities(conversation_et);
      this._get_unread_events(conversation_et);
    }
  }

  /**
   * Forward the reaction event to the Notification repository for browser and audio notifications.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation that event was received in
   * @param {Message} messageEntity - Message that has been reacted upon
   * @param {Object} eventJson -] JSON data of received reaction event
   * @returns {Promise} Resolves when the notification was prepared
   */
  _prepareReactionNotification(conversationEntity, messageEntity, eventJson) {
    const {data: event_data, from} = eventJson;

    const messageFromSelf = messageEntity.from === this.selfUser().id;
    if (messageFromSelf && event_data.reaction) {
      return this.user_repository.get_user_by_id(from).then(userEntity => {
        const reactionMessageEntity = new z.entity.Message(messageEntity.id, z.message.SuperType.REACTION);
        reactionMessageEntity.user(userEntity);
        reactionMessageEntity.reaction = event_data.reaction;
        return {conversationEntity, messageEntity: reactionMessageEntity};
      });
    }

    return Promise.resolve({conversationEntity});
  }

  _updateMessagesUserEntities(messageEntities) {
    return Promise.all(messageEntities.map(messageEntity => this._updateMessageUserEntities(messageEntity)));
  }

  /**
   * Updates the user entities that are part of a message.
   *
   * @private
   * @param {Message} messageEntity - Message to be updated
   * @returns {Promise} Resolves when users have been update
   */
  _updateMessageUserEntities(messageEntity) {
    return this.user_repository.get_user_by_id(messageEntity.from).then(userEntity => {
      messageEntity.user(userEntity);

      if (messageEntity.is_member() || messageEntity.userEntities) {
        return this.user_repository.get_users_by_id(messageEntity.userIds()).then(userEntities => {
          userEntities.sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
          messageEntity.userEntities(userEntities);
          return messageEntity;
        });
      }

      if (messageEntity.is_content()) {
        const userIds = Object.keys(messageEntity.reactions());

        messageEntity.reactions_user_ets.removeAll();
        if (userIds.length) {
          return this.user_repository.get_users_by_id(userIds).then(userEntities => {
            messageEntity.reactions_user_ets(userEntities);
            return messageEntity;
          });
        }

        if (messageEntity.has_asset_text()) {
          messageEntity.assets().forEach(assetEntity => {
            if (assetEntity.is_text()) {
              assetEntity.theme_color = messageEntity.user().accent_color();
            }
          });
        }
      }

      return messageEntity;
    });
  }

  /**
   * Cancel asset upload.
   * @param {Message} message_et - Message on which the cancel was initiated
   * @returns {undefined} No return value
   */
  cancel_asset_upload(message_et) {
    this.send_asset_upload_failed(
      this.active_conversation(),
      message_et.id,
      z.assets.AssetUploadFailedReason.CANCELLED
    );
  }

  /**
   * Delete message from UI and database. Primary key is used to delete message in database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {Message} message_et - Message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  _delete_message(conversation_et, message_et) {
    conversation_et.remove_message_by_id(message_et.id);
    return this.eventService.deleteEventByKey(message_et.primary_key);
  }

  /**
   * Delete message from UI and database. Primary key is used to delete message in database.
   *
   * @private
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {string} message_id - ID of message to delete
   * @returns {Promise} Resolves when message was deleted
   */
  _delete_message_by_id(conversation_et, message_id) {
    conversation_et.remove_message_by_id(message_id);
    return this.eventService.deleteEvent(conversation_et.id, message_id);
  }

  /**
   * Delete messages from UI and database.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation that contains the message
   * @param {number} [timestamp] - Timestamp as upper bound which messages to remove
   * @returns {undefined} No return value
   */
  _deleteMessages(conversationEntity, timestamp) {
    conversationEntity.remove_messages(timestamp);
    conversationEntity.hasCreationMessage = false;

    const iso_date = timestamp ? new Date(timestamp).toISOString() : undefined;
    this.eventService.deleteEvents(conversationEntity.id, iso_date);
  }

  /**
   * Add delete message to conversation.
   *
   * @private
   * @param {string} conversationId - ID of conversation
   * @param {string} messageId - ID of message
   * @param {string} time - ISO 8601 formatted time string
   * @param {Message} messageEntity - Message to delete
   * @returns {undefined} No return value
   */
  _addDeleteMessage(conversationId, messageId, time, messageEntity) {
    const deleteEvent = z.conversation.EventBuilder.buildDelete(conversationId, messageId, time, messageEntity);
    this.eventRepository.injectEvent(deleteEvent);
  }

  //##############################################################################
  // Message updates
  //##############################################################################

  /**
   * Update asset in UI and DB as failed
   * @param {Message} message_et - Message to update
   * @param {string} [reason=z.assets.AssetTransferState.UPLOAD_FAILED] - Failure reason
   * @returns {Promise} Resolve when message was updated
   */
  update_message_as_upload_failed(message_et, reason = z.assets.AssetTransferState.UPLOAD_FAILED) {
    if (message_et) {
      if (!message_et.is_content()) {
        throw new Error(`Tried to update wrong message type as upload failed '${message_et.super_type}'`);
      }

      const asset_et = message_et.get_first_asset();
      if (asset_et) {
        const is_proper_asset = asset_et.is_audio() || asset_et.is_file() || asset_et.is_video();
        if (!is_proper_asset) {
          throw new Error(`Tried to update message with wrong asset type as upload failed '${asset_et.type}'`);
        }

        asset_et.status(reason);
        asset_et.upload_failed_reason(z.assets.AssetUploadFailedReason.FAILED);
      }

      return this.eventService.updateEventAsUploadFailed(message_et.primary_key, reason);
    }
  }

  /**
   * Update asset in UI and DB as completed.
   *
   * @param {Conversation} conversation_et - Conversation that contains the message
   * @param {Message} message_et - Message to update
   * @param {Object} event_json - Uploaded asset event information
   * @returns {Promise} Resolve when message was updated
   */
  update_message_as_upload_complete(conversation_et, message_et, event_json) {
    const {id, key, otr_key, sha256, token} = event_json.data;
    const asset_et = message_et.get_first_asset();

    const resource = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token)
      : z.assets.AssetRemoteData.v2(conversation_et.id, id, otr_key, sha256);

    asset_et.original_resource(resource);
    asset_et.status(z.assets.AssetTransferState.UPLOADED);
    message_et.status(z.message.StatusType.SENT);

    return this.eventService.updateEventAsUploadSucceeded(message_et.primary_key, event_json);
  }

  //##############################################################################
  // Tracking helpers
  //##############################################################################

  /**
   * Track generic messages for media actions.
   *
   * @private
   * @param {Conversation} conversationEntity - Conversation entity
   * @param {z.proto.GenericMessage} genericMessage - Protobuf message
   * @param {z.calling.entities.CallMessageEntity} callMessageEntity - Optional call message
   * @returns {undefined} No return value
   */
  _trackContributed(conversationEntity, genericMessage, callMessageEntity) {
    let messageTimer;
    const isEphemeral = genericMessage.content === z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL;

    if (isEphemeral) {
      genericMessage = genericMessage.ephemeral;
      messageTimer = genericMessage.expire_after_millis / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
    }

    const messageContentType = genericMessage.content;
    let actionType;
    let numberOfMentions;
    switch (messageContentType) {
      case 'asset': {
        const protoAsset = genericMessage.asset;
        if (protoAsset.original) {
          actionType = protoAsset.original.image ? 'photo' : 'file';
        }
        break;
      }

      case 'calling': {
        const properties = callMessageEntity.properties;
        const isVideoCall = properties.videosend === z.calling.enum.PROPERTY_STATE.TRUE;
        actionType = isVideoCall ? 'video_call' : 'audio_call';
        break;
      }

      case 'image': {
        actionType = 'photo';
        break;
      }

      case 'knock': {
        actionType = 'ping';
        break;
      }

      case 'text': {
        const protoText = genericMessage.text;
        if (!protoText.link_preview.length) {
          actionType = 'text';
          numberOfMentions = protoText.mentions.length;
        }
        break;
      }

      default:
        break;
    }

    if (actionType) {
      const attributes = {
        action: actionType,
        conversation_type: z.tracking.helpers.getConversationType(conversationEntity),
        ephemeral_time: isEphemeral ? messageTimer : undefined,
        is_ephemeral: isEphemeral,
        is_global_ephemeral: !!conversationEntity.globalMessageTimer(),
        mention_num: numberOfMentions,
        with_service: conversationEntity.hasService(),
      };

      const isTeamConversation = !!conversationEntity.team_id;
      if (isTeamConversation) {
        Object.assign(attributes, z.tracking.helpers.getGuestAttributes(conversationEntity));
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONTRIBUTED, attributes);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Conversation service for all conversation calls to the backend REST API.
z.conversation.ConversationService = class ConversationService {
  static get CONFIG() {
    return {
      URL_CONVERSATIONS: '/conversations',
    };
  }

  /**
   * Construct a new Conversation Service.
   * @param {BackendClient} backendClient - Client for the API calls
   * @param {EventService} eventService - Service that handles events
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, eventService, storageService) {
    this.backendClient = backendClient;
    this.eventService = eventService;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.conversation.ConversationService', z.config.LOGGER.OPTIONS);

    this.CONVERSATION_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.CONVERSATIONS;
    this.EVENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  //##############################################################################
  // Create conversations
  //##############################################################################

  /**
   * Create a group conversation.
   *
   * @note Do not include yourself as the requestor
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createGroupConversation
   *
   * @param {Object} payload - Payload object for group creation
   * @returns {Promise} Resolves when the conversation was created
   */
  postConversations(payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: ConversationService.CONFIG.URL_CONVERSATIONS,
    });
  }

  //##############################################################################
  // Get conversations
  //##############################################################################

  /**
   * Retrieves paged meta information about the conversations of a user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversations
   *
   * @param {number} [limit=100] - Number of results to return (default 100, max 500)
   * @param {string} conversation_id - Conversation ID to start from
   * @returns {Promise} Resolves with the conversation information
   */
  getConversations(limit = 100, conversation_id) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: conversation_id,
      },
      type: 'GET',
      url: ConversationService.CONFIG.URL_CONVERSATIONS,
    });
  }

  /**
   * Retrieves all the conversations of a user.
   * @param {number} [limit=500] - Number of results to return (default 500, max 500)
   * @returns {Promise} Resolves with the conversation information
   */
  getAllConversations(limit = 500) {
    let allConversations = [];

    const _getConversations = conversationId => {
      return this.getConversations(limit, conversationId).then(({conversations, has_more: hasMore}) => {
        if (conversations.length) {
          allConversations = allConversations.concat(conversations);
        }

        return hasMore ? _getConversations(conversations.pop().id) : allConversations;
      });
    };

    return _getConversations();
  }

  /**
   * Get a conversation by ID.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversation
   *
   * @param {string} conversation_id - ID of conversation to get
   * @returns {Promise} Resolves with the server response
   */
  get_conversation_by_id(conversation_id) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}`,
    });
  }

  /**
   * Update the conversation name.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversation
   *
   * @param {string} conversationId - ID of conversation to rename
   * @param {string} name - new name of the conversation
   * @returns {Promise} Resolves with the server response
   */
  updateConversationName(conversationId, name) {
    return this.backendClient.sendJson({
      data: {name},
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}`,
    });
  }

  /**
   * Update the conversation message timer value.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer
   *
   * @param {string} conversationId - ID of conversation to rename
   * @param {number} messageTimer - new message timer of the conversation
   * @returns {Promise} Resolves with the server response
   */
  updateConversationMessageTimer(conversationId, messageTimer) {
    return this.backendClient.sendJson({
      data: {message_timer: messageTimer},
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/message-timer`,
    });
  }
  /**
   * Update self membership properties.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateSelf
   *
   * @param {string} conversation_id - ID of conversation to update
   * @param {Object} payload - Updated properties
   * @returns {Promise} Resolves with the server response
   */
  update_member_properties(conversation_id, payload) {
    return this.backendClient.sendJson({
      data: payload,
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}/self`,
    });
  }

  //##############################################################################
  // Conversation access
  //##############################################################################

  /**
   * Delete the conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/deleteConversationCode
   * @param {string} conversationId - ID of conversation to delete access code for
   * @returns {Promise} Resolves with the server response
   */
  deleteConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Get the conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/getConversationCode
   * @param {string} conversationId - ID of conversation to get access code for
   * @returns {Promise} Resolves with the server response
   */
  getConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Request a conversation access code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createConversationCode
   * @param {string} conversationId - ID of conversation to request access code for
   * @returns {Promise} Resolves with the server response
   */
  postConversationCode(conversationId) {
    return this.backendClient.sendRequest({
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/code`,
    });
  }

  /**
   * Join a conversation using a code.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode
   * @param {string} key - Conversation identifier
   * @param {string} code - Conversation access code
   * @returns {Promise} Resolves with the server response
   */
  postConversationJoin(key, code) {
    return this.backendClient.sendJson({
      data: {
        code: code,
        key: key,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/join`,
    });
  }

  /**
   * Update conversation access mode.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationAccess
   *
   * @param {string} conversationId - ID of conversation
   * @param {Array<z.conversation.ACCESS_MODE>} accessModes - Conversation access mode
   * @param {z.conversation.ACCESS_ROLE} accessRole - Conversation access role
   * @returns {Promise} Resolves with the server response
   */
  putConversationAccess(conversationId, accessModes, accessRole) {
    return this.backendClient.sendJson({
      data: {
        access: accessModes,
        access_role: accessRole,
      },
      type: 'PUT',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/access`,
    });
  }

  //##############################################################################
  // Send events
  //##############################################################################

  /**
   * Remove service from conversation.
   *
   * @param {string} conversationId - ID of conversation to remove service from
   * @param {string} userId - ID of service to be removed from the the conversation
   * @returns {Promise} Resolves with the server response
   */
  deleteBots(conversationId, userId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/bots/${userId}`,
    });
  }

  /**
   * Remove member from conversation.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember
   *
   * @param {string} conversationId - ID of conversation to remove member from
   * @param {string} userId - ID of member to be removed from the the conversation
   * @returns {Promise} Resolves with the server response
   */
  deleteMembers(conversationId, userId) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/members/${userId}`,
    });
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {string} providerId - ID of service provider
   * @param {string} serviceId - ID of service
   * @returns {Promise} Resolves with the server response
   */
  postBots(conversationId, providerId, serviceId) {
    return this.backendClient.sendJson({
      data: {
        provider: providerId,
        service: serviceId,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/bots`,
    });
  }

  /**
   * Post an encrypted message to a conversation.
   *
   * @note If "recipients" are not specified you will receive a list of all missing OTR recipients (user-client-map).
   * @note Options for the precondition check on missing clients are:
   *   'false' - all clients, 'Array<String>' - only clients of listed users, 'true' - force sending
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrMessage
   * @example How to send "recipients" payload
   * "recipients": {
   *   "<user-id>": {
   *     "<client-id>": "<base64-encoded-encrypted-content>"
   *   }
   * }
   *
   * @param {string} conversation_id - ID of conversation to send message in
   * @param {Object} payload - Payload to be posted
   * @param {Object} payload.recipients - Map with per-recipient data
   * @param {string} payload.sender - Client ID of the sender
   * @param {Array<string>|boolean} precondition_option - Level that backend checks for missing clients
   * @returns {Promise} Promise that resolves when the message was sent
   */
  post_encrypted_message(conversation_id, payload, precondition_option) {
    let url = `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversation_id}/otr/messages`;

    if (_.isArray(precondition_option)) {
      url = `${url}?report_missing=${precondition_option.join(',')}`;
    } else if (precondition_option) {
      url = `${url}?ignore_missing=true`;
    }

    return this.backendClient.sendJson({
      data: payload,
      type: 'POST',
      url: url,
    });
  }

  /**
   * Add users to an existing conversation.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/addMembers
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {Array<string>} userIds - IDs of users to be added to the conversation
   * @returns {Promise} Resolves with the server response
   */
  postMembers(conversationId, userIds) {
    return this.backendClient.sendJson({
      data: {
        users: userIds,
      },
      type: 'POST',
      url: `${ConversationService.CONFIG.URL_CONVERSATIONS}/${conversationId}/members`,
    });
  }

  //##############################################################################
  // Database interactions
  //##############################################################################

  /**
   * Deletes a conversation entity from the local database.
   * @param {string} conversation_id - ID of conversation to be deleted
   * @returns {Promise} Resolves when the entity was deleted
   */
  delete_conversation_from_db(conversation_id) {
    return this.storageService.delete(this.CONVERSATION_STORE_NAME, conversation_id).then(primary_key => {
      this.logger.info(`State of conversation '${primary_key}' was deleted`);
      return primary_key;
    });
  }

  /**
   * Get active conversations from database.
   * @returns {Promise} Resolves with active conversations
   */
  get_active_conversations_from_db() {
    const min_date = new Date();
    min_date.setDate(min_date.getDate() - 30);

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('time')
      .aboveOrEqual(min_date.toISOString())
      .toArray()
      .then(events => {
        const conversations = events.reduce((accumulated, event) => {
          if (accumulated[event.conversation]) {
            accumulated[event.conversation] = accumulated[event.conversation] + 1;
          } else {
            accumulated[event.conversation] = 1;
          }

          return accumulated;
        }, {});

        return Object.keys(conversations).sort((id_a, id_b) => conversations[id_b] - conversations[id_a]);
      });
  }

  /**
   * Loads conversation states from the local database.
   * @returns {Promise} Resolves with all the stored conversation states
   */
  load_conversation_states_from_db() {
    return this.storageService.getAll(this.CONVERSATION_STORE_NAME);
  }

  /**
   * Saves a list of conversation records in the local database.
   * @param {Array<Conversation>} conversations - Conversation entity
   * @returns {Promise<Array>} Resolves with a list of conversation records
   */
  save_conversations_in_db(conversations) {
    const keys = conversations.map(conversation => conversation.id);
    return this.storageService.db[this.CONVERSATION_STORE_NAME].bulkPut(conversations, keys).then(() => conversations);
  }

  /**
   * Saves a conversation entity in the local database.
   * @param {Conversation} conversation_et - Conversation entity
   * @returns {Promise} Resolves with the conversation entity
   */
  save_conversation_state_in_db(conversation_et) {
    const conversationData = conversation_et.serialize();

    return this.storageService
      .save(this.CONVERSATION_STORE_NAME, conversation_et.id, conversationData)
      .then(primary_key => {
        this.logger.info(`State of conversation '${primary_key}' was stored`, conversationData);
        return conversation_et;
      });
  }

  /**
   * Search for text in given conversation.
   *
   * @param {string} conversation_id - ID of conversation to add users to
   * @param {string} query - will be checked in against all text messages
   * @returns {Promise} Resolves with the matching events
   */
  search_in_conversation(conversation_id, query) {
    const category_min = z.message.MessageCategory.TEXT;
    const category_max =
      z.message.MessageCategory.TEXT | z.message.MessageCategory.LINK | z.message.MessageCategory.LINK_PREVIEW;

    return this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max).then(events => {
      return events.filter(({data: event_data}) => z.search.FullTextSearch.search(event_data.content, query));
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationStateHandler = class ConversationStateHandler extends z.conversation
  .AbstractConversationEventHandler {
  /**
   * Construct a new conversation state handler.
   * @param {ConversationService} conversationService - Service for conversation related backend interactions
   * @param {ConversationRepository} conversationMapper - Repository for conversation interactions
   */
  constructor(conversationService, conversationMapper) {
    super();
    const eventHandlingConfig = {
      [z.event.Backend.CONVERSATION.ACCESS_UPDATE]: this._mapConversationAccessState.bind(this),
      [z.event.Backend.CONVERSATION.CODE_DELETE]: this._resetConversationAccessCode.bind(this),
      [z.event.Backend.CONVERSATION.CODE_UPDATE]: this._updateConversationAccessCode.bind(this),
    };
    this.setEventHandlingConfig(eventHandlingConfig);
    this.conversationMapper = conversationMapper;
    this.conversationService = conversationService;
  }

  changeAccessState(conversationEntity, accessState) {
    const isConversationInTeam = conversationEntity && conversationEntity.inTeam();
    if (isConversationInTeam) {
      const isStateChange = conversationEntity.accessState() !== accessState;

      if (isStateChange) {
        let accessModes;
        let accessRole;

        const changeToGuestRoom = accessState === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM;
        const changeToTeamOnly = accessState === z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY;
        if (changeToGuestRoom) {
          accessModes = [z.conversation.ACCESS_MODE.INVITE, z.conversation.ACCESS_MODE.CODE];
          accessRole = z.conversation.ACCESS_ROLE.NON_ACTIVATED;
        } else if (changeToTeamOnly) {
          accessModes = [z.conversation.ACCESS_MODE.INVITE];
          accessRole = z.conversation.ACCESS_ROLE.TEAM;
        }

        if (accessModes && accessRole) {
          return this.conversationService
            .putConversationAccess(conversationEntity.id, accessModes, accessRole)
            .then(() => {
              conversationEntity.accessState(accessState);

              if (changeToTeamOnly) {
                conversationEntity.accessCode(undefined);
              }

              const attribute = {is_allow_guests: changeToGuestRoom};
              amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.ALLOW_GUESTS, attribute);
            })
            .catch(() => {
              const messageStringId = changeToGuestRoom
                ? z.string.modalConversationGuestOptionsAllowGuestMessage
                : z.string.modalConversationGuestOptionsDisableGuestMessage;

              this._showModal(messageStringId);
            });
        }
      }
    }

    this._showModal(z.string.modalConversationGuestOptionsToggleGuestsMessage);
    return Promise.resolve();
  }

  getAccessCode(conversationEntity) {
    return this.conversationService
      .getConversationCode(conversationEntity.id)
      .then(response => this.conversationMapper.mapAccessCode(conversationEntity, response))
      .catch(error => {
        const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (!isNotFound) {
          this._showModal(z.string.modalConversationGuestOptionsGetCodeMessage);
        }
      });
  }

  requestAccessCode(conversationEntity) {
    return this.conversationService
      .postConversationCode(conversationEntity.id)
      .then(response => {
        const accessCode = response && response.data;
        if (accessCode) {
          this.conversationMapper.mapAccessCode(conversationEntity, accessCode);
          amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_CREATED);
        }
      })
      .catch(() => this._showModal(z.string.modalConversationGuestOptionsRequestCodeMessage));
  }

  revokeAccessCode(conversationEntity) {
    return this.conversationService
      .deleteConversationCode(conversationEntity.id)
      .then(() => {
        conversationEntity.accessCode(undefined);
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_REVOKED);
      })
      .catch(() => this._showModal(z.string.modalConversationGuestOptionsRevokeCodeMessage));
  }

  _mapConversationAccessState(conversationEntity, eventJson) {
    const {access: accessModes, access_role: accessRole} = eventJson.data;
    this.conversationMapper.mapAccessState(conversationEntity, accessModes, accessRole);
  }

  _resetConversationAccessCode(conversationEntity) {
    conversationEntity.accessCode(undefined);
  }

  _updateConversationAccessCode(conversationEntity, eventJson) {
    this.conversationMapper.mapAccessCode(conversationEntity, eventJson.data);
  }

  _showModal(messageStringId) {
    const modalOptions = {text: {message: z.l10n.text(messageStringId)}};
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Enum of a user's participation status in a conversation.
z.conversation.ConversationStatus = {
  CURRENT_MEMBER: 0,
  PAST_MEMBER: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationStatusIcon = {
  ACTIVE_CALL: 'active-call',
  MISSED_CALL: 'missed-call',
  MUTED: 'muted',
  NONE: 'none',
  PENDING_CONNECTION: 'pending',
  TYPING: 'typing',
  UNREAD_MENTION: 'mention',
  UNREAD_MESSAGES: 'messages',
  UNREAD_PING: 'ping',
  UNREAD_REPLY: 'reply',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Enum of different conversation types.
z.conversation.ConversationType = {
  CONNECT: 3,
  GROUP: 0,
  ONE2ONE: 2,
  SELF: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationVerificationState = {
  DEGRADED: 2,
  UNVERIFIED: 0,
  VERIFIED: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.ConversationVerificationStateHandler = class ConversationVerificationStateHandler {
  constructor(conversationRepository, eventRepository, serverTimeRepository) {
    this.conversationRepository = conversationRepository;
    this.eventRepository = eventRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.logger = new z.util.Logger('z.conversation.ConversationVerificationStateHandler', z.config.LOGGER.OPTIONS);

    amplify.subscribe(z.event.WebApp.USER.CLIENT_ADDED, this.onClientAdded.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_REMOVED, this.onClientRemoved.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENTS_UPDATED, this.onClientsUpdated.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.VERIFICATION_STATE_CHANGED, this.onClientVerificationChanged.bind(this));
  }

  /**
   * Handle client verification state change.
   * @param {string} userId - Self user ID
   * @returns {undefined} No return value
   */
  onClientVerificationChanged(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      const isStateChange = this._checkChangeToVerified(conversationEntity);
      if (!isStateChange) {
        this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.UNVERIFIED);
      }
    });
  }

  /**
   * Self user or other participant added clients.
   * @param {string} userId - ID of user that added client (can be self user ID)
   * @returns {undefined} No return value
   */
  onClientAdded(userId) {
    this.onClientsAdded([userId]);
  }

  /**
   * Multiple participants added clients.
   * @param {Array<string>} userIds - Multiple user IDs (can include self user ID)
   * @returns {undefined} No return value
   */
  onClientsAdded(userIds) {
    this._getActiveConversationsWithUsers(userIds).forEach(({conversationEntity, userIds: matchingUserIds}) => {
      this._checkChangeToDegraded(conversationEntity, matchingUserIds, z.message.VerificationMessageType.NEW_DEVICE);
    });
  }

  /**
   * Self user removed a client or other participants deleted clients.
   * @param {string} userId - ID of user that added client (can be self user ID)
   * @returns {undefined} No return value
   */
  onClientRemoved(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      this._checkChangeToVerified(conversationEntity);
    });
  }

  /**
   * A new conversation was created.
   * @param {z.entity.Conversation} conversationEntity - New conversation entity
   * @returns {undefined} No return value
   */
  onConversationCreate(conversationEntity) {
    this._checkChangeToVerified(conversationEntity);
  }

  /**
   * Clients of a user were updated.
   * @param {string} userId - User ID
   * @returns {undefined} No return value
   */
  onClientsUpdated(userId) {
    this._getActiveConversationsWithUsers([userId]).forEach(({conversationEntity, userIds}) => {
      const isStateChange = this._checkChangeToVerified(conversationEntity);
      if (!isStateChange) {
        this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.NEW_DEVICE);
      }
    });
  }

  /**
   * New member(s) joined the conversation.
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @param {Array<string>} userIds - IDs of added members
   * @returns {undefined} No return value
   */
  onMemberJoined(conversationEntity, userIds) {
    this._checkChangeToDegraded(conversationEntity, userIds, z.message.VerificationMessageType.NEW_MEMBER);
  }

  /**
   * Member(s) left the conversation.
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @returns {undefined} No return value
   */
  onMemberLeft(conversationEntity) {
    this._checkChangeToVerified(conversationEntity);
  }

  /**
   * Change that could verify conversation.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @returns {boolean} True if state changed
   */
  _checkChangeToVerified(conversationEntity) {
    if (this._willChangeToVerified(conversationEntity)) {
      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const allVerifiedEvent = z.conversation.EventBuilder.buildAllVerified(conversationEntity, currentTimestamp);
      this.eventRepository.injectEvent(allVerifiedEvent);
      return true;
    }
  }

  /**
   * Change that could degrade conversation.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Changed conversation entity
   * @param {Array<string>} userIds - IDs of affected users
   * @param {z.message.VerificationMessageType} type - Type of degradation
   * @returns {boolean} True if state changed
   */
  _checkChangeToDegraded(conversationEntity, userIds, type) {
    const isConversationDegraded = this._willChangeToDegraded(conversationEntity);
    if (isConversationDegraded) {
      /**
       * TEMPORARY DEBUGGING FIX:
       * We have seen conversations in a degraded state without an unverified device in there.
       * Previously the code would hide this fact, not create a system message and then fail when it tried to prompt
       * the user to grant subsequent message sending - essentially blocking the conversation.
       *
       * As we are unsure of the trigger of the degradation we temporarly throw an error to get to the bottom of this.
       * The conversation is also reset to the verified state to ensure we can continue to send messages.
       */
      if (!userIds.length) {
        conversationEntity.verification_state(z.conversation.ConversationVerificationState.VERIFIED);
        throw new Error('Conversation degraded without affected users');
      }

      const currentTimestamp = this.serverTimeRepository.toServerTimestamp();
      const event = z.conversation.EventBuilder.buildDegraded(conversationEntity, userIds, type, currentTimestamp);
      this.eventRepository.injectEvent(event);

      return true;
    }
  }

  /**
   * Get all conversation where self user and the given users are active.
   *
   * @private
   * @param {Array<string>} userIds - Multiple user IDs (can include self user ID)
   * @returns {Array<Object>} Array of objects containing the conversation entities and matching user IDs
   */
  _getActiveConversationsWithUsers(userIds) {
    return this.conversationRepository
      .filtered_conversations()
      .map(conversationEntity => {
        if (!conversationEntity.removed_from_conversation()) {
          const selfUserId = this.conversationRepository.selfUser().id;
          const userIdsInConversation = conversationEntity.participating_user_ids().concat(selfUserId);
          const matchingUserIds = _.intersection(userIdsInConversation, userIds);

          if (!!matchingUserIds.length) {
            return {conversationEntity, userIds: matchingUserIds};
          }
        }
      })
      .filter(activeConversationInfo => !!activeConversationInfo);
  }

  /**
   * Check whether to degrade conversation and set corresponding state.
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to evaluate
   * @returns {boolean} Conversation changing to degraded
   */
  _willChangeToDegraded(conversationEntity) {
    const state = conversationEntity.verification_state();
    const isDegraded = state === z.conversation.ConversationVerificationState.DEGRADED;
    if (isDegraded) {
      return false;
    }

    // Explicit Boolean check to prevent state changes on undefined
    const isStateVerified = state === z.conversation.ConversationVerificationState.VERIFIED;
    const isConversationUnverified = conversationEntity.is_verified() === false;
    if (isStateVerified && isConversationUnverified) {
      conversationEntity.verification_state(z.conversation.ConversationVerificationState.DEGRADED);
      this.logger.log(`Verification of conversation '${conversationEntity.id}' changed to degraded`);
      return true;
    }

    return false;
  }

  /**
   * Check whether to verify conversation and set corresponding state
   *
   * @private
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to evaluate
   * @returns {boolean} Conversation changing to verified
   */
  _willChangeToVerified(conversationEntity) {
    const state = conversationEntity.verification_state();
    const isStateVerified = state === z.conversation.ConversationVerificationState.VERIFIED;
    if (isStateVerified) {
      return false;
    }

    // Explicit Boolean check to prevent state changes on undefined
    const isConversationVerified = conversationEntity.is_verified() === true;
    if (isConversationVerified) {
      conversationEntity.verification_state(z.conversation.ConversationVerificationState.VERIFIED);
      this.logger.log(`Verification state of conversation '${conversationEntity.id}' changed to verified`);
      return true;
    }

    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.EventBuilder = {
  build1to1Creation(conversationEntity, timestamp) {
    const {creator: creatorId, id} = conversationEntity;
    const isoDate = new Date(timestamp || 0).toISOString();

    return {
      conversation: id,
      data: {
        userIds: conversationEntity.participating_user_ids(),
      },
      from: creatorId,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.ONE2ONE_CREATION,
    };
  },
  buildAllVerified(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        type: z.message.VerificationMessageType.VERIFIED,
      },
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.VERIFICATION,
    };
  },
  buildAssetAdd(conversationEntity, data, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: data,
      from: conversationEntity.selfUser().id,
      status: z.message.StatusType.SENDING,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.ASSET_ADD,
    };
  },
  buildCalling(conversationEntity, callMessage, userId, clientId) {
    return {
      content: callMessage,
      conversation: conversationEntity.id,
      from: userId,
      sender: clientId,
      type: z.event.Client.CALL.E_CALL,
    };
  },
  buildDegraded(conversationEntity, userIds, type, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        type: type,
        userIds: userIds,
      },
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.VERIFICATION,
    };
  },
  buildDelete(conversationId, messageId, time, deletedMessageEntity) {
    return {
      conversation: conversationId,
      data: {
        deleted_time: time,
      },
      from: deletedMessageEntity.from,
      id: messageId,
      time: new Date(deletedMessageEntity.timestamp()).toISOString(),
      type: z.event.Client.CONVERSATION.DELETE_EVERYWHERE,
    };
  },
  buildGroupCreation(conversationEntity, isTemporaryGuest = false, timestamp) {
    const {creator: creatorId, id} = conversationEntity;
    const selfUserId = conversationEntity.selfUser().id;
    const isoDate = new Date(timestamp || 0).toISOString();

    const userIds = conversationEntity.participating_user_ids().slice();
    const createdBySelf = creatorId === selfUserId || isTemporaryGuest;
    if (!createdBySelf) {
      userIds.push(selfUserId);
    }

    return {
      conversation: id,
      data: {
        allTeamMembers: conversationEntity.withAllTeamMembers(),
        name: conversationEntity.name(),
        userIds: userIds,
      },
      from: isTemporaryGuest ? selfUserId : creatorId,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.GROUP_CREATION,
    };
  },
  buildIncomingMessageTooBig(event, messageError, errorCode) {
    const {conversation: conversationId, data: eventData, from, time} = event;

    return {
      conversation: conversationId,
      error: `${messageError.message} (${eventData.sender})`,
      error_code: `${errorCode} (${eventData.sender})`,
      from: from,
      id: z.util.createRandomUuid(),
      time: time,
      type: z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG,
    };
  },
  buildMemberJoin(conversationEntity, sender, joiningUserIds, timestamp) {
    timestamp = timestamp ? timestamp : conversationEntity.get_last_known_timestamp() + 1;
    const isoDate = new Date(timestamp).toISOString();

    return {
      conversation: conversationEntity.id,
      data: {
        user_ids: joiningUserIds,
      },
      from: sender,
      time: isoDate,
      type: z.event.Backend.CONVERSATION.MEMBER_JOIN,
    };
  },
  buildMemberLeave(conversationEntity, userId, removedBySelfUser, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {
        user_ids: [userId],
      },
      from: removedBySelfUser ? conversationEntity.selfUser().id : userId,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Backend.CONVERSATION.MEMBER_LEAVE,
    };
  },
  buildMessageAdd(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      data: {},
      from: conversationEntity.selfUser().id,
      status: z.message.StatusType.SENDING,
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.MESSAGE_ADD,
    };
  },
  buildMissed(conversationEntity, currentTimestamp) {
    return {
      conversation: conversationEntity.id,
      from: conversationEntity.selfUser().id,
      id: z.util.createRandomUuid(),
      time: conversationEntity.get_next_iso_date(currentTimestamp),
      type: z.event.Client.CONVERSATION.MISSED_MESSAGES,
    };
  },
  buildTeamMemberLeave(conversationEntity, userEntity, isoDate) {
    return {
      conversation: conversationEntity.id,
      data: {
        name: userEntity.name(),
        user_ids: [userEntity.id],
      },
      from: userEntity.id,
      id: z.util.createRandomUuid(),
      time: isoDate,
      type: z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
    };
  },
  buildUnableToDecrypt(event, decryptionError, errorCode) {
    const {conversation: conversationId, data: eventData, from, time} = event;

    return {
      conversation: conversationId,
      error: `${decryptionError.message} (${eventData.sender})`,
      error_code: `${errorCode} (${eventData.sender})`,
      from: from,
      id: z.util.createRandomUuid(),
      time: time,
      type: z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT,
    };
  },
  buildVoiceChannelActivate(callMessageEntity) {
    const {conversationId, userId, time} = callMessageEntity;

    return {
      conversation: conversationId,
      from: userId,
      id: z.util.createRandomUuid(),
      protocol_version: z.calling.CallingRepository.CONFIG.PROTOCOL_VERSION,
      time: time,
      type: z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE,
    };
  },
  buildVoiceChannelDeactivate(callMessageEntity, reason, currentTimestamp = 0) {
    const {conversationId, userId} = callMessageEntity;
    const time = callMessageEntity.time || new Date(currentTimestamp).toISOString();

    return {
      conversation: conversationId,
      data: {
        reason: reason || z.calling.enum.TERMINATION_REASON.COMPLETED,
      },
      from: userId,
      id: z.util.createRandomUuid(),
      protocol_version: z.calling.CallingRepository.CONFIG.PROTOCOL_VERSION,
      time: time,
      type: z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE,
    };
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.EventInfoEntity = class EventInfoEntity {
  /**
   * Constructs a new event info entity.
   * @class z.conversation.EventInfoEntity
   * @param {z.proto.GenericMessage} [genericMessage] - Generic message
   * @param {string} [conversationId=''] - Conversation ID
   * @param {Object} options - Message sending options
   * @param {Array<string>|boolean} [options.nativePush=true] - Send native push notification for message
   * @param {Array<string>|boolean} [options.precondition=false] - Level that backend checks for missing clients
   * @param {Object} [options.recipients={}] - Message recipients
   * @param {number} timestamp - Timestamp of optimistic event
   */
  constructor(genericMessage, conversationId = '', options) {
    this.conversationId = conversationId;
    this.genericMessage = genericMessage;

    this.options = Object.assign({nativePush: true, precondition: false}, options);

    this.timestamp = undefined;
    this.type = undefined;
  }

  forceSending() {
    this.options.precondition = true;
  }

  getType() {
    return this.type ? this.type : this.genericMessage && this.genericMessage.content;
  }

  setTimestamp(time) {
    this.timestamp = new Date(time).getTime();
  }

  setType(type) {
    this.type = type;
  }

  updateOptions(updatedOptions) {
    this.options = Object.assign(this.options, updatedOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

// Event Mapper to convert all server side JSON events into core entities.
z.conversation.EventMapper = class EventMapper {
  /**
   * Construct a new Event Mapper.
   */
  constructor() {
    this.logger = new z.util.Logger('z.conversation.EventMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Convert multiple JSON events into message entities.
   *
   * @param {Array} events - Event data
   * @param {Conversation} conversationEntity - Conversation entity the events belong to
   * @param {boolean} [createDummyImage] - Create a dummy image
   * @returns {Promise<Array<Message>>} Resolves with the mapped message entities
   */
  mapJsonEvents(events, conversationEntity, createDummyImage) {
    return Promise.resolve().then(() => {
      return events
        .filter(event => event)
        .reverse()
        .map(event => {
          try {
            return this._mapJsonEvent(event, conversationEntity, createDummyImage);
          } catch (error) {
            const errorMessage = `Failure while mapping events. Affected '${event.type}' event: ${error.message}`;
            this.logger.error(errorMessage, {error, event});

            const customData = {eventTime: new Date(event.time).toISOString(), eventType: event.type};
            Raygun.send(new Error(errorMessage), customData);
          }
        })
        .filter(messageEntity => messageEntity);
    });
  }

  /**
   * Convert JSON event into a message entity.
   *
   * @param {Object} event - Event data
   * @param {Conversation} conversationEntity - Conversation entity the event belong to
   * @param {boolean} [createDummyImage] - Create a dummy image
   * @returns {Promise} Resolves with the mapped message entity
   */
  mapJsonEvent(event, conversationEntity, createDummyImage) {
    return Promise.resolve()
      .then(() => this._mapJsonEvent(event, conversationEntity, createDummyImage))
      .catch(error => {
        const isMessageNotFound = error.type === z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND;
        if (isMessageNotFound) {
          throw error;
        }
        const errorMessage = `Failure while mapping events. Affected '${event.type}' event: ${error.message}`;
        this.logger.error(errorMessage, {error, event});

        const customData = {eventTime: new Date(event.time).toISOString(), eventType: event.type};
        Raygun.send(new Error(errorMessage), customData);

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
      });
  }

  /**
   * Convert JSON event into a message entity.
   *
   * @param {Object} event - Event data
   * @param {Conversation} conversationEntity - Conversation entity the event belong to
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {Message} Mapped message entity
   */
  _mapJsonEvent(event, conversationEntity, createDummyImage) {
    let messageEntity;

    switch (event.type) {
      case z.event.Backend.CONVERSATION.MEMBER_JOIN: {
        messageEntity = this._mapEventMemberJoin(event, conversationEntity);
        break;
      }

      case z.event.Backend.CONVERSATION.MEMBER_LEAVE: {
        messageEntity = this._mapEventMemberLeave(event);
        break;
      }

      case z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE: {
        messageEntity = this._mapEventMessageTimerUpdate(event);
        break;
      }

      case z.event.Backend.CONVERSATION.RENAME: {
        messageEntity = this._mapEventRename(event);
        break;
      }

      case z.event.Client.CONVERSATION.ASSET_ADD: {
        messageEntity = this._mapEventAssetAdd(event, createDummyImage);
        break;
      }

      case z.event.Client.CONVERSATION.DELETE_EVERYWHERE: {
        messageEntity = this._mapEventDeleteEverywhere(event);
        break;
      }

      case z.event.Client.CONVERSATION.GROUP_CREATION: {
        messageEntity = this._mapEventGroupCreation(event);
        break;
      }

      case z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:
      case z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT: {
        messageEntity = this._mapEventUnableToDecrypt(event);
        break;
      }

      case z.event.Client.CONVERSATION.KNOCK: {
        messageEntity = this._mapEventPing();
        break;
      }

      case z.event.Client.CONVERSATION.LOCATION: {
        messageEntity = this._mapEventLocation(event);
        break;
      }

      case z.event.Client.CONVERSATION.MESSAGE_ADD: {
        messageEntity = this._mapEventMessageAdd(event);
        break;
      }

      case z.event.Client.CONVERSATION.MISSED_MESSAGES: {
        messageEntity = this._mapEventMissedMessages();
        break;
      }

      case z.event.Client.CONVERSATION.ONE2ONE_CREATION: {
        messageEntity = this._mapEvent1to1Creation(event);
        break;
      }

      case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE: {
        messageEntity = this._mapEventTeamMemberLeave(event);
        break;
      }

      case z.event.Client.CONVERSATION.VERIFICATION: {
        messageEntity = this._mapEventVerification(event);
        break;
      }

      case z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE: {
        messageEntity = this._mapEventVoiceChannelActivate();
        break;
      }

      case z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE: {
        messageEntity = this._mapEventVoiceChannelDeactivate(event);
        break;
      }

      default: {
        this.logger.warn(`Ignored unhandled '${event.type}' event ${event.id ? `'${event.id}' ` : ''}`, event);
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.MESSAGE_NOT_FOUND);
      }
    }

    const {category, from, id, primary_key, time, type, version} = event;

    messageEntity.category = category;
    messageEntity.conversation_id = conversationEntity.id;
    messageEntity.from = from;
    messageEntity.id = id;
    messageEntity.primary_key = primary_key;
    messageEntity.timestamp(new Date(time).getTime());
    messageEntity.type = type;
    messageEntity.version = version || 1;

    if (messageEntity.is_content() || messageEntity.is_ping()) {
      messageEntity.status(event.status || z.message.StatusType.SENT);
    }

    if (messageEntity.isReactable()) {
      messageEntity.reactions(event.reactions || {});
    }

    if (event.ephemeral_expires) {
      messageEntity.ephemeral_expires(event.ephemeral_expires);
      messageEntity.ephemeral_started(event.ephemeral_started || '0');
    }

    if (window.isNaN(messageEntity.timestamp())) {
      this.logger.warn(`Could not get timestamp for message '${messageEntity.id}'. Skipping it.`, event);
      messageEntity = undefined;
    }

    return messageEntity;
  }

  //##############################################################################
  // Event mappers
  //##############################################################################

  /**
   * Maps JSON data of conversation.one2one-creation message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {ContentMessage} Member message entity
   */
  _mapEvent1to1Creation({data: eventData}) {
    const {has_service: hasService, userIds} = eventData;

    const messageEntity = new z.entity.MemberMessage();
    messageEntity.memberMessageType = z.message.SystemMessageType.CONNECTION_ACCEPTED;
    messageEntity.userIds(userIds);

    if (hasService) {
      messageEntity.showServicesWarning = true;
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.asset_add message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {ContentMessage} Content message entity
   */
  _mapEventAssetAdd(event, createDummyImage) {
    const eventData = event.data;
    const messageEntity = new z.entity.ContentMessage();

    const assetInfo = eventData.info;
    const isMediumImage = assetInfo && assetInfo.tag === 'medium';
    const assetEntity = isMediumImage ? this._mapAssetImage(event, createDummyImage) : this._mapAssetFile(event);
    messageEntity.assets.push(assetEntity);

    return messageEntity;
  }

  /**
   * Maps JSON data of delete everywhere event to message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {DeleteMessage} Delete message entity
   */
  _mapEventDeleteEverywhere({data: eventData}) {
    const messageEntity = new z.entity.DeleteMessage();
    messageEntity.deleted_timestamp = new Date(eventData.deleted_time).getTime();
    return messageEntity;
  }

  /**
   * Map JSON ata of group creation event to message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventGroupCreation({data: eventData}) {
    const messageEntity = new z.entity.MemberMessage();
    messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_CREATE;
    messageEntity.name(eventData.name || '');
    messageEntity.userIds(eventData.userIds);
    messageEntity.allTeamMembers = eventData.allTeamMembers;
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.location message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {ContentMessage} Location message entity
   */
  _mapEventLocation({data: eventData}) {
    const location = eventData.location;
    const messageEntity = new z.entity.ContentMessage();
    const assetEntity = new z.entity.Location();

    assetEntity.longitude = location.longitude;
    assetEntity.latitude = location.latitude;
    assetEntity.name = location.name;
    assetEntity.zoom = location.zoom;

    messageEntity.assets.push(assetEntity);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.member_join message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @param {z.entity.Conversation} conversationEntity - Conversation entity the event belong to
   * @returns {MemberMessage} Member message entity
   */
  _mapEventMemberJoin(event, conversationEntity) {
    const {data: eventData, from: sender} = event;
    const {has_service: hasService, user_ids: userIds} = eventData;

    const messageEntity = new z.entity.MemberMessage();

    const isSingleModeConversation = conversationEntity.is1to1() || conversationEntity.isRequest();
    messageEntity.visible(!isSingleModeConversation);

    if (conversationEntity.isGroup()) {
      const messageFromCreator = sender === conversationEntity.creator;
      const creatorIndex = userIds.indexOf(sender);
      const creatorIsJoiningMember = messageFromCreator && creatorIndex !== -1;

      if (creatorIsJoiningMember) {
        userIds.splice(creatorIndex, 1);
        messageEntity.memberMessageType = z.message.SystemMessageType.CONVERSATION_CREATE;
      }

      if (hasService) {
        messageEntity.showServicesWarning = true;
      }

      messageEntity.userIds(userIds);
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.member_leave message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventMemberLeave({data: eventData}) {
    const messageEntity = new z.entity.MemberMessage();
    messageEntity.userIds(eventData.user_ids);
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.message_add message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @returns {ContentMessage} Content message entity
   */
  _mapEventMessageAdd(event) {
    const {data: eventData, edited_time: editedTime} = event;
    const messageEntity = new z.entity.ContentMessage();

    messageEntity.assets.push(this._mapAssetText(eventData));
    messageEntity.replacing_message_id = eventData.replacing_message_id;
    messageEntity.edited_timestamp = new Date(editedTime || eventData.edited_time).getTime();

    if (eventData.quote) {
      const {message_id: messageId, user_id: userId, error} = eventData.quote;
      messageEntity.quote(new z.message.QuoteEntity({error, messageId, userId}));
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of local missed message event to message entity.
   * @private
   * @returns {MissedMessage} Missed message entity
   */
  _mapEventMissedMessages() {
    return new z.entity.MissedMessage();
  }

  /**
   * Maps JSON data of conversation.knock message into message entity.
   * @private
   * @returns {PingMessage} Ping message entity
   */
  _mapEventPing() {
    return new z.entity.PingMessage();
  }

  /**
   * Maps JSON data of conversation.rename message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {RenameMessage} Rename message entity
   */
  _mapEventRename({data: eventData}) {
    const messageEntity = new z.entity.RenameMessage();
    messageEntity.name = eventData.name;
    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.message-timer-update message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {MessageTimerUpdateMessage} message timer update message entity
   */
  _mapEventMessageTimerUpdate({data: eventData}) {
    return new z.entity.MessageTimerUpdateMessage(eventData.message_timer);
  }

  /**
   * Maps JSON data of conversation.team_leave message into message entity.
   *
   * @private
   * @param {Object} event - Message data
   * @returns {MemberMessage} Member message entity
   */
  _mapEventTeamMemberLeave(event) {
    const messageEntity = this._mapEventMemberLeave(event);
    const eventData = event.data;
    messageEntity.name(eventData.name || z.l10n.text(z.string.conversationSomeone));
    return messageEntity;
  }

  /**
   * Maps JSON data of local decrypt errors to message entity.
   *
   * @private
   * @param {Object} error_code - Error data received as JSON
   * @returns {DecryptErrorMessage} Decrypt error message entity
   */
  _mapEventUnableToDecrypt({error_code: errorCode}) {
    const messageEntity = new z.entity.DecryptErrorMessage();

    if (errorCode) {
      const [code] = errorCode.split(' ');
      messageEntity.error_code = code;
      messageEntity.client_id = errorCode.substring(code.length + 1).replace(/[()]/g, '');
    }

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.verification message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {VerificationMessage} Verification message entity
   */
  _mapEventVerification({data: eventData}) {
    const messageEntity = new z.entity.VerificationMessage();

    // Database can contain non-camelCased naming. For backwards compatibility reasons we handle both.
    messageEntity.userIds(eventData.userIds || eventData.user_ids);
    messageEntity.verificationMessageType(eventData.type);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.voice-channel-activate message into message entity.
   * @private
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  _mapEventVoiceChannelActivate() {
    const messageEntity = new z.entity.CallMessage();

    messageEntity.call_message_type = z.message.CALL_MESSAGE_TYPE.ACTIVATED;
    messageEntity.visible(false);

    return messageEntity;
  }

  /**
   * Maps JSON data of conversation.voice-channel-deactivate message into message entity.
   *
   * @private
   * @param {Object} eventData - Message data
   * @returns {z.calling.entities.CallMessageEntity} Call message entity
   */
  _mapEventVoiceChannelDeactivate({data: eventData}) {
    const messageEntity = new z.entity.CallMessage();

    messageEntity.call_message_type = z.message.CALL_MESSAGE_TYPE.DEACTIVATED;
    messageEntity.finished_reason = eventData.reason;
    messageEntity.visible(messageEntity.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED);

    return messageEntity;
  }

  //##############################################################################
  // Asset mappers
  //##############################################################################

  _createDummyImage(width, height) {
    return `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 ${width} ${height}' width='${width}' height='${height}'></svg>`;
  }

  /**
   * Maps JSON data of file asset into asset entity.
   *
   * @private
   * @param {Object} event - Asset data received as JSON
   * @returns {File} File asset entity
   */
  _mapAssetFile(event) {
    const {conversation: conversationId, data: eventData} = event;
    const {content_length, content_type, id, info, meta, status} = eventData;

    const assetEntity = new z.entity.File(id);

    assetEntity.conversationId = conversationId;

    // Original
    assetEntity.file_size = content_length;
    assetEntity.file_type = content_type;
    assetEntity.meta = meta;

    // info
    if (info) {
      const {correlation_id, name} = info;
      assetEntity.correlation_id = correlation_id;
      assetEntity.file_name = name;
    }

    // Remote data - full
    const {key, otr_key, sha256, token} = eventData;
    const remoteData = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token)
      : z.assets.AssetRemoteData.v2(conversationId, id, otr_key, sha256);
    assetEntity.original_resource(remoteData);

    // Remote data - preview
    const {preview_id, preview_key, preview_otr_key, preview_sha256, preview_token} = eventData;
    if (preview_otr_key) {
      const remoteDataPreview = preview_key
        ? z.assets.AssetRemoteData.v3(preview_key, preview_otr_key, preview_sha256, preview_token, true)
        : z.assets.AssetRemoteData.v2(conversationId, preview_id, preview_otr_key, preview_sha256, true);
      assetEntity.preview_resource(remoteDataPreview);
    }

    assetEntity.status(status || z.assets.AssetTransferState.UPLOADING);

    return assetEntity;
  }

  /**
   * Maps JSON data of medium image asset into asset entity.
   *
   * @private
   * @param {Object} event - Asset data received as JSON
   * @param {boolean} createDummyImage - Create a dummy image
   * @returns {z.entity.MediumImage} Medium image asset entity
   */
  _mapAssetImage(event, createDummyImage) {
    const {data: eventData, conversation: conversationId} = event;
    const {content_length, content_type, id: assetId, info} = eventData;
    const assetEntity = new z.entity.MediumImage(assetId);

    assetEntity.file_size = content_length;
    assetEntity.file_type = content_type;
    assetEntity.ratio = assetEntity.height / assetEntity.width;

    if (info) {
      const {height, width} = info;
      assetEntity.width = width;
      assetEntity.height = height;
    }

    const {key, otr_key, sha256, token} = eventData;

    const remoteData = key
      ? z.assets.AssetRemoteData.v3(key, otr_key, sha256, token, true)
      : z.assets.AssetRemoteData.v2(conversationId, assetId, otr_key, sha256, true);
    assetEntity.resource(remoteData);

    if (createDummyImage) {
      assetEntity.dummy_url = this._createDummyImage(assetEntity.width, assetEntity.height);
    }

    return assetEntity;
  }

  /**
   * Map link preview from proto message.
   *
   * @private
   * @param {z.proto.LinkPreview} linkPreview - Link preview proto message
   * @returns {LinkPreview} Mapped link preview
   */
  _mapAssetLinkPreview(linkPreview) {
    if (linkPreview) {
      const {image, title, url, meta_data} = linkPreview;
      const {image: article_image, title: article_title} = linkPreview.article || {};

      const linkPreviewEntity = new z.entity.LinkPreview(title || article_title, url);
      linkPreviewEntity.meta_data_type = meta_data;
      linkPreviewEntity.meta_data = linkPreview[meta_data];

      const previewImage = image || article_image;
      if (previewImage && previewImage.uploaded) {
        const {asset_token, asset_id: asset_key} = previewImage.uploaded;

        if (asset_key) {
          let {otr_key, sha256} = previewImage.uploaded;

          otr_key = new Uint8Array(otr_key.toArrayBuffer());
          sha256 = new Uint8Array(sha256.toArrayBuffer());

          linkPreviewEntity.image_resource(z.assets.AssetRemoteData.v3(asset_key, otr_key, sha256, asset_token, true));
        }
      }

      return linkPreviewEntity;
    }
  }

  /**
   * Map link previews from proto messages.
   *
   * @private
   * @param {Array} linkPreviews - Link previews as base64 encoded proto messages
   * @returns {Array<LinkPreview>} Array of mapped link previews
   */
  _mapAssetLinkPreviews(linkPreviews) {
    return linkPreviews
      .map(encodedLinkPreview => z.proto.LinkPreview.decode64(encodedLinkPreview))
      .map(linkPreview => this._mapAssetLinkPreview(linkPreview))
      .filter(linkPreviewEntity => linkPreviewEntity);
  }

  /**
   * Map mentions from proto messages.
   *
   * @private
   * @param {Array} mentions - Mentions as base64 encoded proto messages
   * @param {string} messageText - Text of message
   * @returns {Array<z.message.MentionEntity>} Array of mapped mentions
   */
  _mapAssetMentions(mentions, messageText) {
    return mentions
      .map(encodedMention => {
        const protoMention = z.proto.Mention.decode64(encodedMention);
        return new z.message.MentionEntity(protoMention.start, protoMention.length, protoMention.user_id);
      })
      .filter(mentionEntity => {
        if (mentionEntity) {
          try {
            return mentionEntity.validate(messageText);
          } catch (error) {
            this.logger.warn(`Removed invalid mention when mapping message: ${error.message}`, mentionEntity);
            return false;
          }
        }
      });
  }

  /**
   * Maps JSON data of text asset into asset entity.
   *
   * @private
   * @param {Object} eventData - Asset data received as JSON
   * @returns {Text} Text asset entity
   */
  _mapAssetText(eventData) {
    const {id, content, mentions, message, previews} = eventData;
    const messageText = content || message;
    const assetEntity = new z.entity.Text(id, messageText);

    if (mentions && mentions.length) {
      assetEntity.mentions(this._mapAssetMentions(mentions, messageText));
    }
    if (previews && previews.length) {
      assetEntity.previews(this._mapAssetLinkPreviews(previews));
    }

    return assetEntity;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.conversation = z.conversation || {};

z.conversation.NotificationSetting = {
  /* eslint-disable sort-keys */

  STATE: {
    EVERYTHING: 0b00,
    MENTIONS_AND_REPLIES: 0b01,
    NOTHING: 0b11,
  },

  /* eslint-enable sort-keys */

  getText(status) {
    const statusTexts = {
      [z.conversation.NotificationSetting.STATE.EVERYTHING]: z.string.notificationSettingsEverything,
      [z.conversation.NotificationSetting.STATE.MENTIONS_AND_REPLIES]: z.string.notificationSettingsMentionsAndReplies,
      [z.conversation.NotificationSetting.STATE.NOTHING]: z.string.notificationSettingsNothing,
    };
    return z.l10n.text(statusTexts[status]);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyMapper = class CryptographyMapper {
  static get CONFIG() {
    return {
      MAX_MENTIONS_PER_MESSAGE: 500,
    };
  }

  // Construct a new CryptographyMapper.
  constructor() {
    this.logger = new z.util.Logger('z.cryptography.CryptographyMapper', z.config.LOGGER.OPTIONS);
  }

  /**
   * Maps a generic message into an event in JSON.
   *
   * @param {z.proto.GenericMessage} genericMessage - Received ProtoBuffer message
   * @param {JSON} event - Event of z.event.Backend.CONVERSATION.OTR-ASSET-ADD or z.event.Backend.CONVERSATION.OTR-MESSAGE-ADD
   * @returns {Promise} Resolves with the mapped event
   */
  mapGenericMessage(genericMessage, event) {
    if (!genericMessage) {
      return Promise.reject(new z.error.CryptographyError(z.error.CryptographyError.TYPE.NO_GENERIC_MESSAGE));
    }

    return Promise.resolve()
      .then(() => (genericMessage.external ? this._unwrapExternal(genericMessage.external, event) : genericMessage))
      .then(unwrappedGenericMessage => this._mapGenericMessage(unwrappedGenericMessage, event));
  }

  _mapGenericMessage(genericMessage, event) {
    let specificContent;

    switch (genericMessage.content) {
      case z.cryptography.GENERIC_MESSAGE_TYPE.ASSET: {
        specificContent = this._mapAsset(genericMessage.asset);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.AVAILABILITY: {
        specificContent = this._mapAvailability(genericMessage.availability);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CALLING: {
        specificContent = this._mapCalling(genericMessage.calling, event.data);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CLEARED: {
        specificContent = this._mapCleared(genericMessage.cleared);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.CONFIRMATION: {
        specificContent = this._mapConfirmation(genericMessage.confirmation);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.DELETED: {
        specificContent = this._mapDeleted(genericMessage.deleted);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.EDITED: {
        specificContent = this._mapEdited(genericMessage.edited, genericMessage.message_id);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.EPHEMERAL: {
        specificContent = this._mapEphemeral(genericMessage, event);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.HIDDEN: {
        specificContent = this._mapHidden(genericMessage.hidden);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.IMAGE: {
        specificContent = this._mapImage(genericMessage.image, event.data.id);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.KNOCK: {
        specificContent = this._mapKnock();
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.LAST_READ: {
        specificContent = this._mapLastRead(genericMessage.lastRead);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.LOCATION: {
        specificContent = this._mapLocation(genericMessage.location);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.REACTION: {
        specificContent = this._mapReaction(genericMessage.reaction);
        break;
      }

      case z.cryptography.GENERIC_MESSAGE_TYPE.TEXT: {
        specificContent = this._mapText(genericMessage.text);
        break;
      }

      default: {
        const logMessage = `Skipped event '${genericMessage.message_id}' of unhandled type '${genericMessage.content}'`;
        this.logger.debug(logMessage, {event, generic_message: genericMessage});
        throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
      }
    }

    const genericContent = {
      conversation: event.conversation,
      from: event.from,
      id: genericMessage.message_id,
      status: event.status,
      time: event.time,
    };

    return Object.assign(genericContent, specificContent);
  }

  _mapAsset(asset) {
    const {original, preview, uploaded, not_uploaded: notUploaded} = asset;
    let data = {};

    if (original) {
      data = {
        content_length: original.size.toNumber(),
        content_type: original.mime_type,
        info: {
          name: original.name,
        },
      };

      if (original.image) {
        data.info.height = original.image.height;
        data.info.width = original.image.width;
      } else {
        data.meta = this._mapAssetMetaData(original);
      }
    }

    if (preview) {
      const remote = preview.remote;

      data = Object.assign(data, {
        preview_key: remote.asset_id,
        preview_otr_key: new Uint8Array(remote.otr_key.toArrayBuffer()),
        preview_sha256: new Uint8Array(remote.sha256.toArrayBuffer()),
        preview_token: remote.asset_token,
      });
    }

    const isImage = uploaded && uploaded.asset_id && original && original.image;
    if (isImage) {
      data.info.tag = 'medium';
    }

    if (uploaded !== null) {
      data = Object.assign(data, {
        key: uploaded.asset_id,
        otr_key: new Uint8Array(uploaded.otr_key.toArrayBuffer()),
        sha256: new Uint8Array(uploaded.sha256.toArrayBuffer()),
        status: z.assets.AssetTransferState.UPLOADED,
        token: uploaded.asset_token,
      });
    }

    if (notUploaded !== null) {
      data = Object.assign(data, {
        reason: notUploaded,
        status: z.assets.AssetTransferState.UPLOAD_FAILED,
      });
    }

    return {data, type: z.event.Client.CONVERSATION.ASSET_ADD};
  }

  _mapAssetMetaData(original) {
    const audioData = original.audio;
    if (audioData) {
      const loudnessArray = audioData.normalized_loudness ? audioData.normalized_loudness.toArrayBuffer() : [];
      const durationInSeconds = audioData.duration_in_millis
        ? audioData.duration_in_millis / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND
        : 0;

      return {
        duration: durationInSeconds,
        loudness: new Uint8Array(loudnessArray),
      };
    }
  }

  _mapAvailability(availability) {
    return {
      data: {
        availability: (() => {
          switch (availability.type) {
            case z.proto.Availability.Type.NONE:
              return z.user.AvailabilityType.NONE;
            case z.proto.Availability.Type.AVAILABLE:
              return z.user.AvailabilityType.AVAILABLE;
            case z.proto.Availability.Type.AWAY:
              return z.user.AvailabilityType.AWAY;
            case z.proto.Availability.Type.BUSY:
              return z.user.AvailabilityType.BUSY;
            default:
              const message = 'Unhandled availability type';
              throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE, message);
          }
        })(),
      },
      type: z.event.Client.USER.AVAILABILITY,
    };
  }

  _mapCalling(calling, eventData) {
    return {
      content: JSON.parse(calling.content),
      sender: eventData.sender,
      type: z.event.Client.CALL.E_CALL,
    };
  }

  _mapCleared(cleared) {
    return {
      data: {
        cleared_timestamp: cleared.cleared_timestamp.toString(),
        conversationId: cleared.conversation_id,
      },
      type: z.event.Backend.CONVERSATION.MEMBER_UPDATE,
    };
  }

  _mapConfirmation(confirmation) {
    return {
      data: {
        message_id: confirmation.first_message_id,
        status: (() => {
          switch (confirmation.type) {
            case z.proto.Confirmation.Type.DELIVERED:
              return z.message.StatusType.DELIVERED;
            case z.proto.Confirmation.Type.READ:
              return z.message.StatusType.SEEN;
            default:
              const message = 'Unhandled confirmation type';
              throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE, message);
          }
        })(),
      },
      type: z.event.Client.CONVERSATION.CONFIRMATION,
    };
  }

  _mapDeleted(deleted) {
    return {
      data: {
        message_id: deleted.message_id,
      },
      type: z.event.Client.CONVERSATION.MESSAGE_DELETE,
    };
  }

  _mapEdited(edited, eventId) {
    const mappedMessage = this._mapText(edited.text, eventId);
    mappedMessage.data.replacing_message_id = edited.replacing_message_id;
    return mappedMessage;
  }

  _mapEphemeral(genericMessage, event) {
    const messageTimer = genericMessage.ephemeral.expire_after_millis.toNumber();
    genericMessage.ephemeral.message_id = genericMessage.message_id;

    const embeddedMessage = this._mapGenericMessage(genericMessage.ephemeral, event);
    embeddedMessage.ephemeral_expires = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    return embeddedMessage;
  }

  /**
   * Unpacks a specific generic message which is wrapped inside an external generic message.
   *
   * @note Wrapped messages get the 'message_id' of their wrappers (external message)
   * @param {z.proto.External} external - Generic message of type 'external'
   * @param {JSON} event - Backend event of type 'conversation.otr-message-add'
   * @returns {Promise} Resolves with generic message
   */
  _unwrapExternal(external, event) {
    return Promise.resolve(external)
      .then(({otr_key: otrKey, sha256}) => {
        const eventData = event.data;
        if (!eventData.data || !otrKey || !sha256) {
          throw new Error('Not all expected properties defined');
        }

        const cipherText = z.util.base64ToArray(eventData.data).buffer;
        const keyBytes = new Uint8Array(otrKey.toArrayBuffer()).buffer;
        const referenceSha256 = new Uint8Array(sha256.toArrayBuffer()).buffer;

        return z.assets.AssetCrypto.decryptAesAsset(cipherText, keyBytes, referenceSha256);
      })
      .then(externalMessageBuffer => z.proto.GenericMessage.decode(externalMessageBuffer))
      .catch(error => {
        this.logger.error(`Failed to unwrap external message: ${error.message}`, error);
        throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.BROKEN_EXTERNAL);
      });
  }

  _mapHidden(hidden) {
    return {
      data: {
        conversation_id: hidden.conversation_id,
        message_id: hidden.message_id,
      },
      type: z.event.Client.CONVERSATION.MESSAGE_HIDDEN,
    };
  }

  _mapImage(image, eventId) {
    const isMediumImage = image.tag === 'medium';
    if (isMediumImage) {
      return this._mapImageMedium(image, eventId);
    }

    this.logger.info(`Skipped event '${eventId}': ${z.error.CryptographyError.MESSAGE.IGNORED_PREVIEW}`);
    throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.IGNORED_PREVIEW);
  }

  _mapImageMedium(image, eventId) {
    // set ID even if asset id is missing
    eventId = eventId || z.util.createRandomUuid();

    return {
      data: {
        content_length: image.size,
        content_type: image.mime_type,
        id: eventId,
        info: {
          height: image.height,
          tag: image.tag,
          width: image.width,
        },
        otr_key: new Uint8Array(image.otr_key ? image.otr_key.toArrayBuffer() : []),
        sha256: new Uint8Array(image.sha256 ? image.sha256.toArrayBuffer() : []),
      },
      type: z.event.Client.CONVERSATION.ASSET_ADD,
    };
  }

  _mapKnock() {
    return {type: z.event.Client.CONVERSATION.KNOCK};
  }

  _mapLastRead(lastRead) {
    return {
      data: {
        conversationId: lastRead.conversation_id,
        last_read_timestamp: lastRead.last_read_timestamp.toString(),
      },
      type: z.event.Backend.CONVERSATION.MEMBER_UPDATE,
    };
  }

  _mapLocation(location) {
    return {
      data: {
        location: {
          latitude: location.latitude,
          longitude: location.longitude,
          name: location.name,
          zoom: location.zoom,
        },
      },
      type: z.event.Client.CONVERSATION.LOCATION,
    };
  }

  _mapReaction(reaction) {
    return {
      data: {
        message_id: reaction.message_id,
        reaction: reaction.emoji,
      },
      type: z.event.Client.CONVERSATION.REACTION,
    };
  }

  _mapText(text) {
    const {link_preview: protoLinkPreviews, mentions: protoMentions, quote: protoQuote} = text;

    if (protoMentions && protoMentions.length > CryptographyMapper.CONFIG.MAX_MENTIONS_PER_MESSAGE) {
      this.logger.warn(`Message contains '${protoMentions.length}' mentions exceeding limit`, text);
      protoMentions.length = CryptographyMapper.CONFIG.MAX_MENTIONS_PER_MESSAGE;
    }

    return {
      data: {
        content: `${text.content}`,
        mentions: protoMentions.map(protoMention => protoMention.encode64()),
        previews: protoLinkPreviews.map(protoLinkPreview => protoLinkPreview.encode64()),
        quote: protoQuote && protoQuote.encode64(),
      },
      type: z.event.Client.CONVERSATION.MESSAGE_ADD,
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyRepository = class CryptographyRepository {
  static get CONFIG() {
    return {
      UNKNOWN_DECRYPTION_ERROR_CODE: 999,
    };
  }

  static get REMOTE_ENCRYPTION_FAILURE() {
    return '💣';
  }

  /**
   * Construct a new Cryptography repository.
   * @param {z.cryptography.CryptographyService} cryptographyService - Backend REST API cryptography service implementation
   * @param {z.storage.StorageRepository} storageRepository - Repository for all storage interactions
   */
  constructor(cryptographyService, storageRepository) {
    this.cryptographyService = cryptographyService;
    this.storageRepository = storageRepository;
    this.logger = new z.util.Logger('z.cryptography.CryptographyRepository', z.config.LOGGER.OPTIONS);

    this.cryptographyMapper = new z.cryptography.CryptographyMapper();

    this.currentClient = undefined;
    this.cryptobox = undefined;
  }

  /**
   * Initializes the repository by loading an existing Cryptobox.
   * @param {Object} database - Database object
   * @returns {Promise} Resolves after initialization
   */
  createCryptobox(database) {
    return this._init(database).then(() => this.cryptobox.create());
  }

  /**
   * Initializes the repository by creating a new Cryptobox.
   * @param {Object} database - Database object
   * @returns {Promise} Resolves after initialization
   */
  loadCryptobox(database) {
    return this._init(database).then(() => this.cryptobox.load());
  }

  resetCryptobox(clientEntity) {
    const deleteEverything = clientEntity ? clientEntity.isTemporary() : false;
    const deletePromise = deleteEverything
      ? this.storageRepository.deleteDatabase()
      : this.storageRepository.deleteCryptographyStores();

    return deletePromise
      .catch(databaseError => {
        const message = `Failed cryptography-related db deletion on client validation error: ${databaseError.message}`;
        this.logger.error(message, databaseError);
        throw new z.error.ClientError(z.error.ClientError.TYPE.DATABASE_FAILURE);
      })
      .then(() => deleteEverything);
  }

  /**
   * Initialize the repository.
   *
   * @private
   * @param {Object} database - Dexie instance
   * @returns {Promise} Resolves after initialization
   */
  _init(database) {
    return Promise.resolve().then(() => {
      this.logger.info(`Initializing Cryptobox with database '${database.name}'...`);
      const storeEngine = new StoreEngine.IndexedDBEngine();
      storeEngine.initWithDb(database);
      this.cryptobox = new cryptobox.Cryptobox(storeEngine, 10);

      this.cryptobox.on(cryptobox.Cryptobox.TOPIC.NEW_PREKEYS, preKeys => {
        const serializedPreKeys = preKeys.map(preKey => this.cryptobox.serialize_prekey(preKey));

        this.logger.log(`Received '${preKeys.length}' new PreKeys.`, serializedPreKeys);
        return this.cryptographyService.putClientPreKeys(this.currentClient().id, serializedPreKeys).then(() => {
          this.logger.log(`Successfully uploaded '${serializedPreKeys.length}' PreKeys.`, serializedPreKeys);
        });
      });

      this.cryptobox.on(cryptobox.Cryptobox.TOPIC.NEW_SESSION, sessionId => {
        const {userId, clientId} = z.client.ClientEntity.dismantleUserClientId(sessionId);
        amplify.publish(z.event.WebApp.CLIENT.ADD, userId, {id: clientId}, true);
      });
    });
  }

  /**
   * Generate all keys needed for client registration.
   * @returns {Promise} Resolves with an array of last resort key, pre-keys, and signaling keys
   */
  generateClientKeys() {
    return Promise.all([
      this.cryptobox.get_serialized_last_resort_prekey(),
      this.cryptobox.get_serialized_standard_prekeys(),
      this._generateSignalingKeys(),
    ]).catch(error => {
      throw new Error(`Failed to generate client keys: ${error.message}`);
    });
  }

  /**
   * Get the fingerprint of the local identity.
   * @returns {string} Fingerprint of local identity public key
   */
  getLocalFingerprint() {
    return this._formatFingerprint(this.cryptobox.identity.public_key.fingerprint());
  }

  /**
   * Get the fingerprint of a remote identity.
   * @param {string} userId - ID of user
   * @param {string} clientId - ID of client
   * @returns {Promise} Resolves with the remote fingerprint
   */
  getRemoteFingerprint(userId, clientId) {
    return this._loadSession(userId, clientId).then(cryptoboxSession => {
      return cryptoboxSession ? this._formatFingerprint(cryptoboxSession.fingerprint_remote()) : '';
    });
  }

  _formatFingerprint(fingerprint) {
    return z.util.zeroPadding(fingerprint, 16).match(/.{1,2}/g) || [];
  }

  /**
   * Get a pre-key for the given client of the user.
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @returns {Promise} Resolves with a map of pre-keys for the requested clients
   */
  getUserPreKeyByIds(userId, clientId) {
    return this.cryptographyService
      .getUserPreKeyByIds(userId, clientId)
      .then(response => response.prekey)
      .catch(error => {
        const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
        if (isNotFound) {
          throw new z.error.UserError(z.error.UserError.TYPE.PRE_KEY_NOT_FOUND);
        }

        this.logger.error(`Failed to get pre-key from backend: ${error.message}`);
        throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
      });
  }

  /**
   * Get a pre-key for each client in the user client map.
   * @param {Object} recipients - User client map to request pre-keys for
   * @returns {Promise} Resolves with a map of pre-keys for the requested clients
   */
  getUsersPreKeys(recipients) {
    return this.cryptographyService.getUsersPreKeys(recipients).catch(error => {
      const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
      if (isNotFound) {
        throw new z.error.UserError(z.error.UserError.TYPE.PRE_KEY_NOT_FOUND);
      }

      this.logger.error(`Failed to get pre-key from backend: ${error.message}`);
      throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
    });
  }

  _loadSession(userId, clientId) {
    const sessionId = this._constructSessionId(userId, clientId);

    return this.cryptobox.session_load(sessionId).catch(() => {
      return this.getUserPreKeyByIds(userId, clientId).then(preKey => {
        return this._createSessionFromPreKey(preKey, userId, clientId);
      });
    });
  }

  /**
   * Generate the signaling keys (which are used for mobile push notifications).
   * @note Signaling Keys are  required by the backend but unimportant for the webapp
   *   (because they are used for iOS or Android push notifications).
   *   Thus this method returns a static Signaling Key Pair.
   *
   * @private
   * @returns {Object} Object containing the signaling keys
   */
  _generateSignalingKeys() {
    return {
      enckey: 'Wuec0oJi9/q9VsgOil9Ds4uhhYwBT+CAUrvi/S9vcz0=',
      mackey: 'Wuec0oJi9/q9VsgOil9Ds4uhhYwBT+CAUrvi/S9vcz0=',
    };
  }

  /**
   * Construct a session ID.
   *
   * @todo Make public
   * @private
   * @param {string} userId - User ID for the remote participant
   * @param {string} clientId - Client ID of the remote participant
   * @returns {string} Session ID
   */
  _constructSessionId(userId, clientId) {
    return `${userId}@${clientId}`;
  }

  deleteSession(userId, clientId) {
    const sessionId = this._constructSessionId(userId, clientId);
    return this.cryptobox.session_delete(sessionId);
  }

  /**
   * Bundles and encrypts the generic message for all given clients.
   *
   * @param {Object} recipients - Contains all users and their known clients
   * @param {z.proto.GenericMessage} genericMessage - Proto buffer message to be encrypted
   * @param {Object} [payload={sender: string, recipients: {}, native_push: true}] - Object to contain encrypted message payload
   * @returns {Promise} Resolves with the encrypted payload
   */
  encryptGenericMessage(recipients, genericMessage, payload = this._constructPayload(this.currentClient().id)) {
    return Promise.resolve()
      .then(() => {
        const receivingUsers = Object.keys(recipients).length;
        const logMessage = `Encrypting message of type '${genericMessage.content}' for '${receivingUsers}' users.`;
        this.logger.log(logMessage, recipients);

        return this._encryptGenericMessage(recipients, genericMessage, payload);
      })
      .then(({messagePayload, missingRecipients}) => {
        return Object.keys(missingRecipients).length
          ? this._encryptGenericMessageForMissingRecipients(missingRecipients, genericMessage, messagePayload)
          : {messagePayload, missingRecipients};
      })
      .then(({messagePayload, missingRecipients}) => {
        const payloadUsers = Object.keys(messagePayload.recipients).length;
        const logMessage = `Encrypted message of type '${genericMessage.content}' for '${payloadUsers}' users.`;
        this.logger.log(logMessage, messagePayload.recipients);

        const missingUsers = Object.keys(missingRecipients).length;
        if (missingUsers) {
          this.logger.warn(`Failed to encrypt message for '${missingUsers}' users`, missingRecipients);
        }

        return messagePayload;
      });
  }

  /**
   * Handle an encrypted event.
   * @param {Object} event - Backend event to decrypt
   * @returns {Promise} Resolves with decrypted and mapped message
   */
  handleEncryptedEvent(event) {
    const {data: eventData, from: userId, id} = event;

    if (!eventData) {
      const logMessage = `Encrypted event with ID '${id}' from user '${userId}' does not have a 'data' property.`;
      this.logger.error(logMessage, event);

      return Promise.reject(new z.error.CryptographyError(z.error.CryptographyError.TYPE.NO_DATA_CONTENT));
    }

    // Check the length of the message
    const genericMessageIsTooBig = eventData.text.length > z.config.MAXIMUM_MESSAGE_LENGTH_RECEIVING;
    const isExternal = typeof eventData.data === 'string';
    const externalMessageIsTooBig = isExternal && eventData.data.length > z.config.MAXIMUM_MESSAGE_LENGTH_RECEIVING;
    if (genericMessageIsTooBig || externalMessageIsTooBig) {
      const error = new Proteus.errors.DecryptError.InvalidMessage('The received message was too big.', 300);
      const errorEvent = z.conversation.EventBuilder.buildIncomingMessageTooBig(event, error, error.code);
      return Promise.resolve(errorEvent);
    }

    const failedEncryption = eventData.text === CryptographyRepository.REMOTE_ENCRYPTION_FAILURE;
    if (failedEncryption) {
      const decryptionError = new Proteus.errors.DecryptError.InvalidMessage(
        'Sender failed to encrypt a message.',
        213
      );
      return Promise.resolve(this._handleDecryptionFailure(decryptionError, event));
    }

    return this._decryptEvent(event)
      .then(genericMessage => this.cryptographyMapper.mapGenericMessage(genericMessage, event))
      .catch(error => {
        const isUnhandledType = error.type === z.error.CryptographyError.TYPE.UNHANDLED_TYPE;
        if (isUnhandledType) {
          throw error;
        }

        return this._handleDecryptionFailure(error, event);
      });
  }

  _createSessionFromPreKey(preKey, userId, clientId) {
    return Promise.resolve()
      .then(() => {
        if (preKey) {
          this.logger.log(`Initializing session with user '${userId}' (${clientId}) with pre-key ID '${preKey.id}'.`);
          const sessionId = this._constructSessionId(userId, clientId);

          return this.cryptobox.session_from_prekey(sessionId, z.util.base64ToArray(preKey.key).buffer);
        }

        Raygun.send(new Error('Failed to create session: No pre-key found'));
        this.logger.warn(`No pre-key for user '${userId}' ('${clientId}') found. The client might have been deleted.`);
        return undefined;
      })
      .catch(error => {
        Raygun.send(new Error(`Failed to create session: ${error.message}`));

        const message = `Pre-key for user '${userId}' ('${clientId}') invalid. Skipping encryption: ${error.message}`;
        this.logger.warn(message, error);
        return undefined;
      });
  }

  _encryptGenericMessage(recipients, genericMessage, messagePayload) {
    return Promise.resolve()
      .then(() => {
        const cipherPayloadPromises = [];

        Object.entries(recipients).forEach(([userId, clientIds]) => {
          if (clientIds && clientIds.length) {
            messagePayload.recipients[userId] = messagePayload.recipients[userId] || {};
            clientIds.forEach(clientId => {
              const sessionId = this._constructSessionId(userId, clientId);
              const encryptionPromise = this._encryptPayloadForSession(sessionId, genericMessage);

              cipherPayloadPromises.push(encryptionPromise);
            });
          }
        });

        return Promise.all(cipherPayloadPromises);
      })
      .then(cipherPayload => this._mapCipherTextToPayload(messagePayload, cipherPayload));
  }

  _encryptGenericMessageForMissingRecipients(missingRecipients, genericMessage, messagePayload) {
    return this.getUsersPreKeys(missingRecipients)
      .then(userPreKeyMap => {
        this.logger.info(`Fetched pre-keys for '${Object.keys(userPreKeyMap).length}' users.`, userPreKeyMap);

        const cipherPayloadPromises = [];

        Object.entries(userPreKeyMap).forEach(([userId, clientPreKeyMap]) => {
          if (clientPreKeyMap && Object.keys(clientPreKeyMap).length) {
            Object.entries(clientPreKeyMap).forEach(([clientId, preKeyPayload]) => {
              if (preKeyPayload) {
                const sessionId = this._constructSessionId(userId, clientId);
                const preKeyBundle = z.util.base64ToArray(preKeyPayload.key).buffer;
                const encryptionPromise = this._encryptPayloadForSession(sessionId, genericMessage, preKeyBundle);

                cipherPayloadPromises.push(encryptionPromise);
              }
            });
          }
        });

        return Promise.all(cipherPayloadPromises);
      })
      .then(cipherPayload => this._mapCipherTextToPayload(messagePayload, cipherPayload));
  }

  _mapCipherTextToPayload(messagePayload, cipherPayload) {
    const missingRecipients = {};

    cipherPayload.forEach(({cipherText, sessionId}) => {
      const {userId, clientId} = z.client.ClientEntity.dismantleUserClientId(sessionId);

      if (cipherText) {
        messagePayload.recipients[userId][clientId] = cipherText;
      } else {
        missingRecipients[userId] = missingRecipients[userId] || [];
        missingRecipients[userId].push(clientId);
      }
    });

    return {messagePayload, missingRecipients};
  }

  /**
   * Construct the payload for an encrypted message.
   *
   * @private
   * @param {string} sender - Client ID of message sender
   * @returns {Object} Payload to send to backend
   */
  _constructPayload(sender) {
    return {
      native_push: true,
      recipients: {},
      sender: sender,
    };
  }

  /**
   * Decrypt an event.
   *
   * @private
   * @param {Object} event - Backend event to decrypt
   * @returns {Promise} Resolves with the decrypted message in ProtocolBuffer format
   */
  _decryptEvent(event) {
    const {data: eventData, from: userId} = event;
    const cipherText = z.util.base64ToArray(eventData.text || eventData.key).buffer;
    const sessionId = this._constructSessionId(userId, eventData.sender);

    return this.cryptobox.decrypt(sessionId, cipherText).then(plaintext => z.proto.GenericMessage.decode(plaintext));
  }

  /**
   * Encrypt the generic message for a given session.
   * @note We created the convention that whenever we fail to encrypt for a specific client, we send a Bomb Emoji (no joke!)
   *
   * @private
   * @param {string} sessionId - ID of session to encrypt for
   * @param {z.proto.GenericMessage} genericMessage - ProtoBuffer message
   * @param {Object} [preKeyBundle] - Pre-key bundle
   * @returns {Object} Contains session ID and encrypted message as base64 encoded string
   */
  _encryptPayloadForSession(sessionId, genericMessage, preKeyBundle) {
    return this.cryptobox
      .encrypt(sessionId, genericMessage.toArrayBuffer(), preKeyBundle)
      .then(cipherText => ({cipherText: z.util.arrayToBase64(cipherText), sessionId}))
      .catch(error => {
        if (error instanceof StoreEngine.error.RecordNotFoundError) {
          this.logger.log(`Session '${sessionId}' needs to get initialized...`);
          return {sessionId};
        }

        const message = `Failed encrypting '${genericMessage.content}' for session '${sessionId}': ${error.message}`;
        this.logger.warn(message, error);
        return {cipherText: CryptographyRepository.REMOTE_ENCRYPTION_FAILURE, sessionId};
      });
  }

  _handleDecryptionFailure(error, event) {
    // Get error information
    const errorCode = error.code || CryptographyRepository.CONFIG.UNKNOWN_DECRYPTION_ERROR_CODE;

    const {data: eventData, from: remoteUserId, time: formattedTime} = event;

    const isDuplicateMessage = error instanceof Proteus.errors.DecryptError.DuplicateMessage;
    const isOutdatedMessage = error instanceof Proteus.errors.DecryptError.OutdatedMessage;
    // We don't need to show these message errors to the user
    if (isDuplicateMessage || isOutdatedMessage) {
      throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
    }

    const isCryptographyError = error instanceof z.error.CryptographyError;
    if (isCryptographyError && error.type === z.error.CryptographyError.TYPE.PREVIOUSLY_STORED) {
      throw new z.error.CryptographyError(z.error.CryptographyError.TYPE.UNHANDLED_TYPE);
    }

    const remoteClientId = eventData.sender;

    const isInvalidMessage = error instanceof Proteus.errors.DecryptError.InvalidMessage;
    const isInvalidSignature = error instanceof Proteus.errors.DecryptError.InvalidSignature;
    const isRemoteIdentityChanged = error instanceof Proteus.errors.DecryptError.RemoteIdentityChanged;
    // Session is broken, let's see what's really causing it...
    if (isInvalidMessage || isInvalidSignature) {
      this.logger.error(
        `Session with user '${remoteUserId}' (${remoteClientId}) is broken.\nReset the session for possible fix.`
      );
    } else if (isRemoteIdentityChanged) {
      this.logger.error(`Remote identity of client '${remoteClientId}' from user '${remoteUserId}' changed`);
    }

    this.logger.warn(
      `Failed to decrypt event from client '${remoteClientId}' of user '${remoteUserId}' (${formattedTime}).\nError Code: '${errorCode}'\nError Message: ${
        error.message
      }`,
      error
    );
    this._reportDecryptionFailure(error, event);

    return z.conversation.EventBuilder.buildUnableToDecrypt(event, error, errorCode);
  }

  /**
   * Report decryption error to Localytics and stack traces to Raygun.
   *
   * @private
   * @param {Error} error - Error from event decryption
   * @param {Object} eventData - Event data
   * @param {string} userId - Remote user ID
   * @param {string} eventType - Event type
   * @returns {undefined} No return value
   */
  _reportDecryptionFailure(error, {data: eventData, type: eventType}) {
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.E2EE.FAILED_MESSAGE_DECRYPTION, {
      cause: error.code || error.message,
    });

    const customData = {
      clientLocalClass: this.currentClient().class,
      clientLocalType: this.currentClient().type,
      cryptoboxVersion: cryptobox.version,
      errorCode: error.code,
      eventType: eventType,
    };

    const raygunError = new Error(`Decryption failed: ${error.code || error.message}`);
    raygunError.stack = error.stack;
    Raygun.send(raygunError, customData);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.CryptographyService = class CryptographyService {
  static get CONFIG() {
    return {
      URL_CLIENTS: '/clients',
      URL_USERS: '/users',
    };
  }

  /**
   * Construct a new Cryptography Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.cryptography.CryptographyService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Gets a pre-key for a client of a user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getPrekey
   *
   * @param {string} userId - User ID
   * @param {string} clientId - Client ID
   * @returns {Promise} Resolves with a pre-key for given the client of the user
   */
  getUserPreKeyByIds(userId, clientId) {
    return this.backendClient.sendJson({
      type: 'GET',
      url: `${CryptographyService.CONFIG.URL_USERS}/${userId}/prekeys/${clientId}`,
    });
  }

  /**
   * Gets a pre-key for each client of a user client map.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getMultiPrekeyBundles
   *
   * @param {Object} recipients - User client map to request pre-keys for
   * @returns {Promise} Resolves with a pre-key for each client of the given map
   */
  getUsersPreKeys(recipients) {
    return this.backendClient.sendJson({
      data: recipients,
      type: 'POST',
      url: `${CryptographyService.CONFIG.URL_USERS}/prekeys`,
    });
  }

  /**
   * Put pre-keys for client to be used by remote clients for session initialization.
   *
   * @param {string} clientId - Local client ID
   * @param {Array<string>} serializedPreKeys - Additional pre-keys to be made available
   * @returns {Promise} Resolves once the pre-keys are accepted
   */
  putClientPreKeys(clientId, serializedPreKeys) {
    return this.backendClient.sendJson({
      data: {
        prekeys: serializedPreKeys,
      },
      type: 'PUT',
      url: `${CryptographyService.CONFIG.URL_CLIENTS}/${clientId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.GENERIC_MESSAGE_TYPE = {
  ASSET: 'asset',
  AVAILABILITY: 'availability',
  CALLING: 'calling',
  CLEARED: 'cleared',
  CLIENT_ACTION: 'clientAction',
  CONFIRMATION: 'confirmation',
  DELETED: 'deleted',
  EDITED: 'edited',
  EPHEMERAL: 'ephemeral',
  EXTERNAL: 'external',
  HIDDEN: 'hidden',
  IMAGE: 'image',
  KNOCK: 'knock',
  LAST_READ: 'lastRead',
  LOCATION: 'location',
  REACTION: 'reaction',
  TEXT: 'text',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.cryptography = z.cryptography || {};

z.cryptography.PROTO_MESSAGE_TYPE = {
  ASSET_NOT_UPLOADED: 'not_uploaded',
  ASSET_ORIGINAL: 'original',
  ASSET_PREVIEW: 'preview',
  ASSET_UPLOADED: 'uploaded',
  EPHEMERAL_EXPIRATION: 'expire_after_millis',
  LINK_PREVIEW_IMAGE: 'image',
  LINK_PREVIEW_TITLE: 'title',
  LINK_PREVIEWS: 'link_preview',
  MENTION_TYPE_USER_ID: 'user_id',
  MENTIONS: 'mentions',
  QUOTE: 'quote',
  TWEET: 'tweet',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ephemeral = z.ephemeral || {};

z.ephemeral.timings = class {
  static get VALUES() {
    return [
      z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
      z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE * 5,
      z.util.TimeUtil.UNITS_IN_MILLIS.HOUR,
      z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      z.util.TimeUtil.UNITS_IN_MILLIS.WEEK,
      z.util.TimeUtil.UNITS_IN_MILLIS.WEEK * 4,
    ];
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.Backend = {
  CONVERSATION: {
    ACCESS_UPDATE: 'conversation.access-update',
    CODE_DELETE: 'conversation.code-delete',
    CODE_UPDATE: 'conversation.code-update',
    CONNECT_REQUEST: 'conversation.connect-request',
    CREATE: 'conversation.create',
    DELETE: 'conversation.delete',
    MEMBER_JOIN: 'conversation.member-join',
    MEMBER_LEAVE: 'conversation.member-leave',
    MEMBER_UPDATE: 'conversation.member-update',
    MESSAGE_TIMER_UPDATE: 'conversation.message-timer-update',
    OTR_MESSAGE_ADD: 'conversation.otr-message-add',
    RENAME: 'conversation.rename',
    TYPING: 'conversation.typing',
  },
  TEAM: {
    CONVERSATION_CREATE: 'team.conversation-create',
    CONVERSATION_DELETE: 'team.conversation-delete',
    CREATE: 'team.create',
    DELETE: 'team.delete',
    MEMBER_JOIN: 'team.member-join',
    MEMBER_LEAVE: 'team.member-leave',
    MEMBER_UPDATE: 'team.member-update',
    UPDATE: 'team.update',
  },
  USER: {
    ACTIVATE: 'user.activate',
    CLIENT_ADD: 'user.client-add',
    CLIENT_REMOVE: 'user.client-remove',
    CONNECTION: 'user.connection',
    DELETE: 'user.delete',
    UPDATE: 'user.update',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.Client = {
  CALL: {
    E_CALL: 'call.e-call',
  },
  CONVERSATION: {
    ASSET_ADD: 'conversation.asset-add',
    CONFIRMATION: 'conversation.confirmation',
    DELETE_EVERYWHERE: 'conversation.delete-everywhere',
    GROUP_CREATION: 'conversation.group-creation',
    INCOMING_MESSAGE_TOO_BIG: 'conversation.incoming-message-too-big',
    KNOCK: 'conversation.knock',
    LOCATION: 'conversation.location',
    MESSAGE_ADD: 'conversation.message-add',
    MESSAGE_DELETE: 'conversation.message-delete',
    MESSAGE_HIDDEN: 'conversation.message-hidden',
    MISSED_MESSAGES: 'conversation.missed-messages',
    ONE2ONE_CREATION: 'conversation.one2one-creation',
    REACTION: 'conversation.reaction',
    TEAM_MEMBER_LEAVE: 'conversation.team-member-leave',
    UNABLE_TO_DECRYPT: 'conversation.unable-to-decrypt',
    VERIFICATION: 'conversation.verification',
    VOICE_CHANNEL_ACTIVATE: 'conversation.voice-channel-activate',
    VOICE_CHANNEL_DEACTIVATE: 'conversation.voice-channel-deactivate',
  },
  USER: {
    AVAILABILITY: 'user.availability',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EventRepository = class EventRepository {
  static get CONFIG() {
    return {
      E_CALL_EVENT_LIFETIME: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 30,
      IGNORED_ERRORS: [
        z.error.CryptographyError.TYPE.IGNORED_ASSET,
        z.error.CryptographyError.TYPE.IGNORED_PREVIEW,
        z.error.CryptographyError.TYPE.PREVIOUSLY_STORED,
        z.error.CryptographyError.TYPE.UNHANDLED_TYPE,
        z.error.EventError.TYPE.OUTDATED_E_CALL_EVENT,
        z.error.EventError.TYPE.VALIDATION_FAILED,
      ],
      NOTIFICATION_BATCHES: {
        INITIAL: 500,
        MAX: 10000,
        SUBSEQUENT: 5000,
      },
    };
  }

  static get SOURCE() {
    return {
      BACKEND_RESPONSE: 'backend_response',
      INJECTED: 'injected',
      STREAM: 'Notification Stream',
      WEB_SOCKET: 'WebSocket',
    };
  }

  /**
   * Construct a new Event Repository.
   *
   * @param {z.event.EventService} eventService - Service that handles interactions with events
   * @param {z.event.NotificationService} notificationService - Service handling the notification stream
   * @param {z.event.WebSocketService} webSocketService - Service that connects to WebSocket
   * @param {z.conversation.ConversationService} conversationService - Service to handle conversation related tasks
   * @param {z.cryptography.CryptographyRepository} cryptographyRepository - Repository for all cryptography interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(
    eventService,
    notificationService,
    webSocketService,
    conversationService,
    cryptographyRepository,
    serverTimeRepository,
    userRepository
  ) {
    this.eventService = eventService;
    this.notificationService = notificationService;
    this.webSocketService = webSocketService;
    this.conversationService = conversationService;
    this.cryptographyRepository = cryptographyRepository;
    this.serverTimeRepository = serverTimeRepository;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.event.EventRepository', z.config.LOGGER.OPTIONS);

    this.currentClient = undefined;

    this.notificationHandlingState = ko.observable(z.event.NOTIFICATION_HANDLING_STATE.STREAM);
    this.notificationHandlingState.subscribe(handling_state => {
      amplify.publish(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, handling_state);

      const isHandlingWebSocket = handling_state === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (isHandlingWebSocket) {
        this._handleBufferedNotifications();
        const previouslyHandlingRecovery = this.previousHandlingState === z.event.NOTIFICATION_HANDLING_STATE.RECOVERY;
        if (previouslyHandlingRecovery) {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY);
        }
      }
      this.previousHandlingState = handling_state;
    });

    this.previousHandlingState = this.notificationHandlingState();

    this.notificationsHandled = 0;
    this.notificationsLoaded = ko.observable(false);
    this.notificationsPromises = undefined;
    this.notificationsTotal = 0;
    this.notificationsQueue = ko.observableArray([]);
    this.notificationsBlocked = false;

    this.loadEvent = this.eventService.loadEvent.bind(this.eventService);

    this.notificationsQueue.subscribe(notifications => {
      if (notifications.length) {
        if (this.notificationsBlocked) {
          return;
        }

        const [notification] = notifications;
        this.notificationsBlocked = true;

        return this._handleNotification(notification)
          .catch(error => {
            const errorMessage = `We failed to handle a notification but will continue with queue: ${error.message}`;
            this.logger.warn(errorMessage, error);
          })
          .then(() => {
            this.notificationsBlocked = false;
            this.notificationsQueue.shift();
            this.notificationsHandled++;

            const isHandlingStream = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.STREAM;
            if (isHandlingStream) {
              this._updateProgress();
            }
          });
      }

      const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (this.notificationsLoaded() && !isHandlingWebSocket) {
        this.logger.info(`Done handling '${this.notificationsTotal}' notifications from the stream`);
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);
        this.notificationsLoaded(false);
        this.notificationsPromises[0](this.lastNotificationId());
      }
    });

    this.webSocketBuffer = [];

    this.lastNotificationId = ko.observable();
    this.lastEventDate = ko.observable();

    this.eventProcessMiddlewares = [];

    amplify.subscribe(z.event.WebApp.CONNECTION.ONLINE, this.recoverFromStream.bind(this));
  }

  /**
   * Will set a middleware to run before the EventRepository actually processes the event.
   * Middleware is just a function with the following signature (Event) => Promise<Event>.
   *
   * @param {Array<Function>} middlewares - middlewares to run when a new event is about to be processed
   * @returns {void} - returns nothing
   */
  setEventProcessMiddlewares(middlewares) {
    this.eventProcessMiddlewares = middlewares;
  }

  //##############################################################################
  // WebSocket handling
  //##############################################################################

  /**
   * Initiate the WebSocket connection.
   * @returns {undefined} No return value
   */
  connectWebSocket() {
    if (!this.currentClient().id) {
      throw new z.error.EventError(z.error.EventError.TYPE.NO_CLIENT_ID);
    }

    this.webSocketService.clientId = this.currentClient().id;
    this.webSocketService.connect(notification => {
      const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
      if (isHandlingWebSocket) {
        return this.notificationsQueue.push(notification);
      }
      this._bufferWebSocketNotification(notification);
    });
  }

  /**
   * Close the WebSocket connection.
   * @param {z.event.WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the disconnect
   * @returns {undefined} No return value
   */
  disconnectWebSocket(trigger) {
    this.webSocketService.reset(trigger);
  }

  /**
   * Re-connect the WebSocket connection.
   * @param {z.event.WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reconnect
   * @returns {undefined} No return value
   */
  reconnectWebSocket(trigger) {
    this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.RECOVERY);
    this.webSocketService.reconnect(trigger);
  }

  /**
   * Buffer an incoming notification.
   * @param {Object} notification - Notification data
   * @returns {undefined} No return value
   */
  _bufferWebSocketNotification(notification) {
    this.webSocketBuffer.push(notification);
  }

  /**
   * Handle buffered notifications.
   * @returns {undefined} No return value
   */
  _handleBufferedNotifications() {
    this.logger.info(`Received '${this.webSocketBuffer.length}' notifications via WebSocket while handling stream`);
    if (this.webSocketBuffer.length) {
      z.util.koArrayPushAll(this.notificationsQueue, this.webSocketBuffer);
      this.webSocketBuffer.length = 0;
    }
  }

  //##############################################################################
  // Notification Stream handling
  //##############################################################################

  /**
   * Get notifications for the current client from the stream.
   *
   * @param {string} notificationId - Event ID to start from
   * @param {number} [limit=EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX] - Max. number of notifications to retrieve from backend at once
   * @returns {Promise} Resolves when all new notifications from the stream have been handled
   */
  getNotifications(notificationId, limit = EventRepository.CONFIG.NOTIFICATION_BATCHES.MAX) {
    return new Promise((resolve, reject) => {
      const _gotNotifications = ({has_more: hasAdditionalNotifications, notifications, time}) => {
        if (time) {
          this.serverTimeRepository.computeTimeOffset(time);
        }

        if (notifications.length > 0) {
          notificationId = notifications[notifications.length - 1].id;

          this.logger.info(`Added '${notifications.length}' notifications to the queue`);
          z.util.koArrayPushAll(this.notificationsQueue, notifications);

          if (!this.notificationsPromises) {
            this.notificationsPromises = [resolve, reject];
          }

          this.notificationsTotal += notifications.length;

          if (hasAdditionalNotifications) {
            return this.getNotifications(notificationId, EventRepository.CONFIG.NOTIFICATION_BATCHES.SUBSEQUENT);
          }

          this.notificationsLoaded(true);
          this.logger.info(`Fetched '${this.notificationsTotal}' notifications from the backend`);
          return notificationId;
        }
        this.logger.info(`No notifications found since '${notificationId}'`);
        return reject(new z.error.EventError(z.error.EventError.TYPE.NO_NOTIFICATIONS));
      };

      return this.notificationService
        .getNotifications(this.currentClient().id, notificationId, limit)
        .then(_gotNotifications)
        .catch(errorResponse => {
          // When asking for notifications with a since set to a notification ID that does not belong to our client ID,
          // we will get a 404 AND notifications
          if (errorResponse.notifications) {
            this._missedEventsFromStream();
            return _gotNotifications(errorResponse);
          }

          const isNotFound = errorResponse.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (isNotFound) {
            this.logger.info(`No notifications found since '${notificationId}'`, errorResponse);
            return reject(new z.error.EventError(z.error.EventError.TYPE.NO_NOTIFICATIONS));
          }

          this.logger.error(`Failed to get notifications: ${errorResponse.message}`, errorResponse);
          return reject(new z.error.EventError(z.error.EventError.TYPE.REQUEST_FAILURE));
        });
    });
  }

  /**
   * Get the last notification.
   * @returns {Promise} Resolves with the last handled notification ID
   */
  getStreamState() {
    return this.notificationService
      .getLastNotificationIdFromDb()
      .catch(error => {
        const isNoLastId = error.type === z.error.EventError.TYPE.NO_LAST_ID;
        if (!isNoLastId) {
          throw error;
        }

        this.logger.warn('Last notification ID not found in database. Resetting...');
        return this.setStreamState(this.currentClient().id).then(() => {
          this._missedEventsFromStream();
          return this.lastNotificationId();
        });
      })
      .then(notificationId => {
        this.lastNotificationId(notificationId);
        return this.notificationService.getLastEventDateFromDb();
      })
      .then(eventDate => this.lastEventDate(eventDate))
      .catch(error => {
        const isNoLastDate = error.type === z.error.EventError.TYPE.NO_LAST_DATE;
        if (!isNoLastDate) {
          throw error;
        }

        this.logger.warn('Last event date not found in database. Resetting...');
        this.lastEventDate(new Date(0).toISOString());
      })
      .then(() => ({eventDate: this.lastEventDate(), notificationId: this.lastNotificationId()}));
  }

  /**
   * Set state for notification stream.
   * @returns {Promise} Resolves when all notifications have been handled
   */
  initializeFromStream() {
    return this.getStreamState()
      .then(({notificationId}) => this._updateFromStream(notificationId))
      .catch(error => {
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);

        const isNoLastId = error.type === z.error.EventError.TYPE.NO_LAST_ID;
        if (isNoLastId) {
          this.logger.info('No notifications found for this user', error);
          return 0;
        }

        throw error;
      });
  }

  /**
   * Retrieve missed notifications from the stream after a connectivity loss.
   * @returns {Promise} Resolves when all missed notifications have been handled
   */
  recoverFromStream() {
    this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.RECOVERY);
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY);

    return this._updateFromStream(this._getLastKnownNotificationId())
      .then(numberOfNotifications => {
        this.logger.info(`Retrieved '${numberOfNotifications}' notifications from stream after connectivity loss`);
      })
      .catch(error => {
        const isNoNotifications = error.type === z.error.EventError.TYPE.NO_NOTIFICATIONS;
        if (!isNoNotifications) {
          this.logger.error(`Failed to recover from notification stream: ${error.message}`, error);
          this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);
          // @todo What do we do in this case?
          amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        }
      });
  }

  /**
   * Get the last notification ID and set event date for a given client.
   *
   * @param {string} clientId - Client ID to retrieve last notification ID for
   * @param {boolean} [isInitialization=false] - Set initial date to 0 if not found
   * @returns {Promise} Resolves when stream state has been initialized
   */
  setStreamState(clientId, isInitialization = false) {
    return this.notificationService.getNotificationsLast(clientId).then(({id: notificationId, payload}) => {
      const [event] = payload;
      const isoDateString = this._getIsoDateFromEvent(event, isInitialization);

      if (notificationId) {
        const logMessage = isoDateString
          ? `Set starting point on notification stream to '${notificationId}' (isoDateString)`
          : `Reset starting point on notification stream to '${notificationId}'`;
        this.logger.info(logMessage);

        return Promise.all([this._updateLastEventDate(isoDateString), this._updateLastNotificationId(notificationId)]);
      }
    });
  }

  _getIsoDateFromEvent(event, defaultValue = false) {
    const {client, connection, time: eventDate, type: eventType} = event;

    if (eventDate) {
      return eventDate;
    }

    const isTypeUserClientAdd = eventType === z.event.Backend.USER.CLIENT_ADD;
    if (isTypeUserClientAdd) {
      return client.time;
    }

    const isTypeUserConnection = eventType === z.event.Backend.USER.CONNECTION;
    if (isTypeUserConnection) {
      return connection.lastUpdate;
    }

    if (defaultValue) {
      return new Date(0).toISOString();
    }
  }

  /**
   * Get the ID of the last known notification.
   * @note Notifications that have not yet been handled but are in the queue should not be fetched again on recovery
   *
   * @private
   * @returns {string} ID of last known notification
   */
  _getLastKnownNotificationId() {
    return this.notificationsQueue().length
      ? this.notificationsQueue()[this.notificationsQueue().length - 1].id
      : this.lastNotificationId();
  }

  _missedEventsFromStream() {
    this.notificationService.getMissedIdFromDb().then(notificationId => {
      const lastNotificationIdEqualsMissedId = this.lastNotificationId() === notificationId;
      if (!lastNotificationIdEqualsMissedId) {
        amplify.publish(z.event.WebApp.CONVERSATION.MISSED_EVENTS);
        this.notificationService.saveMissedIdToDb(this.lastNotificationId());
      }
    });
  }

  /**
   * Fetch all missed events from the notification stream since the given last notification ID.
   *
   * @private
   * @param {string} lastNotificationId - Last known notification ID to start update from
   * @returns {Promise} Resolves with the total number of notifications
   */
  _updateFromStream(lastNotificationId) {
    this.notificationsTotal = 0;

    return this.getNotifications(lastNotificationId, EventRepository.CONFIG.NOTIFICATION_BATCHES.INITIAL)
      .then(updatedLastNotificationId => {
        if (updatedLastNotificationId) {
          this.logger.info(`ID of last notification fetched from stream is '${updatedLastNotificationId}'`);
        }
        return this.notificationsTotal;
      })
      .catch(error => {
        this.notificationHandlingState(z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET);

        const isNoNotifications = error.type === z.error.EventError.TYPE.NO_NOTIFICATIONS;
        if (isNoNotifications) {
          this.logger.info('No notifications found for this user', error);
          return 0;
        }

        this.logger.error(`Failed to handle notification stream: ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Persist updated last event timestamp.
   *
   * @private
   * @param {string} eventDate - Updated last event date
   * @returns {Promise} Resolves when the last event date was stored
   */
  _updateLastEventDate(eventDate) {
    const didDateIncrease = eventDate > this.lastEventDate();
    if (didDateIncrease) {
      this.lastEventDate(eventDate);
      return this.notificationService.saveLastEventDateToDb(eventDate);
    }
  }

  /**
   * Persist updated last notification ID.
   *
   * @private
   * @param {string} notificationId - Updated last notification ID
   * @returns {Promise} Resolves when the last notification ID was stored
   */
  _updateLastNotificationId(notificationId) {
    if (notificationId) {
      this.lastNotificationId(notificationId);
      return this.notificationService.saveLastNotificationIdToDb(notificationId);
    }
  }

  _updateProgress() {
    if (this.notificationsHandled % 5 === 0 || this.notificationsHandled < 5) {
      const content = {
        handled: this.notificationsHandled,
        total: this.notificationsTotal,
      };
      const progress = (this.notificationsHandled / this.notificationsTotal) * 50 + 25;

      amplify.publish(z.event.WebApp.APP.UPDATE_PROGRESS, progress, z.string.initDecryption, content);
    }
  }

  //##############################################################################
  // Notification/Event handling
  //##############################################################################

  /**
   * Inject event into a conversation.
   * @note Don't add unable to decrypt to self conversation
   *
   * @param {Object} event - Event payload to be injected
   * @param {z.event.EventRepository.SOURCE} [source=EventRepository.SOURCE.INJECTED] - Source of injection
   * @returns {Promise<Event>} Resolves when the event has been processed
   */
  injectEvent(event, source = EventRepository.SOURCE.INJECTED) {
    if (!event) {
      throw new z.error.EventError(z.error.EventError.TYPE.NO_EVENT);
    }

    const isHandlingWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;
    if (!isHandlingWebSocket) {
      source = EventRepository.SOURCE.INJECTED;
    }

    const {conversation: conversationId, id = 'ID not specified', type} = event;
    const inSelfConversation = conversationId === this.userRepository.self().id;
    if (!inSelfConversation) {
      this.logger.info(`Injected event ID '${id}' of type '${type}'`, event);
      return this._handleEvent(event, source);
    }
    return Promise.resolve(event);
  }

  /**
   * Distribute the given event.
   *
   * @private
   * @param {Object} event - Mapped event to be distributed
   * @param {z.event.EventRepository.SOURCE} source - Source of notification
   * @returns {undefined} No return value
   */
  _distributeEvent(event, source) {
    const {conversation: conversationId, from: userId, type} = event;

    const hasIds = conversationId && userId;
    const logMessage = hasIds
      ? `Distributed '${type}' event for conversation '${conversationId}' from user '${userId}'`
      : `Distributed '${type}' event`;
    this.logger.info(logMessage, event);

    const [category] = type.split('.');
    switch (category) {
      case z.event.EVENT_TYPE.CALL:
        amplify.publish(z.event.WebApp.CALL.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.CONVERSATION:
        amplify.publish(z.event.WebApp.CONVERSATION.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.TEAM:
        amplify.publish(z.event.WebApp.TEAM.EVENT_FROM_BACKEND, event, source);
        break;
      case z.event.EVENT_TYPE.USER:
        amplify.publish(z.event.WebApp.USER.EVENT_FROM_BACKEND, event, source);
        break;
      default:
        amplify.publish(type, event, source);
    }
  }

  /**
   * Handle a single event from the notification stream or WebSocket.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved record or boolean true if the event was skipped
   */
  _handleEvent(event, source) {
    return this._handleEventValidation(event, source)
      .then(validatedEvent => this.processEvent(validatedEvent, source))
      .catch(error => {
        const isIgnoredError = EventRepository.CONFIG.IGNORED_ERRORS.includes(error.type);
        if (!isIgnoredError) {
          throw error;
        }

        return event;
      });
  }

  /**
   * Decrypts, saves and distributes an event received from the backend.
   *
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved record or boolean true if the event was skipped
   */
  processEvent(event, source) {
    const isEncryptedEvent = event.type === z.event.Backend.CONVERSATION.OTR_MESSAGE_ADD;
    const mapEvent = isEncryptedEvent
      ? this.cryptographyRepository.handleEncryptedEvent(event)
      : Promise.resolve(event);

    return mapEvent
      .then(mappedEvent => {
        return this.eventProcessMiddlewares.reduce((eventPromise, middleware) => {
          // use reduce to resolve promises sequentially
          // see https://hackernoon.com/functional-javascript-resolving-promises-sequentially-7aac18c4431e
          return eventPromise.then(middleware);
        }, Promise.resolve(mappedEvent));
      })
      .then(mappedEvent => {
        const shouldSaveEvent = z.event.EventTypeHandling.STORE.includes(mappedEvent.type);
        return shouldSaveEvent ? this._handleEventSaving(mappedEvent, source) : mappedEvent;
      })
      .then(savedEvent => this._handleEventDistribution(savedEvent, source));
  }

  /**
   * Handle a saved event and distribute it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {JSON} The distributed event
   */
  _handleEventDistribution(event, source) {
    const eventDate = this._getIsoDateFromEvent(event);
    const isInjectedEvent = source === EventRepository.SOURCE.INJECTED;
    const canSetEventDate = !isInjectedEvent && eventDate;
    if (canSetEventDate) {
      this._updateLastEventDate(eventDate);
    }

    const isCallEvent = event.type === z.event.Client.CALL.E_CALL;
    if (isCallEvent) {
      this._validateCallEventLifetime(event);
    }

    this._distributeEvent(event, source);

    return event;
  }

  /**
   * Handle a mapped event, check for malicious ID use and save it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the saved event
   */
  _handleEventSaving(event, source) {
    const conversationId = event.conversation;
    const mappedData = event.data || {};

    //first check if a message that should be replaced exists in DB
    const findEventToReplacePromise = mappedData.replacing_message_id
      ? this.eventService.loadEvent(conversationId, mappedData.replacing_message_id)
      : Promise.resolve();

    return findEventToReplacePromise.then(eventToReplace => {
      const hasLinkPreview = mappedData.previews && mappedData.previews.length;
      const isReplacementWithoutOriginal = !eventToReplace && mappedData.replacing_message_id;
      if (isReplacementWithoutOriginal && !hasLinkPreview) {
        // the only valid case of a replacement with no original message is when an edited message gets a link preview
        this._throwValidationError(event, 'Edit event without original event');
      }

      const handleEvent = newEvent => {
        // check for duplicates (same id)
        const loadEventPromise = newEvent.id
          ? this.eventService.loadEvent(conversationId, newEvent.id)
          : Promise.resolve();

        return loadEventPromise.then(storedEvent => {
          return storedEvent
            ? this._handleDuplicatedEvent(storedEvent, newEvent)
            : this.eventService.saveEvent(newEvent);
        });
      };

      return eventToReplace ? this._handleEventReplacement(eventToReplace, event) : handleEvent(event);
    });
  }

  _handleEventReplacement(originalEvent, newEvent) {
    const newData = newEvent.data || {};
    if (originalEvent.data.from !== newData.from) {
      const logMessage = `ID previously used by user '${newEvent.from}'`;
      const errorMessage = 'ID reused by other user';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }
    const primaryKeyUpdate = {primary_key: originalEvent.primary_key};
    const isLinkPreviewEdit = newData.previews && !!newData.previews.length;

    let updates = this._getUpdatesForMessageEdit(originalEvent, newEvent);

    if (isLinkPreviewEdit) {
      updates = Object.assign({}, this._getUpdatesForLinkPreview(originalEvent, newEvent), updates);
    }
    const identifiedUpdates = Object.assign({}, primaryKeyUpdate, updates);
    return this.eventService.replaceEvent(identifiedUpdates);
  }

  _handleDuplicatedEvent(originalEvent, newEvent) {
    switch (newEvent.type) {
      case z.event.Client.CONVERSATION.ASSET_ADD:
        return this._handleAssetUpdate(originalEvent, newEvent);

      case z.event.Client.CONVERSATION.MESSAGE_ADD:
        return this._handleLinkPreviewUpdate(originalEvent, newEvent);

      default:
        this._throwValidationError(newEvent, `Forbidden type '${newEvent.type}' for duplicate events`);
    }
  }

  _handleAssetUpdate(originalEvent, newEvent) {
    const newEventData = newEvent.data;
    // the preview status is not sent by the client so we fake a 'preview' status in order to cleany handle it in the switch statement
    const ASSET_PREVIEW = 'preview';
    const isPreviewEvent = !newEventData.status && newEventData.preview_key;
    const status = isPreviewEvent ? ASSET_PREVIEW : newEventData.status;

    switch (status) {
      case ASSET_PREVIEW:
      case z.assets.AssetTransferState.UPLOADED: {
        const updatedData = Object.assign({}, originalEvent.data, newEventData);
        const updatedEvent = Object.assign({}, originalEvent, {data: updatedData});
        return this.eventService.replaceEvent(updatedEvent);
      }

      case z.assets.AssetTransferState.UPLOAD_FAILED: {
        // case of both failed or canceled upload
        const fromOther = newEvent.from !== this.userRepository.self().id;
        const selfCancel = !fromOther && newEvent.data.reason === z.assets.AssetUploadFailedReason.CANCELLED;
        // we want to delete the event in the case of an error from the remote client or a cancel on the user's own client
        const shouldDeleteEvent = fromOther || selfCancel;
        return shouldDeleteEvent
          ? this.eventService.deleteEvent(newEvent.conversation, newEvent.id).then(() => newEvent)
          : this.eventService.updateEventAsUploadFailed(originalEvent.primary_key, newEvent.data.reason);
      }

      default:
        return this._throwValidationError(newEvent, `Unhandled asset status update '${newEvent.data.status}'`);
    }
  }

  _handleLinkPreviewUpdate(originalEvent, newEvent) {
    const newEventData = newEvent.data;
    const originalData = originalEvent.data;
    if (originalEvent.from !== newEvent.from) {
      const logMessage = `ID previously used by user '${newEvent.from}'`;
      const errorMessage = 'ID reused by other user';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    const containsLinkPreview = newEventData.previews && !!newEventData.previews.length;
    if (!containsLinkPreview) {
      const errorMessage = 'Link preview event does not contain previews';
      this._throwValidationError(newEvent, errorMessage);
    }

    const textContentMatches = newEventData.content === originalData.content;
    if (!textContentMatches) {
      const errorMessage = 'ID of link preview reused';
      const logMessage = 'Text content for link preview not matching';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    const bothAreMessageAddType = newEvent.type === originalEvent.type;
    if (!bothAreMessageAddType) {
      this._throwValidationError(newEvent, 'ID reused by same user');
    }

    const updates = this._getUpdatesForLinkPreview(originalEvent, newEvent);
    const identifiedUpdates = Object.assign({}, {primary_key: originalEvent.primary_key}, updates);
    return this.eventService.replaceEvent(identifiedUpdates);
  }

  _getUpdatesForMessageEdit(originalEvent, newEvent) {
    return Object.assign({}, newEvent, {
      edited_time: newEvent.time,
      time: originalEvent.time,
      version: 1,
    });
  }

  _getUpdatesForLinkPreview(originalEvent, newEvent) {
    const newData = newEvent.data;
    const originalData = originalEvent.data;
    const updatingLinkPreview = !!originalData.previews.length;
    if (updatingLinkPreview) {
      this._throwValidationError(newEvent, 'ID of link preview reused');
    }

    const textContentMatches = !newData.previews.length || newData.content === originalData.content;
    if (!textContentMatches) {
      const logMessage = 'Text content for link preview not matching';
      const errorMessage = 'ID of link preview reused';
      this._throwValidationError(newEvent, errorMessage, logMessage);
    }

    return Object.assign({}, newEvent, {
      category: z.message.MessageCategorization.categoryFromEvent(newEvent),
      ephemeral_expires: originalEvent.ephemeral_expires,
      ephemeral_started: originalEvent.ephemeral_started,
      ephemeral_time: originalEvent.ephemeral_time,
      server_time: newEvent.time,
      time: originalEvent.time,
      version: originalEvent.version,
    });
  }

  _throwValidationError(event, errorMessage, logMessage) {
    const baseLogMessage = `Ignored '${event.type}' (${event.id}) in '${event.conversation}' from '${event.from}':'`;
    const baseErrorMessage = 'Event validation failed:';
    this.logger.warn(`${baseLogMessage} ${logMessage || errorMessage}`, event);
    throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, `${baseErrorMessage} ${errorMessage}`);
  }

  /**
   * Handle an event by validating it.
   *
   * @private
   * @param {JSON} event - Backend event extracted from notification stream
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves with the event
   */
  _handleEventValidation(event, source) {
    return Promise.resolve().then(() => {
      const {time: eventDate, type: eventType} = event;

      const isIgnoredEvent = z.event.EventTypeHandling.IGNORE.includes(eventType);
      if (isIgnoredEvent) {
        this.logger.info(`Event ignored: '${event.type}'`, {event_json: JSON.stringify(event), event_object: event});
        const errorMessage = 'Event ignored: Type ignored';
        throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, errorMessage);
      }

      const eventFromStream = source === EventRepository.SOURCE.STREAM;
      const shouldCheckEventDate = eventFromStream && eventDate;
      if (shouldCheckEventDate) {
        const outdatedEvent = this.lastEventDate() >= new Date(eventDate).toISOString();

        if (outdatedEvent) {
          const logObject = {eventJson: JSON.stringify(event), eventObject: event};
          this.logger.info(`Event from stream skipped as outdated: '${eventType}'`, logObject);
          const errorMessage = 'Event validation failed: Outdated timestamp';
          throw new z.error.EventError(z.error.EventError.TYPE.VALIDATION_FAILED, errorMessage);
        }
      }

      return event;
    });
  }

  /**
   * Handle all events from the payload of an incoming notification.
   *
   * @private
   * @param {Array} events - Events contained in a notification
   * @param {string} id - Notification ID
   * @param {boolean} transient - Type of notification
   * @returns {Promise} Resolves with the ID of the handled notification
   */
  _handleNotification({payload: events, id, transient}) {
    const source = transient !== undefined ? EventRepository.SOURCE.WEB_SOCKET : EventRepository.SOURCE.STREAM;
    const isTransientEvent = !!transient;
    this.logger.info(`Handling notification '${id}' from '${source}' containing '${events.length}' events`, events);

    if (!events.length) {
      this.logger.warn('Notification payload does not contain any events');
      return isTransientEvent ? Promise.resolve(id) : this._updateLastNotificationId(id);
    }

    return Promise.all(events.map(event => this._handleEvent(event, source)))
      .then(() => (isTransientEvent ? id : this._updateLastNotificationId(id)))
      .catch(error => {
        this.logger.error(`Failed to handle notification '${id}' from '${source}': ${error.message}`, error);
        throw error;
      });
  }

  /**
   * Check if call event is handled within its valid lifespan.
   *
   * @private
   * @param {Object} event - Event to validate
   * @returns {boolean} Returns true if event is handled within is lifetime, otherwise throws error
   */
  _validateCallEventLifetime(event) {
    const {content = {}, conversation: conversationId, time, type} = event;
    const forcedEventTypes = [z.calling.enum.CALL_MESSAGE_TYPE.CANCEL, z.calling.enum.CALL_MESSAGE_TYPE.GROUP_LEAVE];

    const correctedTimestamp = this.serverTimeRepository.toServerTimestamp();
    const thresholdTimestamp = new Date(time).getTime() + EventRepository.CONFIG.E_CALL_EVENT_LIFETIME;

    const isForcedEventType = forcedEventTypes.includes(content.type);
    const eventWithinThreshold = correctedTimestamp < thresholdTimestamp;
    const stateIsWebSocket = this.notificationHandlingState() === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isValidEvent = isForcedEventType || eventWithinThreshold || stateIsWebSocket;
    if (isValidEvent) {
      return true;
    }

    const eventIsoDate = new Date(time).toISOString();
    const logMessage = `Ignored outdated '${type}' event (${eventIsoDate}) in conversation '${conversationId}'`;
    const logObject = {
      eventJson: JSON.stringify(event),
      eventObject: event,
      eventTime: eventIsoDate,
      localTime: new Date(correctedTimestamp).toISOString(),
    };
    this.logger.info(logMessage, logObject);
    throw new z.error.EventError(z.error.EventError.TYPE.OUTDATED_E_CALL_EVENT);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

/** Handles all databases interactions related to events */
z.event.EventService = class EventService {
  /**
   * Construct a new Event Service.
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(storageService) {
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.conversation.EventService', z.config.LOGGER.OPTIONS);
    this.EVENT_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.EVENTS;
  }

  /**
   * Load event from database.
   *
   * @param {string} conversationId - ID of conversation
   * @param {string} eventId - ID of event to retrieve
   * @returns {Promise} Resolves with the stored record
   */
  loadEvent(conversationId, eventId) {
    if (!conversationId || !eventId) {
      this.logger.error(`Cannot get event '${eventId}' in conversation '${conversationId}' without IDs`);
      return Promise.reject(new z.error.ConversationError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('id')
      .equals(eventId)
      .filter(record => record.conversation === conversationId)
      .first()
      .catch(error => {
        const logMessage = `Failed to get event '${eventId}' for conversation '${conversationId}': ${error.message}`;
        this.logger.error(logMessage, error);
        throw error;
      });
  }

  /**
   * Load all events that match a minimun category from database.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {MessageCategory} categoryMin - Minimum message category
   * @param {MessageCategory} [categoryMax=z.message.MessageCategory.LIKED] - Maximum message category
   * @returns {Promise} Resolves with matching events
   */
  loadEventsWithCategory(conversationId, categoryMin, categoryMax = z.message.MessageCategory.LIKED) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('[conversation+category]')
      .between([conversationId, categoryMin], [conversationId, categoryMax], true, true)
      .sortBy('time');
  }

  loadEventsReplyingToMessage(conversationId, quotedMessageId, quotedMessageTime) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where(['conversation', 'time'])
      .between([conversationId, quotedMessageTime], [conversationId, new Date().toISOString()], true, true)
      .filter(event => event.data && event.data.quote && event.data.quote.message_id === quotedMessageId)
      .toArray();
  }

  /**
   * Load events starting from the fromDate going back in history until either limit or toDate is reached.
   *
   * @param {string} conversationId - ID of conversation
   * @param {Date} [fromDate=new Date(0)] - Load from this date (included)
   * @param {Date} [toDate=new Date()] - Load until this date (excluded)
   * @param {number} [limit=Number.MAX_SAFE_INTEGER] - Amount of events to load
   * @returns {Promise} Resolves with the retrieved records
   */
  loadPrecedingEvents(conversationId, fromDate = new Date(0), toDate = new Date(), limit = Number.MAX_SAFE_INTEGER) {
    const includeParams = {
      includeFrom: true,
      includeTo: false,
    };

    return this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams)
      .reverse()
      .sortBy('time')
      .catch(error => {
        const message = `Failed to load events for conversation '${conversationId}' from database: '${error.message}'`;
        this.logger.error(message);
        throw error;
      });
  }

  /**
   * Load events starting from the fromDate to the present until the limit is reached.
   *
   * @param {string} conversationId - ID of conversation
   * @param {Date} fromDate - Load until this date (excluded)
   * @param {number} [limit=Number.MAX_SAFE_INTEGER] - Amount of events to load
   * @param {number} [includeFrom=true] - Should upper bound be part of the messages
   * @returns {Promise} Resolves with the retrieved records
   */
  loadFollowingEvents(conversationId, fromDate, limit = Number.MAX_SAFE_INTEGER, includeFrom = true) {
    const includeParams = {
      includeFrom,
      includeTo: true,
    };
    if (!_.isDate(fromDate)) {
      const errorMessage = `fromDate ('${typeof fromDate}') must be of type 'Date'.`;
      throw new Error(errorMessage);
    }
    const toDate = new Date(Math.max(fromDate.getTime() + 1, Date.now()));

    return this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams).sortBy('time');
  }

  _loadEventsInDateRange(conversationId, fromDate, toDate, limit, includes) {
    const {includeFrom, includeTo} = includes;
    if (!_.isDate(toDate) || !_.isDate(fromDate)) {
      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;
      throw new Error(errorMessage);
    }

    if (fromDate.getTime() > toDate.getTime()) {
      const errorMessage = `Lower bound (${fromDate.getTime()}) cannot be greater than upper bound (${toDate.getTime()}).`;
      throw new Error(errorMessage);
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('[conversation+time]')
      .between([conversationId, fromDate.toISOString()], [conversationId, toDate.toISOString()], includeFrom, includeTo)
      .limit(limit);
  }

  /**
   * Save an unencrypted conversation event.
   * Will also recompute the category of the event to be stored.
   *
   * @param {Object} event - JSON event to be stored
   * @returns {Promise<Event>} Resolves with the stored record
   */
  saveEvent(event) {
    event.category = z.message.MessageCategorization.categoryFromEvent(event);
    return this.storageService.save(this.EVENT_STORE_NAME, undefined, event).then(() => event);
  }

  /**
   * Update an unencrypted event.
   *
   * @param {Object} event - JSON event to be stored
   * @returns {Promise<Event>} Resolves with the updated record
   */
  replaceEvent(event) {
    return this.storageService.update(this.EVENT_STORE_NAME, event.primary_key, event).then(() => event);
  }

  /**
   * Update event as uploaded in database.
   *
   * @param {string} primaryKey - Primary key used to find an event in the database
   * @param {Object} event - Updated event asset data
   * @returns {Promise} Resolves when the message was updated in database
   */
  updateEventAsUploadSucceeded(primaryKey, event) {
    return this.storageService.load(this.EVENT_STORE_NAME, primaryKey).then(record => {
      if (!record) {
        return this.logger.warn('Did not find message to update asset (uploaded)', primaryKey);
      }
      const assetData = event.data;

      record.data.id = assetData.id;
      record.data.key = assetData.key;
      record.data.otr_key = assetData.otr_key;
      record.data.sha256 = assetData.sha256;
      record.data.status = z.assets.AssetTransferState.UPLOADED;
      record.data.token = assetData.token;
      record.status = z.message.StatusType.SENT;

      return this.replaceEvent(record).then(() => this.logger.info('Updated asset message_et (uploaded)', primaryKey));
    });
  }

  /**
   * Update event as upload failed in database.
   *
   * @param {string} primaryKey - Primary key used to find an event in the database
   * @param {string} reason - Failure reason
   * @returns {Promise} Resolves when the message was updated in database
   */
  updateEventAsUploadFailed(primaryKey, reason) {
    return this.storageService.load(this.EVENT_STORE_NAME, primaryKey).then(record => {
      if (!record) {
        return this.logger.warn('Did not find message to update asset (failed)', primaryKey);
      }
      record.data.reason = reason;
      record.data.status = z.assets.AssetTransferState.UPLOAD_FAILED;

      return this.replaceEvent(record).then(() => {
        this.logger.info('Updated asset message_et (failed)', primaryKey);
        return record;
      });
    });
  }

  /**
   * Update an unencrypted event.
   * A valid update must not contain a 'version' property.
   *
   * @param {number} primaryKey - event's primary key
   * @param {Object<Event>} [updates={}] - Updates to perform on the message.
   * @returns {Promise} Resolves when the message was updated in database.
   */
  updateEvent(primaryKey, updates) {
    return Promise.resolve(primaryKey).then(key => {
      const hasChanges = updates && !!Object.keys(updates).length;
      if (!hasChanges) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.NO_CHANGES);
      }

      const hasVersionedUpdates = !!updates.version;
      if (hasVersionedUpdates) {
        const error = new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CHANGE);
        error.message += ' Use the `updateEventSequentially` method to perform a versioned update of an event';
        throw error;
      }

      const identifiedUpdates = Object.assign({}, updates, {primary_key: key});
      return this.replaceEvent(identifiedUpdates);
    });
  }

  /**
   * Update an event in the database and checks that the update is sequential.
   *
   * @param {number} primaryKey - Event primary key
   * @param {Object} [changes={}] - Changes to update message with
   * @returns {Promise<Event>} Resolves when the message was updated in database
   */
  updateEventSequentially(primaryKey, changes = {}) {
    return Promise.resolve(primaryKey).then(key => {
      const hasVersionedChanges = !!changes.version;
      if (!hasVersionedChanges) {
        throw new z.error.ConversationError(z.error.ConversationError.TYPE.WRONG_CHANGE);
      }

      // Create a DB transaction to avoid concurrent sequential update.
      return this.storageService.db.transaction('rw', this.EVENT_STORE_NAME, () => {
        return this.storageService.load(this.EVENT_STORE_NAME, key).then(record => {
          if (!record) {
            throw new z.error.StorageError(z.error.StorageError.TYPE.NOT_FOUND);
          }

          const databaseVersion = record.version || 1;

          const isSequentialUpdate = changes.version === databaseVersion + 1;
          if (isSequentialUpdate) {
            return this.storageService.update(this.EVENT_STORE_NAME, primaryKey, changes);
          }

          const logMessage = 'Failed sequential database update';
          const logObject = {
            databaseVersion: databaseVersion,
            updateVersion: changes.version,
          };

          this.logger.error(logMessage, logObject);

          Raygun.send(new Error(logMessage), logObject);
          throw new z.error.StorageError(z.error.StorageError.TYPE.NON_SEQUENTIAL_UPDATE);
        });
      });
    });
  }

  /**
   * Delete an event from a conversation. Duplicates are delete as well.
   *
   * @param {string} conversationId - ID of conversation to remove message from
   * @param {string} eventId - ID of the actual message
   * @returns {Promise} Resolves with the number of deleted records
   */
  deleteEvent(conversationId, eventId) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('id')
      .equals(eventId)
      .and(record => record.conversation === conversationId)
      .delete();
  }

  /**
   * Delete an event from a conversation with the given primary.
   *
   * @param {string} primaryKey - ID of the actual message
   * @returns {Promise} Resolves with the number of deleted records
   */
  deleteEventByKey(primaryKey) {
    return this.storageService.db[this.EVENT_STORE_NAME].delete(primaryKey);
  }

  /**
   * Delete all events of a conversation.
   *
   * @param {string} conversationId - Delete events for this conversation
   * @param {string} [isoDate] - Date in ISO string format as upper bound which events should be removed
   * @returns {Promise} Resolves when the events was deleted
   */
  deleteEvents(conversationId, isoDate) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .filter(record => !isoDate || isoDate >= record.time)
      .delete();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

// TODO: This function can be removed once Microsoft Edge's IndexedDB supports compound indices:
// - https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/
z.event.EventServiceNoCompound = class EventServiceNoCompound extends z.event.EventService {
  constructor(storage_service) {
    super(storage_service);
  }

  /**
   * Get events with given category.
   *
   * @param {string} conversationId - ID of conversation to add users to
   * @param {z.message.MessageCategory} category - Will be used as lower bound
   * @returns {Promise} Resolves with matching events
   */
  loadEventsWithCategory(conversationId, category) {
    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .sortBy('time')
      .then(records => records.filter(record => record.category >= category));
  }

  _loadEventsInDateRange(conversationId, fromDate, toDate, limit, includes) {
    const {includeFrom, includeTo} = includes;
    if (!_.isDate(toDate) || !_.isDate(fromDate)) {
      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;
      throw new Error(errorMessage);
    }

    if (fromDate.getTime() > toDate.getTime()) {
      const errorMessage = `Lower bound (${toDate.getTime()}) cannot be greater than upper bound (${fromDate.getTime()}).`;
      throw new Error(errorMessage);
    }

    return this.storageService.db[this.EVENT_STORE_NAME]
      .where('conversation')
      .equals(conversationId)
      .and(record => {
        const timestamp = new Date(record.time).getTime();
        const fromCompareFunction = includeFrom ? date => timestamp >= date : date => timestamp > date;
        const toCompareFunction = includeTo ? date => timestamp <= date : date => timestamp < date;
        return fromCompareFunction(fromDate) && toCompareFunction(toDate);
      })
      .limit(limit);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EVENT_TYPE = {
  CALL: 'call',
  CONVERSATION: 'conversation',
  TEAM: 'team',
  USER: 'user',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.EventTypeHandling = {
  CONFIRM: [
    z.event.Client.CONVERSATION.ASSET_ADD,
    z.event.Client.CONVERSATION.KNOCK,
    z.event.Client.CONVERSATION.LOCATION,
    z.event.Client.CONVERSATION.MESSAGE_ADD,
  ],
  IGNORE: [z.event.Backend.CONVERSATION.TYPING],
  STORE: [
    z.event.Backend.CONVERSATION.MEMBER_JOIN,
    z.event.Backend.CONVERSATION.MEMBER_LEAVE,
    z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE,
    z.event.Backend.CONVERSATION.RENAME,
    z.event.Client.CONVERSATION.ASSET_ADD,
    z.event.Client.CONVERSATION.DELETE_EVERYWHERE,
    z.event.Client.CONVERSATION.GROUP_CREATION,
    z.event.Client.CONVERSATION.INCOMING_MESSAGE_TOO_BIG,
    z.event.Client.CONVERSATION.KNOCK,
    z.event.Client.CONVERSATION.LOCATION,
    z.event.Client.CONVERSATION.MESSAGE_ADD,
    z.event.Client.CONVERSATION.MISSED_MESSAGES,
    z.event.Client.CONVERSATION.ONE2ONE_CREATION,
    z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE,
    z.event.Client.CONVERSATION.UNABLE_TO_DECRYPT,
    z.event.Client.CONVERSATION.VERIFICATION,
    z.event.Client.CONVERSATION.VOICE_CHANNEL_ACTIVATE,
    z.event.Client.CONVERSATION.VOICE_CHANNEL_DEACTIVATE,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.NOTIFICATION_HANDLING_STATE = {
  RECOVERY: 'z.event.NOTIFICATION_HANDLING_STATE.RECOVERY',
  STREAM: 'z.event.NOTIFICATION_HANDLING_STATE.STREAM',
  WEB_SOCKET: 'z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.NotificationService = class NotificationService {
  static get CONFIG() {
    return {
      PRIMARY_KEY_LAST_EVENT: 'z.storage.StorageKey.EVENT.LAST_DATE',
      PRIMARY_KEY_LAST_NOTIFICATION: 'z.storage.StorageKey.NOTIFICATION.LAST_ID',
      PRIMARY_KEY_MISSED: 'z.storage.StorageKey.NOTIFICATION.MISSED',
      URL_NOTIFICATIONS: '/notifications',
      URL_NOTIFICATIONS_LAST: '/notifications/last',
    };
  }

  /**
   * Construct a new Notification Service.
   *
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   * @param {z.storage.StorageService} storageService - Service for all storage related tasks
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.storageService = storageService;
    this.logger = new z.util.Logger('z.event.NotificationService', z.config.LOGGER.OPTIONS);

    this.AMPLIFY_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.AMPLIFY;
  }

  /**
   * Get notifications from the stream.
   *
   * @param {string} clientId - Only return notifications targeted at the given client
   * @param {string} notificationId - Only return notifications more recent than this notification ID (like "7130304a-c839-11e5-8001-22000b0fe035")
   * @param {number} size - Maximum number of notifications to return
   * @returns {Promise} Resolves with the retrieved notifications
   */
  getNotifications(clientId, notificationId, size) {
    return this.backendClient.sendRequest({
      data: {
        client: clientId,
        since: notificationId,
        size: size,
      },
      type: 'GET',
      url: NotificationService.CONFIG.URL_NOTIFICATIONS,
    });
  }

  /**
   * Get the last notification for a given client.
   * @param {string} clientId - Client ID to retrieve notification ID for
   * @returns {Promise} Resolves with the last known notification ID for given client
   */
  getNotificationsLast(clientId) {
    return this.backendClient.sendRequest({
      data: {
        client: clientId,
      },
      type: 'GET',
      url: NotificationService.CONFIG.URL_NOTIFICATIONS_LAST,
    });
  }

  /**
   * Load last event date from storage.
   * @returns {Promise} Resolves with the stored last event date.
   */
  getLastEventDateFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_EVENT)
      .catch(error => {
        this.logger.error(`Failed to get last event timestamp from storage: ${error.message}`, error);
        throw new z.error.EventError(z.error.EventError.TYPE.DATABASE_FAILURE);
      })
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
        throw new z.error.EventError(z.error.EventError.TYPE.NO_LAST_DATE);
      });
  }

  /**
   * Load last notifications ID from storage.
   * @returns {Promise} Resolves with the stored last notification ID.
   */
  getLastNotificationIdFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_NOTIFICATION)
      .catch(error => {
        this.logger.error(`Failed to get last notification ID from storage: ${error.message}`, error);
        throw new z.error.EventError(z.error.EventError.TYPE.DATABASE_FAILURE);
      })
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
        throw new z.error.EventError(z.error.EventError.TYPE.NO_LAST_ID);
      });
  }

  /**
   * Load missed ID from storage.
   * @returns {Promise} Resolves with the stored missed ID.
   */
  getMissedIdFromDb() {
    return this.storageService
      .load(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_MISSED)
      .then(record => {
        if (record && record.value) {
          return record.value;
        }
      });
  }

  /**
   * Save last event date to storage.
   * @param {string} eventDate - Event date to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveLastEventDateToDb(eventDate) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_EVENT, {
      value: eventDate,
    });
  }

  /**
   * Save last notifications ID to storage.
   * @param {string} notificationId - Notification ID to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveLastNotificationIdToDb(notificationId) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_LAST_NOTIFICATION, {
      value: notificationId,
    });
  }

  /**
   * Save missed notifications ID to storage.
   * @param {string} notificationId - Notification ID to be stored
   * @returns {Promise} Resolves with the stored record
   */
  saveMissedIdToDb(notificationId) {
    return this.storageService.save(this.AMPLIFY_STORE_NAME, NotificationService.CONFIG.PRIMARY_KEY_MISSED, {
      value: notificationId,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};
window.z.event.preprocessor = z.event.preprocessor || {};

z.event.preprocessor.QuotedMessageMiddleware = class QuotedMessageMiddleware {
  /**
   * Construct a new QuotedMessageMiddleware.
   * This class is reponsible for parsing incoming text messages that contains quoted messages.
   * It will handle validating the quote and adding metadata to the event.
   *
   * @param {z.event.EventService} eventService - Repository that handles events
   * @param {z.message.MessageHasher} messageHasher - Handles hashing messages
   */
  constructor(eventService, messageHasher) {
    this.eventService = eventService;
    this.messageHasher = messageHasher;
    this.logger = new z.util.Logger('z.event.preprocessor.QuotedMessageMiddleware', z.config.LOGGER.OPTIONS);
  }

  /**
   * Handles validation of the event if it contains a quote.
   * If the event does contain a quote, will also decorate the event with some metadata regarding the quoted message
   *
   * @param {Object} event - event in the DB format
   * @returns {Object} event - the original event if no quote is found (or does not validate). The decorated event if the quote is valid
   */
  processEvent(event) {
    switch (event.type) {
      case z.event.Client.CONVERSATION.MESSAGE_ADD:
        if (event.data.replacing_message_id) {
          return this._handleEditEvent(event);
        }
        return this._handleAddEvent(event);

      case z.event.Client.CONVERSATION.MESSAGE_DELETE:
        return this._handleDeleteEvent(event);

      default:
        return Promise.resolve(event);
    }
  }

  _handleDeleteEvent(event) {
    const originalMessageId = event.data.message_id;
    return this._findRepliesToMessage(event.conversation, originalMessageId).then(({replies}) => {
      this.logger.info(`Invalidating '${replies.length}' replies to deleted message '${originalMessageId}'`);
      replies.forEach(reply => {
        reply.data.quote = {error: {type: z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND}};
        this.eventService.replaceEvent(reply);
      });
      return event;
    });
  }

  _handleEditEvent(event) {
    const originalMessageId = event.data.replacing_message_id;
    return this._findRepliesToMessage(event.conversation, originalMessageId).then(({originalEvent, replies}) => {
      if (!originalEvent) {
        return event;
      }

      this.logger.info(`Updating '${replies.length}' replies to updated message '${originalMessageId}'`);

      replies.forEach(reply => {
        reply.data.quote.message_id = event.id;
        this.eventService.replaceEvent(reply);
      });

      const decoratedData = Object.assign({}, event.data, {quote: originalEvent.data.quote});
      return Object.assign({}, event, {data: decoratedData});
    });
  }

  _handleAddEvent(event) {
    const rawQuote = event.data && event.data.quote;

    if (!rawQuote) {
      return Promise.resolve(event);
    }

    const quote = z.proto.Quote.decode64(rawQuote);
    this.logger.info('Found quoted message', quote);

    return this.eventService.loadEvent(event.conversation, quote.quoted_message_id).then(quotedMessage => {
      if (!quotedMessage) {
        this.logger.warn(`Quoted message with ID "${quote.quoted_message_id}" not found.`);
        const quoteData = {
          error: {
            type: z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND,
          },
        };

        const decoratedData = Object.assign({}, event.data, {quote: quoteData});
        return Promise.resolve(Object.assign({}, event, {data: decoratedData}));
      }

      return this.messageHasher
        .validateHash(quotedMessage, quote.quoted_message_sha256.toArrayBuffer())
        .then(isValid => {
          let quoteData;

          if (!isValid) {
            this.logger.warn(`Quoted message hash for message ID "${quote.quoted_message_id}" does not match.`);
            quoteData = {
              error: {
                type: z.message.QuoteEntity.ERROR.INVALID_HASH,
              },
            };
          } else {
            quoteData = {
              message_id: quote.quoted_message_id,
              user_id: quotedMessage.from,
            };
          }

          const decoratedData = Object.assign({}, event.data, {quote: quoteData});
          return Promise.resolve(Object.assign({}, event, {data: decoratedData}));
        });
    });
  }

  _findRepliesToMessage(conversationId, messageId) {
    return this.eventService.loadEvent(conversationId, messageId).then(originalEvent => {
      if (!originalEvent) {
        return {
          replies: [],
        };
      }
      return this.eventService
        .loadEventsReplyingToMessage(conversationId, messageId, originalEvent.time)
        .then(replies => ({
          originalEvent,
          replies,
        }));
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};
window.z.event.preprocessor = z.event.preprocessor || {};

z.event.preprocessor.ServiceMiddleware = class ServiceMiddleware {
  /**
   * Construct a new ServiceMiddleware.
   *
   * @param {z.conversation.ConverationRepository} conversationRepository - Repository to handle conversation related tasks
   * @param {z.conversation.UserRepository} userRepository - Repository to handle user related tasks
   */
  constructor(conversationRepository, userRepository) {
    this.userRepository = userRepository;
    this.conversationRepository = conversationRepository;
    this.logger = new z.util.Logger('z.event.preprocessor.ServiceMiddleware', z.config.LOGGER.OPTIONS);
  }

  processEvent(event) {
    switch (event.type) {
      case z.event.Client.CONVERSATION.ONE2ONE_CREATION:
        return this._process1To1ConversationCreationEvent(event);

      case z.event.Backend.CONVERSATION.MEMBER_JOIN:
        return this._processMemberJoinEvent(event);

      default:
        return Promise.resolve(event);
    }
  }

  _processMemberJoinEvent(event) {
    this.logger.info(`Preprocessing event of type ${event.type}`);

    const {conversation: conversationId, data: eventData} = event;
    const selfUserId = this.userRepository.self().id;
    const containsSelfUser = eventData.user_ids.includes(selfUserId);

    const getUsersPromise = containsSelfUser
      ? this.conversationRepository
          .get_conversation_by_id(conversationId)
          .then(conversationEntity => conversationEntity.participating_user_ids())
      : Promise.resolve(eventData.user_ids);

    return getUsersPromise
      .then(userIds => this._containsService(userIds))
      .then(hasService => (hasService ? this._decorateWithHasServiceFlag(event) : event));
  }

  _process1To1ConversationCreationEvent(event) {
    this.logger.info(`Preprocessing event of type ${event.type}`);
    return this._containsService(event.data.userIds).then(hasService => {
      return hasService ? this._decorateWithHasServiceFlag(event) : event;
    });
  }

  _containsService(userIds) {
    return this.userRepository.get_users_by_id(userIds).then(userEntities => {
      return userEntities.some(userEntity => userEntity.isService);
    });
  }

  _decorateWithHasServiceFlag(event) {
    const updatedData = Object.assign({}, event.data, {has_service: true});
    return Object.assign({}, event, {data: updatedData});
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

// Enum of different webapp events.
z.event.WebApp = {
  ANALYTICS: {
    EVENT: 'wire.webapp.analytics.event',
    SUPER_PROPERTY: 'wire.webapp.analytics.super_property',
  },
  APP: {
    UPDATE_PROGRESS: 'wire.webapp.app.update_progress',
  },
  AUDIO: {
    PLAY: 'wire.webapp.audio.play',
    PLAY_IN_LOOP: 'wire.webapp.audio.play_in_loop',
    STOP: 'wire.webapp.audio.stop',
  },
  BACKUP: {
    EXPORT: {
      START: 'wire.webapp.backup.export.start',
    },
    IMPORT: {
      START: 'wire.webapp.backup.import.start',
    },
  },
  BROADCAST: {
    SEND_MESSAGE: 'wire.app.broadcast.send_message',
  },
  CALL: {
    EVENT_FROM_BACKEND: 'wire.webapp.call.event_from_backend',
    MEDIA: {
      ADD_STREAM: 'wire.webapp.call.media.add_stream',
      CHOOSE_SCREEN: 'wire.webapp.call.media.choose_screen',
      CONNECTION_CLOSED: 'wire.webapp.call.media.connection_closed',
      MUTE_AUDIO: 'wire.webapp.call.media.mute_audio',
      TOGGLE: 'wire.webapp.call.media.toggle',
    },
    SIGNALING: {
      DELETE_FLOW: 'wire.webapp.call.signaling.delete_flow',
      POST_FLOWS: 'wire.webapp.call.signaling.post_flows',
      SEND_ICE_CANDIDATE_INFO: 'wire.webapp.call.signaling.send_ice_candidate_info',
      SEND_LOCAL_SDP_INFO: 'wire.webapp.call.signaling.send_local_sdp_info',
    },
    STATE: {
      CHECK: 'wire.webapp.call.state.check',
      DELETE: 'wire.webapp.call.state.delete',
      JOIN: 'wire.webapp.call.state.join',
      LEAVE: 'wire.webapp.call.state.leave',
      REJECT: 'wire.webapp.call.state.reject',
      REMOVE_PARTICIPANT: 'wire.webapp.call.state.remove_participant',
      TOGGLE: 'wire.webapp.call.state.toggle',
    },
  },
  CLIENT: {
    ADD: 'wire.webapp.user.client.add',
    REMOVE: 'wire.webapp.client.remove',
    UPDATE: 'wire.webapp.client.update',
    VERIFICATION_STATE_CHANGED: 'wire.webapp.client.verification_state_changed',
  },
  CONNECT: {
    IMPORT_CONTACTS: 'wire.webapp.connect.import_contacts',
  },
  CONNECTION: {
    ACCESS_TOKEN: {
      RENEW: 'wire.webapp.connection.access_token.renew',
      RENEWED: 'wire.webapp.connection.access_token.renewed',
    },
    ONLINE: 'wire.webapp.connection.online',
  },
  CONTENT: {
    SWITCH: 'wire.webapp.content.switch',
  },
  CONTEXT_MENU: 'wire.webapp.context_menu',
  CONVERSATION: {
    ASSET: {
      CANCEL: 'wire.webapp.conversation.asset.cancel',
    },
    CREATE_GROUP: 'wire.webapp.conversation.create_group',
    DEBUG: 'wire.webapp.conversation.debug',
    DETAIL_VIEW: {
      SHOW: 'wire.webapp.conversation.detail_view.show',
    },
    EPHEMERAL_MESSAGE_TIMEOUT: 'wire.webapp.conversation.ephemeral_message_timeout',
    EVENT_FROM_BACKEND: 'wire.webapp.conversation.event_from_backend',
    IMAGE: {
      SEND: 'wire.webapp.conversation.image.send',
    },
    MAP_CONNECTION: 'wire.webapp.conversation.map_connection',
    MESSAGE: {
      ADDED: 'wire.webapp.conversation.message.added',
      EDIT: 'wire.webapp.conversation.message.edit',
      REMOVED: 'wire.webapp.conversation.message.removed',
      REPLY: 'wire.webapp.conversation.message.reply',
      UPDATED: 'wire.webapp.conversation.message.updated',
    },
    MISSED_EVENTS: 'wire.webapp.conversation.missed_events',
    PEOPLE: {
      HIDE: 'wire.webapp.conversation.people.hide',
    },
    PERSIST_STATE: 'wire.webapp.conversation.persist_state',
    SHOW: 'wire.webapp.conversation.show',
  },
  DEBUG: {
    UPDATE_LAST_CALL_STATUS: 'wire.webapp.debug.update_last_call_status',
  },
  EVENT: {
    NOTIFICATION_HANDLING_STATE: 'wire.webapp.event.notification_handling',
  },
  EXTENSIONS: {
    GIPHY: {
      SEND: 'wire.webapp.extionsions.giphy.send',
      SHOW: 'wire.webapp.extionsions.giphy.show',
    },
  },
  INPUT: {
    RESIZE: 'wire.webapp.input.resize',
  },
  LEFT: {
    FADE_IN: 'wire.webapp.left.fade_in',
    HIDE: 'wire.webapp.left.hide',
  },
  LIFECYCLE: {
    ASK_TO_CLEAR_DATA: 'wire.webapp.lifecycle.ask_to_clear_data',
    LOADED: 'wire.webapp.lifecycle.loaded',
    REFRESH: 'wire.webapp.lifecycle.refresh',
    RESTART: 'wire.webapp.lifecycle.restart',
    SIGN_OUT: 'wire.webapp.lifecycle.sign_out',
    SIGNED_OUT: 'wire.webapp.lifecycle.signed_out',
    UNREAD_COUNT: 'wire.webapp.lifecycle.unread_count',
    UPDATE: 'wire.webapp.lifecycle.update',
  },
  NOTIFICATION: {
    CLICK: 'wire.webapp.notification.click',
    NOTIFY: 'wire.webapp.notification.notify',
    PERMISSION_STATE: 'wire.webapp.notification.permissionState',
    REMOVE_READ: 'wire.webapp.notification.remove_read',
    SHOW: 'wire.webapp.notification.show',
  },
  PENDING: {
    SHOW: 'wire.webapp.pending.show',
  },
  PREFERENCES: {
    MANAGE_ACCOUNT: 'wire.webapp.preferences.manage_account',
    MANAGE_DEVICES: 'wire.webapp.preferences.manage_devices',
    UPLOAD_PICTURE: 'wire.webapp.preferences.upload_picture',
  },
  PROFILE: {
    SETTINGS: {
      SHOW: 'wire.webapp.profile.settings.show',
    },
  },
  PROPERTIES: {
    UPDATE: {
      CONTACTS: 'wire.webapp.properties.update.contacts',
      EMOJI: {
        REPLACE_INLINE: 'wire.webapp.properties.update.emoji.replace_inline',
      },
      NOTIFICATIONS: 'wire.webapp.properties.update.notifications',
      PREVIEWS: {
        SEND: 'wire.webapp.properties.update.previews.send',
      },
      PRIVACY: 'wire.webapp.properties.update.privacy',
      SOUND_ALERTS: 'wire.webapp.properties.update.sound_alerts',
    },
    UPDATED: 'wire.webapp.properties.updated',
  },
  SEARCH: {
    BADGE: {
      HIDE: 'wire.webapp.search.badge.hide',
      SHOW: 'wire.webapp.search.badge.show',
    },
    HIDE: 'wire.webapp.search.hide',
    SHOW: 'wire.webapp.search.show',
  },
  SHORTCUT: {
    ADD_PEOPLE: 'wire.webapp.shortcut.add_people',
    ARCHIVE: 'wire.webapp.shortcut.archive',
    CALL_MUTE: 'wire.webapp.shortcut.call_mute',
    CALL_REJECT: 'wire.webapp.shortcut.call_reject',
    DELETE: 'wire.webapp.shortcut.delete',
    NEXT: 'wire.webapp.shortcut.next',
    NOTIFICATIONS: 'wire.webapp.shortcut.notifications',
    PEOPLE: 'wire.webapp.shortcut.people',
    PICTURE: 'wire.webapp.shortcut.picture',
    PING: 'wire.webapp.shortcut.ping',
    PREV: 'wire.webapp.shortcut.prev',
    SILENCE: 'wire.webapp.shortcut.silence', // todo: deprecated - remove when user base of wrappers version >= 3.4 is large enough
    START: 'wire.webapp.shortcut.start',
  },
  SIGN_OUT: 'wire.webapp.logout',
  STORAGE: {
    SAVE_ENTITY: 'wire.webapp.storage.save_entity',
  },
  SYSTEM_NOTIFICATION: {
    CLICK: 'wire.webapp.notification.click', // todo: deprecated - remove when user base of wrappers version >= 3.2 is large enough
  },
  TEAM: {
    EVENT_FROM_BACKEND: 'wire.webapp.team.event_from_backend',
    INFO: 'wire.webapp.team.info',
    MEMBER_LEAVE: 'wire.webapp.team.member_leave',
    UPDATE_INFO: 'wire.webapp.team.update_info',
  },
  TELEMETRY: {
    BACKEND_REQUESTS: 'wire.webapp.telemetry.backend_requests',
  },
  USER: {
    CLIENT_ADDED: 'wire.webapp.user.client_added',
    CLIENT_REMOVED: 'wire.webapp.user.client_removed',
    CLIENTS_UPDATED: 'wire.webapp.user.clients_updated',
    EVENT_FROM_BACKEND: 'wire.webapp.user.event_from_backend',
    PERSIST: 'wire.webapp.user.persist',
    SET_AVAILABILITY: 'wire.webapp.user.set_availability',
    UNBLOCKED: 'wire.webapp.user.unblocked',
    UPDATE: 'wire.webapp.user.update',
  },
  WARNING: {
    DISMISS: 'wire.webapp.warning.dismiss',
    MODAL: 'wire.webapp.warning.modal',
    SHOW: 'wire.webapp.warning.show',
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.event = z.event || {};

z.event.WebSocketService = class WebSocketService {
  static get CHANGE_TRIGGER() {
    return {
      CLEANUP: 'WebSocketService.CHANGE_TRIGGER.CLEANUP',
      CLOSE: 'WebSocketService.CHANGE_TRIGGER.CLOSE',
      ERROR: 'WebSocketService.CHANGE_TRIGGER.ERROR',
      LOGOUT: 'WebSocketService.CHANGE_TRIGGER.LOGOUT',
      LONG_INACTIVITY: 'WebSocketService.CHANGE_TRIGGER.LONG_INACTIVITY',
      OFFLINE: 'WebSocketService.CHANGE_TRIGGER.OFFLINE',
      ONLINE: 'WebSocketService.CHANGE_TRIGGER.ONLINE',
      PAGE_NAVIGATION: 'WebSocketService.CHANGE_TRIGGER.PAGE_NAVIGATION',
      PING_INTERVAL: 'WebSocketService.CHANGE_TRIGGER.PING_INTERVAL',
      READY_STATE: 'WebSocketService.CHANGE_TRIGGER.READY_STATE',
      WARNING_BAR: 'WebSocketService.CHANGE_TRIGGER.WARNING_BAR',
    };
  }

  static get CONFIG() {
    return {
      PING_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 30,
      PING_INTERVAL_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
      RECONNECT_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 15,
    };
  }

  /**
   * Construct a new WebSocket Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.sendPing = this.sendPing.bind(this);

    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.event.WebSocketService', z.config.LOGGER.OPTIONS);

    this.clientId = undefined;
    this.connectionUrl = '';
    this.socket = undefined;

    this.onNotification = undefined;

    this.pingIntervalId = undefined;
    this.lastPingTime = undefined;

    this.reconnectTimeoutId = undefined;
    this.reconnectCount = 0;

    this.pendingReconnectTrigger = undefined;

    amplify.subscribe(z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEWED, this.pendingReconnect.bind(this));
  }

  /**
   * Establish the WebSocket connection.
   * @param {Function} onNotification - Function to be called on incoming notifications
   * @returns {Promise} Resolves once the WebSocket connects
   */
  connect(onNotification) {
    this.onNotification = onNotification;

    return new Promise((resolve, reject) => {
      this.connectionUrl = `${this.backendClient.webSocketUrl}/await?access_token=${this.backendClient.accessToken}`;
      if (this.clientId) {
        this.connectionUrl = z.util.URLUtil.appendParameter(this.connectionUrl, `client=${this.clientId}`);
      }

      const wrongSocketType = typeof this.socket === 'object';
      if (wrongSocketType) {
        this.reset(WebSocketService.CHANGE_TRIGGER.CLEANUP);
      }

      this.socket = new WebSocket(this.connectionUrl);
      this.socket.binaryType = 'blob';

      // http://stackoverflow.com/a/27828483/451634
      delete this.socket.URL;

      this.socket.onopen = () => {
        this.logger.info(`Connected WebSocket to: ${this.backendClient.webSocketUrl}/await`);
        this.pingIntervalId = window.setInterval(this.sendPing, WebSocketService.CONFIG.PING_INTERVAL);
        resolve();
      };

      this.socket.onerror = event => {
        this.logger.error('WebSocket connection error.', event);
        this.reset(WebSocketService.CHANGE_TRIGGER.ERROR, true);
      };

      this.socket.onclose = event => {
        this.logger.warn('Closed WebSocket connection', event);
        this.reset(WebSocketService.CHANGE_TRIGGER.CLOSE, true);
      };

      this.socket.onmessage = event => {
        if (this._pingHasExperiencedSuspiciousInactivity()) {
          const secondsSinceLastPing = (Date.now() - this.lastPingTime) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
          this.logger.warn(`Message received but ping was inactive for "${secondsSinceLastPing}" sec, reconnecting.`);
          return this.reconnect(WebSocketService.CHANGE_TRIGGER.LONG_INACTIVITY);
        }
        if (event.data instanceof Blob) {
          const blobReader = new FileReader();
          blobReader.onload = () => onNotification(JSON.parse(blobReader.result));
          blobReader.readAsText(event.data);
        }
      };
    });
  }

  /**
   * Reconnect WebSocket after access token has been refreshed.
   * @returns {undefined} No return value
   */
  pendingReconnect() {
    if (this.pendingReconnectTrigger) {
      this.logger.info(`Reconnecting WebSocket (TRIGGER: ${this.pendingReconnectTrigger}) after access token refresh`);
      this.reconnect(this.pendingReconnectTrigger);
      this.pendingReconnectTrigger = undefined;
    }
  }

  /**
   * Try to re-establish the WebSocket connection.
   * @param {WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reconnect
   * @returns {undefined} No return value
   */
  reconnect(trigger) {
    if (!z.util.StorageUtil.getValue(z.storage.StorageKey.AUTH.ACCESS_TOKEN.EXPIRATION)) {
      this.logger.info(`Access token has to be refreshed before reconnecting the WebSocket triggered by '${trigger}'`);
      this.pendingReconnectTrigger = trigger;
      return amplify.publish(
        z.event.WebApp.CONNECTION.ACCESS_TOKEN.RENEW,
        z.auth.AuthRepository.ACCESS_TOKEN_TRIGGER.WEB_SOCKET
      );
    }

    this.reconnectCount++;
    const reconnect = () => {
      this.logger.info(`Trying to re-establish WebSocket connection. Try #${this.reconnectCount}`);
      return this.connect(this.onNotification).then(() => {
        this.reconnectCount = 0;
        this.logger.info(`Reconnect to WebSocket triggered by '${trigger}'`);
        return this.reconnected();
      });
    };

    const isFirstReconnectAttempt = this.reconnectCount === 1;
    if (isFirstReconnectAttempt) {
      return reconnect();
    }
    this.reconnectTimeoutId = window.setTimeout(() => reconnect(), WebSocketService.CONFIG.RECONNECT_INTERVAL);
  }

  /**
   * Behavior when WebSocket connection is re-established after a connection drop.
   * @returns {undefined} No return value
   */
  reconnected() {
    amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
    this.logger.warn('Re-established WebSocket connection. Recovering from Notification Stream...');
    amplify.publish(z.event.WebApp.CONNECTION.ONLINE);
  }

  /**
   * Reset the WebSocket connection.
   *
   * @param {WebSocketService.CHANGE_TRIGGER} trigger - Trigger of the reset
   * @param {boolean} [reconnect=false] - Re-establish the WebSocket connection
   * @returns {undefined} No return value
   */
  reset(trigger, reconnect = false) {
    if (this.socket && this.socket.onclose) {
      this.logger.info(`WebSocket reset triggered by '${trigger}'`);
      this.socket.onerror = undefined;
      this.socket.onclose = undefined;
      this.socket.close();
      window.clearInterval(this.pingIntervalId);
      window.clearTimeout(this.reconnectTimeoutId);
      this.lastPingTime = undefined;
    }

    if (reconnect) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
      this.reconnect(trigger);
    }
  }

  /**
   * Send a WebSocket ping.
   * @returns {undefined} No return value
   */
  sendPing() {
    const isReadyStateOpen = this.socket.readyState === 1;
    if (isReadyStateOpen) {
      if (this._pingHasExperiencedSuspiciousInactivity()) {
        this.logger.warn('Ping interval check failed');
        return this.reconnect(WebSocketService.CHANGE_TRIGGER.PING_INTERVAL);
      }
      this.logger.info('Sending ping to WebSocket');
      this.lastPingTime = Date.now();
      return this.socket.send('Wire is so much nicer with internet!');
    }

    this.logger.warn(`WebSocket connection is closed. Current ready state: ${this.socket.readyState}`);
    this.reconnect(WebSocketService.CHANGE_TRIGGER.READY_STATE);
  }

  /**
   * Returns true if the gap between the last ping and the current time is too big.
   *
   * @returns {boolean} Was the last ping too long ago
   */
  _pingHasExperiencedSuspiciousInactivity() {
    const currentTime = Date.now();
    const lastPingTime = this.lastPingTime || currentTime;
    const pingIntervalDifference = currentTime - lastPingTime;

    const maxDifference = WebSocketService.CONFIG.PING_INTERVAL + WebSocketService.CONFIG.PING_INTERVAL_THRESHOLD;
    return pingIntervalDifference > maxDifference;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

z.extension.GiphyService = class GiphyService {
  static get CONFIG() {
    return {
      ENDPOINT_BASE: '/proxy/giphy/v1/gifs',
    };
  }

  /**
   * Construct a new Giphy Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
  }

  /**
   * Get GIFs for IDs.
   * @param {string|Array} ids - A single id or comma separated list of IDs to fetch GIF size data
   * @returns {Promise} Resolves with the size data
   */
  getById(ids) {
    ids = [].concat(ids);

    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/${ids.join(',')}`,
    });
  }

  /**
   * Search all Giphy GIFs for a word or phrase.
   * @param {string} tag - GIF tag to limit randomness by
   * @returns {Promise} Resolves with random gifs for given tag
   */
  getRandom(tag) {
    return this.backendClient.sendRequest({
      data: {
        tag: tag,
      },
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/random`,
    });
  }

  /**
   * Search GIFs for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.q - Search query term or phrase
   * @param {number} [options.limit=25] - Number of results to return (maximum 100)
   * @param {number} [options.offset=0] - Results offset
   * @param {string} [options.sorting='relevant'] - Specify sorting ('relevant' or 'recent')
   * @returns {Promise} Resolves with matches
   */
  getSearch(options) {
    return this.backendClient.sendRequest({
      data: Object.assign(
        {
          limit: 25,
          offset: 0,
          sort: 'relevant',
        },
        options
      ),
      type: 'GET',
      url: `${GiphyService.CONFIG.ENDPOINT_BASE}/search`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

z.extension.GiphyRepository = class GiphyRepository {
  static get CONFIG() {
    return {
      MAX_RETRIES: 3,
      MAX_SIZE: 3 * 1024 * 1024, // 3MB
      NUMBER_OF_RESULTS: 6,
    };
  }

  /**
   * Construct a new Giphy Repository.
   * @param {z.extension.GiphyService} giphyService - Giphy REST API implementation
   */
  constructor(giphyService) {
    this.giphyService = giphyService;
    this.logger = new z.util.Logger('z.extension.GiphyRepository', z.config.LOGGER.OPTIONS);
    this.gifQueryCache = {};
  }

  /**
   * Get random GIF for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.tag - Search query term or phrase
   * @param {number} [options.retry=3] - How many retries to get the correct size
   * @param {number} [options.max_size=3MB] - Maximum gif size in bytes
   * @returns {Promise} Resolves with a random matching gif
   */
  getRandomGif(options) {
    options = $.extend(
      {
        maxRetries: GiphyRepository.CONFIG.MAX_RETRIES,
        maxSize: GiphyRepository.CONFIG.MAX_SIZE,
      },
      options
    );

    const _getRandomGif = (retry = 0) => {
      const hasReachedRetryLimit = retry >= options.maxRetries;
      if (hasReachedRetryLimit) {
        throw new Error(`Unable to fetch a proper gif within ${options.maxRetries} retries`);
      }

      return this.giphyService
        .getRandom(options.tag)
        .then(({data: randomGif}) => {
          if (!randomGif.id) {
            throw new Error(`Could not find any gif with tag '${options.tag}'`);
          }
          return this.giphyService.getById(randomGif.id);
        })
        .then(({data: {images, url}}) => {
          const staticGif = images[z.extension.GiphyContentSizes.FIXED_WIDTH_STILL];
          const animatedGif = images[z.extension.GiphyContentSizes.DOWNSIZED];

          const exceedsMaxSize = animatedGif.size > options.maxSize;
          if (exceedsMaxSize) {
            this.logger.info(`Gif size (${animatedGif.size}) is over maximum size (${animatedGif.size})`);
            return _getRandomGif(retry + 1);
          }

          return {
            animated: animatedGif.url,
            static: staticGif.url,
            url: url,
          };
        });
    };

    return _getRandomGif();
  }

  /**
   * Get random GIFs for a word or phrase.
   *
   * @param {Object} options - Search options
   * @param {string} options.query - Search query term or phrase
   * @param {number} options.number - Amount of GIFs to retrieve
   * @param {number} [options.max_size=3MB] - Maximum gif size in bytes
   * @param {boolean} [options.random=true] - Will return an randomized result
   * @param {string} [options.sorting='recent'] - Specify sorting ('relevant' or 'recent')
   * @returns {Promise} Resolves with gifs
   */
  getGifs(options) {
    let offset = 0;

    options = $.extend(
      {
        maxSize: GiphyRepository.CONFIG.MAX_SIZE,
        random: true,
        results: GiphyRepository.CONFIG.NUMBER_OF_RESULTS,
        sorting: 'relevant',
      },
      options
    );

    if (!options.query) {
      const error = new Error('No query specified');
      this.logger.error(error.message, error);
      throw error;
    }

    if (options.random) {
      const total = this.gifQueryCache[options.query];
      if (total) {
        const resultExceedsTotal = options.results >= total;
        offset = resultExceedsTotal ? 0 : Math.floor(Math.random() * (total - options.number));
      }
    }

    return this.giphyService
      .getSearch({
        limit: 100,
        offset: offset,
        // eslint-disable-next-line id-length
        q: options.query,
        sort: options.sorting,
      })
      .then(({data: gifs, pagination}) => {
        const result = [];

        if (options.random) {
          gifs = gifs.sort(() => 0.5 - Math.random());
        }

        this.gifQueryCache[options.query] = pagination.total_count;

        for (const {images, url} of gifs.slice(0, options.number)) {
          const staticGif = images[z.extension.GiphyContentSizes.FIXED_WIDTH_STILL];
          const animatedGif = images[z.extension.GiphyContentSizes.DOWNSIZED];

          const exceedsMaxSize = animatedGif.size > options.maxSize;
          if (!exceedsMaxSize) {
            result.push({
              animated: animatedGif.url,
              static: staticGif.url,
              url: url,
            });
          }
        }

        return result;
      })
      .catch(error => {
        this.logger.info(`Unable to fetch gif for query: ${options.query}`, error);
        throw error;
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.extension = z.extension || {};

// Enum of different Giphy content sizes.
z.extension.GiphyContentSizes = {
  DOWNSIZED: 'downsized',
  DOWNSIZED_LARGE: 'downsized_large',
  DOWNSIZED_STILL: 'downsized_still',
  FIXED_HEIGHT: 'fixed_height',
  FIXED_HEIGHT_DOWNSAMPLED: 'fixed_height_downsampled',
  FIXED_HEIGHT_SMALL: 'fixed_height_small',
  FIXED_HEIGHT_SMALL_STILL: 'fixed_height_small_still',
  FIXED_HEIGHT_STILL: 'fixed_height_still',
  FIXED_WIDTH: 'fixed_width',
  FIXED_WIDTH_DOWNSAMPLED: 'fixed_width_downsampled',
  FIXED_WIDTH_SMALL: 'fixed_width_small',
  FIXED_WIDTH_SMALL_STILL: 'fixed_width_small_still',
  FIXED_WIDTH_STILL: 'fixed_width_still',
  ORIGINAL: 'original',
  ORIGINAL_STILL: 'original_still',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationMapper = (() => {
  const _mapProviderFromObject = providerData => {
    return _updateProviderFromObject(providerData);
  };

  const _mapServicesFromArray = (servicesData = []) => {
    return servicesData
      .filter(serviceData => serviceData.enabled)
      .map(serviceData => _updateServiceFromObject(serviceData));
  };

  const _mapServiceFromObject = serviceData => {
    return _updateServiceFromObject(serviceData);
  };

  const _updateProviderFromObject = (providerData, providerEntity = new z.integration.ProviderEntity()) => {
    if (providerData) {
      const {description, email, id, name, url} = providerData;

      if (id) {
        providerEntity.id = id;
      }

      if (description) {
        providerEntity.description = description;
      }

      if (email) {
        providerEntity.email = email;
      }

      if (name) {
        providerEntity.name = name;
      }

      if (url) {
        providerEntity.url = url;
      }
    }

    return providerEntity;
  };

  const _updateServiceFromObject = (serviceData, serviceEntity = new z.integration.ServiceEntity()) => {
    if (serviceData) {
      const {assets, description, id, name, provider: providerId, summary, tags} = serviceData;

      if (id) {
        serviceEntity.id = id;
      }

      if (assets && assets.length) {
        const mappedAssets = z.assets.AssetMapper.mapProfileAssets(serviceEntity.id, assets);
        z.assets.AssetMapper.updateUserEntityAssets(serviceEntity, mappedAssets);
      }

      if (description) {
        serviceEntity.description = description;
      }

      if (name) {
        serviceEntity.name = name;
      }

      if (providerId) {
        serviceEntity.providerId = providerId;
      }

      if (summary) {
        serviceEntity.summary = summary;
      }

      if (tags) {
        serviceEntity.tags = tags;
      }
    }

    return serviceEntity;
  };

  return {
    mapProviderFromObject: _mapProviderFromObject,
    mapServiceFromObject: _mapServiceFromObject,
    mapServicesFromArray: _mapServicesFromArray,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationRepository = class IntegrationRepository {
  /**
   * Trim query string for search.
   * @param {string} query - Service search string
   * @returns {string} Normalized service search query
   */
  static normalizeQuery(query) {
    if (!_.isString(query)) {
      return '';
    }
    return query.trim().toLowerCase();
  }

  constructor(integrationService, conversationRepository, teamRepository) {
    this.logger = new z.util.Logger('z.integration.IntegrationRepository', z.config.LOGGER.OPTIONS);

    this.integrationService = integrationService;

    this.conversationRepository = conversationRepository;
    this.teamRepository = teamRepository;

    this.isTeam = this.teamRepository.isTeam;
    this.services = ko.observableArray([]);
  }

  /**
   * Get provider name for entity.
   * @param {ServiceEntity|User} entity - Service or user to add provider name to
   * @returns {Promise} - Resolves with the entity
   */
  addProviderNameToParticipant(entity) {
    const shouldUpdateProviderName = entity.providerName && !entity.providerName().trim();
    return shouldUpdateProviderName
      ? this.getProviderById(entity.providerId).then(providerEntity => {
          entity.providerName(providerEntity.name);
          return entity;
        })
      : entity;
  }

  /**
   * Get ServiceEntity for entity.
   * @param {z.integration.ServiceEntity|User} entity - Service or user to resolve to ServiceEntity
   * @returns {Promise} - Resolves with the ServiceEntity
   */
  getServiceFromUser(entity) {
    if (entity instanceof z.integration.ServiceEntity) {
      return Promise.resolve(entity);
    }
    const {providerId, serviceId} = entity;
    return this.getServiceById(providerId, serviceId);
  }

  /**
   * Add a service to an existing conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to add service to
   * @param {z.integration.ServiceEntity} serviceEntity - Service to be added to conversation
   * @param {string} method - Method used to add service
   * @returns {Promise} Resolves when service was added
   */
  addService(conversationEntity, serviceEntity, method) {
    const {id: serviceId, name, providerId} = serviceEntity;
    this.logger.info(`Adding service '${name}' to conversation '${conversationEntity.id}'`, serviceEntity);

    return this.conversationRepository.addService(conversationEntity, providerId, serviceId).then(event => {
      if (event) {
        const attributes = {
          conversation_size: conversationEntity.getNumberOfParticipants(true, false),
          method: method,
          service_id: serviceId,
          services_size: conversationEntity.getNumberOfServices(),
        };

        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.INTEGRATION.ADDED_SERVICE, attributes);
      }

      return event;
    });
  }

  /**
   * Add service to conversation.
   *
   * @param {z.integration.ServiceEntity} serviceEntity - Information about service to be added
   * @returns {Promise} Resolves when conversation with the integration was was created
   */
  create1to1ConversationWithService(serviceEntity) {
    return this.conversationRepository
      .createGroupConversation([], undefined, z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM)
      .then(conversationEntity => {
        if (conversationEntity) {
          return this.addService(conversationEntity, serviceEntity, 'start_ui').then(() => conversationEntity);
        }

        throw new z.error.ConversationError(z.error.ConversationError.TYPE.CONVERSATION_NOT_FOUND);
      })
      .catch(error => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
          text: {
            message: z.l10n.text(z.string.modalIntegrationUnavailableMessage),
            title: z.l10n.text(z.string.modalIntegrationUnavailableHeadline),
          },
        });
        throw error;
      });
  }

  /**
   * Get conversation with a service.
   * @param {Service} serviceEntity - Service entity for whom to get the conversation
   * @returns {Promise} Resolves with the conversation with requested service
   */
  get1To1ConversationWithService(serviceEntity) {
    const matchingConversationEntity = this.conversationRepository.conversations().find(conversationEntity => {
      if (!conversationEntity.is1to1()) {
        // Disregard conversations that are not 1:1
        return false;
      }

      const isActiveConversation = !conversationEntity.removed_from_conversation();
      if (!isActiveConversation) {
        // Disregard coversations that self is no longer part of
        return false;
      }

      const [userEntity] = conversationEntity.participating_user_ets();
      if (!userEntity) {
        // Disregard conversations with no user entities
        return false;
      }

      if (!userEntity.isService) {
        // Disregard conversations with users instead of services
        return false;
      }

      const {serviceId, providerId} = userEntity;
      const isExpectedServiceId = serviceEntity.id === serviceId;
      const isExpectedProviderId = serviceEntity.providerId === providerId;
      return isExpectedServiceId && isExpectedProviderId;
    });

    return matchingConversationEntity
      ? Promise.resolve(matchingConversationEntity)
      : this.create1to1ConversationWithService(serviceEntity);
  }

  getProviderById(providerId) {
    return this.integrationService.getProvider(providerId).then(providerData => {
      if (providerData) {
        return z.integration.IntegrationMapper.mapProviderFromObject(providerData);
      }
    });
  }

  getServiceById(providerId, serviceId) {
    return this.integrationService.getService(providerId, serviceId).then(serviceData => {
      if (serviceData) {
        return z.integration.IntegrationMapper.mapServiceFromObject(serviceData);
      }
    });
  }

  getServices(tags, start) {
    const tagsArray = _.isArray(tags) ? tags.slice(0, 3) : [z.integration.ServiceTag.INTEGRATION];

    return this.integrationService.getServices(tagsArray.join(','), start).then(({services: servicesData}) => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  getServicesByProvider(providerId) {
    return this.integrationService.getProviderServices(providerId).then(servicesData => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  /**
   * Remove service from conversation.
   *
   * @param {Conversation} conversationEntity - Conversation to remove service from
   * @param {z.entity.User} userEntity - Service user to be removed from the conversation
   * @returns {Promise} Resolves when service was removed from the conversation
   */
  removeService(conversationEntity, userEntity) {
    const {id: userId, serviceId} = userEntity;

    return this.conversationRepository.removeService(conversationEntity, userId).then(event => {
      if (event) {
        const attributes = {service_id: serviceId};
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.INTEGRATION.REMOVED_SERVICE, attributes);
        return event;
      }
    });
  }

  searchForServices(query, queryObservable) {
    const normalizedQuery = IntegrationRepository.normalizeQuery(query);

    return this.teamRepository
      .getWhitelistedServices(this.teamRepository.team().id, 20)
      .then(serviceEntities => {
        const isCurrentQuery = normalizedQuery === IntegrationRepository.normalizeQuery(queryObservable());
        if (isCurrentQuery) {
          serviceEntities = serviceEntities
            .filter(serviceEntity => z.util.StringUtil.compareTransliteration(serviceEntity.name, normalizedQuery))
            .sort((serviceA, serviceB) => {
              return z.util.StringUtil.sortByPriority(serviceA.name, serviceB.name, normalizedQuery);
            });
          this.services(serviceEntities);
        }
      })
      .catch(error => this.logger.error(`Error searching for services: ${error.message}`, error));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.IntegrationService = class IntegrationService {
  static get URL() {
    return {
      PROVIDERS: '/providers',
      SERVICES: '/services',
    };
  }

  /**
   * Construct a new Integration Service.
   * @class z.integration.IntegrationService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.integration.IntegrationService', z.config.LOGGER.OPTIONS);
  }

  getProvider(providerId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}`,
    });
  }

  getProviderServices(providerId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}${IntegrationService.URL.SERVICES}`,
    });
  }

  getService(providerId, serviceId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${IntegrationService.URL.PROVIDERS}/${providerId}${IntegrationService.URL.SERVICES}/${serviceId}`,
    });
  }

  getServices(tags, start) {
    const params = {tags};
    if (start) {
      params.start = start;
    }

    return this.backendClient.sendRequest({
      data: params,
      type: 'GET',
      url: IntegrationService.URL.SERVICES,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ProviderEntity = class ProviderEntity {
  constructor(providerData = {}) {
    const {description, id, name, url, email} = providerData;

    this.id = id || '';

    this.description = description || '';
    this.email = email || '';
    this.name = name || '';
    this.url = url || '';
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ServiceEntity = class ServiceEntity {
  constructor(serviceData = {}) {
    const {description, id, name, provider: providerId, summary, tags} = serviceData;

    this.id = id || '';

    this.description = description || '';
    this.name = name || '';
    this.providerId = providerId || '';
    this.providerName = ko.observable(' ');
    this.summary = summary || '';
    this.tags = tags || [];

    this.mediumPictureResource = ko.observable();
    this.previewPictureResource = ko.observable();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.integration = z.integration || {};

z.integration.ServiceTag = {
  AUDIO: 'audio',
  BOOKS: 'books',
  BUSINESS: 'business',
  DESIGN: 'design',
  EDUCATION: 'education',
  ENTERTAINMENT: 'entertainment',
  FINANCE: 'finance',
  FITNESS: 'fitness',
  FOOD_DRINK: 'food-drink',
  GAMES: 'games',
  GRAPHICS: 'graphics',
  HEALTH: 'health',
  INTEGRATION: 'integration',
  LIFETSTYLE: 'lifestyle',
  MEDIA: 'media',
  MEDICAL: 'medical',
  MOVIES: 'movies',
  MUSIC: 'music',
  NEWS: 'news',
  PHOTOGRAPHY: 'photography',
  POLL: 'poll',
  PRODUCTIVITY: 'productivity',
  QUIZ: 'quiz',
  RATING: 'rating',
  SHOPPING: 'shopping',
  SOCIAL: 'social',
  SPORTS: 'sports',
  TRAVEL: 'travel',
  TUTORIAL: 'tutorial',
  VIDEO: 'video',
  WEATHER: 'weather',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.LifecycleService = class LifecycleService {
  static get CONFIG() {
    return {
      URL: {
        VERSION: '/version/',
      },
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.lifecycle.LifecycleService', z.config.LOGGER.OPTIONS);
  }

  getVersion() {
    return this._fetchData(LifecycleService.CONFIG.URL.VERSION).then(({version}) => version);
  }

  _fetchData(url) {
    return fetch(url).then(response => {
      if (response.ok) {
        return response.json();
      }
      throw new Error(`Failed to fetch '${url}': ${response.statusText}`);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.LifecycleRepository = class LifecycleRepository {
  static get CONFIG() {
    return {
      CHECK_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR * 3,
      CHECK_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE * 5,
      UPDATE_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.HOUR * 6,
    };
  }

  constructor(lifecycleService, userRepository) {
    this.logger = new z.util.Logger('z.lifecycle.LifecycleRepository', z.config.LOGGER.OPTIONS);
    this.lifecycleService = lifecycleService;
    this.userRepository = userRepository;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
  }

  init() {
    if (this.isActivatedAccount()) {
      window.setInterval(() => this.checkVersion(), LifecycleRepository.CONFIG.CHECK_INTERVAL);
    }
  }

  checkVersion() {
    const shouldCheckVersion = this.isActivatedAccount() && navigator.onLine;
    if (shouldCheckVersion) {
      return this.lifecycleService.getVersion().then(serverVersion => {
        const currentVersion = z.util.Environment.version(false, true);
        this.logger.info(`Checking current webapp version. Server '${serverVersion}' vs. local '${currentVersion}'`);

        const isOutdatedVersion = serverVersion > currentVersion;
        if (isOutdatedVersion) {
          amplify.publish(z.event.WebApp.LIFECYCLE.UPDATE, z.lifecycle.UPDATE_SOURCE.WEBAPP);
        }
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.lifecycle = z.lifecycle || {};

z.lifecycle.UPDATE_SOURCE = {
  WEBAPP: 'webapp',
};

// @todo Added for wrapper backwards compatibility. Remove after uptake of version > 3.1.
window.z.announce = z.announce || {};
z.announce.UPDATE_SOURCE = z.lifecycle.UPDATE_SOURCE;

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

const codeBlockRegex = /(`|```)[^]*?\1/gm;

z.links.LinkPreviewHelpers = {
  /**
   * Check if the text contains only one link
   * @param {string} text - Text to parse
   * @returns {boolean} Text contains only a link
   */
  containsOnlyLink(text) {
    const textWithoutCode = text.trim().replace(codeBlockRegex, '');
    const urls = linkify.find(textWithoutCode, 'url');
    return urls.length === 1 && urls[0].value === textWithoutCode;
  },

  /**
   * Get first link and link offset for given text.
   * @param {string} text - Text to parse
   * @returns {Object} Containing link and its offset
   */
  getFirstLinkWithOffset(text) {
    const textWithoutCode = text.trim().replace(codeBlockRegex, '');

    const [firstLink] = linkify.find(textWithoutCode, 'url');

    if (firstLink) {
      const linkOffset = textWithoutCode.indexOf(firstLink.value);
      return {
        offset: linkOffset,
        url: firstLink.value,
      };
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewMetaDataType = {
  TWEET: 'tweet',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewProtoBuilder = {
  /**
   * Create Protocol Buffers message for link previews.
   * Open Graph data can be validated through: https://developers.facebook.com/tools/debug/
   *
   * @param {Object} data - Open graph data
   * @param {string} url - Link entered by the user
   * @param {number} offset - Starting index of the link
   *
   * @returns {z.proto.LinkPreview} Link preview proto
   */
  buildFromOpenGraphData(data, url, offset = 0) {
    if (!_.isEmpty(data)) {
      data.url = data.url || url;

      if (data.title && data.url) {
        const protoArticle = new z.proto.Article(data.url, data.title, data.description); // deprecated format

        const {description, title, url: dataUrl} = data;
        const protoLinkPreview = new z.proto.LinkPreview(url, offset, protoArticle, dataUrl, title, description);

        if (data.site_name === 'Twitter' && z.util.ValidationUtil.urls.isTweet(data.url)) {
          const author = data.title.replace('on Twitter', '').trim();
          const username = data.url.match(/com\/([^/]*)\//)[1];
          const protoTweet = new z.proto.Tweet(author, username);

          protoLinkPreview.set(z.cryptography.PROTO_MESSAGE_TYPE.TWEET, protoTweet);
          protoLinkPreview.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_TITLE, data.description);
        }

        return protoLinkPreview;
      }
    }
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewRepository = class LinkPreviewRepository {
  constructor(assetService, propertiesRepository) {
    this.getLinkPreviewFromString = this.getLinkPreviewFromString.bind(this);
    this.updatedSendPreference = this.updatedSendPreference.bind(this);

    this.assetService = assetService;
    this.logger = new z.util.Logger('z.links.LinkPreviewRepository', z.config.LOGGER.OPTIONS);

    this.shouldSendPreviews = propertiesRepository.getPreference(z.properties.PROPERTIES_TYPE.PREVIEWS.SEND);

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.PREVIEWS.SEND, this.updatedSendPreference);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, properties => {
      this.updatedSendPreference(properties.settings.previews.send);
    });
  }

  /**
   * Searches for url in given string and creates a link preview.
   *
   * @note This will already upload the associated image as asset
   * @param {string} string - Input text to generate preview for
   * @returns {Promise} Resolves with link preview proto message
   */
  getLinkPreviewFromString(string) {
    if (this.shouldSendPreviews && z.util.Environment.desktop) {
      return Promise.resolve().then(() => {
        const linkData = z.links.LinkPreviewHelpers.getFirstLinkWithOffset(string);

        if (linkData) {
          return this.getLinkPreview(linkData.url, linkData.offset).catch(error => {
            const isLinkPreviewError = error instanceof z.error.LinkPreviewError;
            if (!isLinkPreviewError) {
              throw error;
            }
          });
        }
      });
    }
    return Promise.resolve();
  }

  /**
   * Creates link preview for given link. This will upload associated image as asset and will
   * resolve with an z.proto.LinkPreview instance
   *
   * @param {string} url - URL found to generate link preview from
   * @param {number} [offset=0] - starting index of the link
   * @returns {Promise} Resolves with a link preview if generated
   */
  getLinkPreview(url, offset = 0) {
    let openGraphData;

    return Promise.resolve()
      .then(() => {
        if (z.links.LinkPreviewBlackList.isBlacklisted(url)) {
          throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.BLACKLISTED);
        }

        if (window.openGraph) {
          return this._fetchOpenGraphData(url);
        }

        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.NOT_SUPPORTED);
      })
      .then(fetchedData => {
        if (fetchedData) {
          openGraphData = fetchedData;
          return z.links.LinkPreviewProtoBuilder.buildFromOpenGraphData(openGraphData, url, offset);
        }
        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.NO_DATA_AVAILABLE);
      })
      .then(linkPreview => {
        if (linkPreview) {
          return this._fetchPreviewImage(linkPreview, openGraphData.image);
        }
        throw new z.error.LinkPreviewError(z.error.LinkPreviewError.TYPE.UNSUPPORTED_TYPE);
      });
  }

  /**
   * Update the send link preview preference
   * @param {boolean} sendPreviewsPreference - Updated preference
   * @returns {undefined} No return value
   */
  updatedSendPreference(sendPreviewsPreference) {
    this.shouldSendPreviews = sendPreviewsPreference;
  }

  /**
   * Fetch and upload open graph images.
   *
   * @private
   * @param {z.proto.LinkPreview} linkPreview - Link preview proto message
   * @param {Object} [openGraphImage={}] - Open graph image URL
   * @returns {Promise} Resolves with the link preview proto message
   */
  _fetchPreviewImage(linkPreview, openGraphImage = {}) {
    if (openGraphImage.data) {
      return this._uploadPreviewImage(openGraphImage.data)
        .then(asset => {
          linkPreview.article.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_IMAGE, asset); // deprecated
          linkPreview.image.set(z.cryptography.PROTO_MESSAGE_TYPE.LINK_PREVIEW_IMAGE, asset);
          return linkPreview;
        })
        .catch(() => linkPreview);
    }

    return Promise.resolve(linkPreview);
  }

  /**
   * Fetch open graph data.
   *
   * @private
   * @param {string} link - Link to fetch open graph data from
   * @returns {Promise} Resolves with the retrieved open graph data
   */
  _fetchOpenGraphData(link) {
    return new Promise(resolve => {
      return window
        .openGraph(link, (error, data) => {
          if (error) {
            resolve();
          }

          if (data) {
            data = Object.entries(data).reduce((filteredData, [key, value]) => {
              filteredData[key] = Array.isArray(value) ? value[0] : value;
              return filteredData;
            }, {});
          }

          resolve(data);
        })
        .catch(resolve);
    });
  }

  /**
   * Upload open graph image as asset
   *
   * @private
   * @param {string} dataUri - image data as base64 encoded data URI
   * @returns {Promise} Resolves with the uploaded asset
   */
  _uploadPreviewImage(dataUri) {
    return Promise.resolve(z.util.base64ToBlob(dataUri)).then(blob =>
      this.assetService.uploadImageAsset(blob, {public: true})
    );
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.links = z.links || {};

z.links.LinkPreviewBlackList = (() => {
  const soundCloudStatic = [
    'about',
    'channels',
    'charts',
    'discover',
    'discussion',
    'featured',
    'home',
    'messages',
    'mobile',
    'pages',
    'playlists',
    'sets',
    'settings',
    'stream',
    'terms-of-use',
    'upload',
    'videos',
    'you',
  ];
  const BLACKLIST = [
    `soundcloud.com/(?!${soundCloudStatic.join('|')})`,
    'spotify.com/(?!\\w\\w/)',
    'youtu.be',
    'youtube(-nocookie)?.com/(watch|embed)',
    'vimeo.com/(channels/[^/]+/|video/)?[0-9]+',
  ];

  return {
    isBlacklisted: url => new RegExp(BLACKLIST.join('|')).test(url),
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.location = window.z.location || {};

z.location.LocationService = (() => {
  const GOOGLE_GEOCODE_PROXY_BASE_URL = '/proxy/googlemaps/maps/api/geocode/json';

  const _parseResults = ([{address_components: addressComponents, formatted_address: formattedAddress, geometry}]) => {
    const locationResult = {
      address: formattedAddress,
      lat: geometry.location.lat,
      lng: geometry.location.lng,
    };

    addressComponents.forEach(({long_name: longName, short_name: shortName, types}) => {
      const name = longName || shortName;

      types.forEach(type => {
        locationResult[type] = name;
        const isCountry = type === 'country';
        if (isCountry) {
          locationResult.countryCode = shortName || '';
        }
      });
    });

    const {
      administrative_area_level_1: areaLevel1,
      administrative_area_level_2: areaLevel2,
      administrative_area_level_3: areaLevel3,
      locality,
      natural_feature: naturalFeature,
    } = locationResult;

    locationResult.place = locality || naturalFeature || areaLevel3 || areaLevel2 || areaLevel1;

    delete locationResult.political;
    return z.util.ObjectUtil.escapeProperties(locationResult);
  };

  return class LocationService {
    constructor(backendClient) {
      this.backendClient = backendClient;
    }

    /**
     * Reverse loop up for geo location
     * @param {number} latitude - Latitude of location
     * @param {number} longitude - Longitude of location
     * @returns {Promise} Resolves with the location information
     */
    getLocation(latitude, longitude) {
      return new Promise((resolve, reject) => {
        if (latitude == null || longitude == null) {
          const errorMessage = 'You need to specify latitude and longitude in order to retrieve the location';
          return reject(new z.error.LocationError(z.error.BaseError.MISSING_PARAMETER, errorMessage));
        }

        const requestConfig = {
          data: {
            latlng: `${latitude},${longitude}`,
          },
          type: 'GET',
          url: GOOGLE_GEOCODE_PROXY_BASE_URL,
        };

        return this.backendClient
          .sendRequest(requestConfig)
          .then(response => {
            const isStatusOk = response.status === 'OK';
            return isStatusOk ? resolve(_parseResults(response.results)) : resolve();
          })
          .catch((jqXHR, textStatus, errorThrown) => {
            reject(new z.error.LocationError(z.error.LocationError.TYPE.REQUEST_FAILED, errorThrown));
          });
      });
    }
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.location = window.z.location || {};

z.location.LocationRepository = class LocationRepository {
  constructor(locationService) {
    this.locationService = locationService;
  }

  getLocation(latitude, longitude) {
    return this.locationService.getLocation(latitude, longitude);
  }

  /**
   * Return link to Google Maps.
   *
   * @param {number} latitude - Latitude of location
   * @param {number} longitude - Longitude of location
   * @param {string} name - Name of location
   * @param {string} zoom - Map zoom level
   * @returns {string} URL to location in Google Maps
   */
  getMapsUrl(latitude, longitude, name, zoom) {
    const baseUrl = 'https://google.com/maps/';

    const nameParam = name ? `place/${name}/` : '';
    const locationParam = `@${latitude},${longitude}`;
    const zoomParam = zoom ? `,${zoom}z` : '';

    return `${baseUrl}${nameParam}${locationParam}${zoomParam}`;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaConstraintsHandler = class MediaConstraintsHandler {
  static get CONFIG() {
    return {
      DEFAULT_DEVICE_ID: 'default',
      SCREEN_CONSTRAINTS: {
        CHROME: {
          mandatory: {
            chromeMediaSource: 'desktop',
            maxHeight: 1080,
            minHeight: 1080,
          },
        },
        FIREFOX: {
          frameRate: 30,
          height: {exact: 720},
          mediaSource: 'screen',
        },
      },
      VIDEO_CONSTRAINTS: {
        FULL_HD: {
          frameRate: 30,
          height: 1080,
          width: 1920,
        },
        GROUP: {
          frameRate: 30,
          height: 240,
          width: 320,
        },
        HD: {
          frameRate: 30,
          height: 720,
          width: 1280,
        },
        MOBILE: {
          frameRate: 30,
          height: 480,
          width: 640,
        },
        PREFERRED_FACING_MODE: 'user',
      },
    };
  }

  /**
   * Construct a new MediaConstraints handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository with with references to all other handlers
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaConstraintsHandler', z.config.LOGGER.OPTIONS);
  }

  //##############################################################################
  // MediaStream constraints
  //##############################################################################

  /**
   * Get the MediaStreamConstraints to be used for MediaStream creation.
   *
   * @private
   * @param {boolean} [requestAudio=false] - Request audio in the constraints
   * @param {boolean} [requestVideo=false] - Request video in the constraints
   * @param {boolean} [isGroup=false] - Get constraints for group
   * @returns {Promise} Resolves with MediaStreamConstraints
   */
  getMediaStreamConstraints(requestAudio = false, requestVideo = false, isGroup = false) {
    return Promise.resolve().then(() => {
      const currentDeviceId = this.mediaRepository.devicesHandler.currentDeviceId;
      const mode = isGroup ? z.media.VIDEO_QUALITY_MODE.GROUP : z.media.VIDEO_QUALITY_MODE.MOBILE;

      return {
        audio: requestAudio ? this._getAudioStreamConstraints(currentDeviceId.audioInput()) : undefined,
        video: requestVideo ? this._getVideoStreamConstraints(currentDeviceId.videoInput(), mode) : undefined,
      };
    });
  }

  /**
   * Get the video constraints to be used for MediaStream creation.
   * @private
   * @param {string} [mediaDeviceId=''] - ID of MediaDevice to be used
   * @returns {Object} Video stream constraints
   */
  _getAudioStreamConstraints(mediaDeviceId = '') {
    const requireExactMediaDevice = mediaDeviceId && mediaDeviceId !== MediaConstraintsHandler.CONFIG.DEFAULT_DEVICE_ID;
    return requireExactMediaDevice ? {deviceId: {exact: mediaDeviceId}} : true;
  }

  /**
   * Get the MediaStreamConstraints to be used for screen sharing.
   * @returns {Promise} Resolves with MediaStreamConstraints and their type
   */
  getScreenStreamConstraints() {
    if (window.desktopCapturer) {
      this.logger.info('Enabling screen sharing from Electron');

      const streamConstraints = {
        audio: false,
        video: MediaConstraintsHandler.CONFIG.SCREEN_CONSTRAINTS.CHROME,
      };

      const chromeMediaSourceId = this.mediaRepository.devicesHandler.currentDeviceId.screenInput();
      streamConstraints.video.mandatory = Object.assign(streamConstraints.video.mandatory, {chromeMediaSourceId});

      return Promise.resolve(streamConstraints);
    }

    if (z.util.Environment.browser.firefox) {
      this.logger.info('Enabling screen sharing from Firefox');

      const streamConstraints = {
        audio: false,
        video: MediaConstraintsHandler.CONFIG.SCREEN_CONSTRAINTS.FIREFOX,
      };

      return Promise.resolve(streamConstraints);
    }

    return Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.SCREEN_NOT_SUPPORTED));
  }

  /**
   * Get the video constraints to be used for MediaStream creation.
   *
   * @private
   * @param {string} mediaDeviceId - Optional ID of MediaDevice to be used
   * @param {z.media.VIDEO_QUALITY_MODE} [mode=z.media.VIDEO_QUALITY_MODE.MOBILE] - Quality of video stream requested
   * @returns {Object} Video stream constraints
   */
  _getVideoStreamConstraints(mediaDeviceId, mode = z.media.VIDEO_QUALITY_MODE.MOBILE) {
    let streamConstraints;
    switch (mode) {
      case z.media.VIDEO_QUALITY_MODE.FULL_HD: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.FULL_HD;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.GROUP: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.GROUP;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.HD: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.HD;
        break;
      }

      case z.media.VIDEO_QUALITY_MODE.MOBILE:
      default: {
        streamConstraints = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.MOBILE;
        break;
      }
    }

    if (_.isString(mediaDeviceId)) {
      streamConstraints.deviceId = {exact: mediaDeviceId};
    } else {
      streamConstraints.facingMode = MediaConstraintsHandler.CONFIG.VIDEO_CONSTRAINTS.PREFERRED_FACING_MODE;
    }

    return streamConstraints;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaDevicesHandler = class MediaDevicesHandler {
  static get CONFIG() {
    return {
      DEFAULT_DEVICE_ID: 'default',
      SCREEN_DEVICE_TYPE: 'screen',
    };
  }

  /**
   * Construct a new MediaDevices handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository referencing the other handlers
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaDevicesHandler', z.config.LOGGER.OPTIONS);

    this.availableDevices = {
      audioInput: ko.observableArray([]),
      audioOutput: ko.observableArray([]),
      screenInput: ko.observableArray([]),
      videoInput: ko.observableArray([]),
    };

    this.currentDeviceId = {
      audioInput: ko.observable(),
      audioOutput: ko.observable(),
      screenInput: ko.observable(),
      videoInput: ko.observable(),
    };

    this.currentDeviceIndex = {
      audioInput: ko.observable(0),
      audioOutput: ko.observable(0),
      screenInput: ko.observable(0),
      videoInput: ko.observable(0),
    };

    this.deviceSupport = {
      audioInput: ko.pureComputed(() => !!this.availableDevices.audioInput().length),
      audioOutput: ko.pureComputed(() => !!this.availableDevices.audioOutput().length),
      screenInput: ko.pureComputed(() => !!this.availableDevices.screenInput().length),
      videoInput: ko.pureComputed(() => !!this.availableDevices.videoInput().length),
    };

    this.initializeMediaDevices();
  }

  /**
   * Initialize the list of MediaDevices and subscriptions.
   * @returns {undefined} No return value
   */
  initializeMediaDevices() {
    if (z.media.MediaRepository.supportsMediaDevices()) {
      this.getMediaDevices().then(() => {
        this._setCurrentDevices();
        this._subscribeToObservables();
        this._subscribeToDevices();
      });
    }
  }

  /**
   * Set current media device IDs.
   * @returns {undefined} No return value
   */
  _setCurrentDevices() {
    const defaultDeviceId = MediaDevicesHandler.CONFIG.DEFAULT_DEVICE_ID;

    const audioInputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.AUDIO_INPUT) || defaultDeviceId;
    this.currentDeviceId.audioInput(audioInputId);

    const audioOutputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.AUDIO_OUTPUT) || defaultDeviceId;
    this.currentDeviceId.audioOutput(audioOutputId);

    const videoInputId = z.util.StorageUtil.getValue(z.media.MediaDeviceType.VIDEO_INPUT);
    this.currentDeviceId.videoInput(videoInputId);

    const setDefaultVideoId = !this.currentDeviceId.videoInput() && this.deviceSupport.videoInput();
    if (setDefaultVideoId) {
      const defaultDeviceIndex = this.availableDevices.videoInput().length - 1;
      const videoDeviceId = this.availableDevices.videoInput()[defaultDeviceIndex].deviceId;

      this.currentDeviceId.videoInput(videoDeviceId);
      this.currentDeviceIndex.videoInput(defaultDeviceIndex);
    }

    this.logger.info('Set selected MediaDevice IDs');
  }

  /**
   * Subscribe to MediaDevices updates if available.
   * @returns {undefined} No return value
   */
  _subscribeToDevices() {
    navigator.mediaDevices.ondevicechange = () => {
      this.logger.info('List of available MediaDevices has changed');
      this.getMediaDevices();
    };
  }

  /**
   * Subscribe to Knockout observables.
   * @returns {undefined} No return value
   */
  _subscribeToObservables() {
    this.availableDevices.audioInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.AUDIO_INPUT, mediaDevices);
      }
    });

    this.availableDevices.audioOutput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDevices);
      }
    });

    this.availableDevices.screenInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.SCREEN_INPUT, mediaDevices);
      }
    });

    this.availableDevices.videoInput.subscribe(mediaDevices => {
      if (mediaDevices.length) {
        this._updateCurrentIndexFromDevices(z.media.MediaDeviceType.VIDEO_INPUT, mediaDevices);
      }
    });

    this.currentDeviceId.audioInput.subscribe(mediaDeviceId => {
      z.util.StorageUtil.setValue(z.media.MediaDeviceType.AUDIO_INPUT, mediaDeviceId);

      const updateStream = mediaDeviceId && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.AUDIO, z.media.MediaDeviceType.AUDIO_INPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.audioOutput.subscribe(mediaDeviceId => {
      z.util.StorageUtil.setValue(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDeviceId);

      if (mediaDeviceId) {
        this.mediaRepository.elementHandler.switchMediaElementOutput(mediaDeviceId);
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.AUDIO_OUTPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.screenInput.subscribe(mediaDeviceId => {
      if (mediaDeviceId) {
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.SCREEN_INPUT, mediaDeviceId);
      }

      const isMediaTypeScreen = this.mediaRepository.streamHandler.localMediaType() === z.media.MediaType.SCREEN;
      const updateStream = mediaDeviceId && isMediaTypeScreen && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.SCREEN, z.media.MediaDeviceType.SCREEN_INPUT, mediaDeviceId);
      }
    });

    this.currentDeviceId.videoInput.subscribe(mediaDeviceId => {
      if (mediaDeviceId) {
        this._updateCurrentIndexFromId(z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);
      }

      z.util.StorageUtil.setValue(z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);

      const isMediaTypeVideo = this.mediaRepository.streamHandler.localMediaType() === z.media.MediaType.VIDEO;
      const updateStream = mediaDeviceId && isMediaTypeVideo && this.mediaRepository.streamHandler.localMediaStream();
      if (updateStream) {
        this._replaceInputDevice(z.media.MediaType.VIDEO, z.media.MediaDeviceType.VIDEO_INPUT, mediaDeviceId);
      }
    });
  }

  /**
   * Update list of available MediaDevices.
   * @returns {Promise} Resolves with all MediaDevices when the list has been updated
   */
  getMediaDevices() {
    return navigator.mediaDevices
      .enumerateDevices()
      .catch(error => {
        this.logger.error(`Failed to update MediaDevice list: ${error.message}`, error);
        throw error;
      })
      .then(mediaDevices => {
        this._removeAllDevices();

        if (mediaDevices) {
          const audioInputDevices = [];
          const audioOutputDevices = [];
          const videoInputDevices = [];

          mediaDevices.forEach(mediaDevice => {
            switch (mediaDevice.kind) {
              case z.media.MediaDeviceType.AUDIO_INPUT: {
                audioInputDevices.push(mediaDevice);
                break;
              }

              case z.media.MediaDeviceType.AUDIO_OUTPUT: {
                audioOutputDevices.push(mediaDevice);
                break;
              }

              case z.media.MediaDeviceType.VIDEO_INPUT: {
                videoInputDevices.push(mediaDevice);
                break;
              }

              default: {
                throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
              }
            }
          });

          z.util.koArrayPushAll(this.availableDevices.audioInput, audioInputDevices);
          z.util.koArrayPushAll(this.availableDevices.audioOutput, audioOutputDevices);
          z.util.koArrayPushAll(this.availableDevices.videoInput, videoInputDevices);

          this.logger.info('Updated MediaDevice list', mediaDevices);
          return mediaDevices;
        }
        throw new z.error.MediaError(z.error.MediaError.TYPE.NO_MEDIA_DEVICES_FOUND);
      });
  }

  /**
   * Update list of available Screens.
   * @returns {Promise} resolves with all screen sources when the list has been updated
   */
  getScreenSources() {
    return new Promise((resolve, reject) => {
      const options = {
        thumbnailSize: {
          height: 176,
          width: 312,
        },
        types: [MediaDevicesHandler.CONFIG.SCREEN_DEVICE_TYPE],
      };

      return window.desktopCapturer.getSources(options, (error, screenSources) => {
        if (error) {
          return reject(error);
        }

        this.logger.info(`Detected '${screenSources.length}' sources for screen sharing from Electron`, screenSources);
        this.availableDevices.screenInput(screenSources);

        if (screenSources.length === 1) {
          const [firstScreenSource] = screenSources;
          this.currentDeviceId.screenInput('');
          this.logger.info(`Selected '${firstScreenSource.name}' for screen sharing`, firstScreenSource);
          this.currentDeviceId.screenInput(firstScreenSource.id);
        }
        return resolve(screenSources);
      });
    });
  }

  /**
   * Replace input device of given type
   *
   * @private
   * @param {z.media.MediaType} mediaType - Media type to change device for
   * @param {z.media.MediaDeviceType} mediaDeviceType - Media device type to change
   * @param {string} mediaDeviceId - New media device Id
   * @returns {undefined} No return value
   */
  _replaceInputDevice(mediaType, mediaDeviceType, mediaDeviceId) {
    this.mediaRepository.streamHandler
      .replaceInputSource(mediaType)
      .then(() => this._updateCurrentIndexFromId(mediaDeviceType, mediaDeviceId))
      .catch(error => {
        this.logger.error(`Failed to replace input device of type '${mediaType}'`, error);
      });
  }

  /**
   * Toggle between the available cameras.
   * @returns {Promise} Resolves when camera has been toggled.
   */
  toggleNextCamera() {
    return this.getMediaDevices().then(() => {
      const availableDevices = this.availableDevices.videoInput();
      const currentDeviceId = this.currentDeviceId.videoInput;
      const currentDeviceIndex = this.currentDeviceIndex.videoInput();

      const {deviceName, nextDeviceId} = this._toggleNextDevice(availableDevices, currentDeviceId, currentDeviceIndex);
      this.logger.info(`Switching the active camera from '${deviceName}' to '${nextDeviceId}'`);
    });
  }

  /**
   * Toggle between the available screens.
   * @returns {Promise} Resolves when screen has been toggled.
   */
  toggleNextScreen() {
    return this.getScreenSources().then(() => {
      const availableDevices = this.availableDevices.screenInput();
      const currentDeviceId = this.currentDeviceId.screenInput;
      const currentDeviceIndex = this.currentDeviceIndex.screenInput();

      const {deviceName, nextDeviceId} = this._toggleNextDevice(availableDevices, currentDeviceId, currentDeviceIndex);
      this.logger.info(`Switching the active screen from '${deviceName}' to '${nextDeviceId}'`);
    });
  }

  _toggleNextDevice(availableDevices, currentDeviceIdObservable, currentDeviceIndex) {
    const {device} = this._getCurrentDevice(availableDevices, currentDeviceIdObservable());
    const nextIndex = z.util.ArrayUtil.iterateIndex(availableDevices, currentDeviceIndex);

    const nextDevice = availableDevices[nextIndex || 0];
    const deviceId = nextDevice.deviceId || nextDevice.id;
    const label = nextDevice.label || nextDevice.name;

    currentDeviceIdObservable(deviceId);

    const deviceName = device ? device.label || device.deviceId : undefined;
    const nextDeviceId = label || deviceId;

    return {deviceName, nextDeviceId};
  }

  /**
   * Check for availability of selected devices.
   * @param {boolean} videoSend - Also check for video devices
   * @returns {Promise} Resolves when the current device has been updated
   */
  updateCurrentDevices(videoSend) {
    return this.getMediaDevices().then(() => {
      const _checkDevice = (mediaType, deviceType) => {
        deviceType = this._typeConversion(deviceType);

        const deviceIdObservable = this.currentDeviceId[`${deviceType}`];
        const mediaDevices = this.availableDevices[`${deviceType}`]();
        const {device: mediaDevice} = this._getCurrentDevice(mediaDevices, deviceIdObservable());

        if (!mediaDevice) {
          const [updatedDevice] = this.availableDevices[`${deviceType}`]();

          if (updatedDevice) {
            const id = updatedDevice.label || updatedDevice.deviceId;
            const log = `Selected '${mediaType}' device '${deviceIdObservable()}' not found and replaced by '${id}'`;
            this.logger.warn(log, mediaDevices);
            return deviceIdObservable(updatedDevice.deviceId);
          }

          const logMessage = `Selected '${mediaType}' device '${deviceIdObservable()}' not found and reset'`;
          this.logger.warn(logMessage, mediaDevices);
          return deviceIdObservable('');
        }
      };

      _checkDevice(z.media.MediaType.AUDIO, z.media.MediaDeviceType.AUDIO_INPUT);
      if (videoSend) {
        _checkDevice(z.media.MediaType.VIDEO, z.media.MediaDeviceType.VIDEO_INPUT);
      }
    });
  }

  /**
   * Get the currently selected MediaDevice.
   *
   * @param {Array} mediaDevices - Array of MediaDevices
   * @param {string} currentDeviceId - ID of selected MediaDevice
   * @returns {Object} Selected MediaDevice and its array index
   */
  _getCurrentDevice(mediaDevices, currentDeviceId) {
    for (const [index, mediaDevice] of mediaDevices.entries()) {
      const isCurrentDevice = mediaDevice.deviceId === currentDeviceId || mediaDevice.id === currentDeviceId;
      if (isCurrentDevice) {
        return {device: mediaDevice, deviceIndex: index};
      }
    }

    return {deviceIndex: 0};
  }

  /**
   * Remove all known MediaDevices from the lists.
   * @private
   * @returns {undefined} No return value
   */
  _removeAllDevices() {
    this.availableDevices.audioInput.removeAll();
    this.availableDevices.audioOutput.removeAll();
    this.availableDevices.videoInput.removeAll();
  }

  /**
   * Add uppercase to MediaDevice types.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - Device type string to update
   * @returns {string} Updated device type
   */
  _typeConversion(deviceType) {
    return deviceType.replace('input', 'Input').replace('output', 'Output');
  }

  /**
   * Update the current index by searching for the current device.
   *
   * @private
   * @param {ko.observable} indexObservable - Observable containing the current index
   * @param {Array} availableDevices - Array of MediaDevices
   * @param {string} currentDeviceId - Current device ID to look for
   * @returns {undefined} No return value
   */
  _updateCurrentDeviceIndex(indexObservable, availableDevices, currentDeviceId) {
    const {deviceIndex} = this._getCurrentDevice(availableDevices, currentDeviceId);

    if (_.isNumber(deviceIndex)) {
      indexObservable(deviceIndex);
    }
  }

  /**
   * Update the index for current device after the list of devices changed.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - MediaDeviceType to be updates
   * @param {Array} availableDevices - Array of MediaDevices
   * @returns {undefined} No return value
   */
  _updateCurrentIndexFromDevices(deviceType, availableDevices) {
    deviceType = this._typeConversion(deviceType);
    const deviceIndexObservable = this.currentDeviceIndex[deviceType];
    const currentDeviceId = this.currentDeviceId[deviceType]();

    this._updateCurrentDeviceIndex(deviceIndexObservable, availableDevices, currentDeviceId);
  }

  /**
   * Update the index for current device after the current device changed.
   * @private
   * @param {z.media.MediaDeviceType} deviceType - MediaDeviceType to be updates
   * @param {string} selectedInputDeviceId - ID of selected input device
   * @returns {undefined} No return value
   */
  _updateCurrentIndexFromId(deviceType, selectedInputDeviceId) {
    deviceType = this._typeConversion(deviceType);
    const deviceIndexObservable = this.currentDeviceIndex[deviceType];
    const availableDevices = this.availableDevices[deviceType]();

    this._updateCurrentDeviceIndex(deviceIndexObservable, availableDevices, selectedInputDeviceId);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaDeviceType = {
  AUDIO_INPUT: 'audioinput',
  AUDIO_OUTPUT: 'audiooutput',
  SCREEN_INPUT: 'screeninput',
  VIDEO_INPUT: 'videoinput',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaElementHandler = class MediaElementHandler {
  /**
   * Construct an new MediaElement handler.
   * @param {z.media.MediaRepository} mediaRepository - Repository for media interactions
   */
  constructor(mediaRepository) {
    this.mediaRepository = mediaRepository;
    this.logger = new z.util.Logger('z.media.MediaElementHandler', z.config.LOGGER.OPTIONS);

    this.currentDeviceId = this.mediaRepository.devicesHandler.currentDeviceId;
    this.remoteMediaElements = ko.observableArray([]);
  }

  /**
   * Add MediaElement for new stream.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {undefined} No return value
   */
  addMediaElement(mediaStreamInfo) {
    const isVideoStream = mediaStreamInfo.getType() === z.media.MediaType.VIDEO;
    if (!isVideoStream) {
      const remoteMediaElement = this._createMediaElement(mediaStreamInfo);
      this.remoteMediaElements.push(remoteMediaElement);

      const elementType = remoteMediaElement.nodeName.toLowerCase();
      const message = `Created MediaElement of type '${elementType}' for flow '${mediaStreamInfo.flowId}'`;
      this.logger.info(message, remoteMediaElement);
    }
  }

  /**
   * Destroy the remote media element of a flow.
   * @private
   * @param {string} flowId - Flow ID for which to destroy the remote media element
   * @returns {undefined} No return value
   */
  removeMediaElement(flowId) {
    this._getMediaElements(flowId).forEach(mediaElement => {
      this._destroyMediaElement(mediaElement);
      this.remoteMediaElements.remove(mediaElement);
      const elementType = mediaElement.tagName.toLocaleLowerCase();
      this.logger.info(`Deleted MediaElement of type '${elementType}' for flow '${flowId}'`);
    });
  }

  /**
   * Switch the output device used for all MediaElements.
   * @param {string} mediaDeviceId - Media Device ID to be used for playback
   * @returns {undefined} No return value
   */
  switchMediaElementOutput(mediaDeviceId) {
    this.remoteMediaElements().forEach(mediaElement => this._setMediaElementOutput(mediaElement, mediaDeviceId));
  }

  /**
   * Create a new media element.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {Element} HTMLAudioElement that has the stream attached to it
   */
  _createMediaElement(mediaStreamInfo) {
    try {
      const mediaElement = document.createElement('audio');
      mediaElement.srcObject = mediaStreamInfo.stream;
      mediaElement.dataset.conversationId = mediaStreamInfo.conversationId;
      mediaElement.dataset.flowId = mediaStreamInfo.flowId;
      mediaElement.muted = false;
      mediaElement.setAttribute('autoplay', true);
      if (z.util.Environment.browser.supports.audioOutputSelection) {
        this._setMediaElementOutput(mediaElement, this.currentDeviceId.audioOutput());
      }
      return mediaElement;
    } catch (error) {
      this.logger.error(`Unable to create AudioElement for flow '${mediaStreamInfo.flowId}'`, error);
    }
  }

  /**
   * Stop the media element.
   *
   * @private
   * @param {HTMLMediaElement} mediaElement - A HTMLMediaElement that has the media stream attached to it
   * @returns {undefined} No return value
   */
  _destroyMediaElement(mediaElement) {
    if (mediaElement) {
      mediaElement.pause();
      mediaElement.srcObject = undefined;
    }
  }

  /**
   * Get all the MediaElements related to a given flow ID.
   *
   * @private
   * @param {string} flowId - ID of flow to search MediaElements for
   * @returns {Array<HTMLMediaElement>} Related MediaElements
   */
  _getMediaElements(flowId) {
    return this.remoteMediaElements().filter(mediaElement => mediaElement.dataset.flowId === flowId);
  }

  /**
   * Change the output device used for audio playback of a media element.
   *
   * @private
   * @param {Element} mediaElement - HTMLMediaElement to change playback device for
   * @param {string} sinkId - ID of MediaDevice to be used
   * @returns {undefined} No return value
   */
  _setMediaElementOutput(mediaElement, sinkId) {
    if (mediaElement.setSinkId) {
      const flowId = mediaElement.dataset.flowId;

      mediaElement
        .setSinkId(sinkId)
        .then(() => this.logger.info(`Audio output device '${sinkId}' attached to flow '${flowId}`, mediaElement))
        .catch(error => {
          const message = `Failed to attach audio output device '${sinkId}' to flow '${flowId}': ${error.message}`;
          this.logger.warn(message, error);
        });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaEmbeds = (function() {
  /**
   * Create and iframe.
   * @private
   * @param {Object} options - Settings to be used to create the iframe
   * @returns {string} HTML string
   */
  const _createIframeContainer = options => {
    const defaults = {
      allowfullscreen: ' allowfullscreen',
      class: 'iframe-container iframe-container-video',
      frameborder: '0',
      height: '100%',
      type: 'default',
      video: true,
      width: '100%',
    };

    options = _.extend(defaults, options);
    const iframeContainer = `<div class="{0}"><iframe class="${
      options.type
    }" width="{1}" height="{2}" src="{3}" frameborder="{4}"{5}></iframe></div>`;

    if (!options.video) {
      options.allowfullscreen = '';
      options.class = 'iframe-container';
    }

    if (z.util.Environment.desktop) {
      options.allowfullscreen = '';
    }

    return z.util.StringUtil.format(
      iframeContainer,
      options.class,
      options.width,
      options.height,
      options.src,
      options.frameborder,
      options.allowfullscreen
    );
  };

  // Enum of different regex for the supported services.
  const _regex = {
    // example: http://regexr.com/3ase5
    soundcloud: /(https?:\/\/(?:www\.|m\.)?)?soundcloud\.com(\/[\w-]+){2,3}/g,
    spotify: /https?:\/\/(?:play\.|open\.)*spotify\.com\/([^?]+)/g,
    vimeo: /https?:\/\/(?:(?:player\.)?vimeo\.com\/)(?:channels(?:\/[^/]+)?\/|video\/)?([0-9]+)/g,
    youtube: /(?:youtube(?:-nocookie)?\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\/?\?(?:\S*?&?v=))|youtu\.be\/)([a-zA-Z0-9_-]{6,11})/g,
  };

  /**
   * Appends an iFrame.
   *
   * @private
   * @param {HTMLAnchorElement} link - Link element
   * @param {string} message - Message containing the link
   * @param {string} iframe - HTML of iframe
   * @returns {string} Message content
   */
  const _appendIframe = (link, message, iframe) => {
    const linkString = link.outerHTML.replace(/&amp;/g, '&');
    return message.replace(/&amp;/g, '&').replace(linkString, `${linkString}${iframe}`);
  };

  /**
   * Find search parameters in a string
   *
   * @private
   * @param {string} params - String where we should find the parameters
   * @returns {string} Parameters
   */
  const _getParameters = params => params.substr(params.indexOf('?'), params.length).replace(/^\?/, '');

  /**
   * Generate embed URL to use as src in iframes
   *
   * @private
   * @param {string} url - Given youtube url
   * @returns {string} Youtube embed URL
   */
  const _generateYouTubeEmbedUrl = url => {
    if (url.match(_regex.youtube)) {
      const videoId = url.match(/(?:embed\/|v=|v\/|be\/)([a-zA-Z0-9_-]{11})/);
      if (!videoId) {
        return;
      }

      // Extract params from the URL
      const parser = document.createElement('a');
      parser.href = url;
      const searchParams = new URLSearchParams([_getParameters(parser.search), _getParameters(parser.hash)].join('&'));

      // Append HTML5 parameter to YouTube src to force HTML5 mode
      // This fixes the issue that FF displays black box in some cases
      searchParams.set('html5', 1);

      searchParams.set('enablejsapi', 0);
      searchParams.set('modestbranding', 1);

      // Do not get related videos at the end
      searchParams.set('rel', 0);

      // Convert the timestamp into an embed friendly format (start=seconds)
      if (searchParams.has('t')) {
        searchParams.set('start', _convertYouTubeTimestampToSeconds(searchParams.get('t')));
        searchParams.delete('t');
      }

      // Remove some parameters
      searchParams.delete('autoplay');
      searchParams.delete('v');
      searchParams.delete('widget_referrer');
      searchParams.delete('showinfo');

      return `https://www.youtube-nocookie.com/embed/${videoId[1]}?${searchParams.toString()}`;
    }
  };

  /**
   * Converts youtube timestamp into seconds
   *
   * @private
   * @param {string} timestamp - Youtube timestamp (1h8m55s)
   * @returns {number} Timestamp in seconds
   */
  const _convertYouTubeTimestampToSeconds = timestamp => {
    if (timestamp) {
      if (/^[0-9]*$/.test(timestamp)) {
        return window.parseInt(timestamp, 10);
      }

      const _extractUnit = unit => {
        return window.parseInt((timestamp.match(new RegExp(`([0-9]+)(?=${unit})`)) || [0])[0], 10);
      };

      return _extractUnit('h') * 3600 + _extractUnit('m') * 60 + _extractUnit('s');
    }
    return 0;
  };

  // Make public for testability.
  return {
    convertYouTubeTimestampToSeconds: _convertYouTubeTimestampToSeconds,
    generateYouTubeEmbedUrl: _generateYouTubeEmbedUrl,
    regex: _regex,

    /**
     * Appends SoundCloud iFrame if link is a valid SoundCloud source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    soundcloud(link, message) {
      let linkSrc = link.href;

      if (linkSrc.match(_regex.soundcloud)) {
        linkSrc = linkSrc.replace(/(m\.)/, '');
        let linkPathName = link.pathname;

        if (linkPathName.endsWith('/')) {
          linkPathName = linkPathName.substr(0, linkPathName.length - 1);
        }

        let isSingleTrack = false;
        const slashesInLink = linkPathName.split('/').length;

        if (slashesInLink === 3) {
          isSingleTrack = true;
        } else if (slashesInLink > 3 && linkPathName.indexOf('sets') === -1) {
          // Fix for WEBAPP-1137
          return message;
        }

        const height = isSingleTrack ? 164 : 465;

        const iframe = _createIframeContainer({
          height: height,
          src:
            'https://w.soundcloud.com/player/?url={1}&visual=false&show_comments=false&buying=false&show_playcount=false&liking=false&sharing=false&hide_related=true',
          type: 'soundcloud',
          video: false,
        });

        const embed = z.util.StringUtil.format(iframe, height, linkSrc);
        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends Spotify iFrame if link is a valid Spotify source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    spotify(link, message) {
      const linkSrc = link.href;

      if (linkSrc.match(_regex.spotify)) {
        const iframe = _createIframeContainer({
          height: '80px',
          src: 'https://embed.spotify.com/?uri=spotify$1',
          type: 'spotify',
          video: false,
        });

        // convert spotify uri: album/23... -> album:23... -> album%3A23...
        let embed = '';
        linkSrc.replace(_regex.spotify, (match, group1) => {
          const replaceSlashes = group1.replace(/\//g, ':');
          const encodedParams = window.encodeURIComponent(`:${replaceSlashes}`);
          return (embed = iframe.replace('$1', encodedParams));
        });

        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends Vimeo iFrame if link is a valid Vimeo source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @param {string} themeColor - User color
     * @returns {string} Message with appended iFrame
     */
    vimeo(link, message, themeColor) {
      const linkSrc = link.href;
      const vimeoColor = themeColor ? themeColor.replace('#', '') : undefined;

      if (linkSrc.match(_regex.vimeo)) {
        const iframe = _createIframeContainer({
          src: `https://player.vimeo.com/video/$1?portrait=0&color=${vimeoColor}&badge=0`,
          type: 'vimeo',
        });

        let embed = '';
        linkSrc.replace(_regex.vimeo, (match, group1) => (embed = iframe.replace('$1', group1)));

        message = _appendIframe(link, message, embed);
      }

      return message;
    },

    /**
     * Appends YouTube iFrame if link is a valid YouTube source.
     *
     * @param {HTMLAnchorElement} link - Link element
     * @param {string} message - Message containing the link
     * @returns {string} Message with appended iFrame
     */
    youtube(link, message) {
      const embedUrl = _generateYouTubeEmbedUrl(link.href);

      if (embedUrl) {
        const iframe = _createIframeContainer({
          src: embedUrl,
          type: 'youtube',
        });

        message = _appendIframe(link, message, iframe);
        return message;
      }

      return message;
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

class MediaParser {
  constructor() {
    this.renderMediaEmbeds = this.renderMediaEmbeds.bind(this);

    this.embeds = [
      z.media.MediaEmbeds.soundcloud,
      z.media.MediaEmbeds.spotify,
      z.media.MediaEmbeds.vimeo,
      z.media.MediaEmbeds.youtube,
    ];
  }

  /**
   * Render media embeds.
   * @note Checks message for valid media links and appends an iFrame right after the link
   *
   * @param {string} message - Message text
   * @param {string} themeColor - Accent color to be applied to the embed
   * @returns {string} Message with rendered media embeds
   */
  renderMediaEmbeds(message, themeColor) {
    z.util.URLUtil.getLinksFromHtml(message).forEach(link => {
      this.embeds.forEach(embed => (message = embed(link, message, themeColor)));
    });

    return message;
  }
}

z.media.MediaParser = new MediaParser();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaRepository = class MediaRepository {
  // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/state
  static get AUDIO_CONTEXT_STATE() {
    return {
      CLOSED: 'closed',
      RUNNING: 'running',
      SUSPENDED: 'suspended',
    };
  }

  /**
   * Extended check for MediaDevices support of browser.
   * @returns {boolean} True if MediaDevices are supported
   */
  static supportsMediaDevices() {
    return z.util.Environment.browser.supports.mediaDevices;
  }

  /**
   * Construct a new Media repository.
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   */
  constructor(permissionRepository) {
    this.logger = new z.util.Logger('z.media.MediaRepository', z.config.LOGGER.OPTIONS);

    this.constraintsHandler = new z.media.MediaConstraintsHandler(this);
    this.devicesHandler = new z.media.MediaDevicesHandler(this);
    this.elementHandler = new z.media.MediaElementHandler(this);
    this.streamHandler = new z.media.MediaStreamHandler(this, permissionRepository);

    this.audioContext = undefined;
  }

  /**
   * Closing the AudioContext.
   * @returns {undefined} No return value
   */
  closeAudioContext() {
    const contextRunning = this.audioContext && this.audioContext.state === MediaRepository.AUDIO_CONTEXT_STATE.RUNNING;
    if (contextRunning) {
      this.audioContext.close().then(() => {
        this.logger.info('Closed existing AudioContext', this.audioContext);
        this.audioContext = undefined;
      });
    }
  }

  /**
   * Initialize the AudioContext.
   * @returns {AudioContext} AudioContext
   */
  getAudioContext() {
    const contextRunning = this.audioContext && this.audioContext.state === MediaRepository.AUDIO_CONTEXT_STATE.RUNNING;
    if (contextRunning) {
      this.logger.info('Reusing existing AudioContext', this.audioContext);
      return this.audioContext;
    }

    if (window.AudioContext && window.AudioContext.prototype.createMediaStreamSource) {
      this.audioContext = new window.AudioContext();
      this.logger.info('Initialized a new AudioContext', this.audioContext);
      return this.audioContext;
    }

    this.logger.error('The flow audio cannot use the Web Audio API as it is unavailable.');
    return undefined;
  }

  showNoCameraModal() {
    const modalOptions = {
      text: {
        htmlMessage: z.l10n.safeHtml(z.string.modalNoCameraMessage, {
          replaceDangerously: {
            '/faqLink': '</a>',
            br: '<br>',
            faqLink:
              '<a href="https://support.wire.com/hc/articles/202935412" data-uie-name="go-no-camera-faq" target="_blank" rel="noopener noreferrer">',
          },
        }),
        title: z.l10n.text(z.string.modalNoCameraTitle),
      },
    };
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Errors
z.media.MEDIA_STREAM_ERROR = {
  ABORT_ERROR: 'AbortError',
  NOT_ALLOWED_ERROR: 'NotAllowedError',
  NOT_FOUND_ERROR: 'NotFoundError',
  NOT_READABLE_ERROR: 'NotReadableError',
  NOT_SUPPORTED_ERROR: 'NotSupportedError',
  OVERCONSTRAINED_ERROR: 'OverConstrainedError',
  SECURITY_ERROR: 'SecurityError',
  TYPE_ERROR: 'TypeError',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

// https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Errors
z.media.MEDIA_STREAM_ERROR_TYPES = {
  DEVICE: [
    z.media.MEDIA_STREAM_ERROR.ABORT_ERROR,
    z.media.MEDIA_STREAM_ERROR.NOT_FOUND_ERROR,
    z.media.MEDIA_STREAM_ERROR.NOT_READABLE_ERROR,
  ],
  MISC: [
    z.media.MEDIA_STREAM_ERROR.NOT_SUPPORTED_ERROR,
    z.media.MEDIA_STREAM_ERROR.OVERCONSTRAINED_ERROR,
    z.media.MEDIA_STREAM_ERROR.TYPE_ERROR,
  ],
  PERMISSION: [z.media.MEDIA_STREAM_ERROR.NOT_ALLOWED_ERROR, z.media.MEDIA_STREAM_ERROR.SECURITY_ERROR],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamHandler = class MediaStreamHandler {
  /**
   * Detect whether a MediaStream has a video MediaStreamTrack attached
   * @param {MediaStream} mediaStream - MediaStream to detect the type off
   * @returns {MediaType} Media type information
   */
  static detectMediaStreamType(mediaStream) {
    const audioTracks = mediaStream.getAudioTracks();
    const videoTracks = mediaStream.getVideoTracks();

    const hasAudioTrack = audioTracks && audioTracks.length;
    const hasVideoTrack = videoTracks && videoTracks.length;
    if (hasVideoTrack) {
      return hasAudioTrack ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.VIDEO;
    }
    return hasAudioTrack ? z.media.MediaType.AUDIO : z.media.MediaType.NONE;
  }

  /**
   * Get MediaStreamTracks from a MediaStream.
   *
   * @param {MediaStream} mediaStream - MediaStream to get tracks from
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of requested tracks
   * @returns {Array} MediaStreamTracks
   */
  static getMediaTracks(mediaStream, mediaType = z.media.MediaType.AUDIO_VIDEO) {
    if (!mediaStream) {
      throw new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND);
    }

    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return mediaStream.getAudioTracks();
      }

      case z.media.MediaType.AUDIO_VIDEO: {
        return mediaStream.getTracks();
      }

      case z.media.MediaType.SCREEN:
      case z.media.MediaType.VIDEO: {
        return mediaStream.getVideoTracks();
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  static get CONFIG() {
    return {
      MEDIA_TYPE: {
        CONTAINS_AUDIO: [z.media.MediaType.AUDIO, z.media.MediaType.AUDIO_VIDEO],
        CONTAINS_VIDEO: [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO],
      },
      PERMISSION_HINT_DELAY: 200,
    };
  }

  /**
   * Construct a new MediaStream handler.
   * @param {z.media.MediaRepository} mediaRepository - Media repository with with references to all other handlers
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   */
  constructor(mediaRepository, permissionRepository) {
    this._toggleScreenSend = this._toggleScreenSend.bind(this);
    this._toggleVideoSend = this._toggleVideoSend.bind(this);

    this.mediaRepository = mediaRepository;
    this.permissionRepository = permissionRepository;
    this.logger = new z.util.Logger('z.media.MediaStreamHandler', z.config.LOGGER.OPTIONS);

    this.currentCalls = new Map();
    this.joinedCall = ko.observable();

    this.constraintsHandler = this.mediaRepository.constraintsHandler;
    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.elementHandler = this.mediaRepository.elementHandler;

    this.deviceSupport = this.devicesHandler.deviceSupport;

    this.localMediaStream = ko.observable();
    this.localMediaType = ko.observable(z.media.MediaType.AUDIO);

    this.remoteMediaStreamInfo = ko.observableArray([]);
    this.remoteMediaStreamInfoIndex = {
      audio: ko.pureComputed(() => {
        return this.remoteMediaStreamInfo().filter(mediaStreamInfo => {
          return mediaStreamInfo.getType() === z.media.MediaType.AUDIO;
        });
      }),
      video: ko.pureComputed(() => {
        const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
        return this.remoteMediaStreamInfo().filter(mediaStreamInfo => videoTypes.includes(mediaStreamInfo.getType()));
      }),
    };

    this.selfStreamState = {
      audioSend: ko.observable(true),
      screenSend: ko.observable(false),
      videoSend: ko.observable(false),
    };

    this.selfStreamState.audioSend.subscribe(audioSend => {
      this._toggleStreamEnabled(z.media.MediaType.AUDIO, audioSend);
    });
    this.selfStreamState.screenSend.subscribe(screenSend => {
      this._toggleStreamEnabled(z.media.MediaType.VIDEO, screenSend);
    });
    this.selfStreamState.videoSend.subscribe(videoSend => {
      this._toggleStreamEnabled(z.media.MediaType.VIDEO, videoSend);
    });

    this.hasActiveVideo = ko.pureComputed(() => this.selfStreamState.screenSend() || this.selfStreamState.videoSend());

    this.requestHintTimeout = undefined;

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.ADD_STREAM, this.addRemoteMediaStream.bind(this));
    amplify.subscribe(z.event.WebApp.CALL.MEDIA.CONNECTION_CLOSED, this.removeRemoteMediaStreamTracks.bind(this));
  }

  //##############################################################################
  // Local MediaStream handling
  //##############################################################################

  /**
   * Initiate the MediaStream.
   *
   * @param {string} conversationId - Conversation ID of call
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @param {boolean} [isGroup=false] - Set constraints for group
   * @returns {Promise} Resolves when the MediaStream has been initiated
   */
  initiateMediaStream(conversationId, mediaType = z.media.MediaType.AUDIO, isGroup = false) {
    const videoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;

    return this.devicesHandler
      .updateCurrentDevices(videoSend)
      .then(() => this.constraintsHandler.getMediaStreamConstraints(true, videoSend, isGroup))
      .then(streamConstraints => this.requestMediaStream(mediaType, streamConstraints))
      .then(mediaStreamInfo => this._initiateMediaStreamSuccess(conversationId, mediaStreamInfo))
      .catch(error => {
        this._initiateMediaStreamFailure(error, conversationId);

        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CALLING.FAILED_REQUESTING_MEDIA, {
          cause: error.name || error.message,
          video: videoSend,
        });

        throw error;
      });
  }

  /**
   * Release the local MediaStream.
   * @returns {undefined} Not return value
   */
  releaseMediaStream() {
    if (this._releaseMediaStream(this.localMediaStream())) {
      this.localMediaStream(undefined);
    }
  }

  /**
   * Replace the MediaStream after a change of the selected input device.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Info about new MediaStream
   * @returns {undefined} No return value
   */
  changeMediaStream(mediaStreamInfo) {
    const mediaStream = mediaStreamInfo.stream;

    const logMessage = `Received new MediaStream containing '${mediaStream.getTracks().length}' track/s`;
    const logObject = {
      audioTracks: mediaStream.getAudioTracks(),
      stream: mediaStream,
      videoTracks: mediaStream.getVideoTracks(),
    };
    this.logger.debug(logMessage, logObject);

    const replacePromise = this.joinedCall()
      ? this._updateJoinedCall(mediaStreamInfo)
      : Promise.resolve({replacedTrack: false, streamInfo: mediaStreamInfo});

    replacePromise.then(this._handleReplacedMediaStream.bind(this));
  }

  _handleReplacedMediaStream({replacedTrack, streamInfo: mediaStreamInfo}) {
    const replaceMediaStreamLocally = newMediaStreamInfo => {
      const newMediaStream = newMediaStreamInfo.stream;
      const newMediaStreamType = newMediaStreamInfo.getType();

      this._releaseMediaStream(this.localMediaStream());
      this._setStreamState(newMediaStream, newMediaStreamType);
      this.localMediaStream(newMediaStream);
    };

    const replaceMediaTracksLocally = newMediaStreamInfo => {
      const mediaStream = newMediaStreamInfo.stream;
      const mediaType = newMediaStreamInfo.getType();
      const localMediaStream = this.localMediaStream();

      if (localMediaStream) {
        this._releaseTracksFromStream(localMediaStream, mediaType);
        this._addTracksToStream(mediaStream, localMediaStream, mediaType);
      } else {
        this.localMediaStream(mediaStream);
      }
    };

    return replacedTrack ? replaceMediaTracksLocally(mediaStreamInfo) : replaceMediaStreamLocally(mediaStreamInfo);
  }

  /**
   * Update the used MediaStream after a new input device was selected.
   * @param {z.media.MediaType} mediaType - Media type of device that was replaced
   * @returns {Promise} Resolves when the input source has been replaced
   */
  replaceInputSource(mediaType) {
    const isPreferenceChange = this.currentCalls.size === 0;

    let constraintsPromise;
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        constraintsPromise = this.constraintsHandler.getMediaStreamConstraints(true, isPreferenceChange);
        break;
      }

      case z.media.MediaType.SCREEN: {
        constraintsPromise = this.constraintsHandler.getScreenStreamConstraints();
        break;
      }

      case z.media.MediaType.VIDEO: {
        constraintsPromise = this.constraintsHandler.getMediaStreamConstraints(isPreferenceChange, true);
        break;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }

    return constraintsPromise
      .then(streamConstraints => this.requestMediaStream(mediaType, streamConstraints))
      .then(mediaStreamInfo => {
        // FIXME: the mediaStreamInUse should be more intelligent and handle all scenarios where the stream is actually needed
        if (!isPreferenceChange && !this.mediaStreamInUse()) {
          // in case the stream is returned after the call has actually ended, we need to release the stream right away
          this.logger.warn('Releasing obsolete MediaStream as there is no active call', mediaStreamInfo);
          return this._releaseMediaStream(mediaStreamInfo.stream);
        }

        this._setSelfStreamState(mediaType);
        this.changeMediaStream(mediaStreamInfo);
      })
      .catch(error => {
        const isMediaTypeScreen = mediaType === z.media.MediaType.SCREEN;
        const logMessage = isMediaTypeScreen
          ? `Could not enable screen sharing: ${error.message}`
          : `Could not replace '${mediaType}' input source: ${error.message}`;
        this.logger.warn(logMessage, error);

        throw error;
      });
  }

  /**
   * Request a MediaStream.
   *
   * @param {z.media.MediaType} mediaType - Type of MediaStream to be requested
   * @param {RTCMediaStreamConstraints} mediaStreamConstraints - Constraints for the MediaStream to be requested
   * @returns {Promise} Resolves with the stream and its type
   */
  requestMediaStream(mediaType, mediaStreamConstraints) {
    return this._checkDeviceAvailability(mediaType)
      .then(() => this._hasPermissionToAccess(mediaType))
      .then(hasPermission => this._requestMediaStream(mediaType, mediaStreamConstraints, hasPermission))
      .catch(error => {
        const isPermissionDenied = error.type === z.error.PermissionError.TYPE.DENIED;
        throw isPermissionDenied
          ? new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION, mediaType)
          : error;
      });
  }

  /**
   * Add tracks to a new stream.
   *
   * @private
   * @param {MediaStream} sourceStream - MediaStream to take tracks from
   * @param {MediaStream} targetStream - MediaStream to add tracks to
   * @param {z.media.MediaType} mediaType - Type of track to add
   * @returns {undefined} Not return value
   */
  _addTracksToStream(sourceStream, targetStream, mediaType) {
    const mediaStreamTracks = MediaStreamHandler.getMediaTracks(sourceStream, mediaType);
    mediaStreamTracks.forEach(mediaStreamTrack => targetStream.addTrack(mediaStreamTrack));
  }

  /**
   * Check for devices of requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Promise} Resolves when the device availability has been verified
   */
  _checkDeviceAvailability(mediaType) {
    const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
    const noVideoTypes = !this.deviceSupport.videoInput() && videoTypes.includes(mediaType);
    if (noVideoTypes) {
      const mediaError = new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, z.media.MediaType.VIDEO);
      return Promise.reject(mediaError);
    }

    const audioTypes = [z.media.MediaType.AUDIO, z.media.MediaType.AUDIO_VIDEO];
    const noAudioDevice = !this.deviceSupport.audioInput() && audioTypes.includes(mediaType);
    if (noAudioDevice) {
      const mediaError = new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, z.media.MediaType.AUDIO);
      return Promise.reject(mediaError);
    }

    return Promise.resolve();
  }

  /**
   * Check for permission for the requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Promise} Resolves true when permissions is granted
   */
  _hasPermissionToAccess(mediaType) {
    if (!z.util.Environment.browser.supports.mediaPermissions) {
      return Promise.resolve(false);
    }

    const checkPermissionStates = typesToCheck => {
      return this.permissionRepository.getPermissionStates(typesToCheck).then(permissions => {
        for (const permission of permissions) {
          const {permissionState, permissionType} = permission;
          const isPermissionPrompt = permissionState === z.permission.PermissionStatusState.PROMPT;
          if (isPermissionPrompt) {
            this.logger.info(`Need to prompt for '${permissionType}' permission`, permissions);
            return Promise.resolve(false);
          }

          const isPermissionDenied = permissionState === z.permission.PermissionStatusState.DENIED;
          if (isPermissionDenied) {
            this.logger.warn(`Permission for '${permissionType}' is denied`, permissions);
            return Promise.reject(new z.error.PermissionError(z.error.PermissionError.TYPE.DENIED));
          }
        }

        return Promise.resolve(true);
      });
    };

    const permissionTypes = this._getPermissionTypes(mediaType);
    const shouldCheckPermissions = permissionTypes && permissionTypes.length;
    return shouldCheckPermissions ? checkPermissionStates(permissionTypes) : Promise.resolve(true);
  }

  /**
   * Get permission types for the requested media type.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Requested media type
   * @returns {Array<z.permission.PermissionType>} Array containing the necessary permission types
   */
  _getPermissionTypes(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return [z.permission.PermissionType.MICROPHONE];
      }

      case z.media.MediaType.AUDIO_VIDEO: {
        return [z.permission.PermissionType.CAMERA, z.permission.PermissionType.MICROPHONE];
      }

      case z.media.MediaType.VIDEO: {
        return [z.permission.PermissionType.CAMERA];
      }
    }
  }

  /**
   * Clear the permission request hint timeout or hide the warning.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _clearPermissionRequestHint(mediaType) {
    if (this.requestHintTimeout) {
      return window.clearTimeout(this.requestHintTimeout);
    }
    this._hidePermissionRequestHint(mediaType);
  }

  /**
   * Hide the permission denied hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _hidePermissionFailedHint(mediaType) {
    const warningType = this._selectPermissionDeniedWarningType(mediaType);
    amplify.publish(z.event.WebApp.WARNING.DISMISS, warningType);
  }

  /**
   * Hide the permission request hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested stream
   * @returns {undefined} No return value
   */
  _hidePermissionRequestHint(mediaType) {
    if (!z.util.Environment.electron) {
      const warningType = this._selectPermissionRequestWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.DISMISS, warningType);
    }
  }

  /**
   * Initial request for local MediaStream was successful.
   *
   * @private
   * @param {string} conversationId - ID of conversation to initiate MediaStream for
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - Type of requested MediaStream
   * @returns {undefined} No return value
   */
  _initiateMediaStreamSuccess(conversationId, mediaStreamInfo) {
    if (mediaStreamInfo) {
      const callEntity = this.currentCalls.get(conversationId);
      const callNeedsMediaStream = callEntity && callEntity.needsMediaStream();
      const mediaStream = mediaStreamInfo.stream;

      if (!callNeedsMediaStream) {
        this.logger.warn(`Releasing obsolete MediaStream as call '${conversationId}' is no longer active`, callEntity);
        return this._releaseMediaStream(mediaStream);
      }

      const mediaType = mediaStreamInfo.getType();
      const isVideoSend = mediaType === z.media.MediaType.AUDIO_VIDEO;
      this.selfStreamState.videoSend(isVideoSend);
      if (isVideoSend) {
        this.localMediaType(z.media.MediaType.VIDEO);
      }

      const logMessage = `Received initial MediaStream containing '${mediaStream.getTracks().length}' tracks/s`;
      const logObject = {
        audioTracks: mediaStream.getAudioTracks(),
        stream: mediaStream,
        videoTracks: mediaStream.getVideoTracks(),
      };
      this.logger.debug(logMessage, logObject);

      this._setStreamState(mediaStream, mediaType);
      this.localMediaStream(mediaStream);
    }
  }

  /**
   * Local MediaStream creation failed.
   *
   * @private
   * @param {z.error.MediaError} error - MediaError
   * @param {string} conversationId - Conversation ID
   * @returns {undefined} No return value
   */
  _initiateMediaStreamFailure(error, conversationId) {
    const {type, mediaType} = error;

    if (mediaType) {
      const isStreamDeviceError = type === z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE;
      return isStreamDeviceError
        ? this._showDeviceNotFoundHint(mediaType, conversationId)
        : this._showPermissionDeniedHint(mediaType);
    }
  }

  /**
   * Release a MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to be released
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of MediaStreamTracks to be released
   * @returns {boolean} Have tracks been stopped
   */
  _releaseMediaStream(mediaStream, mediaType = z.media.MediaType.AUDIO_VIDEO) {
    return mediaStream ? this._releaseTracksFromStream(mediaStream, mediaType) : false;
  }

  /**
   * Release tracks from a MediaStream.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to release tracks from
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO_VIDEO] - Type of MediaStreamTracks to be released
   * @returns {boolean} Have tracks been stopped
   */
  _releaseTracksFromStream(mediaStream, mediaType) {
    const mediaStreamTracks = MediaStreamHandler.getMediaTracks(mediaStream, mediaType);

    if (mediaStreamTracks.length) {
      mediaStreamTracks.forEach(mediaStreamTrack => {
        mediaStream.removeTrack(mediaStreamTrack);
        mediaStreamTrack.stop();
        this.logger.info(`Stopping MediaStreamTrack of kind '${mediaStreamTrack.kind}' successful`, mediaStreamTrack);
      });

      return true;
    }

    this.logger.warn('No MediaStreamTrack found to stop', mediaStream);
    return false;
  }

  _schedulePermissionHint(mediaType) {
    this.requestHintTimeout = window.setTimeout(() => {
      this._hidePermissionFailedHint(mediaType);
      this._showPermissionRequestHint(mediaType);
      this.requestHintTimeout = undefined;
    }, MediaStreamHandler.CONFIG.PERMISSION_HINT_DELAY);
  }

  /**
   * Request a MediaStream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of MediaStream to be requested
   * @param {RTCMediaStreamConstraints} mediaStreamConstraints - Constraints for the MediaStream to be requested
   * @param {boolean} hasPermission - Has required media permissions
   * @returns {Promise} Resolves with the stream and its type
   */
  _requestMediaStream(mediaType, mediaStreamConstraints, hasPermission) {
    this.logger.info(`Requesting MediaStream access for '${mediaType}'`, mediaStreamConstraints);

    const willPromptForPermission = !hasPermission && !z.util.Environment.desktop;
    if (willPromptForPermission) {
      this._schedulePermissionHint(mediaType);
    }

    return navigator.mediaDevices
      .getUserMedia(mediaStreamConstraints)
      .then(mediaStream => {
        this._clearPermissionRequestHint(mediaType);
        return new z.media.MediaStreamInfo(z.media.MediaStreamSource.LOCAL, 'self', mediaStream);
      })
      .catch(error => {
        const {message, name} = error;
        this.logger.warn(`MediaStream request for '${mediaType}' failed: ${name} ${message}`, error);
        this._clearPermissionRequestHint(mediaType);

        if (z.media.MEDIA_STREAM_ERROR_TYPES.DEVICE.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE, mediaType);
        }

        if (z.media.MEDIA_STREAM_ERROR_TYPES.MISC.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_MISC, mediaType);
        }

        if (z.media.MEDIA_STREAM_ERROR_TYPES.PERMISSION.includes(name)) {
          throw new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION, mediaType);
        }

        throw error;
      });
  }

  _selectPermissionDeniedWarningType(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_MICROPHONE;
      }

      case z.media.MediaType.SCREEN: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_SCREEN;
      }

      case z.media.MediaType.AUDIO_VIDEO:
      case z.media.MediaType.VIDEO: {
        return z.viewModel.WarningsViewModel.TYPE.DENIED_CAMERA;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  _selectPermissionRequestWarningType(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_MICROPHONE;
      }

      case z.media.MediaType.SCREEN: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_SCREEN;
      }

      case z.media.MediaType.AUDIO_VIDEO:
      case z.media.MediaType.VIDEO: {
        return z.viewModel.WarningsViewModel.TYPE.REQUEST_CAMERA;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  /**
   * Show microphone not found hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of device not found
   * @param {string} conversationId - Optional conversation ID
   * @returns {undefined} No return value
   */
  _showDeviceNotFoundHint(mediaType, conversationId) {
    if (mediaType === z.media.MediaType.AUDIO) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NOT_FOUND_MICROPHONE);
    } else if (mediaType === z.media.MediaType.VIDEO) {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NOT_FOUND_CAMERA);
    }

    if (conversationId) {
      amplify.publish(z.event.WebApp.CALL.STATE.REJECT, conversationId);
    }
  }

  /**
   * Show permission denied hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of media access request
   * @returns {undefined} No return value
   */
  _showPermissionDeniedHint(mediaType) {
    const videoTypes = [z.media.MediaType.AUDIO_VIDEO, z.media.MediaType.VIDEO];
    if (!videoTypes.includes(mediaType)) {
      const warningType = this._selectPermissionDeniedWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.SHOW, warningType);
    }
  }

  /**
   * Show permission request hint banner.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of requested MediaStream
   * @returns {undefined} No return value
   */
  _showPermissionRequestHint(mediaType) {
    if (!z.util.Environment.electron) {
      const warningType = this._selectPermissionRequestWarningType(mediaType);
      amplify.publish(z.event.WebApp.WARNING.SHOW, warningType);
    }
  }

  /**
   * Update MediaStream used in joined call.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - New MediaStream to use
   * @returns {Promise} Resolves when MediaStream was replaced
   */
  _updateJoinedCall(mediaStreamInfo) {
    this._setStreamState(mediaStreamInfo.stream, mediaStreamInfo.getType());
    const flowEntities = this.joinedCall().getFlows();
    const [firstFlowEntity] = flowEntities;

    const replaceMediaTrackInFlows = (streamInfo, flows) => {
      const replacementPromises = flows.map(flowEntity => flowEntity.replaceMediaTrack(streamInfo));
      return Promise.all(replacementPromises).then(() => ({replacedTrack: true, streamInfo}));
    };

    const replaceMediaStreamInFlows = (streamInfo, flows) => {
      return this._updateMediaStream(streamInfo).then(newMediaStreamInfo => {
        const upgradePromises = flows.map(flowEntity => {
          return flowEntity.replaceMediaStream(newMediaStreamInfo, this.localMediaStream());
        });
        return Promise.all(upgradePromises).then(() => ({replacedTrack: false, streamInfo: newMediaStreamInfo}));
      });
    };

    return firstFlowEntity
      .supportsTrackReplacement(mediaStreamInfo.getType())
      .then(canReplaceTracks => {
        return canReplaceTracks
          ? replaceMediaTrackInFlows(mediaStreamInfo, flowEntities)
          : replaceMediaStreamInFlows(mediaStreamInfo, flowEntities);
      })
      .catch(error => {
        const message = `Failed to update call with '${mediaStreamInfo.getType()}': ${error.name} - ${error.message}`;
        this.logger.error(message, error);
        throw error;
      });
  }

  /**
   * Upgrade the local MediaStream with new MediaStreamTracks.
   *
   * @private
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStreamInfo containing new MediaStreamTracks
   * @returns {Promise<z.media.MediaStreamInfo>} Resolves with new MediaStream to be used
   */
  _updateMediaStream(mediaStreamInfo) {
    if (!this.localMediaStream()) {
      return Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.STREAM_NOT_FOUND));
    }

    const newMediaStream = mediaStreamInfo.stream;
    const mediaType = mediaStreamInfo.getType();
    this._releaseTracksFromStream(this.localMediaStream(), mediaType);

    const clonedMediaStream = this.localMediaStream().clone();
    const clonedMediaStreamType = MediaStreamHandler.detectMediaStreamType(clonedMediaStream);
    // Reset MediaStreamTrack enabled states as older Chrome versions fail to copy these when cloning
    this._setStreamState(clonedMediaStream, clonedMediaStreamType);
    this._addTracksToStream(newMediaStream, clonedMediaStream, mediaType);

    this.logger.info(`Upgraded the MediaStream to update '${mediaType}'`, clonedMediaStream);
    return Promise.resolve(new z.media.MediaStreamInfo(z.media.MediaStreamSource.LOCAL, 'self', clonedMediaStream));
  }

  //##############################################################################
  // Remote MediaStream handling
  //##############################################################################

  /**
   * Add a remote MediaStream.
   * @param {z.media.MediaStreamInfo} mediaStreamInfo - MediaStream information
   * @returns {undefined} No return value
   */
  addRemoteMediaStream(mediaStreamInfo) {
    const handledStreamTypes = [z.media.MediaType.AUDIO, z.media.MediaType.VIDEO, z.media.MediaType.AUDIO_VIDEO];
    if (!handledStreamTypes.includes(mediaStreamInfo.getType())) {
      throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
    }

    this.remoteMediaStreamInfo.push(mediaStreamInfo);
    this.elementHandler.addMediaElement(mediaStreamInfo);
  }

  /**
   * Removes the given tracks from the streams containing them.
   * If a stream ends up having no tracks, it gets filtered out from the array of streams
   * removeRemoteMediaStreamTracks
   *
   * @param {MediaStreamTrack[]} tracks - the tracks to remove
   * @returns {void} - void
   */
  removeRemoteMediaStreamTracks(tracks) {
    const filteredMediaStreamsInfo = this.remoteMediaStreamInfo()
      .map(mediaStreamInfo => {
        tracks.forEach(track => mediaStreamInfo.stream.removeTrack(track));
        return mediaStreamInfo;
      })
      .filter(mediaStreamInfo => mediaStreamInfo.stream.getTracks().length);

    this.remoteMediaStreamInfo(filteredMediaStreamsInfo);
  }

  //##############################################################################
  // Media handling
  //##############################################################################

  /**
   * Check for active calls that need a MediaStream.
   * @returns {boolean} Returns true if an active media stream is needed for at least one call
   */
  mediaStreamInUse() {
    for (const callEntity of this.currentCalls.values()) {
      const callNeedsMediaStream = callEntity.needsMediaStream();
      if (callNeedsMediaStream) {
        return true;
      }
    }

    return false;
  }

  // Toggle the mute state of the microphone.
  toggleAudioSend() {
    return this._toggleAudioSend();
  }

  // Toggle the screen.
  toggleScreenSend() {
    return this._toggleMediaSend(z.media.MediaType.SCREEN, this._toggleScreenSend);
  }

  // Toggle the camera.
  toggleVideoSend() {
    return this._toggleMediaSend(z.media.MediaType.VIDEO, this._toggleVideoSend);
  }

  // Reset the enabled states of media types.
  resetSelfStates() {
    this.selfStreamState.audioSend(true);
    this.selfStreamState.screenSend(false);
    this.selfStreamState.videoSend(false);
    this.localMediaType(z.media.MediaType.AUDIO);
  }

  // Reset the MediaStream and states.
  resetMediaStream() {
    if (!this.mediaStreamInUse()) {
      this.releaseMediaStream();
      this.resetSelfStates();
      this.mediaRepository.closeAudioContext();
    }
  }

  /**
   * Set the self stream state to reflect current media type.
   * @param {z.media.MediaType} mediaType - Type of state to enable
   * @returns {undefined} No return value
   */
  _setSelfStreamState(mediaType) {
    switch (mediaType) {
      case z.media.MediaType.AUDIO: {
        this.selfStreamState.audioSend(true);
        break;
      }

      case z.media.MediaType.SCREEN: {
        this.selfStreamState.videoSend(false);
        this.selfStreamState.screenSend(true);
        this.localMediaType(z.media.MediaType.SCREEN);
        break;
      }

      case z.media.MediaType.VIDEO: {
        this.selfStreamState.videoSend(true);
        this.selfStreamState.screenSend(false);
        this.localMediaType(z.media.MediaType.VIDEO);
        break;
      }

      default: {
        throw new z.error.MediaError(z.error.MediaError.TYPE.UNHANDLED_MEDIA_TYPE);
      }
    }
  }

  /**
   * Set the enabled state of a new MediaStream.
   * @private
   * @param {MediaStream} mediaStream - MediaStream to set state on
   * @param {z.media.MediaType} mediaType - Type to set state for
   * @returns {undefined} No return value
   */
  _setStreamState(mediaStream, mediaType) {
    const includesAudioTracks = MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_AUDIO.includes(mediaType);
    if (includesAudioTracks) {
      this._setTrackState(mediaStream, z.media.MediaType.AUDIO);
    }

    const includesVideoTracks = MediaStreamHandler.CONFIG.MEDIA_TYPE.CONTAINS_VIDEO.includes(mediaType);
    if (includesVideoTracks) {
      this._setTrackState(mediaStream, z.media.MediaType.VIDEO);
    }
  }

  _setTrackState(mediaStream, mediaType) {
    const streamTracks = MediaStreamHandler.getMediaTracks(mediaStream, mediaType);

    if (streamTracks.length > 1) {
      this.logger.warn(`Media stream contains multiple '${mediaType}' tracks`, streamTracks);
    }

    const isVideo = mediaType === z.media.MediaType.VIDEO;
    const isEnabledState = isVideo ? this.hasActiveVideo() : this.selfStreamState.audioSend();

    streamTracks.forEach(streamTrack => (streamTrack.enabled = isEnabledState));
    const logMessage = `Set stream '${mediaType}' enabled to '${isEnabledState}' on '${streamTracks.length}' tracks`;
    this.logger.log(logMessage, streamTracks);
  }

  /**
   * Toggle the audio stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleAudioSend() {
    return this._toggleSendState(this.selfStreamState.audioSend, 'Microphone');
  }

  /**
   * Toggle the screen stream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Type of media to toggle
   * @param {Function} toggleFn - Function to toggle type of media
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleMediaSend(mediaType, toggleFn) {
    const hasActiveScreenStream = this.localMediaStream() && this.localMediaType() === mediaType;
    return hasActiveScreenStream ? toggleFn() : this.replaceInputSource(mediaType);
  }

  /**
   * Toggle the screen stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleScreenSend() {
    return this._toggleSendState(this.selfStreamState.screenSend, 'Screen');
  }

  /**
   * Toggle a given send state.
   *
   * @private
   * @param {ko.observable} stateObservable - State to toggle
   * @param {string} name - Name of state being toggled
   * @returns {Promise} Resolves when the state has been toggled
   */
  _toggleSendState(stateObservable, name) {
    return Promise.resolve().then(() => {
      stateObservable(!stateObservable());
      this.logger.info(`${name} enabled: ${stateObservable()}`);
      return stateObservable();
    });
  }

  /**
   * Toggle the video stream.
   * @private
   * @returns {Promise} Resolves when the stream has been toggled
   */
  _toggleVideoSend() {
    return this._toggleSendState(this.selfStreamState.videoSend, 'Camera');
  }

  /**
   * Toggle the enabled state of a MediaStream.
   *
   * @private
   * @param {z.media.MediaType} mediaType - Media type to toggle
   * @param {boolean} sendState - New call property send state
   * @returns {undefined} No return value
   */
  _toggleStreamEnabled(mediaType, sendState) {
    const isTypeAudio = mediaType === z.media.MediaType.AUDIO;
    if (isTypeAudio) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.MUTE_AUDIO, !sendState);
    }

    if (this.localMediaStream()) {
      const mediaStreamTracks = MediaStreamHandler.getMediaTracks(this.localMediaStream(), mediaType);
      mediaStreamTracks.forEach(mediaStreamTrack => (mediaStreamTrack.enabled = sendState));
    }
  }

  updateCurrentCalls(callEntities) {
    this.currentCalls.clear();
    callEntities.forEach(callEntity => this.currentCalls.set(callEntity.id, callEntity));
  }

  setJoinedCall(callEntity) {
    this.joinedCall(callEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamSource = {
  LOCAL: 'local',
  REMOTE: 'remote',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaStreamInfo = class MediaStreamInfo {
  constructor(source, flowId, stream, callEntity) {
    this.source = source;
    this.flowId = flowId;
    this.stream = stream;
    this.callEntity = callEntity;

    this.conversationId = callEntity ? callEntity.id : undefined;
  }

  getType() {
    return z.media.MediaStreamHandler.detectMediaStreamType(this.stream);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.MediaType = {
  AUDIO: 'audio',
  AUDIO_VIDEO: 'audio/video',
  NONE: 'none',
  SCREEN: 'screen',
  VIDEO: 'video',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.media = z.media || {};

z.media.VIDEO_QUALITY_MODE = {
  FULL_HD: 'z.media.VIDEO_QUALITY_MODE.FULL_HD',
  GROUP: 'z.media.VIDEO_QUALITY_MODE.GROUP',
  HD: 'z.media.VIDEO_QUALITY_MODE.MOBILE.HD',
  MOBILE: 'z.media.VIDEO_QUALITY_MODE.MOBILE',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.motion = z.motion || {};

z.motion.MotionDuration = {
  LONG: 550,
  MEDIUM: 350,
  SHORT: 150,
  X_LONG: 700,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

// https://developer.mozilla.org/en-US/docs/Web/API/Notification/permission
z.notification.PermissionState = {
  DEFAULT: 'default',
  DENIED: 'denied',
  GRANTED: 'granted',
  IGNORED: 'ignored',
  UNSUPPORTED: 'unsupported',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

// Enum of notification preferences.
z.notification.NotificationPreference = {
  NONE: 'none',
  OBFUSCATE: 'obfuscate',
  OBFUSCATE_MESSAGE: 'obfuscate-message',
  ON: 'on',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.notification = z.notification || {};

/**
 * Notification repository to trigger browser and audio notifications.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/notification
 * @see http://www.w3.org/TR/notifications
 */
z.notification.NotificationRepository = class NotificationRepository {
  static get CONFIG() {
    return {
      BODY_LENGTH: 80,
      ICON_URL: '/image/logo/notification.png',
      TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 5,
      TITLE_LENGTH: 38,
    };
  }

  static get EVENTS_TO_NOTIFY() {
    return [
      z.message.SuperType.CALL,
      z.message.SuperType.CONTENT,
      z.message.SuperType.MEMBER,
      z.message.SuperType.PING,
      z.message.SuperType.REACTION,
      z.message.SuperType.SYSTEM,
    ];
  }

  /**
   * Construct a new Notification Repository.
   * @param {z.calling.CallingRepository} callingRepository - Repository for all call interactions
   * @param {z.conversation.ConversationRepository} conversationRepository - Repository for all conversation interactions
   * @param {z.permission.PermissionRepository} permissionRepository - Repository for all permission interactions
   * @param {z.user.UserRepository} userRepository - Repository for users
   */
  constructor(callingRepository, conversationRepository, permissionRepository, userRepository) {
    this.callingRepository = callingRepository;
    this.conversationRepository = conversationRepository;
    this.permissionRepository = permissionRepository;
    this.userRepository = userRepository;

    this.logger = new z.util.Logger('z.notification.NotificationRepository', z.config.LOGGER.OPTIONS);

    this.notifications = [];

    this.subscribeToEvents();
    this.notificationsPreference = ko.observable(z.notification.NotificationPreference.ON);
    this.notificationsPreference.subscribe(notificationsPreference => {
      const preferenceIsNone = notificationsPreference === z.notification.NotificationPreference.NONE;
      if (!preferenceIsNone) {
        this.checkPermission();
      }
    });

    this.permissionState = this.permissionRepository.permissionState[z.permission.PermissionType.NOTIFICATIONS];
    this.selfUser = this.userRepository.self;
  }

  subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.NOTIFICATION.NOTIFY, this.notify.bind(this));
    amplify.subscribe(z.event.WebApp.NOTIFICATION.PERMISSION_STATE, this.updatePermissionState.bind(this));
    amplify.subscribe(z.event.WebApp.NOTIFICATION.REMOVE_READ, this.removeReadNotifications.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updatedProperties.bind(this));
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.NOTIFICATIONS, this.updatedNotificationsProperty.bind(this));
  }

  /**
   * Check for browser permission if we have not yet asked.
   * @returns {Promise} Promise that resolves with the permission state
   */
  checkPermission() {
    return this._checkPermissionState().then(isPermitted => {
      if (_.isBoolean(isPermitted)) {
        return isPermitted;
      }

      if (!z.util.Environment.browser.supports.notifications) {
        return this.updatePermissionState(z.notification.PermissionState.UNSUPPORTED);
      }

      if (z.util.Environment.browser.supports.permissions) {
        return this.permissionRepository.getPermissionState(z.permission.PermissionType.NOTIFICATIONS).then(() => {
          const shouldRequestPermission = this.permissionState() === z.permission.PermissionStatusState.PROMPT;
          return shouldRequestPermission ? this._requestPermission() : this._checkPermissionState();
        });
      }

      const currentPermission = window.Notification.permission;
      const shouldRequestPermission = currentPermission === z.notification.PermissionState.DEFAULT;
      return shouldRequestPermission ? this._requestPermission() : this.updatePermissionState(currentPermission);
    });
  }

  /**
   * Close all notifications.
   * @returns {undefined} No return value
   */
  clearNotifications() {
    this.notifications.forEach(notification => {
      notification.close();
      if (notification.data) {
        const {conversationId, messageId} = notification.data;
        this.logger.info(`Notification for '${messageId}' in '${conversationId}' closed on unload.`, notification);
      }
    });
  }

  /**
   * Display browser notification and play sound notification.
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves when notification has been handled
   */
  notify(messageEntity, connectionEntity, conversationEntity) {
    const notifyInConversation = conversationEntity
      ? NotificationRepository.shouldNotifyInConversation(conversationEntity, messageEntity, this.selfUser().id)
      : true;

    return Promise.resolve(notifyInConversation).then(shouldNotifyInConversation => {
      if (shouldNotifyInConversation) {
        this._notifySound(messageEntity);
        return this._notifyBanner(messageEntity, connectionEntity, conversationEntity);
      }
    });
  }

  // Remove notifications from the queue that are no longer unread
  removeReadNotifications() {
    this.notifications.forEach(notification => {
      const {conversationId, messageId, messageType} = notification.data || {};

      if (messageId) {
        this.conversationRepository.is_message_read(conversationId, messageId).then(isRead => {
          if (isRead) {
            notification.close();
            const messageInfo = messageId
              ? `message '${messageId}' of type '${messageType}'`
              : `'${messageType}' message`;
            this.logger.info(`Removed read notification for ${messageInfo} in '${conversationId}'.`);
          }
        });
      }
    });
  }

  updatedProperties(properties) {
    const notificationPreference = properties.settings.notifications;
    return this.notificationsPreference(notificationPreference);
  }

  updatedNotificationsProperty(notificationPreference) {
    return this.notificationsPreference(notificationPreference);
  }

  /**
   * Set the permission state.
   * @param {z.permission.PermissionStatusState} permissionState - State of browser permission
   * @returns {Promise} Resolves with true if notifications are enabled
   */
  updatePermissionState(permissionState) {
    this.permissionState(permissionState);
    return this._checkPermissionState();
  }

  /**
   * Creates the notification body for calls.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {string} Notification message body
   */
  _createBodyCall(messageEntity) {
    if (messageEntity.is_activation()) {
      return z.l10n.text(z.string.notificationVoiceChannelActivate);
    }

    if (messageEntity.is_deactivation() && messageEntity.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED) {
      return z.l10n.text(z.string.notificationVoiceChannelDeactivate);
    }
  }

  /**
   * Creates the notification body for text messages and pictures.
   *
   * @private
   * @param {z.entity.ContentMessage} messageEntity - Normal message entity
   * @returns {string} Notification message body
   */
  _createBodyContent(messageEntity) {
    if (messageEntity.has_asset_text()) {
      for (const assetEntity of messageEntity.assets()) {
        if (assetEntity.is_text()) {
          let notificationText;

          if (assetEntity.isUserMentioned(this.selfUser().id)) {
            notificationText = z.l10n.text(z.string.notificationMention, assetEntity.text);
          } else if (messageEntity.isUserQuoted(this.selfUser().id)) {
            notificationText = z.l10n.text(z.string.notificationReply, assetEntity.text);
          } else {
            notificationText = assetEntity.text;
          }

          return z.util.StringUtil.truncate(notificationText, NotificationRepository.CONFIG.BODY_LENGTH);
        }
      }
    }

    if (messageEntity.has_asset_image()) {
      return z.l10n.text(z.string.notificationAssetAdd);
    }

    if (messageEntity.has_asset_location()) {
      return z.l10n.text(z.string.notificationSharedLocation);
    }

    if (messageEntity.has_asset()) {
      const assetEntity = messageEntity.get_first_asset();

      if (assetEntity.is_audio()) {
        return z.l10n.text(z.string.notificationSharedAudio);
      }

      if (assetEntity.is_video()) {
        return z.l10n.text(z.string.notificationSharedVideo);
      }

      if (assetEntity.is_file()) {
        return z.l10n.text(z.string.notificationSharedFile);
      }
    }
  }

  /**
   * Creates the notification body for people being added to a group conversation.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodyMemberJoin(messageEntity) {
    const updatedOneParticipant = messageEntity.userEntities().length === 1;
    if (updatedOneParticipant) {
      const [otherUserEntity] = messageEntity.userEntities();

      const declension = z.string.Declension.ACCUSATIVE;
      const nameOfJoinedUser = z.util.SanitizationUtil.getFirstName(otherUserEntity, declension);

      const senderJoined = messageEntity.user().id === otherUserEntity.id;
      if (senderJoined) {
        return z.l10n.text(z.string.notificationMemberJoinSelf, nameOfJoinedUser);
      }

      const substitutions = {user1: messageEntity.user().first_name(), user2: nameOfJoinedUser};
      return z.l10n.text(z.string.notificationMemberJoinOne, substitutions);
    }

    const substitutions = {number: messageEntity.userIds().length, user: messageEntity.user().first_name()};
    return z.l10n.text(z.string.notificationMemberJoinMany, substitutions);
  }

  /**
   * Creates the notification body for people being removed from or leaving a group conversation.
   * @note Only show a notification if self user was removed
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodyMemberLeave(messageEntity) {
    const updatedOneParticipant = messageEntity.userEntities().length === 1;
    if (updatedOneParticipant && !messageEntity.remoteUserEntities().length) {
      return z.l10n.text(z.string.notificationMemberLeaveRemovedYou, messageEntity.user().first_name());
    }
  }

  /**
   * Selects the type of system message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message body
   */
  _createBodyMemberUpdate(messageEntity, connectionEntity, conversationEntity) {
    const isGroup = conversationEntity && conversationEntity.isGroup();

    switch (messageEntity.memberMessageType) {
      case z.message.SystemMessageType.NORMAL:
        if (isGroup) {
          if (messageEntity.isMemberJoin()) {
            return this._createBodyMemberJoin(messageEntity);
          }
          if (messageEntity.isMemberLeave()) {
            return this._createBodyMemberLeave(messageEntity);
          }
        }
        break;
      case z.message.SystemMessageType.CONNECTION_ACCEPTED:
        return z.l10n.text(z.string.notificationConnectionAccepted);
      case z.message.SystemMessageType.CONNECTION_CONNECTED:
        return z.l10n.text(z.string.notificationConnectionConnected);
      case z.message.SystemMessageType.CONNECTION_REQUEST:
        return z.l10n.text(z.string.notificationConnectionRequest);
      case z.message.SystemMessageType.CONVERSATION_CREATE:
        return z.l10n.text(z.string.notificationConversationCreate, messageEntity.user().first_name());
      default:
        const conversationId = this._getConversationId(connectionEntity, conversationEntity);
        const message = `No notification for '${messageEntity.id} in '${conversationId}'.`;
        this.logger.log(this.logger.levels.OFF, message);
    }
  }

  /**
   * Creates the notification body for obfuscated messages.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message to obfuscate body for
   * @returns {string} Notification message body
   */
  _createBodyObfuscated(messageEntity) {
    if (messageEntity.is_content()) {
      const isSelfMentioned = messageEntity.isUserMentioned(this.selfUser().id);

      if (isSelfMentioned) {
        return z.l10n.text(z.string.notificationObfuscatedMention);
      }

      const isSelfQuoted = messageEntity.isUserQuoted(this.selfUser().id);

      if (isSelfQuoted) {
        return z.l10n.text(z.string.notificationObfuscatedReply);
      }
    }

    return z.l10n.text(z.string.notificationObfuscated);
  }

  /**
   * Creates the notification body for ping.
   * @private
   * @returns {string} Notification message body
   */
  _createBodyPing() {
    return z.l10n.text(z.string.notificationPing);
  }

  /**
   * Creates the notification body for reaction.
   * @private
   * @param {z.entity.Message} messageEntity - Fake reaction message entity
   * @returns {string} Notification message body
   */
  _createBodyReaction(messageEntity) {
    return z.l10n.text(z.string.notificationReaction, messageEntity.reaction);
  }

  /**
   * Selects the type of system message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.MemberMessage} messageEntity - Member message entity
   * @returns {string} Notification message body
   */
  _createBodySystem(messageEntity) {
    const createBodyMessageTimerUpdate = () => {
      const messageTimer = z.conversation.ConversationEphemeralHandler.validateTimer(messageEntity.message_timer);

      if (messageTimer) {
        const timeString = z.util.TimeUtil.formatDuration(messageTimer).text;
        const substitutions = {time: timeString, user: messageEntity.user().first_name()};
        return z.l10n.text(z.string.notificationConversationMessageTimerUpdate, substitutions);
      }
      return z.l10n.text(z.string.notificationConversationMessageTimerReset, messageEntity.user().first_name());
    };

    const createBodyRename = () => {
      const substitutions = {name: messageEntity.name, user: messageEntity.user().first_name()};
      return z.l10n.text(z.string.notificationConversationRename, substitutions);
    };

    switch (messageEntity.system_message_type) {
      case z.message.SystemMessageType.CONVERSATION_RENAME: {
        return createBodyRename();
      }

      case z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE: {
        return createBodyMessageTimerUpdate(messageEntity);
      }
    }
  }

  /**
   * Create notification content.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves with the notification content
   */
  _createNotificationContent(messageEntity, connectionEntity, conversationEntity) {
    let optionsBody = undefined;

    return this._createOptionsBody(messageEntity, connectionEntity, conversationEntity)
      .then(body => {
        optionsBody = body;
        if (optionsBody) {
          return this._shouldObfuscateNotificationSender(messageEntity);
        }
        throw new z.error.NotificationError(z.error.NotificationError.TYPE.HIDE_NOTIFICATION);
      })
      .then(shouldObfuscateSender => {
        return this._createOptionsIcon(shouldObfuscateSender, messageEntity.user()).then(iconUrl => {
          const shouldObfuscateMessage = this._shouldObfuscateNotificationMessage(messageEntity);
          return {
            options: {
              body: shouldObfuscateMessage ? this._createBodyObfuscated(messageEntity) : optionsBody,
              data: this._createOptionsData(messageEntity, connectionEntity, conversationEntity),
              icon: iconUrl,
              silent: true, // @note When Firefox supports this we can remove the fix for WEBAPP-731
              tag: this._createOptionsTag(connectionEntity, conversationEntity),
            },
            timeout: NotificationRepository.CONFIG.TIMEOUT,
            title: shouldObfuscateSender
              ? this._createTitleObfuscated()
              : this._createTitle(messageEntity, conversationEntity),
            trigger: this._createTrigger(messageEntity, connectionEntity, conversationEntity),
          };
        });
      });
  }

  /**
   * Selects the type of message that the notification body needs to be created for.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} connectionEntity - Connection entity
   * @param {z.entity.Conversation} conversationEntity - Conversation entity
   * @returns {Promise} Resolves with the notification message body
   */
  _createOptionsBody(messageEntity, connectionEntity, conversationEntity) {
    return Promise.resolve().then(() => {
      switch (messageEntity.super_type) {
        case z.message.SuperType.CALL:
          return this._createBodyCall(messageEntity);
        case z.message.SuperType.CONTENT:
          return this._createBodyContent(messageEntity);
        case z.message.SuperType.MEMBER:
          return this._createBodyMemberUpdate(messageEntity, connectionEntity, conversationEntity);
        case z.message.SuperType.PING:
          return this._createBodyPing();
        case z.message.SuperType.REACTION:
          return this._createBodyReaction(messageEntity);
        case z.message.SuperType.SYSTEM:
          return this._createBodySystem(messageEntity);
        default:
          const conversationId = this._getConversationId(connectionEntity, conversationEntity);
          const message = `No notification for '${messageEntity.id} in '${conversationId}'.`;
          this.logger.log(this.logger.levels.OFF, message);
      }
    });
  }

  /**
   * Creates the notification data to help check its content.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Object} Notification message data
   */
  _createOptionsData(messageEntity, connectionEntity, conversationEntity) {
    const {id: messageId, type: messageType} = messageEntity;

    return {
      conversationId: this._getConversationId(connectionEntity, conversationEntity),
      messageId: messageId === '0' ? undefined : messageId,
      messageType: messageType,
    };
  }

  /**
   * Creates the notification icon.
   *
   * @private
   * @param {boolean} shouldObfuscateSender - Sender visible in notification
   * @param {z.entity.User} userEntity - Sender of message
   * @returns {Promise} Resolves with the icon URL
   */
  _createOptionsIcon(shouldObfuscateSender, userEntity) {
    const canShowUserImage = userEntity.previewPictureResource() && !shouldObfuscateSender;
    if (canShowUserImage) {
      return userEntity
        .previewPictureResource()
        .generateUrl()
        .catch(error => {
          if (error instanceof z.util.ValidationUtilError) {
            this.logger.error(`Failed to validate an asset URL: ${error.message}`);
          }
          return '';
        });
    }

    const isMacOsWrapper = z.util.Environment.electron && z.util.Environment.os.mac;
    return Promise.resolve(isMacOsWrapper ? '' : NotificationRepository.CONFIG.ICON_URL);
  }

  /**
   * Creates the notification tag.
   *
   * @private
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message tag
   */
  _createOptionsTag(connectionEntity, conversationEntity) {
    return this._getConversationId(connectionEntity, conversationEntity);
  }

  /**
   * Creates the notification title.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} Notification message title
   */
  _createTitle(messageEntity, conversationEntity) {
    const conversationName = conversationEntity && conversationEntity.display_name();
    const userEntity = messageEntity.user();

    let title;
    if (conversationName) {
      title = conversationEntity.isGroup()
        ? z.l10n.text(z.string.notificationTitleGroup, {conversation: conversationName, user: userEntity.first_name()})
        : conversationName;
    }

    return z.util.StringUtil.truncate(title || userEntity.name(), NotificationRepository.CONFIG.TITLE_LENGTH, false);
  }

  /**
   * Create obfuscated title.
   * @private
   * @returns {string} Obfuscated notification message title
   */
  _createTitleObfuscated() {
    const obfuscatedTitle = z.l10n.text(z.string.notificationObfuscatedTitle);
    return z.util.StringUtil.truncate(obfuscatedTitle, NotificationRepository.CONFIG.TITLE_LENGTH, false);
  }

  /**
   * Creates the notification trigger.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Function} Function to be called when notification is clicked
   */
  _createTrigger(messageEntity, connectionEntity, conversationEntity) {
    const conversationId = this._getConversationId(connectionEntity, conversationEntity);

    const containsSelfMention = messageEntity.is_content() && messageEntity.isUserMentioned(this.selfUser().id);
    if (containsSelfMention) {
      const showOptions = {exposeMessage: messageEntity, openFirstSelfMention: true};
      return () => amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity, showOptions);
    }

    const isConnectionRequest = messageEntity.is_member() && messageEntity.isConnectionRequest();
    if (isConnectionRequest) {
      return () => {
        amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
      };
    }

    return () => amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity || conversationId);
  }

  /**
   * Retrieve conversation ID from either conversation or connection.
   *
   * @private
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {string} ID of conversation
   */
  _getConversationId(connectionEntity, conversationEntity) {
    return connectionEntity ? connectionEntity.conversationId : conversationEntity.id;
  }

  /**
   * Evaluates the current permission state.
   * @private
   * @returns {Promise} Resolves with true if notifications are permitted
   */
  _checkPermissionState() {
    switch (this.permissionState()) {
      case z.permission.PermissionStatusState.GRANTED: {
        return Promise.resolve(true);
      }

      case z.notification.PermissionState.IGNORED:
      case z.notification.PermissionState.UNSUPPORTED:
      case z.permission.PermissionStatusState.DENIED: {
        return Promise.resolve(false);
      }

      default: {
        return Promise.resolve(undefined);
      }
    }
  }

  /**
   * Creates the browser notification and sends it.
   *
   * @private
   * @see https://developer.mozilla.org/en/docs/Web/API/notification#Parameters
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.connection.ConnectionEntity} [connectionEntity] - Connection entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves when notification was handled
   */
  _notifyBanner(messageEntity, connectionEntity, conversationEntity) {
    return this._shouldShowNotification(messageEntity, conversationEntity)
      .then(() => this._createNotificationContent(messageEntity, connectionEntity, conversationEntity))
      .then(notificationContent => {
        return this.checkPermission().then(isPermitted => {
          return isPermitted ? this._showNotification(notificationContent) : undefined;
        });
      })
      .catch(error => {
        const hideNotification = error.type === z.error.NotificationError.TYPE.HIDE_NOTIFICATION;
        if (!hideNotification) {
          throw error;
        }
      });
  }

  /**
   * Plays the sound from the audio repository.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {undefined} No return value
   */
  _notifySound(messageEntity) {
    const muteSound = !document.hasFocus() && z.util.Environment.browser.firefox && z.util.Environment.os.mac;
    const isFromSelf = messageEntity.user().is_me;
    const shouldPlaySound = !muteSound && !isFromSelf;

    if (shouldPlaySound) {
      switch (messageEntity.super_type) {
        case z.message.SuperType.CONTENT: {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.NEW_MESSAGE);
          break;
        }

        case z.message.SuperType.PING: {
          amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.INCOMING_PING);
          break;
        }

        default:
          this.logger.log(this.logger.levels.OFF, `No notification sound for message '${messageEntity.id}.`);
      }
    }
  }

  // Request browser permission for notifications.
  _requestPermission() {
    return new Promise(resolve => {
      amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.REQUEST_NOTIFICATION);
      // Note: The callback will be only triggered in Chrome.
      // If you ignore a permission request on Firefox, then the callback will not be triggered.
      if (window.Notification.requestPermission) {
        window.Notification.requestPermission(permissionState => {
          amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.REQUEST_NOTIFICATION);
          this.updatePermissionState(permissionState).then(resolve);
        });
      }
    });
  }

  /**
   * Should message in a notification be obfuscated.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {boolean} Obfuscate message in notification
   */
  _shouldObfuscateNotificationMessage(messageEntity) {
    const preferencesToObfuscateMessage = [
      z.notification.NotificationPreference.OBFUSCATE,
      z.notification.NotificationPreference.OBFUSCATE_MESSAGE,
    ];

    return preferencesToObfuscateMessage.includes(this.notificationsPreference()) || messageEntity.is_ephemeral();
  }

  /**
   * Should sender in a notification be obfuscated.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @returns {boolean} Obfuscate sender in notification
   */
  _shouldObfuscateNotificationSender(messageEntity) {
    const isSetToObfuscate = this.notificationsPreference() === z.notification.NotificationPreference.OBFUSCATE;
    return isSetToObfuscate || messageEntity.is_ephemeral();
  }

  /**
   * Should hide notification.
   * @private
   * @param {z.entity.Message} messageEntity - Message entity
   * @param {z.entity.Conversation} [conversationEntity] - Conversation entity
   * @returns {Promise} Resolves if the notification should be shown
   */
  _shouldShowNotification(messageEntity, conversationEntity) {
    const inActiveConversation = conversationEntity
      ? this.conversationRepository.is_active_conversation(conversationEntity)
      : false;
    const inConversationView = wire.app.view.content.state() === z.viewModel.ContentViewModel.STATE.CONVERSATION;
    const inMaximizedCall = this.callingRepository.joinedCall() && !wire.app.view.content.multitasking.isMinimized();

    const activeConversation = document.hasFocus() && inConversationView && inActiveConversation && !inMaximizedCall;
    const messageFromSelf = messageEntity.user().is_me;
    const permissionDenied = this.permissionState() === z.permission.PermissionStatusState.DENIED;
    const preferenceIsNone = this.notificationsPreference() === z.notification.NotificationPreference.NONE;
    const supportsNotification = z.util.Environment.browser.supports.notifications;

    const hideNotification =
      activeConversation || messageFromSelf || permissionDenied || preferenceIsNone || !supportsNotification;

    return hideNotification
      ? Promise.reject(new z.error.NotificationError(z.error.NotificationError.TYPE.HIDE_NOTIFICATION))
      : Promise.resolve();
  }

  /**
   * Sending the notification.
   *
   * @param {Object} notificationContent - Content of notification
   * @param {string} notificationContent.title - Title of notification
   * @param {Object} notificationContent.options - Notification options
   * @param {Function} notificationContent.trigger - Function to be called on notificiation click
   * @param {Integer} notificationContent.timeout - Timeout after which notification is closed
   * @returns {undefined} No return value
   */
  _showNotification(notificationContent) {
    amplify.publish(z.event.WebApp.NOTIFICATION.SHOW, notificationContent);
    this._showNotificationInBrowser(notificationContent);
  }

  /**
   * Sending the browser notification.
   *
   * @private
   * @param {Object} notificationContent - Content of notification
   * @param {string} notificationContent.title - Notification title
   * @param {Object} notificationContent.options - Notification options
   * @param {Function} notificationContent.trigger - Function to be triggered on click [Function] trigger
   * @param {number} notificationContent.timeout - Timeout for notification
   * @returns {undefined} No return value
   */
  _showNotificationInBrowser(notificationContent) {
    /*
    @note Notification.data is only supported on Chrome
    @see https://developer.mozilla.org/en-US/docs/Web/API/Notification/data
    */
    this.removeReadNotifications();
    const notification = new window.Notification(notificationContent.title, notificationContent.options);
    const {conversationId, messageId, messageType} = notificationContent.options.data;
    let timeoutTriggerId = undefined;

    const messageInfo = messageId ? `message '${messageId}' of type '${messageType}'` : `'${messageType}' message`;
    notification.onclick = () => {
      amplify.publish(z.event.WebApp.NOTIFICATION.CLICK);
      window.focus();
      wire.app.view.content.multitasking.isMinimized(true);
      notificationContent.trigger();

      this.logger.info(`Notification for ${messageInfo} in '${conversationId}' closed by click.`);
      notification.close();
    };

    notification.onclose = () => {
      window.clearTimeout(timeoutTriggerId);
      this.notifications.splice(this.notifications.indexOf(notification), 1);
      this.logger.info(`Removed notification for ${messageInfo} in '${conversationId}' locally.`);
    };

    notification.onerror = error => {
      this.logger.error(`Notification for ${messageInfo} in '${conversationId}' closed by error.`, error);
      notification.close();
    };

    notification.onshow = () => {
      timeoutTriggerId = window.setTimeout(() => {
        this.logger.info(`Notification for ${messageInfo} in '${conversationId}' closed by timeout.`);
        notification.close();
      }, notificationContent.timeout);
    };

    this.notifications.push(notification);
    this.logger.info(`Added notification for ${messageInfo} in '${conversationId}' to queue.`);
  }

  /**
   * Check whether conversation is in state to trigger notitication.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation to notify in .
   * @param {z.entity.Message} messageEntity - The message to filter from.
   * @param {string} userId - The user id to check mentions for.
   * @returns {boolean} True if the conversation should show notification.
   */
  static shouldNotifyInConversation(conversationEntity, messageEntity, userId) {
    if (conversationEntity.showNotificationsNothing()) {
      return false;
    }

    const isEventTypeToNotify = NotificationRepository.EVENTS_TO_NOTIFY.includes(messageEntity.super_type);
    const isEventToNotify = isEventTypeToNotify && !messageEntity.isEdited() && !messageEntity.isLinkPreview();

    if (conversationEntity.showNotificationsEverything()) {
      return isEventToNotify;
    }

    const isSelfMentionOrReply = messageEntity.is_content() && messageEntity.isUserTargeted(userId);

    return isEventToNotify && isSelfMentionOrReply;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

/**
 * Permission repository to check browser permissions.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API
 */
z.permission.PermissionRepository = class PermissionRepository {
  static get CONFIG() {
    return {
      MEDIA_TYPES: [z.permission.PermissionType.CAMERA, z.permission.PermissionType.MICROPHONE],
    };
  }
  /**
   * Construct a new Permission Repository.
   * @param {z.calling.CallingRepository} callingRepository - Repository for all call interactions
   * @param {z.conversation.ConversationService} conversationRepository - Repository for all conversation interactions
   */
  constructor(callingRepository, conversationRepository) {
    this.logger = new z.util.Logger('z.permission.PermissionRepository', z.config.LOGGER.OPTIONS);

    this.permissionState = {
      [z.permission.PermissionType.CAMERA]: ko.observable(undefined),
      [z.permission.PermissionType.GEO_LOCATION]: ko.observable(undefined),
      [z.permission.PermissionType.MICROPHONE]: ko.observable(undefined),
      [z.permission.PermissionType.NOTIFICATIONS]: ko.observable(undefined),
    };
  }

  checkPermissionState(permissionType) {
    return Promise.resolve().then(() => {
      const setPermissionState = permissionState => this.permissionState[permissionType](permissionState);

      if (!z.util.Environment.browser.supports.permissions) {
        throw new z.error.PermissionError(z.error.PermissionError.TYPE.UNSUPPORTED);
      }

      const isMediaPermission = PermissionRepository.CONFIG.MEDIA_TYPES.includes(permissionType);
      if (isMediaPermission && !z.util.Environment.browser.supports.mediaPermissions) {
        throw new z.error.PermissionError(z.error.PermissionError.TYPE.UNSUPPORTED_TYPE);
      }

      return navigator.permissions.query({name: permissionType}).then(permissionStatus => {
        this.logger.log(`Permission state for '${permissionType}' is '${permissionStatus.state}'`, permissionStatus);
        setPermissionState(permissionStatus.state);

        permissionStatus.onchange = () => {
          const logMessage = `Permission  state for '${permissionType}' changed to '${permissionStatus.state}'`;
          this.logger.log(logMessage, permissionStatus);
          setPermissionState(permissionStatus.state);
        };

        return permissionStatus.state;
      });
    });
  }

  getPermissionState(permissionType) {
    const currentPermissionState = this.permissionState[permissionType]();
    return currentPermissionState ? Promise.resolve(currentPermissionState) : this.checkPermissionState(permissionType);
  }

  getPermissionStates(permissionTypes) {
    const permissionPromises = permissionTypes.map(permissionType => {
      return this.getPermissionState(permissionType)
        .then(permissionState => ({permissionState, permissionType}))
        .catch(() => ({permissionState: z.permission.PermissionStatusState.PROMPT, permissionType}));
    });

    return Promise.all(permissionPromises);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

// https://developer.mozilla.org/en-US/docs/Web/API/PermissionStatus/state
z.permission.PermissionStatusState = {
  DENIED: 'denied',
  GRANTED: 'granted',
  PROMPT: 'prompt',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.permission = z.permission || {};

// https://developer.mozilla.org/en-US/docs/Web/API/Permissions/query
z.permission.PermissionType = {
  CAMERA: 'camera',
  GEO_LOCATION: 'geolocation',
  MICROPHONE: 'microphone',
  NOTIFICATIONS: 'notifications',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesEntity = class PropertiesEntity {
  constructor() {
    this[z.properties.PROPERTIES_TYPE.VERSION] = 1;
    this.settings = {
      emoji: {
        replace_inline: true,
      },
      notifications: z.notification.NotificationPreference.ON,
      previews: {
        send: true,
      },
      privacy: {
        improve_wire: undefined,
      },
      sound: {
        alerts: z.audio.AudioPreference.ALL,
      },
    };
    this.contact_import = {
      macos: undefined,
    };
    this[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING] = false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesRepository = class PropertiesRepository {
  static get CONFIG() {
    return {
      PROPERTIES_KEY: 'webapp',
    };
  }

  /**
   * Construct a new User properties repository.
   * @param {z.properties.PropertiesService} propertiesService - Backend REST API properties service implementation
   */
  constructor(propertiesService) {
    this.propertiesService = propertiesService;
    this.logger = new z.util.Logger('z.properties.PropertiesRepository', z.config.LOGGER.OPTIONS);

    this.properties = new z.properties.PropertiesEntity();
    this.selfUser = ko.observable();

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.propertiesUpdated.bind(this));
  }

  checkPrivacyPermission() {
    const isPrivacyPreferenceSet = this.getPreference(z.properties.PROPERTIES_TYPE.PRIVACY) !== undefined;

    return isPrivacyPreferenceSet
      ? Promise.resolve()
      : new Promise(resolve => {
          amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
            action: () => {
              this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, true);
              this._publishProperties();
              resolve();
            },
            preventClose: true,
            secondary: () => {
              this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, false);
              resolve();
            },
            text: {
              action: z.l10n.text(z.string.modalImproveWireAction),
              message: z.l10n.text(z.string.modalImproveWireMessage),
              secondary: z.l10n.text(z.string.modalImproveWireSecondary),
              title: z.l10n.text(z.string.modalImproveWireHeadline),
            },
            warning: false,
          });
        });
  }

  /**
   * Get the current preference for a property type.
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to get
   * @returns {*} Preference value
   */
  getPreference(propertiesType) {
    const typeParts = propertiesType.split('.');
    const [partOne, partTwo, partThree] = typeParts;

    switch (typeParts.length) {
      case 1:
        return this.properties[partOne];
      case 2:
        return this.properties[partOne][partTwo];
      case 3:
        return this.properties[partOne][partTwo][partThree];
      default:
        throw new Error(`Failed to get preference of type ${propertiesType}`);
    }
  }

  /**
   * Initialize properties on app startup.
   * @param {z.entity.User} selfUserEntity - Self user
   * @returns {Promise} Resolves when repository has been initialized
   */
  init(selfUserEntity) {
    this.selfUser(selfUserEntity);

    return this.selfUser().isTemporaryGuest() ? this._initTemporaryGuestAccount() : this._initActivatedAccount();
  }

  _initActivatedAccount() {
    return this.propertiesService
      .getProperties()
      .then(keys => {
        if (keys.includes(PropertiesRepository.CONFIG.PROPERTIES_KEY)) {
          return this.propertiesService
            .getPropertiesByKey(PropertiesRepository.CONFIG.PROPERTIES_KEY)
            .then(properties => {
              $.extend(true, this.properties, properties);
              this.logger.info('Loaded user properties', this.properties);
            });
        }

        this.logger.info('No properties found: Using default properties');
      })
      .then(() => this._publishProperties());
  }

  _initTemporaryGuestAccount() {
    this.logger.info('Temporary guest user: Using default properties');
    this.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, false);
    return Promise.resolve(this._publishProperties());
  }

  _publishProperties() {
    amplify.publish(z.event.WebApp.PROPERTIES.UPDATED, this.properties);
    return this.properties;
  }

  /**
   * Updated properties handler.
   * @param {z.properties.Properties} properties - New properties
   * @returns {boolean} Always returns true to ensure other subscribers handling the event
   */
  propertiesUpdated(properties) {
    if (properties[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING]) {
      amplify.publish(z.util.Logger.prototype.LOG_ON_DEBUG, properties[z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING]);
    }
    return true;
  }

  /**
   * Save property setting.
   *
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to update
   * @param {*} updatedPreference - New property setting
   * @returns {undefined} No return value
   */
  savePreference(propertiesType, updatedPreference) {
    if (updatedPreference === undefined) {
      switch (propertiesType) {
        case z.properties.PROPERTIES_TYPE.CONTACT_IMPORT.MACOS:
          updatedPreference = Date.now();
          break;
        default:
          updatedPreference = true;
      }
    }

    if (updatedPreference !== this.getPreference(propertiesType)) {
      this._setPreference(propertiesType, updatedPreference);

      const savePromise = this.selfUser().isTemporaryGuest()
        ? this._savePreferenceTemporaryGuestAccount(propertiesType, updatedPreference)
        : this._savePreferenceActivatedAccount(propertiesType, updatedPreference);

      savePromise.then(() => this._publishPropertyUpdate(propertiesType, updatedPreference));
    }
  }

  _savePreferenceActivatedAccount(propertiesType, updatedPreference) {
    return this.propertiesService
      .putPropertiesByKey(PropertiesRepository.CONFIG.PROPERTIES_KEY, this.properties)
      .then(() => this.logger.info(`Saved updated preference: '${propertiesType}' - '${updatedPreference}'`));
  }

  _savePreferenceTemporaryGuestAccount(propertiesType, updatedPreference) {
    this.logger.info(`Updated preference: '${propertiesType}' - '${updatedPreference}'`);
    return Promise.resolve();
  }

  _publishPropertyUpdate(propertiesType, updatedPreference) {
    switch (propertiesType) {
      case z.properties.PROPERTIES_TYPE.CONTACT_IMPORT.MACOS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.CONTACTS, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.EMOJI.REPLACE_INLINE, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING:
        amplify.publish(z.util.Logger.prototype.LOG_ON_DEBUG, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.NOTIFICATIONS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.NOTIFICATIONS, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.PREVIEWS.SEND:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.PREVIEWS.SEND, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.PRIVACY:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.PRIVACY, updatedPreference);
        break;
      case z.properties.PROPERTIES_TYPE.SOUND_ALERTS:
        amplify.publish(z.event.WebApp.PROPERTIES.UPDATE.SOUND_ALERTS, updatedPreference);
        break;
      default:
        throw new Error(`Failed to update preference of unhandled type '${propertiesType}'`);
    }
  }

  /**
   * Set the preference of specified type
   *
   * @private
   * @param {z.properties.PROPERTIES_TYPE} propertiesType - Type of preference to set
   * @param {*} changedPreference - New preference to set
   * @returns {undefined} No return value
   */
  _setPreference(propertiesType, changedPreference) {
    const typeParts = propertiesType.split('.');
    const [partOne, partTwo, partThree] = typeParts;

    switch (typeParts.length) {
      case 1:
        this.properties[partOne] = changedPreference;
        break;
      case 2:
        this.properties[partOne][partTwo] = changedPreference;
        break;
      case 3:
        this.properties[partOne][partTwo][partThree] = changedPreference;
        break;
      default:
        throw new Error(`Failed to set preference of type ${propertiesType}`);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PropertiesService = class PropertiesService {
  static get CONFIG() {
    return {
      URL_PROPERTIES: '/properties',
    };
  }

  /**
   * Construct a new Properties Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.properties.PropertiesService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Clear all properties store for the user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/clearProperties
   * @returns {Promise} Resolves when all properties for user have been cleared
   */
  deleteProperties() {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: PropertiesService.CONFIG.URL_PROPERTIES,
    });
  }

  /**
   * Delete a property.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/deleteProperty
   * @param {string} key - Key used to store user properties
   * @returns {Promise} Resolves when the requested property for user has been cleared
   */
  deletePropertiesByKey(key) {
    return this.backendClient.sendRequest({
      type: 'DELETE',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }

  /**
   * List all property keys stored for the user.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/listPropertyKeys
   * @returns {Promise} Resolves with an array of the property keys stored for the user
   */
  getProperties() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: PropertiesService.CONFIG.URL_PROPERTIES,
    });
  }

  /**
   * Get a property value stored for a key.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/getProperty
   *
   * @param {string} key - Key used to store user properties
   * @returns {Promise} Resolves with the property set for the given key
   */
  getPropertiesByKey(key) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }

  /**
   * Set a property value for a key.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/setProperty
   *
   * @param {string} key - Key used to store user properties
   * @param {Object} properties - Payload to be stored
   * @returns {Promise} Resolves when the property has been stored
   */
  putPropertiesByKey(key, properties) {
    return this.backendClient.sendJson({
      data: properties,
      type: 'PUT',
      url: `${PropertiesService.CONFIG.URL_PROPERTIES}/${key}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.properties = z.properties || {};

z.properties.PROPERTIES_TYPE = {
  CONTACT_IMPORT: {
    MACOS: 'contact_import.macos',
  },
  EMOJI: {
    REPLACE_INLINE: 'settings.emoji.replace_inline',
  },
  ENABLE_DEBUGGING: 'enable_debugging',
  NOTIFICATIONS: 'settings.notifications',
  PREVIEWS: {
    SEND: 'settings.previews.send',
  },
  PRIVACY: 'settings.privacy.improve_wire',
  SOUND_ALERTS: 'settings.sound.alerts',
  VERSION: 'version',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.FullTextSearch = (() => {
  const _getSearchRegex = query => {
    const delimiter = ' ';
    const flags = 'gumi';
    const regex = query
      .trim()
      .split(delimiter)
      .map(word => `(${z.util.SanitizationUtil.escapeRegex(word)})`)
      .join('(?:.*)');

    return new RegExp(regex, flags);
  };

  const _search = (text, query = '') => {
    query = query.trim();

    if (query.length > 0) {
      return _getSearchRegex(query).test(text);
    }
    return false;
  };

  return {
    getSearchRegex: _getSearchRegex,
    search: _search,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.SearchService = class SearchService {
  /**
   * Construct a new Search Service.
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.search.SearchService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Search for a user.
   *
   * @param {string} query - Query string (case insensitive)
   * @param {number} size - Number of requested user
   * @returns {Promise} Resolves with the search results
   */
  getContacts(query, size) {
    return this.backendClient.sendRequest({
      data: {
        // eslint-disable-next-line id-length
        q: query,
        size,
      },
      type: 'GET',
      url: '/search/contacts',
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.search = z.search || {};

z.search.SearchRepository = class SearchRepository {
  static get CONFIG() {
    return {
      MAX_DIRECTORY_RESULTS: 30,
      MAX_SEARCH_RESULTS: 10,
      SEARCHABLE_FIELDS: {
        NAME: 'name',
        USERNAME: 'username',
      },
    };
  }

  /**
   * Trim and remove @.
   * @param {string} query - Search string
   * @returns {string} Normalized search query
   */
  static normalizeQuery(query) {
    if (!_.isString(query)) {
      return '';
    }
    return query
      .trim()
      .replace(/^[@]/, '')
      .toLowerCase();
  }

  /**
   * Construct a new Conversation Repository.
   * @param {z.search.SearchService} searchService - Backend REST API search service implementation
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(searchService, userRepository) {
    this.searchService = searchService;
    this.userRepository = userRepository;
    this.logger = new z.util.Logger('z.search.SearchRepository', z.config.LOGGER.OPTIONS);
  }

  /**
   * Search for a user in the given user list and given a search term.
   * Doesn't sort the results and keep the initial order of the given user list.
   *
   * @param {string} term - the search term
   * @param {Array<z.entity.User>} userEntities - entities to match the search term against
   * @param {Array<z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS>} properties=[z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS.NAME, z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS.USERNAME] - list of properties that will be matched against the search term
   *    the order of the properties in the array indicates the priorities by which results will be sorted
   * @returns {Array<z.entity.User>} the filtered list of users
   */
  searchUserInSet(term, userEntities, properties) {
    if (term === '') {
      return userEntities;
    }
    properties = properties || [
      SearchRepository.CONFIG.SEARCHABLE_FIELDS.NAME,
      SearchRepository.CONFIG.SEARCHABLE_FIELDS.USERNAME,
    ];

    const weightedResults = userEntities.reduce((results, userEntity) => {
      const matchWeight = properties
        .slice()
        .reverse()
        .reduce((weight, property, index) => {
          const propertyWeight = 10 * index + 1;
          const propertyMatchWeight = this._matches(term, property, userEntity);
          return weight + propertyMatchWeight * propertyWeight;
        }, 0);

      return matchWeight === 0 ? results : results.concat({user: userEntity, weight: matchWeight});
    }, []);

    return weightedResults
      .slice()
      .sort((result1, result2) => {
        if (result2.weight === result1.weight) {
          return result2.user.name() > result1.user.name() ? -1 : 1;
        }
        return result2.weight - result1.weight;
      })
      .map(result => result.user);
  }

  _matches(term, property, userEntity) {
    const excludedEmojis = Array.from(term).reduce((emojis, char) => {
      const isEmoji = z.util.EmojiUtil.UNICODE_RANGES.includes(char);
      return isEmoji ? Object.assign({}, emojis, {[char]: char}) : emojis;
    }, {});
    const value = ko.unwrap(userEntity[property]) || '';

    const isStrictMatch = value.toLowerCase().startsWith(term.toLowerCase());
    if (isStrictMatch) {
      // if the pattern matches the raw text, give the maximum value to the match
      return 100;
    }
    const isStrictTransliteratedMatch = z.util.StringUtil.compareTransliteration(value, term, excludedEmojis, true);
    if (isStrictTransliteratedMatch) {
      // give a little less points if the pattern strictly matches the transliterated string
      return 50;
    }
    const isLoosyMatch = z.util.StringUtil.compareTransliteration(value, term, excludedEmojis, false);
    if (!isLoosyMatch) {
      // if the pattern doesn't match loosely, then it's not a match at all
      return 0;
    }

    const tokens = z.util.StringUtil.computeTransliteration(value).split(/-/g);
    // computing the match value by testing all components of the property
    return tokens.reverse().reduce((weight, token, index) => {
      const indexWeight = index + 1;
      let tokenWeight = 0;

      if (z.util.StringUtil.compareTransliteration(token, term, excludedEmojis, true)) {
        tokenWeight = indexWeight * 10;
      } else if (z.util.StringUtil.compareTransliteration(token, term, excludedEmojis, false)) {
        tokenWeight = indexWeight;
      }

      return weight + tokenWeight;
    }, 0);
  }

  /**
   * Search for users on the backend by name.
   * @note We skip a few results as connection changes need a while to reflect on the backend.
   *
   * @param {string} name - Search query
   * @param {boolean} isHandle - Is query a user handle
   * @param {number} [maxResults=SearchRepository.CONFIG.MAX_SEARCH_RESULTS] - Maximum number of results
   * @returns {Promise} Resolves with the search results
   */
  search_by_name(name, isHandle, maxResults = SearchRepository.CONFIG.MAX_SEARCH_RESULTS) {
    const directorySearch = this.searchService
      .getContacts(name, SearchRepository.CONFIG.MAX_DIRECTORY_RESULTS)
      .then(({documents}) => documents.map(match => match.id));

    const searchPromises = [directorySearch];

    if (z.user.UserHandleGenerator.validate_handle(name)) {
      searchPromises.push(this.userRepository.get_user_id_by_handle(name));
    }

    return Promise.all(searchPromises)
      .then(([directoryResults, usernameResult]) => {
        if (usernameResult && !directoryResults.includes(usernameResult)) {
          directoryResults.push(usernameResult);
        }

        return directoryResults;
      })
      .then(userIds => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => {
        return userEntities.filter(userEntity => {
          return !userEntity.is_me && !userEntity.isConnected() && !userEntity.isTeamMember();
        });
      })
      .then(userEntities => {
        if (isHandle) {
          userEntities = userEntities.filter(userEntity => z.util.StringUtil.startsWith(userEntity.username(), name));
        }

        return userEntities
          .sort((userA, userB) => {
            return isHandle
              ? z.util.StringUtil.sortByPriority(userA.username(), userB.username(), name)
              : z.util.StringUtil.sortByPriority(userA.name(), userB.name(), name);
          })
          .slice(0, maxResults);
      });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.self = z.self || {};

z.self.SelfService = class SelfService {
  static get URL() {
    return {
      SELF: '/self',
    };
  }

  /**
   * Construct a new Self Service.
   * @class z.self.SelfService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.self.SelfService', z.config.LOGGER.OPTIONS);
  }

  /**
   * Delete self user.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//deleteUser
   *
   * @param {string} [password] - Self user password to authorize immediate account deletion
   * @returns {Promise} Promise that resolves when account deletion has been initiated
   */
  deleteSelf(password) {
    return this.backendClient.sendJson({
      data: {
        password: password,
      },
      type: 'DELETE',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Get your own user profile.
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//self
   * @returns {Promise} Promise that will resolve with the self user
   */
  getSelf() {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Get your consents.
   * @returns {Promise} Promise that will resolve with the consents user has given
   */
  getSelfConsent() {
    return this.backendClient
      .sendRequest({
        type: 'GET',
        url: `${SelfService.URL.SELF}/consent`,
      })
      .then(data => data.results);
  }

  /**
   * Update your own user profile.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//updateSelf
   *
   * @param {Object} selfData - Updated user profile information
   * @returns {Promise} Resolves with backend response.
   */
  putSelf(selfData) {
    return this.backendClient.sendJson({
      data: selfData,
      type: 'PUT',
      url: SelfService.URL.SELF,
    });
  }

  /**
   * Set a consent value .
   *
   * @param {number} consentType - Type of consent given
   * @param {number} value - Value of consent
   * @param {string} source - Identifier of app from consent
   * @returns {Promise} Promise that will resolve with the self user
   */
  putSelfConsent(consentType, value, source) {
    return this.backendClient.sendJson({
      data: {
        source: source,
        type: consentType,
        value: value,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/consent`,
    });
  }

  /**
   * Change your own user email.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeEmail
   *
   * @param {string} email - New email address for the user
   * @returns {Promise} Promise that resolves when email changing process has been started on backend
   */
  putSelfEmail(email) {
    return this.backendClient.sendJson({
      data: {
        email: email,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/email`,
    });
  }

  /**
   * Change username.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeHandle
   *
   * @param {string} username - New username for the user
   * @returns {Promise} Promise that resolves when username changing process has been started on backend
   */
  putSelfHandle(username) {
    return this.backendClient.sendJson({
      data: {
        handle: username,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/handle`,
    });
  }

  /**
   * Change your locale.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changeLocale
   *
   * @param {string} newLocale - Locale to be set
   * @returns {Promise} Promise that resolves when locale has been changed on backend
   */
  putSelfLocale(newLocale) {
    return this.backendClient.sendJson({
      data: {
        locale: newLocale,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/locale`,
    });
  }

  /**
   * Change own user password.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changePassword
   *
   * @param {string} newPassword - New user password
   * @param {string} [oldPassword] - Old password of the user
   * @returns {Promise} Promise that resolves when password has been changed on backend
   */
  putSelfPassword(newPassword, oldPassword) {
    return this.backendClient.sendJson({
      data: {
        new_password: newPassword,
        old_password: oldPassword,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/password`,
    });
  }

  /**
   * Change your phone number.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/tab.html#!//changePhone
   *
   * @param {string} phoneNumber - Phone number in E.164 format
   * @returns {Promise} Promise that resolves when phone number change process has been started on backend
   */
  putSelfPhone(phoneNumber) {
    return this.backendClient.sendJson({
      data: {
        phone: phoneNumber,
      },
      type: 'PUT',
      url: `${SelfService.URL.SELF}/phone`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.time = z.time || {};

z.time.ServerTimeRepository = class ServerTimeRepository {
  constructor() {
    this.logger = new z.util.Logger('z.time.ServerTimeRepository', z.config.LOGGER.OPTIONS);
    this._timeOffset = undefined;
  }

  computeTimeOffset(serverTimeString) {
    this._timeOffset = new Date() - new Date(serverTimeString);
    this.logger.info(`Current backend time is '${serverTimeString}'. Time offset updated to '${this._timeOffset}' ms`);
  }

  getTimeOffset() {
    if (this._timeOffset === undefined) {
      this.logger.warn('Trying to get server/client time offset, but no server time has been set.');
      return 0;
    }
    return this._timeOffset;
  }

  /**
   * Converts a local timestamp to a server timestamp.
   * @param {number} [localTimestamp = Date.now()] - the local timestamp to convert
   * @returns {number} serverTimestamp - the timestamp adjusted with the client/server time shift
   */
  toServerTimestamp(localTimestamp = Date.now()) {
    return localTimestamp - this.getTimeOffset();
  }

  /**
   * Converts a server timestamp to a local timestamp.
   * @param {number} [serverTimestamp = Date.now()] - the server timestamp to convert
   * @returns {number} localTimestamp - the timestamp adjusted with the client/server time shift
   */
  toLocalTimestamp(serverTimestamp = Date.now()) {
    return serverTimestamp + this.getTimeOffset();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamEntity = class TeamEntity {
  constructor(id) {
    this.creator = undefined;
    this.icon = '';
    this.iconKey = undefined;
    this.members = ko.observableArray([]);
    this.id = id;
    this.name = ko.observable('');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamMapper = class TeamMapper {
  constructor() {
    this.logger = new z.util.Logger('z.team.TeamMapper', z.config.LOGGER.OPTIONS);
  }

  mapTeamFromObject(data) {
    return this.updateTeamFromObject(data);
  }

  updateTeamFromObject(teamData, teamEntity = new z.team.TeamEntity()) {
    if (teamData) {
      const {creator, icon, icon_key: iconKey, id, name} = teamData;

      if (creator) {
        teamEntity.creator = creator;
      }

      if (icon) {
        teamEntity.icon = icon;
      }

      if (iconKey) {
        teamEntity.iconKey = iconKey;
      }

      if (id) {
        teamEntity.id = id;
      }

      if (name) {
        teamEntity.name(name);
      }

      return teamEntity;
    }
  }

  mapMemberFromArray(membersData) {
    return membersData.map(data => this.updateMemberFromObject(data));
  }

  mapMemberFromObject(data) {
    return this.updateMemberFromObject(data);
  }

  mapRole(userEntity, permissions) {
    if (permissions) {
      const teamRole = z.team.TeamRole.checkRole(permissions);
      this.logger.info(`Identified user '${userEntity.id}' as '${teamRole}'`, permissions);
      userEntity.teamRole(teamRole);
    }
  }

  updateMemberFromObject(memberData, memberEntity = new z.team.TeamMemberEntity()) {
    if (memberData) {
      const {permissions, user} = memberData;
      if (permissions) {
        memberEntity.permissions = permissions;
      }

      if (user) {
        memberEntity.userId = user;
      }

      return memberEntity;
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamMemberEntity = class TeamMemberEntity {
  constructor() {
    this.permissions = undefined;
    this.userId = undefined;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamPermission = (() => {
  const _permissionsForRole = teamRole => {
    switch (teamRole) {
      case z.team.TeamRole.ROLE.OWNER: {
        return _combinePermissions([
          _permissionsForRole(z.team.TeamRole.ROLE.ADMIN),
          PERMISSION.DELETE_TEAM,
          PERMISSION.GET_BILLING,
          PERMISSION.SET_BILLING,
        ]);
      }
      case z.team.TeamRole.ROLE.ADMIN: {
        return _combinePermissions([
          _permissionsForRole(z.team.TeamRole.ROLE.MEMBER),
          PERMISSION.ADD_TEAM_MEMBER,
          PERMISSION.REMOVE_TEAM_MEMBER,
          PERMISSION.SET_MEMBER_PERMISSIONS,
          PERMISSION.SET_TEAM_DATA,
        ]);
      }
      case z.team.TeamRole.ROLE.MEMBER: {
        return _combinePermissions([
          PERMISSION.ADD_CONVERSATION_MEMBER,
          PERMISSION.CREATE_CONVERSATION,
          PERMISSION.DELETE_CONVERSATION,
          PERMISSION.GET_MEMBER_PERMISSIONS,
          PERMISSION.GET_TEAM_CONVERSATIONS,
          PERMISSION.REMOVE_CONVERSATION_MEMBER,
        ]);
      }
      default: {
        return 0;
      }
    }
  };

  const _combinePermissions = permissions => {
    let result = 0;
    for (const permission of permissions) {
      result = result | permission;
    }
    return result;
  };

  const _hasPermissionForRole = (memberPermissions, role) => {
    const rolePermissions = _permissionsForRole(role);
    return _hasPermission(memberPermissions, rolePermissions);
  };

  const _hasPermission = (memberPermissions, expectedPermissions) => {
    if (Number.isSafeInteger(memberPermissions) && memberPermissions > 0) {
      return (memberPermissions & expectedPermissions) === expectedPermissions;
    }
    return false;
  };

  /**
   * Enum for different team permissions.
   * @returns {z.team.TeamPermission.PERMISSION} Enum of team permissions
   */
  const PERMISSION = {
    ADD_CONVERSATION_MEMBER: 1 << 4,
    ADD_TEAM_MEMBER: 1 << 2,
    CREATE_CONVERSATION: 1 << 0,
    DELETE_CONVERSATION: 1 << 1,
    DELETE_TEAM: 1 << 11,
    GET_BILLING: 1 << 6,
    GET_MEMBER_PERMISSIONS: 1 << 9,
    GET_TEAM_CONVERSATIONS: 1 << 10,
    NONE: 0,
    REMOVE_CONVERSATION_MEMBER: 1 << 5,
    REMOVE_TEAM_MEMBER: 1 << 3,
    SET_BILLING: 1 << 7,
    SET_MEMBER_PERMISSIONS: 1 << 12,
    SET_TEAM_DATA: 1 << 8,
  };

  return {
    PERMISSION: PERMISSION,
    hasPermission: _hasPermission,
    hasPermissionForRole: _hasPermissionForRole,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamRepository = class TeamRepository {
  /**
   * Construct a new Team Repository.
   * @class z.team.TeamRepository
   *
   * @param {z.team.TeamService} teamService - Backend REST API team service implementation
   * @param {z.user.UserRepository} userRepository - Repository for all user interactions
   */
  constructor(teamService, userRepository) {
    this.logger = new z.util.Logger('z.team.TeamRepository', z.config.LOGGER.OPTIONS);

    this.teamMapper = new z.team.TeamMapper();
    this.teamService = teamService;
    this.userRepository = userRepository;

    this.selfUser = this.userRepository.self;

    this.team = ko.observable();

    this.isTeam = ko.pureComputed(() => (this.team() ? !!this.team().id : false));

    this.teamMembers = ko.pureComputed(() => (this.isTeam() ? this.team().members() : []));
    this.teamName = ko.pureComputed(() => (this.isTeam() ? this.team().name() : this.selfUser().name()));
    this.teamSize = ko.pureComputed(() => (this.isTeam() ? this.teamMembers().length + 1 : 0));
    this.teamUsers = ko.pureComputed(() => {
      return this.teamMembers()
        .concat(this.userRepository.connected_users())
        .filter((item, index, array) => array.indexOf(item) === index)
        .sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
    });

    this.teamMembers.subscribe(() => this.userRepository.mapGuestStatus());
    this.teamSize.subscribe(teamSize => {
      amplify.publish(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, z.tracking.SuperProperty.TEAM.SIZE, teamSize);
    });

    this.userRepository.isTeam = this.isTeam;
    this.userRepository.teamMembers = this.teamMembers;
    this.userRepository.teamUsers = this.teamUsers;

    amplify.subscribe(z.event.WebApp.TEAM.EVENT_FROM_BACKEND, this.onTeamEvent.bind(this));
    amplify.subscribe(z.event.WebApp.TEAM.UPDATE_INFO, this.sendAccountInfo.bind(this));
  }

  getTeam() {
    const teamPromise = this.selfUser().teamId ? this._getTeamById() : this._getBindingTeam();
    return teamPromise
      .then(teamData => {
        if (teamData) {
          const teamEntity = this.teamMapper.mapTeamFromObject(teamData);
          this.team(teamEntity);
          return this.updateTeamMembers(teamEntity);
        }

        this.team(new z.team.TeamEntity());
      })
      .then(() => this.sendAccountInfo())
      .then(() => this.team());
  }

  getTeamMember(teamId, userId) {
    return this.teamService
      .getTeamMember(teamId, userId)
      .then(memberResponse => this.teamMapper.mapMemberFromObject(memberResponse));
  }

  getTeamMembers(teamId) {
    return this.teamService.getTeamMembers(teamId).then(({members}) => {
      if (members.length) {
        return this.teamMapper.mapMemberFromArray(members);
      }
    });
  }

  getWhitelistedServices(teamId, size, prefix) {
    return this.teamService.getWhitelistedServices(teamId, size, prefix).then(({services: servicesData}) => {
      return z.integration.IntegrationMapper.mapServicesFromArray(servicesData);
    });
  }

  /**
   * Listener for incoming team events.
   *
   * @param {Object} eventJson - JSON data for team event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {Promise} Resolves when event was handled
   */
  onTeamEvent(eventJson, source) {
    const type = eventJson.type;

    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};
    this.logger.info(`»» Team Event: '${type}' (Source: ${source})`, logObject);

    switch (type) {
      case z.event.Backend.TEAM.CONVERSATION_CREATE:
      case z.event.Backend.TEAM.CONVERSATION_DELETE: {
        this._onUnhandled(eventJson);
        break;
      }
      case z.event.Backend.TEAM.DELETE: {
        this._onDelete(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_JOIN: {
        this._onMemberJoin(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_LEAVE: {
        this._onMemberLeave(eventJson);
        break;
      }
      case z.event.Backend.TEAM.MEMBER_UPDATE: {
        this._onMemberUpdate(eventJson);
        break;
      }
      case z.event.Backend.TEAM.UPDATE: {
        this._onUpdate(eventJson);
        break;
      }
      default: {
        this._onUnhandled(eventJson);
      }
    }
  }

  sendAccountInfo() {
    if (z.util.Environment.desktop) {
      const imageResource = this.isTeam() ? undefined : this.selfUser().previewPictureResource();
      const imagePromise = imageResource ? imageResource.load() : Promise.resolve();

      imagePromise
        .then(imageBlob => {
          if (imageBlob) {
            return z.util.loadDataUrl(imageBlob);
          }
        })
        .then(imageDataUrl => {
          const accountInfo = {
            accentID: this.selfUser().accent_id(),
            name: this.teamName(),
            picture: imageDataUrl,
            teamID: this.team().id,
            teamRole: this.selfUser().teamRole(),
            userID: this.selfUser().id,
          };

          this.logger.info('Publishing account info', accountInfo);
          amplify.publish(z.event.WebApp.TEAM.INFO, accountInfo);
        });
    }
  }

  updateTeamMembers(teamEntity) {
    return this.getTeamMembers(teamEntity.id)
      .then(teamMembers => {
        const memberIds = teamMembers
          .filter(memberEntity => {
            const isSelfUser = memberEntity.userId === this.selfUser().id;

            if (isSelfUser) {
              this.teamMapper.mapRole(this.selfUser(), memberEntity.permissions);
            }

            return !isSelfUser;
          })
          .map(memberEntity => memberEntity.userId);

        return this.userRepository.get_users_by_id(memberIds);
      })
      .then(userEntities => teamEntity.members(userEntities));
  }

  _addUserToTeam(userEntity) {
    const members = this.team().members;

    if (!members().find(member => member.id === userEntity.id)) {
      members.push(userEntity);
    }
  }

  _getTeamById() {
    return this.teamService.getTeamById(this.selfUser().teamId);
  }

  _getBindingTeam() {
    return this.teamService.getTeams().then(({teams}) => {
      const [team] = teams;
      if (team && team.binding) {
        return team;
      }
    });
  }

  _onDelete({team: teamId}) {
    if (this.isTeam() && this.team().id === teamId) {
      window.setTimeout(() => {
        amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED, true);
      }, 50);
    }
  }

  _onMemberJoin(eventJson) {
    const {
      data: {user: userId},
      team: teamId,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;
    const isOtherUser = this.selfUser().id !== userId;

    if (isLocalTeam && isOtherUser) {
      this.userRepository.get_user_by_id(userId).then(userEntity => this._addUserToTeam(userEntity));
    }
  }

  _onMemberLeave(eventJson) {
    const {
      data: {user: userId},
      team: teamId,
      time,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;

    if (isLocalTeam) {
      const isSelfUser = this.selfUser().id === userId;
      if (isSelfUser) {
        return this._onDelete(eventJson);
      }

      this.team().members.remove(member => member.id === userId);
      amplify.publish(z.event.WebApp.TEAM.MEMBER_LEAVE, teamId, userId, new Date(time).toISOString());
    }
  }

  _onMemberUpdate(eventJson) {
    const {
      data: {user: userId},
      permissions,
      team: teamId,
    } = eventJson;
    const isLocalTeam = this.team().id === teamId;
    const isSelfUser = this.selfUser().id === userId;

    if (isLocalTeam && isSelfUser) {
      const memberPromise = permissions ? Promise.resolve({permissions}) : this.getTeamMember(teamId, userId);

      memberPromise
        .then(memberEntity => this.teamMapper.mapRole(this.selfUser(), memberEntity.permissions))
        .then(() => this.sendAccountInfo());
    }
  }

  _onUnhandled(eventJson) {
    this.logger.log(`Received '${eventJson.type}' event from backend which is not yet handled`, eventJson);
  }

  _onUpdate(eventJson) {
    const {data: teamData, team: teamId} = eventJson;

    if (this.team().id === teamId) {
      this.teamMapper.updateTeamFromObject(teamData, this.team());
      this.sendAccountInfo();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamRole = (() => {
  const ROLE = {
    ADMIN: 'z.team.TeamRole.ROLE.ADMIN',
    INVALID: 'z.team.TeamRole.ROLE.INVALID',
    MEMBER: 'z.team.TeamRole.ROLE.MEMBER',
    NONE: 'z.team.TeamRole.ROLE.NONE',
    OWNER: 'z.team.TeamRole.ROLE.OWNER',
  };

  const _checkRole = permissions => {
    if (!permissions) {
      throw new z.error.TeamError(z.error.TeamError.TYPE.NO_PERMISSIONS);
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.OWNER)) {
      return ROLE.OWNER;
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.ADMIN)) {
      return ROLE.ADMIN;
    }

    if (z.team.TeamPermission.hasPermissionForRole(permissions.self, ROLE.MEMBER)) {
      return ROLE.MEMBER;
    }

    return ROLE.INVALID;
  };

  return {
    ROLE: ROLE,
    checkRole: _checkRole,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.team = z.team || {};

z.team.TeamService = class TeamService {
  static get URL() {
    return {
      TEAMS: '/teams',
    };
  }

  /**
   * Construct a new Team Service.
   * @class z.user.TeamService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   */
  constructor(backendClient) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.team.TeamService', z.config.LOGGER.OPTIONS);
  }

  getTeamById(teamId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}`,
    });
  }

  getTeamMember(teamId, userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/members/${userId}`,
    });
  }

  getTeamMembers(teamId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/members`,
    });
  }

  getTeams(limit = 100, teamIds) {
    return this.backendClient.sendRequest({
      data: {
        size: limit,
        start: teamIds,
      },
      type: 'GET',
      url: TeamService.URL.TEAMS,
    });
  }

  getWhitelistedServices(teamId, size = 100, prefix) {
    return this.backendClient.sendRequest({
      data: {
        prefix,
        size,
      },
      type: 'GET',
      url: `${TeamService.URL.TEAMS}/${teamId}/services/whitelisted`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitStatistics = class AppInitStatistics {
  static get CONFIG() {
    return {
      LOG_LENGTH_KEY: 17,
      LOG_LENGTH_VALUE: 11,
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.telemetry.app_init.AppInitStatistics', z.config.LOGGER.OPTIONS);

    amplify.subscribe(z.event.WebApp.TELEMETRY.BACKEND_REQUESTS, this.update_backend_requests.bind(this));
  }

  add(statistic, value, bucket_size) {
    if (bucket_size && _.isNumber(value)) {
      const buckets = Math.floor(value / bucket_size) + (value % bucket_size ? 1 : 0);

      return (this[statistic] = value === 0 ? 0 : bucket_size * buckets);
    }

    return (this[statistic] = value);
  }

  get() {
    const statistics = {};

    Object.entries(this).forEach(([key, value]) => {
      if (_.isNumber(value) || _.isString(value)) {
        statistics[key] = value;
      }
    });

    return statistics;
  }

  log() {
    this.logger.debug('App initialization statistics');

    Object.entries(this).forEach(([key, value]) => {
      if (_.isNumber(value) || _.isString(value)) {
        const placeholderKeyLength = Math.max(AppInitStatistics.CONFIG.LOG_LENGTH_KEY - key.length, 1);
        const placeholderKey = new Array(placeholderKeyLength).join(' ');
        const placeholderValueLength = Math.max(AppInitStatistics.CONFIG.LOG_LENGTH_VALUE - value.toString().length, 1);
        const placeholderValue = new Array(placeholderValueLength).join(' ');

        this.logger.info(`${placeholderKey}'${key}':${placeholderValue}${value}`);
      }
    });
  }

  update_backend_requests(number_of_requests) {
    this[z.telemetry.app_init.AppInitStatisticsValue.BACKEND_REQUESTS] = number_of_requests;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitStatisticsValue = {
  BACKEND_REQUESTS: 'backend_requests',
  CLIENT_TYPE: 'client_type',
  CLIENTS: 'clients',
  CONNECTIONS: 'connections',
  CONVERSATIONS: 'conversations',
  NOTIFICATIONS: 'notifications',
  SESSIONS: 'sessions',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitTelemetry = class AppInitTelemetry {
  constructor() {
    this.logger = new z.util.Logger('z.telemetry.app_init.AppInitTelemetry', z.config.LOGGER.OPTIONS);
    this.timings = new z.telemetry.app_init.AppInitTimings();
    this.statistics = new z.telemetry.app_init.AppInitStatistics();
  }

  add_statistic(statistic, value, bucket_size) {
    return this.statistics.add(statistic, value, bucket_size);
  }

  get_statistics() {
    return this.statistics.get();
  }

  get_timings() {
    return this.timings.get();
  }

  log_statistics() {
    return this.statistics.log();
  }

  log_timings() {
    return this.timings.log();
  }

  report() {
    const statistics = this.get_statistics();

    statistics.loading_time = this.timings.get_app_load();
    statistics.app_version = z.util.Environment.version(false);
    this.logger.debug('App initialization telemetry');
    this.logger.info(`App version '${statistics.app_version}' initialized within ${statistics.loading_time}s`);
    this.log_statistics();
    this.log_timings();

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.TELEMETRY.APP_INITIALIZATION, statistics);
  }

  time_step(step) {
    return this.timings.time_step(step);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

z.telemetry.app_init.AppInitTimings = class AppInitTimings {
  static get CONFIG() {
    return {
      BUCKET_SIZE: 10,
      LOG_LENGTH_KEY: 27,
      LOG_LENGTH_VALUE: 6,
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.telemetry.AppInitTimings', z.config.LOGGER.OPTIONS);
    this.init = window.performance.now();
  }

  get() {
    const timings = {};

    Object.entries(this).forEach(([key, value]) => {
      if (key.toString() !== 'init' && _.isNumber(value)) {
        timings[key] = value;
      }
    });

    return timings;
  }

  get_app_load() {
    const CONFIG = AppInitTimings.CONFIG;
    const appLoaded = this[z.telemetry.app_init.AppInitTimingsStep.APP_LOADED];
    const appLoadedInSeconds = appLoaded / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;

    return (Math.floor(appLoadedInSeconds / CONFIG.BUCKET_SIZE) + 1) * CONFIG.BUCKET_SIZE;
  }

  log() {
    this.logger.debug('App initialization step durations');

    Object.entries(this).forEach(([key, value]) => {
      if (key.toString() !== 'init' && _.isNumber(value)) {
        const placeholderKeyLength = Math.max(AppInitTimings.CONFIG.LOG_LENGTH_KEY - key.length, 1);
        const placeholderKey = new Array(placeholderKeyLength).join(' ');
        const placeholderValueLength = Math.max(AppInitTimings.CONFIG.LOG_LENGTH_VALUE - value.toString().length, 1);
        const placeholderValue = new Array(placeholderValueLength).join(' ');

        this.logger.info(`${placeholderKey}'${key}':${placeholderValue}${value}ms`);
      }
    });
  }

  time_step(step) {
    if (!this[step]) {
      return (this[step] = window.parseInt(window.performance.now() - this.init));
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.app_init = z.telemetry.app_init || {};

/* eslint-disable sort-keys */

z.telemetry.app_init.AppInitTimingsStep = {
  RECEIVED_ACCESS_TOKEN: 'received_access_token',
  RECEIVED_SELF_USER: 'received_self_user',
  INITIALIZED_CRYPTOGRAPHY: 'initialized_cryptography',
  VALIDATED_CLIENT: 'validated_client',
  RECEIVED_USER_DATA: 'received_user_data',
  UPDATED_FROM_NOTIFICATIONS: 'updated_from_notifications',
  APP_PRE_LOADED: 'app_pre_loaded',
  APP_LOADED: 'app_loaded',
  UPDATED_CONVERSATIONS: 'updated_conversations',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupSteps = {
  ICE_CONNECTION_CONNECTED: 'ice_connection_connected',
  ICE_GATHERING_COMPLETED: 'ice_gathering_completed',
  LOCAL_SDP_SEND: 'local_sdp_send',
  LOCAL_SDP_SET: 'local_sdp_set',
  PEER_CONNECTION_CREATED: 'peer_connection_created',
  REMOTE_SDP_SET: 'remote_sdp_set',
  STARTED: 'started',
  STREAM_RECEIVED: 'stream_received',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupStepsOrder = {
  ANSWER: [
    z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED,
    z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED,
    z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND,
    z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED,
  ],
  OFFER: [
    z.telemetry.calling.CallSetupSteps.STREAM_RECEIVED,
    z.telemetry.calling.CallSetupSteps.PEER_CONNECTION_CREATED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_GATHERING_COMPLETED,
    z.telemetry.calling.CallSetupSteps.LOCAL_SDP_SEND,
    z.telemetry.calling.CallSetupSteps.REMOTE_SDP_SET,
    z.telemetry.calling.CallSetupSteps.ICE_CONNECTION_CONNECTED,
  ],
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.CallSetupTimings = class CallSetupTimings {
  constructor(call_id) {
    this.get = this.get.bind(this);
    this.log = this.log.bind(this);
    this.call_id = call_id;

    this.logger = new z.util.Logger('z.telemetry.calling.CallSetupTimings', z.config.LOGGER.OPTIONS);

    this.is_answer = false;
    this.flowId = undefined;

    this.started = window.performance.now();
    this.stream_requested = 0;
    this.stream_received = 0;
    this.state_put = 0;
    this.flow_received = 0;
    this.peer_connection_created = 0;
    this.remote_sdp_received = 0;
    this.remote_sdp_set = 0;
    this.local_sdp_created = 0;
    this.local_sdp_send = 0;
    this.local_sdp_set = 0;
    this.ice_gathering_started = 0;
    this.ice_gathering_completed = 0;
    this.ice_connection_checking = 0;
    this.ice_connection_connected = 0;
    this.ice_connection_completed = 0;
  }

  get() {
    const timings = {};

    this._steps_order().forEach(step => {
      timings[step] = this[step];
    });

    return timings;
  }

  time_step(step) {
    if (this[step] === 0) {
      this[step] = window.parseInt(window.performance.now() - this.started);
    }
  }

  log() {
    this.logger.info(`Call setup duration for flow ID '${this.flowId}' of call ID '${this.call_id}'`);

    this._steps_order().forEach(step => {
      if (this.hasOwnProperty(step)) {
        const placeholder_key = Array.from(Math.max(26 - step.length, 1)).join(' ');
        const placeholder_value = Array.from(Math.max(6 - this[step].toString().length, 1)).join(' ');

        this.logger.info(`Step${placeholder_key}'${step}':${placeholder_value}${this[step]}ms`);
      }
    });
  }

  _steps_order() {
    return this.is_answer
      ? z.telemetry.calling.CallSetupStepsOrder.ANSWER
      : z.telemetry.calling.CallSetupStepsOrder.OFFER;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

z.telemetry.calling.FlowTelemetry = class FlowTelemetry {
  /**
   * Construct new flow telemetry entity.
   *
   * @param {string} id - Flow ID
   * @param {string} remote_user_id - Remote user ID
   * @param {z.calling.entities.CallEntity} call_et - Call entity
   * @param {CallSetupTimings} timings - Timings of call setup steps
   */
  constructor(id, remote_user_id, call_et, timings) {
    this.id = id;
    this.remote_user_id = remote_user_id;
    this.call_et = call_et;

    const loggerId = this.id.substr(0, 8);
    const loggerTimestamp = new Date().getMilliseconds();
    const loggerName = `z.telemetry.calling.FlowTelemetry - ${loggerId} (${loggerTimestamp})`;
    this.logger = new z.util.Logger(loggerName, z.config.LOGGER.OPTIONS);
    this.is_answer = false;
    this.peer_connection = undefined;

    this.timings = $.extend(new z.telemetry.calling.CallSetupTimings(this.id), timings ? timings.get() : {});
  }

  //##############################################################################
  // External misc
  //##############################################################################

  /**
   * Create flow status report for automation.
   * @returns {Object} Report
   */
  create_automation_report() {
    const report = this.create_report();
    report.meta.remote_user_id = this.remote_user_id;
    return report;
  }

  /**
   * Create flow status report.
   * @param {Error} [passed_error] - Optional error to be added to report
   * @returns {Object} Report
   */
  create_report(passed_error) {
    const report = {
      meta: {
        browser_name: z.util.Environment.browser.name,
        browser_version: z.util.Environment.browser.version,
        flow_id: this.id,
        id: this.call_et.id,
        is_answer: this.is_answer,
        session_id: this.call_et.sessionId,
      },
      telemetry: {
        timings: this.get_timings(),
      },
    };

    if (this.peer_connection) {
      report.rtc_peer_connection = {
        ice_connection_state: this.peer_connection.iceConnectionState,
        ice_gathering_state: this.peer_connection.iceGatheringState,
        signaling_state: this.peer_connection.signalingState,
      };

      const isSignalingStateClosed = this.peer_connection.signalingState === z.calling.rtc.SIGNALING_STATE.CLOSED;
      if (!isSignalingStateClosed) {
        if (this.peer_connection.localDescription) {
          $.extend(report.rtc_peer_connection, {
            local_SDP: this.peer_connection.localDescription.sdp,
            local_SDP_type: this.peer_connection.localDescription.type,
          });
        }

        if (this.peer_connection.remoteDescription) {
          $.extend(report.rtc_peer_connection, {
            remote_SDP: this.peer_connection.remoteDescription.sdp,
            remote_SDP_type: this.peer_connection.remoteDescription.type,
          });
        }
      }
    }

    if (passed_error) {
      report.error = passed_error;
    }

    return report;
  }

  /**
   * Publish call report.
   * @returns {undefined} No return value
   */
  disconnected() {
    amplify.publish(z.event.WebApp.DEBUG.UPDATE_LAST_CALL_STATUS, this.create_report());
  }

  /**
   * Set the PeerConnection on the telemetry.
   * @param {RTCPeerConnection} peer_connection - PeerConnection to be used for telemetry
   * @returns {undefined} No return value
   */
  set_peer_connection(peer_connection) {
    this.peer_connection = peer_connection;
    this.logger.debug('Set or updated PeerConnection for telemetry checks', this.peer_connection);
  }

  /**
   * Update 'is_answer' status of flow.
   * @param {boolean} is_answer - Is the flow an answer
   * @returns {undefined} No return value
   */
  update_is_answer(is_answer) {
    this.is_answer = is_answer;
    this.timings.is_answer = is_answer;
  }

  //##############################################################################
  // Timings
  //##############################################################################

  /**
   * Return the step timings object.
   * @returns {CallSetupTimings} Flow statistics
   */
  get_timings() {
    return this.timings.get();
  }

  /**
   * Time a call setup step.
   * @param {CallSetupSteps} step - Step to time
   * @returns {undefined} No return value
   */
  time_step(step) {
    this.timings.time_step(step);
  }

  //##############################################################################
  // Reporting & Logging
  //##############################################################################

  /**
   * Get full report.
   * @returns {Object} Full automation report
   */
  get_automation_report() {
    return {
      report: this.create_automation_report(),
    };
  }

  /**
   * Log the flow to the browser console.
   * @param {z.calling.entities.ParticipantEntity} participant_et - Call participant
   * @returns {undefined} No return value
   */
  log_status(participant_et) {
    this.logger.force_log(`-- ID: ${this.id}`);

    if (this.remote_user !== undefined) {
      this.logger.force_log(`-- Remote user: ${participant_et.user.name()} (${participant_et.user.id})`);
    }

    this.logger.force_log(`-- User is connected: ${participant_et.isConnected()}`);
    this.logger.force_log(`-- Flow is answer: ${this.is_answer}`);

    if (this.peer_connection) {
      this.logger.force_log(`-- ICE connection: ${this.peer_connection.iceConnectionState}`);
      this.logger.force_log(`-- ICE gathering: ${this.peer_connection.iceGatheringState}`);
    }
  }

  /**
   * Log call timings.
   * @returns {undefined} No return value
   */
  log_timings() {
    this.timings.log();
  }

  /**
   * Report an error to Raygun.
   *
   * @param {string} description - Error description
   * @param {Object} passed_error - Error passed into the report
   * @param {Object} payload - Additional payload for the custom data
   * @returns {undefined} No return value
   */
  report_error(description, passed_error, payload) {
    const custom_data = this.create_report();
    const raygun_error = new Error(description);

    if (passed_error) {
      custom_data.error = passed_error;
      raygun_error.stack = passed_error.stack;
    }

    if (payload) {
      custom_data.payload = payload;
    }

    this.logger.error(description, custom_data);
    Raygun.send(raygun_error, custom_data);
  }

  report_status() {
    const custom_data = this.create_report();
    this.logger.info('Created flow status for call failure report', custom_data);
    return custom_data;
  }

  report_timings() {
    const custom_data = this.timings.log();
    Raygun.send(new Error('Call setup step timings'), custom_data);
    this.logger.info(`Reported setup step timings of flow id '${this.id}' for call analysis`, custom_data);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.telemetry = z.telemetry || {};
window.z.telemetry.calling = z.telemetry.calling || {};

// Call traces entity.
z.telemetry.calling.CallTelemetry = class CallTelemetry {
  constructor() {
    this.logger = new z.util.Logger('z.telemetry.calling.CallTelemetry', z.config.LOGGER.OPTIONS);

    this.sessions = {};
    this.remote_version = undefined;
    this.hasToggledAV = false;
    this.maxNumberOfParticipants = 0;
    this.direction = undefined;

    this.mediaType = z.media.MediaType.AUDIO;
  }

  //##############################################################################
  // Sessions
  //##############################################################################

  /**
   * Force log last call session IDs.
   * @returns {Object} Containing all the sessions
   */
  log_sessions() {
    const sortedSessions = z.util.sortObjectByKeys(this.sessions, true);

    this.logger.force_log('Your last session IDs:');
    Object.values(sortedSessions).forEach(trackingInfo => this.logger.force_log(trackingInfo.to_string()));

    return sortedSessions;
  }

  //##############################################################################
  // Error reporting
  //##############################################################################

  /**
   * Report an error to Raygun.
   * @param {string} description - Error description
   * @param {Error} passed_error - Error to be attached to the report
   * @returns {undefined} No return value
   */
  report_error(description, passed_error) {
    let custom_data;
    const raygun_error = new Error(description);

    if (passed_error) {
      custom_data = {error: passed_error};
      raygun_error.stack = passed_error.stack;
    }

    Raygun.send(raygun_error, custom_data);
  }

  //##############################################################################
  // Analytics
  //##############################################################################

  /**
   * Prepare the call telemetry for a new call (resets to initial values)
   * @param {z.calling.enum.CALL_STATE} direction - direction of the call (outgoing or incoming)
   * @param {z.media.MediaType} [mediaType=z.media.MediaType.AUDIO] - Media type for this call
   * @returns {undefined} No return value
   */
  initiateNewCall(direction, mediaType = z.media.MediaType.AUDIO) {
    this.mediaType = mediaType;
    this.hasToggledAV = false;
    this.maxNumberOfParticipants = 0;
    this.direction = direction;
    this.logger.info(`Initiate new '${direction}' call of type '${this.mediaType}'`);
  }

  setAVToggled() {
    this.hasToggledAV = true;
  }

  /**
   * Sets the remove version of the call.
   * @param {string} remote_version - Remove version string
   * @returns {undefined} No return value
   */
  set_remote_version(remote_version) {
    if (this.remote_version !== remote_version) {
      this.remote_version = remote_version;
      this.logger.info(`Identified remote call version as '${remote_version}'`);
    }
  }

  /**
   * Reports call events for call tracking to Localytics.
   * @param {z.tracking.EventName} eventName - String for call event
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @param {Object} [attributes={}] - Attributes for the event
   * @returns {undefined} No return value
   */
  track_event(eventName, callEntity, attributes = {}) {
    if (callEntity) {
      const {conversationEntity, isGroup} = callEntity;

      const videoTypes = [z.media.MediaType.VIDEO, z.media.MediaType.AUDIO_VIDEO];

      attributes = Object.assign(
        {
          conversation_participants: conversationEntity.getNumberOfParticipants(),
          conversation_participants_in_call_max: this.maxNumberOfParticipants
            ? this.maxNumberOfParticipants
            : undefined,
          conversation_type: isGroup
            ? z.tracking.attribute.ConversationType.GROUP
            : z.tracking.attribute.ConversationType.ONE_TO_ONE,
          direction: this.direction,
          remote_version: [
            z.tracking.EventName.CALLING.ESTABLISHED_CALL,
            z.tracking.EventName.CALLING.JOINED_CALL,
          ].includes(eventName)
            ? this.remote_version
            : undefined,
          started_as_video: videoTypes.includes(this.mediaType),
          with_service: conversationEntity.hasService(),
        },
        z.tracking.helpers.getGuestAttributes(conversationEntity),
        attributes
      );
    }

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, eventName, attributes);
  }

  /**
   * Track the call duration.
   * @param {z.calling.entities.CallEntity} callEntity - Call entity
   * @returns {undefined} No return value
   */
  track_duration(callEntity) {
    const {terminationReason, timerStart, durationTime} = callEntity;

    const duration = Math.floor((Date.now() - timerStart) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    if (!window.isNaN(duration)) {
      this.logger.info(`Call duration: ${duration} seconds.`, durationTime());

      const attributes = {
        AV_switch_toggled: this.hasToggledAV,
        duration: duration,
        reason: terminationReason,
        remote_version: this.remote_version,
      };

      this.track_event(z.tracking.EventName.CALLING.ENDED_CALL, callEntity, attributes);
    }
  }

  numberOfParticipantsChanged(newNumberOfParticipants) {
    this.maxNumberOfParticipants = Math.max(this.maxNumberOfParticipants, newNumberOfParticipants);
  }
};

z.telemetry.calling.CallLogger = class CallLogger {
  static get CONFIG() {
    return {
      MESSAGE_LOG_LENGTH: 10000,
      OBFUSCATION_TRUNCATE_TO: 4,
    };
  }

  static get LOG_LEVEL() {
    return {
      DEBUG: 700,
      ERROR: 1000,
      INFO: 800,
      LEVEL_1: 300,
      LEVEL_2: 400,
      LEVEL_3: 500,
      OFF: 0,
      WARNING: 900,
    };
  }

  static get OBFUSCATED() {
    return {
      FINGERPRINT: 'XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX',
      ICE_PASSWORD: 'XXXXXXXXXXXXXXXXXXXXXXXX',
      IPV4: 'XXX',
      IPV6: 'XXXX:XXXX:XXXX:XXXX',
      KASE_PUBLIC_KEY: 'x-KASEv1:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    };
  }

  static get OBFUSCATION_MODE() {
    return {
      HARD: 'CallLogger.OBFUSCATION_MODE.HARD',
      SOFT: 'CallLogger.OBFUSCATION_MODE.SOFT',
    };
  }

  static get REGEXES() {
    return {
      // From https://github.com/sindresorhus/ip-regex/blob/master/index.js
      IPV4: /(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}/gm,
      IPV6: /((?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(:[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(:[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(:[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(:[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(:[a-fA-F\d]{1,4}){1,6}|:)|(?::((?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(%[0-9a-zA-Z]{1,})?/gm,
      UUID: /([0-9a-f]{8})-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gm,
    };
  }

  constructor(name, id, options, messageLog) {
    name = id ? this._createName(name, id) : name;

    this.logger = new z.util.Logger(name, options);
    this.levels = this.logger.levels;

    this.messageLog = messageLog;
    this.name = name;
    this.options = options;

    this.obfuscationMode = CallLogger.OBFUSCATION_MODE.SOFT;
  }

  obfuscate(string) {
    if (string) {
      if (this._isHardObfuscationMode()) {
        return CryptoJS.SHA256(string)
          .toString()
          .substr(0, CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
      }

      return string.substr(0, CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
    }
  }

  obfuscateSdp(sdpMessage) {
    if (!sdpMessage || !window.sdpTransform) {
      return '[Unknown]';
    }

    const decodedSdpMessage = window.sdpTransform.parse(sdpMessage);

    decodedSdpMessage.media.forEach(({fingerprint, icePwd, invalid}, index) => {
      // Remove fingerprints
      const hasFingerprintHash = fingerprint && fingerprint.hash;
      if (hasFingerprintHash) {
        decodedSdpMessage.media[index].fingerprint.hash = CallLogger.OBFUSCATED.FINGERPRINT;
      }

      // Remove ice password
      const hasIcePassword = !!icePwd;
      if (hasIcePassword) {
        decodedSdpMessage.media[index].icePwd = CallLogger.OBFUSCATED.ICE_PASSWORD;
      }

      // Remove KASE public key (for receiving side)
      const hasInvalid = !!invalid;
      if (hasInvalid) {
        invalid.forEach(({value}, invalidIndex) => {
          if (value.startsWith('x-KASEv1')) {
            decodedSdpMessage.media[index].invalid[invalidIndex].value = CallLogger.OBFUSCATED.KASE_PUBLIC_KEY;
          }
        });
      }
    });

    return window.sdpTransform.write(decodedSdpMessage);
  }

  getDebugType(number) {
    switch (number) {
      case CallLogger.LOG_LEVEL.LEVEL_1:
      case CallLogger.LOG_LEVEL.LEVEL_2:
      case CallLogger.LOG_LEVEL.LEVEL_3: {
        return 'VERBOSE';
      }

      case CallLogger.LOG_LEVEL.DEBUG: {
        return 'DEBUG';
      }

      case CallLogger.LOG_LEVEL.INFO: {
        return 'INFO';
      }

      case CallLogger.LOG_LEVEL.WARNING: {
        return 'INFO';
      }

      case CallLogger.LOG_LEVEL.ERROR: {
        return 'ERROR';
      }
    }
  }

  logToMemory(logLevel, obfuscatedMessage) {
    while (this.messageLog.length >= CallLogger.CONFIG.MESSAGE_LOG_LENGTH) {
      this.messageLog.shift();
    }

    const shouldLogToMemory = logLevel !== CallLogger.LOG_LEVEL.OFF;
    if (shouldLogToMemory) {
      const logType = this.getDebugType(logLevel);
      let logMessage = `[${new Date().toISOString()}] [${this.name}] (${logType}) ${obfuscatedMessage}`;
      logMessage = this.safeGuard(logMessage);
      this.messageLog.push(logMessage);
    }
  }

  _createName(name, id) {
    return `${name} - ${this.obfuscate(id)} (${new Date().getMilliseconds()})`;
  }

  _isHardObfuscationMode() {
    return this.obfuscationMode === CallLogger.OBFUSCATION_MODE.HARD;
  }

  debug() {
    this._log([this.logger.levels.DEBUG].concat(...arguments));
  }

  error() {
    this._log([this.logger.levels.ERROR].concat(...arguments));
  }

  info() {
    this._log([this.logger.levels.INFO].concat(...arguments));
  }

  warn() {
    this._log([this.logger.levels.WARN].concat(...arguments));
  }

  log(logLevel) {
    if (typeof logLevel === 'function') {
      return this._log(arguments);
    }
    this._log([this.logger.levels.INFO].concat(...arguments));
  }

  _log(args) {
    // Use obfuscated format for call logs if possible
    const [firstArgument, secondArgument] = args;
    const isLogMessageObject = typeof secondArgument === 'object';
    if (isLogMessageObject) {
      const {message, data} = secondArgument;

      const isExpectedObjectStructure = typeof message === 'string' && typeof data === 'object';
      if (isExpectedObjectStructure) {
        const defaultMessage = z.util.StringUtil.format(message, ...data.default);
        const obfuscatedMessage = z.util.StringUtil.format(message, ...data.obfuscated);
        args[1] = defaultMessage;

        this.logToMemory(firstArgument(), obfuscatedMessage);
        return this.logger.log(...args);
      }
    }

    const hasMultipleArgs = args.length > 1;
    const logLevel = hasMultipleArgs ? firstArgument() : CallLogger.LOG_LEVEL.INFO;
    const logMessage = hasMultipleArgs ? secondArgument : firstArgument;
    this.logToMemory(logLevel, logMessage);
    this.logger.log(...args);
  }

  safeGuard(message) {
    // Ensure UUID are properly obfuscated
    message = message.replace(CallLogger.REGEXES.UUID, match => this.obfuscate(match));

    // Obfuscate IP addresses
    message = message.replace(CallLogger.REGEXES.IPV4, ip => {
      ip = ip.split('.');
      ip[ip.length - 1] = CallLogger.OBFUSCATED.IPV4;
      ip[ip.length - 2] = CallLogger.OBFUSCATED.IPV4;
      return ip.join('.');
    });
    message = message.replace(CallLogger.REGEXES.IPV6, ip => {
      ip = ip.split(':').slice(0, 3);
      return [...ip, CallLogger.OBFUSCATED.IPV6].join(':');
    });

    return message;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.AvailabilityMapper = (() => {
  const AVAILABILITY_VALUES = {
    AVAILABLE: 'available',
    AWAY: 'away',
    BUSY: 'busy',
    NONE: 'none',
  };

  const valueFromType = availabilityType => {
    const TYPE_VALUES = {
      [z.user.AvailabilityType.AVAILABLE]: AVAILABILITY_VALUES.AVAILABLE,
      [z.user.AvailabilityType.AWAY]: AVAILABILITY_VALUES.AWAY,
      [z.user.AvailabilityType.BUSY]: AVAILABILITY_VALUES.BUSY,
      [z.user.AvailabilityType.NONE]: AVAILABILITY_VALUES.NONE,
    };

    const value = TYPE_VALUES[availabilityType];
    if (value) {
      return value;
    }
    throw new z.error.UserError(z.error.BaseError.TYPE.INVALID_PARAMETER);
  };

  return {
    nameFromType: availabilityType => {
      const TYPE_STRING_IDS = {
        [z.user.AvailabilityType.AVAILABLE]: z.string.userAvailabilityAvailable,
        [z.user.AvailabilityType.AWAY]: z.string.userAvailabilityAway,
        [z.user.AvailabilityType.BUSY]: z.string.userAvailabilityBusy,
        [z.user.AvailabilityType.NONE]: z.string.userAvailabilityNone,
      };

      const stringId = TYPE_STRING_IDS[availabilityType];
      if (stringId) {
        return z.l10n.text(stringId);
      }
      throw new z.error.UserError(z.error.BaseError.TYPE.INVALID_PARAMETER);
    },
    protoFromType: availabilityType => {
      const typeValue = valueFromType(availabilityType).toUpperCase();
      return z.proto.Availability.Type[typeValue];
    },
    valueFromType,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

/**
 * Enum for different user availability types.
 * @type {z.user.AvailabilityType} Enum of availability types
 */
z.user.AvailabilityType = {
  AVAILABLE: 1,
  AWAY: 2,
  BUSY: 3,
  NONE: 0,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.ConsentType = {
  MARKETING: 2,
  TERMS_OF_USE: 1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.ConsentValue = {
  GIVEN: 1,
  NOT_GIVEN: 0,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserService = class UserService {
  static get URL() {
    return {
      PASSWORD_RESET: '/password-reset',
      USERS: '/users',
    };
  }

  /**
   * Construct a new User Service.
   * @class z.user.UserService
   * @param {z.service.BackendClient} backendClient - Client for the API calls
   * @param {StorageService} storageService - Service for all storage interactions
   */
  constructor(backendClient, storageService) {
    this.backendClient = backendClient;
    this.logger = new z.util.Logger('z.user.UserService', z.config.LOGGER.OPTIONS);
    this.storageService = storageService;

    this.USER_STORE_NAME = z.storage.StorageSchemata.OBJECT_STORE.USERS;
  }

  //##############################################################################
  // Database interactions
  //##############################################################################

  /**
   * Loads user states from the local database.
   * @returns {Promise} Resolves with all the stored user states
   */
  loadUserFromDb() {
    return this.storageService.getAll(this.USER_STORE_NAME);
  }

  /**
   * Saves a user entity in the local database.
   * @param {User} userEntity - User entity
   * @returns {Promise} Resolves with the conversation entity
   */
  saveUserInDb(userEntity) {
    const userData = userEntity.serialize();

    return this.storageService.save(this.USER_STORE_NAME, userEntity.id, userData).then(primaryKey => {
      this.logger.info(`State of user '${primaryKey}' was stored`, userData);
      return userEntity;
    });
  }

  //##############################################################################
  // Backend interactions
  //##############################################################################

  /**
   * Check if a username exists.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/checkUserHandle
   *
   * @param {string} username - Username
   * @returns {Promise} Resolves with backend response.
   */
  checkUserHandle(username) {
    return this.backendClient.sendRequest({
      type: 'HEAD',
      url: `${UserService.URL.USERS}/handles/${username}`,
    });
  }

  getUserByHandle(username) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${UserService.URL.USERS}/handles/${username}`,
    });
  }

  /**
   * Get a set of users for the given usernames.
   *
   * @example ['0bb84213-8cc2-4bb1-9e0b-b8dd522396d5', '15ede065-72b3-433a-9917-252f076ed031']
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/checkUserHandles
   *
   * @param {array} usernames - List of usernames
   * @param {number} amount - amount of usernames to return
   * @returns {Promise} Resolves with backend response.
   */
  checkUserHandles(usernames, amount = 1) {
    return this.backendClient.sendJson({
      data: {
        handles: usernames,
        return: amount,
      },
      type: 'POST',
      url: `${UserService.URL.USERS}/handles`,
    });
  }

  /**
   * Get a set of users.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/users
   * @example ['0bb84213-8cc2-4bb1-9e0b-b8dd522396d5', '15ede065-72b3-433a-9917-252f076ed031']
   *
   * @param {Array<string>} userIds - ID of users to be fetched
   * @returns {Promise} Resolves with backend response.
   */
  getUsers(userIds) {
    return this.backendClient.sendRequest({
      data: {
        ids: userIds.join(','),
      },
      type: 'GET',
      url: UserService.URL.USERS,
    });
  }

  /**
   * Get a user by ID.
   *
   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/users/user
   *
   * @param {string} userId - User ID
   * @returns {Promise} Resolves with backend response.
   */
  getUser(userId) {
    return this.backendClient.sendRequest({
      type: 'GET',
      url: `${UserService.URL.USERS}/${userId}`,
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserMapper = class UserMapper {
  /**
   * Construct a new User Mapper.
   * @class z.user.UserMapper
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   */
  constructor(serverTimeRepository) {
    this.logger = new z.util.Logger('z.user.UserMapper', z.config.LOGGER.OPTIONS);
    this.serverTimeRepository = serverTimeRepository;
  }

  /**
   * Converts JSON user into user entity.
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  mapUserFromJson(userData) {
    return this.updateUserFromObject(new z.entity.User(), userData);
  }

  /**
   * Converts JSON self user into user entity.
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  mapSelfUserFromJson(userData) {
    const userEntity = this.updateUserFromObject(new z.entity.User(), userData);
    userEntity.is_me = true;

    if (userData.locale) {
      userEntity.locale = userData.locale;
    }

    return userEntity;
  }

  /**
   * Convert multiple JSON users into user entities.
   * @note Return an empty array in any case to prevent crashes.
   *
   * @param {Array<Object>} usersData - Users data
   * @returns {Array<z.entity.User>} Mapped user entities
   */
  mapUsersFromJson(usersData) {
    if (usersData && usersData.length) {
      return usersData.filter(userData => userData).map(userData => this.mapUserFromJson(userData));
    }
    this.logger.warn('We got no user data from the backend');
    return [];
  }

  /**
   * Maps JSON user into a blank user entity or updates an existing one.
   * @note Mapping of single properties to an existing user happens when the user changes his name or accent color.
   * @param {z.entity.User} userEntity - User entity that the info shall be mapped to
   * @param {Object} userData - User data
   * @returns {z.entity.User} Mapped user entity
   */
  updateUserFromObject(userEntity, userData) {
    if (!userData) {
      return;
    }

    // We are trying to update non-matching users
    const isUnexpectedId = userEntity.id !== '' && userData.id !== userEntity.id;
    if (isUnexpectedId) {
      throw new Error(`Updating wrong user entity. User '${userEntity.id}' does not match data '${userData.id}'.`);
    }

    const isNewUser = userEntity.id === '' && userData.id !== '';
    if (isNewUser) {
      userEntity.id = userData.id;
      userEntity.joaatHash = z.util.Crypto.Hashing.joaatHash(userData.id);
    }

    const {
      accent_id: accentId,
      assets,
      email,
      expires_at: expirationDate,
      handle,
      name,
      phone,
      picture,
      service,
      sso_id: ssoId,
      team,
    } = userData;

    if (accentId) {
      userEntity.accent_id(accentId);
    }

    const hasAsset = assets && assets.length;
    const hasPicture = picture && picture.length;
    let mappedAssets;
    if (hasAsset) {
      mappedAssets = z.assets.AssetMapper.mapProfileAssets(userEntity.id, userData.assets);
    } else if (hasPicture) {
      mappedAssets = z.assets.AssetMapper.mapProfileAssetsV1(userEntity.id, userData.picture);
    }
    z.assets.AssetMapper.updateUserEntityAssets(userEntity, mappedAssets);

    if (email) {
      userEntity.email(email);
    }

    if (expirationDate) {
      userEntity.isTemporaryGuest(true);
      const adjustedTimestamp = this.serverTimeRepository.toLocalTimestamp(new Date(expirationDate).getTime());
      userEntity.setGuestExpiration(adjustedTimestamp);
    }

    if (handle) {
      userEntity.username(handle);
    }

    if (name) {
      userEntity.name(name.trim());
    }

    if (phone) {
      userEntity.phone(phone);
    }

    if (service) {
      userEntity.isService = true;
      userEntity.providerId = service.provider;
      userEntity.providerName = ko.observable('');
      userEntity.serviceId = service.id;
    }

    if (ssoId && Object.keys(ssoId).length) {
      userEntity.isSingleSignOn = true;
    }

    if (team) {
      userEntity.inTeam(true);
      userEntity.teamId = team;
    }

    return userEntity;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

z.user.UserRepository = class UserRepository {
  static get CONFIG() {
    return {
      MINIMUM_NAME_LENGTH: 2,
      MINIMUM_PICTURE_SIZE: {
        HEIGHT: 320,
        WIDTH: 320,
      },
      MINIMUM_USERNAME_LENGTH: 2,
    };
  }

  /**
   * Construct a new User repository.
   * @class z.user.UserRepository
   * @param {z.user.UserService} user_service - Backend REST API user service implementation
   * @param {z.assets.AssetService} asset_service - Backend REST API asset service implementation
   * @param {z.self.SelfService} selfService - Backend REST API self service implementation
   * @param {z.client.ClientRepository} client_repository - Repository for all client interactions
   * @param {z.time.ServerTimeRepository} serverTimeRepository - Handles time shift between server and client
   */
  constructor(user_service, asset_service, selfService, client_repository, serverTimeRepository) {
    this.user_service = user_service;
    this.asset_service = asset_service;
    this.selfService = selfService;
    this.client_repository = client_repository;
    this.logger = new z.util.Logger('z.user.UserRepository', z.config.LOGGER.OPTIONS);

    this.user_mapper = new z.user.UserMapper(serverTimeRepository);
    this.should_set_username = false;

    this.self = ko.observable();
    this.users = ko.observableArray([]);

    this.connect_requests = ko
      .pureComputed(() => {
        return this.users().filter(user_et => user_et.isIncomingRequest());
      })
      .extend({rateLimit: 50});

    this.connected_users = ko
      .pureComputed(() => {
        return this.users()
          .filter(user_et => user_et.isConnected())
          .sort((user_a, user_b) => z.util.StringUtil.sortByPriority(user_a.first_name(), user_b.first_name()));
      })
      .extend({rateLimit: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND});

    this.isActivatedAccount = ko.pureComputed(() => this.self() && !this.self().isTemporaryGuest());
    this.isTemporaryGuest = ko.pureComputed(() => this.self() && this.self().isTemporaryGuest());

    this.isTeam = ko.observable();
    this.teamMembers = undefined;
    this.teamUsers = undefined;

    this.number_of_contacts = ko.pureComputed(() => {
      const contacts = this.isTeam() ? this.teamUsers() : this.connected_users();
      return contacts.filter(user_et => !user_et.isService).length;
    });
    this.number_of_contacts.subscribe(number_of_contacts => {
      amplify.publish(z.event.WebApp.ANALYTICS.SUPER_PROPERTY, z.tracking.SuperProperty.CONTACTS, number_of_contacts);
    });

    this.marketingConsent = ko.observable(false);

    amplify.subscribe(z.event.WebApp.CLIENT.ADD, this.addClientToUser.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.REMOVE, this.remove_client_from_user.bind(this));
    amplify.subscribe(z.event.WebApp.CLIENT.UPDATE, this.update_clients_from_user.bind(this));
    amplify.subscribe(z.event.WebApp.USER.SET_AVAILABILITY, this.setAvailability.bind(this));
    amplify.subscribe(z.event.WebApp.USER.EVENT_FROM_BACKEND, this.on_user_event.bind(this));
    amplify.subscribe(z.event.WebApp.USER.PERSIST, this.saveUserInDb.bind(this));
    amplify.subscribe(z.event.WebApp.USER.UPDATE, this.updateUserById.bind(this));
  }

  /**
   * Listener for incoming user events.
   *
   * @param {Object} event_json - JSON data for event
   * @param {z.event.EventRepository.SOURCE} source - Source of event
   * @returns {undefined} No return value
   */
  on_user_event(event_json, source) {
    const type = event_json.type;

    const logObject = {eventJson: JSON.stringify(event_json), eventObject: event_json};
    this.logger.info(`»» User Event: '${type}' (Source: ${source})`, logObject);

    switch (type) {
      case z.event.Backend.USER.DELETE:
        this.user_delete(event_json);
        break;
      case z.event.Backend.USER.UPDATE:
        this.user_update(event_json);
        break;
      case z.event.Client.USER.AVAILABILITY:
        this.onUserAvailability(event_json);
        break;
      default:
    }
  }

  loadUsers() {
    if (this.isTeam()) {
      return this.user_service
        .loadUserFromDb()
        .then(users => {
          if (users.length) {
            this.logger.log(`Loaded state of '${users.length}' users from database`, users);

            const mappingPromises = users.map(user => {
              return this.get_user_by_id(user.id).then(userEntity => userEntity.availability(user.availability));
            });

            return Promise.all(mappingPromises);
          }
        })
        .then(() => this.users().forEach(userEntity => userEntity.subscribeToChanges()));
    }
  }

  /**
   * Persists a conversation state in the database.
   * @param {User} userEntity - User which should be persisted
   * @returns {Promise} Resolves when user was saved
   */
  saveUserInDb(userEntity) {
    return this.user_service.saveUserInDb(userEntity);
  }

  /**
   * Event to delete the matching user.
   * @param {string} id - User ID of deleted user
   * @returns {undefined} No return value
   */
  user_delete({id}) {
    // @todo Add user deletion cases for other users
    const is_self_user = id === this.self().id;
    if (is_self_user) {
      window.setTimeout(() => {
        amplify.publish(z.event.WebApp.LIFECYCLE.SIGN_OUT, z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED, true);
      }, 50);
    }
  }

  /**
   * Event to update availability of user.
   * @param {Object} event - Event data
   * @returns {undefined} No return value
   */
  onUserAvailability(event) {
    if (this.isTeam()) {
      const {
        from: userId,
        data: {availability},
      } = event;
      this.get_user_by_id(userId).then(userEntity => userEntity.availability(availability));
    }
  }

  /**
   * Event to update the matching user.
   * @param {Object} user - Update user info
   * @returns {Promise} Resolves wit the updated user entity
   */
  user_update({user}) {
    const is_self_user = user.id === this.self().id;
    const user_promise = is_self_user ? Promise.resolve(this.self()) : this.get_user_by_id(user.id);
    return user_promise.then(user_et => {
      this.user_mapper.updateUserFromObject(user_et, user);

      if (is_self_user) {
        amplify.publish(z.event.WebApp.TEAM.UPDATE_INFO);
      }

      return user_et;
    });
  }

  /**
   * Update users matching the given connections.
   * @param {Array<z.connection.ConnectionEntity>} connectionEntities - Connection entities
   * @returns {Promise<Array<z.connection.ConnectionEntity>>} Promise that resolves when all connections have been updated
   */
  updateUsersFromConnections(connectionEntities) {
    const userIds = connectionEntities.map(connectionEntity => connectionEntity.userId);
    return this.get_users_by_id(userIds).then(userEntities => {
      userEntities.forEach(userEntity => {
        const connectionEntity = connectionEntities.find(({userId}) => userId === userEntity.id);
        userEntity.connection(connectionEntity);
      });
      return this._assignAllClients();
    });
  }

  /**
   * Assign all locally stored clients to the users.
   * @private
   * @returns {Promise} Promise that resolves with all user entities where client entities have been assigned to.
   */
  _assignAllClients() {
    return this.client_repository.getAllClientsFromDb().then(recipients => {
      const userIds = Object.keys(recipients);
      this.logger.info(`Found locally stored clients for '${userIds.length}' users`, recipients);

      return this.get_users_by_id(userIds).then(userEntities => {
        userEntities.forEach(userEntity => {
          const clientEntities = recipients[userEntity.id];
          const tooManyClients = clientEntities > 8;
          if (tooManyClients) {
            this.logger.warn(`Found '${clientEntities.length}' clients for '${userEntity.name()}'`, clientEntities);
          }
          userEntity.devices(clientEntities);
        });

        return userEntities;
      });
    });
  }

  /**
   * Saves a new client for the first time to the database and adds it to a user's entity.
   *
   * @param {string} userId - ID of user
   * @param {Object} clientPayload - Payload of client which should be added to user
   * @param {boolean} publishClient - Publish new client
   * @returns {Promise} Promise that resolves when a client and its session have been deleted
   */
  addClientToUser(userId, clientPayload, publishClient = false) {
    return this.get_user_by_id(userId).then(userEntity => {
      const clientEntity = this.client_repository.clientMapper.mapClient(clientPayload, userEntity.is_me);
      const wasClientAdded = userEntity.add_client(clientEntity);

      if (wasClientAdded) {
        return this.client_repository.saveClientInDb(userId, clientEntity.toJson()).then(() => {
          if (publishClient) {
            amplify.publish(z.event.WebApp.USER.CLIENT_ADDED, userId, clientEntity);
          }
        });
      }
    });
  }

  /**
   * Removes a stored client and the session connected with it.
   * @param {string} user_id - ID of user
   * @param {string} client_id - ID of client to be deleted
   * @returns {Promise} Promise that resolves when a client and its session have been deleted
   */
  remove_client_from_user(user_id, client_id) {
    return this.client_repository
      .removeClient(user_id, client_id)
      .then(() => this.get_user_by_id(user_id))
      .then(user_et => {
        user_et.remove_client(client_id);
        amplify.publish(z.event.WebApp.USER.CLIENT_REMOVED, user_id, client_id);
      });
  }

  /**
   * Update clients for given user.
   * @param {string} user_id - ID of user
   * @param {Array<z.client.ClientEntity>} client_ets - Clients which should get updated
   * @returns {undefined} No return value
   */
  update_clients_from_user(user_id, client_ets) {
    this.get_user_by_id(user_id).then(user_et => {
      user_et.devices(client_ets);
      amplify.publish(z.event.WebApp.USER.CLIENTS_UPDATED, user_id, client_ets);
    });
  }

  setAvailability(availability, method) {
    const hasAvailabilityChanged = availability !== this.self().availability();
    const newAvailabilityValue = z.user.AvailabilityMapper.valueFromType(availability);
    if (hasAvailabilityChanged) {
      const oldAvailabilityValue = z.user.AvailabilityMapper.valueFromType(this.self().availability());
      this.logger.log(`Availability was changed from '${oldAvailabilityValue}' to '${newAvailabilityValue}'`);
      this.self().availability(availability);
      this._trackAvailability(availability, method);
    } else {
      this.logger.log(`Availability was again set to '${newAvailabilityValue}'`);
    }

    const genericMessage = new z.proto.GenericMessage(z.util.createRandomUuid());
    const protoAvailability = new z.proto.Availability(z.user.AvailabilityMapper.protoFromType(availability));
    genericMessage.set(z.cryptography.GENERIC_MESSAGE_TYPE.AVAILABILITY, protoAvailability);

    amplify.publish(z.event.WebApp.BROADCAST.SEND_MESSAGE, genericMessage);
  }

  /**
   * Track availability action.
   *
   * @param {z.user.AvailabilityType} availability - Type of availability
   * @param {string} method - Method used for availability change
   * @returns {undefined} No return value
   */
  _trackAvailability(availability, method) {
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.CHANGED_STATUS, {
      method: method,
      status: z.user.AvailabilityMapper.valueFromType(availability),
    });
  }

  /**
   * Request account deletion.
   * @returns {Promise} Promise that resolves when account deletion process has been initiated
   */
  delete_me() {
    return this.selfService
      .deleteSelf()
      .then(() => this.logger.info('Account deletion initiated'))
      .catch(error => this.logger.error(`Unable to delete self: ${error}`));
  }

  /**
   * Get a user from the backend.
   * @param {string} userId - User ID
   * @returns {Promise<z.entity.User>} Promise that resolves with the user entity
   */
  _fetchUserById(userId) {
    return this.fetchUsersById([userId]).then(([userEntity]) => userEntity);
  }

  /**
   * Get users from the backend.
   * @param {Array<string>} userIds - User IDs
   * @returns {Promise<Array<z.entity.User>>} Promise that resolves with an array of user entities
   */
  fetchUsersById(userIds = []) {
    userIds = userIds.filter(userId => !!userId);

    if (!userIds.length) {
      return Promise.resolve([]);
    }

    const _getUsers = chunkOfUserIds => {
      return this.user_service
        .getUsers(chunkOfUserIds)
        .then(response => (response ? this.user_mapper.mapUsersFromJson(response) : []))
        .catch(error => {
          const isNotFound = error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND;
          if (isNotFound) {
            return [];
          }
          throw error;
        });
    };

    const chunksOfUserIds = z.util.ArrayUtil.chunk(userIds, z.config.MAXIMUM_USERS_PER_REQUEST);
    return Promise.all(chunksOfUserIds.map(chunkOfUserIds => _getUsers(chunkOfUserIds)))
      .then(resolveArray => {
        const newUserEntities = _.flatten(resolveArray);

        if (this.isTeam()) {
          this.mapGuestStatus(newUserEntities);
        }

        return this.save_users(newUserEntities);
      })
      .then(fetchedUserEntities => {
        // If there is a difference then we most likely have a case with a suspended user
        const isAllUserIds = userIds.length === fetchedUserEntities.length;
        if (!isAllUserIds) {
          fetchedUserEntities = this._add_suspended_users(userIds, fetchedUserEntities);
        }

        return fetchedUserEntities;
      });
  }

  /**
   * Find a local user.
   * @param {string} userId - User ID
   * @returns {Promise<z.entity.User>} Resolves with the matching user entity
   */
  findUserById(userId) {
    if (!userId) {
      return Promise.reject(new z.error.UserError(z.error.BaseError.TYPE.MISSING_PARAMETER));
    }

    const matchingUserEntity = this.users().find(userEntity => userEntity.id === userId);
    return matchingUserEntity
      ? Promise.resolve(matchingUserEntity)
      : Promise.reject(new z.error.UserError(z.error.UserError.TYPE.USER_NOT_FOUND));
  }

  /**
   * Get self user from backend.
   * @returns {Promise} Promise that will resolve with the self user entity
   */
  getSelf() {
    return this.selfService
      .getSelf()
      .then(userData => this._upgradePictureAsset(userData))
      .then(response => this.user_mapper.mapSelfUserFromJson(response))
      .then(userEntity => {
        const promises = [this.save_user(userEntity, true), this.getMarketingConsent()];
        return Promise.all(promises).then(() => userEntity);
      })
      .catch(error => {
        this.logger.error(`Unable to load self user: ${error.message || error}`, [error]);
        throw error;
      });
  }

  /**
   * Detects if the user has a profile picture that uses the outdated picture API.
   * Will migrate the picture to the newer assets API if so.
   *
   * @param {Object} userData - user data from the backend
   * @returns {void}
   */
  _upgradePictureAsset(userData) {
    const hasPicture = userData.picture.length;
    const hasAsset = userData.assets.length;

    if (hasPicture) {
      if (!hasAsset) {
        // if there are no assets, just upload the old picture to the new api
        const {medium} = z.assets.AssetMapper.mapProfileAssetsV1(userData.id, userData.picture);
        medium.load().then(imageBlob => this.change_picture(imageBlob));
      } else {
        // if an asset is already there, remove the pointer to the old picture
        this.selfService.putSelf({picture: []});
      }
    }
    return userData;
  }

  /**
   * Check for user locally and fetch it from the server otherwise.
   * @param {string} user_id - User ID
   * @returns {Promise<z.entity.User>} Promise that resolves with the matching user entity
   */
  get_user_by_id(user_id) {
    return this.findUserById(user_id)
      .catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (isNotFound) {
          return this._fetchUserById(user_id);
        }
        throw error;
      })
      .catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (!isNotFound) {
          this.logger.error(`Failed to get user '${user_id}': ${error.message}`, error);
        }
        throw error;
      });
  }

  get_user_id_by_handle(handle) {
    return this.user_service
      .getUserByHandle(handle.toLowerCase())
      .then(({user: user_id}) => user_id)
      .catch(error => {
        if (error.code !== z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          throw error;
        }
      });
  }

  /**
   * Check for users locally and fetch them from the server otherwise.
   * @param {Array<string>} user_ids - User IDs
   * @param {boolean} offline - Should we only look for cached contacts
   * @returns {Promise<Array<z.entity.User>>} Resolves with an array of users
   */
  get_users_by_id(user_ids = [], offline = false) {
    if (!user_ids.length) {
      return Promise.resolve([]);
    }

    const _find_user = user_id => {
      return this.findUserById(user_id).catch(error => {
        if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
          throw error;
        }
        return user_id;
      });
    };

    const find_users = user_ids.map(user_id => _find_user(user_id));

    return Promise.all(find_users).then(resolve_array => {
      const known_user_ets = resolve_array.filter(array_item => array_item instanceof z.entity.User);
      const unknown_user_ids = resolve_array.filter(array_item => _.isString(array_item));

      if (offline || !unknown_user_ids.length) {
        return known_user_ets;
      }

      return this.fetchUsersById(unknown_user_ids).then(user_ets => known_user_ets.concat(user_ets));
    });
  }

  /**
   * Is the user the logged in user.
   * @param {z.entity.User|string} user_id - User entity or user ID
   * @returns {boolean} Is the user the logged in user
   */
  is_me(user_id) {
    if (!_.isString(user_id)) {
      user_id = user_id.id;
    }
    return this.self().id === user_id;
  }

  /**
   * Is the user the logged in user.
   * @param {z.entity.User|string} user_et - User entity or user ID
   * @param {boolean} is_me - True, if self user
   * @returns {Promise} Resolves with the user entity
   */
  save_user(user_et, is_me = false) {
    return this.findUserById(user_et.id).catch(error => {
      if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
        throw error;
      }

      if (is_me) {
        user_et.is_me = true;
        this.self(user_et);
      }
      this.users.push(user_et);
      return user_et;
    });
  }

  /**
   * Save multiple users at once.
   * @param {Array<z.entity.User>} user_ets - Array of user entities to be stored
   * @returns {Promise} Resolves with users passed as parameter
   */
  save_users(user_ets) {
    const _find_users = user_et => {
      return this.findUserById(user_et.id)
        .then(() => undefined)
        .catch(error => {
          if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
            throw error;
          }
          return user_et;
        });
    };

    const find_users = user_ets.map(user_et => _find_users(user_et));

    return Promise.all(find_users).then(resolve_array => {
      z.util.koArrayPushAll(this.users, resolve_array.filter(user_et => user_et));
      return user_ets;
    });
  }

  /**
   * Update a local user from the backend by ID.
   * @param {string} userId - User ID
   * @returns {Promise} Resolves when user was updated
   */
  updateUserById(userId) {
    const getLocalUser = () =>
      this.findUserById(userId).catch(error => {
        const isNotFound = error.type === z.error.UserError.TYPE.USER_NOT_FOUND;
        if (isNotFound) {
          return new z.entity.User();
        }
        throw error;
      });

    return Promise.all([getLocalUser(userId), this.user_service.getUser(userId)])
      .then(([localUserEntity, updatedUserData]) =>
        this.user_mapper.updateUserFromObject(localUserEntity, updatedUserData)
      )
      .then(userEntity => {
        if (this.isTeam()) {
          this.mapGuestStatus([userEntity]);
        }
      });
  }

  /**
   * Add user entities for suspended users.
   * @param {Array<string>} user_ids - Requested user IDs
   * @param {Array<z.entity.User>} user_ets - User entities returned by backend
   * @returns {Array<z.entity.User>} User entities to be returned
   */
  _add_suspended_users(user_ids, user_ets) {
    for (const user_id of user_ids) {
      const matching_user_ids = user_ets.find(user_et => user_et.id === user_id);

      if (!matching_user_ids) {
        const user_et = new z.entity.User(user_id);
        user_et.name(z.l10n.text(z.string.nonexistentUser));
        user_ets.push(user_et);
      }
    }
    return user_ets;
  }

  /**
   * Change the accent color.
   * @param {number} accent_id - New accent color
   * @returns {Promise} Resolves when accent color was changed
   */
  change_accent_color(accent_id) {
    return this.selfService
      .putSelf({accent_id})
      .then(() => this.user_update({user: {accent_id: accent_id, id: this.self().id}}));
  }

  /**
   * Change name.
   * @param {string} name - New name
   * @returns {Promise} Resolves when the name was changed
   */
  change_name(name) {
    if (name.length >= UserRepository.CONFIG.MINIMUM_NAME_LENGTH) {
      return this.selfService.putSelf({name}).then(() => this.user_update({user: {id: this.self().id, name: name}}));
    }

    return Promise.reject(new z.error.UserError(z.userUserError.TYPE.INVALID_UPDATE));
  }

  /**
   * Whether the user needs to set a username.
   * @returns {boolean} True, if username should be changed.
   */
  shouldChangeUsername() {
    return this.should_set_username;
  }

  /**
   * Tries to generate a username suggestion.
   * @returns {Promise} Resolves with the username suggestions
   */
  get_username_suggestion() {
    let suggestions = null;

    return Promise.resolve()
      .then(() => {
        suggestions = z.user.UserHandleGenerator.create_suggestions(this.self().name());
        return this.verify_usernames(suggestions);
      })
      .then(valid_suggestions => {
        this.should_set_username = true;
        this.self().username(valid_suggestions[0]);
      })
      .catch(error => {
        if (error.code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          this.should_set_username = false;
        }

        throw error;
      });
  }

  /**
   * Change username.
   * @param {string} username - New username
   * @returns {Promise} Resolves when the username was changed
   */
  change_username(username) {
    if (username.length >= UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH) {
      return this.selfService
        .putSelfHandle(username)
        .then(() => {
          this.should_set_username = false;
          return this.user_update({user: {handle: username, id: this.self().id}});
        })
        .catch(({code: error_code}) => {
          if (
            [
              z.error.BackendClientError.STATUS_CODE.CONFLICT,
              z.error.BackendClientError.STATUS_CODE.BAD_REQUEST,
            ].includes(error_code)
          ) {
            throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
          }
          throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
        });
    }

    return Promise.reject(new z.error.UserError(z.userUserError.TYPE.INVALID_UPDATE));
  }

  /**
   * Verify usernames against the backend.
   * @param {Array} usernames - Username suggestions
   * @returns {Promise<string>} A list with usernames that are not taken.
   */
  verify_usernames(usernames) {
    return this.user_service.checkUserHandles(usernames);
  }

  /**
   * Verify a username against the backend.
   * @param {string} username - New user name
   * @returns {string} Username which is not taken.
   */
  verify_username(username) {
    return this.user_service
      .checkUserHandle(username)
      .catch(({code: error_code}) => {
        if (error_code === z.error.BackendClientError.STATUS_CODE.NOT_FOUND) {
          return username;
        }
        if (error_code === z.error.BackendClientError.STATUS_CODE.BAD_REQUEST) {
          throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
        }
        throw new z.error.UserError(z.error.UserError.TYPE.REQUEST_FAILURE);
      })
      .then(verified_username => {
        if (verified_username) {
          return verified_username;
        }
        throw new z.error.UserError(z.error.UserError.TYPE.USERNAME_TAKEN);
      });
  }

  /**
   * Change the profile image.
   * @param {string|Object} picture - New user picture
   * @returns {Promise} Resolves when the picture was updated
   */
  change_picture(picture) {
    return this.asset_service
      .uploadProfileImage(picture)
      .then(({previewImageKey, mediumImageKey}) => {
        const assets = [
          {key: previewImageKey, size: 'preview', type: 'image'},
          {key: mediumImageKey, size: 'complete', type: 'image'},
        ];
        return this.selfService
          .putSelf({assets, picture: []})
          .then(() => this.user_update({user: {assets: assets, id: this.self().id}}));
      })
      .catch(error => {
        throw new Error(`Error during profile image upload: ${error.message || error.code || error}`);
      });
  }

  /**
   * Set users default profile image.
   * @returns {undefined} No return value
   */
  set_default_picture() {
    return z.util.loadUrlBlob(z.config.UNSPLASH_URL).then(blob => this.change_picture(blob));
  }

  mapGuestStatus(userEntities = this.users()) {
    userEntities.forEach(userEntity => {
      if (!userEntity.is_me) {
        const isTeamMember = this.teamMembers().some(teamMember => teamMember.id === userEntity.id);
        const isGuest = !userEntity.isService && !isTeamMember;
        userEntity.isGuest(isGuest);
        userEntity.isTeamMember(isTeamMember);
      }
    });
  }

  getMarketingConsent() {
    if (!window.wire.env.FEATURE.CHECK_CONSENT) {
      this.logger.warn(`Consent check feature is disabled. Defaulting to '${this.marketingConsent()}'`);
      return Promise.resolve();
    }
    return this.selfService
      .getSelfConsent()
      .then(consents => {
        for (const {type: consentType, value: consentValue} of consents) {
          const isMarketingConsent = consentType === z.user.ConsentType.MARKETING;
          if (isMarketingConsent) {
            const hasGivenConsent = consentValue === z.user.ConsentValue.GIVEN;
            this.marketingConsent(hasGivenConsent);
            this.marketingConsent.subscribe(changedConsentValue => this.changeMarketingConsent(changedConsentValue));

            this.logger.log(`Marketing consent retrieved as '${consentValue}'`);
            return;
          }
        }

        this.logger.log(`Marketing consent not set. Defaulting to '${this.marketingConsent()}'`);
      })
      .catch(error => {
        this.logger.warn(`Failed to retrieve marketing consent: ${error.message || error.code}`, error);
      });
  }

  setConsent(consentType, consentValue) {
    return this.selfService.putSelfConsent(consentType, consentValue, `Webapp ${z.util.Environment.version(false)}`);
  }

  changeMarketingConsent(consentGiven) {
    const consentValue = consentGiven ? z.user.ConsentValue.GIVEN : z.user.ConsentValue.NOT_GIVEN;
    return this.setConsent(z.user.ConsentType.MARKETING, consentValue).then(() => {
      this.logger.log(`Marketing consent updated to ${consentValue}`);
      this.marketingConsent(consentGiven);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.user = z.user || {};

(function() {
  const MIN_HANDLE_LENGTH = 2;
  const MAX_HANDLE_LENGTH = 21;

  const RANDOM_WORDS_1 = [
    'acid',
    'agate',
    'agile',
    'amber',
    'aqua',
    'arid',
    'avid',
    'azure',
    'baby',
    'basic',
    'beige',
    'best',
    'black',
    'blond',
    'blue',
    'brass',
    'brave',
    'brown',
    'busy',
    'chief',
    'chill',
    'clear',
    'cold',
    'cool',
    'coral',
    'cosy',
    'cozy',
    'cream',
    'curly',
    'cyan',
    'dear',
    'dry',
    'early',
    'even',
    'fancy',
    'fast',
    'fit',
    'folk',
    'gold',
    'green',
    'grey',
    'happy',
    'hazy',
    'icy',
    'iron',
    'kind',
    'large',
    'lazy',
    'lemon',
    'light',
    'lilac',
    'lime',
    'lord',
    'lucid',
    'mauve',
    'melt',
    'merry',
    'mint',
    'nice',
    'noir',
    'ochre',
    'odd',
    'olive',
    'opal',
    'peach',
    'pearl',
    'pink',
    'plain',
    'purple',
    'quiet',
    'rapid',
    'red',
    'rock',
    'rose',
    'ruby',
    'rust',
    'sand',
    'sassy',
    'shiny',
    'shy',
    'silly',
    'slow',
    'small',
    'stone',
    'sweet',
    'swift',
    'talc',
    'tame',
    'tiny',
    'topaz',
    'torn',
    'total',
    'vinyl',
    'violet',
    'warm',
    'white',
    'wise',
    'witty',
    'yellow',
    'young',
    'zinc',
  ];
  const RANDOM_WORDS_2 = [
    'alligator',
    'alpaca',
    'ant',
    'antelope',
    'asp',
    'badger',
    'bat',
    'bear',
    'bee',
    'beetle',
    'bird',
    'bison',
    'bobcat',
    'buffalo',
    'buzzard',
    'camel',
    'caribou',
    'carp',
    'cat',
    'catfish',
    'cheetah',
    'clam',
    'cobra',
    'cod',
    'condor',
    'cow',
    'coyote',
    'crane',
    'crayfish',
    'cricket',
    'crow',
    'deer',
    'dog',
    'dolphin',
    'donkey',
    'dove',
    'duck',
    'eagle',
    'eel',
    'elk',
    'falcon',
    'ferret',
    'finch',
    'fly',
    'fox',
    'frog',
    'gazelle',
    'giraffe',
    'gnu',
    'goat',
    'goose',
    'gopher',
    'grouse',
    'gull',
    'halibut',
    'hamster',
    'hare',
    'hawk',
    'heron',
    'herring',
    'horse',
    'husky',
    'impala',
    'jackal',
    'jaguar',
    'kangaroo',
    'koala',
    'lemur',
    'lion',
    'lizard',
    'llama',
    'lobster',
    'mackerel',
    'mole',
    'moose',
    'moth',
    'mouse',
    'mule',
    'mussel',
    'newt',
    'octopus',
    'orca',
    'ostrich',
    'otter',
    'owl',
    'ox',
    'oyster',
    'panda',
    'panther',
    'parrot',
    'pelican',
    'penguin',
    'pigeon',
    'pike',
    'pony',
    'quail',
    'rabbit',
    'racoon',
    'ram',
    'raven',
    'salmon',
    'sardine',
    'seal',
    'shark',
    'sheep',
    'sloth',
    'snail',
    'snake',
    'squid',
    'sturgeon',
    'swan',
    'tiger',
    'tilapia',
    'toad',
    'trout',
    'tuna',
    'turkey',
    'turtle',
    'walrus',
    'wapiti',
    'wasp',
    'weasel',
    'whale',
    'wolf',
    'wombat',
    'yak',
    'zebra',
  ];

  /**
   * Create a set of suggestions based on the name.
   * @param {string} name - Name to create suggestions for
   * @returns {Array<string>} Username suggestions
   */
  function create_suggestions(name) {
    const normalized_name = normalize_name(name);
    const random_name = get_random_word_combination();
    let suggestions = [];

    if (normalized_name) {
      suggestions.push(normalized_name);
      const normalized_name_variations = generate_handle_variations(normalized_name);
      suggestions = suggestions.concat(normalized_name_variations);
    }

    suggestions.push(append_random_digits(random_name));
    const random_name_variations = generate_handle_variations(random_name);
    return suggestions.concat(random_name_variations);
  }

  function get_random_word_combination() {
    return `${z.util.ArrayUtil.randomElement(RANDOM_WORDS_1)}${z.util.ArrayUtil.randomElement(RANDOM_WORDS_2)}`;
  }

  /**
   * Creates variations of the given handle by appending random digits.
   * @param {string} handle - Input
   * @param {number} [number_of_variations=5] - Number of variants that should be generated
   * @returns {Array<string>} Handle variations
   */
  function generate_handle_variations(handle, number_of_variations = 5) {
    return _.range(1, number_of_variations + 1).map(value => {
      return append_random_digits(handle.slice(0, MAX_HANDLE_LENGTH - value), value);
    });
  }

  /**
   * Appends random digits from 1 to 9 to the end of the string.
   * @param {string} handle - Input
   * @param {number} additional_numbers - number of digits to append
   * @returns {string} String appended with random digits.
   */
  function append_random_digits(handle, additional_numbers) {
    const random_digits = _.range(additional_numbers).map(() => z.util.NumberUtil.getRandomNumber(1, 8));
    return `${handle}${random_digits.join('')}`;
  }

  /**
   * Creates a handle based on the users name.
   * @param {string} name - User name
   * @returns {string} User handle
   */
  function normalize_name(name) {
    return window
      .getSlug(name)
      .toLowerCase()
      .replace(new RegExp(/[^a-z0-9_]/, 'g'), '')
      .substring(0, MAX_HANDLE_LENGTH);
  }

  /**
   * Validates that a character can be used for a handle.
   * @param {string} character - Character candidate
   * @returns {boolean} True, if character can be used for a handle.
   */
  function validate_character(character) {
    const isAlphaNumeric = /[a-z0-9_]/.test(character);
    const isString = _.isString(character) && character.length === 1;
    return isAlphaNumeric && isString;
  }

  /**
   * Validates that an input is a valid handle.
   * @param {string} handle - Character candidate
   * @returns {boolean} True, if handle is valid.
   */
  function validate_handle(handle = '') {
    if (!handle.length || handle.length < MIN_HANDLE_LENGTH || handle.length > MAX_HANDLE_LENGTH) {
      return false;
    }

    for (const character of handle) {
      if (!validate_character(character)) {
        return false;
      }
    }

    return true;
  }

  z.user.UserHandleGenerator = {
    append_random_digits: append_random_digits,
    create_suggestions: create_suggestions,
    generate_handle_variations: generate_handle_variations,
    normalize_name: normalize_name,
    validate_character: validate_character,
    validate_handle: validate_handle,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ActionsViewModel = class ActionsViewModel {
  constructor(mainViewModel, repositories) {
    this.clientRepository = repositories.client;
    this.connectionRepository = repositories.connection;
    this.conversationRepository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.ListViewModel', z.config.LOGGER.OPTIONS);
  }

  acceptConnectionRequest(userEntity, showConversation) {
    if (userEntity) {
      return this.connectionRepository.acceptRequest(userEntity, showConversation);
    }
  }

  archiveConversation(conversationEntity) {
    if (conversationEntity) {
      return this.conversationRepository.archiveConversation(conversationEntity);
    }
  }

  blockUser(userEntity, hideConversation, nextConversationEntity) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.connectionRepository.blockUser(userEntity, hideConversation, nextConversationEntity),
        text: {
          action: z.l10n.text(z.string.modalUserBlockAction),
          message: z.l10n.text(z.string.modalUserBlockMessage, userEntity.first_name()),
          title: z.l10n.text(z.string.modalUserBlockHeadline, userEntity.first_name()),
        },
      });
    }
  }

  cancelConnectionRequest(userEntity, hideConversation, nextConversationEntity) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.connectionRepository.cancelRequest(userEntity, hideConversation, nextConversationEntity),
        text: {
          action: z.l10n.text(z.string.modalConnectCancelAction),
          message: z.l10n.text(z.string.modalConnectCancelMessage, userEntity.first_name()),
          secondary: z.l10n.text(z.string.modalConnectCancelSecondary),
          title: z.l10n.text(z.string.modalConnectCancelHeadline),
        },
      });
    }
  }

  clearConversation(conversationEntity) {
    if (conversationEntity) {
      const modalType = conversationEntity.isLeavable()
        ? z.viewModel.ModalsViewModel.TYPE.OPTION
        : z.viewModel.ModalsViewModel.TYPE.CONFIRM;

      amplify.publish(z.event.WebApp.WARNING.MODAL, modalType, {
        action: (leaveConversation = false) => {
          this.conversationRepository.clear_conversation(conversationEntity, leaveConversation);
        },
        text: {
          action: z.l10n.text(z.string.modalConversationClearAction),
          message: z.l10n.text(z.string.modalConversationClearMessage),
          option: z.l10n.text(z.string.modalConversationClearOption),
          title: z.l10n.text(z.string.modalConversationClearHeadline),
        },
      });
    }
  }

  deleteClient(clientEntity) {
    // @todo Add failure case ux WEBAPP-3570
    if (this.userRepository.self().isSingleSignOn) {
      // SSO users can remove their clients without the need of entering a password
      return this.clientRepository.deleteClient(clientEntity.id);
    }

    return new Promise((resolve, reject) => {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.INPUT, {
        action: password => {
          this.clientRepository
            .deleteClient(clientEntity.id, password)
            .then(resolve)
            .catch(error => {
              amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
              reject(error);
            });
        },
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalAccountRemoveDeviceAction),
          input: z.l10n.text(z.string.modalAccountRemoveDevicePlaceholder),
          message: z.l10n.text(z.string.modalAccountRemoveDeviceMessage),
          title: z.l10n.text(z.string.modalAccountRemoveDeviceHeadline, clientEntity.model),
        },
        warning: false,
      });
    });
  }

  deleteMessage(conversationEntity, messageEntity) {
    if (conversationEntity && messageEntity) {
      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.deleteMessage(conversationEntity, messageEntity);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationDeleteMessageAction),
            message: z.l10n.text(z.string.modalConversationDeleteMessageMessage),
            title: z.l10n.text(z.string.modalConversationDeleteMessageHeadline),
          },
        });
      });
    }
  }

  deleteMessageEveryone(conversationEntity, messageEntity) {
    if (conversationEntity && messageEntity) {
      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.deleteMessageForEveryone(conversationEntity, messageEntity);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneAction),
            message: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneMessage),
            title: z.l10n.text(z.string.modalConversationDeleteMessageEveryoneHeadline),
          },
        });
      });
    }
  }

  ignoreConnectionRequest(userEntity) {
    if (userEntity) {
      return this.connectionRepository.ignoreRequest(userEntity);
    }
  }

  leaveConversation(conversationEntity) {
    if (conversationEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => this.conversationRepository.removeMember(conversationEntity, this.userRepository.self().id),
        text: {
          action: z.l10n.text(z.string.modalConversationLeaveAction),
          message: z.l10n.text(z.string.modalConversationLeaveMessage),
          title: z.l10n.text(z.string.modalConversationLeaveHeadline, conversationEntity.display_name()),
        },
      });
    }
  }

  open1to1Conversation(userEntity) {
    if (userEntity) {
      return this.conversationRepository
        .get1To1Conversation(userEntity)
        .then(conversationEntity => this._openConversation(conversationEntity));
    }
  }

  open1to1ConversationWithService(serviceEntity) {
    if (serviceEntity) {
      return this.integrationRepository
        .get1To1ConversationWithService(serviceEntity)
        .then(conversationEntity => this._openConversation(conversationEntity));
    }
  }

  openGroupConversation(conversationEntity) {
    if (conversationEntity) {
      return Promise.resolve().then(() => this._openConversation(conversationEntity));
    }
  }

  _openConversation(conversationEntity) {
    if (conversationEntity) {
      if (conversationEntity.is_archived()) {
        this.conversationRepository.unarchiveConversation(conversationEntity, true);
      }

      if (conversationEntity.is_cleared()) {
        conversationEntity.cleared_timestamp(0);
      }

      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
    }
  }

  removeFromConversation(conversationEntity, userEntity) {
    if (conversationEntity && userEntity) {
      if (userEntity.isService) {
        return this.integrationRepository.removeService(conversationEntity, userEntity);
      }

      return new Promise(resolve => {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
          action: () => {
            this.conversationRepository.removeMember(conversationEntity, userEntity.id);
            resolve();
          },
          text: {
            action: z.l10n.text(z.string.modalConversationRemoveAction),
            message: z.l10n.text(z.string.modalConversationRemoveMessage, userEntity.first_name()),
            title: z.l10n.text(z.string.modalConversationRemoveHeadline),
          },
        });
      });
    }
  }

  sendConnectionRequest(userEntity, showConversation) {
    if (userEntity) {
      return this.connectionRepository.createConnection(userEntity, showConversation);
    }
  }

  toggleMuteConversation(conversationEntity) {
    if (conversationEntity) {
      const notificationState = conversationEntity.showNotificationsEverything()
        ? z.conversation.NotificationSetting.STATE.NOTHING
        : z.conversation.NotificationSetting.STATE.EVERYTHING;
      this.conversationRepository.setNotificationState(conversationEntity, notificationState);
    }
  }

  unblockUser(userEntity, showConversation) {
    if (userEntity) {
      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => {
          this.connectionRepository
            .unblockUser(userEntity, showConversation)
            .then(() => this.conversationRepository.get1To1Conversation(userEntity))
            .then(conversationEntity => {
              return this.conversationRepository.updateParticipatingUserEntities(conversationEntity);
            });
        },
        text: {
          action: z.l10n.text(z.string.modalUserUnblockAction),
          message: z.l10n.text(z.string.modalUserUnblockMessage, userEntity.first_name()),
          title: z.l10n.text(z.string.modalUserUnblockHeadline),
        },
      });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

/**
 * The FaviconViewModel is responsible for updating the favicon according to unread messages.
 * To do so, it will listen for the UNREAD_COUNT that the app dispatches through the given dispatcher.
 */
z.viewModel.FaviconViewModel = class FaviconViewModel {
  /**
   * Construct a new FaviconViewModel.
   *
   * @param {Dispatcher} dispatcher - event dispatcher
   */
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this.unreadCount = ko.observable(0);

    this.unreadCountSubscription = this.unreadCount.subscribe(this._updateFavicon.bind(this));
    this.dispatcher.subscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, this, this._updateUnreadCount);
  }

  _updateUnreadCount(unreadCount) {
    this.unreadCount(unreadCount);
  }

  _updateFavicon(unreadCount) {
    const iconBadge = unreadCount ? '-badge' : '';
    const link = document.querySelector("link[rel*='shortcut icon']") || document.createElement('link');
    link.type = 'image/x-icon';
    link.rel = 'shortcut icon';
    link.href = `/image/favicon${iconBadge}.ico`;
    document.getElementsByTagName('head')[0].appendChild(link);
  }

  dispose() {
    this.dispatcher.unsubscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, this, this._updateUnreadCount);
    this.unreadCountSubscription.dispose();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ImageDetailViewViewModel = class ImageDetailViewViewModel {
  constructor(mainViewModel, repositories) {
    this.beforeHideCallback = this.beforeHideCallback.bind(this);
    this.hideCallback = this.hideCallback.bind(this);
    this.messageAdded = this.messageAdded.bind(this);
    this.messageExpired = this.messageExpired.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);

    this.elementId = 'detail-view';
    this.mainViewModel = mainViewModel;
    this.conversationRepository = repositories.conversation;

    this.actionsViewModel = this.mainViewModel.actions;
    this.source = undefined;

    this.imageModal = undefined;
    this.imageSrc = ko.observable();
    this.imageVisible = ko.observable(false);

    this.conversationEntity = ko.observable();
    this.items = ko.observableArray();
    this.messageEntity = ko.observable();
    this.messageEntity.subscribe(messageEntity => {
      if (messageEntity) {
        const conversationId = messageEntity.conversation_id;
        const isExpectedId = this.conversationEntity() ? conversationId === this.conversationEntity().id : false;
        if (!isExpectedId) {
          this.conversationRepository
            .get_conversation_by_id(conversationId)
            .then(conversationEntity => this.conversationEntity(conversationEntity));
        }
      }
    });

    amplify.subscribe(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, this.show.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  beforeHideCallback() {
    this.imageVisible(false);
  }

  hideCallback() {
    $(document).off('keydown.lightbox');
    window.URL.revokeObjectURL(this.imageSrc());

    this.imageSrc(undefined);
    this.items.removeAll();
    this.messageEntity(undefined);
    this.source = undefined;

    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageExpired);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.messageAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.messageRemoved);
  }

  show(messageEntity, messageEntities, source) {
    this.items(messageEntities);
    this.messageEntity(messageEntity);
    this.source = source;

    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageExpired);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.messageAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.messageRemoved);

    if (!this.imageModal) {
      this.imageModal = new z.ui.Modal('#detail-view', this.hideCallback, this.beforeHideCallback);
    }

    this.imageModal.show();

    this._loadImage();
    $(document).on('keydown.lightbox', keyboardEvent => {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ESC: {
          this.clickOnClose();
          break;
        }

        case z.util.KeyboardUtil.KEY.ARROW_DOWN:
        case z.util.KeyboardUtil.KEY.ARROW_RIGHT: {
          this.clickOnShowNext(this, keyboardEvent);
          break;
        }

        case z.util.KeyboardUtil.KEY.ARROW_LEFT:
        case z.util.KeyboardUtil.KEY.ARROW_UP: {
          this.clickOnShowPrevious(this, keyboardEvent);
          break;
        }

        default:
          break;
      }
    });
  }

  messageAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation;
    if (isCurrentConversation) {
      this.items.push(messageEntity);
    }
  }

  messageExpired(messageEntity) {
    this.messageRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  messageRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      const isVisibleMessage = this.messageEntity().id === messageId;
      if (isVisibleMessage) {
        return this.imageModal.hide();
      }

      this.items.remove(messageEntity => messageEntity.id === messageId);
    }
  }

  _loadImage() {
    this.imageVisible(false);
    this.messageEntity()
      .get_first_asset()
      .resource()
      .load()
      .then(blob => {
        if (blob) {
          this.imageSrc(window.URL.createObjectURL(blob));
          this.imageVisible(true);
        }
      });
  }

  clickOnClose() {
    this.imageModal.hide();
  }

  clickOnDownload() {
    this.messageEntity().download();
  }

  clickOnLike() {
    this.conversationRepository.toggle_like(this.conversationEntity(), this.messageEntity());
  }

  clickOnReply() {
    amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, this.messageEntity());
    this.imageModal.hide();
  }

  clickOnShowNext(imageDetailViewViewModel, event) {
    event.stopPropagation();
    this._iterateImage(true);
  }

  clickOnShowPrevious(imageDetailViewViewModel, event) {
    event.stopPropagation();
    this._iterateImage(false);
  }

  _iterateImage(reverse) {
    const messageEntity = z.util.ArrayUtil.iterateItem(this.items(), this.messageEntity(), reverse);

    if (messageEntity) {
      this.messageEntity(messageEntity);
      this._loadImage();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.LoadingViewModel = class LoadingViewModel {
  constructor(mainViewModel, repositories) {
    this.elementId = 'loading-screen';
    this.userRepository = repositories.user;
    this.loadingMessage = ko.observable('');
    this.loadingProgress = ko.observable(0);
    amplify.subscribe(z.event.WebApp.APP.UPDATE_PROGRESS, this.updateProgress.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  removeFromView() {
    $(`#${this.elementId}`).remove();
    amplify.unsubscribeAll(z.event.WebApp.APP.UPDATE_PROGRESS);
  }

  updateProgress(progress = 0, messageLocator, replaceContent) {
    const hasProgressIncreased = progress > this.loadingProgress();
    progress = hasProgressIncreased ? progress : this.loadingProgress() + 0.01;
    this.loadingProgress(progress);

    if (messageLocator) {
      let updatedLoadingMessage;

      switch (messageLocator) {
        case z.string.initReceivedSelfUser: {
          updatedLoadingMessage = z.l10n.text(messageLocator, this.userRepository.self().first_name());
          break;
        }

        case z.string.initDecryption:
        case z.string.initEvents: {
          if (z.util.Environment.frontend.isProduction()) {
            updatedLoadingMessage = z.l10n.text(messageLocator);
            break;
          }

          const substitutes = {
            number1: replaceContent.handled,
            number2: replaceContent.total,
          };

          const handlingProgress = z.l10n.text(z.string.initProgress, substitutes);
          updatedLoadingMessage = `${z.l10n.text(messageLocator)}${handlingProgress}`;
          break;
        }

        default:
          updatedLoadingMessage = z.l10n.text(messageLocator);
      }

      this.loadingMessage(updatedLoadingMessage);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.MainViewModel = class MainViewModel {
  static get CONFIG() {
    return {
      PANEL: {
        BREAKPOINT: 1000,
        WIDTH: 304,
      },
    };
  }

  static get PANEL_STATE() {
    return {
      CLOSED: 'MainViewModel.PANEL_STATE.CLOSED',
      OPEN: 'MainViewModel.PANEL_STATE.OPEN',
    };
  }

  static get PANEL_STYLE() {
    return {
      CLOSED: {
        position: 'absolute',
        right: '0',
        transform: `translateX(${MainViewModel.CONFIG.PANEL.WIDTH}px)`,
        width: `${MainViewModel.CONFIG.PANEL.WIDTH}px`,
      },
      OPEN: {
        position: 'absolute',
        right: '0',
        transform: `translateX(0px)`,
        width: `${MainViewModel.CONFIG.PANEL.WIDTH}px`,
      },
    };
  }

  constructor(repositories) {
    this.closePanel = this.closePanel.bind(this);
    this.closePanelImmediatly = this.closePanelImmediatly.bind(this);
    this.closePanelOnClick = this.closePanelOnClick.bind(this);
    this.openPanel = this.openPanel.bind(this);
    this.togglePanel = this.togglePanel.bind(this);

    this.elementId = 'wire-main';
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.MainViewModel', z.config.LOGGER.OPTIONS);

    this.selfUser = this.userRepository.self;

    this.isPanelOpen = ko.observable(false);

    this.actions = new z.viewModel.ActionsViewModel(this, repositories);

    this.panel = new z.viewModel.PanelViewModel(this, repositories);
    this.content = new z.viewModel.ContentViewModel(this, repositories);
    this.list = new z.viewModel.ListViewModel(this, repositories);

    this.modals = new z.viewModel.ModalsViewModel();
    this.lightbox = new z.viewModel.ImageDetailViewViewModel(this, repositories);
    this.loading = new z.viewModel.LoadingViewModel(this, repositories);
    this.shortcuts = new z.viewModel.ShortcutsViewModel(this, repositories);
    this.title = new z.viewModel.WindowTitleViewModel(this, repositories);
    this.favicon = new z.viewModel.FaviconViewModel(window.amplify);
    this.videoCalling = new z.viewModel.VideoCallingViewModel(this, repositories);
    this.warnings = new z.viewModel.WarningsViewModel();

    this.mainClasses = ko.pureComputed(() => {
      if (this.selfUser()) {
        // deprecated - still used on input control hover
        return `main-accent-color-${this.selfUser().accent_id()} ${this.selfUser().accent_theme()} show`;
      }
    });

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  openPanel() {
    return this.togglePanel(MainViewModel.PANEL_STATE.OPEN);
  }

  closePanel() {
    return this.togglePanel(MainViewModel.PANEL_STATE.CLOSED);
  }

  closePanelImmediatly() {
    document.querySelector('.center-column__overlay').removeEventListener('click', this.togglePanel);
    document.querySelector('#app').classList.remove('app--panel-open');
    this.isPanelOpen(false);
  }

  togglePanel(forceState) {
    const app = document.querySelector('#app');
    const panel = document.querySelector('.right-column');

    const isPanelOpen = app.classList.contains('app--panel-open');
    const isAlreadyClosed = forceState === MainViewModel.PANEL_STATE.CLOSED && !isPanelOpen;
    const isAlreadyOpen = forceState === MainViewModel.PANEL_STATE.OPEN && isPanelOpen;

    const isInForcedState = isAlreadyClosed || isAlreadyOpen;
    if (isInForcedState) {
      return Promise.resolve();
    }

    const titleBar = document.querySelector('#conversation-title-bar');
    const input = document.querySelector('#conversation-input-bar');

    const isNarrowScreen = app.offsetWidth < MainViewModel.CONFIG.PANEL.BREAKPOINT;

    const centerWidthClose = app.offsetWidth - MainViewModel.CONFIG.PANEL.WIDTH;
    const centerWidthOpen = centerWidthClose - MainViewModel.CONFIG.PANEL.WIDTH;

    return new Promise(resolve => {
      const transitionEndHandler = event => {
        if (event.target === panel) {
          panel.removeEventListener('transitionend', transitionEndHandler);
          this._clearStyles(panel, ['width', 'transform', 'position', 'right', 'transition']);
          this._clearStyles(titleBar, ['width', 'transition']);
          this._clearStyles(input, ['width', 'transition']);

          const overlay = document.querySelector('.center-column__overlay');
          if (isPanelOpen) {
            app.classList.remove('app--panel-open');
            this.isPanelOpen(false);
            overlay.removeEventListener('click', this.closePanelOnClick);
          } else {
            app.classList.add('app--panel-open');
            this.isPanelOpen(true);
            overlay.addEventListener('click', this.closePanelOnClick);
          }

          if (!isNarrowScreen) {
            // In case we are not on a narrow screen, opening a panel will resize a bunch of elements
            // we need to warn them by triggering a window resize event.
            // When the screen is narrow, the panel just goes on top, no elements are resized
            window.dispatchEvent(new Event('resize'));
          }

          resolve();
        }
      };

      panel.addEventListener('transitionend', transitionEndHandler);

      if (isPanelOpen) {
        this._applyStyle(panel, MainViewModel.PANEL_STYLE.OPEN);
        if (!isNarrowScreen) {
          this._applyStyle(titleBar, {width: `${centerWidthOpen}px`});
          this._applyStyle(input, {width: `${centerWidthOpen}px`});
        }
      } else {
        this._applyStyle(panel, MainViewModel.PANEL_STYLE.CLOSED);
        if (!isNarrowScreen) {
          this._applyStyle(titleBar, {width: `${centerWidthClose}px`});
          this._applyStyle(input, {width: `${centerWidthClose}px`});
        }
      }

      z.util.afterRender(() => {
        const widthTransition = 'width .35s cubic-bezier(0.19, 1, 0.22, 1)';
        this._applyStyle(panel, {transition: 'transform .35s cubic-bezier(0.19, 1, 0.22, 1)'});
        this._applyStyle(titleBar, {transition: widthTransition});
        this._applyStyle(input, {transition: widthTransition});

        if (isPanelOpen) {
          this._applyStyle(panel, MainViewModel.PANEL_STYLE.CLOSED);
          if (!isNarrowScreen) {
            this._applyStyle(titleBar, {width: `${centerWidthClose}px`});
            this._applyStyle(input, {width: `${centerWidthClose}px`});
          }
        } else {
          this._applyStyle(panel, MainViewModel.PANEL_STYLE.OPEN);
          if (!isNarrowScreen) {
            this._applyStyle(titleBar, {width: `${centerWidthOpen}px`});
            this._applyStyle(input, {width: `${centerWidthOpen}px`});
          }
        }
      });
    });
  }

  _applyStyle(element, style) {
    if (element) {
      Object.entries(style).forEach(([key, styleValue]) => (element.style[key] = styleValue));
    }
  }

  _clearStyles(element, styles) {
    if (element) {
      styles.forEach(key => (element.style[key] = ''));
    }
  }

  closePanelOnClick() {
    this.panel.closePanel();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ModalsViewModel = class ModalsViewModel {
  static get TYPE() {
    return {
      ACCOUNT_NEW_DEVICES: '.modal-account-new-devices',
      ACKNOWLEDGE: '.modal-template-acknowledge',
      CONFIRM: '.modal-template-confirm',
      INPUT: '.modal-template-input',
      OPTION: '.modal-template-option',
      SESSION_RESET: '.modal-session-reset',
    };
  }

  constructor() {
    this.logger = new z.util.Logger('z.viewModel.ModalsViewModel', z.config.LOGGER.OPTIONS);
    this.elementId = 'modals';

    this.modals = {};

    amplify.subscribe(z.event.WebApp.WARNING.MODAL, this.showModal.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Show modal
   *
   * @param {ModalsViewModel.TYPE} type - Indicates which modal to show
   * @param {Object} [options={}] - Information to configure modal
   * @param {Object} options.data - Content needed for visualization on modal
   * @param {Function} options.action - Called when action in modal is triggered
   * @param {boolean} [options.preventClose] - Set to true to disable autoclose behavior
   * @param {Function} options.secondary - Called when secondary action in modal is triggered
   * @returns {undefined} No return value
   */
  showModal(type, options = {}) {
    const actionElement = $(type).find('.modal-action');
    const messageElement = $(type).find('.modal-text');
    const titleElement = $(type).find('.modal-title');

    switch (type) {
      case ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES:
        this._showModalAccountNewDevices(options.data);
        break;
      case ModalsViewModel.TYPE.ACKNOWLEDGE:
        this._showModalAcknowledge(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.CONFIRM:
        this._showModalConfirm(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.INPUT:
        this._showModalInput(options, titleElement, messageElement, actionElement);
        break;
      case ModalsViewModel.TYPE.OPTION:
        this._showModalOption(options, titleElement, messageElement, actionElement);
        break;
      default:
        this.logger.warn(`Modal of type '${type}' is not supported`);
    }

    const {preventClose = false, action: actionFn, close: closeFn, secondary: secondaryFn} = options;
    const modal = new z.ui.Modal(type, null, () => {
      $(type)
        .find('.modal-close')
        .off('click');

      $(type)
        .find('.modal-action')
        .off('click');

      $(type)
        .find('.modal-secondary')
        .off('click');

      modal.destroy();

      if (typeof closeFn === 'function') {
        closeFn();
      }
    });

    $(type)
      .find('.modal-close')
      .click(() => modal.hide());

    $(type)
      .find('.modal-secondary')
      .click(() => {
        modal.hide(() => {
          if (typeof secondaryFn === 'function') {
            secondaryFn();
          }
        });
      });

    $(type)
      .find('.modal-action')
      .click(() => {
        if (typeof actionFn === 'function') {
          const checkbox = $(type).find('.modal-checkbox');
          const input = $(type).find('.modal-input');

          let parameter;
          if (checkbox.length) {
            parameter = checkbox.is(':checked');
            checkbox.prop('checked', false);
          } else if (input.length) {
            parameter = input.val();
            input.val('');
          }

          actionFn(parameter);
        }

        modal.hide();
      });

    if (!modal.isShown()) {
      this.logger.info(`Show modal of type '${type}'`);
    }

    modal.setAutoclose(!preventClose);
    modal.toggle();
  }

  _showModalAcknowledge(options, titleElement, messageElement, actionElement) {
    const {action: actionText, htmlMessage, message: messageText, title: titleText} = options.text;

    actionElement.text(actionText || z.l10n.text(z.string.modalAcknowledgeAction));
    if (htmlMessage) {
      messageElement.html(htmlMessage);
    } else {
      messageElement.text(messageText || '');
    }
    titleElement.text(titleText || z.l10n.text(z.string.modalAcknowledgeHeadline));

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalConfirm(options, titleElement, messageElement, actionElement) {
    const secondaryElement = $(ModalsViewModel.TYPE.CONFIRM).find('.modal-secondary');
    const {action: actionText, message: messageText, secondary, title: titleText} = options.text;

    const secondaryText = secondary || z.l10n.text(z.string.modalConfirmSecondary);

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    secondaryElement.text(secondaryText);
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalAccountNewDevices(devices) {
    const devicesElement = $(ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES).find('.modal-new-devices-list');

    devicesElement.empty();

    devices.map(device => {
      $('<div>')
        .text(`${moment(device.time).format('MMMM Do YYYY, HH:mm')} - UTC`)
        .appendTo(devicesElement);

      $('<div>')
        .text(`${z.l10n.text(z.string.modalAccountNewDevicesFrom)} ${device.model}`)
        .appendTo(devicesElement);
    });
  }

  _showModalOption(options, titleElement, messageElement, actionElement) {
    const secondaryElement = $(ModalsViewModel.TYPE.OPTION).find('.modal-secondary');
    const optionElement = $(ModalsViewModel.TYPE.OPTION).find('.modal-option-text');
    const {action: actionText, message: messageText, option: optionText, secondary, title: titleText} = options.text;

    const secondaryText = secondary || z.l10n.text(z.string.modalOptionSecondary);

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    optionElement.text(optionText || '');
    secondaryElement.text(secondaryText);
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }

  _showModalInput(options, titleElement, messageElement, actionElement) {
    const inputElement = $(ModalsViewModel.TYPE.INPUT).find('.modal-input');
    const {action: actionText, input: inputText, message: messageText, title: titleText} = options.text;

    actionElement.text(actionText || '');
    messageElement.text(messageText || '');
    inputElement.attr('placeholder', inputText || '');
    titleElement.text(titleText || '');

    if (options.warning !== false) {
      amplify.publish(z.event.WebApp.AUDIO.PLAY, z.audio.AudioType.ALERT);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ShortcutsViewModel = class ShortcutsViewModel {
  constructor(mainViewModel, repositories) {
    this.onMuteCall = this.onMuteCall.bind(this);
    this.onRejectCall = this.onRejectCall.bind(this);

    this.callingRepository = repositories.calling;
    this.logger = new z.util.Logger('z.viewModel.ShortcutsViewModel', z.config.LOGGER.OPTIONS);

    this.joinedCall = this.callingRepository.joinedCall;
    this.joinedCall.subscribe(callEntity => this._updateShortcutSubscription(callEntity));
  }

  _updateShortcutSubscription(callEntity) {
    this._unsubscribeShortcuts();

    if (callEntity) {
      switch (callEntity.state()) {
        case z.calling.enum.CALL_STATE.ONGOING:
        case z.calling.enum.CALL_STATE.OUTGOING:
          this._subscribeOutgoingOrOngoingCall();
          break;
        case z.calling.enum.CALL_STATE.INCOMING:
          this._subscribeIncomingCall();
          break;
        default:
          break;
      }
    }
  }

  _subscribeIncomingCall() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.CALL_REJECT, this.onRejectCall);
  }

  _subscribeOutgoingOrOngoingCall() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.CALL_MUTE, this.onMuteCall);
  }

  _unsubscribeShortcuts() {
    amplify.unsubscribe(z.event.WebApp.SHORTCUT.CALL_MUTE, this.onMuteCall);
    amplify.unsubscribe(z.event.WebApp.SHORTCUT.CALL_REJECT, this.onRejectCall);
  }

  onMuteCall() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.AUDIO);
    }
  }

  onRejectCall() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.STATE.REJECT, this.joinedCall().id);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.WarningsViewModel = class WarningsViewModel {
  static get CONFIG() {
    return {
      DIMMED_MODES: [
        WarningsViewModel.TYPE.REQUEST_CAMERA,
        WarningsViewModel.TYPE.REQUEST_MICROPHONE,
        WarningsViewModel.TYPE.REQUEST_NOTIFICATION,
        WarningsViewModel.TYPE.REQUEST_SCREEN,
      ],
      MINI_MODES: [
        WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT,
        WarningsViewModel.TYPE.LIFECYCLE_UPDATE,
        WarningsViewModel.TYPE.NO_INTERNET,
      ],
    };
  }

  static get TYPE() {
    return {
      CONNECTIVITY_RECONNECT: 'connectivity_reconnect',
      CONNECTIVITY_RECOVERY: 'connectivity_recovery',
      DENIED_CAMERA: 'camera_access_denied',
      DENIED_MICROPHONE: 'mic_access_denied',
      DENIED_SCREEN: 'screen_access_denied',
      LIFECYCLE_UPDATE: 'lifecycle_update',
      NO_INTERNET: 'no_internet',
      NOT_FOUND_CAMERA: 'not_found_camera',
      NOT_FOUND_MICROPHONE: 'not_found_microphone',
      REQUEST_CAMERA: 'request_camera',
      REQUEST_MICROPHONE: 'request_microphone',
      REQUEST_NOTIFICATION: 'request_notification',
      REQUEST_SCREEN: 'request_screen',
      UNSUPPORTED_INCOMING_CALL: 'unsupported_incoming_call',
      UNSUPPORTED_OUTGOING_CALL: 'unsupported_outgoing_call',
    };
  }

  constructor() {
    this.elementId = 'warnings';
    this.logger = new z.util.Logger('z.viewModel.WarningsViewModel', z.config.LOGGER.OPTIONS);

    // Array of warning banners
    this.warnings = ko.observableArray();
    this.visibleWarning = ko.pureComputed(() => this.warnings()[this.warnings().length - 1]);

    this.warnings.subscribe(warnings => {
      let topMargin;

      const visibleWarning = warnings[warnings.length - 1];
      const isConnectivityRecovery = visibleWarning === WarningsViewModel.TYPE.CONNECTIVITY_RECOVERY;
      const noMargin = !warnings.length || isConnectivityRecovery;
      if (noMargin) {
        topMargin = '0';
      } else {
        const isMiniMode = WarningsViewModel.CONFIG.MINI_MODES.includes(visibleWarning);
        topMargin = isMiniMode ? '32px' : '64px';
      }

      $('#app').css({top: topMargin});
      window.requestAnimationFrame(() => $(window).trigger('resize'));
    });

    this.name = ko.observable();

    this.warningDimmed = ko
      .pureComputed(() => {
        for (const warning of this.warnings()) {
          const isDimmedMode = WarningsViewModel.CONFIG.DIMMED_MODES.includes(warning);
          if (isDimmedMode) {
            return true;
          }
        }
        return false;
      })
      .extend({rateLimit: 200});

    amplify.subscribe(z.event.WebApp.WARNING.SHOW, this.showWarning.bind(this));
    amplify.subscribe(z.event.WebApp.WARNING.DISMISS, this.dismissWarning.bind(this));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Close warning.
   * @note Used to close a warning banner by clicking the close button
   * @returns {undefined} No return value
   */
  closeWarning() {
    const warningToClose = this.visibleWarning();
    this.dismissWarning(warningToClose);

    switch (warningToClose) {
      case WarningsViewModel.TYPE.REQUEST_MICROPHONE: {
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
          action: () => {
            const url = z.util.URLUtil.buildSupportUrl(z.config.SUPPORT.ID.MICROPHONE_ACCESS_DENIED);
            z.util.SanitizationUtil.safeWindowOpen(url);
          },
          text: {
            action: z.l10n.text(z.string.modalCallNoMicrophoneAction),
            message: z.l10n.text(z.string.modalCallNoMicrophoneMessage),
            title: z.l10n.text(z.string.modalCallNoMicrophoneHeadline),
          },
        });
        break;
      }

      case WarningsViewModel.TYPE.REQUEST_NOTIFICATION: {
        // We block subsequent permission requests for notifications when the user ignores the request.
        amplify.publish(z.event.WebApp.NOTIFICATION.PERMISSION_STATE, z.notification.PermissionState.IGNORED);
        break;
      }

      default:
        break;
    }
  }

  dismissWarning(type = this.visibleWarning()) {
    const dismissedWarnings = this.warnings.remove(type);
    if (dismissedWarnings.length) {
      this.logger.info(`Dismissed warning of type '${type}'`);
    }
  }

  showWarning(type, info) {
    const connectivityTypes = [WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT, WarningsViewModel.TYPE.NO_INTERNET];
    const isConnectivityWarning = connectivityTypes.includes(type);
    const visibleWarningIsLifecycleUpdate = this.visibleWarning() === WarningsViewModel.TYPE.LIFECYCLE_UPDATE;
    if (isConnectivityWarning && !visibleWarningIsLifecycleUpdate) {
      this.dismissWarning(this.visibleWarning());
    }

    this.logger.warn(`Showing warning of type '${type}'`);
    if (info) {
      this.name(info.name);
    }
    this.warnings.push(type);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.VideoCallingViewModel = class VideoCallingViewModel {
  static get CONFIG() {
    return {
      AUTO_MINIMIZE_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 4,
      HIDE_CONTROLS_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 4,
    };
  }

  constructor(mainViewModel, repositories) {
    this.clickedOnCancelScreen = this.clickedOnCancelScreen.bind(this);
    this.clickedOnChooseScreen = this.clickedOnChooseScreen.bind(this);
    this.chooseSharedScreen = this.chooseSharedScreen.bind(this);

    this.elementId = 'video-calling';

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.mediaRepository = repositories.media;
    this.userRepository = repositories.user;
    this.videoGridRepository = repositories.videoGrid;

    this.contentViewModel = mainViewModel.content;
    this.multitasking = this.contentViewModel.multitasking;
    this.logger = new z.util.Logger('z.viewModel.VideoCallingViewModel', z.config.LOGGER.OPTIONS);

    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.streamHandler = this.mediaRepository.streamHandler;

    this.availableDevices = this.devicesHandler.availableDevices;
    this.currentDeviceId = this.devicesHandler.currentDeviceId;
    this.currentDeviceIndex = this.devicesHandler.currentDeviceIndex;

    this.hasSelfVideo = this.streamHandler.hasActiveVideo;
    this.selfStreamState = this.streamHandler.selfStreamState;
    this.localVideoStream = this.streamHandler.localMediaStream;
    this.remoteVideoStreamsInfo = this.streamHandler.remoteMediaStreamInfoIndex.video;

    this.isChoosingScreen = ko.observable(false);

    this.minimizeTimeout = undefined;

    this.calls = this.callingRepository.calls;
    this.joinedCall = this.callingRepository.joinedCall;

    this.videodCall = ko.pureComputed(() => {
      for (const callEntity of this.calls()) {
        const selfScreenSend = callEntity.selfClientJoined() && this.selfStreamState.screenSend();
        const selfVideoSend = selfScreenSend || this.selfStreamState.videoSend();
        const remoteVideoSend = callEntity.isRemoteVideoCall() && !callEntity.isOngoingOnAnotherClient();
        const isVideoCall = selfVideoSend || remoteVideoSend || this.isChoosingScreen();

        if (callEntity.isActiveState() && isVideoCall) {
          return callEntity;
        }
      }
    });

    this.isCallOngoing = ko.pureComputed(() => {
      if (this.joinedCall()) {
        const isSendingVideo = this.localVideoStream() && this.hasSelfVideo();
        const isVideoCall = isSendingVideo || this.joinedCall().isRemoteVideoCall();
        return this.joinedCall().isOngoing() && isVideoCall;
      }
    });

    this.showFullscreen = ko.pureComputed(() => {
      const isFullScreenState = this.isCallOngoing() || this.isChoosingScreen();
      return isFullScreenState && !this.multitasking.isMinimized() && !!this.videodCall();
    });

    this.remoteUser = ko.pureComputed(() => {
      const [participantEntity] = this.joinedCall() ? this.joinedCall().participants() : [];

      if (participantEntity) {
        return participantEntity.user;
      }
    });

    this.showRemoteParticipant = ko.pureComputed(() => {
      const showRemoteParticipant = this.remoteUser() && !this.multitasking.isMinimized() && !this.isChoosingScreen();
      return showRemoteParticipant && this.isCallOngoing() && !this.showRemoteVideo();
    });

    this.showRemoteVideo = ko.pureComputed(() => {
      if (this.isCallOngoing()) {
        const remoteVideoState = this.joinedCall() && this.joinedCall().isRemoteVideoCall();
        return remoteVideoState && this.remoteVideoStreamsInfo().length;
      }
    });

    this.showSwitchCamera = ko.pureComputed(() => {
      const hasMultipleCameras = this.availableDevices.videoInput().length > 1;
      const isVisible = hasMultipleCameras && this.localVideoStream() && this.selfStreamState.videoSend();
      return this.isCallOngoing() && isVisible;
    });
    this.showSwitchScreen = ko.pureComputed(() => {
      const hasMultipleScreens = this.availableDevices.screenInput().length > 1;
      const isVisible = hasMultipleScreens && this.localVideoStream() && this.selfStreamState.screenSend();
      return this.isCallOngoing() && isVisible;
    });

    this.showControls = ko.pureComputed(() => {
      const isFullscreenEnabled = this.showRemoteParticipant() && !this.multitasking.isMinimized();
      const isVisible = this.showRemoteVideo() || isFullscreenEnabled;
      return this.isCallOngoing() && isVisible;
    });
    this.showToggleVideo = ko.pureComputed(() => {
      return this.joinedCall() ? this.joinedCall().conversationEntity.supportsVideoCall(false) : false;
    });
    this.disableToggleScreen = ko.pureComputed(() => !z.calling.CallingRepository.supportsScreenSharing);

    this.visibleCallId = undefined;
    this.joinedCall.subscribe(callEntity => {
      if (callEntity) {
        const isVisibleId = this.visibleCallId === callEntity.id;
        if (!isVisibleId) {
          this.visibleCallId = callEntity.id;

          // FIXME find a better condition to actually minimize/maximize the call
          // we should do this when we check that everything is alright with audio calls also
          if (this.showRemoteVideo()) {
            this.multitasking.isMinimized(false);
            return this.logger.info(`Maximizing video call '${callEntity.id}' to full-screen`, callEntity);
          }

          //this.multitasking.isMinimized(true);
          this.logger.info(`Minimizing audio call '${callEntity.id}' from full-screen`, callEntity);
        }
      } else {
        this.visibleCallId = undefined;
        this.multitasking.autoMinimize(true);
        this.multitasking.isMinimized(false);
        this.logger.info('Resetting full-screen calling to maximize');
      }
    });

    this.showRemoteParticipant.subscribe(showRemoteParticipant => {
      if (this.minimizeTimeout) {
        window.clearTimeout(this.minimizeTimeout);
        this.minimizeTimeout = undefined;
      }

      const isVideoCall = showRemoteParticipant && this.videodCall();
      const shouldAutoMinimize = isVideoCall && this.multitasking.autoMinimize() && !this.isChoosingScreen();
      if (shouldAutoMinimize) {
        const remoteUserName = this.remoteUser() ? this.remoteUser().name() : '';

        const callId = this.videodCall().id;
        const logMessage = `Scheduled minimizing call '${callId}' as remote user '${remoteUserName}' is not videod`;
        this.logger.info(logMessage);
        this.minimizeTimeout = window.setTimeout(() => {
          if (!this.isChoosingScreen()) {
            this.multitasking.isMinimized(true);
          }
          const message = `Minimizing call '${callId}' on timeout as remote user '${remoteUserName}' is not videod`;
          this.logger.info(message);
        }, VideoCallingViewModel.CONFIG.AUTO_MINIMIZE_TIMEOUT);
      }
    });

    this.hasUnreadMessages = ko.observable(false);

    amplify.subscribe(z.event.WebApp.CALL.MEDIA.CHOOSE_SCREEN, this.chooseSharedScreen);
    amplify.subscribe(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, unreadCount => this.hasUnreadMessages(unreadCount > 0));

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  chooseSharedScreen(conversationId) {
    if (!this.disableToggleScreen()) {
      const skipScreenSelection = this.selfStreamState.screenSend() || z.util.Environment.browser.firefox;
      if (skipScreenSelection) {
        amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, conversationId, z.media.MediaType.SCREEN);
        return;
      }

      if (z.util.Environment.desktop) {
        this.mediaRepository.devicesHandler
          .getScreenSources()
          .then(screenSources => {
            const conversationEntity = this.joinedCall().conversationEntity;

            const attributes = {
              conversation_type: z.tracking.helpers.getConversationType(conversationEntity),
              kind_of_call_when_sharing: this.joinedCall().isRemoteVideoSend() ? 'video' : 'audio',
              num_screens: screenSources.length,
            };

            const isTeamConversation = !!conversationEntity.team_id;
            if (isTeamConversation) {
              Object.assign(attributes, z.tracking.helpers.getGuestAttributes(conversationEntity));
            }

            amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CALLING.SHARED_SCREEN, attributes);

            const hasMultipleScreens = screenSources.length > 1;
            if (hasMultipleScreens) {
              this.isChoosingScreen(true);
              if (this.multitasking.isMinimized()) {
                this.multitasking.resetMinimize(true);
                this.multitasking.isMinimized(false);
              }
            } else {
              amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, conversationId, z.media.MediaType.SCREEN);
            }
          })
          .catch(error => {
            this.logger.error('Unable to get screens sources for sharing', error);
          });
      }
    }
  }

  clickedOnCancelScreen() {
    this.isChoosingScreen(false);
  }

  clickedOnLeaveCall() {
    if (this.joinedCall()) {
      const reason = z.calling.enum.TERMINATION_REASON.SELF_USER;
      amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.joinedCall().id, reason);
    }
  }

  clickedOnMuteAudio() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.AUDIO);
    }
  }

  clickedOnShareScreen() {
    if (!this.disableToggleScreen() && this.joinedCall()) {
      this.chooseSharedScreen(this.joinedCall().id);
    }
  }

  clickedOnChooseScreen(screenSource) {
    this.currentDeviceId.screenInput('');

    this.logger.info(`Selected '${screenSource.name}' for screen sharing`, screenSource);
    this.isChoosingScreen(false);
    this.currentDeviceId.screenInput(screenSource.id);
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.SCREEN);

    if (this.multitasking.resetMinimize()) {
      this.multitasking.isMinimized(true);
      this.multitasking.resetMinimize(false);
      this.logger.info(`Minimizing call '${this.joinedCall().id}' on screen selection to return to previous state`);
    }
  }

  clickedOnStopVideo() {
    if (this.joinedCall()) {
      amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.joinedCall().id, z.media.MediaType.VIDEO);
    }
  }

  clickedOnToggleCamera() {
    this.mediaRepository.devicesHandler.toggleNextCamera();
  }

  clickedOnToggleScreen() {
    this.mediaRepository.devicesHandler.toggleNextScreen();
  }

  clickedOnMinimize() {
    this.multitasking.isMinimized(true);
    this.logger.info(`Minimizing call '${this.videodCall().id}' on user click`);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.WindowTitleViewModel = class WindowTitleViewModel {
  static get TITLE_DEBOUNCE() {
    return 250;
  }

  constructor(mainViewModel, repositories) {
    this.initiateTitleUpdates = this.initiateTitleUpdates.bind(this);

    this.contentState = mainViewModel.content.state;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.WindowTitleViewModel', z.config.LOGGER.OPTIONS);

    this.updateWindowTitle = ko.observable(false);

    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setUpdateState.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.initiateTitleUpdates);
  }

  initiateTitleUpdates() {
    amplify.unsubscribe(z.event.WebApp.LIFECYCLE.LOADED, this.initiateTitleUpdates);

    this.logger.info('Starting to update window title');
    this.updateWindowTitle(true);

    ko.computed(() => {
      if (this.updateWindowTitle()) {
        const connectionRequests = this.userRepository.connect_requests().length;

        const unreadConversations = this.conversationRepository
          .conversations_unarchived()
          .filter(conversationEntity => {
            const {
              allMessages: unreadMessages,
              selfMentions: unreadSelfMentions,
              selfReplies: unreadSelfReplies,
            } = conversationEntity.unreadState();

            const isIgnored = conversationEntity.isRequest() || conversationEntity.showNotificationsNothing();

            if (isIgnored) {
              return false;
            }

            return conversationEntity.showNotificationsMentionsAndReplies()
              ? unreadSelfMentions.length || unreadSelfReplies.length
              : unreadMessages.length > 0 || conversationEntity.hasJoinableCall();
          }).length;

        const unreadCount = connectionRequests + unreadConversations;

        let specificTitle = unreadCount > 0 ? `(${unreadCount}) ` : '';

        amplify.publish(z.event.WebApp.LIFECYCLE.UNREAD_COUNT, unreadCount);

        switch (this.contentState()) {
          case z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS: {
            const multipleRequests = connectionRequests > 1;
            const stringId = multipleRequests
              ? z.string.conversationsConnectionRequestMany
              : z.string.conversationsConnectionRequestOne;
            specificTitle += z.l10n.text(stringId, connectionRequests);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.CONVERSATION: {
            if (this.conversationRepository.active_conversation()) {
              specificTitle += this.conversationRepository.active_conversation().display_name();
            }
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT: {
            specificTitle += z.l10n.text(z.string.preferencesAbout);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT: {
            specificTitle += z.l10n.text(z.string.preferencesAccount);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_AV: {
            specificTitle += z.l10n.text(z.string.preferencesAV);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS: {
            specificTitle += z.l10n.text(z.string.preferencesDeviceDetails);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES: {
            specificTitle += z.l10n.text(z.string.preferencesDevices);
            break;
          }

          case z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS: {
            specificTitle += z.l10n.text(z.string.preferencesOptions);
            break;
          }

          default:
            break;
        }

        const isTitleSet = specificTitle !== '' && !specificTitle.endsWith(' ');
        window.document.title = `${specificTitle}${isTitleSet ? ' · ' : ''}${z.l10n.text(z.string.wire)}`;
      }
    }).extend({rateLimit: WindowTitleViewModel.TITLE_DEBOUNCE});
  }

  setUpdateState(handlingNotifications) {
    const updateWindowTitle = handlingNotifications === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.updateWindowTitle() !== updateWindowTitle;
    if (isStateChange) {
      this.updateWindowTitle(updateWindowTitle);
      this.logger.debug(`Set window title update state to '${this.updateWindowTitle()}'`);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

/**
 * Use it on the drop area.
 */
ko.bindingHandlers.drop_file = {
  init(element, valueAccessor, allBindings, data, context) {
    const onDragLeave = (_data, event) => event.currentTarget.classList.remove('drag-hover');

    const onDragOver = (_data, event) => {
      event.preventDefault();
      event.originalEvent.dataTransfer.dropEffect = 'copy';
      event.currentTarget.classList.add('drag-hover');
    };

    const onDrop = (_data, event) => {
      event.preventDefault();
      event.currentTarget.classList.remove('drag-hover');

      const {dataTransfer, originalEvent} = event;
      const eventDataTransfer = dataTransfer || (originalEvent && originalEvent.dataTransfer) || {};
      const files = eventDataTransfer.files || [];

      if (files.length > 0) {
        valueAccessor()(files);
      }
    };

    ko.applyBindingsToNode(
      element,
      {
        event: {
          dragleave: onDragLeave,
          dragover: onDragOver,
          drop: onDrop,
        },
      },
      context
    );
  },
};

/**
 * Capture pasted files.
 */
ko.bindingHandlers.paste_file = {
  init(element, valueAccessor, allBindings, data, context) {
    const onPaste = (_data, event) => {
      const clipboardData = event.originalEvent.clipboardData;
      const items = [].slice.call(clipboardData.items || clipboardData.files);

      const files = items
        .filter(item => item.kind === 'file')
        .map(item => new Blob([item.getAsFile()], {type: item.type}))
        .filter(item => item && item.size !== 4); // Pasted files result in 4 byte blob (OSX)

      if (files.length > 0) {
        valueAccessor()(files);
        return false;
      }
      return true;
    };

    ko.applyBindingsToNode(
      window,
      {
        event: {
          paste: onPaste,
        },
      },
      context
    );
  },
};

/**
 * Blocks the default behavior when dropping a file on the element.
 * @note If a child element is listening to drag events, than this will be triggered after
 */
ko.bindingHandlers.ignore_drop_file = {
  init(element, valueAccessor, allBindings, data, context) {
    ko.applyBindingsToNode(
      element,
      {
        event: {
          dragover: (_data, event) => event.preventDefault(),
          drop: (_data, event) => event.preventDefault(),
        },
      },
      context
    );
  },
};

/**
 * Indicate that the current binding loop should not try to bind this element’s children.
 * @see http://www.knockmeout.net/2012/05/quick-tip-skip-binding.html
 */
ko.bindingHandlers.stopBinding = {
  init() {
    return {controlsDescendantBindings: true};
  },
};

ko.virtualElements.allowedBindings.stopBinding = true;

/**
 * Resize textarea according to the containing text.
 */
ko.bindingHandlers.resize = {
  init(element, valueAccessor, allBindings, data, context) {
    const params = ko.unwrap(valueAccessor()) || {};

    let lastHeight = element.scrollHeight;

    const resizeTextarea = (textareaElement => {
      textareaElement.style.height = 0;
      const newStyleHeight = `${textareaElement.scrollHeight}px`;
      textareaElement.style.height = newStyleHeight;

      const currentHeight = textareaElement.clientHeight;

      if (lastHeight !== currentHeight) {
        lastHeight = currentHeight;
        const maxHeight = window.parseInt(getComputedStyle(textareaElement).maxHeight, 10);

        const isMaximumHeight = currentHeight >= maxHeight;
        const newStyleOverflowY = isMaximumHeight ? 'scroll' : 'hidden';
        textareaElement.style.overflowY = newStyleOverflowY;
      }
    }).bind(null, element);
    const throttledResizeTextarea = _.throttle(resizeTextarea, 100, {leading: !params.delayedResize});

    resizeTextarea();
    return ko.applyBindingsToNode(
      element,
      {
        event: {
          focus: throttledResizeTextarea,
          input: throttledResizeTextarea,
        },
      },
      context
    );
  },
};

ko.bindingHandlers.heightSync = {
  init(element, valueAccessor, allBindings, data, context) {
    const params = ko.unwrap(valueAccessor()) || {};

    const resizeCallback = params.callback;
    const targetElement = document.querySelector(params.target);
    const triggerValue = params.trigger;

    const resizeTarget = () => {
      const sourceHeight = element.scrollHeight;
      const targetHeight = targetElement.offsetHeight;
      if (sourceHeight !== targetHeight) {
        targetElement.style.overflowY = 'hidden';
        targetElement.style.height = `${element.scrollHeight}px`;
        z.util.afterRender(() => (targetElement.style.overflowY = ''));
        if (typeof resizeCallback === 'function') {
          resizeCallback(sourceHeight, targetHeight);
        }
      }
    };

    // initial resize
    resizeTarget();
    const valueSubscription = triggerValue.subscribe(() => window.requestAnimationFrame(resizeTarget));
    ko.utils.domNodeDisposal.addDisposeCallback(element, () => valueSubscription.dispose());
  },
};

/**
 * Syncs scrolling to another element.
 */
ko.bindingHandlers.scrollSync = {
  init(element, valueAccessor) {
    const selector = valueAccessor();
    const anchorElement = document.querySelector(selector);
    if (anchorElement) {
      anchorElement.addEventListener('scroll', () => {
        element.scrollTop = anchorElement.scrollTop;
      });
    }
  },
};

/**
 * Register on enter key pressed.
 */
ko.bindingHandlers.enter = {
  init(element, valueAccessor, allBindings, data, context) {
    const wrapper = function(_data, jquery_event) {
      const keyboard_event = jquery_event.originalEvent || jquery_event;

      if (z.util.KeyboardUtil.isEnterKey(keyboard_event) && !keyboard_event.shiftKey && !keyboard_event.altKey) {
        const callback = valueAccessor();
        if (typeof callback === 'function') {
          callback.call(this, data, keyboard_event);
          return false;
        }
      }
      return true;
    };

    return ko.applyBindingsToNode(
      element,
      {
        event: {
          keypress: wrapper,
        },
      },
      context
    );
  },
};

/**
 * Binding for <input type="file" data-bind="fileSelect: on_file_select">.
 */
ko.bindingHandlers.file_select = {
  init(element, valueAccessor, allBindings, data, context) {
    const wrapper = function(_data, event) {
      if (event.target.files.length > 0) {
        valueAccessor().call(this, event.target.files);

        // http://stackoverflow.com/a/12102992/4453133
        // wait before clearing to fix autotests
        window.setTimeout(() => {
          $(event.target).val(null);
        }, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      }
    };

    return ko.applyBindingsToNode(
      element,
      {
        event: {
          change: wrapper,
          focus(_data, event) {
            return $(event.target).blur();
          },
        },
      },
      context
    );
  },
};

/**
 * Wait for image to be loaded before applying as background image.
 */
ko.bindingHandlers.loadImage = {
  init(element, valueAccessor) {
    const image_src = z.util.stripUrlWrapper(ko.unwrap(valueAccessor()));
    const image = new Image();
    image.onload = () => (element.style.backgroundImage = `url(${image_src})`);
    image.src = image_src;
  },
};

/**
 * Load image when hovering over element.
 */
ko.bindingHandlers.load_image_on_hover = {
  init(element) {
    const hoverable_item = $(element);
    const static_image = hoverable_item.data('src');
    const animated_gif = hoverable_item.data('hover');

    if (animated_gif) {
      let image = undefined;
      hoverable_item
        .on('mouseover', function() {
          const item = $(this);
          image = new Image();
          image.onload = () => item.css({backgroundImage: `url(${animated_gif})`});
          image.src = animated_gif;
        })
        .on('mouseout', function() {
          image.onload = undefined;
          $(this).css({backgroundImage: `url(${static_image})`});
        });
    }
  },
};

/**
 * This execution trims the underlying value.
 * @returns {ko.computed} Computed
 */
ko.subscribable.fn.trimmed = function() {
  return ko.computed({
    owner: this,
    read() {
      return this().trim();
    },
    write(value) {
      this(value.trim());
      this.valueHasMutated();
    },
  });
};

/**
 * Will only fire once when the value has changed.
 * @param {*} handler - Handler
 * @param {ko.observable} owner - Subscription owner
 * @param {string} event_name - Event name
 * @returns {undefined} No return value
 */
ko.subscribable.fn.subscribe_once = function(handler, owner, event_name) {
  const subscription = this.subscribe(
    new_value => {
      subscription.dispose();
      handler(new_value);
    },
    owner,
    event_name
  );
};

/**
 * Subscribe to changes and receive the new and the old value
 * https://github.com/knockout/knockout/issues/914#issuecomment-66697321
 * @param {function} handler - Handler
 * @returns {ko.subscription} knockout subscription
 */

ko.subscribable.fn.subscribeChanged = function(handler) {
  let savedValue = this.peek();
  return this.subscribe(latestValue => {
    const oldValue = savedValue;
    savedValue = latestValue;
    handler(latestValue, oldValue);
  });
};

/**
 * Render antiscroll scrollbar.
 */
ko.bindingHandlers.antiscroll = {
  init(element, valueAccessor) {
    let trigger_subscription;
    $(element).antiscroll({
      autoHide: true,
      autoWrap: true,
      debug: false,
      notHorizontal: true,
    });

    const parent_element = $(element).parent();
    const antiscroll = parent_element.data('antiscroll');

    if (antiscroll) {
      const trigger_value = valueAccessor();
      if (ko.isObservable(trigger_value)) {
        trigger_subscription = trigger_value.subscribe(() => {
          antiscroll.rebuild();
        });
      }

      const resize_event = `resize.${Date.now()}`;
      $(window).on(
        resize_event,
        _.throttle(() => {
          antiscroll.rebuild();
        }, 100)
      );

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        antiscroll.destroy();
        $(window).off(resize_event);
        if (trigger_subscription) {
          trigger_subscription.dispose();
        }
      });
    }
  },
};

ko.bindingHandlers.simplebar = {
  init(element, valueAccessor) {
    const {trigger = valueAccessor(), onInit} = valueAccessor();
    const simpleBar = new window.SimpleBar(element, {autoHide: false});
    if (ko.isObservable(trigger)) {
      const triggerSubscription = trigger.subscribe(() => simpleBar.recalculate());
      ko.utils.domNodeDisposal.addDisposeCallback(element, () => triggerSubscription.dispose());
    }
    if (onInit) {
      onInit(simpleBar);
    }
  },
};

ko.bindingHandlers.electron_remove = {
  init(element) {
    if (z.util.Environment.electron) {
      $(element).remove();
    }
  },
};

ko.bindingHandlers.visibility = (function() {
  const setVisibility = function(element, valueAccessor) {
    const hidden = ko.unwrap(valueAccessor());
    return $(element).css('visibility', hidden ? 'visible' : 'hidden');
  };
  return {
    init: setVisibility,
    update: setVisibility,
  };
})();

ko.bindingHandlers.relative_timestamp = (function() {
  const timestamps = [];

  // should be fine to fire all 60 sec
  window.setInterval(() => timestamps.map(timestamp_func => timestamp_func()), z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

  const calculate = function(element, timestamp) {
    timestamp = window.parseInt(timestamp);
    const date = moment.unix(timestamp / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    const now = moment().local();
    const today = now.format('YYMMDD');
    const yesterday = now.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return $(element).text(z.l10n.text(z.string.conversationJustNow));
    }

    if (moment().diff(date, 'minutes') < 60) {
      return $(element).text(date.fromNow());
    }

    if (current_day === today) {
      return $(element).text(date.local().format('HH:mm'));
    }

    if (current_day === yesterday) {
      return $(element).text(`${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`);
    }

    if (moment().diff(date, 'days') < 7) {
      return $(element).text(date.local().format('dddd HH:mm'));
    }

    return $(element).text(date.local().format('dddd, MMMM D, HH:mm'));
  };

  return {
    init(element, valueAccessor) {
      const timestamp_func = () => calculate(element, valueAccessor());
      timestamp_func();
      timestamps.push(timestamp_func);

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        const timestamp_index = timestamps.indexOf(timestamp_func);
        timestamps.splice(timestamp_index, 1);
      });
    },
  };
})();

/**
 * Add 'hide-controls' when the mouse leave the element or stops moving.
 */
ko.bindingHandlers.hide_controls = {
  init(element, valueAccessor) {
    const {timeout = valueAccessor(), skipClass} = valueAccessor();
    let hide_timeout = undefined;

    element.onmouseenter = function() {
      element.classList.remove('hide-controls');
    };

    element.onmouseleave = function() {
      if (document.hasFocus()) {
        return element.classList.add('hide-controls');
      }
    };

    element.onmousemove = function({target}) {
      if (hide_timeout) {
        window.clearTimeout(hide_timeout);
      }

      element.classList.remove('hide-controls');

      let node = target;
      while (node && node !== element) {
        if (node.classList.contains(skipClass)) {
          return;
        }
        node = node.parentNode;
      }

      hide_timeout = window.setTimeout(() => {
        element.classList.add('hide-controls');
      }, timeout);
    };
  },
};

/**
 * Element is added to view.
 */
ko.bindingHandlers.added_to_view = {
  init(element, valueAccessor) {
    const callback = valueAccessor();
    callback();
  },
};

/**
 * Element is removed fomr view
 */
ko.bindingHandlers.removed_from_view = {
  init(element, valueAccessor) {
    const callback = valueAccessor();
    ko.utils.domNodeDisposal.addDisposeCallback(element, () => callback());
  },
};

/**
 * Adds a callback called whenever an element is in viewport and not overlayed by another element.
 */
ko.bindingHandlers.in_viewport = {
  init(element, valueAccessor) {
    const onElementVisible = valueAccessor();
    if (!onElementVisible) {
      return;
    }
    z.ui.ViewportObserver.addElement(element, () => {
      return z.ui.OverlayedObserver.onElementVisible(element, onElementVisible);
    });

    ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
      z.ui.OverlayedObserver.removeElement(element);
      z.ui.ViewportObserver.removeElement(element);
    });
  },
};

ko.bindingHandlers.tooltip = {
  update(element, valueAccessor) {
    const {text = valueAccessor(), position, disabled} = valueAccessor();
    if (!disabled) {
      const {id = text, substitute} = text;
      element.classList.add('with-tooltip', `with-tooltip--${position === 'bottom' ? 'bottom' : 'top'}`);
      element.setAttribute('data-tooltip', z.l10n.text(id, substitute));
    }
  },
};

/**
 * Suppresses the click event if we are in the macOs wrapper and are dragging the window
 */
ko.bindingHandlers.clickOrDrag = {
  init(element, valueAccessor, allBindings, viewModel, bindingContext) {
    const isMacDesktop = z.util.Environment.electron && z.util.Environment.os.mac;
    const context = bindingContext.$data;
    const callback = valueAccessor().bind(context, context);
    if (!isMacDesktop) {
      return element.addEventListener('click', callback);
    }

    let isMoved = false;
    let isDragging = false;
    let startX = 0;
    let startY = 0;

    element.addEventListener('mousedown', ({screenX, screenY}) => {
      isDragging = true;
      isMoved = false;
      startX = screenX;
      startY = screenY;
    });

    element.addEventListener('mousemove', ({screenX, screenY}) => {
      if (isDragging && !isMoved) {
        const diffX = Math.abs(startX - screenX);
        const diffY = Math.abs(startY - screenY);
        if (diffX > 1 || diffY > 1) {
          isMoved = true;
        }
      }
    });

    element.addEventListener('mouseup', event => {
      if (!isMoved) {
        callback(event);
      }
      isDragging = false;
    });
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

// show scroll borders
ko.bindingHandlers.bordered_list = (function() {
  const calculate_borders = _.throttle($element => {
    if ($element) {
      window.requestAnimationFrame(() => {
        const list_column = $($element).parent();
        if ($element.height() <= 0 || !$element.isScrollable()) {
          return list_column.removeClass('left-list-center-border-bottom conversations-center-border-top');
        }

        list_column.toggleClass('left-list-center-border-top', !$element.isScrolledTop());
        list_column.toggleClass('left-list-center-border-bottom', !$element.isScrolledBottom());
      });
    }
  }, 100);

  return {
    init(element) {
      const $element = $(element);
      $element.on('scroll', () => calculate_borders($element));
      $('.left').on('click', () => calculate_borders($element));
      $(window).on('resize', () => calculate_borders($element));
      amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, () => calculate_borders($element));
    },

    update(element, valueAccessor) {
      ko.unwrap(valueAccessor());
      calculate_borders($(element));
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.bindingHandlers.switchBackground = (() => {
  return {
    update(element, valueAccessor) {
      const imageResource = ko.unwrap(valueAccessor());

      if (imageResource) {
        const backgroundImages = $(element).find('.background');
        const backgroundLast = backgroundImages.last();
        const backgroundNext = backgroundLast.clone();
        backgroundNext.css({opacity: '0'});
        backgroundNext.insertAfter(backgroundLast);

        imageResource
          .load()
          .then(blob => {
            if (blob) {
              backgroundNext
                .find('.background-image')
                .css({'background-image': `url(${window.URL.createObjectURL(blob)})`});
            }
          })
          .then(() => backgroundNext.css({opacity: '1'}).one(z.util.alias.animationend, backgroundLast.remove));
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.bindingHandlers.l10n_href = {
  update(element, valueAccessor) {
    const {support, type, path} = valueAccessor();
    const href = support ? z.util.URLUtil.buildSupportUrl(support) : z.util.URLUtil.buildUrl(type, z.l10n.text(path));
    element.setAttribute('href', href);
  },
};

ko.bindingHandlers.l10n_input = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('value', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_placeholder = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('placeholder', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_text = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    ko.utils.setTextContent(element, z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10nSafeHtml = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitutions} = valueAccessor();
    ko.utils.setHtml(element, z.l10n.safeHtml(id, substitutions));
  },
};

ko.bindingHandlers.l10n_tooltip = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('title', z.l10n.text(id, substitute));
  },
};

ko.bindingHandlers.l10n_aria_label = {
  update(element, valueAccessor) {
    const {id = valueAccessor(), substitute} = valueAccessor();
    element.setAttribute('aria-label', z.l10n.text(id, substitute));
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

/**
 * Focus input field when user starts typing if no other input field or textarea is selected.
 */
ko.bindingHandlers.focus_on_keydown = {
  init(element, valueAccessor, allBindings, data, context) {
    return ko.applyBindingsToNode(
      window,
      {
        event: {
          keydown(_data, jquery_event) {
            if ($('.detail-view').hasClass('modal-show')) {
              return false;
            }

            const keyboard_event = jquery_event.originalEvent || jquery_event;
            // check for activeElement needed, cause in IE11 i could be undefined under some circumstances
            const active_element_is_input =
              document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
            const is_arrow_key = z.util.KeyboardUtil.isArrowKey(keyboard_event);

            if (!active_element_is_input && !is_arrow_key) {
              const is_meta_key_pressed = z.util.KeyboardUtil.isMetaKey(keyboard_event);
              const is_paste_action = z.util.KeyboardUtil.isPasteAction(keyboard_event);

              if (!is_meta_key_pressed || is_paste_action) {
                element.focus();
              }
            }

            return true;
          },
        },
      },
      context
    );
  },
};

/**
 * Show timestamp when hovering over the element.
 */
ko.bindingHandlers.show_all_timestamps = {
  init(element) {
    const $element = $(element);

    $element.on('mousemove mouseout', function(event) {
      const rect = $(this)
        .find('.messages')[0]
        .getBoundingClientRect();
      const show_timestamps = event.clientX > rect.right - 64 && event.clientX < rect.right;
      $('.time').toggleClass('show-timestamp', show_timestamps);
    });
  },
};

/**
 * Start loading image once they are in the viewport.
 */
ko.bindingHandlers.background_image = {
  init(element, valueAccessor, allBindingsAccessor) {
    const assetLoader = valueAccessor();

    if (!assetLoader) {
      return;
    }

    const imageElement = $(element).find('img');
    let objectUrl;

    const loadImage = () => {
      assetLoader()
        .load()
        .then(blob => {
          $(element).removeClass('image-loading');
          objectUrl = window.URL.createObjectURL(blob);
          imageElement[0].src = objectUrl;
        })
        .catch(() => {});
    };

    z.ui.ViewportObserver.addElement(element, loadImage);

    ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
      z.ui.ViewportObserver.removeElement(element);
      if (objectUrl) {
        window.URL.revokeObjectURL(objectUrl);
      }
    });
  },
};

/**
 * Generate message timestamp.
 */
ko.bindingHandlers.relative_timestamp = (function() {
  // timestamp that should be updated
  const timestamps = [];

  const calculate_timestamp = function(date) {
    const current_time = moment().local();
    const today = current_time.format('YYMMDD');
    const yesterday = current_time.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return z.l10n.text(z.string.conversationJustNow);
    }

    if (moment().diff(date, 'minutes') < 60) {
      return date.fromNow();
    }

    if (current_day === today) {
      return date.local().format('HH:mm');
    }

    if (current_day === yesterday) {
      return `${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`;
    }

    if (moment().diff(date, 'days') < 7) {
      return date.local().format('dddd HH:mm');
    }

    return date.local().format('MMMM D, HH:mm');
  };

  const calculate_timestamp_day = function(date) {
    const now = moment().local();
    const today = now.format('YYMMDD');
    const yesterday = now.subtract(1, 'days').format('YYMMDD');
    const current_day = date.local().format('YYMMDD');

    if (moment().diff(date, 'minutes') < 2) {
      return z.l10n.text(z.string.conversationJustNow);
    }

    if (moment().diff(date, 'minutes') < 60) {
      return date.fromNow();
    }

    if (current_day === today) {
      return `${z.l10n.text(z.string.conversationToday)} ${date.local().format('HH:mm')}`;
    }

    if (current_day === yesterday) {
      return `${z.l10n.text(z.string.conversationYesterday)} ${date.local().format('HH:mm')}`;
    }

    if (moment().diff(date, 'days') < 7) {
      return date.local().format('dddd HH:mm');
    }

    return date.local().format('dddd, MMMM D, HH:mm');
  };

  // should be fine to update every minute
  window.setInterval(() => timestamps.map(timestamp_func => timestamp_func()), z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

  const calculate = function(element, timestamp, is_day) {
    timestamp = window.parseInt(timestamp);
    const date = moment.unix(timestamp / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    if (is_day) {
      return $(element).text(calculate_timestamp_day(date));
    }

    return $(element).text(calculate_timestamp(date));
  };

  return {
    init(element, valueAccessor, allBindings) {
      const timestamp_func = function() {
        calculate(element, valueAccessor(), allBindings.get('relative_timestamp_day'));
      };

      timestamp_func();
      timestamps.push(timestamp_func);

      ko.utils.domNodeDisposal.addDisposeCallback(element, () => {
        const timestamp_index = timestamps.indexOf(timestamp_func);
        timestamps.splice(timestamp_index, 1);
      });
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

// http://stackoverflow.com/questions/28762211/unable-to-mute-html5-video-tag-in-firefox
ko.bindingHandlers.muteMediaElement = {
  update(element, valueAccessor) {
    if (valueAccessor()) {
      element.muted = true;
    }
  },
};

ko.bindingHandlers.sourceStream = {
  update(element, valueAccessor) {
    element.srcObject = valueAccessor();
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ContentViewModel = class ContentViewModel {
  static get STATE() {
    return {
      COLLECTION: 'ContentViewModel.STATE.COLLECTION',
      COLLECTION_DETAILS: 'ContentViewModel.STATE.COLLECTION_DETAILS',
      CONNECTION_REQUESTS: 'ContentViewModel.STATE.CONNECTION_REQUESTS',
      CONVERSATION: 'ContentViewModel.STATE.CONVERSATION',
      HISTORY_EXPORT: 'ContentViewModel.STATE.HISTORY_EXPORT',
      HISTORY_IMPORT: 'ContentViewModel.STATE.HISTORY_IMPORT',
      PREFERENCES_ABOUT: 'ContentViewModel.STATE.PREFERENCES_ABOUT',
      PREFERENCES_ACCOUNT: 'ContentViewModel.STATE.PREFERENCES_ACCOUNT',
      PREFERENCES_AV: 'ContentViewModel.STATE.PREFERENCES_AV',
      PREFERENCES_DEVICE_DETAILS: 'ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS',
      PREFERENCES_DEVICES: 'ContentViewModel.STATE.PREFERENCES_DEVICES',
      PREFERENCES_OPTIONS: 'ContentViewModel.STATE.PREFERENCES_OPTIONS',
      WATERMARK: 'ContentViewModel.STATE.WATERMARK',
    };
  }

  constructor(mainViewModel, repositories) {
    this.showConversation = this.showConversation.bind(this);
    this.switchContent = this.switchContent.bind(this);
    this.switchPreviousContent = this.switchPreviousContent.bind(this);

    this.elementId = 'center-column';
    this.mainViewModel = mainViewModel;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.ContentViewModel', z.config.LOGGER.OPTIONS);

    // State
    this.state = ko.observable(ContentViewModel.STATE.WATERMARK);
    this.multitasking = {
      autoMinimize: ko.observable(true),
      isMinimized: ko.observable(false),
      resetMinimize: ko.observable(false),
    };

    // Nested view models
    this.collectionDetails = new z.viewModel.content.CollectionDetailsViewModel();
    this.collection = new z.viewModel.content.CollectionViewModel(mainViewModel, this, repositories);
    this.connectRequests = new z.viewModel.content.ConnectRequestsViewModel(mainViewModel, this, repositories);
    this.emojiInput = new z.viewModel.content.EmojiInputViewModel(mainViewModel, this, repositories);
    this.giphy = new z.viewModel.content.GiphyViewModel(mainViewModel, this, repositories);
    this.inputBar = new z.viewModel.content.InputBarViewModel(
      mainViewModel,
      this,
      repositories,
      z.message.MessageHasher
    );
    this.groupCreation = new z.viewModel.content.GroupCreationViewModel(mainViewModel, this, repositories);
    this.messageList = new z.viewModel.content.MessageListViewModel(mainViewModel, this, repositories);
    this.titleBar = new z.viewModel.content.TitleBarViewModel(mainViewModel, this, repositories);

    this.preferencesAbout = new z.viewModel.content.PreferencesAboutViewModel(mainViewModel, this, repositories);
    this.preferencesAccount = new z.viewModel.content.PreferencesAccountViewModel(mainViewModel, this, repositories);
    this.preferencesAV = new z.viewModel.content.PreferencesAVViewModel(mainViewModel, this, repositories);
    this.preferencesDeviceDetails = new z.viewModel.content.PreferencesDeviceDetailsViewModel(
      mainViewModel,
      this,
      repositories
    );
    this.preferencesDevices = new z.viewModel.content.PreferencesDevicesViewModel(mainViewModel, this, repositories);
    this.preferencesOptions = new z.viewModel.content.PreferencesOptionsViewModel(mainViewModel, this, repositories);

    this.historyExport = new z.viewModel.content.HistoryExportViewModel(mainViewModel, this, repositories);
    this.historyImport = new z.viewModel.content.HistoryImportViewModel(mainViewModel, this, repositories);

    this.previousState = undefined;
    this.previousConversation = undefined;

    this.state.subscribe(state => {
      switch (state) {
        case ContentViewModel.STATE.CONVERSATION:
          this.inputBar.addedToView();
          this.titleBar.addedToView();
          break;
        case ContentViewModel.STATE.PREFERENCES_ACCOUNT:
          this.preferencesAccount.checkNewClients();
          break;
        case ContentViewModel.STATE.PREFERENCES_AV:
          this.preferencesAV.initiateDevices();
          break;
        case ContentViewModel.STATE.PREFERENCES_DEVICES:
          this.preferencesDevices.updateDeviceInfo();
          break;
        case ContentViewModel.STATE.COLLECTION:
          this.collection.setConversation(this.previousConversation);
          break;
        default:
          this.inputBar.removedFromView();
          this.titleBar.removedFromView();
      }
    });

    this.userRepository.connect_requests.subscribe(requests => {
      const isStateRequests = this.state() === ContentViewModel.STATE.CONNECTION_REQUESTS;
      if (isStateRequests && !requests.length) {
        this.showConversation(this.conversationRepository.getMostRecentConversation());
      }
    });

    this._initSubscriptions();

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this.switchContent.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.SHOW, this.showConversation.bind(this));
  }

  /**
   * Slide in specified content.
   * @param {string} contentSelector - DOM element to apply slide in animation
   * @returns {undefined} No return value
   */
  _shiftContent(contentSelector) {
    const incomingCssClass = 'content-animation-incoming-horizontal-left';

    $(contentSelector)
      .removeClass(incomingCssClass)
      .off(z.util.alias.animationend)
      .addClass(incomingCssClass)
      .one(z.util.alias.animationend, function() {
        $(this)
          .removeClass(incomingCssClass)
          .off(z.util.alias.animationend);
      });
  }

  /**
   * Opens the specified conversation.
   *
   * @note If the conversation_et is not defined, it will open the incoming connection requests instead
   *  Conversation_et can also just be the conversation ID
   *
   * @param {z.entity.Conversation|string} conversation - Conversation entity or conversation ID
   * @param {Object} options - State to open conversation in
   * @param {z.entity.Message} [options.exposeMessage] - Scroll to message and highlight it
   * @param {boolean} [options.openFirstSelfMention=false] - Open first self mention instead of passed message
   * @param {boolean} [options.openNotificationSettings=false] - Open notification settings of conversation
   * @returns {undefined} No return value
   */
  showConversation(conversation, options = {}) {
    const {
      exposeMessage: exposeMessageEntity,
      openFirstSelfMention = false,
      openNotificationSettings = false,
    } = options;

    if (!conversation) {
      return this.switchContent(ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    const isConversation = typeof conversation === 'object' && conversation.id;
    const isConversationId = typeof conversation === 'string';
    if (!isConversation && !isConversationId) {
      throw new Error(`Wrong input for conversation: ${typeof conversation}`);
    }

    const conversationPromise = isConversation
      ? Promise.resolve(conversation)
      : this.conversationRepository.get_conversation_by_id(conversation);

    conversationPromise.then(conversationEntity => {
      const isActiveConversation = conversationEntity === this.conversationRepository.active_conversation();
      const isConversationState = this.state() === ContentViewModel.STATE.CONVERSATION;
      const isOpenedConversation = conversationEntity && isActiveConversation && isConversationState;

      if (isOpenedConversation) {
        if (openNotificationSettings) {
          this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
        }
        return;
      }

      this._releaseContent(this.state());

      this.state(ContentViewModel.STATE.CONVERSATION);

      if (!isActiveConversation) {
        this.conversationRepository.active_conversation(conversationEntity);
      }

      const messageEntity = openFirstSelfMention ? conversationEntity.getFirstUnreadSelfMention() : exposeMessageEntity;
      this.messageList.changeConversation(conversationEntity, messageEntity).then(() => {
        this._showContent(ContentViewModel.STATE.CONVERSATION);
        this.previousConversation = this.conversationRepository.active_conversation();
        if (openNotificationSettings) {
          this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
        }
      });
    });
  }

  switchContent(newContentState) {
    const isStateChange = newContentState !== this.state();
    if (isStateChange) {
      this._releaseContent(newContentState);
      this._showContent(this._checkContentAvailability(newContentState));
    }
  }

  switchPreviousContent() {
    const isStateChange = this.previousState !== this.state();
    if (isStateChange) {
      const isStateRequests = this.previousState === ContentViewModel.STATE.CONNECTION_REQUESTS;
      if (isStateRequests) {
        this.switchContent(ContentViewModel.STATE.CONNECTION_REQUESTS);
      }

      if (this.previousConversation && !this.previousConversation.is_archived()) {
        return this.showConversation(this.previousConversation);
      }

      return this.switchContent(ContentViewModel.STATE.WATERMARK);
    }
  }

  _checkContentAvailability(state) {
    const isStateRequests = state === ContentViewModel.STATE.CONNECTION_REQUESTS;
    if (isStateRequests) {
      const hasConnectRequests = !!this.userRepository.connect_requests().length;
      if (!hasConnectRequests) {
        return ContentViewModel.STATE.WATERMARK;
      }
    }
    return state;
  }

  _getElementOfContent(state) {
    switch (state) {
      case ContentViewModel.STATE.COLLECTION:
        return '.collection';
      case ContentViewModel.STATE.COLLECTION_DETAILS:
        return '.collection-details';
      case ContentViewModel.STATE.CONVERSATION:
        return '.conversation';
      case ContentViewModel.STATE.CONNECTION_REQUESTS:
        return '.connect-requests';
      case ContentViewModel.STATE.PREFERENCES_ABOUT:
        return '.preferences-about';
      case ContentViewModel.STATE.PREFERENCES_ACCOUNT:
        return '.preferences-account';
      case ContentViewModel.STATE.PREFERENCES_AV:
        return '.preferences-av';
      case ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS:
        return '.preferences-device-details';
      case ContentViewModel.STATE.PREFERENCES_DEVICES:
        return '.preferences-devices';
      case ContentViewModel.STATE.PREFERENCES_OPTIONS:
        return '.preferences-options';
      default:
        return '.watermark';
    }
  }

  _releaseContent(newContentState) {
    this.previousState = this.state();

    const isStateConversation = this.previousState === ContentViewModel.STATE.CONVERSATION;
    if (isStateConversation) {
      const collectionStates = [ContentViewModel.STATE.COLLECTION, ContentViewModel.STATE.COLLECTION_DETAILS];
      const isCollectionState = collectionStates.includes(newContentState);
      if (!isCollectionState) {
        this.conversationRepository.active_conversation(null);
      }

      return this.messageList.release_conversation();
    }

    const isStatePreferencesAv = this.previousState === ContentViewModel.STATE.PREFERENCES_AV;
    if (isStatePreferencesAv) {
      this.preferencesAV.releaseDevices();
    }
  }

  _showContent(newContentState) {
    this.state(newContentState);
    return this._shiftContent(this._getElementOfContent(newContentState));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.CollectionDetailsViewModel = class CollectionDetailsViewModel {
  constructor() {
    this.itemAdded = this.itemAdded.bind(this);
    this.itemRemoved = this.itemRemoved.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);
    this.removedFromView = this.removedFromView.bind(this);
    this.setConversation = this.setConversation.bind(this);

    this.logger = new z.util.Logger('z.viewModel.CollectionDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.template = ko.observable();
    this.conversationEntity = ko.observable();

    this.items = ko.observableArray();

    this.lastMessageTimestamp = undefined;
  }

  setConversation(conversationEntity, category, items) {
    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    this.template(category);
    this.conversationEntity(conversationEntity);
    z.util.koPushDeferred(this.items, items);
  }

  itemAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation_id;
    if (isCurrentConversation) {
      switch (this.template()) {
        case 'images': {
          const isImage = messageEntity.category & z.message.MessageCategory.IMAGE;
          const isGif = messageEntity.category & z.message.MessageCategory.GIF;
          if (isImage && !isGif) {
            this.items.push(messageEntity);
          }
          break;
        }

        case 'files': {
          const isFile = messageEntity.category & z.message.MessageCategory.FILE;
          if (isFile) {
            this.items.push(messageEntity);
          }
          break;
        }

        case 'links':
          const isLinkPreview = messageEntity.category & z.message.MessageCategory.LINK_PREVIEW;
          if (isLinkPreview) {
            this.items.push(messageEntity);
          }
          break;

        default:
          break;
      }
    }
  }

  itemRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      this.items.remove(messageEntity => messageEntity.id === messageId);
      if (!this.items().length) {
        this.clickOnBackButton();
      }
    }
  }

  messageRemoved(messageEntity) {
    this.itemRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  removedFromView() {
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    this.lastMessageTimestamp = undefined;
    this.conversationEntity(null);
    this.items.removeAll();
  }

  clickOnBackButton() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION);
  }

  clickOnImage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, messageEntity, this.items(), 'collection');
  }

  shouldShowHeader(messageEntity) {
    if (!this.lastMessageTimestamp) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }

    // We passed today
    const isSameDay = moment(messageEntity.timestamp()).isSameDay(this.lastMessageTimestamp);
    const wasToday = moment(this.lastMessageTimestamp).isToday();
    if (!isSameDay && wasToday) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }

    // We passed the month
    const isSameMonth = moment(messageEntity.timestamp()).isSameMonth(this.lastMessageTimestamp);
    if (!isSameMonth) {
      this.lastMessageTimestamp = messageEntity.timestamp();
      return true;
    }
  }

  getTitleForHeader(messageEntity) {
    const messageDate = moment(messageEntity.timestamp());
    if (messageDate.isToday()) {
      return z.l10n.text(z.string.conversationToday);
    }

    return messageDate.isCurrentYear() ? messageDate.format('MMMM') : messageDate.format('MMMM Y');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.CollectionViewModel = class CollectionViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.addedToView = this.addedToView.bind(this);
    this.clickOnMessage = this.clickOnMessage.bind(this);
    this.itemAdded = this.itemAdded.bind(this);
    this.itemRemoved = this.itemRemoved.bind(this);
    this.messageRemoved = this.messageRemoved.bind(this);
    this.onInputChange = this.onInputChange.bind(this);
    this.removedFromView = this.removedFromView.bind(this);
    this.searchInConversation = this.searchInConversation.bind(this);
    this.setConversation = this.setConversation.bind(this);

    this.collectionDetails = contentViewModel.collectionDetails;
    this.conversation_repository = repositories.conversation;
    this.logger = new z.util.Logger('z.viewModel.CollectionViewModel', z.config.LOGGER.OPTIONS);

    this.conversationEntity = ko.observable();

    this.audio = ko.observableArray().extend({rateLimit: 1});
    this.files = ko.observableArray().extend({rateLimit: 1});
    this.images = ko.observableArray().extend({rateLimit: 1});
    this.links = ko.observableArray().extend({rateLimit: 1});

    this.searchInput = ko.observable('');
  }

  addedToView() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    $(document).on('keydown.collection', keyboardEvent => {
      if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
        amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity());
      }
    });
  }

  searchInConversation(query) {
    return this.conversation_repository.searchInConversation(this.conversationEntity(), query);
  }

  onInputChange(input) {
    this.searchInput(input || '');
  }

  itemAdded(messageEntity) {
    const isCurrentConversation = this.conversationEntity().id === messageEntity.conversation_id;
    if (isCurrentConversation) {
      this._populateItems([messageEntity]);
    }
  }

  itemRemoved(messageId, conversationId) {
    const isCurrentConversation = this.conversationEntity().id === conversationId;
    if (isCurrentConversation) {
      const _removeItem = messageEntity => messageEntity.id === messageId;
      [this.audio, this.files, this.images, this.links].forEach(array => array.remove(_removeItem));
    }
  }

  messageRemoved(messageEntity) {
    this.itemRemoved(messageEntity.id, messageEntity.conversation_id);
  }

  removedFromView() {
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, this.messageRemoved);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, this.itemAdded);
    amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, this.itemRemoved);
    $(document).off('keydown.collection');
    this.conversationEntity(null);
    this.searchInput('');
    [this.images, this.files, this.links, this.audio].forEach(array => array.removeAll());
  }

  setConversation(conversationEntity = this.conversation_repository.active_conversation()) {
    if (conversationEntity) {
      this.conversationEntity(conversationEntity);

      this.conversation_repository
        .get_events_for_category(conversationEntity, z.message.MessageCategory.LINK_PREVIEW)
        .then(messageEntities => this._populateItems(messageEntities));
    }
  }

  _populateItems(messageEntities) {
    messageEntities.forEach(messageEntity => {
      if (!messageEntity.is_expired()) {
        // TODO: create binary map helper
        const isImage = messageEntity.category & z.message.MessageCategory.IMAGE;
        const isGif = messageEntity.category & z.message.MessageCategory.GIF;
        if (isImage && !isGif) {
          return this.images.push(messageEntity);
        }

        const isFile = messageEntity.category & z.message.MessageCategory.FILE;
        if (isFile) {
          const isAudio = messageEntity.get_first_asset().is_audio();
          return isAudio ? this.audio.push(messageEntity) : this.files.push(messageEntity);
        }

        const isLinkPreview = messageEntity.category & z.message.MessageCategory.LINK_PREVIEW;
        if (isLinkPreview) {
          this.links.push(messageEntity);
        }
      }
    });
  }

  clickOnMessage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity(), {exposeMessage: messageEntity});
  }

  clickOnBackButton() {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, this.conversationEntity());
  }

  clickOnSection(category, items) {
    this.collectionDetails.setConversation(this.conversationEntity(), category, [].concat(items));
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION_DETAILS);
  }

  clickOnImage(messageEntity) {
    amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, messageEntity, this.images(), 'collection');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.ConnectRequestsViewModel = class ConnectRequestsViewModel {
  /**
   * View model for connection requests.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ContentViewModel} contentViewModel - Content view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, contentViewModel, repositories) {
    this.afterRender = this.afterRender.bind(this);
    this.clickOnAccept = this.clickOnAccept.bind(this);
    this.clickOnIgnore = this.clickOnIgnore.bind(this);

    this.mainViewModel = mainViewModel;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.ConnectRequestsViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;
    this.connectRequests = this.userRepository.connect_requests;

    this.shouldUpdateScrollbar = ko.computed(() => this.connectRequests()).extend({notify: 'always', rateLimit: 500});
  }

  /**
   * Called after each connection request is rendered.
   * @param {Object} elements - rendered objects
   * @param {z.entity.User} request - Rendered connection request
   * @returns {undefined} No return value
   */
  afterRender(elements, request) {
    if (z.util.ArrayUtil.isLastItem(this.connectRequests(), request)) {
      window.requestAnimationFrame(() => $('.connect-requests').scrollToBottom());
    }
  }

  /**
   * Click on accept.
   * @param {z.entity.User} userEntity - User to accept connection request from
   * @returns {undefined} No return value
   */
  clickOnAccept(userEntity) {
    const showConversation = this.connectRequests().length === 1;
    this.actionsViewModel.acceptConnectionRequest(userEntity, showConversation);
  }

  /**
   * Click on ignore.
   * @param {z.entity.User} userEntity - User to ignore connection request from
   * @returns {undefined} No return value
   */
  clickOnIgnore(userEntity) {
    this.actionsViewModel.ignoreConnectionRequest(userEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.EmojiInputViewModel = class EmojiInputViewModel {
  static get CONFIG() {
    return {
      LIST: {
        LENGTH: 5,
        OFFSET_LEFT: 8,
        OFFSET_TOP: 8,
      },
    };
  }

  // DO NOT USE COLON WITH LOWERCASE LETTERS IN THE SHORTCUTS, or you will prevent searching emojis.
  // For example, while :D should be replaced with unicode symbol, :d should allow searching for :dancer:
  /* eslint-disable sort-keys, no-multi-spaces */
  static get INLINE_REPLACEMENT() {
    return [
      {shortcut: ':)', name: 'slight smile'},
      {shortcut: ':-)', name: 'slight smile'},
      {shortcut: ':D', name: 'smile'},
      {shortcut: ':-D', name: 'smile'},
      {shortcut: ':-d', name: 'grinning'},
      {shortcut: 'B-)', name: 'sunglasses'},
      {shortcut: 'b-)', name: 'sunglasses'},
      {shortcut: '8-)', name: 'sunglasses'},
      {shortcut: ':(', name: 'disappointed'},
      {shortcut: ':-(', name: 'disappointed'},
      {shortcut: ';)', name: 'wink'},
      {shortcut: ';-)', name: 'wink'},
      {shortcut: ';-]', name: 'wink'},
      {shortcut: ';]', name: 'wink'},
      {shortcut: ':/', name: 'confused'},
      {shortcut: ':-/', name: 'confused'},
      {shortcut: ':P', name: 'stuck out tongue'},
      {shortcut: ':-P', name: 'stuck out tongue'},
      {shortcut: ':-p', name: 'stuck out tongue'},
      {shortcut: ';P', name: 'stuck out tongue winking eye'},
      {shortcut: ';-P', name: 'stuck out tongue winking eye'},
      {shortcut: ';-p', name: 'stuck out tongue winking eye'},
      {shortcut: ':O', name: 'open mouth'},
      {shortcut: ':-o', name: 'open mouth'},
      {shortcut: 'O:)', name: 'innocent'},
      {shortcut: 'O:-)', name: 'innocent'},
      {shortcut: 'o:)', name: 'innocent'},
      {shortcut: 'o:-)', name: 'innocent'},
      {shortcut: ';^)', name: 'smirk'},
      {shortcut: ':@', name: 'angry'},
      {shortcut: '>:(', name: 'rage'},
      {shortcut: '}:-)', name: 'smiling imp'},
      {shortcut: '}:)', name: 'smiling imp'},
      {shortcut: '3:-)', name: 'smiling imp'},
      {shortcut: '3:)', name: 'smiling imp'},
      {shortcut: ":'-(", name: 'cry'},
      {shortcut: ":'(", name: 'cry'},
      {shortcut: ';(', name: 'cry'},
      {shortcut: ":'-)", name: 'joy'},
      {shortcut: ":')", name: 'joy'},
      {shortcut: ':*', name: 'kissing heart'},
      {shortcut: ':^*', name: 'kissing heart'},
      {shortcut: ':-*', name: 'kissing heart'},
      {shortcut: ':-|', name: 'neutral face'},
      {shortcut: ':|', name: 'neutral face'},
      {shortcut: ':$', name: 'flushed'},
      {shortcut: ':-X', name: 'no mouth'},
      {shortcut: ':X', name: 'no mouth'},
      {shortcut: ':-#', name: 'no mouth'},
      {shortcut: ':#', name: 'no mouth'},
      {shortcut: '\\o/', name: 'raised hands'},
      {shortcut: '<3', name: 'heart'},
      {shortcut: '</3', name: 'broken heart'},
    ].sort((first, second) => {
      const isUnequalLength = first.shortcut.length !== second.shortcut.length;

      return isUnequalLength
        ? second.shortcut.length - first.shortcut.length
        : first.shortcut.localeCompare(second.shortcut);
    });
  }
  /* eslint-enable sort-keys, no-multi-spaces */

  constructor(mainViewModel, contentViewModel, repositories) {
    this.removeEmojiPopup = this.removeEmojiPopup.bind(this);
    this.updatedReplaceEmojiPreference = this.updatedReplaceEmojiPreference.bind(this);

    const EMOJI_DIV_CLASS = 'conversation-input-bar-emoji-list';
    this.INLINE_MAX_LENGTH = EmojiInputViewModel.INLINE_REPLACEMENT.reduce((accumulator, currentItem) => {
      return accumulator.length > currentItem.length ? accumulator : currentItem;
    }).length;

    this.isVisible = false;

    this.emojiList = [];
    this.emojiDict = {};

    this.emojiDiv = $(`<div class='${EMOJI_DIV_CLASS}' />`);
    this.emojiStartPosition = -1;
    this.emojiUsageCount = z.util.StorageUtil.getValue(z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT) || {};

    this.shouldReplaceEmoji = repositories.properties.getPreference(z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE);

    $(document).on('click', `.${EMOJI_DIV_CLASS}`, event => {
      const clicked = $(event.target);
      const emojiLine = clicked.hasClass('emoji') ? clicked : clicked.closest('.emoji');
      const [input] = $('#conversation-input-bar-text');
      this._enterEmojiPopupLine(input, emojiLine);
      return false;
    });

    $(document).on('mouseenter', `.${EMOJI_DIV_CLASS} .emoji`, event => {
      $(`.${EMOJI_DIV_CLASS} .emoji`).removeClass('selected');
      $(event.currentTarget).addClass('selected');
    });

    fetch('/image/emoji.json')
      .then(response => response.json())
      .then(json => {
        for (const code in json) {
          const details = json[code];

          // Ignore 'tone' emojis for now, they clutter suggestions too much.
          if (details.alpha_code.match(/_tone\d/)) {
            continue;
          }

          const icon = String.fromCodePoint.apply(null, details.output.split('-').map(char => `0x${char}`));
          const alphaCodes = [details.alpha_code, ...details.aliases.split('|')];
          alphaCodes.forEach(alphaCode => {
            if (alphaCode) {
              const name = alphaCode
                .slice(1, -1)
                .replace(/_/g, ' ')
                .toLowerCase();
              this.emojiList.push({icon, name});
              this.emojiDict[name] = icon;
            }
          });
        }
      });

    this._initSubscriptions();
  }

  onInputKeyDown(data, keyboardEvent) {
    const input = keyboardEvent.target;

    // Handling just entered inline emoji
    switch (keyboardEvent.key) {
      case z.util.KeyboardUtil.KEY.SPACE: {
        if (this._tryReplaceInlineEmoji(input)) {
          return false;
        }
        break;
      }

      case z.util.KeyboardUtil.KEY.TAB: {
        if (this._tryReplaceInlineEmoji(input)) {
          keyboardEvent.preventDefault();
          return true;
        }
        break;
      }

      default:
        break;
    }

    // Handling emoji popup
    if (this.isVisible) {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ESC: {
          this.removeEmojiPopup();
          keyboardEvent.preventDefault();
          return true;
        }

        case z.util.KeyboardUtil.KEY.ARROW_UP:
        case z.util.KeyboardUtil.KEY.ARROW_DOWN: {
          this._rotateEmojiPopup(z.util.KeyboardUtil.isKey(keyboardEvent, z.util.KeyboardUtil.KEY.ARROW_UP));
          this.suppressKeyUp = true;
          keyboardEvent.preventDefault();
          return true;
        }

        case z.util.KeyboardUtil.KEY.ENTER:
        case z.util.KeyboardUtil.KEY.TAB: {
          if (keyboardEvent.shiftKey && z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
            break;
          }

          this._enterEmojiPopupLine(input, this.emojiDiv.find('.emoji.selected'));
          keyboardEvent.preventDefault();
          return true;
        }

        default:
          break;
      }
    }

    // Handling inline emoji in the whole text
    if (z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
      this._replaceAllInlineEmoji(input);
    }

    return false;
  }

  onInputKeyUp(data, keyboardEvent) {
    if (this.suppressKeyUp) {
      this.suppressKeyUp = false;
      return true;
    }

    const input = keyboardEvent.target;
    const {selectionStart: selection, value: text} = input;

    if (text) {
      const popupTrigger = text.slice(Math.max(selection - 2, 0), selection);
      const containsPopupTrigger = /\B:$/.test(popupTrigger);
      if (containsPopupTrigger) {
        this.emojiStartPosition = selection;
        this._updateEmojiPopup(input);
      } else if (this.emojiStartPosition !== -1) {
        if (selection < this.emojiStartPosition || text[this.emojiStartPosition - 1] !== ':') {
          this.removeEmojiPopup();
        } else {
          this._updateEmojiPopup(input);
        }
      }
    }

    return true;
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this.removeEmojiPopup);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATE.EMOJI.REPLACE_INLINE, this.updatedReplaceEmojiPreference);
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, properties => {
      this.updatedReplaceEmojiPreference(properties.settings.emoji.replace_inline);
    });
  }

  updatedReplaceEmojiPreference(preference) {
    this.shouldReplaceEmoji = preference;
  }

  _tryReplaceInlineEmoji(input) {
    const {selectionStart: selection, value: text} = input;

    if (this.shouldReplaceEmoji && text) {
      const textUntilCursor = text.substring(Math.max(0, selection - this.INLINE_MAX_LENGTH - 1), selection);

      for (const replacement of EmojiInputViewModel.INLINE_REPLACEMENT) {
        const icon = this.emojiDict[replacement.name];
        if (icon) {
          const validInlineEmojiRegEx = new RegExp(`(^|\\s)${this._escapeRegexp(replacement.shortcut)}$`);

          if (validInlineEmojiRegEx.test(textUntilCursor)) {
            this.emojiStartPosition = selection - replacement.shortcut.length + 1;
            this._enterEmoji(input, icon);

            return true;
          }
        }
      }
    }

    return false;
  }

  _replaceAllInlineEmoji(input) {
    if (!this.shouldReplaceEmoji) {
      return false;
    }

    const {selectionStart: selection, value: text} = input;
    let textBeforeCursor = text.substr(0, selection);
    let textAfterCursor = text.substr(selection);

    for (const replacement of EmojiInputViewModel.INLINE_REPLACEMENT) {
      const icon = this.emojiDict[replacement.name];

      if (icon) {
        const validIInlineEmojiRegex = new RegExp(`(^|\\s)${this._escapeRegexp(replacement.shortcut)}(?=\\s|$)`, 'g');
        textBeforeCursor = textBeforeCursor.replace(validIInlineEmojiRegex, `$1${icon}`);
        textAfterCursor = textAfterCursor.replace(validIInlineEmojiRegex, `$1${icon}`);
      }
    }

    input.value = `${textBeforeCursor}${textAfterCursor}`;
    input.setSelectionRange(textBeforeCursor.length, textBeforeCursor.length);
    $(input).change();
    $(input).focus();
  }

  _updateEmojiPopup(input) {
    const {selectionStart: selection, value: text} = input;
    if (!text) {
      return;
    }

    const query = text.substr(this.emojiStartPosition, selection - this.emojiStartPosition);
    if (!query.length) {
      return this._closeEmojiPopup();
    }

    const shouldRemovePopup = !this.emojiList.length || query.startsWith(' ') || /\s{2,}/.test(query);
    if (shouldRemovePopup) {
      return this.removeEmojiPopup();
    }

    const queryWords = query.split(' ');
    const expectedWords = (query.match(/\s/g) || []).length + 1;

    const emojiMatched = this.emojiList
      .filter(emoji => {
        const emojiNameWords = emoji.name.split(' ');

        if (emojiNameWords.length < expectedWords) {
          return false;
        }

        return queryWords.every(queryWord => {
          return emojiNameWords.some(emojiNameWord => emojiNameWord.startsWith(queryWord));
        });
      })
      .reduce((accumulator, emoji) => {
        const iconNotFound = !accumulator.find(item => item.icon === emoji.icon);
        if (iconNotFound) {
          accumulator.push(emoji);
        }
        return accumulator;
      }, [])
      .sort((emojiA, emojiB) => {
        const usageCountA = this._getUsageCount(emojiA.name);
        const usageCountB = this._getUsageCount(emojiB.name);

        const sameUsageCount = usageCountA === usageCountB;
        return sameUsageCount
          ? z.util.StringUtil.sortByPriority(emojiA.name, emojiB.name, query)
          : usageCountB - usageCountA;
      })
      .slice(0, EmojiInputViewModel.CONFIG.LIST.LENGTH)
      .map(emoji => {
        return `
          <div class='emoji'>
            <span class='symbol'>${emoji.icon}</span><span class='name'>${emoji.name}</span>
          </div>`;
      })
      .join('');

    if (emojiMatched === '') {
      return this._closeEmojiPopup();
    }

    window.addEventListener('click', this.removeEmojiPopup);
    this.isVisible = true;
    this.emojiDiv
      .html(emojiMatched)
      .appendTo('body')
      .show();
    this.emojiDiv.find('.emoji:nth(0)').addClass('selected');

    const position = z.util.popup.getCursorPixelPosition(input);
    const top = position.top - this.emojiDiv.height() - EmojiInputViewModel.CONFIG.LIST.OFFSET_TOP;
    const left = position.left - EmojiInputViewModel.CONFIG.LIST.OFFSET_LEFT;

    this.emojiDiv.css('left', left);
    this.emojiDiv.css('top', top);
  }

  _rotateEmojiPopup(backward) {
    const previous = this.emojiDiv.find('.emoji.selected');
    const newSelection = (previous.index() + (backward ? -1 : 1)) % this.emojiDiv.find('.emoji').length;
    previous.removeClass('selected');
    this.emojiDiv.find(`.emoji:nth(${newSelection})`).addClass('selected');
  }

  _enterEmojiPopupLine(input, emojiLine) {
    const emojiIcon = emojiLine.find('.symbol').text();
    const emojiName = emojiLine
      .find('.name')
      .text()
      .toLowerCase();

    this._enterEmoji(input, emojiIcon);
    this._increaseUsageCount(emojiName); // only emojis selected from the list should affect the count
  }

  _enterEmoji(input, emojiIcon) {
    const {selectionStart: selection, value: text} = input;

    const textBeforeEmoji = text.substr(0, this.emojiStartPosition - 1);
    const textAfterEmoji = text.substr(selection);
    const newCursorPosition = textBeforeEmoji.length + emojiIcon.length;
    input.value = `${textBeforeEmoji}${emojiIcon}${textAfterEmoji}`;
    input.setSelectionRange(newCursorPosition, newCursorPosition);
    this.removeEmojiPopup();
    $(input).change();
    $(input).focus();
  }

  _closeEmojiPopup() {
    this.isVisible = false;
    window.removeEventListener('click', this.removeEmojiPopup);
    this.emojiDiv.remove();
  }

  removeEmojiPopup() {
    this._closeEmojiPopup();
    this.emojiStartPosition = -1;
  }

  _getUsageCount(emojiName) {
    return this.emojiUsageCount[emojiName] || 0;
  }

  _increaseUsageCount(emojiName) {
    this.emojiUsageCount[emojiName] = this._getUsageCount(emojiName) + 1;
    z.util.StorageUtil.setValue(z.storage.StorageKey.CONVERSATION.EMOJI_USAGE_COUNT, this.emojiUsageCount);
  }

  _escapeRegexp(string) {
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.GiphyViewModel = class GiphyViewModel {
  static get CONFIG() {
    return {
      NUMBER_OF_GIFS: 6,
    };
  }

  static get STATE() {
    return {
      DEFAULT: '',
      ERROR: 'GiphyViewModel.STATE.ERROR',
      LOADING: 'GiphyViewModel.STATE.LOADING',
      RESULT: 'GiphyViewModel.STATE.RESULT',
      RESULTS: 'GiphyViewModel.STATE.RESULTS',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.clickToSelectGif = this.clickToSelectGif.bind(this);

    this.conversationRepository = repositories.conversation;
    this.giphyRepository = repositories.giphy;
    this.logger = new z.util.Logger('z.viewModel.content.GiphyViewModel', z.config.LOGGER.OPTIONS);

    this.modal = undefined;
    this.state = ko.observable(GiphyViewModel.STATE.DEFAULT);
    this.query = ko.observable('');
    this.sendingGiphyMessage = false;

    // GIF presented in the single GIF view
    this.gif = ko.observable();

    // GIFs rendered in the modal
    this.gifs = ko.observableArray();

    // GIF selected by user or single GIF when in single GIF view
    this.selectedGif = ko.observable();

    this.isStateError = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.ERROR);
    this.isStateLoading = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.LOADING);
    this.isStateResult = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.RESULT);
    this.isStateResults = ko.pureComputed(() => this.state() === GiphyViewModel.STATE.RESULTS);

    this.isResultState = ko.pureComputed(() => {
      return [GiphyViewModel.STATE.RESULT, GiphyViewModel.STATE.RESULTS].includes(this.state());
    });

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.EXTENSIONS.GIPHY.SHOW, this.showGiphy.bind(this));
  }

  clickOnBack() {
    this.gifs([this.gif()]);
    this.selectedGif(this.gif());
    this.state(GiphyViewModel.STATE.RESULT);
  }

  clickOnClose() {
    this.modal.hide();
  }

  clickOnTryAnother() {
    this._getRandomGif();
  }

  clickOnGrid() {
    this._getRandomGifs();
  }

  clickToSelectGif(clickedGif, event) {
    const hasMultipleGifs = this.gifs().length !== 1;
    if (hasMultipleGifs) {
      const gifItem = $(event.currentTarget);
      const gifItems = gifItem.parent().children();

      const remove_unselected = function() {
        $(this).removeClass('gif-container-item-unselected');
      };

      const add_unselected = function() {
        $(this).addClass('gif-container-item-unselected');
      };

      if (this.selectedGif() === clickedGif) {
        gifItems.each(remove_unselected);
        this.selectedGif(undefined);
      } else {
        gifItems.each(add_unselected);
        remove_unselected.apply(gifItem);
        this.selectedGif(clickedGif);
      }
    }
  }

  clickToSend() {
    if (this.selectedGif() && !this.sendingGiphyMessage) {
      const conversationEntity = this.conversationRepository.active_conversation();
      this.sendingGiphyMessage = true;

      this.conversationRepository.sendGif(conversationEntity, this.selectedGif().animated, this.query()).then(() => {
        this.sendingGiphyMessage = false;
        amplify.publish(z.event.WebApp.EXTENSIONS.GIPHY.SEND);
      });

      this.modal.hide();
    }
  }

  showGiphy(query) {
    this.sendingGiphyMessage = false;
    this.query(query);
    this.state(GiphyViewModel.STATE.DEFAULT);
    this._getRandomGif();

    if (!this.modal) {
      this.modal = new z.ui.Modal('#giphy-modal');
    }

    this.modal.show();
  }

  _clearGifs() {
    this.gifs.removeAll();
    this.selectedGif(undefined);
    this.state(GiphyViewModel.STATE.LOADING);
  }

  _getRandomGif() {
    const isStateError = this.state() === GiphyViewModel.STATE.ERROR;
    if (!isStateError) {
      this._clearGifs();

      this.giphyRepository
        .getRandomGif({tag: this.query()})
        .then(gif => {
          this.gif(gif);
          this.gifs([this.gif()]);
          this.selectedGif(this.gif());
          this.state(GiphyViewModel.STATE.RESULT);
        })
        .catch(error => {
          this.logger.error(`No gif found for query: ${this.query()}`, error);
          this.state(GiphyViewModel.STATE.ERROR);
        });
    }
  }

  _getRandomGifs() {
    const isStateError = this.state() === GiphyViewModel.STATE.ERROR;
    if (!isStateError) {
      this._clearGifs();

      this.giphyRepository
        .getGifs({
          number: GiphyViewModel.CONFIG.NUMBER_OF_GIFS,
          query: this.query(),
        })
        .then(gifs => {
          this.gifs(gifs);

          if (gifs.length === 1) {
            this.selectedGif(gifs[0]);
          }

          this.state(GiphyViewModel.STATE.RESULTS);
        })
        .catch(error => {
          this.logger.error(`No gifs found for query: ${this.query()}`, error);
          this.state(GiphyViewModel.STATE.ERROR);
        });
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.GroupCreationViewModel = class GroupCreationViewModel {
  static get STATE() {
    return {
      DEFAULT: 'GroupCreationViewModel.STATE.DEFAULT',
      PARTICIPANTS: 'GroupCreationViewModel.STATE.PARTICIPANTS',
      PREFERENCES: 'GroupCreationViewModel.STATE.PREFERENCES',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.GroupCreationViewModel', z.config.LOGGER.OPTIONS);

    this.clickOnCreate = this.clickOnCreate.bind(this);
    this.clickOnToggleGuestMode = this.clickOnToggleGuestMode.bind(this);

    this.conversationRepository = repositories.conversation;
    this.searchRepository = repositories.search;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.isTeam = this.teamRepository.isTeam;

    this.modal = undefined;
    this.state = ko.observable(GroupCreationViewModel.STATE.DEFAULT);

    this.isCreatingConversation = false;
    this.method = undefined;
    this.nameError = ko.observable('');
    this.nameInput = ko.observable('');
    this.selectedContacts = ko.observableArray([]);
    this.showContacts = ko.observable(false);
    this.participantsInput = ko.observable('');

    this.accessState = ko.observable(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isGuestRoom = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isGuestRoom.subscribe(isGuestRoom => {
      if (!isGuestRoom) {
        this.selectedContacts.remove(userEntity => !userEntity.isTeamMember());
      }
    });

    this.activateNext = ko.pureComputed(() => this.nameInput().length);
    this.contacts = ko.pureComputed(() => {
      if (this.showContacts()) {
        if (!this.isTeam()) {
          return this.userRepository.connected_users();
        }

        if (this.isGuestRoom()) {
          return this.userRepository.teamUsers();
        }

        return this.teamRepository
          .teamMembers()
          .sort((userA, userB) => z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name()));
      }
      return [];
    });
    this.participantsActionText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.groupCreationParticipantsActionCreate
        : z.string.groupCreationParticipantsActionSkip;
      return z.l10n.text(stringSelector);
    });
    this.participantsHeaderText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.groupCreationParticipantsHeaderWithCounter
        : z.string.groupCreationParticipantsHeader;
      return z.l10n.text(stringSelector, {number: this.selectedContacts().length});
    });
    this.stateIsPreferences = ko.pureComputed(() => this.state() === GroupCreationViewModel.STATE.PREFERENCES);
    this.stateIsParticipants = ko.pureComputed(() => this.state() === GroupCreationViewModel.STATE.PARTICIPANTS);

    this.nameInput.subscribe(() => this.nameError(''));
    this.stateIsPreferences.subscribe(stateIsPreference => {
      if (stateIsPreference) {
        return $(document).on('keydown.groupCreation', keyboardEvent => {
          if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
            this._hideModal();
          }
        });
      }
      return $(document).off('keydown.groupCreation');
    });
    this.stateIsParticipants.subscribe(stateIsParticipants => {
      if (stateIsParticipants) {
        return window.setTimeout(() => this.showContacts(true));
      }
      this.showContacts(false);
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedContacts() && this.stateIsPreferences() && this.contacts())
      .extend({notify: 'always', rateLimit: 500});

    amplify.subscribe(z.event.WebApp.CONVERSATION.CREATE_GROUP, this.showCreateGroup.bind(this));
  }

  showCreateGroup(method, userEntity) {
    this.method = method;

    if (!this.modal) {
      this.modal = new z.ui.Modal('#group-creation-modal', this._afterHideModal.bind(this));
      this.modal.setAutoclose(false);
    }

    this.state(GroupCreationViewModel.STATE.PREFERENCES);
    if (userEntity) {
      this.selectedContacts.push(userEntity);
    }

    this.modal.show();
    $('.group-creation-modal-teamname-input').focus();

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.OPENED_GROUP_CREATION, {
      method: this.method,
    });
  }

  clickOnBack() {
    this.state(GroupCreationViewModel.STATE.PREFERENCES);
  }

  clickOnClose() {
    this._hideModal();
  }

  clickOnToggleGuestMode() {
    const accessState = this.isGuestRoom()
      ? z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY
      : z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM;

    this.accessState(accessState);
  }

  clickOnCreate() {
    if (!this.isCreatingConversation) {
      this.isCreatingConversation = true;

      const accessState = this.isTeam() ? this.accessState() : undefined;

      this.conversationRepository
        .createGroupConversation(this.selectedContacts(), this.nameInput(), accessState)
        .then(conversationEntity => {
          this._hideModal();

          amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);

          this._trackGroupCreation(conversationEntity);
        })
        .catch(error => {
          this.isCreatingConversation = false;
          throw error;
        });
    }
  }

  clickOnNext() {
    if (this.nameInput().length) {
      const trimmedNameInput = this.nameInput().trim();
      const nameTooLong = trimmedNameInput.length > z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH;
      const nameTooShort = !trimmedNameInput.length;

      this.nameInput(trimmedNameInput.slice(0, z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH));
      if (nameTooLong) {
        return this.nameError(z.l10n.text(z.string.groupCreationPreferencesErrorNameLong));
      }

      if (nameTooShort) {
        return this.nameError(z.l10n.text(z.string.groupCreationPreferencesErrorNameShort));
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.OPENED_SELECT_PARTICIPANTS, {
        method: this.method,
      });

      this.state(GroupCreationViewModel.STATE.PARTICIPANTS);
    }
  }

  _afterHideModal() {
    this.isCreatingConversation = false;
    this.method = undefined;
    this.nameError('');
    this.nameInput('');
    this.participantsInput('');
    this.selectedContacts([]);
    this.state(GroupCreationViewModel.STATE.DEFAULT);
    this.accessState(z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
  }

  _hideModal() {
    if (this.modal) {
      this.modal.hide();
    }
  }

  _trackGroupCreation(conversationEntity) {
    this._trackGroupCreationSucceeded(conversationEntity);
    this._trackAddParticipants(conversationEntity);
  }

  _trackGroupCreationSucceeded(conversationEntity) {
    const attributes = {
      method: this.method,
      with_participants: !!this.selectedContacts().length,
    };

    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      attributes.is_allow_guests = !conversationEntity.isTeamOnly();
    }

    const eventName = z.tracking.EventName.CONVERSATION.GROUP_CREATION_SUCCEEDED;
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, eventName, attributes);
  }

  _trackAddParticipants(conversationEntity) {
    const attributes = {
      method: 'create',
      user_num: conversationEntity.getNumberOfParticipants(),
    };

    const isTeamConversation = !!conversationEntity.team_id;
    if (isTeamConversation) {
      const participants = z.tracking.helpers.getParticipantTypes(conversationEntity.participating_user_ets(), true);

      Object.assign(attributes, {
        guest_num: participants.guests,
        is_allow_guests: conversationEntity.isGuestRoom(),
        temporary_guest_num: participants.temporaryGuests,
        user_num: participants.users,
      });
    }

    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.ADD_PARTICIPANTS, attributes);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.HistoryExportViewModel = class HistoryExportViewModel {
  static get STATE() {
    return {
      COMPRESSING: 'HistoryExportViewModel.STATE.COMPRESSING',
      DONE: 'HistoryExportViewModel.STATE.DONE',
      EXPORTING: 'HistoryExportViewModel.STATE.EXPORTING',
      PREPARING: 'HistoryExportViewModel.STATE.PREPARING',
    };
  }

  static get CONFIG() {
    return {
      FILE_EXTENSION: 'desktop_wbu',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.backupRepository = repositories.backup;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.HistoryExportViewModel', z.config.LOGGER.OPTIONS);

    this.hasError = ko.observable(false);
    this.state = ko.observable(HistoryExportViewModel.STATE.PREPARING);
    this.isPreparing = ko.pureComputed(() => {
      return !this.hasError() && this.state() === HistoryExportViewModel.STATE.PREPARING;
    });
    this.isExporting = ko.pureComputed(() => {
      const exportingStates = [HistoryExportViewModel.STATE.EXPORTING, HistoryExportViewModel.STATE.COMPRESSING];
      return !this.hasError() && exportingStates.includes(this.state());
    });
    this.isDone = ko.pureComputed(() => !this.hasError() && this.state() === HistoryExportViewModel.STATE.DONE);

    this.numberOfRecords = ko.observable(0);
    this.numberOfProcessedRecords = ko.observable(0);
    this.loadingProgress = ko.pureComputed(() => {
      return Math.floor((this.numberOfProcessedRecords() / this.numberOfRecords()) * 100);
    });

    this.archiveBlob = ko.observable(null);

    this.loadingMessage = ko.pureComputed(() => {
      switch (this.state()) {
        case HistoryExportViewModel.STATE.PREPARING: {
          return z.l10n.text(z.string.backupExportProgressHeadline);
        }
        case HistoryExportViewModel.STATE.EXPORTING: {
          const replacements = {
            processed: this.numberOfProcessedRecords(),
            progress: this.loadingProgress(),
            total: this.numberOfRecords(),
          };
          return z.l10n.text(z.string.backupExportProgressSecondary, replacements);
        }
        case HistoryExportViewModel.STATE.COMPRESSING: {
          return z.l10n.text(z.string.backupExportProgressCompressing);
        }
        default:
          return '';
      }
    });

    amplify.subscribe(z.event.WebApp.BACKUP.EXPORT.START, this.exportHistory.bind(this));
  }

  exportHistory() {
    this.state(HistoryExportViewModel.STATE.PREPARING);
    this.hasError(false);
    this.backupRepository.getBackupInitData().then(numberOfRecords => {
      this.logger.log(`Exporting '${numberOfRecords}' records from history`);

      this.numberOfRecords(numberOfRecords);
      this.numberOfProcessedRecords(0);

      this.backupRepository
        .generateHistory(this.onProgress.bind(this))
        .then(archive => {
          this.state(HistoryExportViewModel.STATE.COMPRESSING);
          return archive.generateAsync({compression: 'DEFLATE', type: 'blob'});
        })
        .then(archiveBlob => {
          this.onSuccess(archiveBlob);
          this.logger.log(`Completed export of '${numberOfRecords}' records from history`);
        })
        .catch(this.onError.bind(this));
    });
  }

  downloadArchiveFile() {
    const userName = this.userRepository.self().username();
    const fileExtension = HistoryExportViewModel.CONFIG.FILE_EXTENSION;
    const filename = `Wire-${userName}-Backup_${z.util.TimeUtil.getCurrentDate()}.${fileExtension}`;

    this.dismissExport();
    z.util.downloadBlob(this.archiveBlob(), filename, 'application/octet-stream');
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.BACKUP_SUCCEEDED);
  }

  onCancel() {
    this.backupRepository.cancelAction();
  }

  onProgress(processedNumber) {
    this.state(HistoryExportViewModel.STATE.EXPORTING);
    this.numberOfProcessedRecords(this.numberOfProcessedRecords() + processedNumber);
  }

  onError(error) {
    if (error instanceof z.backup.CancelError) {
      this.logger.log(`History export was cancelled`);
      return this.dismissExport();
    }
    this.hasError(true);
    this.logger.error(`Failed to export history: ${error.message}`, error);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.BACKUP_FAILED);
  }

  onSuccess(archiveBlob) {
    this.state(HistoryExportViewModel.STATE.DONE);
    this.hasError(false);
    this.archiveBlob(archiveBlob);
  }

  onTryAgain() {
    this.exportHistory();
  }

  dismissExport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.HistoryImportViewModel = class HistoryImportViewModel {
  static get STATE() {
    return {
      DONE: 'HistoryImportViewModel.STATE.DONE',
      IMPORTING: 'HistoryImportViewModel.STATE.IMPORTING',
      PREPARING: 'HistoryImportViewModel.STATE.PREPARING',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.backupRepository = repositories.backup;

    this.logger = new z.util.Logger('z.viewModel.content.HistoryExportViewModel', z.config.LOGGER.OPTIONS);

    this.error = ko.observable(null);
    this.errorHeadline = ko.observable('');
    this.errorSecondary = ko.observable('');

    this.state = ko.observable(HistoryImportViewModel.STATE.PREPARING);
    this.isPreparing = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.PREPARING);
    this.isImporting = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.IMPORTING);
    this.isDone = ko.pureComputed(() => !this.error() && this.state() === HistoryImportViewModel.STATE.DONE);

    this.numberOfRecords = ko.observable(0);
    this.numberOfProcessedRecords = ko.observable(0);
    this.loadingProgress = ko.pureComputed(() => {
      return Math.floor((this.numberOfProcessedRecords() / this.numberOfRecords()) * 100);
    });

    this.loadingMessage = ko.pureComputed(() => {
      switch (this.state()) {
        case HistoryImportViewModel.STATE.PREPARING: {
          return z.l10n.text(z.string.backupImportProgressHeadline);
        }
        case HistoryImportViewModel.STATE.IMPORTING: {
          const replacements = {
            processed: this.numberOfProcessedRecords(),
            progress: this.loadingProgress(),
            total: this.numberOfRecords(),
          };
          return z.l10n.text(z.string.backupImportProgressSecondary, replacements);
        }
        default:
          return '';
      }
    });

    this.error.subscribe(error => {
      if (!error) {
        this.errorHeadline('');
        this.errorSecondary('');
      } else if (error instanceof z.backup.DifferentAccountError) {
        this.errorHeadline(z.l10n.text(z.string.backupImportAccountErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportAccountErrorSecondary));
      } else if (error instanceof z.backup.IncompatibleBackupError) {
        this.errorHeadline(z.l10n.text(z.string.backupImportVersionErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportVersionErrorSecondary));
      } else {
        this.errorHeadline(z.l10n.text(z.string.backupImportGenericErrorHeadline));
        this.errorSecondary(z.l10n.text(z.string.backupImportGenericErrorSecondary));
      }
    });

    amplify.subscribe(z.event.WebApp.BACKUP.IMPORT.START, this.importHistory.bind(this));
  }

  importHistory(file) {
    this.state(HistoryImportViewModel.STATE.PREPARING);
    this.error(null);
    JSZip.loadAsync(file)
      .then(archive => this.backupRepository.importHistory(archive, this.onInit.bind(this), this.onProgress.bind(this)))
      .then(this.onSuccess.bind(this))
      .catch(this.onError.bind(this));
  }

  onInit(numberOfRecords) {
    this.state(HistoryImportViewModel.STATE.IMPORTING);
    this.numberOfRecords(numberOfRecords);
    this.numberOfProcessedRecords(0);
  }

  onProgress(numberProcessed) {
    this.numberOfProcessedRecords(this.numberOfProcessedRecords() + numberProcessed);
  }

  onSuccess() {
    this.error(null);
    this.state(HistoryImportViewModel.STATE.DONE);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.RESTORE_SUCCEEDED);
    window.setTimeout(this.dismissImport.bind(this), z.motion.MotionDuration.X_LONG * 2);
  }

  onCancel() {
    this.backupRepository.cancelAction();
  }

  dismissImport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  onError(error) {
    if (error instanceof z.backup.CancelError) {
      this.logger.log(`History import was cancelled`);
      return this.dismissImport();
    }
    this.error(error);
    this.logger.error(`Failed to import history: ${error.message}`, error);
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.HISTORY.RESTORE_FAILED);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.InputBarViewModel = class InputBarViewModel {
  static get CONFIG() {
    return {
      ASSETS: {
        CONCURRENT_UPLOAD_LIMIT: 10,
      },
      GIPHY_TEXT_LENGTH: 256,
      IMAGE: {
        FILE_TYPES: ['image/bmp', 'image/gif', 'image/jpeg', 'image/jpg', 'image/png', '.jpg-large'],
      },
      PING_TIMEOUT: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 2,
    };
  }

  constructor(mainViewModel, contentViewModel, repositories, messageHasher) {
    this.addedToView = this.addedToView.bind(this);
    this.addMention = this.addMention.bind(this);
    this.clickToPing = this.clickToPing.bind(this);
    this.endMentionFlow = this.endMentionFlow.bind(this);
    this.onDropFiles = this.onDropFiles.bind(this);
    this.onPasteFiles = this.onPasteFiles.bind(this);
    this.onWindowClick = this.onWindowClick.bind(this);
    this.setElements = this.setElements.bind(this);
    this.updateSelectionState = this.updateSelectionState.bind(this);

    this.messageHasher = messageHasher;

    this.shadowInput = null;
    this.textarea = null;

    this.selectionStart = ko.observable(0);
    this.selectionEnd = ko.observable(0);

    this.emojiInput = contentViewModel.emojiInput;

    this.eventRepository = repositories.event;
    this.conversationRepository = repositories.conversation;
    this.searchRepository = repositories.search;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.InputBarViewModel', z.config.LOGGER.OPTIONS);

    this.conversationEntity = this.conversationRepository.active_conversation;
    this.selfUser = this.userRepository.self;

    this.conversationHasFocus = ko.observable(true).extend({notify: 'always'});

    this.editMessageEntity = ko.observable();
    this.replyMessageEntity = ko.observable();

    const handleRepliedMessageDeleted = messageId => {
      if (this.replyMessageEntity() && this.replyMessageEntity().id === messageId) {
        this.replyMessageEntity(undefined);
      }
    };

    const handleRepliedMessageUpdated = (originalMessageId, messageEntity) => {
      if (this.replyMessageEntity() && this.replyMessageEntity().id === originalMessageId) {
        this.replyMessageEntity(messageEntity);
      }
    };

    ko.pureComputed(() => !!this.replyMessageEntity())
      .extend({notify: 'always', rateLimit: 100})
      .subscribeChanged((isReplyingToMessage, wasReplyingToMessage) => {
        if (isReplyingToMessage !== wasReplyingToMessage) {
          this.triggerInputChangeEvent();
          if (isReplyingToMessage) {
            amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleRepliedMessageDeleted);
            amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleRepliedMessageUpdated);
          } else {
            amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleRepliedMessageDeleted);
            amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleRepliedMessageUpdated);
          }
        }
      });

    this.replyAsset = ko.pureComputed(() => {
      return this.replyMessageEntity() && this.replyMessageEntity().assets() && this.replyMessageEntity().assets()[0];
    });

    this.isEditing = ko.pureComputed(() => !!this.editMessageEntity());
    this.isReplying = ko.pureComputed(() => !!this.replyMessageEntity());
    this.replyMessageId = ko.pureComputed(() => (this.replyMessageEntity() ? this.replyMessageEntity().id : undefined));

    this.pastedFile = ko.observable();
    this.pastedFilePreviewUrl = ko.observable();
    this.pastedFileName = ko.observable();

    this.pingDisabled = ko.observable(false);

    this.editedMention = ko.observable(undefined);
    this.currentMentions = ko.observableArray();

    this.hasFocus = ko.pureComputed(() => this.isEditing() || this.conversationHasFocus()).extend({notify: 'always'});
    this.hasTextInput = ko.pureComputed(() => this.input().length);

    this.input = ko.observable('');

    this.input.subscribeChanged((newValue, oldValue) => {
      const difference = newValue.length - oldValue.length;
      const updatedMentions = this.updateMentionRanges(
        this.currentMentions(),
        this.selectionStart(),
        this.selectionEnd(),
        difference
      );
      this.currentMentions(updatedMentions);
      this.updateSelectionState();
    });

    this.draftMessage = ko
      .pureComputed(() => {
        const text = this.input();
        const mentions = this.currentMentions();
        const reply = this.replyMessageEntity();
        return {mentions, reply, text};
      })
      .extend({rateLimit: {method: 'notifyWhenChangesStop', timeout: 1}});

    this.mentionSuggestions = ko.pureComputed(() => {
      if (!this.editedMention() || !this.conversationEntity()) {
        return [];
      }

      const candidates = this.conversationEntity()
        .participating_user_ets()
        .filter(userEntity => !userEntity.isService);
      return this.searchRepository.searchUserInSet(this.editedMention().term, candidates);
    });

    this.richTextInput = ko.pureComputed(() => {
      const mentionAttributes = ' class="input-mention" data-uie-name="item-input-mention"';
      const pieces = this.currentMentions()
        .slice()
        .reverse()
        .reduce(
          (currentPieces, mentionEntity) => {
            const currentPiece = currentPieces.shift();
            currentPieces.unshift(currentPiece.substr(mentionEntity.endIndex));
            currentPieces.unshift(currentPiece.substr(mentionEntity.startIndex, mentionEntity.length));
            currentPieces.unshift(currentPiece.substr(0, mentionEntity.startIndex));
            return currentPieces;
          },
          [this.input()]
        );

      return pieces
        .map((piece, index) => {
          const textPiece = z.util.SanitizationUtil.escapeString(piece).replace(/[\r\n]/g, '<br>');
          return `<span${index % 2 ? mentionAttributes : ''}>${textPiece}</span>`;
        })
        .join('')
        .replace(/<br><\/span>$/, '<br>&nbsp;</span>');
    });

    this.richTextInput.subscribe(() => {
      if (this.textarea && this.shadowInput) {
        z.util.afterRender(() => {
          if (this.shadowInput.scrollTop !== this.textarea.scrollTop) {
            this.shadowInput.scrollTop = this.textarea.scrollTop;
          }
        });
      }
    });

    this.inputPlaceholder = ko.pureComputed(() => {
      if (this.showAvailabilityTooltip()) {
        const userEntity = this.conversationEntity().firstUserEntity();
        const availabilityStrings = {
          [z.user.AvailabilityType.AVAILABLE]: z.string.tooltipConversationInputPlaceholderAvailable,
          [z.user.AvailabilityType.AWAY]: z.string.tooltipConversationInputPlaceholderAway,
          [z.user.AvailabilityType.BUSY]: z.string.tooltipConversationInputPlaceholderBusy,
        };

        return z.l10n.text(availabilityStrings[userEntity.availability()], userEntity.first_name());
      }

      const stringId = this.conversationEntity().messageTimer()
        ? z.string.tooltipConversationEphemeral
        : z.string.tooltipConversationInputPlaceholder;

      return z.l10n.text(stringId);
    });

    this.showAvailabilityTooltip = ko.pureComputed(() => {
      if (this.conversationEntity() && this.conversationEntity().firstUserEntity()) {
        const isOne2OneConversation = this.conversationEntity().is1to1();
        const firstUserEntity = this.conversationEntity().firstUserEntity();
        const availabilityIsNone = firstUserEntity.availability() === z.user.AvailabilityType.NONE;
        return this.selfUser().inTeam() && isOne2OneConversation && !availabilityIsNone;
      }

      return false;
    });

    this.showGiphyButton = ko.pureComputed(() => {
      return this.hasTextInput() && this.input().length <= InputBarViewModel.CONFIG.GIPHY_TEXT_LENGTH;
    });

    const pingShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.PING);
    this.pingTooltip = z.l10n.text(z.string.tooltipConversationPing, pingShortcut);

    this.isEditing.subscribe(isEditing => {
      if (isEditing) {
        return window.addEventListener('click', this.onWindowClick);
      }

      window.removeEventListener('click', this.onWindowClick);
    });

    this.pastedFile.subscribe(blob => {
      if (blob) {
        const isSupportedFileType = InputBarViewModel.CONFIG.IMAGE.FILE_TYPES.includes(blob.type);
        if (isSupportedFileType) {
          this.pastedFilePreviewUrl(URL.createObjectURL(blob));
        }

        const date = moment(blob.lastModifiedDate).format('MMMM Do YYYY, h:mm:ss a');
        return this.pastedFileName(z.l10n.text(z.string.conversationSendPastedFile, date));
      }

      this.pastedFilePreviewUrl(null);
      this.pastedFileName(null);
    });

    this.hasLocalEphemeralTimer = ko.pureComputed(() => {
      const conversationEntity = this.conversationEntity();
      return conversationEntity.localMessageTimer() && !conversationEntity.hasGlobalMessageTimer();
    });

    this.conversationEntity.subscribe(this.loadInitialStateForConversation.bind(this));
    this.draftMessage.subscribe(message => {
      if (this.conversationEntity()) {
        this._saveDraftState(this.conversationEntity(), message.text, message.mentions, message.reply);
      }
    });

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.IMAGE.SEND, this.uploadImages.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.EDIT, this.editMessage.bind(this));
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, this.replyMessage.bind(this));
    amplify.subscribe(z.event.WebApp.EXTENSIONS.GIPHY.SEND, this.sendGiphy.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.SHOW, () => this.conversationHasFocus(false));
    amplify.subscribe(z.event.WebApp.SEARCH.HIDE, () => {
      window.requestAnimationFrame(() => this.conversationHasFocus(true));
    });
  }

  setElements(nodes) {
    this.textarea = nodes.find(node => node.id === 'conversation-input-bar-text');
    this.shadowInput = nodes.find(node => node.classList && node.classList.contains('shadow-input'));
    this.updateSelectionState();
  }

  loadInitialStateForConversation(conversationEntity) {
    this.conversationHasFocus(true);
    this.pastedFile(null);
    this.cancelMessageEditing();
    this.cancelMessageReply();
    this.endMentionFlow();

    if (conversationEntity) {
      const previousSessionData = this._loadDraftState(conversationEntity);
      this.input(previousSessionData.text);
      this.currentMentions(previousSessionData.mentions);

      if (previousSessionData.replyEntityPromise) {
        previousSessionData.replyEntityPromise.then(replyEntity => {
          if (replyEntity && replyEntity.isReplyable()) {
            this.replyMessageEntity(replyEntity);
          }
        });
      }
    }
  }

  _saveDraftState(conversationEntity, text, mentions, reply) {
    if (!this.isEditing()) {
      // we only save state for newly written messages
      reply = reply && reply.id ? {messageId: reply.id} : {};
      const storageKey = this._generateStorageKey(conversationEntity);
      z.util.StorageUtil.setValue(storageKey, {mentions, reply, text});
    }
  }

  _generateStorageKey(conversationEntity) {
    return `${z.storage.StorageKey.CONVERSATION.INPUT}|${conversationEntity.id}`;
  }

  _loadDraftState(conversationEntity) {
    const storageKey = this._generateStorageKey(conversationEntity);
    const storageValue = z.util.StorageUtil.getValue(storageKey);

    if (typeof storageValue === 'undefined') {
      return {mentions: [], reply: {}, text: ''};
    }

    if (typeof storageValue === 'string') {
      return {mentions: [], reply: {}, text: storageValue};
    }

    storageValue.mentions = storageValue.mentions.map(mention => {
      return new z.message.MentionEntity(mention.startIndex, mention.length, mention.userId);
    });

    const replyMessageId = storageValue.reply ? storageValue.reply.messageId : undefined;

    if (replyMessageId) {
      storageValue.replyEntityPromise = this.conversationRepository.get_message_in_conversation_by_id(
        conversationEntity,
        replyMessageId,
        false,
        true
      );
    }

    return storageValue;
  }

  _resetDraftState() {
    this.currentMentions.removeAll();
    this.input('');
  }

  _createMentionEntity(userEntity) {
    const mentionLength = userEntity.name().length + 1;
    return new z.message.MentionEntity(this.editedMention().startIndex, mentionLength, userEntity.id);
  }

  addMention(userEntity, inputElement) {
    const mentionEntity = this._createMentionEntity(userEntity);

    // keep track of what is before and after the mention being edited
    const beforeMentionPartial = this.input().slice(0, mentionEntity.startIndex);
    const afterMentionPartial = this.input()
      .slice(mentionEntity.startIndex + this.editedMention().term.length + 1)
      .replace(/^ /, '');

    // insert the mention in between
    this.input(`${beforeMentionPartial}@${userEntity.name()} ${afterMentionPartial}`);

    this.currentMentions.push(mentionEntity);
    this.currentMentions.sort((mentionA, mentionB) => mentionA.startIndex - mentionB.startIndex);

    const caretPosition = mentionEntity.endIndex + 1;
    inputElement.selectionStart = caretPosition;
    inputElement.selectionEnd = caretPosition;
    this.endMentionFlow();
  }

  endMentionFlow() {
    this.editedMention(undefined);
    this.updateSelectionState();
  }

  addedToView() {
    amplify.subscribe(z.event.WebApp.SHORTCUT.PING, this.clickToPing);
  }

  cancelMessageEditing(resetDraft = true) {
    this.editMessageEntity(undefined);
    this.replyMessageEntity(undefined);
    if (resetDraft) {
      this._resetDraftState();
    }
  }

  cancelMessageReply(resetDraft = true) {
    this.replyMessageEntity(undefined);
    if (resetDraft) {
      this._resetDraftState();
    }
  }

  handleCancelReply() {
    if (!this.mentionSuggestions().length) {
      this.cancelMessageReply(false);
    }
    this.textarea.focus();
  }

  clickToCancelPastedFile() {
    this.pastedFile(null);
  }

  clickToShowGiphy() {
    amplify.publish(z.event.WebApp.EXTENSIONS.GIPHY.SHOW, this.input());
  }

  clickToPing() {
    if (this.conversationEntity() && !this.pingDisabled()) {
      this.pingDisabled(true);
      this.conversationRepository.sendKnock(this.conversationEntity()).then(() => {
        window.setTimeout(() => this.pingDisabled(false), InputBarViewModel.CONFIG.PING_TIMEOUT);
      });
    }
  }

  editMessage(messageEntity) {
    if (messageEntity && messageEntity.is_editable() && messageEntity !== this.editMessageEntity()) {
      this.cancelMessageReply();
      this.cancelMessageEditing();
      this.editMessageEntity(messageEntity);

      this.input(messageEntity.get_first_asset().text);
      const newMentions = messageEntity
        .get_first_asset()
        .mentions()
        .slice();
      this.currentMentions(newMentions);

      if (messageEntity.quote()) {
        this.conversationRepository
          .get_message_in_conversation_by_id(this.conversationEntity(), messageEntity.quote().messageId)
          .then(quotedMessage => this.replyMessageEntity(quotedMessage));
      }

      this._moveCursorToEnd();
    }
  }

  replyMessage(messageEntity) {
    if (messageEntity && messageEntity.isReplyable() && messageEntity !== this.replyMessageEntity()) {
      this.cancelMessageReply(false);
      this.cancelMessageEditing(!!this.editMessageEntity());
      this.replyMessageEntity(messageEntity);
      this.textarea.focus();
    }
  }

  onDropFiles(droppedFiles) {
    const images = [];
    const files = [];

    const tooManyConcurrentUploads = this._isHittingUploadLimit(droppedFiles);
    if (!tooManyConcurrentUploads) {
      Array.from(droppedFiles).forEach(file => {
        const isSupportedImage = InputBarViewModel.CONFIG.IMAGE.FILE_TYPES.includes(file.type);
        if (isSupportedImage) {
          return images.push(file);
        }
        files.push(file);
      });

      this.uploadImages(images);
      this.uploadFiles(files);
    }
  }

  onPasteFiles(pastedFiles) {
    const [pastedFile] = pastedFiles;
    this.pastedFile(pastedFile);
  }

  onWindowClick(event) {
    if (!$(event.target).closest('.conversation-input-bar, .conversation-input-bar-mention-suggestion').length) {
      this.cancelMessageEditing();
      this.cancelMessageReply();
    }
  }

  onInputEnter(data, event) {
    if (this.pastedFile()) {
      return this.sendPastedFile();
    }

    const beforeLength = this.input().length;
    const messageTrimmedStart = z.util.StringUtil.trimStart(this.input());
    const afterLength = messageTrimmedStart.length;

    const updatedMentions = this.updateMentionRanges(this.currentMentions(), 0, 0, afterLength - beforeLength);
    this.currentMentions(updatedMentions);

    const messageText = z.util.StringUtil.trimEnd(messageTrimmedStart);

    const isMessageTextTooLong = messageText.length > z.config.MAXIMUM_MESSAGE_LENGTH;
    if (isMessageTextTooLong) {
      return amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
        text: {
          message: z.l10n.text(z.string.modalConversationMessageTooLongMessage, z.config.MAXIMUM_MESSAGE_LENGTH),
          title: z.l10n.text(z.string.modalConversationMessageTooLongHeadline),
        },
      });
    }

    if (this.isEditing()) {
      this.sendMessageEdit(messageText, this.editMessageEntity(), this.replyMessageEntity());
    } else {
      this.sendMessage(messageText, this.replyMessageEntity());
    }

    this._resetDraftState();
    $(event.target).focus();
  }

  onInputKeyDown(data, keyboardEvent) {
    const inputHandledByEmoji = !this.editedMention() && this.emojiInput.onInputKeyDown(data, keyboardEvent);

    if (!inputHandledByEmoji) {
      switch (keyboardEvent.key) {
        case z.util.KeyboardUtil.KEY.ARROW_UP: {
          if (!z.util.KeyboardUtil.isFunctionKey(keyboardEvent) && !this.input().length) {
            this.editMessage(this.conversationEntity().get_last_editable_message());
            this.updateMentions(data, keyboardEvent);
          }
          break;
        }

        case z.util.KeyboardUtil.KEY.ESC: {
          if (this.mentionSuggestions().length) {
            this.endMentionFlow();
          } else if (this.pastedFile()) {
            this.pastedFile(null);
          } else if (this.isEditing()) {
            this.cancelMessageEditing();
          } else if (this.isReplying()) {
            this.cancelMessageReply(false);
          }
          break;
        }

        case z.util.KeyboardUtil.KEY.ENTER: {
          if (keyboardEvent.altKey || keyboardEvent.metaKey) {
            z.util.KeyboardUtil.insertAtCaret(keyboardEvent.target, '\n');
            $(keyboardEvent.target).change();
            keyboardEvent.preventDefault();
          }
          break;
        }

        default:
          break;
      }

      return true;
    }
  }

  /**
   * Returns a term which is a mention match together with its starting position.
   * If nothing could be matched, it returns `undefined`.
   *
   * @param {number} selectionStart - Current caret position or start of selection  (if text is marked)
   * @param {number} selectionEnd - Current caret position or end of selection (if text is marked)
   * @param {string} value - Text input
   * @returns {undefined|{startIndex: number, term: string}} Matched mention info
   */
  getMentionCandidate(selectionStart, selectionEnd, value) {
    const textInSelection = value.substring(selectionStart, selectionEnd);
    const wordBeforeSelection = value.substring(0, selectionStart).replace(/[^]*\s/, '');
    const isSpaceSelected = /\s/.test(textInSelection);

    const startOffset = wordBeforeSelection.length ? wordBeforeSelection.length - 1 : 1;
    const isSelectionStartMention = this.findMentionAtPosition(selectionStart - startOffset, this.currentMentions());
    const isSelectionEndMention = this.findMentionAtPosition(selectionEnd, this.currentMentions());
    const isOverMention = isSelectionStartMention || isSelectionEndMention;
    const isOverValidMentionString = /^@\S*$/.test(wordBeforeSelection);

    if (!isSpaceSelected && !isOverMention && isOverValidMentionString) {
      const wordAfterSelection = value.substring(selectionEnd).replace(/\s[^]*/, '');

      const term = `${wordBeforeSelection.replace(/^@/, '')}${textInSelection}${wordAfterSelection}`;
      const startIndex = selectionStart - wordBeforeSelection.length;
      return {startIndex, term};
    }

    return undefined;
  }

  handleMentionFlow() {
    const {selectionStart, selectionEnd, value} = this.textarea;
    const mentionCandidate = this.getMentionCandidate(selectionStart, selectionEnd, value);
    this.editedMention(mentionCandidate);
    this.updateSelectionState();
  }

  updateSelectionState() {
    if (!this.textarea) {
      return;
    }
    const {selectionStart, selectionEnd} = this.textarea;
    const defaultRange = {endIndex: 0, startIndex: Infinity};

    const firstMention = this.findMentionAtPosition(selectionStart, this.currentMentions()) || defaultRange;
    const lastMention = this.findMentionAtPosition(selectionEnd, this.currentMentions()) || defaultRange;

    const mentionStart = Math.min(firstMention.startIndex, lastMention.startIndex);
    const mentionEnd = Math.max(firstMention.endIndex, lastMention.endIndex);

    const newStart = Math.min(mentionStart, selectionStart);
    const newEnd = Math.max(mentionEnd, selectionEnd);
    if (newStart !== selectionStart || newEnd !== selectionEnd) {
      this.textarea.selectionStart = newStart;
      this.textarea.selectionEnd = newEnd;
    }
    this.selectionStart(newStart);
    this.selectionEnd(newEnd);
  }

  updateMentions(data, event) {
    const textarea = event.target;
    const value = textarea.value;
    const previousValue = this.input();

    const lengthDifference = value.length - previousValue.length;
    const edgeMention = this.detectMentionEdgeDeletion(textarea, lengthDifference);
    if (edgeMention) {
      textarea.value = this.input();
      textarea.selectionStart = edgeMention.startIndex;
      textarea.selectionEnd = edgeMention.endIndex;
    }
  }

  detectMentionEdgeDeletion(textarea, lengthDifference) {
    const hadSelection = this.selectionStart() !== this.selectionEnd();
    if (hadSelection) {
      return null;
    }
    if (lengthDifference >= 0) {
      return null;
    }
    const currentSelectionStart = textarea.selectionStart;
    const forwardDeleted = currentSelectionStart === this.selectionStart();
    const checkPosition = forwardDeleted ? currentSelectionStart + 1 : currentSelectionStart;
    return this.findMentionAtPosition(checkPosition, this.currentMentions());
  }

  updateMentionRanges(mentions, start, end, difference) {
    const remainingMentions = mentions.filter(({startIndex, endIndex}) => endIndex <= start || startIndex >= end);

    remainingMentions.forEach(mention => {
      if (mention.startIndex >= end) {
        mention.startIndex += difference;
      }
    });

    return remainingMentions;
  }

  findMentionAtPosition(position, mentions) {
    return mentions.find(({startIndex, endIndex}) => position > startIndex && position < endIndex);
  }

  onInputKeyUp(data, keyboardEvent) {
    if (!this.editedMention()) {
      this.emojiInput.onInputKeyUp(data, keyboardEvent);
    }
    if (keyboardEvent.key !== z.util.KeyboardUtil.KEY.ESC) {
      this.handleMentionFlow();
    }
  }

  removedFromView() {
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.PING);
  }

  triggerInputChangeEvent(newInputHeight = 0, previousInputHeight = 0) {
    amplify.publish(z.event.WebApp.INPUT.RESIZE, newInputHeight - previousInputHeight);
  }

  sendGiphy() {
    this._resetDraftState();
  }

  _generateQuote(replyMessageEntity) {
    return !replyMessageEntity
      ? Promise.resolve()
      : this.eventRepository
          .loadEvent(replyMessageEntity.conversation_id, replyMessageEntity.id)
          .then(this.messageHasher.hashEvent)
          .then(messageHash => {
            return new z.message.QuoteEntity({
              hash: messageHash,
              messageId: replyMessageEntity.id,
              userId: replyMessageEntity.from,
            });
          });
  }

  sendMessage(messageText, replyMessageEntity) {
    if (messageText.length) {
      const mentionEntities = this.currentMentions.slice();

      this._generateQuote(replyMessageEntity).then(quoteEntity => {
        this.conversationRepository.sendTextWithLinkPreview(
          this.conversationEntity(),
          messageText,
          mentionEntities,
          quoteEntity
        );
        this.cancelMessageReply();
      });
    }
  }

  sendMessageEdit(messageText, messageEntity, replyMessageEntity) {
    const mentionEntities = this.currentMentions.slice();
    this.cancelMessageEditing();

    if (!messageText.length) {
      return this.conversationRepository.deleteMessageForEveryone(this.conversationEntity(), messageEntity);
    }

    this.conversationRepository
      .sendMessageEdit(this.conversationEntity(), messageText, messageEntity, mentionEntities)
      .catch(error => {
        if (error.type !== z.error.ConversationError.TYPE.NO_MESSAGE_CHANGES) {
          throw error;
        }
      });
    this.cancelMessageReply();
  }

  sendPastedFile() {
    this.onDropFiles([this.pastedFile()]);
    this.pastedFile(null);
  }

  /**
   * Post images to a conversation.
   * @param {Array|FileList} images - Images
   * @returns {undefined} No return value
   */
  uploadImages(images) {
    if (!this._isHittingUploadLimit(images)) {
      for (const image of Array.from(images)) {
        const isTooLarge = image.size > z.config.MAXIMUM_IMAGE_FILE_SIZE;
        if (isTooLarge) {
          return this._showUploadWarning(image);
        }
      }

      this.conversationRepository.upload_images(this.conversationEntity(), images);
    }
  }

  /**
   * Post files to a conversation.
   * @param {Array|FileList} files - Images
   * @returns {undefined} No return value
   */
  uploadFiles(files) {
    const uploadLimit = this.selfUser().inTeam()
      ? z.config.MAXIMUM_ASSET_FILE_SIZE_TEAM
      : z.config.MAXIMUM_ASSET_FILE_SIZE_PERSONAL;
    if (!this._isHittingUploadLimit(files)) {
      for (const file of Array.from(files)) {
        const isTooLarge = file.size > uploadLimit;
        if (isTooLarge) {
          const fileSize = z.util.formatBytes(uploadLimit);
          const options = {
            text: {
              message: z.l10n.text(z.string.modalAssetTooLargeMessage, fileSize),
              title: z.l10n.text(z.string.modalAssetTooLargeHeadline),
            },
          };

          return amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, options);
        }
      }

      this.conversationRepository.upload_files(this.conversationEntity(), files);
    }
  }

  _isHittingUploadLimit(files) {
    const concurrentUploadLimit = InputBarViewModel.CONFIG.ASSETS.CONCURRENT_UPLOAD_LIMIT;
    const concurrentUploads = files.length + this.conversationRepository.get_number_of_pending_uploads();
    const isHittingUploadLimit = concurrentUploads > InputBarViewModel.CONFIG.ASSETS.CONCURRENT_UPLOAD_LIMIT;

    if (isHittingUploadLimit) {
      const modalOptions = {
        text: {
          message: z.l10n.text(z.string.modalAssetParallelUploadsMessage, concurrentUploadLimit),
          title: z.l10n.text(z.string.modalAssetParallelUploadsHeadline),
        },
      };

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
    }

    return isHittingUploadLimit;
  }

  _moveCursorToEnd() {
    z.util.afterRender(() => {
      if (this.textarea) {
        const endPosition = this.textarea.value.length;
        this.textarea.setSelectionRange(endPosition, endPosition);
        this.updateSelectionState();
      }
    });
  }

  _showUploadWarning(image) {
    const isGif = image.type === 'image/gif';
    const messageStringId = isGif ? z.string.modalGifTooLargeMessage : z.string.modalPictureTooLargeMessage;
    const titleStringId = isGif ? z.string.modalGifTooLargeHeadline : z.string.modalPictureTooLargeHeadline;

    const modalOptions = {
      text: {
        message: z.l10n.text(messageStringId, z.config.MAXIMUM_IMAGE_FILE_SIZE / 1024 / 1024),
        title: z.l10n.text(titleStringId),
      },
    };

    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

/**
 * Message list rendering view model.
 *
 * @todo Get rid of the participants dependencies whenever bubble implementation has changed
 * @todo Remove all jquery selectors
 */
z.viewModel.content.MessageListViewModel = class MessageListViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this._scrollAddedMessagesIntoView = this._scrollAddedMessagesIntoView.bind(this);
    this.click_on_cancel_request = this.click_on_cancel_request.bind(this);
    this.click_on_like = this.click_on_like.bind(this);
    this.clickOnInvitePeople = this.clickOnInvitePeople.bind(this);
    this.get_timestamp_class = this.get_timestamp_class.bind(this);
    this.handleClickOnMessage = this.handleClickOnMessage.bind(this);
    this.is_last_delivered_message = this.is_last_delivered_message.bind(this);
    this.on_session_reset_click = this.on_session_reset_click.bind(this);
    this.should_hide_user_avatar = this.should_hide_user_avatar.bind(this);
    this.showUserDetails = this.showUserDetails.bind(this);
    this._handleWindowResize = this._handleWindowResize.bind(this);
    this.focusMessage = this.focusMessage.bind(this);
    this.showParticipants = this.showParticipants.bind(this);
    this.show_detail = this.show_detail.bind(this);

    this.mainViewModel = mainViewModel;
    this.conversation_repository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.locationRepository = repositories.location;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.MessageListViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;
    this.selfUser = this.userRepository.self;

    this.conversation = ko.observable(new z.entity.Conversation());
    this.verticallyCenterMessage = ko.pureComputed(() => {
      if (this.conversation().messages_visible().length === 1) {
        const [messageEntity] = this.conversation().messages_visible();
        return messageEntity.is_member() && messageEntity.isConnection();
      }
    });

    amplify.subscribe(z.event.WebApp.INPUT.RESIZE, this._handleInputResize.bind(this));

    this.conversationLoaded = ko.observable(false);
    // Store last read to show until user switches conversation
    this.conversation_last_read_timestamp = ko.observable(undefined);

    // Store conversation to mark as read when browser gets focus
    this.mark_as_read_on_focus = undefined;

    // Can be used to prevent scroll handler from being executed (e.g. when using scrollTop())
    this.capture_scrolling_event = false;

    // Store message subscription id
    this.messagesChangeSubscription = undefined;
    this.messagesBeforeChangeSubscription = undefined;

    this.onMouseWheel = _.throttle((data, event) => {
      const element = $(event.currentTarget);
      if (element.isScrollable()) {
        // if the element is scrollable, the scroll event will take the relay
        return true;
      }
      const isScrollingUp = event.deltaY > 0;
      const loadExtraMessagePromise = isScrollingUp ? this._loadPrecedingMessages() : this._loadFollowingMessages();

      loadExtraMessagePromise.then(() => {
        const antiscroll = $('.message-list').data('antiscroll');
        if (antiscroll) {
          antiscroll.rebuild();
        }
      });

      return true;
    }, 50);

    this.onScroll = _.throttle((data, event) => {
      if (!this.capture_scrolling_event) {
        return;
      }
      const element = $(event.currentTarget);

      // On some HDPI screen scrollTop returns a floating point number instead of an integer
      // https://github.com/jquery/api.jquery.com/issues/608
      const scrollPosition = Math.ceil(element.scrollTop());
      const scrollEnd = element.scrollEnd();
      const hitTop = scrollPosition <= 0;
      const hitBottom = scrollPosition >= scrollEnd;

      if (hitTop) {
        return this._loadPrecedingMessages();
      }

      if (hitBottom) {
        this._loadFollowingMessages().then(() => {
          this._mark_conversation_as_read_on_focus(this.conversation());
        });
      }
    }, 100);

    this.messagesContainer = undefined;

    $(window).on('focus', () => {
      if (this.mark_as_read_on_focus) {
        window.setTimeout(() => {
          this.conversation_repository.markAsRead(this.mark_as_read_on_focus);
          this.mark_as_read_on_focus = undefined;
        }, z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      }
    });

    this.showInvitePeople = ko.pureComputed(() => {
      return (
        this.conversation().isActiveParticipant() && this.conversation().inTeam() && this.conversation().isGuestRoom()
      );
    });
  }

  /**
   * Mark conversation as read if window has focus
   * @param {z.entity.Conversation} conversation_et - Conversation entity to mark as read
   * @returns {undefined} No return value
   */
  _mark_conversation_as_read_on_focus(conversation_et) {
    if (document.hasFocus()) {
      return this.conversation_repository.markAsRead(conversation_et);
    }
    this.mark_as_read_on_focus = conversation_et;
  }

  /**
   * Remove all subscriptions and reset states.
   * @param {z.entity.Conversation} [conversation_et] - Conversation entity to change to
   * @returns {undefined} No return value
   */
  release_conversation(conversation_et) {
    if (conversation_et) {
      conversation_et.release();
    }
    if (this.messagesBeforeChangeSubscription) {
      this.messagesBeforeChangeSubscription.dispose();
    }
    if (this.messagesChangeSubscription) {
      this.messagesChangeSubscription.dispose();
    }
    this.capture_scrolling_event = false;
    this.conversation_last_read_timestamp(false);
    this.messagesContainer = undefined;
    window.removeEventListener('resize', this._handleWindowResize);
  }

  _shouldStickToBottom() {
    const messagesContainer = this._getMessagesContainer();
    const scrollPosition = Math.ceil(messagesContainer.scrollTop());
    const scrollEnd = Math.ceil(messagesContainer.scrollEnd());
    return scrollPosition > scrollEnd - z.config.SCROLL_TO_LAST_MESSAGE_THRESHOLD;
  }

  _handleWindowResize() {
    if (this._shouldStickToBottom()) {
      this._getMessagesContainer().scrollToBottom();
    }
  }

  _handleInputResize(inputSizeDiff) {
    const antiscroll = $('.message-list').data('antiscroll');
    if (antiscroll) {
      antiscroll.rebuild();
    }

    if (inputSizeDiff) {
      this._getMessagesContainer().scrollBy(inputSizeDiff);
    } else if (this._shouldStickToBottom()) {
      this._getMessagesContainer().scrollToBottom();
    }
  }

  /**
   * Change conversation.
   *
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to change to
   * @param {z.entity.Message} messageEntity - message to be focused
   * @returns {Promise} Resolves when conversation was changed
   */
  changeConversation(conversationEntity, messageEntity) {
    // Clean up old conversation
    this.conversationLoaded(false);
    if (this.conversation()) {
      this.release_conversation(this.conversation());
    }

    // Update new conversation
    this.conversation(conversationEntity);

    // Keep last read timestamp to render unread when entering conversation
    if (this.conversation().unreadState().allEvents.length) {
      this.conversation_last_read_timestamp(this.conversation().last_read_timestamp());
    }

    conversationEntity.is_loaded(false);
    return this._loadConversation(conversationEntity, messageEntity)
      .then(() => this._renderConversation(conversationEntity, messageEntity))
      .then(() => {
        conversationEntity.is_loaded(true);
        this.conversationLoaded(true);
      });
  }

  _loadConversation(conversationEntity, messageEntity) {
    return this.conversation_repository
      .updateParticipatingUserEntities(conversationEntity, false, true)
      .then(_conversationEntity => {
        return messageEntity
          ? this.conversation_repository.getMessagesWithOffset(_conversationEntity, messageEntity)
          : this.conversation_repository.getPrecedingMessages(_conversationEntity);
      });
  }

  _conversationHasExtraMessages(conversationEntity) {
    const lastMessageEntity = conversationEntity.getLastMessage();
    if (!lastMessageEntity) {
      return false;
    }

    const isLastConversationEvent = lastMessageEntity.timestamp() >= this.conversation().last_event_timestamp();
    return !isLastConversationEvent && lastMessageEntity.timestamp();
  }

  _getMessagesContainer() {
    if (!this.messagesContainer) {
      this.messagesContainer = $('.messages-wrap');
    }
    return this.messagesContainer;
  }

  /**
   * Sets the conversation and waits for further processing until knockout has rendered the messages.
   * @param {z.entity.Conversation} conversationEntity - Conversation entity to set
   * @param {z.entity.Message} messageEntity - Message that should be in focus when the conversation loads
   * @returns {Promise} Resolves when conversation was rendered
   */
  _renderConversation(conversationEntity, messageEntity) {
    const messages_container = this._getMessagesContainer();

    const is_current_conversation = conversationEntity === this.conversation();
    if (!is_current_conversation) {
      this.logger.info(`Skipped re-loading current conversation '${conversationEntity.display_name()}'`);
      return Promise.resolve();
    }

    return new Promise(resolve => {
      window.setTimeout(() => {
        // Reset scroll position
        messages_container.scrollTop(0);

        if (messageEntity) {
          this.focusMessage(messageEntity.id);
        } else {
          const unread_message = $('.message-timestamp-unread');
          if (unread_message.length) {
            const unreadMarkerPosition = unread_message.parents('.message').position();

            messages_container.scrollBy(unreadMarkerPosition.top);
          } else {
            messages_container.scrollToBottom();
          }
        }

        if (!messages_container.isScrollable() && !this._conversationHasExtraMessages(this.conversation())) {
          this._mark_conversation_as_read_on_focus(this.conversation());
        }

        this.capture_scrolling_event = true;
        window.addEventListener('resize', this._handleWindowResize);

        let shouldStickToBottomOnMessageAdd;

        this.messagesBeforeChangeSubscription = conversationEntity.messages_visible.subscribe(
          () => {
            // we need to keep track of the scroll position before the message array has changed
            shouldStickToBottomOnMessageAdd = this._shouldStickToBottom();
          },
          null,
          'beforeChange'
        );

        // Subscribe for incoming messages
        this.messagesChangeSubscription = conversationEntity.messages_visible.subscribe(
          changedMessages => {
            this._scrollAddedMessagesIntoView(changedMessages, shouldStickToBottomOnMessageAdd);
            shouldStickToBottomOnMessageAdd = undefined;
          },
          null,
          'arrayChange'
        );
        resolve();
      }, 100);
    });
  }

  /**
   * Checks how to scroll message list and if conversation should be marked as unread.
   * @param {Array} changedMessages - List of the messages that were added or removed from the list
   * @param {boolean} shouldStickToBottom - should the list stick to the bottom
   * @returns {undefined} No return value
   */
  _scrollAddedMessagesIntoView(changedMessages, shouldStickToBottom) {
    const messages_container = this._getMessagesContainer();
    const lastAddedItem = changedMessages
      .slice()
      .reverse()
      .find(changedMessage => changedMessage.status === 'added');

    // We are only interested in items that were added
    if (!lastAddedItem) {
      return;
    }

    const lastMessage = lastAddedItem.value;

    if (lastMessage) {
      // Message was prepended
      if (lastMessage.timestamp() < this.conversation().last_event_timestamp()) {
        return;
      }

      // Scroll to bottom if self user send the message
      if (lastMessage.from === this.selfUser().id) {
        window.requestAnimationFrame(() => messages_container.scrollToBottom());
        return;
      }
    }

    // Scroll to the end of the list if we are under a certain threshold
    if (shouldStickToBottom) {
      window.requestAnimationFrame(() => messages_container.scrollToBottom());

      if (document.hasFocus()) {
        this.conversation_repository.markAsRead(this.conversation());
      }
    }

    // Mark as read when conversation is not scrollable
    if (!messages_container.isScrollable()) {
      this._mark_conversation_as_read_on_focus(this.conversation());
    }
  }

  /**
   * Fetch older messages beginning from the oldest message in view
   * @returns {Promise<any>} A promise that resolves when the loading is done
   */
  _loadPrecedingMessages() {
    const shouldPullMessages = !this.conversation().is_pending() && this.conversation().hasAdditionalMessages();
    const [messagesContainer] = this._getMessagesContainer().children();

    if (shouldPullMessages && messagesContainer) {
      const initialListHeight = messagesContainer.scrollHeight;

      this.capture_scrolling_event = false;
      return this.conversation_repository.getPrecedingMessages(this.conversation()).then(() => {
        if (messagesContainer) {
          const newListHeight = messagesContainer.scrollHeight;
          this._getMessagesContainer().scrollTop(newListHeight - initialListHeight);
          this.capture_scrolling_event = true;
        }
      });
    }
    return Promise.resolve();
  }

  /**
   * Fetch newer messages beginning from the newest message in view
   * @returns {Promise<any>} A promise that resolves when the loading is done
   */
  _loadFollowingMessages() {
    const last_message = this.conversation().getLastMessage();

    if (last_message && this._conversationHasExtraMessages(this.conversation())) {
      this.capture_scrolling_event = false;
      return this.conversation_repository
        .getSubsequentMessages(this.conversation(), last_message, false)
        .then(message_ets => {
          this.capture_scrolling_event = true;
        });
    }
    return Promise.resolve();
  }

  /**
   * Scroll to given message in the list.
   *
   * @note Ideally message is centered horizontally
   * @param {string} messageId - Target message's id
   * @returns {undefined} No return value
   */
  focusMessage(messageId) {
    const messageIsLoaded = !!this.conversation().getMessage(messageId);
    const conversationEntity = this.conversation();

    const loadMessagePromise = messageIsLoaded
      ? Promise.resolve()
      : this.conversation_repository
          .get_message_in_conversation_by_id(conversationEntity, messageId)
          .then(messageEntity => {
            conversationEntity.remove_messages();
            return this.conversation_repository.getMessagesWithOffset(conversationEntity, messageEntity);
          });

    loadMessagePromise.then(() => {
      z.util.afterRender(() => {
        const messagesContainer = this._getMessagesContainer();
        const messageElement = messagesContainer.find(`.message[data-uie-uid="${messageId}"]`);

        if (messageElement.length) {
          messageElement.removeClass('message-marked');
          messagesContainer.scrollBy(messageElement.offset().top - messagesContainer.height() / 2);
          messageElement.addClass('message-marked');
        }
      });
    });
  }

  /**
   * Triggered when user clicks on an avatar in the message list.
   * @param {z.entity.User} userEntity - User entity of the selected user
   * @returns {undefined} No return value
   */
  showUserDetails(userEntity) {
    userEntity = ko.unwrap(userEntity);
    const conversationEntity = this.conversation_repository.active_conversation();
    const isSingleModeConversation = conversationEntity.is1to1() || conversationEntity.isRequest();

    if (isSingleModeConversation && !userEntity.is_me) {
      return this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.CONVERSATION_DETAILS);
    }

    const params = {entity: userEntity};
    const panelId = userEntity.isService
      ? z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE
      : z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER;

    this.mainViewModel.panel.togglePanel(panelId, params);
  }

  /**
   * Triggered when user clicks on the session reset link in a decrypt error message.
   * @param {z.entity.DecryptErrorMessage} message_et - Decrypt error message
   * @returns {undefined} No return value
   */
  on_session_reset_click(message_et) {
    const reset_progress = () =>
      window.setTimeout(() => {
        message_et.is_resetting_session(false);
        amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.SESSION_RESET);
      }, z.motion.MotionDuration.LONG);

    message_et.is_resetting_session(true);
    this.conversation_repository
      .reset_session(message_et.from, message_et.client_id, this.conversation().id)
      .then(() => reset_progress())
      .catch(() => reset_progress());
  }

  /**
   * Shows detail image view.
   *
   * @param {z.entity.Message} message_et - Message with asset to be displayed
   * @param {UIEvent} event - Actual scroll event
   * @returns {undefined} No return value
   */
  show_detail(message_et, event) {
    if (message_et.is_expired() || $(event.currentTarget).hasClass('image-loading')) {
      return;
    }

    this.conversation_repository
      .get_events_for_category(this.conversation(), z.message.MessageCategory.IMAGE)
      .then(items => {
        const message_ets = items.filter(
          item => item.category & z.message.MessageCategory.IMAGE && !(item.category & z.message.MessageCategory.GIF)
        );
        const [image_message_et] = message_ets.filter(item => item.id === message_et.id);

        amplify.publish(z.event.WebApp.CONVERSATION.DETAIL_VIEW.SHOW, image_message_et || message_et, message_ets);
      });
  }

  get_timestamp_class(message_et) {
    const last_message = this.conversation().get_previous_message(message_et);
    if (last_message) {
      if (message_et.is_call()) {
        return '';
      }

      if (last_message.timestamp() === this.conversation_last_read_timestamp()) {
        return 'message-timestamp-visible message-timestamp-unread';
      }

      const last = moment(last_message.timestamp());
      const current = moment(message_et.timestamp());

      if (!last.isSame(current, 'day')) {
        return 'message-timestamp-visible message-timestamp-day';
      }

      if (current.diff(last, 'minutes') > 60) {
        return 'message-timestamp-visible';
      }
    }
  }

  /**
   * Checks its older neighbor in order to see if the avatar should be rendered or not
   * @param {z.entity.Message} message_et - Message to check
   * @returns {boolean} Should user avatar be hidden
   */
  should_hide_user_avatar(message_et) {
    // @todo avoid double check
    if (this.get_timestamp_class(message_et)) {
      return false;
    }

    if (message_et.is_content() && message_et.replacing_message_id) {
      return false;
    }

    const last_message = this.conversation().get_previous_message(message_et);
    return last_message && last_message.is_content() && last_message.user().id === message_et.user().id;
  }

  /**
   * Checks if the given message is the last delivered one
   * @param {z.entity.Message} message_et - Message to check
   * @returns {boolean} Message is last delivered one
   */
  is_last_delivered_message(message_et) {
    return this.conversation().getLastDeliveredMessage() === message_et;
  }

  click_on_cancel_request(messageEntity) {
    const conversationEntity = this.conversation_repository.active_conversation();
    const nextConversationEntity = this.conversation_repository.get_next_conversation(conversationEntity);
    this.actionsViewModel.cancelConnectionRequest(messageEntity.otherUser(), true, nextConversationEntity);
  }

  click_on_like(message_et, button = true) {
    this.conversation_repository.toggle_like(this.conversation(), message_et, button);
  }

  clickOnInvitePeople() {
    this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.GUEST_OPTIONS);
  }

  /**
   * Message appeared in viewport.
   * @param {z.entity.Message} messageEntity - Message to check
   * @returns {boolean} Message is in viewport
   */
  getInViewportCallback(messageEntity) {
    if (!messageEntity.is_ephemeral()) {
      const isCreationMessage = messageEntity.is_member() && messageEntity.isCreation();
      if (this.conversation().is1to1() && isCreationMessage) {
        this.integrationRepository.addProviderNameToParticipant(messageEntity.otherUser());
      }
      return null;
    }

    return () => {
      const startTimer = () => {
        if (messageEntity.conversation_id === this.conversation().id) {
          this.conversation_repository.checkMessageTimer(messageEntity);
        }
      };
      return document.hasFocus() ? startTimer() : $(window).one('focus', startTimer);
    };
  }

  handleClickOnMessage(messageEntity, event) {
    const hasMentions = messageEntity.mentions().length;
    const mentionElement = hasMentions && event.target.closest('.message-mention');
    const userId = mentionElement && mentionElement.dataset.userId;

    if (userId) {
      this.userRepository
        .get_user_by_id(userId)
        .then(userEntity => this.showUserDetails(userEntity))
        .catch(error => {
          if (error.type !== z.error.UserError.TYPE.USER_NOT_FOUND) {
            throw error;
          }
        });
    }

    // need to return `true` because knockout will prevent default if we return anything else (including undefined)
    return true;
  }

  showParticipants(participants) {
    this.mainViewModel.panel.togglePanel(z.viewModel.PanelViewModel.STATE.CONVERSATION_PARTICIPANTS, participants);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAboutViewModel = class PreferencesAboutViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAboutViewModel', z.config.LOGGER.OPTIONS);

    this.userRepository = repositories.user;
    this.selfUser = this.userRepository.self;
  }

  clickOnToU() {
    const path = `${z.config.URL_PATH.TERMS_OF_USE}${this.selfUser().inTeam() ? 'teams' : 'personal'}/`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAccountViewModel = class PreferencesAccountViewModel {
  static get CONFIG() {
    return {
      PROFILE_IMAGE: {
        FILE_TYPES: ['image/bmp', 'image/jpeg', 'image/jpg', 'image/png', '.jpg-large'],
      },
      SAVE_ANIMATION_TIMEOUT: z.motion.MotionDuration.X_LONG * 2,
    };
  }

  static get USERNAME_STATE() {
    return {
      AVAILABLE: 'PreferencesAccountViewModel.USERNAME_STATE.AVAILABLE',
      TAKEN: 'PreferencesAccountViewModel.USERNAME_STATE.TAKEN',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.changeAccentColor = this.changeAccentColor.bind(this);
    this.checkNewClients = this.checkNewClients.bind(this);
    this.removedFromView = this.removedFromView.bind(this);

    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAccountViewModel', z.config.LOGGER.OPTIONS);

    this.mainViewModel = mainViewModel;
    this.backupRepository = repositories.backup;
    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.propertiesRepository = repositories.properties;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.selfUser = this.userRepository.self;

    this.newClients = ko.observableArray([]);
    this.name = ko.pureComputed(() => this.selfUser().name());
    this.availability = ko.pureComputed(() => this.selfUser().availability());

    this.availabilityLabel = ko.pureComputed(() => {
      let label = z.user.AvailabilityMapper.nameFromType(this.availability());

      const noStatusSet = this.availability() === z.user.AvailabilityType.NONE;
      if (noStatusSet) {
        label = z.l10n.text(z.string.preferencesAccountAvaibilityUnset);
      }

      return label;
    });

    this.username = ko.pureComputed(() => this.selfUser().username());
    this.enteredUsername = ko.observable();
    this.submittedUsername = ko.observable();
    this.usernameState = ko.observable();

    this.nameSaved = ko.observable();
    this.usernameSaved = ko.observable();

    this.isTeam = this.teamRepository.isTeam;
    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());
    this.team = this.teamRepository.team;
    this.teamName = ko.pureComputed(() => z.l10n.text(z.string.preferencesAccountTeam, this.teamRepository.teamName()));

    this.optionPrivacy = ko.observable();
    this.optionPrivacy.subscribe(privacyPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.PRIVACY, privacyPreference);
    });

    this.optionMarketingConsent = this.userRepository.marketingConsent;
    this.isMacOsWrapper = z.util.Environment.electron && z.util.Environment.os.mac;

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updateProperties.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_ADDED, this.onClientAdd.bind(this));
    amplify.subscribe(z.event.WebApp.USER.CLIENT_REMOVED, this.onClientRemove.bind(this));
  }

  changeAccentColor(id) {
    this.userRepository.change_accent_color(id);
  }

  changeName(viewModel, event) {
    const newName = event.target.value.trim();

    const isUnchanged = newName === this.selfUser().name();
    if (isUnchanged) {
      return event.target.blur();
    }

    const isValidName = newName.length >= z.user.UserRepository.CONFIG.MINIMUM_NAME_LENGTH;
    if (isValidName) {
      this.userRepository.change_name(newName).then(() => {
        this.nameSaved(true);
        event.target.blur();
        window.setTimeout(() => this.nameSaved(false), PreferencesAccountViewModel.CONFIG.SAVE_ANIMATION_TIMEOUT);
      });
    }
  }

  changeUsername(username, event) {
    const enteredUsername = event.target.value;
    const normalizedUsername = enteredUsername.toLowerCase().replace(/[^a-z0-9_]/g, '');

    const wasNormalized = enteredUsername !== normalizedUsername;
    if (wasNormalized) {
      event.target.value = normalizedUsername;
    }

    const isUnchanged = normalizedUsername === this.selfUser().username();
    if (isUnchanged) {
      return event.target.blur();
    }

    const isInvalidName = normalizedUsername.length < z.user.UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH;
    if (isInvalidName) {
      return this.usernameState(null);
    }

    this.submittedUsername(normalizedUsername);
    this.userRepository
      .change_username(normalizedUsername)
      .then(() => {
        const isCurrentRequest = this.enteredUsername() === this.submittedUsername();
        if (isCurrentRequest) {
          this.usernameState(null);
          this.usernameSaved(true);

          event.target.blur();
          window.setTimeout(() => this.usernameSaved(false), PreferencesAccountViewModel.CONFIG.SAVE_ANIMATION_TIMEOUT);
        }
      })
      .catch(error => {
        const isUsernameTaken = error.type === z.error.UserError.TYPE.USERNAME_TAKEN;
        const isCurrentRequest = this.enteredUsername() === this.submittedUsername();
        if (isUsernameTaken && isCurrentRequest) {
          this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.TAKEN);
        }
      });
  }

  checkUsernameInput(username, keyboardEvent) {
    if (z.util.KeyboardUtil.isKey(keyboardEvent, z.util.KeyboardUtil.KEY.BACKSPACE)) {
      return true;
    }

    // Automation: KeyboardEvent triggered during tests is missing key property
    const inputChar = keyboardEvent.key || String.fromCharCode(event.charCode);
    return z.user.UserHandleGenerator.validate_character(inputChar.toLowerCase());
  }

  checkNewClients() {
    if (this.newClients().length) {
      amplify.publish(z.event.WebApp.SEARCH.BADGE.HIDE);

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACCOUNT_NEW_DEVICES, {
        close: () => this.newClients.removeAll(),
        data: this.newClients(),
        preventClose: true,
        secondary: () => {
          amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
        },
      });
    }
  }

  clickOnChangePicture(files) {
    const [newUserPicture] = Array.from(files);

    this.setPicture(newUserPicture).catch(error => {
      const isInvalidUpdate = error.type === z.error.UserError.TYPE.INVALID_UPDATE;
      if (!isInvalidUpdate) {
        throw error;
      }
    });
  }

  clickOnAvailability(viewModel, event) {
    z.ui.AvailabilityContextMenu.show(event, 'settings', 'preferences-account-availability-menu');
  }

  clickOnBackupExport() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.HISTORY_EXPORT);
    amplify.publish(z.event.WebApp.BACKUP.EXPORT.START);
  }

  onImportFileChange(viewModel, event) {
    const file = event.target.files[0];
    if (file) {
      amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.HISTORY_IMPORT);
      amplify.publish(z.event.WebApp.BACKUP.IMPORT.START, file);
    }
  }

  clickOpenCreateTeam() {
    const path = `${z.l10n.text(z.string.urlWebsiteCreateTeam)}?pk_campaign=client&pk_kwd=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path));
  }

  clickOnDeleteAccount() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => this.userRepository.delete_me(),
      text: {
        action: z.l10n.text(z.string.modalAccountDeletionAction),
        message: z.l10n.text(z.string.modalAccountDeletionMessage),
        title: z.l10n.text(z.string.modalAccountDeletionHeadline),
      },
    });
  }

  clickOnLeaveGuestRoom() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => this.conversationRepository.leaveGuestRoom().then(() => this.clientRepository.logoutClient()),
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalAccountLeaveGuestRoomAction),
        message: z.l10n.text(z.string.modalAccountLeaveGuestRoomMessage),
        title: z.l10n.text(z.string.modalAccountLeaveGuestRoomHeadline),
      },
      warning: false,
    });
  }

  clickOnLogout() {
    this.clientRepository.logoutClient();
  }

  clickOpenManageTeam() {
    const path = `${z.config.URL_PATH.MANAGE_TEAM}?utm_source=client_settings&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  clickOnResetPassword() {
    const url = z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.ACCOUNT, z.config.URL_PATH.PASSWORD_RESET);
    z.util.SanitizationUtil.safeWindowOpen(url);
  }

  onClientAdd(userId, clientEntity) {
    const isSelfUser = userId === this.selfUser().id;
    if (isSelfUser) {
      amplify.publish(z.event.WebApp.SEARCH.BADGE.SHOW);
      this.newClients.push(clientEntity);
    }
  }

  onClientRemove(userId, clientId) {
    const isSelfUser = userId === this.selfUser().id;
    if (isSelfUser) {
      this.newClients.remove(clientEntity => {
        const isExpectedId = clientEntity.id === clientId;
        return isExpectedId && clientEntity.isPermanent();
      });

      if (!this.newClients().length) {
        amplify.publish(z.event.WebApp.SEARCH.BADGE.HIDE);
      }
    }
    return true;
  }

  removedFromView() {
    this._resetUsernameInput();
  }

  resetNameInput() {
    if (!this.nameSaved()) {
      this.name.notifySubscribers();
    }
  }

  resetUsernameInput() {
    if (!this.usernameSaved()) {
      this._resetUsernameInput();
      this.username.notifySubscribers();
    }
  }

  setPicture(newUserPicture) {
    const isTooLarge = newUserPicture.size > z.config.MAXIMUM_IMAGE_FILE_SIZE;
    if (isTooLarge) {
      const maximumSizeInMB = z.config.MAXIMUM_IMAGE_FILE_SIZE / 1024 / 1024;
      const messageString = z.l10n.text(z.string.modalPictureTooLargeMessage, maximumSizeInMB);
      const titleString = z.l10n.text(z.string.modalPictureTooLargeHeadline);

      return this._showUploadWarning(titleString, messageString);
    }

    const isWrongFormat = !PreferencesAccountViewModel.CONFIG.PROFILE_IMAGE.FILE_TYPES.includes(newUserPicture.type);
    if (isWrongFormat) {
      const titleString = z.l10n.text(z.string.modalPictureFileFormatHeadline);
      const messageString = z.l10n.text(z.string.modalPictureFileFormatMessage);

      return this._showUploadWarning(titleString, messageString);
    }

    const minHeight = z.user.UserRepository.CONFIG.MINIMUM_PICTURE_SIZE.HEIGHT;
    const minWidth = z.user.UserRepository.CONFIG.MINIMUM_PICTURE_SIZE.WIDTH;

    return z.util.validateProfileImageResolution(newUserPicture, minWidth, minHeight).then(isValid => {
      if (isValid) {
        return this.userRepository.change_picture(newUserPicture);
      }

      const messageString = z.l10n.text(z.string.modalPictureTooSmallMessage);
      const titleString = z.l10n.text(z.string.modalPictureTooSmallHeadline);
      return this._showUploadWarning(titleString, messageString);
    });
  }

  shouldFocusUsername() {
    return this.userRepository.should_set_username;
  }

  verifyUsername(username, event) {
    const enteredUsername = event.target.value.toLowerCase().replace(/[^a-z0-9_]/g, '');

    const usernameTooShort = enteredUsername.length < z.user.UserRepository.CONFIG.MINIMUM_USERNAME_LENGTH;
    const usernameUnchanged = enteredUsername === this.selfUser().username();
    if (usernameTooShort || usernameUnchanged) {
      return this.usernameState(null);
    }

    this.enteredUsername(enteredUsername);

    if (z.user.UserHandleGenerator.validate_handle(enteredUsername)) {
      this.userRepository
        .verify_username(enteredUsername)
        .then(() => {
          const isCurrentRequest = this.enteredUsername() === enteredUsername;
          if (isCurrentRequest) {
            this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.AVAILABLE);
          }
        })
        .catch(error => {
          const isUsernameTaken = error.type === z.error.UserError.TYPE.USERNAME_TAKEN;
          const isCurrentRequest = this.enteredUsername() === enteredUsername;
          if (isUsernameTaken && isCurrentRequest) {
            this.usernameState(PreferencesAccountViewModel.USERNAME_STATE.TAKEN);
          }
        });
    }
  }

  _showUploadWarning(title, message) {
    const modalOptions = {text: {message, title}};
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, modalOptions);

    return Promise.reject(new z.error.UserError(z.error.UserError.TYPE.INVALID_UPDATE));
  }

  _resetUsernameInput() {
    this.usernameState(null);
    this.enteredUsername(null);
    this.submittedUsername(null);
  }

  updateProperties(properties) {
    this.optionPrivacy(properties.settings.privacy.improve_wire);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesAVViewModel = class PreferencesAVViewModel {
  static get CONFIG() {
    return {
      AUDIO_METER: {
        FFT_SIZE: 1024,
        INTERVAL: 100,
        LEVEL_ADJUSTMENT: 0.075,
        SMOOTHING_TIME_CONSTANT: 0.2,
      },
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.initiateDevices = this.initiateDevices.bind(this);
    this.releaseDevices = this.releaseDevices.bind(this);

    this.logger = new z.util.Logger('z.viewModel.content.PreferencesAVViewModel', z.config.LOGGER.OPTIONS);

    this.mediaRepository = repositories.media;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.devicesHandler = this.mediaRepository.devicesHandler;
    this.availableDevices = this.devicesHandler.availableDevices;
    this.currentDeviceId = this.devicesHandler.currentDeviceId;
    this.deviceSupport = this.devicesHandler.deviceSupport;

    this.constraintsHandler = this.mediaRepository.constraintsHandler;
    this.streamHandler = this.mediaRepository.streamHandler;
    this.mediaStream = this.streamHandler.localMediaStream;

    this.isVisible = false;

    const selfUser = this.userRepository.self;
    this.isTemporaryGuest = ko.pureComputed(() => selfUser() && selfUser().isTemporaryGuest());

    this.mediaStream.subscribe(mediaStream => {
      if (this.audioInterval) {
        this._releaseAudioMeter();
      }

      if (this.isVisible && mediaStream) {
        this._initiateAudioMeter(mediaStream);
      }
    });

    this.audioContext = undefined;
    this.audioInterval = undefined;
    this.audioLevel = ko.observable(0);
    this.audioSource = undefined;

    this.permissionDenied = ko.observable(false);

    this.supportsAudioOutput = ko.pureComputed(() => {
      return this.deviceSupport.audioOutput() && z.util.Environment.browser.supports.audioOutputSelection;
    });
  }

  /**
   * Initiate media devices.
   * @returns {undefined} No return value
   */
  initiateDevices() {
    this.isVisible = true;

    this._getMediaStream().then(mediaStream => {
      if (mediaStream && !this.audioInterval) {
        this._initiateAudioMeter(mediaStream);
      }
    });
  }

  tryAgain() {
    this.releaseDevices();
    this.initiateDevices();
  }

  /**
   * Release media devices.
   * @returns {undefined} No return value.
   */
  releaseDevices() {
    this.isVisible = false;
    this._releaseAudioMeter();
    this._releaseMediaStream();
  }

  /**
   * Check supported media type.
   * @private
   * @returns {Promise} Resolves with a MediaType or false
   */
  _checkMediaSupport() {
    let mediaType;
    if (this.deviceSupport.audioInput()) {
      mediaType = this.deviceSupport.videoInput() ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
    } else {
      mediaType = this.deviceSupport.videoInput() ? z.media.MediaType.VIDEO : undefined;
    }

    return mediaType
      ? Promise.resolve(mediaType)
      : Promise.reject(new z.error.MediaError(z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE));
  }

  /**
   * Get current MediaStream or initiate it.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _getCurrentMediaStream() {
    const hasActiveStream = this.deviceSupport.videoInput()
      ? !!this.mediaStream() && this.streamHandler.localMediaType() === z.media.MediaType.VIDEO
      : !!this.mediaStream();

    return Promise.resolve(hasActiveStream ? this.mediaStream() : undefined);
  }

  /**
   * Get current MediaStream or initiate it.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _getMediaStream() {
    return this._getCurrentMediaStream().then(mediaStream => (mediaStream ? mediaStream : this._initiateMediaStream()));
  }

  /**
   * Initiate MediaStream.
   * @private
   * @returns {Promise} Resolves with a MediaStream
   */
  _initiateMediaStream() {
    return this._checkMediaSupport()
      .then(mediaType => {
        return this.constraintsHandler
          .getMediaStreamConstraints(this.deviceSupport.audioInput(), this.deviceSupport.videoInput())
          .then(streamConstraints => this.streamHandler.requestMediaStream(mediaType, streamConstraints));
      })
      .then(mediaStreamInfo => {
        if (this.deviceSupport.videoInput()) {
          this.streamHandler.localMediaType(z.media.MediaType.VIDEO);
        }

        this.streamHandler.localMediaStream(mediaStreamInfo.stream);
        return this.streamHandler.localMediaStream();
      })
      .catch(error => {
        this.logger.error(`Requesting MediaStream failed: ${error.message}`, error);

        const expectedErrors = [
          z.error.MediaError.TYPE.MEDIA_STREAM_DEVICE,
          z.error.MediaError.TYPE.MEDIA_STREAM_PERMISSION,
        ];

        const isExpectedError = expectedErrors.includes(error.type);
        if (isExpectedError) {
          this.permissionDenied(true);
          return false;
        }

        throw error;
      });
  }

  /**
   * Initiate audio meter.
   *
   * @private
   * @param {MediaStream} mediaStream - MediaStream to measure audio levels on
   * @returns {undefined} No return value
   */
  _initiateAudioMeter(mediaStream) {
    this.logger.info('Initiating new audio meter', mediaStream);
    this.audioContext = this.mediaRepository.getAudioContext();

    const audioAnalyser = this.audioContext.createAnalyser();
    audioAnalyser.fftSize = PreferencesAVViewModel.CONFIG.AUDIO_METER.FFT_SIZE;
    audioAnalyser.smoothingTimeConstant = PreferencesAVViewModel.CONFIG.AUDIO_METER.SMOOTHING_TIME_CONSTANT;

    const audioDataArray = new Float32Array(audioAnalyser.frequencyBinCount);

    this.audioInterval = window.setInterval(() => {
      audioAnalyser.getFloatFrequencyData(audioDataArray);
      let volume = 0;

      // Data is in the db range of -100 to -30, but can also be -Infinity. We normalize the value up to -50 to the range of 0, 1.
      for (const dataPoint of audioDataArray) {
        volume += Math.abs(Math.max(dataPoint, -100) + 100) / 50;
      }

      const averageVolume = volume / audioDataArray.length;

      this.audioLevel(averageVolume - PreferencesAVViewModel.CONFIG.AUDIO_METER.LEVEL_ADJUSTMENT);
    }, PreferencesAVViewModel.CONFIG.AUDIO_METER.INTERVAL);

    this.audioSource = this.audioContext.createMediaStreamSource(mediaStream);
    this.audioSource.connect(audioAnalyser);
  }

  _releaseAudioMeter() {
    window.clearInterval(this.audioInterval);
    this.audioInterval = undefined;
    if (this.audioSource) {
      this.audioSource.disconnect();
    }
  }

  _releaseMediaStream() {
    this.streamHandler.resetMediaStream();
    this.permissionDenied(false);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesDeviceDetailsViewModel = class PreferencesDeviceDetailsViewModel {
  static get SESSION_RESET_STATE() {
    return {
      CONFIRMATION: 'confirmation',
      ONGOING: 'ongoing',
      RESET: 'reset',
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.cryptographyRepository = repositories.cryptography;
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesDeviceDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = mainViewModel.actions;
    this.selfUser = this.clientRepository.selfUser;

    this.activationDate = ko.observableArray([]);
    this.device = ko.observable();
    this.fingerprint = ko.observableArray([]);
    this.sessionResetState = ko.observable(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);

    this.device.subscribe(clientEntity => {
      if (clientEntity) {
        this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        this._updateFingerprint();
        this._updateActivationTime(clientEntity.time);
      }
    });
  }

  _updateActivationTime(time) {
    const formattedTime = z.util.TimeUtil.formatTimestamp(time);
    const stringTemplate = z.string.preferencesDevicesActivatedOn;
    const sanitizedText = z.util.StringUtil.splitAtPivotElement(stringTemplate, '{{date}}', formattedTime);
    this.activationDate(sanitizedText);
  }

  _updateFingerprint() {
    this.fingerprint([]);

    this.cryptographyRepository
      .getRemoteFingerprint(this.selfUser().id, this.device().id)
      .then(fingerprint => this.fingerprint(fingerprint));
  }

  clickOnDetailsClose() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
    this.device(null);
  }

  clickOnResetSession() {
    this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.ONGOING);

    const selfConversationId = this.conversationRepository.self_conversation().id;
    this.conversationRepository
      .reset_session(this.selfUser().id, this.device().id, selfConversationId)
      .then(() => {
        window.setTimeout(() => {
          this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.CONFIRMATION);
        }, z.motion.MotionDuration.LONG);

        window.setTimeout(() => {
          this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        }, 5000);
      })
      .catch(error => {
        this.sessionResetState(PreferencesDeviceDetailsViewModel.SESSION_RESET_STATE.RESET);
        throw error;
      });
  }

  clickOnRemoveDevice() {
    this.actionsViewModel.deleteClient(this.device()).then(() => this.clickOnDetailsClose());
  }

  toggleDeviceVerification() {
    const toggleVerified = !this.device().meta.isVerified();
    this.clientRepository.verifyClient(this.selfUser().id, this.device(), toggleVerified);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesDevicesViewModel = class PreferencesDevicesViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.clickOnRemoveDevice = this.clickOnRemoveDevice.bind(this);
    this.clickOnShowDevice = this.clickOnShowDevice.bind(this);
    this.updateDeviceInfo = this.updateDeviceInfo.bind(this);

    this.clientRepository = repositories.client;
    this.conversationRepository = repositories.conversation;
    this.cryptographyRepository = repositories.cryptography;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesDevicesViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = mainViewModel.actions;
    this.preferencesDeviceDetails = contentViewModel.preferencesDeviceDetails;
    this.currentClient = this.clientRepository.currentClient;
    this.displayClientId = ko.pureComputed(() => (this.currentClient() ? this.currentClient().formatId() : []));

    this.activationDate = ko.observable([]);
    this.devices = ko.observableArray();
    this.localFingerprint = ko.observableArray([]);
    this.selfUser = this.userRepository.self;
    this.isSSO = ko.pureComputed(() => this.selfUser() && this.selfUser().isSingleSignOn);

    this.shouldUpdateScrollbar = ko.computed(() => this.devices()).extend({notify: 'always', rateLimit: 500});

    // All clients except the current client
    this.clientRepository.clients.subscribe(clientEntities => {
      const devices = clientEntities.filter(clientEntity => clientEntity.id !== this.currentClient().id);
      this.devices(devices);
    });
  }

  _updateActivationDate(time, template = z.string.preferencesDevicesActivatedOn) {
    const formattedTime = z.util.TimeUtil.formatTimestamp(time);
    const sanitizedText = z.util.StringUtil.splitAtPivotElement(template, '{{date}}', formattedTime);
    this.activationDate(sanitizedText);
  }

  clickOnShowDevice(clientEntity) {
    this.preferencesDeviceDetails.device(clientEntity);
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS);
  }

  clickOnRemoveDevice(clientEntity, event) {
    this.actionsViewModel.deleteClient(clientEntity);
    event.stopPropagation();
  }

  updateDeviceInfo() {
    if (this.currentClient() && !this.localFingerprint().length) {
      this._updateActivationDate(this.currentClient().time);
      this.localFingerprint(this.cryptographyRepository.getLocalFingerprint());
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

z.viewModel.content.PreferencesOptionsViewModel = class PreferencesOptionsViewModel {
  static get CONFIG() {
    return {
      MINIMUM_CALL_LOG_LENGTH: 10,
    };
  }

  constructor(mainViewModel, contentViewModel, repositories) {
    this.logger = new z.util.Logger('z.viewModel.content.PreferencesOptionsViewModel', z.config.LOGGER.OPTIONS);

    this.callingRepository = repositories.calling;
    this.propertiesRepository = repositories.properties;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isTeam = this.teamRepository.isTeam;

    this.optionAudio = ko.observable();
    this.optionAudio.subscribe(audioPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.SOUND_ALERTS, audioPreference);
    });

    this.optionReplaceInlineEmoji = ko.observable();
    this.optionReplaceInlineEmoji.subscribe(emojiPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.EMOJI.REPLACE_INLINE, emojiPreference);
    });

    this.optionNotifications = ko.observable();
    this.optionNotifications.subscribe(notificationsPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.NOTIFICATIONS, notificationsPreference);
    });

    this.optionSendPreviews = ko.observable();
    this.optionSendPreviews.subscribe(sendPreviewsPreference => {
      this.propertiesRepository.savePreference(z.properties.PROPERTIES_TYPE.PREVIEWS.SEND, sendPreviewsPreference);
    });

    amplify.subscribe(z.event.WebApp.PROPERTIES.UPDATED, this.updateProperties.bind(this));
  }

  connectMacOSContacts() {
    amplify.publish(z.event.WebApp.CONNECT.IMPORT_CONTACTS, z.connect.ConnectSource.ICLOUD);
  }

  saveCallLogs() {
    const messageLog = this.callingRepository.messageLog;
    // Very short logs will not contain useful information
    const logExceedsMinimumLength = messageLog.length > PreferencesOptionsViewModel.CONFIG.MINIMUM_CALL_LOG_LENGTH;
    if (logExceedsMinimumLength) {
      const callLog = [messageLog.join('\r\n')];
      const blob = new Blob(callLog, {type: 'text/plain;charset=utf-8'});

      const selfUserId = this.userRepository.self().id;
      const truncatedId = selfUserId.substr(0, z.telemetry.calling.CallLogger.CONFIG.OBFUSCATION_TRUNCATE_TO);
      const filename = `Wire-${truncatedId}-Calling_${z.util.TimeUtil.getCurrentDate()}.log`;

      return z.util.downloadBlob(blob, filename);
    }

    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
      text: {
        message: z.l10n.text(z.string.modalCallEmptyLogMessage),
        title: z.l10n.text(z.string.modalCallEmptyLogHeadline),
      },
    });
  }

  updateProperties(properties) {
    this.optionAudio(properties.settings.sound.alerts);
    this.optionReplaceInlineEmoji(properties.settings.emoji.replace_inline);
    this.optionSendPreviews(properties.settings.previews.send);
    this.optionNotifications(properties.settings.notifications);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.content = z.viewModel.content || {};

// Parent: z.viewModel.ContentViewModel
z.viewModel.content.TitleBarViewModel = class TitleBarViewModel {
  constructor(mainViewModel, contentViewModel, repositories) {
    this.addedToView = this.addedToView.bind(this);

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.multitasking = contentViewModel.multitasking;
    this.logger = new z.util.Logger('z.viewModel.content.TitleBarViewModel', z.config.LOGGER.OPTIONS);

    this.panelViewModel = mainViewModel.panel;

    this.panelIsVisible = this.panelViewModel.isVisible;

    // TODO remove the titlebar for now to ensure that buttons are clickable in macOS wrappers
    window.setTimeout(() => $('.titlebar').remove(), z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);

    this.conversationEntity = this.conversationRepository.active_conversation;

    this.joinedCall = this.callingRepository.joinedCall;
    this.selfStreamState = this.callingRepository.selfStreamState;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.hasCall = ko.pureComputed(() => {
      const hasEntities = this.conversationEntity() && this.joinedCall();
      return hasEntities ? this.conversationEntity().id === this.joinedCall().id : false;
    });

    this.badgeLabelCopy = ko.pureComputed(() => {
      let stringId;

      if (this.conversationEntity().hasGuest()) {
        stringId = this.conversationEntity().hasService()
          ? z.string.guestRoomConversationBadgeGuestAndService
          : z.string.guestRoomConversationBadge;
      } else if (this.conversationEntity().hasService()) {
        stringId = z.string.guestRoomConversationBadgeService;
      }

      return stringId ? z.l10n.text(stringId) : '';
    });

    this.hasOngoingCall = ko.computed(() => {
      return this.hasCall() && this.joinedCall() ? this.joinedCall().isOngoing() : false;
    });

    this.showCallControls = ko.pureComputed(() => {
      if (!this.conversationEntity()) {
        return false;
      }

      const isSupportedConversation = this.conversationEntity().isGroup() || this.conversationEntity().is1to1();
      const hasParticipants = !!this.conversationEntity().participating_user_ids().length;
      const isActiveConversation = hasParticipants && !this.conversationEntity().removed_from_conversation();
      return !this.hasCall() && isSupportedConversation && isActiveConversation;
    });

    this.supportsVideoCall = ko.pureComputed(() => {
      return this.conversationEntity() && this.conversationEntity().supportsVideoCall(true);
    });

    const shortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.PEOPLE);
    this.peopleTooltip = z.l10n.text(z.string.tooltipConversationPeople, shortcut);
  }

  addedToView() {
    window.setTimeout(() => {
      amplify.subscribe(z.event.WebApp.SHORTCUT.PEOPLE, () => this.showDetails());
      amplify.subscribe(z.event.WebApp.SHORTCUT.ADD_PEOPLE, () => {
        if (this.isActivatedAccount()) {
          this.showAddParticipant();
        }
      });
    }, 50);
  }

  removedFromView() {
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.PEOPLE);
    amplify.unsubscribeAll(z.event.WebApp.SHORTCUT.ADD_PEOPLE);
  }

  clickOnCallButton() {
    amplify.publish(z.event.WebApp.CALL.STATE.TOGGLE, z.media.MediaType.AUDIO);
  }

  clickOnDetails() {
    this.showDetails();
  }

  clickOnVideoButton() {
    amplify.publish(z.event.WebApp.CALL.STATE.TOGGLE, z.media.MediaType.AUDIO_VIDEO);
  }

  clickOnCollectionButton() {
    amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.COLLECTION);
  }

  showAddParticipant() {
    const canAddPeople = this.conversationEntity() && this.conversationEntity().isActiveParticipant();

    if (!canAddPeople) {
      return this.showDetails();
    }

    return this.conversationEntity().isGroup()
      ? this.showDetails(true)
      : amplify.publish(
          z.event.WebApp.CONVERSATION.CREATE_GROUP,
          'conversation_details',
          this.conversationEntity().firstUserEntity()
        );
  }

  showDetails(addParticipants) {
    const panelId = addParticipants
      ? z.viewModel.PanelViewModel.STATE.ADD_PARTICIPANTS
      : z.viewModel.PanelViewModel.STATE.CONVERSATION_DETAILS;

    this.panelViewModel.togglePanel(panelId);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.PanelViewModel = class PanelViewModel {
  static get STATE() {
    return {
      ADD_PARTICIPANTS: 'PanelViewModel.STATE.ADD_PARTICIPANTS',
      CONVERSATION_DETAILS: 'PanelViewModel.STATE.CONVERSATION_DETAILS',
      CONVERSATION_PARTICIPANTS: 'PanelViewModel.STATE.CONVERSATION_PARTICIPANTS',
      GROUP_PARTICIPANT_SERVICE: 'PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE',
      GROUP_PARTICIPANT_USER: 'PanelViewModel.STATE.GROUP_PARTICIPANT_USER',
      GUEST_OPTIONS: 'PanelViewModel.STATE.GUEST_OPTIONS',
      NOTIFICATIONS: 'PanelViewModel.STATE.NOTIFICATIONS',
      PARTICIPANT_DEVICES: 'PanelViewModel.STATE.DEVICES',
      TIMED_MESSAGES: 'PanelViewModel.STATE.TIMED_MESSAGES',
    };
  }

  buildSubViews() {
    const viewModels = {
      [PanelViewModel.STATE.ADD_PARTICIPANTS]: z.viewModel.panel.AddParticipantsViewModel,
      [PanelViewModel.STATE.CONVERSATION_DETAILS]: z.viewModel.panel.ConversationDetailsViewModel,
      [PanelViewModel.STATE.CONVERSATION_PARTICIPANTS]: z.viewModel.panel.ConversationParticipantsViewModel,
      [PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE]: z.viewModel.panel.GroupParticipantServiceViewModel,
      [PanelViewModel.STATE.GROUP_PARTICIPANT_USER]: z.viewModel.panel.GroupParticipantUserViewModel,
      [PanelViewModel.STATE.GUEST_OPTIONS]: z.viewModel.panel.GuestsAndServicesViewModel,
      [PanelViewModel.STATE.NOTIFICATIONS]: z.viewModel.panel.NotificationsViewModel,
      [PanelViewModel.STATE.PARTICIPANT_DEVICES]: z.viewModel.panel.ParticipantDevicesViewModel,
      [PanelViewModel.STATE.TIMED_MESSAGES]: z.viewModel.panel.TimedMessagesViewModel,
    };

    return Object.entries(viewModels).reduce((subViews, [state, viewModel]) => {
      subViews[state] = new viewModel({
        isVisible: ko.pureComputed(this._isStateVisible.bind(this, state)),
        mainViewModel: this.mainViewModel,
        navigateTo: this._navigateTo.bind(this),
        onClose: this.closePanel.bind(this),
        onGoBack: this._goBack.bind(this),
        onGoToRoot: this._goToRoot.bind(this),
        repositories: this.repositories,
      });
      return subViews;
    }, {});
  }

  /**
   * View model for the details column.
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, repositories) {
    this.elementId = 'right-column';
    this.repositories = repositories;
    this.conversationRepository = repositories.conversation;
    this.mainViewModel = mainViewModel;

    this.conversationEntity = this.conversationRepository.active_conversation;
    this.stateHistory = [];

    this.isAnimating = ko.observable(false);
    this.isVisible = ko.pureComputed(() => this.state() !== null);
    this.exitingState = ko.observable(undefined);
    this.state = ko.observable(null);

    this.conversationEntity.subscribe(this._forceClosePanel.bind(this), null, 'beforeChange');
    this.subViews = this.buildSubViews();

    amplify.subscribe(z.event.WebApp.CONTENT.SWITCH, this._switchContent.bind(this));
    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  /**
   * Toggles (open/close) a panel.
   * If the state given is the one visible (and the parameters are the same), the panel closes.
   * Else the panels opens on the given state.
   *
   * Note: panels that are toggled are not counted in the state history.
   *
   * @param {string} state - the new state to navigate to.
   * @param {Object} params - params to give to the new view.
   * @returns {void} nothing returned
   */
  togglePanel(state, params) {
    const isStateChange = this.state() !== state;
    if (!isStateChange) {
      const currentInstance = this.subViews[state];
      const isNewParams = params && params.entity && params.entity.id !== currentInstance.getEntityId();
      if (!isNewParams) {
        return this.closePanel();
      }
    }
    this._openPanel(state, params);
  }

  /**
   * Graciously closes the current opened panel.
   *
   * @returns {void} nothing returned
   */
  closePanel() {
    if (this.isAnimating()) {
      return Promise.resolve(false);
    }

    this.isAnimating(true);
    return this.mainViewModel.closePanel().then(() => {
      this._resetState();
      return true;
    });
  }

  /**
   * Will navigate from the current state to the new state.
   *
   * @param {string} newState - the new state to navigate to.
   * @param {Object} params - params to give to the new view.
   * @returns {void} nothing returned.
   */
  _navigateTo(newState, params) {
    this._switchState(newState, this.state(), params);
    this.stateHistory.push({params, state: newState});
  }

  _forceClosePanel() {
    if (this.isVisible()) {
      this.mainViewModel.closePanelImmediatly();
      this._resetState();
    }
  }

  _resetState() {
    this.isAnimating(false);
    this._hidePanel(this.state());
    this.state(null);
    this.stateHistory = [];
  }

  _isStateVisible(state) {
    const isStateActive = this.state() === state;
    const isStateExiting = this.exitingState() === state;
    return (isStateExiting || isStateActive) && this.isVisible();
  }

  _goBack() {
    this.stateHistory.pop();
    const toHistory = this.stateHistory[this.stateHistory.length - 1];
    const {state, params} = toHistory;
    this._switchState(state, this.state(), params, true);
  }

  _goToRoot() {
    this._openPanel(PanelViewModel.STATE.CONVERSATION_DETAILS);
  }

  _switchContent(newContentState) {
    const stateIsCollection = newContentState === z.viewModel.ContentViewModel.STATE.COLLECTION;
    if (stateIsCollection) {
      this._forceClosePanel();
    }
  }

  _switchState(toState, fromState, params, fromLeft = false) {
    const toViewModel = this.subViews[toState];
    const fromViewModel = this.subViews[fromState];
    toViewModel.initView(params);

    const isSameState = fromState === toState;
    if (isSameState) {
      return;
    }

    if (!fromViewModel) {
      return this._showPanel(toState);
    }

    const skipTransition = fromViewModel.shouldSkipTransition() || toViewModel.shouldSkipTransition();

    if (skipTransition) {
      this._hidePanel(fromState);
      this._showPanel(toState);
      return;
    }

    this.exitingState(fromState);

    const fromPanel = $(`#${fromViewModel.getElementId()}`);
    const toPanel = this._showPanel(toState);

    toPanel.addClass(`panel__page--move-in${fromLeft ? '--left' : '--right'}`);
    fromPanel.addClass(`panel__page--move-out${fromLeft ? '--left' : '--right'}`);

    window.setTimeout(() => {
      toPanel.removeClass('panel__page--move-in--left panel__page--move-in--right');
      this._hidePanel(fromState);
    }, z.motion.MotionDuration.MEDIUM);
  }

  _hidePanel(state) {
    if (!this.subViews[state]) {
      return;
    }
    this.exitingState(undefined);

    const panelStateElementId = this.subViews[state].getElementId();
    const exitPanel = $(`#${panelStateElementId}`);
    exitPanel.removeClass('panel__page--visible panel__page--move-out--left panel__page--move-out--right');
  }

  _openPanel(newState, params) {
    if (!this.isAnimating()) {
      this._hidePanel(this.state());
      const rootState = PanelViewModel.STATE.CONVERSATION_DETAILS;
      this.stateHistory = [{state: rootState}, {params, state: newState}];
      this.isAnimating(true);
      this.exitingState(undefined);
      this._switchState(newState, null, params, true);
      this.mainViewModel.openPanel().then(() => this.isAnimating(false));
    }
  }

  _showPanel(newPanelState) {
    this.state(newPanelState);

    const panelStateElementId = this.subViews[newPanelState].getElementId();
    if (panelStateElementId) {
      return $(`#${panelStateElementId}`).addClass('panel__page--visible');
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.BasePanelViewModel = class BasePanelViewModel {
  constructor({isVisible, navigateTo, onClose, onGoBack, onGoToRoot, repositories}) {
    this.onClose = onClose;
    this.onGoBack = onGoBack;
    this.onGoToRoot = onGoToRoot;
    this.navigateTo = navigateTo;

    this.isVisible = isVisible;

    this.activeConversation = repositories.conversation.active_conversation;
  }

  initView() {}

  getElementId() {
    return 'conversation-details';
  }

  getEntityId() {
    return this.activeConversation() ? this.activeConversation().id : false;
  }

  shouldSkipTransition() {
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.AddParticipantsViewModel = class AddParticipantsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get STATE() {
    return {
      ADD_PEOPLE: 'AddParticipantsViewModel.STATE.ADD_PEOPLE',
      ADD_SERVICE: 'AddParticipantsViewModel.STATE.ADD_SERVICE',
    };
  }

  constructor(params) {
    super(params);

    const {conversation, integration, search, team, user} = params.repositories;
    this.conversationRepository = conversation;
    this.integrationRepository = integration;
    this.searchRepository = search;
    this.teamRepository = team;
    this.userRepository = user;

    this.logger = new z.util.Logger('z.viewModel.panel.AddParticipantsViewModel', z.config.LOGGER.OPTIONS);

    this.isTeam = this.teamRepository.isTeam;
    this.selfUser = this.userRepository.self;
    this.services = this.integrationRepository.services;
    this.teamUsers = this.teamRepository.teamUsers;
    this.teamMembers = this.teamRepository.teamMembers;

    this.isInitialServiceSearch = ko.observable(true);
    this.searchInput = ko.observable('');
    this.selectedContacts = ko.observableArray([]);
    this.selectedService = ko.observable();
    this.state = ko.observable(AddParticipantsViewModel.STATE.ADD_PEOPLE);

    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());

    this.showIntegrations = ko.pureComputed(() => {
      if (this.activeConversation()) {
        const firstUserEntity = this.activeConversation().firstUserEntity();
        const hasBotUser = firstUserEntity && firstUserEntity.isService;
        const allowIntegrations = this.activeConversation().isGroup() || hasBotUser;
        return this.isTeam() && allowIntegrations && this.activeConversation().inTeam() && !this.isTeamOnly();
      }
    });
    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());

    this.enableAddAction = ko.pureComputed(() => this.selectedContacts().length > 0);

    this.isStateAddPeople = ko.pureComputed(() => this.state() === AddParticipantsViewModel.STATE.ADD_PEOPLE);
    this.isStateAddService = ko.pureComputed(() => this.state() === AddParticipantsViewModel.STATE.ADD_SERVICE);

    this.contacts = ko.pureComputed(() => {
      const activeConversation = this.activeConversation();
      let userEntities = [];

      if (!activeConversation) {
        return userEntities;
      }

      if (this.isTeam()) {
        userEntities = this.isTeamOnly()
          ? this.teamMembers().sort((userA, userB) => {
              return z.util.StringUtil.sortByPriority(userA.first_name(), userB.first_name());
            })
          : this.teamUsers();
      } else {
        userEntities = this.userRepository.connected_users();
      }

      return userEntities.filter(userEntity => {
        return !activeConversation.participating_user_ids().find(id => userEntity.id === id);
      });
    });

    this.isSearching = ko.pureComputed(() => this.searchInput().length);
    this.headerText = ko.pureComputed(() => {
      const stringSelector = this.selectedContacts().length
        ? z.string.addParticipantsHeaderWithCounter
        : z.string.addParticipantsHeader;
      return z.l10n.text(stringSelector, {number: this.selectedContacts().length});
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => (this.contacts() || this.searchInput()) && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});

    this.searchInput.subscribe(searchInput => this.searchServices(searchInput));
    this.clickOnSelectService = this.clickOnSelectService.bind(this);
  }

  getElementId() {
    return 'add-participants';
  }

  clickOnAddPeople() {
    this.state(AddParticipantsViewModel.STATE.ADD_PEOPLE);
  }

  clickOnAddService() {
    this.state(AddParticipantsViewModel.STATE.ADD_SERVICE);
    this.searchServices(this.searchInput());
  }

  clickOnSelectService(serviceEntity) {
    this.selectedService(serviceEntity);
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE, {
      addMode: true,
      entity: serviceEntity,
    });
  }

  clickToAddParticipants() {
    this._addMembers();
    this.onGoBack();
  }

  clickOpenManageServices() {
    const path = `${z.config.URL_PATH.MANAGE_SERVICES}?utm_source=client_landing&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  initView() {
    this.state(AddParticipantsViewModel.STATE.ADD_PEOPLE);
    this.selectedContacts.removeAll();
    this.selectedService(undefined);
    this.searchInput('');
    this.isInitialServiceSearch(true);
  }

  searchServices(query) {
    if (this.isStateAddService()) {
      this.integrationRepository
        .searchForServices(this.searchInput(), this.searchInput)
        .then(() => this.isInitialServiceSearch(false));
    }
  }

  _addMembers() {
    const activeConversation = this.activeConversation();
    const userEntities = this.selectedContacts().slice();

    this.conversationRepository.addMembers(activeConversation, userEntities).then(() => {
      const attributes = {
        method: 'add',
        user_num: userEntities.length,
      };

      const isTeamConversation = !!this.activeConversation().team_id;
      if (isTeamConversation) {
        const participants = z.tracking.helpers.getParticipantTypes(userEntities, false);

        Object.assign(attributes, {
          guest_num: participants.guests,
          is_allow_guests: activeConversation.isGuestRoom(),
          temporary_guest_num: participants.temporaryGuests,
          user_num: participants.users,
        });
      }

      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.CONVERSATION.ADD_PARTICIPANTS, attributes);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ConversationDetailsViewModel = class ConversationDetailsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get CONFIG() {
    return {
      MAX_USERS_VISIBLE: 7,
      REDUCED_USERS_COUNT: 5,
    };
  }

  constructor(params) {
    super(params);
    this.clickOnShowService = this.clickOnShowService.bind(this);
    this.clickOnShowUser = this.clickOnShowUser.bind(this);

    const {mainViewModel, repositories} = params;

    const {conversation, integration, search, team, user} = repositories;
    this.conversationRepository = conversation;
    this.integrationRepository = integration;
    this.searchRepository = search;
    this.teamRepository = team;
    this.userRepository = user;

    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.ConversationDetailsViewModel', z.config.LOGGER.OPTIONS);

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isTeam = this.teamRepository.isTeam;

    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());

    this.serviceParticipants = ko.observableArray();
    this.userParticipants = ko.observableArray();
    this.showAllUsersCount = ko.observable(0);
    this.selectedService = ko.observable();

    ko.computed(() => {
      if (this.activeConversation()) {
        this.serviceParticipants.removeAll();
        this.userParticipants.removeAll();

        this.activeConversation()
          .participating_user_ets()
          .map(userEntity => {
            if (userEntity.isService) {
              return this.serviceParticipants.push(userEntity);
            }
            this.userParticipants.push(userEntity);
          });

        const userCount = this.userParticipants().length;
        const exceedsMaxUserCount = userCount > ConversationDetailsViewModel.CONFIG.MAX_USERS_VISIBLE;
        if (exceedsMaxUserCount) {
          this.userParticipants.splice(ConversationDetailsViewModel.CONFIG.REDUCED_USERS_COUNT);
        }
        this.showAllUsersCount(exceedsMaxUserCount ? userCount : 0);
      }
    });

    this.firstParticipant = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().firstUserEntity();
    });

    this.isSingleUserMode = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().is1to1() || this.activeConversation().isRequest()
        : false;
    });

    this.isActiveGroupParticipant = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().isGroup() && this.activeConversation().isActiveParticipant()
        : false;
    });

    this.isVerified = ko.pureComputed(() => {
      return this.activeConversation()
        ? this.activeConversation().verification_state() === z.conversation.ConversationVerificationState.VERIFIED
        : false;
    });

    this.isEditingName = ko.observable(false);

    this.isEditingName.subscribe(isEditing => {
      if (isEditing) {
        return window.setTimeout(() => $('.conversation-details__name--input').focus(), 0);
      }
      const name = $('.conversation-details__name--input');
      $('.conversation-details__name').css('height', `${name.height()}px`);
    });

    this.isServiceMode = ko.pureComputed(() => {
      return this.isSingleUserMode() && this.firstParticipant() && this.firstParticipant().isService;
    });

    this.showTopActions = ko.pureComputed(() => this.isActiveGroupParticipant() || this.showSectionOptions());

    this.showActionAddParticipants = this.isActiveGroupParticipant;

    this.showActionBlock = ko.pureComputed(() => {
      if (this.isSingleUserMode() && this.firstParticipant()) {
        return this.firstParticipant().isConnected() || this.firstParticipant().isRequest();
      }
    });

    this.showActionCreateGroup = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().is1to1() && !this.isServiceMode();
    });

    this.showActionCancelRequest = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isRequest();
    });

    this.showActionClear = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isClearable());

    this.showActionLeave = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isLeavable());

    this.showActionMute = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isMutable() && !this.isTeam();
    });

    this.showOptionGuests = ko.pureComputed(() => {
      return this.isActiveGroupParticipant() && this.activeConversation().inTeam();
    });

    this.hasAdvancedNotifications = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().isMutable() && this.isTeam();
    });

    this.showOptionNotificationsGroup = ko.pureComputed(() => {
      return this.hasAdvancedNotifications() && this.activeConversation().isGroup();
    });

    this.showOptionNotifications1To1 = ko.pureComputed(() => {
      return this.hasAdvancedNotifications() && !this.activeConversation().isGroup();
    });

    this.showOptionTimedMessages = this.isActiveGroupParticipant;

    this.showSectionOptions = ko.pureComputed(() => {
      return this.showOptionGuests() || this.showOptionNotificationsGroup() || this.showOptionTimedMessages();
    });

    this.participantsUserText = ko.pureComputed(() => {
      const hasMultipleParticipants = this.userParticipants().length > 1;
      return hasMultipleParticipants
        ? z.string.conversationDetailsParticipantsUsersMany
        : z.string.conversationDetailsParticipantsUsersOne;
    });

    this.participantsServiceText = ko.pureComputed(() => {
      const hasMultipleParticipants = this.serviceParticipants().length > 1;
      return hasMultipleParticipants
        ? z.string.conversationDetailsParticipantsServicesMany
        : z.string.conversationDetailsParticipantsServicesOne;
    });

    this.guestOptionsText = ko.pureComputed(() => {
      return this.isTeamOnly() ? z.string.conversationDetailsGuestsOff : z.string.conversationDetailsGuestsOn;
    });

    this.notificationStatusText = ko.pureComputed(() => {
      return this.activeConversation()
        ? z.conversation.NotificationSetting.getText(this.activeConversation().notificationState())
        : '';
    });

    this.timedMessagesText = ko.pureComputed(() => {
      if (this.activeConversation()) {
        const hasTimer = this.activeConversation().messageTimer() && this.activeConversation().hasGlobalMessageTimer();
        if (hasTimer) {
          return z.util.TimeUtil.formatDuration(this.activeConversation().messageTimer()).text;
        }
      }
      return z.l10n.text(z.string.ephemeralUnitsNone);
    });

    const addPeopleShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.ADD_PEOPLE);
    this.addPeopleTooltip = ko.pureComputed(() => {
      return z.l10n.text(z.string.tooltipConversationDetailsAddPeople, addPeopleShortcut);
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.serviceParticipants() && this.userParticipants() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});

    this.isServiceMode.subscribe(isService => {
      if (isService) {
        const entity = this.firstParticipant();
        this.integrationRepository.getServiceFromUser(entity).then(serviceEntity => {
          this.selectedService(serviceEntity);
          this.integrationRepository.addProviderNameToParticipant(serviceEntity);
        });
      }
    });
  }

  getElementId() {
    return 'conversation-details';
  }

  clickOnAddParticipants() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.ADD_PARTICIPANTS);
  }

  clickOnShowAll() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.CONVERSATION_PARTICIPANTS);
  }

  clickOnCreateGroup() {
    amplify.publish(z.event.WebApp.CONVERSATION.CREATE_GROUP, 'conversation_details', this.firstParticipant());
  }

  clickOnDevices() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.PARTICIPANT_DEVICES, {entity: this.firstParticipant()});
  }

  clickOnGuestOptions() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GUEST_OPTIONS);
  }

  clickOnTimedMessages() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.TIMED_MESSAGES);
  }

  clickOnNotifications() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
  }

  clickOnShowUser(userEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER, {entity: userEntity});
  }

  clickOnShowService(serviceEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_SERVICE, {entity: serviceEntity});
  }

  clickToArchive() {
    this.actionsViewModel.archiveConversation(this.activeConversation());
  }

  clickToBlock() {
    if (this.activeConversation()) {
      const userEntity = this.activeConversation().firstUserEntity();
      const nextConversationEntity = this.conversationRepository.get_next_conversation(this.activeConversation());

      this.actionsViewModel.blockUser(userEntity, true, nextConversationEntity);
    }
  }

  clickToCancelRequest() {
    if (this.activeConversation()) {
      const userEntity = this.activeConversation().firstUserEntity();
      const nextConversationEntity = this.conversationRepository.get_next_conversation(this.activeConversation());

      this.actionsViewModel.cancelConnectionRequest(userEntity, true, nextConversationEntity);
    }
  }

  clickToClear() {
    this.actionsViewModel.clearConversation(this.activeConversation());
  }

  clickToEditGroupName() {
    if (this.isActiveGroupParticipant()) {
      this.isEditingName(true);
    }
  }

  clickToLeave() {
    this.actionsViewModel.leaveConversation(this.activeConversation());
  }

  clickToToggleMute() {
    this.actionsViewModel.toggleMuteConversation(this.activeConversation());
  }

  renameConversation(data, event) {
    if (this.activeConversation()) {
      const currentConversationName = this.activeConversation()
        .display_name()
        .trim();

      const newConversationName = z.util.StringUtil.removeLineBreaks(event.target.value.trim());

      this.isEditingName(false);
      const hasNameChanged = newConversationName.length && newConversationName !== currentConversationName;
      if (hasNameChanged) {
        event.target.value = currentConversationName;
        this.conversationRepository.renameConversation(this.activeConversation(), newConversationName);
      }
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ConversationParticipantsViewModel = class ConversationParticipantsViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);
    this.clickOnShowUser = this.clickOnShowUser.bind(this);

    const repositories = params.repositories;
    this.searchRepository = repositories.search;

    this.participants = ko.pureComputed(() => {
      if (this.activeConversation()) {
        return this.activeConversation()
          .participating_user_ets()
          .filter(userEntity => !userEntity.isService);
      }
      return [];
    });

    this.highlightedUsers = ko.observable([]);

    this.searchInput = ko.observable('');

    this.shouldUpdateScrollbar = ko
      .computed(() => (this.participants() || this.searchInput()) && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});
  }

  getElementId() {
    return 'conversation-participants';
  }

  clickOnShowUser(userEntity) {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.GROUP_PARTICIPANT_USER, {entity: userEntity});
  }

  initView(highlightedUsers = []) {
    this.searchInput('');
    this.highlightedUsers(highlightedUsers);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GroupParticipantUserViewModel = class GroupParticipantUserViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);

    const {mainViewModel, repositories} = params;

    this.userRepository = repositories.user;
    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.GroupParticipantUserViewModel', z.config.LOGGER.OPTIONS);

    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selectedParticipant = ko.observable(undefined);

    this.selectedIsConnected = ko.pureComputed(() => {
      return this.selectedParticipant().isConnected() || this.selectedParticipant().isTeamMember();
    });
    this.selectedIsInConversation = ko.pureComputed(() => {
      if (this.isVisible()) {
        const participatingUserIds = this.activeConversation().participating_user_ids();
        return participatingUserIds.some(id => this.selectedParticipant().id === id);
      }
    });

    this.selfIsActiveParticipant = ko.pureComputed(() => {
      return this.isVisible() ? this.activeConversation().isActiveParticipant() : false;
    });

    this.showActionsIncomingRequest = ko.pureComputed(() => this.selectedParticipant().isIncomingRequest());
    this.showActionsOutgoingRequest = ko.pureComputed(() => this.selectedParticipant().isOutgoingRequest());

    this.showActionBlock = ko.pureComputed(() => {
      return this.selectedParticipant().isConnected() || this.selectedParticipant().isRequest();
    });
    this.showActionDevices = ko.pureComputed(() => !this.selectedParticipant().is_me);
    this.showActionOpenConversation = ko.pureComputed(() => {
      return this.selectedIsConnected() && !this.selectedParticipant().is_me;
    });
    this.showActionRemove = ko.pureComputed(() => this.selfIsActiveParticipant() && this.selectedIsInConversation());
    this.showActionSelfProfile = ko.pureComputed(() => this.selectedParticipant().is_me);
    this.showActionSendRequest = ko.pureComputed(() => {
      const isNotConnectedUser = this.selectedParticipant().isCanceled() || this.selectedParticipant().isUnknown();
      const canConnect = !this.selectedParticipant().isTeamMember() && !this.selectedParticipant().isTemporaryGuest();
      return isNotConnectedUser && canConnect;
    });
    this.showActionLeave = ko.pureComputed(() => {
      const isActiveParticipant = this.activeConversation() && !this.activeConversation().removed_from_conversation();
      return this.selectedParticipant().is_me && isActiveParticipant;
    });
    this.showActionUnblock = ko.pureComputed(() => this.selectedParticipant().isBlocked());

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedParticipant() && this.isVisible())
      .extend({notify: 'always', rateLimit: 500});
  }

  getElementId() {
    return 'group-participant-user';
  }

  getEntityId() {
    return this.selectedParticipant().id;
  }

  clickOnDevices() {
    this.navigateTo(z.viewModel.PanelViewModel.STATE.PARTICIPANT_DEVICES, {entity: this.selectedParticipant()});
  }

  clickOnShowProfile() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickOnOpenConversation() {
    this.actionsViewModel.open1to1Conversation(this.selectedParticipant());
  }

  clickToAcceptRequest() {
    this.actionsViewModel.acceptConnectionRequest(this.selectedParticipant(), true);
  }

  clickToBlock() {
    this.actionsViewModel.blockUser(this.selectedParticipant());
  }

  clickToCancelRequest() {
    this.actionsViewModel.cancelConnectionRequest(this.selectedParticipant());
  }

  clickToIgnoreRequest() {
    this.actionsViewModel.ignoreConnectionRequest(this.selectedParticipant());
  }

  clickToLeave() {
    this.actionsViewModel.leaveConversation(this.activeConversation());
  }

  clickToRemove() {
    this.actionsViewModel
      .removeFromConversation(this.activeConversation(), this.selectedParticipant())
      .then(this.onGoBack);
  }

  clickToSendRequest() {
    this.actionsViewModel.sendConnectionRequest(this.selectedParticipant());
  }

  clickToUnblock() {
    this.actionsViewModel.unblockUser(this.selectedParticipant(), false);
  }

  initView({entity: user}) {
    const userEntity = user;
    this.selectedParticipant(userEntity);

    if (userEntity.isTemporaryGuest()) {
      userEntity.checkGuestExpiration();
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GroupParticipantServiceViewModel = class GroupParticipantServiceViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  constructor(params) {
    super(params);

    const {mainViewModel, repositories} = params;

    this.integrationRepository = repositories.integration;
    this.actionsViewModel = mainViewModel.actions;

    this.logger = new z.util.Logger('z.viewModel.panel.GroupParticipantServiceViewModel', z.config.LOGGER.OPTIONS);

    this.selectedParticipant = ko.observable(undefined);
    this.selectedService = ko.observable(undefined);

    this.isAddMode = ko.observable(false);

    this.conversationInTeam = ko.pureComputed(() => this.activeConversation() && this.activeConversation().inTeam());

    this.selectedInConversation = ko.pureComputed(() => {
      if (this.isVisible() && this.activeConversation()) {
        const participatingUserIds = this.activeConversation().participating_user_ids();
        return participatingUserIds.some(id => this.selectedParticipant().id === id);
      }
    });

    this.selfIsActiveParticipant = ko.pureComputed(() => {
      return this.isVisible() ? this.activeConversation().isActiveParticipant() : false;
    });

    this.showActions = ko.pureComputed(() => {
      return this.selfIsActiveParticipant() && this.selectedInConversation() && this.conversationInTeam();
    });

    this.shouldUpdateScrollbar = ko
      .computed(() => this.selectedService() && this.selectedService().providerName() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'group-participant-service';
  }

  getEntityId() {
    return this.selectedParticipant().id;
  }

  clickOnAdd() {
    this.integrationRepository.addService(this.activeConversation(), this.selectedService(), 'conversation_details');
    this.onGoToRoot();
  }

  clickToOpen() {
    this.actionsViewModel.open1to1ConversationWithService(this.selectedService());
  }

  clickToRemove() {
    this.actionsViewModel
      .removeFromConversation(this.activeConversation(), this.selectedParticipant())
      .then(this.onGoBack);
  }

  initView({entity: service, addMode = false}) {
    const serviceEntity = ko.unwrap(service);
    this.selectedParticipant(serviceEntity);
    this.selectedService(undefined);
    this.isAddMode(addMode);
    this._showService(this.selectedParticipant());
  }

  _showService(entity) {
    this.integrationRepository.getServiceFromUser(entity).then(serviceEntity => {
      this.selectedService(serviceEntity);
      this.integrationRepository.addProviderNameToParticipant(serviceEntity);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.GuestsAndServicesViewModel = class GuestsAndServicesViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get CONFIG() {
    return {
      CONFIRM_DURATION: 1500,
    };
  }

  constructor(params) {
    super(params);

    this.copyLink = this.copyLink.bind(this);
    this.toggleAccessState = this.toggleAccessState.bind(this);
    this.requestAccessCode = this.requestAccessCode.bind(this);
    this.revokeAccessCode = this.revokeAccessCode.bind(this);

    const repositories = params.repositories;
    const conversationRepository = repositories.conversation;
    this.stateHandler = conversationRepository.stateHandler;

    this.logger = new z.util.Logger('z.viewModel.panel.GuestsAndServicesViewModel', z.config.LOGGER.OPTIONS);

    this.isLinkCopied = ko.observable(false);
    this.requestOngoing = ko.observable(false);

    this.isGuestRoom = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isGuestRoom());
    this.isTeamOnly = ko.pureComputed(() => this.activeConversation() && this.activeConversation().isTeamOnly());
    this.hasAccessCode = ko.pureComputed(() => (this.isGuestRoom() ? !!this.activeConversation().accessCode() : false));
    this.isGuestEnabled = ko.pureComputed(() => !this.isTeamOnly());
    this.showLinkOptions = ko.pureComputed(() => this.isGuestEnabled());

    this.activeConversation.subscribe(conversationEntity => this._updateCode(this.isVisible(), conversationEntity));
    this.isVisible.subscribe(isVisible => this._updateCode(isVisible, this.activeConversation()));

    this.shouldUpdateScrollbar = ko
      .computed(() => this.isGuestEnabled() && this.hasAccessCode() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'guest-options';
  }

  copyLink() {
    if (!this.isLinkCopied() && this.activeConversation()) {
      z.util.ClipboardUtil.copyText(this.activeConversation().accessCode()).then(() => {
        this.isLinkCopied(true);
        amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.LINK_COPIED);
        window.setTimeout(() => this.isLinkCopied(false), GuestsAndServicesViewModel.CONFIG.CONFIRM_DURATION);
      });
    }
  }

  requestAccessCode() {
    // Handle conversations in legacy state
    const accessStatePromise = this.isGuestRoom()
      ? Promise.resolve()
      : this.stateHandler.changeAccessState(this.activeConversation(), z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);

    accessStatePromise.then(() => {
      if (!this.requestOngoing()) {
        this.requestOngoing(true);

        this.stateHandler.requestAccessCode(this.activeConversation()).then(() => this.requestOngoing(false));
      }
    });
  }

  revokeAccessCode() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => {
        if (!this.requestOngoing()) {
          this.requestOngoing(true);

          this.stateHandler.revokeAccessCode(this.activeConversation()).then(() => this.requestOngoing(false));
        }
      },
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalConversationRevokeLinkAction),
        message: z.l10n.text(z.string.modalConversationRevokeLinkMessage),
        title: z.l10n.text(z.string.modalConversationRevokeLinkHeadline),
      },
    });
  }

  toggleAccessState() {
    const conversationEntity = this.activeConversation();
    if (conversationEntity.inTeam()) {
      const newAccessState = this.isTeamOnly()
        ? z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM
        : z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY;

      const _changeAccessState = () => {
        if (!this.requestOngoing()) {
          this.requestOngoing(true);

          this.stateHandler
            .changeAccessState(conversationEntity, newAccessState)
            .then(() => this.requestOngoing(false));
        }
      };

      const hasGuestOrService = conversationEntity.hasGuest() || conversationEntity.hasService();

      if (this.isTeamOnly() || !hasGuestOrService) {
        return _changeAccessState();
      }

      amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
        action: () => _changeAccessState(),
        preventClose: true,
        text: {
          action: z.l10n.text(z.string.modalConversationRemoveGuestsAction),
          message: z.l10n.text(z.string.modalConversationRemoveGuestsMessage),
          title: z.l10n.text(z.string.modalConversationRemoveGuestsHeadline),
        },
      });
    }
  }

  _updateCode(isVisible, conversationEntity) {
    const updateCode = conversationEntity && conversationEntity.isGuestRoom() && !conversationEntity.accessCode();
    if (isVisible && updateCode) {
      this.requestOngoing(true);
      this.stateHandler.getAccessCode(conversationEntity).then(() => this.requestOngoing(false));
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.NotificationsViewModel = class NotificationsViewModel extends z.viewModel.panel.BasePanelViewModel {
  constructor(params) {
    super(params);
    this.clickOnNotificationSetting = this.clickOnNotificationSetting.bind(this);

    const conversation = params.repositories.conversation;
    this.conversationRepository = conversation;

    this.logger = new z.util.Logger('z.viewModel.panel.NotificationsViewModel', z.config.LOGGER.OPTIONS);

    this.settings = Object.values(z.conversation.NotificationSetting.STATE).map(status => ({
      text: z.conversation.NotificationSetting.getText(status),
      value: status,
    }));

    this.isRendered = ko.observable(false).extend({notify: 'always'});

    this.currentNotificationSetting = ko.pureComputed(() => {
      return this.activeConversation() && this.activeConversation().notificationState();
    });

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.isRendered())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'notification-settings';
  }

  clickOnNotificationSetting({value}) {
    if (this.activeConversation()) {
      this.conversationRepository.setNotificationState(this.activeConversation(), value);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.TimedMessagesViewModel = class TimedMessagesViewModel extends z.viewModel.panel.BasePanelViewModel {
  constructor(params) {
    super(params);

    this.clickOnMessageTime = this.clickOnMessageTime.bind(this);
    this.clickOnMessageTimeOff = this.clickOnMessageTime.bind(this, {value: null});

    const conversation = params.repositories.conversation;
    this.conversationRepository = conversation;

    this.logger = new z.util.Logger('z.viewModel.panel.TimedMessagesViewModel', z.config.LOGGER.OPTIONS);

    this.messageTimes = ko.pureComputed(() => {
      const times = z.ephemeral.timings.VALUES;
      const currentTime = this.currentMessageTimer();

      times.sort((timeA, timeB) => timeA - timeB);

      const mappedTimes = times.map(time => ({
        text: z.util.TimeUtil.formatDuration(time).text,
        value: time,
      }));

      if (currentTime && !times.includes(currentTime)) {
        mappedTimes.push({
          isCustom: true,
          text: z.util.TimeUtil.formatDuration(currentTime).text,
          value: currentTime,
        });
      }

      return mappedTimes;
    });

    this.isRendered = ko.observable(false).extend({notify: 'always'});

    this.currentMessageTimer = ko.pureComputed(() => {
      return this.activeConversation().hasGlobalMessageTimer() ? this.activeConversation().messageTimer() : 0;
    });

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.isRendered())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'timed-messages';
  }

  clickOnMessageTime({value}) {
    const activeConversation = this.activeConversation();
    activeConversation.globalMessageTimer(value);
    this.conversationRepository.updateConversationMessageTimer(activeConversation, value);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.panel = z.viewModel.panel || {};

z.viewModel.panel.ParticipantDevicesViewModel = class ParticipantDevicesViewModel extends z.viewModel.panel
  .BasePanelViewModel {
  static get MODE() {
    return {
      FOUND: 'ParticipantDevicesViewModel.MODE.FOUND',
      NOT_FOUND: 'ParticipantDevicesViewModel.MODE.NOT_FOUND',
      REQUESTING: 'ParticipantDevicesViewModel.MODE.REQUESTING',
    };
  }

  constructor(params) {
    super(params);
    this.clickOnDevice = this.clickOnDevice.bind(this);

    const {client, conversation, cryptography} = params.repositories;
    this.clientRepository = client;
    this.conversationRepository = conversation;
    this.cryptographyRepository = cryptography;

    this.logger = new z.util.Logger('z.viewModel.panel.ParticipantDevicesViewModel', z.config.LOGGER.OPTIONS);

    this.selfClient = this.clientRepository.currentClient;

    this.deviceMode = ko.observable(ParticipantDevicesViewModel.MODE.REQUESTING);
    this.fingerprintLocal = ko.observableArray([]);
    this.fingerprintRemote = ko.observableArray([]);
    this.isResettingSession = ko.observable(false);
    this.showSelfFingerprint = ko.observable(false);
    this.selectedClient = ko.observable();
    this.selectedClientSubscription = undefined;
    this.userEntity = ko.observable();

    this.clientEntities = ko.pureComputed(() => this.userEntity() && this.userEntity().devices());

    this.showDeviceDetails = ko.pureComputed(() => this.selectedClient() && !this.showSelfFingerprint());
    this.showDevicesFound = ko.pureComputed(() => {
      const modeIsFound = this.deviceMode() === ParticipantDevicesViewModel.MODE.FOUND;
      return !this.selectedClient() && !this.showSelfFingerprint() && modeIsFound;
    });
    this.showDevicesNotFound = ko.pureComputed(() => {
      const modeIsNotFound = this.deviceMode() === ParticipantDevicesViewModel.MODE.NOT_FOUND;
      return !this.selectedClient() && !this.showSelfFingerprint() && modeIsNotFound;
    });

    this.detailMessage = ko.pureComputed(() => {
      if (!this.userEntity()) {
        return '';
      }

      const text = z.l10n.text(z.string.participantDevicesDetailHeadline, {user: this.userEntity().first_name()});

      const textWithHtmlTags = /\{\{[^\}]+\}\}[^\{]+\{\{[^\}]+\}\}/;
      const textWithinHtmlTags = /\{\{[^\}]+\}\}/gm;

      const [pivot] = text.match(textWithHtmlTags) || [];
      const sanitizedText = z.util.StringUtil.splitAtPivotElement(text, pivot, pivot);

      return sanitizedText.map(element => {
        if (element.isStyled) {
          element.text = element.text.replace(textWithinHtmlTags, '');
        }
        return element;
      });
    });

    this.devicesHeadlineText = ko.pureComputed(() => {
      return this.userEntity() ? z.l10n.text(z.string.participantDevicesHeadline, this.userEntity().first_name()) : '';
    });

    this.noDevicesHeadlineText = ko.pureComputed(() => {
      return this.userEntity()
        ? z.l10n.text(z.string.participantDevicesOutdatedClientMessage, this.userEntity().first_name())
        : '';
    });

    this.isVisible.subscribe(isVisible => {
      if (isVisible && this.userEntity()) {
        const userId = this.userEntity().id;

        this.clientRepository
          .getClientsByUserId(userId)
          .then(clientEntities => {
            const hasDevices = clientEntities.length > 0;
            const deviceMode = hasDevices
              ? ParticipantDevicesViewModel.MODE.FOUND
              : ParticipantDevicesViewModel.MODE.NOT_FOUND;
            this.deviceMode(deviceMode);
          })
          .catch(error => {
            this.logger.error(`Unable to retrieve clients for user '${userId}': ${error.message || error}`);
          });
      }

      this.selectedClientSubscription = this.selectedClient.subscribe(() => {
        this.fingerprintRemote([]);

        if (this.selectedClient()) {
          this.cryptographyRepository
            .getRemoteFingerprint(this.userEntity().id, this.selectedClient().id)
            .then(remoteFingerprint => this.fingerprintRemote(remoteFingerprint));
        }
      });
    });
    this.shouldUpdateScrollbar = ko
      .computed(() => this.clientEntities() && this.showDeviceDetails() && this.isVisible())
      .extend({notify: 'always', rateLimit: {method: 'notifyWhenChangesStop', timeout: 0}});
  }

  getElementId() {
    return 'participant-devices';
  }

  clickOnBack() {
    if (this.showSelfFingerprint()) {
      return this.showSelfFingerprint(false);
    }

    if (this.selectedClient()) {
      return this.selectedClient(undefined);
    }

    this.onGoBack();
  }

  clickOnDevice(clientEntity) {
    this.selectedClient(clientEntity);
  }

  clickToResetSession() {
    const _resetProgress = () => window.setTimeout(() => this.isResettingSession(false), z.motion.MotionDuration.LONG);

    this.isResettingSession(true);
    this.conversationRepository
      .reset_session(this.userEntity().id, this.selectedClient().id, this.activeConversation().id)
      .then(() => _resetProgress())
      .catch(() => _resetProgress());
  }

  clickOnShowSelfDevices() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_DEVICES);
  }

  clickToShowSelfFingerprint() {
    if (!this.fingerprintLocal().length) {
      this.fingerprintLocal(this.cryptographyRepository.getLocalFingerprint());
    }
    this.showSelfFingerprint(true);
  }

  clickToToggleDeviceVerification() {
    const toggleVerified = !this.selectedClient().meta.isVerified();

    this.clientRepository
      .verifyClient(this.userEntity().id, this.selectedClient(), toggleVerified)
      .catch(error => this.logger.warn(`Failed to toggle client verification: ${error.message}`));
  }

  initView({entity: userEntity}) {
    this.showSelfFingerprint(false);
    this.selectedClient(undefined);
    this.deviceMode(ParticipantDevicesViewModel.MODE.REQUESTING);

    if (this.selectedClientSubscription) {
      this.selectedClientSubscription.dispose();
    }
    this.userEntity(userEntity);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};

z.viewModel.ListViewModel = class ListViewModel {
  static get MODAL_TYPE() {
    return {
      TAKEOVER: 'ListViewModel.MODAL_TYPE.TAKEOVER',
      TEMPORARY_GUEST: 'ListViewModal.MODAL_TYPE.TEMPORARY_GUEST',
    };
  }

  static get STATE() {
    return {
      ARCHIVE: 'ListViewModel.STATE.ARCHIVE',
      CONVERSATIONS: 'ListViewModel.STATE.CONVERSATIONS',
      PREFERENCES: 'ListViewModel.STATE.PREFERENCES',
      START_UI: 'ListViewModel.STATE.START_UI',
      TEMPORARY_GUEST: 'ListViewModel.STATE.TEMPORARY_GUEST',
    };
  }
  /**
   * View model for the list column.
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {Object} repositories - Object containing all the repositories
   */
  constructor(mainViewModel, repositories) {
    this.changeNotificationSetting = this.changeNotificationSetting.bind(this);
    this.switchList = this.switchList.bind(this);
    this.onContextMenu = this.onContextMenu.bind(this);

    this.elementId = 'left-column';
    this.conversationRepository = repositories.conversation;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;

    this.actionsViewModel = mainViewModel.actions;
    this.contentViewModel = mainViewModel.content;
    this.panelViewModel = mainViewModel.panel;

    this.isActivatedAccount = this.userRepository.isActivatedAccount;
    this.isProAccount = this.teamRepository.isTeam;
    this.selfUser = this.userRepository.self;

    this.logger = new z.util.Logger('z.viewModel.ListViewModel', z.config.LOGGER.OPTIONS);

    // State
    this.state = ko.observable(ListViewModel.STATE.CONVERSATIONS);
    this.lastUpdate = ko.observable();
    this.modal = ko.observable();
    this.webappLoaded = ko.observable(false);

    this.selfUserPicture = ko.pureComputed(() => {
      if (this.webappLoaded() && this.selfUser()) {
        return this.selfUser().mediumPictureResource();
      }
    });

    this.visibleListItems = ko.pureComputed(() => {
      const isStatePreferences = this.state() === ListViewModel.STATE.PREFERENCES;
      if (isStatePreferences) {
        const preferenceItems = [
          z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS,
          z.viewModel.ContentViewModel.STATE.PREFERENCES_AV,
        ];

        if (!z.util.Environment.desktop) {
          preferenceItems.push(z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT);
        }

        return preferenceItems;
      }

      const hasConnectRequests = !!this.userRepository.connect_requests().length;
      const states = hasConnectRequests ? z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS : [];
      return this.conversationRepository
        .conversations_calls()
        .concat(states, this.conversationRepository.conversations_unarchived());
    });

    // Nested view models
    this.archive = new z.viewModel.list.ArchiveViewModel(mainViewModel, this, repositories);
    this.conversations = new z.viewModel.list.ConversationListViewModel(mainViewModel, this, repositories);
    this.preferences = new z.viewModel.list.PreferencesListViewModel(mainViewModel, this, repositories);
    this.start = new z.viewModel.list.StartUIViewModel(mainViewModel, this, repositories);
    this.takeover = new z.viewModel.list.TakeoverViewModel(mainViewModel, this, repositories);
    this.temporaryGuest = new z.viewModel.list.TemporaryGuestViewModel(mainViewModel, this, repositories);

    this._initSubscriptions();

    ko.applyBindings(this, document.getElementById(this.elementId));
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONVERSATION.SHOW, this.openConversations.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, () => this.webappLoaded(true));
    amplify.subscribe(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT, this.openPreferencesAccount.bind(this));
    amplify.subscribe(z.event.WebApp.PREFERENCES.MANAGE_DEVICES, this.openPreferencesDevices.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.SHOW, this.openStartUI.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.NEXT, this.goToNext.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.PREV, this.goToPrevious.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.ARCHIVE, this.clickToArchive.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.DELETE, this.clickToClear.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.NOTIFICATIONS, this.changeNotificationSetting);
    amplify.subscribe(z.event.WebApp.SHORTCUT.SILENCE, this.changeNotificationSetting); // todo: deprecated - remove when user base of wrappers version >= 3.4 is large enough
  }

  changeNotificationSetting() {
    if (this.isProAccount()) {
      this.panelViewModel.togglePanel(z.viewModel.PanelViewModel.STATE.NOTIFICATIONS);
    } else {
      this.clickToToggleMute();
    }
  }

  goToNext() {
    this._iterateActiveItem(true);
  }

  goToPrevious() {
    this._iterateActiveItem(false);
  }

  _iterateActiveItem(reverse = false) {
    const isStatePreferences = this.state() === ListViewModel.STATE.PREFERENCES;
    return isStatePreferences ? this._iterateActivePreference(reverse) : this._iterateActiveConversation(reverse);
  }

  _iterateActiveConversation(reverse) {
    const isStateRequests = this.contentViewModel.state() === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    const activeConversationItem = isStateRequests
      ? z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS
      : this.conversationRepository.active_conversation();

    const nextItem = z.util.ArrayUtil.iterateItem(this.visibleListItems(), activeConversationItem, reverse);

    const isConnectionRequestItem = nextItem === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    if (isConnectionRequestItem) {
      return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    if (nextItem) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, nextItem);
    }
  }

  _iterateActivePreference(reverse) {
    let activePreference = this.contentViewModel.state();

    const isDeviceDetails = activePreference === z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS;
    if (isDeviceDetails) {
      activePreference = z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES;
    }

    const nextPreference = z.util.ArrayUtil.iterateItem(this.visibleListItems(), activePreference, reverse);
    if (nextPreference) {
      this.contentViewModel.switchContent(nextPreference);
    }
  }

  openPreferencesAccount() {
    if (this.isActivatedAccount()) {
      this.dismissModal();
    }

    this.switchList(ListViewModel.STATE.PREFERENCES);
    this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  openPreferencesDevices(deviceEntity) {
    this.switchList(ListViewModel.STATE.PREFERENCES);

    if (deviceEntity) {
      this.contentViewModel.preferencesDeviceDetails.device(deviceEntity);
      return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS);
    }

    return this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
  }

  openStartUI() {
    this.switchList(ListViewModel.STATE.START_UI);
  }

  switchList(newListState, respectLastState = true) {
    const isStateChange = this.state() !== newListState;
    if (isStateChange) {
      this._hideList();
      this._updateList(newListState, respectLastState);
      this._showList(newListState);
    }
  }

  openConversations() {
    const newState = this.isActivatedAccount()
      ? ListViewModel.STATE.CONVERSATIONS
      : ListViewModel.STATE.TEMPORARY_GUEST;
    this.switchList(newState, false);
  }

  _hideList() {
    const stateIsStartUI = this.state() === ListViewModel.STATE.START_UI;
    if (stateIsStartUI) {
      this.start.resetView();
    }

    const listStateElementId = this._getElementIdOfList(this.state());
    $(`#${listStateElementId}`).removeClass('left-list-is-visible');
    $(document).off('keydown.listView');
  }

  _showList(newListState) {
    const listStateElementId = this._getElementIdOfList(newListState);
    $(`#${listStateElementId}`).addClass('left-list-is-visible');

    this.state(newListState);
    this.lastUpdate(Date.now());

    $(document).on('keydown.listView', keyboardEvent => {
      if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
        const newState = this.isActivatedAccount()
          ? ListViewModel.STATE.CONVERSATIONS
          : ListViewModel.STATE.TEMPORARY_GUEST;
        this.switchList(newState);
      }
    });
  }

  _updateList(newListState, respectLastState) {
    switch (newListState) {
      case ListViewModel.STATE.ARCHIVE:
        this.archive.updateList();
        break;
      case ListViewModel.STATE.START_UI:
        this.start.updateList();
        break;
      case ListViewModel.STATE.PREFERENCES:
        amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
        break;
      default:
        if (respectLastState) {
          this.contentViewModel.switchPreviousContent();
        }
    }
  }

  _getElementIdOfList(listState) {
    switch (listState) {
      case ListViewModel.STATE.ARCHIVE:
        return 'archive';
      case ListViewModel.STATE.PREFERENCES:
        return 'preferences';
      case ListViewModel.STATE.START_UI:
        return 'start-ui';
      case ListViewModel.STATE.TEMPORARY_GUEST:
        return 'temporary-guest';
      default:
        return 'conversations';
    }
  }

  dismissModal() {
    this.modal(undefined);
  }

  showTakeover() {
    this.modal(ListViewModel.MODAL_TYPE.TAKEOVER);
  }

  showTemporaryGuest() {
    this.switchList(ListViewModel.STATE.TEMPORARY_GUEST);
    this.modal(ListViewModel.MODAL_TYPE.TEMPORARY_GUEST);
    const conversationEntity = this.conversationRepository.getMostRecentConversation();
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
  }

  //##############################################################################
  // Context menu
  //##############################################################################

  onContextMenu(conversationEntity, event) {
    const entries = [];

    if (conversationEntity.isMutable()) {
      const notificationsShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.NOTIFICATIONS);

      if (this.isProAccount()) {
        entries.push({
          click: () => this.clickToOpenNotificationSettings(conversationEntity),
          label: z.l10n.text(z.string.conversationsPopoverNotificationSettings),
          title: z.l10n.text(z.string.tooltipConversationsNotifications, notificationsShortcut),
        });
      } else {
        const labelStringId = conversationEntity.showNotificationsNothing()
          ? z.string.conversationsPopoverNotify
          : z.string.conversationsPopoverSilence;
        const titleStringId = conversationEntity.showNotificationsNothing()
          ? z.string.tooltipConversationsNotify
          : z.string.tooltipConversationsSilence;

        entries.push({
          click: () => this.clickToToggleMute(conversationEntity),
          label: z.l10n.text(labelStringId),
          title: z.l10n.text(titleStringId, notificationsShortcut),
        });
      }
    }

    if (conversationEntity.is_archived()) {
      entries.push({
        click: () => this.clickToUnarchive(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverUnarchive),
      });
    } else {
      const shortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.ARCHIVE);

      entries.push({
        click: () => this.clickToArchive(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverArchive),
        title: z.l10n.text(z.string.tooltipConversationsArchive, shortcut),
      });
    }

    if (conversationEntity.isRequest()) {
      entries.push({
        click: () => this.clickToCancelRequest(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverCancel),
      });
    }

    if (conversationEntity.isClearable()) {
      entries.push({
        click: () => this.clickToClear(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverClear),
      });
    }

    if (!conversationEntity.isGroup()) {
      const userEntity = conversationEntity.firstUserEntity();
      const canBlock = userEntity && (userEntity.isConnected() || userEntity.isRequest());

      if (canBlock) {
        entries.push({
          click: () => this.clickToBlock(conversationEntity),
          label: z.l10n.text(z.string.conversationsPopoverBlock),
        });
      }
    }

    if (conversationEntity.isLeavable()) {
      entries.push({
        click: () => this.clickToLeave(conversationEntity),
        label: z.l10n.text(z.string.conversationsPopoverLeave),
      });
    }

    z.ui.Context.from(event, entries, 'conversation-list-options-menu');
  }

  clickToArchive(conversationEntity = this.conversationRepository.active_conversation()) {
    if (this.isActivatedAccount()) {
      this.actionsViewModel.archiveConversation(conversationEntity);
    }
  }

  clickToBlock(conversationEntity) {
    const userEntity = conversationEntity.firstUserEntity();
    const hideConversation = this._shouldHideConversation(conversationEntity);
    const nextConversationEntity = this.conversationRepository.get_next_conversation(conversationEntity);

    this.actionsViewModel.blockUser(userEntity, hideConversation, nextConversationEntity);
  }

  clickToCancelRequest(conversationEntity) {
    const userEntity = conversationEntity.firstUserEntity();
    const hideConversation = this._shouldHideConversation(conversationEntity);
    const nextConversationEntity = this.conversationRepository.get_next_conversation(conversationEntity);

    this.actionsViewModel.cancelConnectionRequest(userEntity, hideConversation, nextConversationEntity);
  }

  clickToClear(conversationEntity = this.conversationRepository.active_conversation()) {
    this.actionsViewModel.clearConversation(conversationEntity);
  }

  clickToLeave(conversationEntity) {
    this.actionsViewModel.leaveConversation(conversationEntity);
  }

  clickToToggleMute(conversationEntity = this.conversationRepository.active_conversation()) {
    this.actionsViewModel.toggleMuteConversation(conversationEntity);
  }

  clickToOpenNotificationSettings(conversationEntity = this.conversationRepository.active_conversation()) {
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity, {openNotificationSettings: true});
  }

  clickToUnarchive(conversationEntity) {
    this.conversationRepository.unarchiveConversation(conversationEntity, true, 'manual un-archive').then(() => {
      if (!this.conversationRepository.conversations_archived().length) {
        this.switchList(ListViewModel.STATE.CONVERSATIONS);
      }
    });
  }

  _shouldHideConversation(conversationEntity) {
    const isStateConversations = this.state() === ListViewModel.STATE.CONVERSATIONS;
    const isActiveConversation = this.conversationRepository.is_active_conversation(conversationEntity);

    return isStateConversations && isActiveConversation;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.ArchiveViewModel = class ArchiveViewModel {
  /**
   * View model for the archive.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.clickOnClose = this.clickOnClose.bind(this);
    this.updateList = this.updateList.bind(this);

    this.listViewModel = listViewModel;
    this.conversationRepository = repositories.conversation;
    this.logger = new z.util.Logger('z.viewModel.list.ArchiveViewModel', z.config.LOGGER.OPTIONS);

    this.archivedConversations = this.conversationRepository.conversations_archived;

    this.shouldUpdateScrollbar = ko
      .computed(() => this.listViewModel.lastUpdate())
      .extend({notify: 'always', rateLimit: 500});
  }

  clickOnConversation(conversationEntity) {
    this.conversationRepository.unarchiveConversation(conversationEntity, 'opened conversation from archive');
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
    amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
  }

  clickOnClose() {
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
  }

  updateList() {
    this.conversationRepository.updateArchivedConversations();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.ConversationListViewModel = class ConversationListViewModel {
  /**
   * View model for conversation list.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.isSelectedConversation = this.isSelectedConversation.bind(this);

    this.callingRepository = repositories.calling;
    this.conversationRepository = repositories.conversation;
    this.permissionRepository = repositories.permission;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.videoGridRepository = repositories.videoGrid;

    this.contentViewModel = mainViewModel.content;
    this.listViewModel = listViewModel;

    this.logger = new z.util.Logger('z.viewModel.list.ConversationListViewModel', z.config.LOGGER.OPTIONS);
    this.multitasking = this.contentViewModel.multitasking;

    this.showCalls = ko.observable(false);

    this.contentState = this.contentViewModel.state;
    this.selectedConversation = ko.observable();

    this.isTeam = this.teamRepository.isTeam;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selfUser = ko.pureComputed(() => this.userRepository.self && this.userRepository.self());
    this.selfAvailability = ko.pureComputed(() => this.selfUser() && this.selfUser().availability());
    this.selfUserName = ko.pureComputed(() => this.selfUser() && this.selfUser().name());

    this.connectRequests = this.userRepository.connect_requests;
    this.connectRequestsText = ko.pureComputed(() => {
      const hasMultipleRequests = this.connectRequests().length > 1;
      const stringId = hasMultipleRequests
        ? z.string.conversationsConnectionRequestMany
        : z.string.conversationsConnectionRequestOne;

      return z.l10n.text(stringId, this.connectRequests().length);
    });
    this.stateIsRequests = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS;
    });

    this.callConversations = this.conversationRepository.conversations_calls;
    this.archivedConversations = this.conversationRepository.conversations_archived;
    this.unarchivedConversations = this.conversationRepository.conversations_unarchived;

    this.noConversations = ko.pureComputed(() => {
      const noConversations = !this.unarchivedConversations().length && !this.callConversations().length;
      return noConversations && !this.connectRequests().length;
    });

    this.webappIsLoaded = ko.observable(false);

    this.shouldUpdateScrollbar = ko
      .computed(() => {
        const numberOfConversations = this.unarchivedConversations().length + this.callConversations().length;
        return this.webappIsLoaded() || numberOfConversations || this.connectRequests().length;
      })
      .extend({notify: 'always', rateLimit: 500});

    this.activeConversationId = ko.pureComputed(() => {
      if (this.conversationRepository.active_conversation()) {
        return this.conversationRepository.active_conversation().id;
      }
    });

    this.archiveTooltip = ko.pureComputed(() => {
      return z.l10n.text(z.string.tooltipConversationsArchived, this.archivedConversations().length);
    });

    const startShortcut = z.ui.Shortcut.getShortcutTooltip(z.ui.ShortcutType.START);
    this.startTooltip = z.l10n.text(z.string.tooltipConversationsStart, startShortcut);

    this.showConnectRequests = ko.pureComputed(() => this.connectRequests().length);

    this.showBadge = ko.observable(false);

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.EVENT.NOTIFICATION_HANDLING_STATE, this.setShowCallsState.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.LOADED, this.onWebappLoaded.bind(this));
    amplify.subscribe(z.event.WebApp.SHORTCUT.START, this.clickOnPeopleButton.bind(this));
    amplify.subscribe(z.event.WebApp.SEARCH.BADGE.SHOW, () => this.showBadge(true));
    amplify.subscribe(z.event.WebApp.SEARCH.BADGE.HIDE, () => this.showBadge(false));
  }

  clickOnAvailability(viewModel, event) {
    z.ui.AvailabilityContextMenu.show(event, 'list_header', 'left-list-availability-menu');
  }

  clickOnConnectRequests() {
    this.contentViewModel.switchContent(z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
  }

  clickOnConversation(conversationEntity) {
    if (!this.isSelectedConversation(conversationEntity)) {
      this.contentViewModel.showConversation(conversationEntity);
    }
  }

  setShowCallsState(handlingNotifications) {
    const shouldShowCalls = handlingNotifications === z.event.NOTIFICATION_HANDLING_STATE.WEB_SOCKET;

    const isStateChange = this.showCalls() !== shouldShowCalls;
    if (isStateChange) {
      this.showCalls(shouldShowCalls);
      this.logger.debug(`Set show calls state to: ${this.showCalls()}`);
    }
  }

  isSelectedConversation(conversationEntity) {
    const expectedStates = [
      z.viewModel.ContentViewModel.STATE.COLLECTION,
      z.viewModel.ContentViewModel.STATE.COLLECTION_DETAILS,
      z.viewModel.ContentViewModel.STATE.CONVERSATION,
    ];

    const isSelectedConversation = this.conversationRepository.is_active_conversation(conversationEntity);
    const isExpectedState = expectedStates.includes(this.contentState());

    return isSelectedConversation && isExpectedState;
  }

  onWebappLoaded() {
    this.webappIsLoaded(true);
  }

  //##############################################################################
  // Footer actions
  //##############################################################################

  clickOnArchivedButton() {
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.ARCHIVE);
  }

  clickOnPreferencesButton() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickOnPeopleButton() {
    if (this.isActivatedAccount()) {
      this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.START_UI);
    }
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.PreferencesListViewModel = class PreferencesListViewModel {
  /**
   * View model for the preferences list.
   * @param {z.viewModel.ListViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all the repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.mainViewModel = mainViewModel;
    this.listViewModel = listViewModel;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.PreferencesListViewModel', z.config.LOGGER.OPTIONS);

    this.contentViewModel = this.mainViewModel.content;
    this.contentState = this.contentViewModel.state;
    this.isActivatedAccount = this.userRepository.isActivatedAccount;

    this.selectedAbout = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT;
    });
    this.selectedAccount = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT;
    });
    this.selectedAV = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_AV;
    });
    this.selectedDevices = ko.pureComputed(() => {
      const devicesState = [
        z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICE_DETAILS,
        z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES,
      ];
      return devicesState.includes(this.contentState());
    });
    this.selectedOptions = ko.pureComputed(() => {
      return this.contentState() === z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS;
    });
  }

  clickOnClosePreferences() {
    const preventingContentViewStates = [
      z.viewModel.ContentViewModel.STATE.HISTORY_EXPORT,
      z.viewModel.ContentViewModel.STATE.HISTORY_IMPORT,
    ];

    if (!preventingContentViewStates.includes(this.contentState())) {
      if (!this.isActivatedAccount()) {
        return this.listViewModel.showTemporaryGuest();
      }
      this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);
    }
  }

  clickOnAbout() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ABOUT);
  }

  clickOnAccount() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_ACCOUNT);
  }

  clickOnAV() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_AV);
  }

  clickOnDevices() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_DEVICES);
  }

  clickOnOptions() {
    this._switchContent(z.viewModel.ContentViewModel.STATE.PREFERENCES_OPTIONS);
  }

  _switchContent(newContentState) {
    this.contentViewModel.switchContent(newContentState);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.StartUIViewModel = class StartUIViewModel {
  static get STATE() {
    return {
      ADD_PEOPLE: 'StartUIViewModel.STATE.ADD_PEOPLE',
      ADD_SERVICE: 'StartUIViewModel.STATE.ADD_SERVICE',
    };
  }

  /**
   * View model for the start UI.
   * @class z.viewModel.list.StartUIViewModel
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.clickOnClose = this.clickOnClose.bind(this);
    this.clickOnContact = this.clickOnContact.bind(this);
    this.clickOnConversation = this.clickOnConversation.bind(this);
    this.clickOnOther = this.clickOnOther.bind(this);
    this.clickToOpenService = this.clickToOpenService.bind(this);

    this.clickToAcceptInvite = this.clickToAcceptInvite.bind(this);
    this.clickToIgnoreInvite = this.clickToIgnoreInvite.bind(this);
    this.clickToSendRequest = this.clickToSendRequest.bind(this);
    this.clickToUnblock = this.clickToUnblock.bind(this);

    this.handleSearchInput = this.handleSearchInput.bind(this);

    this.mainViewModel = mainViewModel;
    this.listViewModel = listViewModel;
    this.connectRepository = repositories.connect;
    this.conversationRepository = repositories.conversation;
    this.integrationRepository = repositories.integration;
    this.propertiesRepository = repositories.properties;
    this.searchRepository = repositories.search;
    this.teamRepository = repositories.team;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.StartUIViewModel', z.config.LOGGER.OPTIONS);

    this.actionsViewModel = this.mainViewModel.actions;

    this.selfUser = this.userRepository.self;

    this.isTeam = this.teamRepository.isTeam;
    this.teamName = this.teamRepository.teamName;
    this.teamSize = this.teamRepository.teamSize;

    this.state = ko.observable(StartUIViewModel.STATE.ADD_PEOPLE);

    this.peopleTabActive = ko.pureComputed(() => this.state() === StartUIViewModel.STATE.ADD_PEOPLE);

    this.submittedSearch = false;

    this.search = _.debounce(query => {
      this._clearSearchResults();
      if (this.peopleTabActive()) {
        return this._searchPeople(query);
      }

      this.integrationRepository.searchForServices(query, this.searchInput);
    }, 300);

    this.searchInput = ko.observable('');
    this.searchInput.subscribe(this.search);
    this.isSearching = ko.pureComputed(() => this.searchInput().length);

    // User lists
    this.contacts = ko.pureComputed(() => {
      if (this.showMatches()) {
        return this.matchedUsers();
      }

      return this.isTeam() ? this.teamRepository.teamUsers() : this.userRepository.connected_users();
    });

    this.matchedUsers = ko.observableArray([]);
    this.services = this.integrationRepository.services;
    this.topUsers = ko.observableArray([]);

    this.searchResults = {
      contacts: ko.observableArray([]),
      groups: ko.observableArray([]),
      others: ko.observableArray([]),
    };

    // View states
    this.hasSearchResults = ko.pureComputed(() => {
      const {contacts, groups, others} = this.searchResults;
      return contacts().length || groups().length || others().length;
    });

    this.showContent = ko.pureComputed(() => this.showContacts() || this.showMatches() || this.showSearchResults());
    this.showContacts = ko.pureComputed(() => this.contacts().length);
    this.showCreateGuestRoom = ko.pureComputed(() => this.isTeam());
    this.showInvitePeople = ko.pureComputed(() => !this.isTeam());
    this.showMatches = ko.observable(false);

    this.showNoContacts = ko.pureComputed(() => !this.isTeam() && !this.showContent());
    this.showInviteMember = ko.pureComputed(() => this.selfUser().isTeamOwner() && this.teamSize() === 1);
    this.showNoMatches = ko.pureComputed(() => {
      const isTeamOrMatch = this.isTeam() || this.showMatches();
      return isTeamOrMatch && !this.showInviteMember() && !this.showContacts() && !this.showSearchResults();
    });
    this.showNoSearchResults = ko.pureComputed(() => {
      return !this.showMatches() && this.showSearchResults() && !this.hasSearchResults() && this.isSearching();
    });

    this.showSearchResults = ko.pureComputed(() => {
      const shouldShowResults = this.hasSearchResults() || this.isSearching();
      if (!shouldShowResults) {
        this._clearSearchResults();
      }
      return shouldShowResults;
    });
    this.showSpinner = ko.observable(false);
    this.showTopPeople = ko.pureComputed(() => !this.isTeam() && this.topUsers().length && !this.showMatches());

    // Invite bubble states
    this.showInviteForm = ko.observable(true);

    // Invite bubble
    this.inviteBubble = null;

    this.inviteHint = ko.pureComputed(() => {
      const metaKey = z.util.Environment.os.mac
        ? z.l10n.text(z.string.inviteMetaKeyMac)
        : z.l10n.text(z.string.inviteMetaKeyPc);

      const stringId = this.inviteMessageSelected() ? z.string.inviteHintSelected : z.string.inviteHintUnselected;
      return z.l10n.text(stringId, metaKey);
    });
    this.inviteMessage = ko.pureComputed(() => {
      if (this.selfUser()) {
        const username = this.selfUser().username();
        return username
          ? z.l10n.text(z.string.inviteMessage, `@${username}`)
          : z.l10n.text(z.string.inviteMessageNoEmail);
      }
      return '';
    });
    this.inviteMessageSelected = ko.observable(true);

    // Selected user bubble
    this.userProfile = ko.observable(null);
    this.userProfileIsService = ko.pureComputed(() => this.userProfile() instanceof z.integration.ServiceEntity);

    this.additionalBubbleClasses = ko.pureComputed(() => {
      return this.userProfileIsService() ? 'start-ui-service-bubble' : '';
    });

    this.renderAvatar = ko.observable(false);
    this.renderAvatarComputed = ko.computed(() => {
      const hasUserId = !!this.userProfile();

      // swap value to re-render avatar
      this.renderAvatar(false);
      window.setTimeout(() => this.renderAvatar(hasUserId), 0);
    });

    this.serviceConversations = ko.observable([]);

    this.isTeamManager = ko.pureComputed(() => this.isTeam() && this.selfUser().isTeamManager());
    this.isInitialServiceSearch = ko.observable(true);

    this.userBubble = undefined;
    this.userBubbleLastId = undefined;

    this.shouldUpdateScrollbar = ko
      .computed(() => this.listViewModel.lastUpdate())
      .extend({notify: 'always', rateLimit: 500});

    this.shouldUpdateServiceScrollbar = ko
      .computed(() => this.serviceConversations())
      .extend({notify: 'always', rateLimit: 500});

    this._initSubscriptions();
  }

  _initSubscriptions() {
    amplify.subscribe(z.event.WebApp.CONNECT.IMPORT_CONTACTS, this.importContacts.bind(this));
  }

  clickOnClose() {
    this._closeList();
  }

  clickOnContact(userEntity) {
    return this.actionsViewModel.open1to1Conversation(userEntity).then(() => this._closeList());
  }

  clickOnConversation(conversationEntity) {
    return this.actionsViewModel.openGroupConversation(conversationEntity).then(() => this._closeList());
  }

  clickOnCreateGroup() {
    amplify.publish(z.event.WebApp.CONVERSATION.CREATE_GROUP, 'start_ui');
  }

  clickOnCreateGuestRoom() {
    this.conversationRepository.createGuestRoom().then(conversationEntity => {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
      amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.GUEST_ROOMS.GUEST_ROOM_CREATION);
    });
  }

  clickOpenManageTeam() {
    this._openTeamSettings(z.config.URL_PATH.MANAGE_TEAM);
  }

  clickOpenManageServices() {
    this._openTeamSettings(z.config.URL_PATH.MANAGE_SERVICES);
  }

  _openTeamSettings(pagePath) {
    const path = `${pagePath}?utm_source=client_landing&utm_term=desktop`;
    z.util.SanitizationUtil.safeWindowOpen(z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.TEAM_SETTINGS, path));
    amplify.publish(z.event.WebApp.ANALYTICS.EVENT, z.tracking.EventName.SETTINGS.OPENED_MANAGE_TEAM);
  }

  clickOnOther(participantEntity, event) {
    const isUser = participantEntity instanceof z.entity.User;
    if (isUser && participantEntity.isOutgoingRequest()) {
      return this.clickOnContact(participantEntity);
    }

    const createBubble = elementId => {
      this.userProfile(participantEntity);
      this.userBubbleLastId = elementId;
      this.userBubble = new zeta.webapp.module.Bubble({
        host_selector: `#${element.attr('id')}`,
        on_hide: () => {
          this.userBubble = undefined;
          return (this.userBubbleLastId = undefined);
        },
        on_show: () => $('.start-ui-user-bubble .user-profile-connect-message').focus(),
        scroll_selector: '.start-ui-list',
      });

      if (this.userProfileIsService()) {
        this.integrationRepository.addProviderNameToParticipant(this.userProfile());
      }

      this.userBubble.toggle();
    };

    // We clicked on the same bubble
    const isCurrentBubble = this.userBubbleLastId === event.currentTarget.id;
    if (this.userBubble && isCurrentBubble) {
      return this.userBubble.toggle();
    }

    const element = $(event.currentTarget).attr({
      'data-bubble': '#start-ui-user-bubble',
      'data-placement': 'right-flex',
      id: Date.now(),
    });

    // Dismiss old bubble and wait with creating the new one when another bubble is open
    const timeout = this.userBubble ? z.motion.MotionDuration.LONG : 0;
    if (this.userBubble) {
      this.userBubble.hide();
    }
    window.setTimeout(() => createBubble(element[0].id), timeout);
  }

  clickOnShowPeople() {
    this.updateList(StartUIViewModel.STATE.ADD_PEOPLE);
  }

  clickOnShowServices() {
    this.updateList(StartUIViewModel.STATE.ADD_SERVICE);
  }

  clickToOpenService() {
    if (this.userBubble) {
      this.userBubble.hide();
    }

    this.actionsViewModel.open1to1ConversationWithService(this.userProfile());
  }

  handleSearchInput() {
    if (!this.submittedSearch && this.isSearching()) {
      const [matchingContact] = this.searchResults.contacts();
      if (matchingContact) {
        this.submittedSearch = true;
        return this.clickOnContact(matchingContact).then(() => (this.submittedSearch = false));
      }

      const [matchingGroup] = this.searchResults.groups();
      if (matchingGroup) {
        return this.clickOnConversation(matchingGroup);
      }
    }
  }

  resetView() {
    if (this.userBubble) {
      this.userBubble.hide();
    }

    if (this.inviteBubble) {
      this.inviteBubble.hide();
    }

    this.showMatches(false);
    this.showSpinner(false);

    this.state(StartUIViewModel.STATE.ADD_PEOPLE);
    this.searchInput('');
  }

  updateList(state = StartUIViewModel.STATE.ADD_PEOPLE) {
    this.showSpinner(false);

    // Clean up
    this._clearSearchResults();
    this.userProfile(null);
    $('user-input input').focus();

    this.state(state);
    const isAddingPeople = state === StartUIViewModel.STATE.ADD_PEOPLE;
    if (isAddingPeople) {
      return this._updatePeopleList();
    }
    this._updateServicesList();
  }

  _closeList() {
    $('user-input input').blur();

    amplify.publish(z.event.WebApp.SEARCH.HIDE);
    this.listViewModel.switchList(z.viewModel.ListViewModel.STATE.CONVERSATIONS);

    this.resetView();
  }

  _updatePeopleList() {
    if (!this.isTeam()) {
      this.getTopPeople().then(userEntities => this.topUsers(userEntities));
    }
    this._searchPeople(this.searchInput());
  }

  _updateServicesList() {
    this.isInitialServiceSearch(true);
    this.integrationRepository
      .searchForServices(this.searchInput(), this.searchInput)
      .then(() => this.isInitialServiceSearch(false));
  }

  //##############################################################################
  // Data sources
  //##############################################################################

  getTopPeople() {
    return this.conversationRepository
      .get_most_active_conversations()
      .then(conversationEntities => {
        return conversationEntities
          .filter(conversationEntity => conversationEntity.is1to1())
          .slice(0, 6)
          .map(conversationEntity => conversationEntity.participating_user_ids()[0]);
      })
      .then(userIds => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => userEntities.filter(userEntity => !userEntity.isBlocked()));
  }

  //##############################################################################
  // User bubble
  //##############################################################################

  clickToAcceptInvite(userEntity) {
    this._closeList();
    this.actionsViewModel.acceptConnectionRequest(userEntity, true);
  }

  clickToIgnoreInvite(userEntity) {
    this.actionsViewModel.ignoreConnectionRequest(userEntity).then(() => {
      if (this.userBubble) {
        this.userBubble.hide();
      }
    });
  }

  clickToSendRequest(userEntity) {
    this._closeList();
    this.actionsViewModel.sendConnectionRequest(userEntity, true);
  }

  clickToUnblock(userEntity) {
    this._closeList();
    this.actionsViewModel.unblockUser(userEntity, true);
  }

  //##############################################################################
  // Invite bubble
  //##############################################################################

  clickOnImportContacts() {
    this._importContacts(z.connect.ConnectSource.ICLOUD);
  }

  clickToCloseGenericInvite() {
    this.showInviteForm(false);
  }

  clickToShowGenericInvite() {
    this.showInviteForm(true);
    this._focusInviteForm();
  }

  clickToShowInviteBubble() {
    if (!this.inviteBubble) {
      this.inviteBubble = new zeta.webapp.module.Bubble({
        host_selector: '#invite-button',
        on_hide: () => {
          $('.invite-link-box .bg').removeClass('bg-animation');
          $('.invite-link-box .message').off('copy blur focus');
          this.inviteBubble = null;
          this.showInviteForm(true);
        },
        on_show: () => {
          if (this.showInviteForm()) {
            this._focusInviteForm();
          }
        },
        scroll_selector: '.start-ui-list',
      });

      this.inviteBubble.show();
    }
  }

  _importContacts(type) {
    if (this.inviteBubble) {
      this.inviteBubble.hide();
    }
    this.importContacts(type);
  }

  _focusInviteForm() {
    $('.invite-link-box .message')
      .on('copy', event => {
        $(event.currentTarget)
          .parent()
          .find('.bg')
          .addClass('bg-animation')
          .on(z.util.alias.animationend, _event => {
            if (_event.originalEvent.animationName === 'message-bg-fadeout') {
              $(this).off(z.util.alias.animationend);

              if (this.inviteBubble) {
                this.inviteBubble.hide();
              }
            }
          });
      })
      .on('blur', () => this.inviteMessageSelected(false))
      .on('click', event => {
        this.inviteMessageSelected(true);
        $(event.target).select();
      })
      .trigger('click');
  }

  //##############################################################################
  // Contacts import
  //##############################################################################

  /**
   * Connect with contacts.
   * @param {z.connect.ConnectSource} source - Source for the contacts import
   * @returns {undefined} No return value
   */
  importContacts(source) {
    this.connectRepository
      .getContacts(source)
      .then((userIds = []) => this.userRepository.get_users_by_id(userIds))
      .then(userEntities => {
        this.matchedUsers(userEntities);
        this.showMatches(true);
      })
      .catch(error => {
        const isNoContacts = error.type === z.error.ConnectError.TYPE.NO_CONTACTS;
        if (!isNoContacts) {
          this.logger.error(`Importing contacts from '${source}' failed: ${error.message}`, error);

          amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.ACKNOWLEDGE, {
            action: () => this.importContacts(source),
            text: {
              action: z.l10n.text(z.string.modalUploadContactsAction),
              message: z.l10n.text(z.string.modalUploadContactsMessage),
            },
          });
        }
      })
      .then(error => {
        this.showSpinner(false);
      });
  }

  //##############################################################################
  // Search
  //##############################################################################

  _clearSearchResults() {
    this.searchResults.groups.removeAll();
    this.searchResults.contacts.removeAll();
    this.searchResults.others.removeAll();
    this.services.removeAll();
  }

  _searchPeople(query) {
    const normalizedQuery = z.search.SearchRepository.normalizeQuery(query);
    if (normalizedQuery) {
      this.showMatches(false);

      // Contacts, groups and others
      const trimmedQuery = query.trim();
      const isHandle = trimmedQuery.startsWith('@') && z.user.UserHandleGenerator.validate_handle(normalizedQuery);

      this.searchRepository
        .search_by_name(normalizedQuery, isHandle)
        .then(userEntities => {
          const isCurrentQuery = normalizedQuery === z.search.SearchRepository.normalizeQuery(this.searchInput());
          if (isCurrentQuery) {
            this.searchResults.others(userEntities);
          }
        })
        .catch(error => this.logger.error(`Error searching for contacts: ${error.message}`, error));

      const localSearchSources = this.isTeam()
        ? this.teamRepository.teamUsers()
        : this.userRepository.connected_users();

      const SEARCHABLE_FIELDS = z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS;
      const searchFields = isHandle ? [SEARCHABLE_FIELDS.USERNAME] : undefined;

      const contactResults = this.searchRepository.searchUserInSet(normalizedQuery, localSearchSources, searchFields);

      this.searchResults.contacts(contactResults);
      this.searchResults.groups(this.conversationRepository.getGroupsByName(normalizedQuery, isHandle));
    }
  }

  dispose() {
    this.renderAvatarComputed.dispose();
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.TakeoverViewModel = class TakeoverViewModel {
  /**
   * View model for the username takeover screen.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.listViewModel = listViewModel;
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.logger = new z.util.Logger('z.viewModel.list.TakeoverViewModel', z.config.LOGGER.OPTIONS);

    this.selfUser = this.userRepository.self;

    this.name = ko.pureComputed(() => (this.selfUser() ? this.selfUser().name() : ''));
    this.username = ko.pureComputed(() => (this.selfUser() ? this.selfUser().username() : ''));
  }

  chooseUsername() {
    this.listViewModel.dismissModal();
    window.requestAnimationFrame(() => amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT));
  }

  keepUsername() {
    this.userRepository
      .change_username(this.username())
      .then(() => {
        const conversationEntity = this.conversationRepository.getMostRecentConversation();
        if (conversationEntity) {
          return amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
        }

        if (this.userRepository.connect_requests().length) {
          amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
        }
      })
      .catch(() => amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT))
      .then(() => this.listViewModel.dismissModal());
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.viewModel = z.viewModel || {};
window.z.viewModel.list = z.viewModel.list || {};

z.viewModel.list.TemporaryGuestViewModel = class TemporaryGuestViewModel {
  /**
   * View model for the temporary guest experience.
   *
   * @param {z.viewModel.MainViewModel} mainViewModel - Main view model
   * @param {z.viewModel.ListViewModel} listViewModel - List view model
   * @param {Object} repositories - Object containing all repositories
   */
  constructor(mainViewModel, listViewModel, repositories) {
    this.conversationRepository = repositories.conversation;
    this.userRepository = repositories.user;
    this.callingRepository = repositories.calling;
    this.multitasking = mainViewModel.content.multitasking;
    this.permissionRepository = repositories.permission;
    this.videoGridRepository = repositories.videoGrid;

    this.logger = new z.util.Logger('z.viewModel.list.TemporaryGuestViewModel', z.config.LOGGER.OPTIONS);

    this.callConversations = this.conversationRepository.conversations_calls;
    this.selfUser = this.userRepository.self;
  }

  clickOnPreferencesButton() {
    amplify.publish(z.event.WebApp.PREFERENCES.MANAGE_ACCOUNT);
  }

  clickToCreateAccount() {
    amplify.publish(z.event.WebApp.WARNING.MODAL, z.viewModel.ModalsViewModel.TYPE.CONFIRM, {
      action: () => window.location.replace(`/auth/${location.search}`),
      preventClose: true,
      text: {
        action: z.l10n.text(z.string.modalAccountCreateAction),
        message: z.l10n.text(z.string.modalAccountCreateMessage),
        title: z.l10n.text(z.string.modalAccountCreateHeadline),
      },
      warning: false,
    });
  }

  isSelectedConversation() {
    return true;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AccentColorPicker = class AccentColorPicker {
  /**
   * Construct a audio seek bar that renders audio levels.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.User} params.user - User entity
   * @param {z.entity.File} params.asset - Asset file
   * @param {ko.observable} params.selected - Selected accent collor
   */
  constructor(params) {
    this.user = ko.unwrap(params.user);

    this.accent_color_ids = [1, 2, 4, 5, 6, 7];

    this.on_select = function(id) {
      params.selected(id);
      return true;
    };
  }
};

// Knockout registration of the accent color picker component.
ko.components.register('accent-color-picker', {
  template: `
    <!-- ko foreach: accent_color_ids -->
      <input type="radio" name="accent"
             data-bind="attr: {'id': 'accent' + $data, 'checked': $parent.user.accent_id() === $data}, click: $parent.on_select">
      <label data-bind="attr: {'for': 'accent' + $data},css: 'accent-color-' + $data"></label>
    <!-- /ko -->
  `,
  viewModel: z.components.AccentColorPicker,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AvailabilityState = class AvailabilityState {
  constructor(params) {
    this.availability = params.availability;
    this.label = params.label;
    this.showArrow = params.showArrow || false;
    this.theme = params.theme || false;
  }
};

ko.components.register('availability-state', {
  template: `
      <!-- ko if: $data.availability() === z.user.AvailabilityType.AVAILABLE -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="available">
          <circle cx="5" cy="5" r="5" stroke="none"></circle>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.availability() === z.user.AvailabilityType.AWAY -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="away">
          <circle cx="5" cy="5" r="4" stroke-width="2" fill="none"></circle>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.availability() === z.user.AvailabilityType.BUSY -->
        <svg class="availability-state-icon" viewBox="0 0 10 10" data-uie-name="busy">
          <path stroke="none" d="M5 10A5 5 0 1 1 5 0a5 5 0 0 1 0 10zM3 4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2H3z"></path>
        </svg>
      <!-- /ko -->
      <!-- ko if: $data.label -->
        <div class="availability-state-label" data-bind="css: {'text-theme': theme}, text: $data.label" data-uie-name="status-label"></div>
      <!-- /ko -->
      <!-- ko if: $data.showArrow -->
        <span class="availability-state-arrow"></span>
      <!-- /ko -->
        `,
  viewModel: z.components.AvailabilityState,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.CopyToClipboard = class CopyToClipboard {
  constructor(params) {
    this.text = params.text;
  }

  onClick(viewModel, event) {
    if (window.getSelection) {
      const selectionRange = document.createRange();
      selectionRange.selectNode(event.currentTarget);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(selectionRange);
    }
  }
};

ko.components.register('copy-to-clipboard', {
  template: `
    <div class="copy-to-clipboard" data-bind="click: onClick, text: text()"></div>
  `,
  viewModel: z.components.CopyToClipboard,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceCard = class DeviceCard {
  constructor(params, componentInfo) {
    this.device = ko.unwrap(params.device) || {};

    const {class: deviceClass, id, label, model} = this.device;
    this.class = deviceClass || '?';
    this.formattedId = id ? this.device.formatId() : [];
    this.id = id || '';
    this.label = label || '?';
    this.model = model || deviceClass || '?'; // devices for other users will only provide the device class

    this.isCurrentClient = params.current || false;
    this.detailed = params.detailed || false;
    this.click = params.click;

    this.dataUieName = `device-card-info${this.isCurrentClient ? '-current' : ''}`;

    if (this.detailed || !this.click) {
      $(componentInfo.element).addClass('device-card-no-hover');
    }
    if (this.detailed) {
      $(componentInfo.element).addClass('device-card-detailed');
    }
  }

  clickOnDevice() {
    if (typeof this.click === 'function') {
      this.click(this.device);
    }
  }
};

ko.components.register('device-card', {
  template: `
    <div class="device-info" data-bind="click: clickOnDevice,
      attr: {'data-uie-uid': id, 'data-uie-value': label, 'data-uie-name': dataUieName}">
      <!-- ko if: detailed -->
        <div class="label-xs device-label" data-bind="text: label"></div>
        <div class="label-xs">
          <span data-bind="l10n_text: z.string.preferencesDevicesId"></span>
          <span data-bind="foreach: formattedId" data-uie-name="device-id"><span class="device-id-part" data-bind="text: $data"></span></span>
        </div>
        <div class="label-xs" data-bind="text: z.util.TimeUtil.formatTimestamp(device.time)"></div>
      <!-- /ko -->
      <!-- ko ifnot: detailed -->
        <div class="label-xs">
          <span class="device-model" data-bind="text: model"></span>
          <span class="text-graphite-dark" data-bind="visible: isCurrentClient, l10n_text: z.string.authLimitDevicesCurrent"></span>
        </div>
        <div class="text-graphite-dark label-xs">
          <span data-bind="l10n_text: z.string.preferencesDevicesId"></span>
          <span data-bind="foreach: formattedId" data-uie-name="device-id"><span class="device-id-part" data-bind="text: $data"></span></span>
        </div>
      <!-- /ko -->
    </div>
    <!-- ko ifnot: detailed || !click-->
      <disclose-icon></disclose-icon>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.DeviceCard(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceRemove = class DeviceRemove {
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);

    this.device = ko.unwrap(params.device);
    this.device_remove_error = params.error || ko.observable(false);
    this.model = this.device.model;

    this.remove_form_visible = ko.observable(false);

    this.password = ko.observable('');
    this.password_subscription = this.password.subscribe(value => {
      if (value.length > 0) {
        return this.device_remove_error(false);
      }
    });

    this.click_on_submit = function() {
      if (typeof params.remove === 'function') {
        params.remove(this.password(), this.device);
      }
    };

    this.click_on_cancel = () => {
      this.remove_form_visible(false);
      if (typeof params.cancel === 'function') {
        params.cancel();
      }
    };

    this.click_on_remove_device = () => {
      this.remove_form_visible(true);
    };
  }

  dispose() {
    this.password_subscription.dispose();
  }
};

ko.components.register('device-remove', {
  template: `
    <!-- ko ifnot: remove_form_visible() -->
      <span class="device-remove-button text-red"
          data-bind="attr: {'data-uie-value': model}, click: click_on_remove_device, l10n_text: z.string.preferencesDevicesRemove"
          data-uie-name="go-remove-device"></span>
    <!-- /ko -->
    <!-- ko if: remove_form_visible() -->
      <form class="device-remove-form" data-bind="submit: click_on_submit, attr: {'data-uie-value': model}" data-ui-name="device-remove-form">
        <input  class="device-remove-input"
                type="password"
                data-bind="hasfocus: true, textInput: password, l10n_placeholder: z.string.authPlaceholderPasswordPut, css: {'device-remove-input-error': device_remove_error}"
                data-uie-name="remove-device-password" />
        <button class="device-remove-button-remove button button-medium button-fluid"
                data-bind="attr: {'data-uie-value': model}, l10n_text: z.string.preferencesDevicesRemove"
                data-uie-name="do-remove-device"
                type="submit"></button>
        <button class="device-remove-button text-graphite text-underline"
                data-bind="click: click_on_cancel, l10n_text: z.string.preferencesDevicesRemoveCancel"
                data-uie-name="remove-device-cancel"></button>
      </form>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.DeviceRemove(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.EphemeralTimer = class EphemeralTimer {
  constructor({message: messageEntity}) {
    this.started = messageEntity.ephemeral_started();
    this.duration = (messageEntity.ephemeral_expires() - this.started) / 1000;
  }

  setAnimationDelay(data, event) {
    // every time the component gets rendered, the animation delay gets set
    // to accomodate for the passed lifetime of the timed message
    event.target.style.animationDelay = `${(this.started - Date.now()) / 1000}s`;
  }
};

ko.components.register('ephemeral-timer', {
  template: `
    <svg class="ephemeral-timer" viewBox="0 0 8 8" width="8" height="8">
      <circle class="ephemeral-timer__background" cx="4" cy="4" r="3.5"></circle>
      <circle class="ephemeral-timer__dial" cx="4" cy="4" r="2" transform="rotate(-90 4 4)" data-bind="style: {'animation-duration': duration + 's'}, event: {animationstart: setAnimationDelay}">
      </circle>
    </svg>
  `,
  viewModel: z.components.EphemeralTimer,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.FullSearch = class FullSearch {
  static get CONFIG() {
    return {
      MAX_OFFSET_INDEX: 30,
      MAX_TEXT_LENGTH: 60,
      MAX_VISIBLE_MESSAGES: 30,
      PRE_MARKED_OFFSET: 20,
    };
  }

  constructor(params) {
    this.searchProvider = params.search_provider;

    this.onInputChange = query => {
      if (typeof params.change === 'function') {
        params.change(query);
      }
    };

    this.clickOnMessage = messageEntity => {
      if (typeof params.click === 'function') {
        params.click(messageEntity);
      }
    };

    this.messageEntities = [];
    this.visibleMessageEntities = ko.observableArray();

    this.showNoResultsText = ko.observable(false);

    this.input = ko.observable();
    this.input.subscribe(
      _.debounce(searchQuery => {
        searchQuery = searchQuery.trim();

        this.onInputChange(searchQuery);

        const isQueryToShort = searchQuery.length < 2;
        if (isQueryToShort) {
          this.messageEntities = [];
          this.visibleMessageEntities([]);
          return this.showNoResultsText(false);
        }

        this.searchProvider(searchQuery).then(({messageEntities, query}) => {
          const isMatchingQuery = query === this.input().trim();
          if (isMatchingQuery) {
            this.showNoResultsText(messageEntities.length === 0);
            this.messageEntities = messageEntities;
            this.visibleMessageEntities(this.messageEntities.splice(0, FullSearch.CONFIG.MAX_VISIBLE_MESSAGES));
          }
        });
      }, 100)
    );

    // binding?
    $('.collection-list').on('scroll', event => {
      const showAdditionalMessages = $(event.currentTarget).isScrolledBottom() && this.messageEntities.length;
      if (showAdditionalMessages) {
        const additionalMessageEntities = this.messageEntities.splice(0, FullSearch.CONFIG.MAX_VISIBLE_MESSAGES);
        z.util.koArrayPushAll(this.visibleMessageEntities, additionalMessageEntities);
      }
    });
  }

  htmlFormatResult(messageEntity) {
    const text = z.util.SanitizationUtil.escapeString(messageEntity.get_first_asset().text);
    const input = z.util.SanitizationUtil.escapeString(this.input());

    messageEntity.matchesCount = 0;

    const replaceRegex = z.search.FullTextSearch.getSearchRegex(input);
    const replaceFunction = match => {
      messageEntity.matchesCount += 1;
      return `<mark class='full-search-marked' data-uie-name='full-search-item-mark'>${match}</mark>`;
    };

    let transformedText = text.replace(replaceRegex, replaceFunction);

    const markOffset = transformedText.indexOf('<mark') - 1;
    let sliceOffset = markOffset;

    for (const index of _.range(markOffset).reverse()) {
      if (index < markOffset - FullSearch.CONFIG.PRE_MARKED_OFFSET) {
        break;
      }

      const char = transformedText[index];
      const isWhitespace = char === ' ';
      if (isWhitespace) {
        sliceOffset = index + 1;
      }
    }

    const textTooLong = text.length > FullSearch.CONFIG.MAX_TEXT_LENGTH;
    const offsetTooBig = markOffset > FullSearch.CONFIG.MAX_OFFSET_INDEX;
    if (textTooLong && offsetTooBig) {
      transformedText = `…${transformedText.slice(sliceOffset)}`;
    }

    return transformedText;
  }

  clickOnDismiss() {
    this.input('');
  }

  dispose() {
    $('.collection-list').off('scroll');
  }
};

ko.components.register('full-search', {
  template: `
    <header class="full-search-header">
      <span class="full-search-header-icon icon-search"></span>
      <div class="full-search-header-input">
        <input type="text" data-bind="hasFocus: true, l10n_placeholder: z.string.fullsearchPlaceholder, textInput: input" data-uie-name="full-search-header-input"/>
        <span class="button-icon icon-dismiss" data-bind="click: clickOnDismiss, visible: input()" data-uie-name="full-search-dismiss"></span>
      </div>
    </header>
    <!-- ko if: showNoResultsText() -->
      <div class="full-search-no-result" data-bind="l10n_text: z.string.fullsearchNoResults" data-uie-name="full-search-no-results"></div>
    <!-- /ko -->
    <div class="full-search-list" data-bind="foreach: {data: visibleMessageEntities}" data-uie-name="full-search-list">
      <div class="full-search-item" data-bind="click: $parent.clickOnMessage" data-uie-name="full-search-item">
        <div class="full-search-item-avatar">
          <participant-avatar params="participant: user, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
        </div>
        <div class="full-search-item-content">
          <div class="full-search-item-content-text ellipsis" data-bind="html: $parent.htmlFormatResult($data)" data-uie-name="full-search-item-text"></div>
          <div class="full-search-item-content-info">
            <span class="font-weight-bold" data-bind="text: user().first_name()" data-uie-name="full-search-item-sender"></span>
            <span data-bind="text: moment($data.timestamp()).format('MMMM D, YYYY')" data-uie-name="full-search-item-timestamp"></span>
          </div>
        </div>
        <div class="badge" data-bind="text: matchesCount, visible: matchesCount > 1" data-uie-name="full-search-item-badge"></div>
      </div>
    </div>
  `,
  viewModel: z.components.FullSearch,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupListViewModel = class GroupListViewModel {
  /**
   * Construct a new group list view model.
   *
   * @param {Object} params - Component parameters
   * @param {ko.observableArray} params.groups - Data source
   * @param {Function} params.click - Function called when a list item is clicked
   */
  constructor(params) {
    this.groups = params.groups;
    this.on_select = params.click;
  }
};

// Knockout registration of the group list component.
ko.components.register('group-list', {
  template: `
    <div class="search-list search-list-lg" data-bind="foreach: {data: groups, as: 'group'}">
      <div class="search-list-item" data-bind="click: $parent.on_select, attr: {'data-uie-uid': group.id, 'data-uie-value': group.display_name" data-uie-name="item-group">
        <div class="search-list-item-image">
          <group-avatar params="users: group.participating_user_ets()"></group-avatar>
        </div>
        <div class="search-list-item-header" data-bind="text: group.display_name"></div>
      </div>
    </div>
  `,
  viewModel: z.components.GroupListViewModel,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupVideoGrid = class GroupVideoGrid {
  static get CONFIG() {
    return {
      CONTAIN_CLASS: 'group-video-grid__element-video--contain',
      RATIO_THRESHOLD: 0.4,
      VIDEO_ELEMENT_SIZE: {
        FULL_SCREEN: 'full_screen',
        HALF_SCREEN: 'half_screen',
        HIDDEN: 'hidden',
        QUARTER_SCREEN: 'quarter_screen',
      },
    };
  }

  constructor({minimized, videoGridRepository}, rootElement) {
    this.scaleVideos = this.scaleVideos.bind(this, rootElement);
    this.doubleClickedOnVideo = this.doubleClickedOnVideo.bind(this);

    this.grid = videoGridRepository.grid;
    this.thumbnailStream = videoGridRepository.thumbnailStream;
    this.streams = videoGridRepository.streams;

    this.getStreamInfo = id => this.streams().find(stream => stream.id === id);
    this.gridInfo = ko.pureComputed(() => this.grid().map(this.getStreamInfo));

    this.minimized = minimized;

    this.hasBlackBackground = ko.pureComputed(() => {
      const gridElementsCount = this.grid().filter(id => id !== 0).length;
      return this.minimized && gridElementsCount > 1;
    });

    // scale videos when the grid is updated (on the next rendering cycle)
    this.grid.subscribe(() => z.util.afterRender(this.scaleVideos));
  }

  scaleVideos(rootElement) {
    const elements = Array.from(rootElement.querySelectorAll('.group-video-grid__element'));
    const setScale = (videoElement, wrapper) => {
      const streamId = wrapper.dataset.streamId;
      const streamInfo = this.getStreamInfo(streamId);
      if (streamInfo) {
        const isScreenSend = streamInfo.screenSend();
        updateContainClass(videoElement, wrapper, isScreenSend, streamInfo);
        streamInfo.screenSend.subscribe(screenSend => {
          delete streamInfo.fitContain;
          updateContainClass(videoElement, wrapper, screenSend, streamInfo);
        });
      }
    };

    const updateContainClass = (videoElement, wrapper, isScreenSend, streamInfo) => {
      const hasFitSet = streamInfo.hasOwnProperty('fitContain');
      const wrapperRatio = wrapper.clientWidth / wrapper.clientHeight;
      const videoRatio = videoElement.videoWidth / videoElement.videoHeight;
      const isVeryDifferent = Math.abs(wrapperRatio - videoRatio) > GroupVideoGrid.CONFIG.RATIO_THRESHOLD;
      const shouldBeContain = isVeryDifferent || isScreenSend === z.calling.enum.PROPERTY_STATE.TRUE;
      const forceClass = hasFitSet ? streamInfo.fitContain : shouldBeContain;
      videoElement.classList.toggle(GroupVideoGrid.CONFIG.CONTAIN_CLASS, forceClass);
    };

    elements.forEach(element => {
      const videoElement = element.querySelector('video');
      if (videoElement.videoWidth > 0) {
        z.util.afterRender(() => setScale(videoElement, element));
      } else {
        videoElement.addEventListener('loadedmetadata', () => setScale(videoElement, element), {once: true});
      }
    });
  }

  doubleClickedOnVideo(viewModel, {currentTarget}) {
    const childVideo = currentTarget.querySelector('video');
    const streamId = currentTarget.dataset.streamId;
    const streamInfo = this.getStreamInfo(streamId);

    const hasFitProperty = streamInfo.hasOwnProperty('fitContain');
    const hasFitClass = childVideo.classList.contains(GroupVideoGrid.CONFIG.CONTAIN_CLASS);
    streamInfo.fitContain = hasFitProperty ? !streamInfo.fitContain : !hasFitClass;

    childVideo.classList.toggle(GroupVideoGrid.CONFIG.CONTAIN_CLASS, streamInfo.fitContain);
  }

  getSizeForVideo(index) {
    const grid = this.grid();
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    if (grid[index] === 0) {
      return SIZES.EMPTY;
    }

    const isAlone = grid.every((value, i) => i === index || value === 0);
    const hasVerticalNeighbor = index % 2 === 0 ? grid[index + 1] !== 0 : grid[index - 1] !== 0;

    if (isAlone) {
      return SIZES.FULL_SCREEN;
    } else if (!hasVerticalNeighbor) {
      return SIZES.HALF_SCREEN;
    }
    return SIZES.QUARTER_SCREEN;
  }

  getClassNameForVideo(index, isMirrored) {
    const size = this.getSizeForVideo(index);
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    const extraClasses = {
      [SIZES.EMPTY]: 'group-video-grid__element--empty',
      [SIZES.FULL_SCREEN]: 'group-video-grid__element--full-size',
      [SIZES.HALF_SCREEN]: 'group-video-grid__element--full-height',
      [SIZES.QUARTER_SCREEN]: '',
    };

    const roundedClass = this.streams().length === 1 && this.minimized ? ' group-video-grid__element--rounded' : '';
    const mirrorClass = isMirrored ? ' mirror' : '';
    return `group-video-grid__element${index} ${extraClasses[size]}${mirrorClass}${roundedClass}`;
  }

  getUIEValueForVideo(index) {
    const size = this.getSizeForVideo(index);
    const SIZES = GroupVideoGrid.CONFIG.VIDEO_ELEMENT_SIZE;
    const extraClasses = {
      [SIZES.EMPTY]: '',
      [SIZES.FULL_SCREEN]: 'full',
      [SIZES.HALF_SCREEN]: 'half',
      [SIZES.QUARTER_SCREEN]: 'quarter',
    };
    return extraClasses[size];
  }
};

ko.components.register('group-video-grid', {
  template: `
      <div class="group-video">
        <div class="group-video-grid" data-bind="foreach: {data: gridInfo, as: 'streamInfo', afterRender: scaleVideos}, css: {'group-video-grid--black-background': hasBlackBackground()}">
          <!-- ko if: streamInfo -->
            <div class="group-video-grid__element" data-bind="css: $parent.getClassNameForVideo($index(), streamInfo.isSelf && streamInfo.videoSend()), attr: {'data-uie-name': 'item-grid', 'data-uie-value': $parent.getUIEValueForVideo($index()), 'data-stream-id': streamInfo.id}, event: {dblclick: $parent.doubleClickedOnVideo}">
              <video class="group-video-grid__element-video" autoplay playsinline data-bind="sourceStream: streamInfo.stream, muteMediaElement: streamInfo.stream">
              </video>
              <!-- ko if: streamInfo.isSelf && !streamInfo.audioSend() && !$parent.minimized -->
                <div class="group-video-grid__mute-overlay" data-uie-name="status-call-audio-muted">
                  <micoff-icon></micoff-icon>
                </div>
              <!-- /ko -->
              <!-- ko if: streamInfo.videoSend() === z.calling.enum.PROPERTY_STATE.PAUSED -->
                <div class="group-video-grid__pause-overlay" data-bind="switchBackground: streamInfo.picture()">
                  <div class="background">
                    <div class="background-image"></div>
                    <div class="background-darken"></div>
                  </div>
                  <div class="group-video-grid__pause-overlay__label" data-bind="l10n_text: z.string.videoCallPaused, css: {'group-video-grid__pause-overlay__label--minimized': $parent.minimized}" data-uie-name="status-video-paused"></div>
                </div>
              <!-- /ko -->
            </div>
          <!-- /ko -->
        </div>
        <!-- ko if: thumbnailStream() && thumbnailStream().stream -->
          <div class="group-video__thumbnail" data-bind="css: {'group-video__thumbnail--minimized': minimized}">
            <video class="mirror group-video__thumbnail-video" autoplay playsinline data-uie-name="self-video-thumbnail" data-bind="css: {'group-video__thumbnail--minimized': minimized, 'mirror': thumbnailStream().videoSend()}, sourceStream: thumbnailStream().stream, muteMediaElement: thumbnailStream().stream">
            </video>
            <!-- ko if: !thumbnailStream().audioSend() && !minimized -->
              <div class="group-video-grid__mute-overlay" data-uie-name="status-call-audio-muted">
                <micoff-icon></micoff-icon>
              </div>
            <!-- /ko -->
          </div>
        <!-- /ko -->
      </div>
    `,
  viewModel: {
    createViewModel: (params, componentInfo) => new z.components.GroupVideoGrid(params, componentInfo.element),
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.Image = class Image {
  constructor(params, componentInfo) {
    this.asset = ko.unwrap(params.asset);
    this.assetSrc = ko.observable();
    this.assetIsLoading = ko.observable(false);
    this.element = componentInfo.element;

    this.onClick = () => {
      if (!this.assetIsLoading() && typeof params.click === 'function') {
        params.click(this.asset);
      }
    };

    const _onInViewport = () => {
      this.assetIsLoading(true);
      this.asset.load().then(blob => {
        if (blob) {
          this.assetSrc(window.URL.createObjectURL(blob));
        }
        this.assetIsLoading(false);
      });
    };

    z.ui.ViewportObserver.addElement(this.element, _onInViewport);
  }

  dispose() {
    z.ui.ViewportObserver.removeElement(this.element);
    if (this.assetSrc()) {
      window.URL.revokeObjectURL(this.assetSrc());
    }
  }
};

ko.components.register('image-component', {
  template: `
    <!-- ko if: assetSrc() -->
      <img data-bind="attr:{src: assetSrc}, click: onClick"/>
    <!-- /ko -->
    <!-- ko ifnot: assetSrc() -->
      <div data-bind="css: {'three-dots': assetIsLoading()}">
        <span></span><span></span><span></span>
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.Image(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.InputElement = class InputElement {
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.value = params.value;

    this.change = (data, event) => {
      const new_name = z.util.StringUtil.removeLineBreaks(event.target.value.trim());
      const old_name = this.value().trim();
      event.target.value = old_name;
      this.editing(false);

      if (new_name !== old_name && typeof params.change === 'function') {
        params.change(new_name);
      }
    };

    this.edit = () => this.editing(true);

    this.editing = ko.observable(false);
    this.editing_subscription = this.editing.subscribe(value => {
      if (value) {
        $(component_info.element)
          .find('textarea')
          .one('keydown', event => {
            if (event.keyCode === z.util.KEYCODE.ESC) {
              this.editing(false);
            }
          });
      } else {
        $(component_info.element)
          .find('textarea')
          .off('keydown', 'esc', this.abort);
      }
    });

    this.placeholder = params.placeholder;
  }

  dispose() {
    this.editing_subscription.dispose();
  }
};

// Knockout registration of the input element component.
ko.components.register('input-element', {
  template: `
    <span data-bind="visible: !editing(), text: value(), click: edit" data-uie-name="status-name"></span>
    <textarea data-bind="visible: editing, value: value(), enter: change, event: {blur: change}, hasFocus: editing, resize, l10n_placeholder: placeholder" maxlength="64" data-uie-name="enter-name"></textarea>
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.InputElement(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.InputLevel = class InputLevel {
  constructor(params) {
    this.input_level = params.level;
    this.disabled = params.disabled;

    this.level_in_view = ko.pureComputed(() => this.input_level()).extend({rateLimit: 100});

    this.bullet_count = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
  }

  is_bullet_active(index) {
    if (this.disabled()) {
      return 'input-level-bullet-disabled';
    }
    const threshold_passed = this.level_in_view() > (index + 1) / this.bullet_count.length;
    if (threshold_passed) {
      return 'input-level-bullet-active';
    }
  }
};

ko.components.register('input-level', {
  template: `\
    <ul class="input-level" data-bind="foreach: bullet_count">
     <li class="input-level-bullet" data-bind="css: $parent.is_bullet_active($data)"></li>
    </ul>\
  `,
  viewModel: z.components.InputLevel,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

(() => {
  class Message {
    constructor({
      message,
      conversation,
      selfId,
      isSelfTemporaryGuest,
      isLastDeliveredMessage,
      shouldShowAvatar,
      shouldShowInvitePeople,
      onClickAvatar,
      onClickImage,
      onClickInvitePeople,
      onClickMessage,
      onClickTimestamp,
      onClickParticipants,
      onClickResetSession,
      onClickCancelRequest,
      onLike,
      conversationRepository,
      locationRepository,
      actionsViewModel,
    }) {
      this.message = message;
      this.conversation = conversation;

      this.shouldShowAvatar = shouldShowAvatar;
      this.shouldShowInvitePeople = shouldShowInvitePeople;
      this.selfId = selfId;
      this.isSelfTemporaryGuest = isSelfTemporaryGuest;
      this.isLastDeliveredMessage = isLastDeliveredMessage;

      this.onClickImage = onClickImage;
      this.onClickInvitePeople = onClickInvitePeople;
      this.onClickAvatar = onClickAvatar;
      this.onClickMessage = onClickMessage;
      this.onClickTimestamp = onClickTimestamp;
      this.onClickParticipants = onClickParticipants;
      this.onClickResetSession = onClickResetSession;
      this.onClickCancelRequest = onClickCancelRequest;
      this.onLike = onLike;

      this.conversationRepository = conversationRepository;
      this.locationRepository = locationRepository;

      this.actionsViewModel = actionsViewModel;

      this.showLikes = ko.observable(false);

      this.bindShowMore = this.bindShowMore.bind(this);
    }

    getSystemMessageIconComponent(message) {
      const iconComponents = {
        [z.message.SystemMessageType.CONVERSATION_RENAME]: 'edit-icon',
        [z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE]: 'timer-icon',
      };
      return iconComponents[message.system_message_type];
    }

    showDevice(messageEntity) {
      const topic = messageEntity.isSelfClient()
        ? z.event.WebApp.PREFERENCES.MANAGE_DEVICES
        : z.event.WebApp.SHORTCUT.PEOPLE;
      amplify.publish(topic);
    }

    showContextMenu(messageEntity, event) {
      const entries = [];

      if (messageEntity.is_downloadable()) {
        entries.push({
          click: () => messageEntity.download(),
          label: z.l10n.text(z.string.conversationContextMenuDownload),
        });
      }

      if (messageEntity.isReactable() && !this.conversation().removed_from_conversation()) {
        const stringId = messageEntity.is_liked()
          ? z.string.conversationContextMenuUnlike
          : z.string.conversationContextMenuLike;

        entries.push({
          click: () => this.onLike(messageEntity, false),
          label: z.l10n.text(stringId),
        });
      }

      if (messageEntity.is_editable() && !this.conversation().removed_from_conversation()) {
        entries.push({
          click: () => amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.EDIT, messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuEdit),
        });
      }

      if (messageEntity.isReplyable() && !this.conversation().removed_from_conversation()) {
        entries.push({
          click: () => amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.REPLY, messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuReply),
        });
      }

      if (messageEntity.isCopyable()) {
        entries.push({
          click: () => messageEntity.copy(),
          label: z.l10n.text(z.string.conversationContextMenuCopy),
        });
      }

      if (messageEntity.is_deletable()) {
        entries.push({
          click: () => this.actionsViewModel.deleteMessage(this.conversation(), messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuDelete),
        });
      }

      const isSendingMessage = messageEntity.status() === z.message.StatusType.SENDING;
      const canDelete =
        messageEntity.user().is_me && !this.conversation().removed_from_conversation() && !isSendingMessage;
      if (canDelete) {
        entries.push({
          click: () => this.actionsViewModel.deleteMessageEveryone(this.conversation(), messageEntity),
          label: z.l10n.text(z.string.conversationContextMenuDeleteEveryone),
        });
      }

      z.ui.Context.from(event, entries, 'message-options-menu');
    }

    bindShowMore(elements, scope) {
      const label = elements.find(element => element.className === 'message-header-label');
      if (!label) {
        return;
      }
      const link = label.querySelector('.message-header-show-more');
      if (link) {
        link.addEventListener('click', () => this.onClickParticipants(scope.message.highlightedUsers()));
      }
    }
  }

  const normalTemplate = `
  <!-- ko if: shouldShowAvatar -->
    <div class="message-header">
      <div class="message-header-icon">
        <participant-avatar class="sender-avatar" params="participant: message.user, click: onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
      </div>
      <div class="message-header-label">
        <span class="message-header-label-sender" data-bind='css: message.accent_color(), text: message.headerSenderName()' data-uie-name="sender-name"></span>
        <!-- ko if: message.user().isService -->
          <service-icon class="message-header-icon-service"></service-icon>
        <!-- /ko -->
        <!-- ko if: message.was_edited() -->
          <span class="message-header-label-icon icon-edit" data-bind="attr: {title: message.display_edited_timestamp()}"></span>
        <!-- /ko -->
      </div>
    </div>
  <!-- /ko -->
  <!-- ko if: message.quote() -->
    <message-quote params="
        conversation: conversation,
        quote: message.quote(),
        selfId: selfId,
        conversationRepository: conversationRepository,
        locationRepository: locationRepository,
        showDetail: onClickImage,
        focusMessage: onClickTimestamp,
        handleClickOnMessage: onClickMessage,
        showUserDetails: onClickAvatar,
      "></message-quote>
  <!-- /ko -->

  <div class="message-body" data-bind="attr: {'title': message.ephemeral_caption()}">
    <!-- ko if: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
      <ephemeral-timer class="message-ephemeral-timer" params="message: message"></ephemeral-timer>
    <!-- /ko -->

    <!-- ko foreach: {data: message.assets, as: 'asset'} -->
      <!-- ko if: asset.is_image() -->
        <div class="message-asset-image">
          <div class="image image-loading" data-bind="
            attr: {'data-uie-visible': message.visible() && !message.isObfuscated()},
            background_image: asset.resource,
            click: (data, event) => $parent.onClickImage(message, event),
            css: {'bg-color-ephemeral': message.isObfuscated()},
            " data-uie-name="go-image-detail">
            <!-- ko if: message.isObfuscated() -->
              <div class="icon-library flex-center full-screen text-white"></div>
            <!-- /ko -->
            <img class="image-element" data-bind="attr: {src: asset.dummy_url}, css: {'image-ephemeral': message.isObfuscated()}"/>
            <!-- ko ifnot: message.isObfuscated() -->
              <span class="image-placeholder-icon">
                <div class="three-dots">
                  <span></span>
                  <span></span>
                  <span></span>
                </div>
              </span>
            <!-- /ko -->
          </div>
        </div>
      <!-- /ko -->
      <!-- ko if: asset.is_text() -->
        <!-- ko if: asset.should_render_text -->
          <div class="text" data-bind="html: asset.render($parent.selfId()), event: {click: $parent.onClickMessage}, css: {'text-large': z.util.EmojiUtil.includesOnlyEmojies(asset.text), 'text-graphite': message.status() === z.message.StatusType.SENDING, 'ephemeral-message-obfuscated': message.isObfuscated()}" dir="auto"></div>
        <!-- /ko -->
        <!-- ko foreach: asset.previews() -->
          <link-preview-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired': message.isObfuscated()}" params="message: message"></link-preview-asset>
        <!-- /ko -->
      <!-- /ko -->
      <!-- ko if: asset.is_video() -->
        <video-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-movie': message.isObfuscated()}" params="message: message"></video-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_audio() -->
        <audio-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-microphone': message.isObfuscated()}" params="message: message"></audio-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_file() -->
        <file-asset class="message-asset" data-bind="css: {'ephemeral-asset-expired icon-file': message.isObfuscated()}" params="message: message"></file-asset>
      <!-- /ko -->
      <!-- ko if: asset.is_location() -->
        <location-asset params="asset: asset, locationRepository: $parent.locationRepository"></location-asset>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: !message.other_likes().length && message.isReactable() -->
      <div class="message-body-like">
        <span class="message-body-like-icon like-button message-show-on-hover" data-bind="attr: {'data-ui-value': message.is_liked()}, css: {'like-button-liked': message.is_liked()}, style: {opacity: message.is_liked() ? 1 : ''}, click: () => onLike(message)">
          <span class="icon-like-small"></span>
          <span class="icon-liked-small"></span>
        </span>
      </div>
    <!-- /ko -->

    <div class="message-body-actions">
      <span class="context-menu icon-more font-size-xs" data-bind="click: (data, event) => showContextMenu(message, event)"></span>
      <!-- ko if: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
        <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp, 'data-uie-uid': message.id, 'title': message.ephemeral_caption()}"></time>
      <!-- /ko -->
      <!-- ko ifnot: message.ephemeral_status() === z.message.EphemeralStatusType.ACTIVE -->
        <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp, 'data-uie-uid': message.id}"></time>
      <!-- /ko -->
      <!-- ko if: isLastDeliveredMessage -->
        <span class="message-status" data-bind="l10n_text: z.string.conversationMessageDelivered"></span>
      <!-- /ko -->
    </div>

  </div>
  <!-- ko if: message.other_likes().length -->
    <div class="message-footer">
      <div class="message-footer-icon">
        <span class="like-button" data-bind="attr: {'data-ui-value': message.is_liked()}, css: {'like-button-liked': message.is_liked()}, style: {opacity: message.is_liked() ? 1 : ''}, click: () => onLike(message)">
          <span class="icon-like-small"></span>
          <span class="icon-liked-small"></span>
        </span>
      </div>
      <div class="message-footer-label cursor-pointer" data-bind="click: () => showLikes(true)">
        <span class="font-size-xs text-graphite" data-bind="text: message.like_caption(), attr: {'data-uie-value': message.reactions_user_ids()}"  data-uie-name="message-liked-names"></span>
        <!-- ko if: !showLikes() && message.other_likes().length > 5 -->
          <span class="icon-more font-size-xs"></span>
        <!-- /ko -->
      </div>
      <!-- ko if: showLikes() -->
        <div class="message-footer-bottom" data-uie-name="message-liked-avatars">
          <!-- ko foreach: message.reactions_user_ets() -->
            <participant-avatar params="participant: $data, click: $parent.onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
          <!-- /ko -->
          <span class="message-footer-close-button icon-close" data-bind="click: () => showLikes(false)"></span>
        </div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  `;

  const missedTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <span class="icon-sysmsg-error text-red"></span>
    </div>
    <div class="message-header-label" data-bind="l10n_text: z.string.conversationMissedMessages"></div>
  </div>
  `;

  const unableToDecryptTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <span class="icon-sysmsg-error text-red"></span>
    </div>
    <div class="message-header-label ellipsis">
      <span data-bind="html: message.htmlCaption()"></span>
      <span>&nbsp;</span>
      <a class="text-theme" data-bind="l10n_text: z.string.conversationUnableToDecryptLink, attr: {'href': message.link}" rel="nofollow noopener noreferrer" target="_blank"></a>
      <hr class="message-header-line" />
    </div>
  </div>
  <div class="message-body message-body-decrypt-error">
    <div class="message-header-decrypt-error-label" data-bind="html: message.htmlErrorMessage()"></div>
    <!-- ko if: message.is_recoverable -->
      <div class="message-header-decrypt-reset-session">
        <svg class="message-header-decrypt-reset-session-spinner svg-theme spin"
             data-bind="style : {visibility : message.is_resetting_session() ? 'visible' : 'hidden'}"
             width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" data-uie-name="status-loading">
          <path class="fill-theme" d="M12.416 12.417c-2.374 2.375-6.28 2.33-8.72-.112-2.444-2.442-2.488-6.347-.113-8.72 1.658-1.66 4.12-2.18 6.343-1.394.477.17 1-.08 1.17-.557.167-.477-.083-1-.56-1.17C7.658-.552 4.453.124 2.286 2.29-.808 5.384-.75 10.448 2.4 13.6c3.15 3.152 8.216 3.21 11.312.113 2.165-2.166 2.84-5.37 1.824-8.25-.168-.476-.692-.726-1.17-.558-.476.17-.726.692-.557 1.17.784 2.222.265 4.684-1.394 6.342z"></path>
        </svg>
        <span class="message-header-decrypt-reset-session-action button-label text-theme"
              data-bind="click: () => onClickResetSession(message), l10n_text: z.string.conversationUnableToDecryptResetSession, style : {visibility : !message.is_resetting_session() ? 'visible' : 'hidden'}"></span>
      </div>
      <!-- /ko -->
    </div>
  </div>
  `;

  const systemTemplate = `
  <div class="message-header">
    <div class="message-header-icon message-header-icon--svg text-graphite">
      <span data-bind="component: getSystemMessageIconComponent(message)"></span>
    </div>
    <div class="message-header-label">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption()"></span>
      <hr class="message-header-line" />
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  <div class="message-body font-weight-bold" data-bind="text: message.name"></div>
  `;

  const pingTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <div class="icon-ping" data-bind="css: message.get_icon_classes"></div>
    </div>
    <div class="message-header-label" data-bind="attr: {title: message.ephemeral_caption()}, css: {'ephemeral-message-obfuscated': message.isObfuscated()}">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption"></span>
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  `;

  const deleteTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <participant-avatar class="sender-avatar" params="participant: message.user, click: onClickAvatar, size: z.components.ParticipantAvatar.SIZE.X_SMALL"></participant-avatar>
    </div>
    <div class="message-header-label">
      <span class="message-header-label-sender" data-bind='text: message.unsafeSenderName()'></span>
      <span class="message-header-label-icon icon-trash" data-bind="attr: {title: message.display_deleted_timestamp()}"></span>
    </div>
    <div class="message-body-actions message-body-actions-large">
      <time class="time" data-bind="text: message.display_deleted_timestamp(), attr: {'data-timestamp': message.deleted_timestamp, 'data-uie-uid': message.id}" data-uie-name="item-message-delete-timestamp"></time>
    </div>
  </div>
  `;

  const verificationTemplate = `
  <div class="message-header">
    <div class="message-header-icon">
      <!-- ko if: message.isTypeVerified() -->
        <verified-icon></verified-icon>
      <!-- /ko -->
      <!-- ko ifnot: message.isTypeVerified() -->
        <svg width="16" height="16">
          <use xlink:href="#icon-not-verified"></use>
        </svg>
      <!-- /ko -->
    </div>
    <div class="message-header-label">
      <!-- ko if: message.isTypeVerified() -->
        <span data-bind="l10n_text: z.string.tooltipConversationAllVerified"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeUnverified() -->
        <span class="message-header-sender-name" data-bind="text: message.unsafeSenderName()"></span>
        <span class="ellipsis" data-bind="l10n_text: z.string.conversationDeviceUnverified"></span>
        <span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), text: message.captionUnverifiedDevice" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeNewDevice() -->
        <span class="message-header-plain-sender-name" data-bind='text: message.captionUser'></span>
        <span class="ellipsis" data-bind="text: message.captionStartedUsing"></span>
        <span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), text: message.captionNewDevice" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <!-- ko if: message.isTypeNewMember() -->
        <span class="ellipsis" data-bind="l10n_text: z.string.conversationDeviceNewPeopleJoined"></span>&nbsp;<span class="message-verification-action text-theme" data-bind="click: () => showDevice(message), l10n_text: z.string.conversationDeviceNewPeopleJoinedVerify" data-uie-name="go-devices"></span>
      <!-- /ko -->
      <hr class="message-header-line" />
    </div>
  </div>
  `;

  const callTemplate = `
  <div class="message-header">
    <div class="message-header-icon message-header-icon--svg">
      <!-- ko if: message.was_completed() -->
        <div class="svg-green"><pickup-icon></pickup-icon></div>
      <!-- /ko -->
      <!-- ko if: message.was_missed() -->
        <div class="svg-red"><hangup-icon></hangup-icon></div>
      <!-- /ko -->
    </div>
    <div class="message-header-label">
      <span class="message-header-sender-name" data-bind='text: message.unsafeSenderName()'></span>
      <span class="ellipsis" data-bind="text: message.caption()"></span>
    </div>
    <div class="message-body-actions">
      <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
    </div>
  </div>
  `;

  const memberTemplate = `
  <!-- ko if: message.showLargeAvatar() -->
    <div class="message-connected">
      <span class="message-connected-header" data-bind='text: message.otherUser().name()'></span>
      <!-- ko if: message.otherUser().isService -->
        <span class="message-connected-provider-name" data-bind='text: message.otherUser().providerName()'></span>
      <!-- /ko -->
      <!-- ko ifnot: message.otherUser().isService -->
        <span class="message-connected-username label-username" data-bind='text: message.otherUser().username()'></span>
      <!-- /ko -->
      <participant-avatar class="message-connected-avatar avatar-no-badge cursor-default"
                   data-bind="css: {'avatar-no-badge': message.otherUser().isOutgoingRequest()}"
                   params="participant: message.otherUser, size: z.components.ParticipantAvatar.SIZE.X_LARGE"></participant-avatar>
      <!-- ko if: message.otherUser().isOutgoingRequest() -->
        <div class="message-connected-cancel text-theme"
             data-bind="click: () => onClickCancelRequest(message),
                        l10n_text: z.string.conversationConnectionCancelRequest"
             data-uie-name="do-cancel-request"></div>
      <!-- /ko -->
      <!-- ko if: message.showServicesWarning -->
        <div class="message-services-warning" data-bind="l10n_text: z.string.conversationServicesWarning" data-uie-name="label-services-warning"></div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  <!-- ko ifnot: message.showLargeAvatar() -->
    <!-- ko if: message.showNamedCreation() -->
      <div class="message-group-creation-header">
        <div class="message-group-creation-header-text" data-bind="html: message.htmlGroupCreationHeader()"></div>
        <div class="message-group-creation-header-name" data-bind="text: message.name()"></div>
      </div>
    <!-- /ko -->

    <!-- ko if: message.hasUsers() -->
      <div class="message-header" data-bind="template: {afterRender: bindShowMore}">
        <div class="message-header-icon message-header-icon--svg text-graphite">
          <message-icon data-bind="visible: message.isGroupCreation()"></message-icon>
          <span class="icon-minus" data-bind="visible: message.isMemberRemoval()"></span>
          <span class="icon-plus" data-bind="visible: message.isMemberJoin()"></span>
        </div>
        <div class="message-header-label">
          <span class="message-header-caption" data-bind="html: message.htmlCaption()"></span>
          <hr class="message-header-line" />
        </div>
        <!-- ko if: message.isMemberChange() -->
          <div class="message-body-actions">
            <time class="time" data-bind="text: message.display_timestamp_short(), attr: {'data-timestamp': message.timestamp}"></time>
          </div>
        <!-- /ko -->
      </div>
      <!-- ko if: message.showServicesWarning -->
        <div class="message-services-warning" data-bind="l10n_text: z.string.conversationServicesWarning" data-uie-name="label-services-warning"></div>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: message.isGroupCreation() -->
      <!-- ko if: shouldShowInvitePeople -->
        <div class="message-member-footer">
          <div data-bind="l10n_text: z.string.guestRoomConversationHead"></div>
          <div class="message-member-footer-button" data-bind="click: onClickInvitePeople, l10n_text: z.string.guestRoomConversationButton" data-uie-name="do-invite-people"></div>
        </div>
      <!-- /ko -->
      <!-- ko if: isSelfTemporaryGuest -->
        <div class="message-member-footer">
          <div class="message-member-footer-message" data-bind="l10n_text: z.string.temporaryGuestJoinMessage"></div>
          <div class="message-member-footer-description" data-bind="l10n_text: z.string.temporaryGuestJoinDescription"></div>
        </div>
      <!-- /ko -->
    <!-- /ko -->

    <!-- ko if: message.isMemberLeave() && message.user().is_me && isSelfTemporaryGuest -->
      <div class="message-member-footer">
        <div class="message-member-footer-description" data-bind="l10n_text: z.string.temporaryGuestLeaveDescription"></div>
      </div>
    <!-- /ko -->
  <!-- /ko -->  `;

  ko.components.register('message', {
    template: `
    <!-- ko if: message.super_type === 'normal' -->
      ${normalTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'missed' -->
      ${missedTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'unable-to-decrypt' -->
      ${unableToDecryptTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'verification' -->
      ${verificationTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'delete' -->
      ${deleteTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'call' -->
      ${callTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'system' -->
      ${systemTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'member' -->
      ${memberTemplate}
    <!-- /ko -->
    <!-- ko if: message.super_type === 'ping' -->
      ${pingTemplate}
    <!-- /ko -->
    `,
    viewModel: Message,
  });
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MessageQuote = class MessageQuote {
  constructor({
    conversation,
    conversationRepository,
    focusMessage,
    handleClickOnMessage,
    locationRepository,
    quote,
    selfId,
    showDetail,
    showUserDetails,
  }) {
    this.updateCanShowMore = this.updateCanShowMore.bind(this);
    this.toggleShowMore = this.toggleShowMore.bind(this);

    this.showDetail = showDetail;
    this.handleClickOnMessage = handleClickOnMessage;
    this.showUserDetails = showUserDetails;

    this.focusMessage = () => {
      if (this.quotedMessage()) {
        focusMessage(this.quotedMessage().id);
      }
    };

    this.locationRepository = locationRepository;
    this.selfId = selfId;

    this.canShowMore = ko.observable(false);
    this.showFullText = ko.observable(false);

    this.quotedMessage = ko.observable();
    this.quotedMessageId = ko.observable();
    this.error = ko.observable(quote().error);

    this.quotedMessage.subscribe(() => this.showFullText(false));

    this.quotedMessageIsBeforeToday = ko.pureComputed(() => {
      if (!this.quotedMessage()) {
        return false;
      }
      const quoteDate = moment(this.quotedMessage().timestamp());
      const today = moment().startOf('day');
      return quoteDate.isBefore(today);
    });

    if (!this.error() && quote().messageId) {
      conversationRepository
        .get_message_in_conversation_by_id(conversation(), quote().messageId, true, true)
        .then(message => {
          this.quotedMessage(message);
          this.quotedMessageId(message.id);
        })
        .catch(() => this.error(z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND));
    }

    const handleQuoteDeleted = messageId => {
      if (this.quotedMessageId() === messageId) {
        this.error(z.message.QuoteEntity.ERROR.MESSAGE_NOT_FOUND);
        this.quotedMessage(undefined);
      }
    };

    const handleQuoteUpdated = (originalMessageId, messageEntity) => {
      if (this.quotedMessageId() === originalMessageId) {
        this.quotedMessage(messageEntity);
        this.quotedMessageId(messageEntity.id);
      }
    };

    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleQuoteDeleted);
    amplify.subscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleQuoteUpdated);

    this.removedFromView = () => {
      amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.REMOVED, handleQuoteDeleted);
      amplify.unsubscribe(z.event.WebApp.CONVERSATION.MESSAGE.UPDATED, handleQuoteUpdated);
    };
  }

  updateCanShowMore(elements) {
    const textQuote = elements.find(element => element.classList && element.classList.contains('message-quote__text'));
    if (textQuote) {
      const preNode = textQuote.querySelector('pre');
      const width = Math.max(textQuote.scrollWidth, preNode ? preNode.scrollWidth : 0);
      const height = Math.max(textQuote.scrollHeight, preNode ? preNode.scrollHeight : 0);
      const isWider = width > textQuote.clientWidth;
      const isHigher = height > textQuote.clientHeight;
      this.canShowMore(isWider || isHigher);
    }
  }

  toggleShowMore() {
    this.showFullText(!this.showFullText());
  }
};

ko.components.register('message-quote', {
  template: `
  <!-- ko if: quotedMessage() || error() -->
    <div class="message-quote" data-uie-name="quote-item">
      <!-- ko if: error() -->
        <div class="message-quote__error" data-bind="l10n_text: z.string.replyQuoteError" data-uie-name="label-error-quote"></div>
      <!-- /ko -->
      <!-- ko ifnot: error() -->
        <div class="message-quote__sender">
          <span data-bind="text: quotedMessage().headerSenderName(), click: () => showUserDetails(quotedMessage().user)" data-uie-name="label-name-quote"></span>
          <!-- ko if: quotedMessage().was_edited() -->
            <edit-icon data-uie-name="message-edited-quote"></edit-icon>
          <!-- /ko -->
        </div>
        <!-- ko foreach: {data: quotedMessage().assets, as: 'asset', afterRender: updateCanShowMore} -->
          <!-- ko if: asset.is_image() -->
              <div class="message-quote__image" data-bind="background_image: asset.resource, click: (data, event) => $parent.showDetail($parent.quotedMessage(), event)" data-uie-name="media-picture-quote">
                <img data-bind="attr: {src: asset.dummy_url}"/>
              </div>
          <!-- /ko -->

          <!-- ko if: asset.is_text() -->
            <div class="message-quote__text" data-bind="html: asset.render($parent.selfId()), 
                                                        event: {click: $parent.handleClickOnMessage}, 
                                                        css: {'message-quote__text--full': $parent.showFullText(), 
                                                              'message-quote__text--large': z.util.EmojiUtil.includesOnlyEmojies(asset.text)}" 
              dir="auto" data-uie-name="media-text-quote"></div>
            <!-- ko if: $parent.canShowMore -->
              <div class="message-quote__text__show-more" data-bind="click: $parent.toggleShowMore" data-uie-name="do-show-more-quote">
                <span data-bind="l10n_text: $parent.showFullText() ? z.string.replyQuoteShowLess : z.string.replyQuoteShowMore"></span>
                <disclose-icon data-bind="css: {'upside-down': $parent.showFullText()}"></disclose-icon>
              </div>
            <!-- /ko -->
          <!-- /ko -->

          <!-- ko if: asset.is_video() -->
            <video-asset class="message-quote__video" params="message: $parent.quotedMessage, isQuote: true" data-uie-name="media-video-quote"></video-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_audio() -->
            <audio-asset class="message-quote__audio" params="message: $parent.quotedMessage" data-uie-name="media-audio-quote"></audio-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_file() -->
            <file-asset class="message-quote__file" params="message: $parent.quotedMessage" data-uie-name="media-file-quote"></file-asset>
          <!-- /ko -->

          <!-- ko if: asset.is_location() -->
            <location-asset params="asset: asset, locationRepository: $parent.locationRepository" data-uie-name="media-location-quote"></location-asset>
          <!-- /ko -->
        <!-- /ko -->
        <div class="message-quote__timestamp" 
          data-bind="l10n_text: {
              id: quotedMessageIsBeforeToday() ? z.string.replyQuoteTimeStampDate : z.string.replyQuoteTimeStampTime, 
              substitute: moment(quotedMessage().timestamp()).format(quotedMessageIsBeforeToday() ? 'DD.MM.YYYY' : 'HH:mm')
            },
            click: focusMessage" 
          data-uie-name="label-timestamp-quote">
        </div>
      <!-- /ko -->
    </div>
  <!-- /ko -->
  `,
  viewModel: z.components.MessageQuote,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MessageTimerButton = class MessageTimerButton {
  constructor(params) {
    this.conversationEntity = params.conversation;
    this.hasMessageTimer = ko.pureComputed(() => {
      return this.conversationEntity() ? this.conversationEntity().messageTimer() : false;
    });
    this.isTimerDisabled = ko.pureComputed(() => this.conversationEntity().hasGlobalMessageTimer());
    this.duration = ko.pureComputed(() => {
      return this.hasMessageTimer() ? z.util.TimeUtil.formatDuration(this.conversationEntity().messageTimer()) : {};
    });
  }

  /**
   * Click on ephemeral button
   * @param {Object} data - Object
   * @param {DOMEvent} event - Triggered event
   * @returns {undefined} No return value
   */
  onClick(data, event) {
    if (this.isTimerDisabled()) {
      return event.preventDefault();
    }

    const entries = [
      {
        click: () => this.conversationEntity().localMessageTimer(0),
        label: z.l10n.text(z.string.ephemeralUnitsNone),
      },
    ].concat(
      z.ephemeral.timings.VALUES.map(milliseconds => {
        const {text} = z.util.TimeUtil.formatDuration(milliseconds);

        return {
          click: () => this.conversationEntity().localMessageTimer(milliseconds),
          label: text,
        };
      })
    );

    z.ui.Context.from(event, entries, 'message-timer-menu');
  }
};

ko.components.register('message-timer-button', {
  template: `
    <span id="conversation-input-bar-message-timer"
      class="controls-right-button conversation-input-bar-message-timer"
      data-bind="click: onClick, l10n_tooltip: z.string.tooltipConversationEphemeral, attr: {'data-uie-value': isTimerDisabled() ? 'disabled' : 'enabled'}"
      data-uie-name="do-set-ephemeral-timer"
      data-uie-value>
      <!-- ko if: hasMessageTimer() && conversationEntity()-->
        <div class="message-timer-button" data-bind="css: isTimerDisabled() ? 'message-timer-button--disabled' : 'message-timer-button--enabled'">
          <span class="message-timer-button-unit" data-bind="text: duration().symbol"></span>
          <span class="full-screen" data-bind="text: duration().value"></span>
        </div>
      <!-- /ko -->

      <!-- ko ifnot: hasMessageTimer() -->
        <timer-icon class="button-icon-large"></timer-icon>
      <!-- /ko -->
    </span>
    `,
  viewModel: z.components.MessageTimerButton,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MentionSuggestions = class MentionSuggestions {
  constructor(params) {
    this.onInput = this.onInput.bind(this);
    this.onSuggestionClick = this.onSuggestionClick.bind(this);
    this.onInitSimpleBar = this.onInitSimpleBar.bind(this);

    this.isVisible = ko.observable(false);
    this.onSelectionValidated = params.onSelectionValidated || z.util.noop;
    this.onEnd = params.onEnd || z.util.noop;
    this.suggestions = params.suggestions;
    this.targetInputSelector = params.targetInputSelector;
    this.targetInput = undefined;

    this.position = ko.observable({});

    this.selectedSuggestionIndex = ko.observable(0);
    this.selectedSuggestionIndex.subscribe(this.updateScrollPosition);
    this.selectedSuggestion = ko.pureComputed(() => this.suggestions()[this.selectedSuggestionIndex()]);

    this.suggestionSubscription = this.suggestions.subscribe(suggestions => {
      const shouldBeVisible = suggestions.length > 0;
      if (shouldBeVisible && !this.isVisible()) {
        this.initList();
        this.updatePosition();
      } else if (!shouldBeVisible && this.isVisible()) {
        this.teardownList();
      } else if (this.isVisible()) {
        this.updateSelectedIndexBoundaries(suggestions);
        this.updatePosition();
      }
      this.isVisible(shouldBeVisible);
      this.updateScrollPosition(this.selectedSuggestionIndex());
    });

    this.shouldUpdateScrollbar = ko.pureComputed(this.suggestions).extend({notify: 'always', rateLimit: 100});
  }

  setWrapperSize(size = '') {
    const wrapper = document.querySelector('.conversation-input-bar-mention-suggestion');
    if (wrapper) {
      wrapper.style.width = size;
    }
  }

  onInitSimpleBar(simpleBar) {
    this.scrollElement = simpleBar.getScrollElement();
  }

  onInput(keyboardEvent) {
    const actions = {
      [z.util.KeyboardUtil.KEY.ARROW_UP]: this.moveSelection.bind(this, 1),
      [z.util.KeyboardUtil.KEY.ARROW_DOWN]: this.moveSelection.bind(this, -1),
      [z.util.KeyboardUtil.KEY.ENTER]: this.validateSelection.bind(this, keyboardEvent),
      [z.util.KeyboardUtil.KEY.TAB]: this.validateSelection.bind(this, keyboardEvent),
    };

    const action = actions[keyboardEvent.key];
    if (action) {
      const wasHandled = action();
      if (wasHandled) {
        keyboardEvent.preventDefault();
        keyboardEvent.stopPropagation();
      }
    }
  }

  moveSelection(delta) {
    const currentIndex = this.selectedSuggestionIndex();
    const newIndex = z.util.NumberUtil.clamp(currentIndex + delta, 0, this.suggestions().length - 1);
    this.selectedSuggestionIndex(newIndex);
    return true;
  }

  onSuggestionClick(data, event) {
    event.preventDefault();
    $(this.targetInput).focus();
    this.onSelectionValidated(data, this.targetInput);
  }

  validateSelection(keyboardEvent) {
    const isShiftEnter = z.util.KeyboardUtil.isEnterKey(keyboardEvent) && keyboardEvent.shiftKey;
    if (isShiftEnter) {
      return false;
    }

    this.onSelectionValidated(this.selectedSuggestion(), this.targetInput);
    return true;
  }

  updateScrollPosition(selectedNumber) {
    if (!this.scrollElement) {
      return;
    }
    const listItems = this.scrollElement.querySelectorAll('.mention-suggestion-list__item');
    const selectedItem = listItems[listItems.length - 1 - selectedNumber];
    if (!selectedItem) {
      return;
    }
    const scrollRect = this.scrollElement.getBoundingClientRect();
    const itemRect = selectedItem.getBoundingClientRect();
    const topDiff = scrollRect.top - itemRect.top;
    if (topDiff > 0) {
      return (this.scrollElement.scrollTop -= topDiff + 4);
    }
    const bottomDiff = itemRect.bottom - scrollRect.bottom + 20;
    if (bottomDiff > 0) {
      return (this.scrollElement.scrollTop += bottomDiff + 4);
    }
  }

  initList() {
    this.targetInput = this.initTargetInput();
    this.selectedSuggestionIndex(0);
  }

  updatePosition() {
    const inputBoundingRect = this.targetInput.getBoundingClientRect();
    const bottom = window.innerHeight - inputBoundingRect.top + 24;

    this.position({bottom: `${bottom}px`});
  }

  updateSelectedIndexBoundaries(suggestions) {
    const currentIndex = this.selectedSuggestionIndex();
    this.selectedSuggestionIndex(z.util.NumberUtil.clamp(currentIndex, 0, suggestions.length - 1));
  }

  teardownList() {
    this.targetInput.removeEventListener('keydown', this.onInput, true);
  }

  initTargetInput() {
    const input = this.targetInput || document.querySelector(this.targetInputSelector);
    input.addEventListener('keydown', this.onInput, true);
    this.targetInput = input;
    return input;
  }

  dispose() {
    this.suggestionSubscription.dispose();
  }
};

ko.components.register('mention-suggestions', {
  template: `
  <!-- ko if: isVisible() -->
    <div class="conversation-input-bar-mention-suggestion" data-uie-name="list-mention-suggestions" data-bind="style: position(), simplebar: {trigger: shouldUpdateScrollbar, onInit: onInitSimpleBar}">
      <div class="mention-suggestion-list" data-bind="foreach: {data: suggestions().slice().reverse(), as: 'suggestion'}">
        <div class="mention-suggestion-list__item" data-bind="click: $parent.onSuggestionClick, css: {'mention-suggestion-list__item--highlighted': suggestion === $parent.selectedSuggestion()}, attr: {'data-uie-value': suggestion.id, 'data-uie-selected': suggestion === $parent.selectedSuggestion()}" data-uie-name="item-mention-suggestion">
          <participant-avatar params="participant: suggestion, size: z.components.ParticipantAvatar.SIZE.XXX_SMALL"></participant-avatar>
          <div class="mention-suggestion-list__item__name" data-bind="text: suggestion.name()" data-uie-name="status-name"></div>
          <!-- ko if: suggestion.isTemporaryGuest() -->
            <div class="mention-suggestion-list__item__remaining"  data-bind="text: suggestion.expirationRemainingText()" data-uie-name="status-remaining"></div>
          <!-- /ko -->
          <!-- ko ifnot: suggestion.isTemporaryGuest() -->
            <div class="mention-suggestion-list__item__username" data-bind="text: suggestion.username()" data-uie-name="status-username"></div>
          <!-- /ko -->
          <!-- ko if: suggestion.isGuest() -->
            <guest-icon class="mention-suggestion-list__item__guest-badge" data-uie-name="status-guest"></guest-icon>
          <!-- /ko -->
        </div>
      </div>
    </div>
  <!-- /ko -->`,

  viewModel: z.components.MentionSuggestions,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ServiceList = class ServiceList {
  static get MODE() {
    return {
      COMPACT: 'ServiceList.MODE.COMPACT',
      DEFAULT: 'ServiceList.MODE.DEFAULT',
    };
  }

  constructor(params) {
    this.isSearching = params.isSearching || z.util.noop;
    this.mode = params.mode || ServiceList.MODE.DEFAULT;
    this.onClick = params.click;
    this.services = params.services;
    this.altStyle = params.altStyle;

    this.isCompactMode = this.mode === ServiceList.MODE.COMPACT;
    this.isDefaultMode = this.mode === ServiceList.MODE.DEFAULT;

    this.avatarSize = this.isCompactMode
      ? z.components.ParticipantAvatar.SIZE.LARGE
      : z.components.ParticipantAvatar.SIZE.SMALL;

    this.cssClasses = ko.pureComputed(() => (this.isCompactMode ? 'search-list-sm' : 'search-list-lg'));
  }
};

ko.components.register('service-list', {
  template: `
    <div class="search-list" data-bind="css: cssClasses(), foreach: services">
      <participant-item params="participant: $data" data-bind="click: $parent.onClick, css: {'no-underline': $parent.altStyle, 'show-arrow': $parent.altStyle}"></participant-item>
    </div>
    <!-- ko if: isSearching() && !services().length -->
      <div class="no-results" data-bind="l10n_text: z.string.searchListNoMatches"></div>
    <!-- /ko -->
  `,
  viewModel: z.components.ServiceList,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.TopPeople = class TopPeople {
  constructor(params) {
    this.click = params.click;
    this.maxUsers = params.max || 9;
    this.userEntities = params.users;

    this.displayedUsers = ko.pureComputed(() => this.userEntities().slice(0, this.maxUsers));

    this.onUserClick = (userEntity, event) => {
      if (typeof this.click === 'function') {
        return this.click(userEntity, event);
      }
    };
  }
};

ko.components.register('top-people', {
  template: `
    <div class="search-list search-list-sm" data-bind="foreach: {data: displayedUsers}">
      <div class="search-list-item" data-bind="click: $parent.onUserClick, attr: {'data-uie-uid': $data.id, 'data-uie-value': $data.name(), 'data-uie-status': $data.connection().status()}" data-uie-name="item-user">
        <participant-avatar class="search-list-item-image" params="participant: $data, delay: 300, size: z.components.ParticipantAvatar.SIZE.LARGE"></participant-avatar>
        <div class="search-list-item-content">
          <div class="search-list-item-content-name" data-bind="text: first_name"></div>
        </div>
      </div>
    </div>
  `,
  viewModel: z.components.TopPeople,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ParticipantAvatar = class ParticipantAvatar {
  static get SIZE() {
    return {
      LARGE: 'avatar-l',
      MEDIUM: 'avatar-m',
      SMALL: 'avatar-s',
      X_LARGE: 'avatar-xl',
      X_SMALL: 'avatar-xs',
      XX_SMALL: 'avatar-xxs',
      XXX_SMALL: 'avatar-xxxs',
    };
  }

  static get DIAMETER() {
    return {
      [ParticipantAvatar.SIZE.LARGE]: 72,
      [ParticipantAvatar.SIZE.MEDIUM]: 40,
      [ParticipantAvatar.SIZE.SMALL]: 28,
      [ParticipantAvatar.SIZE.X_LARGE]: 200,
      [ParticipantAvatar.SIZE.X_SMALL]: 24,
      [ParticipantAvatar.SIZE.XX_SMALL]: 20,
      [ParticipantAvatar.SIZE.XXX_SMALL]: 16,
    };
  }

  constructor(params, componentInfo) {
    const isParticipantObservable = typeof params.participant === 'function';
    this.participant = isParticipantObservable ? params.participant : ko.observable(params.participant);

    this.isService = ko.pureComputed(() => {
      return this.participant() instanceof z.integration.ServiceEntity || this.participant().isService;
    });

    this.isUser = ko.pureComputed(() => {
      return this.participant() instanceof z.entity.User && !this.participant().isService;
    });

    this.isTemporaryGuest = ko.pureComputed(() => this.isUser() && this.participant().isTemporaryGuest());

    this.remainingTimer = undefined;

    this.avatarType = ko.pureComputed(() => `${this.isUser() ? 'user' : 'service'}-avatar`);
    this.delay = params.delay;
    this.size = params.size || ParticipantAvatar.SIZE.LARGE;
    this.element = $(componentInfo.element);
    this.element.addClass(`${this.avatarType()} ${this.size}`);

    const borderScale = 0.9916;
    const finalBorderWidth = this.size === ParticipantAvatar.SIZE.X_LARGE ? 4 : 1;
    this.borderWidth = (finalBorderWidth / ParticipantAvatar.DIAMETER[this.size]) * 32;
    this.borderRadius = (16 - this.borderWidth / 2) * borderScale;
    this.timerLength = this.borderRadius * Math.PI * 2;
    this.timerOffset = ko.observable();

    this.timerOffset = ko.pureComputed(() => {
      if (this.isTemporaryGuest()) {
        const remainingTime = this.participant().expirationRemaining();
        const normalizedRemainingTime = remainingTime / z.entity.User.CONFIG.TEMPORARY_GUEST.LIFETIME;
        return this.timerLength * (normalizedRemainingTime - 1);
      }
      return 0;
    });

    this.avatarLoadingBlocked = false;
    this.avatarEnteredViewport = false;

    this.dispose = this.dispose.bind(this);

    this.element.attr({
      id: z.util.createRandomUuid(),
      'user-id': this.participant().id,
    });

    this.initials = ko.pureComputed(() => {
      if (this.isService()) {
        return '';
      }

      return this.element.hasClass('avatar-xs')
        ? z.util.StringUtil.getFirstChar(this.participant().initials())
        : this.participant().initials();
    });

    this.state = ko.pureComputed(() => {
      switch (true) {
        case this.isService():
          return '';
        case this.participant().is_me:
          return 'self';
        case typeof params.selected === 'function' && params.selected():
          return 'selected';
        case this.participant().isTeamMember():
          return '';
        case this.participant().isBlocked():
          return 'blocked';
        case this.participant().isRequest():
          return 'pending';
        case this.participant().isIgnored():
          return 'ignored';
        case this.participant().isCanceled() || this.participant().isUnknown():
          return 'unknown';
        default:
          return '';
      }
    });

    this.cssClasses = ko.pureComputed(() => {
      if (this.isService()) {
        return 'accent-color-service';
      }

      return this.isTemporaryGuest()
        ? 'accent-color-temporary'
        : `accent-color-${this.participant().accent_id()} ${this.state()}`;
    });

    this.onClick = (data, event) => {
      if (typeof params.click === 'function') {
        params.click(data.participant, event.currentTarget.parentNode);
      }
    };

    const _loadAvatarPicture = () => {
      this.element.find('.avatar-image').html('');
      this.element.removeClass('avatar-image-loaded avatar-loading-transition');
      if (!this.avatarLoadingBlocked) {
        this.avatarLoadingBlocked = true;

        const isSmall = this.size !== ParticipantAvatar.SIZE.LARGE && this.size !== ParticipantAvatar.SIZE.X_LARGE;
        const loadHiRes = !isSmall && window.devicePixelRatio > 1;
        const pictureResource = loadHiRes
          ? this.participant().mediumPictureResource()
          : this.participant().previewPictureResource();

        if (pictureResource) {
          const isCached = pictureResource.downloadProgress() === 100;

          pictureResource.getObjectUrl().then(url => {
            if (url) {
              const image = new Image();
              image.src = url;
              this.element.find('.avatar-image').html(image);
              this.element.addClass(`avatar-image-loaded ${isCached && isSmall ? '' : 'avatar-loading-transition'}`);
            }
            this.avatarLoadingBlocked = false;
          });
        } else {
          this.avatarLoadingBlocked = false;
        }
      }
    };

    const _onInViewport = () => {
      this.avatarEnteredViewport = true;
      _loadAvatarPicture();
    };

    const _loadAvatarPictureIfVisible = () => {
      if (this.avatarEnteredViewport) {
        _loadAvatarPicture();
      }
    };

    z.ui.ViewportObserver.addElement(componentInfo.element, _onInViewport);

    this.pictureSubscription = this.participant().mediumPictureResource.subscribe(_loadAvatarPictureIfVisible);
    this.participantSubscription = this.participant.subscribe(_loadAvatarPictureIfVisible);
  }

  dispose() {
    z.ui.ViewportObserver.removeElement(this.element[0]);
    this.participantSubscription.dispose();
    this.pictureSubscription.dispose();
  }
};

ko.components.register('participant-avatar', {
  template: `
    <div class="participant-avatar" data-bind="attr: {title: participant().name, 'data-uie-name': avatarType()}, css: cssClasses(), click: onClick, delay: delay">
      <div class="avatar-background"></div>
      <!-- ko if: isUser -->
        <div class="avatar-initials" data-bind="text: initials()"></div>
      <!-- /ko -->
      <!-- ko if: isService -->
        <div class="avatar-service-placeholder">
            <svg width="32" height="32" viewBox="0 0 32 32">
              <path d="M10.5 12A6.5 6.5 0 0 0 4 18.5V24a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-5.5a6.5 6.5 0 0 0-6.5-6.5h-11zm-7.12-1.22L.24 4.95a2 2 0 1 1 3.52-1.9L6.8 8.68C7.94 8.24 9.19 8 10.5 8h11C27.3 8 32 12.7 32 18.5V24a5 5 0 0 1-5 5H5a5 5 0 0 1-5-5v-5.5c0-3.05 1.3-5.8 3.38-7.72zM11 19a2 2 0 1 1-4 0 2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0m5 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm5.26-9.55a2 2 0 0 1-3.52-1.9l3.5-6.5a2 2 0 0 1 3.52 1.9l-3.5 6.5z"></path>
            </svg>
        </div>
      <!-- /ko -->
      <div class="avatar-image"></div>
      <!-- ko if: isUser -->
        <div class="avatar-badge"></div>
      <!-- /ko -->
      <div class="avatar-border"></div>
      <!-- ko if: isTemporaryGuest() -->
        <svg class="avatar-temporary-guest-border" viewBox="0 0 32 32" data-bind="attr: {stroke: participant().accent_color()}">
          <circle cx="16" cy="16" transform="rotate(-90 16 16)" fill="none"
             data-bind="attr: {'stroke-dasharray': timerLength, 'stroke-dashoffset': timerOffset, 'r': borderRadius, 'stroke-width': borderWidth}">
          </circle>
        </svg>
      <!-- /ko -->
    </div>
    `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.ParticipantAvatar(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ParticipantItem = class ParticipantItem {
  constructor(params) {
    this.participant = ko.unwrap(params.participant);
    this.isService = this.participant instanceof z.integration.ServiceEntity || this.participant.isService;
    this.isUser = this.participant instanceof z.entity.User && !this.participant.isService;
    this.selfUser = window.wire.app.repository.user.self;
    this.isTemporaryGuest = this.isUser && this.participant.isTemporaryGuest();

    this.mode = params.mode || z.components.UserList.MODE.DEFAULT;
    this.isDefaultMode = this.mode === z.components.UserList.MODE.DEFAULT;
    this.isOthersMode = this.mode === z.components.UserList.MODE.OTHERS;

    this.canSelect = params.canSelect;
    this.isSelected = params.isSelected;
    this.showCamera = params.showCamera;

    if (params.hideInfo) {
      this.contentInfo = null;
    } else if (this.isService) {
      this.contentInfo = this.participant.summary;
    } else if (this.isTemporaryGuest) {
      this.contentInfo = this.participant.expirationText;
    } else {
      this.contentInfo = this.participant.username();
    }
  }
};

ko.components.register('participant-item', {
  template: `
    <div class="participant-item" data-bind="attr: {'data-uie-name': isUser ? 'item-user' : 'item-service', 'data-uie-value': participant.name}">
      <div class="participant-item-image">
        <participant-avatar params="participant: participant, size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
      </div>

      <div class="participant-item-content">
        <!-- ko if: isUser && selfUser().inTeam() -->
          <availability-state class="participant-item-content-availability participant-item-content-name"
            data-uie-name="status-name"
            params="availability: participant.availability, label: participant.name"></availability-state>
        <!-- /ko -->

        <!-- ko if: isService || !selfUser().inTeam() -->
          <div class="participant-item-content-name" data-bind="text: participant.name" data-uie-name="status-name"></div>
        <!-- /ko -->
        <div class="participant-item-content-info">
          <!-- ko if: contentInfo -->
            <span class="participant-item-content-username label-username-notext" data-bind="text: contentInfo, css: {'label-username': isUser && !isTemporaryGuest}" data-uie-name="status-username"></span>
          <!-- /ko -->
        </div>
      </div>

      <!-- ko if: isUser && participant.is_verified() -->
        <verified-icon data-uie-name="status-verified"></verified-icon>
      <!-- /ko -->

      <!-- ko if: isUser && !isOthersMode && participant.isGuest() -->
        <guest-icon class="participant-item-guest-indicator" data-uie-name="status-guest"></guest-icon>
      <!-- /ko -->

      <!-- ko if: showCamera -->
        <camera-icon data-uie-name="status-video"></camera-icon>
      <!-- /ko -->

      <!-- ko if: canSelect -->
        <div class="search-list-item-select icon-check" data-bind="css: {'selected': isSelected}" data-uie-name="status-selected"></div>
      <!-- /ko -->

      <disclose-icon></disclose-icon>
    </div>
  `,
  viewModel: z.components.ParticipantItem,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserProfile = class UserProfile {
  constructor(params) {
    this.dispose = this.dispose.bind(this);

    this.logger = new z.util.Logger('z.components.UserProfile', z.config.LOGGER.OPTIONS);

    this.userEntity = params.user;

    this.hasUser = ko.pureComputed(() => typeof this.userEntity === 'function' && !!this.userEntity());

    // Actions
    this.clickOnClose = () => {
      if (typeof params.close === 'function') {
        this.renderAvatar(false);
        params.close();
      }
    };

    this.clickOnPending = () => {
      if (this.hasUser()) {
        const isPendingRequest = this.userEntity().isIgnored() || this.userEntity().isIncomingRequest();
        if (isPendingRequest && typeof params.pending === 'function') {
          return params.pending(this.userEntity());
        }
      }
    };

    this.clickToAcceptInvite = () => {
      if (this.hasUser() && typeof params.accept === 'function') {
        params.accept(this.userEntity());
      }
    };

    this.clickToIgnoreInvite = () => {
      if (this.hasUser() && typeof params.ignore === 'function') {
        params.ignore(this.userEntity());
      }
    };

    this.clickToSendRequest = () => {
      if (this.hasUser() && typeof params.connect === 'function') {
        params.connect(this.userEntity());
      }
    };

    this.clickToUnblock = () => {
      if (this.hasUser() && typeof params.unblock === 'function') {
        params.unblock(this.userEntity());
      }
    };

    this.renderAvatar = ko.observable(false);
    this.renderAvatarComputed = ko.computed(() => {
      const hasUserId = this.hasUser();

      // swap value to re-render avatar
      if (hasUserId) {
        this.renderAvatar(false);
        window.setTimeout(() => this.renderAvatar(hasUserId), 0);
      }
    });

    // footer
    this.getFooterTemplate = ko.pureComputed(() => {
      if (this.hasUser()) {
        const userEntity = this.userEntity();

        if (userEntity.isBlocked()) {
          return 'user-profile-footer-unblock';
        }

        if (userEntity.isIgnored() || userEntity.isIncomingRequest()) {
          return 'user-profile-footer-ignore-accept';
        }

        if (userEntity.isUnknown()) {
          return 'user-profile-footer-add';
        }
      }

      return 'user-profile-footer-empty';
    });
  }

  dispose() {
    this.renderAvatarComputed.dispose();
  }
};

ko.components.register('user-profile', {
  template: `
    <div class="user-profile-transition">
      <!-- ko if: hasUser() -->
        <div class="user-profile-default">
          <div class="user-profile-header">
            <div class="name popover-title ellipsis" data-bind="text: userEntity().name(), attr: {'data-uie-uid': userEntity().id, 'data-uie-value': userEntity().name()}" data-uie-name="status-user"></div>
            <div class="username popover-meta label-username" data-bind="text: userEntity().username(), attr: {'data-uie-value': userEntity().name()}" data-uie-name="status-username"></div>
          </div>

          <div class="user-profile-details">
            <!-- ko if: renderAvatar() -->
              <div class="user-profile-details-avatar">
                <participant-avatar class="cursor-default" params="participant: userEntity, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>
              </div>
            <!-- /ko -->
          </div>
          <div class="user-profile-footer">
            <!-- ko template: {name: getFooterTemplate} --><!-- /ko -->
          </div>
        </div>
      <!-- /ko -->
    </div>
  `,
  viewModel: z.components.UserProfile,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserInput = class UserInput {
  constructor(params, componentInfo) {
    this.dispose = this.dispose.bind(this);

    this.input = params.input;
    this.onEnter = params.enter;
    this.placeholderText = params.placeholder;
    this.selectedUsers = params.selected;

    this.element = componentInfo.element;
    this.innerElement = $(this.element).find('.search-inner');
    this.inputElement = $(this.element).find('.search-input');

    this.hasFocus = ko.observable(false);
    if (params.focusDelay) {
      window.setTimeout(() => this.hasFocus(true), params.focusDelay);
    } else {
      this.hasFocus(true);
    }

    this.noSelectedUsers = ko.pureComputed(() => {
      return typeof this.selectedUsers !== 'function' || !this.selectedUsers().length;
    });

    if (typeof this.selectedUsers === 'function') {
      this.selectedSubscription = this.selectedUsers.subscribe(() => {
        if (typeof this.input === 'function') {
          this.input('');
        }

        this.inputElement.focus();
        window.setTimeout(() => this.innerElement.scrollTop(this.innerElement[0].scrollHeight));
      });
    }

    this.placeholder = ko.pureComputed(() => {
      const emptyInput = typeof this.input !== 'function' || !this.input().length;
      if (emptyInput && this.noSelectedUsers()) {
        return z.l10n.text(this.placeholderText);
      }

      return '';
    });
  }

  onKeyDown(data, keyboardEvent) {
    if (typeof this.selectedUsers === 'function') {
      if (z.util.KeyboardUtil.isRemovalAction(keyboardEvent) && !this.input().length) {
        this.selectedUsers.pop();
      }
    }
    return true;
  }

  dispose() {
    if (this.selectedSubscription) {
      this.selectedSubscription.dispose();
    }
  }
};

ko.components.register('user-input', {
  template: `
    <div class="search-outer">
      <div class="search-inner-wrap">
        <div class="search-inner"">
          <div class="search-icon icon-search"></div>
          <!-- ko ifnot: noSelectedUsers-->
            <!-- ko foreach: selectedUsers -->
              <span data-bind="text: first_name()" data-uie-name="item-selected"></span>
            <!-- /ko -->
          <!-- /ko -->
          <input type="text" style="display:none" /> <!-- prevent chrome from autocomplete -->
          <input autocomplete="off" maxlength="128" required spellcheck="false" class="search-input" type="text" data-bind="textInput: input, hasFocus: hasFocus, attr: {placeholder: placeholder}, css: {'search-input-show-placeholder': placeholder}, event: {keydown: onKeyDown}, enter: onEnter" data-uie-name="enter-users">
        </div>
      </div>
    </div>
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.UserInput(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.UserList = class UserList {
  static get MODE() {
    return {
      COMPACT: 'UserList.MODE.COMPACT',
      DEFAULT: 'UserList.MODE.DEFAULT',
      OTHERS: 'UserList.MODE.OTHERS',
    };
  }

  /**
   * Displays a list of user_ets
   *
   * @param {Object} params - Component parameters
   * @param {ko.observableArray} params.user - User data source
   * @param {ko.observable} params.filter - Filter list items
   * @param {Function} params.click - Called when a list item is selected
   * @param {ko.observableArray} params.selected - Populated will all the selected items
   * @param {Array} params.highlightedUsers - List of highlighted items
   */
  constructor(params) {
    this.click = params.click;
    this.filter = params.filter;
    this.selectedUsers = params.selected;
    this.mode = params.mode || UserList.MODE.DEFAULT;
    this.searchRepository = params.searchRepository;
    this.userEntities = params.user;
    const highlightedUsers = params.highlightedUsers ? params.highlightedUsers() : [];
    this.highlightedUserIds = highlightedUsers.map(user => user.id);
    this.isSelectEnabled = typeof params.selected === 'function';
    this.altStyle = params.altStyle;

    this.isCompactMode = this.mode === UserList.MODE.COMPACT;
    this.isDefaultMode = this.mode === UserList.MODE.DEFAULT;
    this.isOthersMode = this.mode === UserList.MODE.OTHERS;

    this.cssClasses = ko.pureComputed(() => (this.isCompactMode ? 'search-list-sm' : 'search-list-lg'));

    this.onUserClick = (userEntity, event) => {
      if (this.isSelectEnabled) {
        if (this.isSelected(userEntity)) {
          this.selectedUsers.remove(userEntity);
        } else {
          this.selectedUsers.push(userEntity);
        }
      }
      if (typeof this.click === 'function') {
        this.click(userEntity, event);
      }
    };

    // Filter all list items if a filter is provided
    this.filteredUserEntities = ko.pureComputed(() => {
      if (typeof this.filter === 'function') {
        const normalizedQuery = z.search.SearchRepository.normalizeQuery(this.filter());
        if (normalizedQuery) {
          const SEARCHABLE_FIELDS = z.search.SearchRepository.CONFIG.SEARCHABLE_FIELDS;
          const trimmedQuery = this.filter().trim();
          const isHandle = trimmedQuery.startsWith('@') && z.user.UserHandleGenerator.validate_handle(normalizedQuery);
          const properties = isHandle ? [SEARCHABLE_FIELDS.USERNAME] : undefined;
          return this.searchRepository.searchUserInSet(normalizedQuery, this.userEntities(), properties);
        }
      }
      return this.userEntities();
    });

    this.isSelected = userEntity => {
      if (this.isSelectEnabled) {
        return this.selectedUsers().includes(userEntity);
      }
    };

    this.selfUser = window.wire.app.repository.user.self;
  }
};

ko.components.register('user-list', {
  template: `
    <div class="search-list" data-bind="css: cssClasses(), foreach: {data: filteredUserEntities}">
      <participant-item params="participant: $data, canSelect: $parent.isSelectEnabled, isSelected: $parent.isSelected($data), mode: $parent.mode" data-bind="click: $parent.onUserClick, css: {'no-underline': $parent.altStyle, 'show-arrow': $parent.altStyle, 'highlighted': $parent.highlightedUserIds.includes($data.id)}"></participant-item>
    </div>

    <!-- ko if: typeof filter === 'function' -->
      <!-- ko if: userEntities().length === 0 -->
        <div class="no-results" data-bind="l10n_text: z.string.searchListEveryoneParticipates"></div>
      <!-- /ko -->

      <!-- ko if: userEntities().length > 0 && filteredUserEntities().length === 0 -->
        <div class="no-results" data-bind="l10n_text: z.string.searchListNoMatches" data-uie-name="status-no-matches"></div>
      <!-- /ko -->
    <!-- /ko -->
  `,
  viewModel: z.components.UserList,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GuestModeToggle = class GuestModeToggle {
  constructor(params) {
    this.isChecked = params.isChecked;
    this.onToggle = params.onToggle;
    this.isDisabled = params.isDisabled;
    this.infoText = params.extendedInfo ? z.string.guestRoomToggleInfoExtended : z.string.guestRoomToggleInfo;
  }
};

ko.components.register('guest-mode-toggle', {
  template: `
    <div class="guest-mode-toggle-row">
      <div data-bind="text: z.string.guestRoomToggleName"></div>
      <div class="slider" data-bind="css: {'disabled': isDisabled}">
        <input class="slider-input" type="checkbox" name="toggle" id="toggle" data-bind="checked: isChecked">
        <label class="button-label" for="toggle" data-bind="click: onToggle, attr: {'data-uie-value': isChecked() ? 'checked': 'unchecked'}" data-uie-name="do-allow-guests" ></label>
      </div>
    </div>
    <div class="panel__info-text guest-mode-toggle-info" data-bind="text: infoText" data-uie-name="status-guest-toggle"></div>
  `,
  viewModel: z.components.GuestModeToggle,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('add-participants-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12 2V0h2v2h2v2h-2v2h-2V4h-2V2h2zm-2.57 8.57A2.57 2.57 0 0 1 12 13.14v1.1a12.8 12.8 0 0 1-12 0v-1.1a2.57 2.57 0 0 1 2.57-2.57h.34a5.97 5.97 0 0 0 6.18 0h.34zM6 8.86A3.43 3.43 0 1 1 6 2a3.43 3.43 0 0 1 0 6.86z"></path>
  </svg>
  `,
});

ko.components.register('archive-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M1 7h14v7a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7zm6 2a1 1 0 1 0 0 2h2a1 1 0 0 0 0-2H7zM2.5 0h11c.8 0 1.2 0 1.5.3.3.1.6.4.7.7.2.3.3.7.3 1.5V4c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V2.5C0 1.7 0 1.3.3 1 .4.7.7.4 1 .3c.3-.2.7-.3 1.5-.3z"></path>
  </svg>
  `,
});

ko.components.register('arrow-left-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
      <path d="M4.83 9l5.24 5.24-1.41 1.41L1 8 8.66.34l1.41 1.41L4.83 7H15v2z"></path>
  </svg>
  `,
});

ko.components.register('attachment-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M1.63 7.7l4.74-4.78a3.33 3.33 0 0 1 4.73 0 3.4 3.4 0 0 1 0 4.78L9.75 9.07l-4.4 4.43a1.9 1.9 0 0 1-2.7 0 1.94 1.94 0 0 1 0-2.73L4 9.41l4.4-4.45a.47.47 0 0 1 .68 0c.18.2.19.5 0 .69l-4.75 4.79a.97.97 0 0 0 0 1.36c.38.38.98.38 1.36 0l4.74-4.79c.94-.94.93-2.46 0-3.4a2.37 2.37 0 0 0-3.38-.01l-4.4 4.44-1.36 1.37a3.89 3.89 0 0 0 0 5.46 3.8 3.8 0 0 0 5.42 0l4.4-4.44 1.35-1.37a5.34 5.34 0 0 0 0-7.5 5.23 5.23 0 0 0-7.44 0L.28 6.32a.97.97 0 0 0 0 1.37c.37.38.98.38 1.35 0z"></path>
  </svg>
  `,
});

ko.components.register('audio-icon', {
  template: `
  <svg width="12" height="16" viewBox="0 0 12 16">
    <path d="M10.5 12l1.4 1.4a8 8 0 0 1-11.9 0L1.4 12a6 6 0 0 0 9.1 0zM6 12a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4 4 4 0 0 1 4 4v4a4 4 0 0 1-4 4z"></path>
  </svg>
  `,
});

ko.components.register('block-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm4.9-11.48l-.2.19-8.18 8.18a6 6 0 0 0 8.37-8.37zm-1.42-1.41a6 6 0 0 0-8.37 8.37l8.18-8.19.19-.18z"></path>
  </svg>
  `,
});

ko.components.register('camera-icon', {
  template: `
  <svg width="16" height="12" viewBox="0 0 16 12">
    <path id="a" d="M2.6 0h4.8c1 0 1.3 0 1.6.3.3.1.6.4.7.7.2.3.3.7.3 1.6v6.8c0 1 0 1.3-.3 1.6-.1.3-.4.6-.7.7-.3.2-.7.3-1.6.3H2.6c-1 0-1.3 0-1.6-.3-.3-.1-.6-.4-.7-.7-.2-.3-.3-.7-.3-1.6V2.6c0-1 0-1.3.3-1.6C.4.7.7.4 1 .3c.3-.2.7-.3 1.6-.3zm8.7 5.3l3-3A1 1 0 0 1 16 3v6a1 1 0 0 1-1.7.7l-3-3a1 1 0 0 1 0-1.4z"></path>
  </svg>
  `,
});

ko.components.register('check-icon', {
  template: `
  <svg width="16" height="12" viewBox="0 0 16 12">
    <path d="M5.7 11.9L16 1.4 14.6 0 5.7 9 1.4 4.8 0 6.2z"></path>
  </svg>
  `,
});

ko.components.register('chevron-icon', {
  template: `
  <svg width="7" height="4" viewBox="0 0 7 4">
    <path d="M3.65 3.65L6.44.85A.5.5 0 0 0 6.09 0H.5a.5.5 0 0 0-.35.85l2.79 2.8c.2.2.51.2.7 0z"></path>
  </svg>
  `,
});

ko.components.register('close-icon', {
  template: `
  <svg width="14" height="14" viewBox="0 0 14 14">
    <path d="M1.41 13.31l5.25-5.24 5.24 5.24 1.41-1.41-5.24-5.24 5.24-5.25L11.9 0 6.66 5.24 1.41 0 0 1.41l5.24 5.25L0 11.9z"></path>
  </svg>
  `,
});

ko.components.register('copy-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M6 10h8V2H6v8zM5 0h10a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1zM2 4v10h10v1a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h1z"></path>
  </svg>
  `,
});

ko.components.register('delete-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M5 2a2 2 0 1 1 4 0h4a1 1 0 0 1 1 1v1H0V3a1 1 0 0 1 1-1h4zM1 6h12l-.8 8c-.11 1.1-1.09 2-2.2 2H4c-1.1 0-2.09-.89-2.2-2L1 6zm5.5 2v5.54h1V8h-1z"></path>
  </svg>
  `,
});

ko.components.register('devices-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M11 4h2.4c1 0 1.2.1 1.6.3.3.1.6.4.7.7.2.3.3.7.3 1.6v6.8c0 1-.1 1.2-.3 1.6-.1.3-.4.6-.7.7-.3.2-.7.3-1.6.3H2.6c-1 0-1.2-.1-1.6-.3a1.8 1.8 0 0 1-.7-.7c-.2-.3-.3-.7-.3-1.6V2.6C0 1.6.1 1.4.3 1 .4.7.7.4 1 .3c.4-.2.7-.3 1.6-.3h5.8c1 0 1.2.1 1.6.3.3.1.6.4.7.7.2.4.3.7.3 1.6V4zM9 4V3a1 1 0 0 0-1-1h-.5a.5.5 0 0 0-.5.5.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5.5.5 0 0 0-.5-.5H3a1 1 0 0 0-1 1v9.7l.1.8.4.4.8.1H7a8.2 8.2 0 0 1 0-.6V6.6c0-1 .1-1.3.3-1.6.1-.3.4-.6.7-.7.3-.2.5-.3 1-.3zm1.3 2l-.8.1a.9.9 0 0 0-.4.4l-.1.8v5.4l.1.8.4.4.8.1h2.4l.8-.1a.9.9 0 0 0 .4-.4l.1-.8V7.3l-.1-.8a.9.9 0 0 0-.4-.4l-.8-.1h-2.4z"></path>
  </svg>
  `,
});

ko.components.register('disclose-icon', {
  template: `
  <svg width="5" height="8" viewBox="0 0 5 8">
    <path d="M0 .92L.94 0 5 4 .94 8 0 7.08 3.13 4z"></path>
  </svg>
  `,
});

ko.components.register('edit-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M14.55 4.85l.75-.75A2.4 2.4 0 0 0 11.9.7l-.75.75 3.4 3.4zm-.7.7l-9.6 9.6L0 16l.85-4.25 9.6-9.6 3.4 3.4zM4 13.6L2 14l.4-2L4 13.6z"></path>
  </svg>
  `,
});

ko.components.register('file-icon', {
  template: `
  <svg  width="12" height="16" viewBox="0 0 12 16">
    <path d="M1 0a1 1 0 0 0-1 1v14c0 .6.5 1 1 1h10c.6 0 1-.5 1-1V6H8a2 2 0 0 1-2-2V0H1zm11 5H8.4C7.7 5 7 4.4 7 3.7V0l5 5z"></path>
  </svg>
  `,
});

ko.components.register('fullscreen-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M16 7V0H9v2h3.6L8 6.6 9.4 8 14 3.4V7h2zM0 9v7h7v-2H3.4L8 9.4 6.6 8 2 12.6V9H0z"></path>
  </svg>
  `,
});

ko.components.register('gif-icon', {
  template: `
  <svg width="16" height="13" viewBox="0 0 16 13">
    <path d="M12 7.2v5h-2V.2h6v2h-4v3h3v2h-3zm-5-7h2v12H7V.2zm-2 5h1v4.2a3 3 0 0 1-6 0V3a3 3 0 0 1 6 0v.2H4V3a1 1 0 0 0-1-1 1 1 0 0 0-1 1v6.4a1 1 0 0 0 1 1 1 1 0 0 0 1-1V7.2H3v-2h2z"></path>
  </svg>
  `,
});

ko.components.register('group-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 4a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zM2 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm12 0a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('guest-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M5 1a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3c0-1.1.9-2 2-2h3zm.5 1a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1h-3zM7 9a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm-2 1a2 2 0 0 0-2 2v1h8v-1a2 2 0 0 0-2-2H5z"></path>
  </svg>
  `,
});

ko.components.register('hangup-icon', {
  template: `
  <svg width="20" height="8" viewBox="0 0 20 8">
    <path d="M.6 2.7C2.2 1.2 6 0 9.7 0c3.8 0 7.6 1.2 9 2.7 1 .9.9 2.9 0 4.6l-.3.3H18A216 216 0 0 0 14 6c-.4-.1-.3-.1-.3-.5V3.4l-1-.2a13 13 0 0 0-6.2 0l-.9.2V6l-.4.2a155.4 155.4 0 0 0-3.8 1.5c-.4.1-.4.1-.6-.3-1-1.7-1-3.7-.2-4.6z"></path>
  </svg>
  `,
});

ko.components.register('image-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 1c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v14c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V1zm14 1H2v9l4-2 8 3.5V2zm-4 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('info-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path id="a" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm0-2A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm0-7c.6 0 1 .4 1 1v3a1 1 0 0 1-2 0V8c0-.6.4-1 1-1zm0-1a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"></path>
  </svg>
  `,
});

ko.components.register('link-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5 3.25A5.79 5.79 0 0 1 10.213 0C13.409 0 16 2.574 16 5.75s-2.591 5.75-5.787 5.75A5.79 5.79 0 0 1 5 8.25h2.4a3.775 3.775 0 0 0 2.813 1.25c2.084 0 3.774-1.679 3.774-3.75 0-2.071-1.69-3.75-3.774-3.75A3.775 3.775 0 0 0 7.4 3.25H5zm6 4.5H8.6A3.775 3.775 0 0 0 5.787 6.5c-2.084 0-3.774 1.679-3.774 3.75 0 2.071 1.69 3.75 3.774 3.75A3.775 3.775 0 0 0 8.6 12.75H11A5.79 5.79 0 0 1 5.787 16C2.591 16 0 13.426 0 10.25S2.591 4.5 5.787 4.5A5.79 5.79 0 0 1 11 7.75z"></path>
  </svg>
  `,
});

ko.components.register('leave-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2 14h7v2H0V0h9v2H2v12zm3-7v2h7v4l4-5-4-5v4H5z"></path>
  </svg>
  `,
});

ko.components.register('location-icon', {
  template: `
  <svg width="12" height="16" viewBox="0 0 12 16">
    <path d="M12 6c0 6-6 10-6 10S0 12 0 6a6 6 0 1 1 12 0zM6 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"></path>
  </svg>
  `,
});

ko.components.register('markdown-icon', {
  template: `
  <svg width="15" height="14" viewBox="0 0 15 14">
    <path d="M3.1 0h1.66l3.1 13.88h-2l-.58-2.98h-2.7l-.6 2.98H0L3.1 0zm9.38 12.87h-.04c-.26.36-.52.64-.79.84-.27.2-.64.29-1.12.29-.23 0-.48-.04-.72-.1a1.8 1.8 0 0 1-.7-.4 2.04 2.04 0 0 1-.52-.8c-.14-.34-.2-.79-.2-1.33 0-.56.04-1.05.13-1.47.1-.43.26-.78.5-1.06s.56-.48.96-.62a4.88 4.88 0 0 1 1.97-.19l.53.04V7.04c0-.34-.07-.62-.22-.84-.14-.22-.4-.33-.78-.33-.26 0-.5.08-.7.25a1.2 1.2 0 0 0-.43.74H8.42c.07-.9.37-1.6.9-2.14.26-.26.57-.47.94-.62a3.45 3.45 0 0 1 2.4-.03 2.58 2.58 0 0 1 1.57 1.57c.16.39.24.84.24 1.36v6.88h-2v-1.01zm0-3.24c-.22-.04-.4-.06-.55-.06-.43 0-.8.1-1.1.3-.3.2-.46.57-.46 1.1 0 .38.1.69.28.92a.9.9 0 0 0 .76.36c.33 0 .6-.12.79-.34.18-.22.28-.53.28-.93V9.63zM3.94 4H3.9l-.98 5.03h2L3.93 4z"></path>
  </svg>
  `,
});

ko.components.register('mention-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 6.2c-.8 0-1.4.8-1.4 2 0 1.3.6 2 1.4 2 1 0 1.5-.7 1.5-2 0-1.2-.6-2-1.5-2zM8.4 0C13 0 16 3 16 7.3c0 3-1.2 5-3.7 5-1.2 0-2.1-.6-2.4-1.5h-.2c-.4 1-1.1 1.5-2.3 1.5-2 0-3.3-1.7-3.3-4.1 0-2.4 1.3-4 3.2-4a2.4 2.4 0 0 1 2.2 1.3h.2c0-.6.5-1 1-1h.3c.6 0 1 .4 1 1v3.9c0 .7.3 1 .8 1 .9 0 1.3-1 1.3-2.9 0-3.5-2.2-5.8-5.8-5.8C4.6 1.7 2 4.4 2 8.2c0 3.9 2.6 6 6.8 6a11.3 11.3 0 0 0 1.5-.1.7.7 0 0 1 .8.7c0 .5-.4 1-.9 1H10l-1.4.2C3.5 16 0 13 0 8c0-4.7 3.4-8 8.4-8z"></path>
  </svg>
  `,
});

ko.components.register('message-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M3 0h10a3 3 0 0 1 3 3v7a3 3 0 0 1-3 3H6a3 3 0 0 0-1.8.7l-2.6 2.1A1 1 0 0 1 0 15V3a3 3 0 0 1 3-3z"></path>
  </svg>
  `,
});

ko.components.register('message-unread-icon', {
  template: `
  <svg width="18" height="18" viewBox="0 0 18 18">
    <path d="M12 2a4 4 0 0 0 4 4v6a3 3 0 0 1-3 3H6a3 3 0 0 0-1.8.7l-2.6 2A1 1 0 0 1 0 17V5a3 3 0 0 1 3-3h9zm4 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"></path>
  </svg>
  `,
});

ko.components.register('micoff-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M3.2 14.5a8 8 0 0 0 10.7-1.1L12.4 12A6 6 0 0 1 5 13.2l-1.8 1.3zm8.7-6a4 4 0 0 1-5 3.4l5-3.4zm0-4.5a4 4 0 0 0-4-4 4 4 0 0 0-4 4v4c0 .5 0 1 .2 1.4L.8 11.7l-.8.5L1.1 14l.9-.6 13-9 .8-.5L14.6 2l-.8.6-2 1.3z"></path>
  </svg>
  `,
});

ko.components.register('minus-icon', {
  template: `
  <svg width="16" height="2" viewBox="0 0 16 2">
    <path d="M0 0h16v2H0z"></path>
  </svg>
  `,
});

ko.components.register('mute-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12 3.2l2-1.4a1 1 0 0 1 1.2 1.6L1.6 13a1 1 0 0 1-1.1-1.6l1.3-.9v-.2S2.7 8.5 3 7.5c.4-1.2 1-4.3 1-4.3C4.3 1.4 6 0 8 0a4 4 0 0 1 4 3.2zm1 4.2v.1l1.2 2.7c.4 1-.1 1.8-1.2 1.8H6.4L13 7.4zM10 14a2 2 0 1 1-4 0h4z"></path>
  </svg>
  `,
});

ko.components.register('notification-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M7 0C5 0 3.3 1.4 3 3.2c0 0-.5 3-1 4.3L.8 10.2C.4 11.2 1 12 2 12h10c1.1 0 1.6-.8 1.2-1.8L12 7.5c-.4-1.2-1-4.3-1-4.3A4 4 0 0 0 7 0zm2 14a2 2 0 1 1-4 0h4z"></path>
  </svg>
  `,
});

ko.components.register('pending-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12zm0 2A8 8 0 1 1 8 0a8 8 0 0 1 0 16zM7 7h5v2H7V7zm0-4h2v6H7V3z"></path>
  </svg>
  `,
});

ko.components.register('people-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path d="M10.6 10h.4a3 3 0 0 1 3 3v1.27a14.93 14.93 0 0 1-14 0V13a3 3 0 0 1 3-3h.4a6.97 6.97 0 0 0 7.2 0zM7 8a4 4 0 1 1 0-8 4 4 0 0 1 0 8z"></path>
  </svg>
  `,
});

ko.components.register('pickup-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M12.7 16c-2 0-5.6-1.8-8.2-4.5C1.8 9 0 5.3 0 3.3 0 2 1.4.6 3.4.1l.3-.1.3.3a216 216 0 0 0 1.7 3.8c.1.4.1.4-.1.6l-1 1-.5.6.4.7A13 13 0 0 0 9 11.5l.7.4 1.6-1.5.1-.1.1-.1.4.1a155.4 155.4 0 0 0 3.8 1.7c.4.2.3.2.2.6-.5 2-1.9 3.4-3.2 3.4z"></path>
  </svg>
  `,
});

ko.components.register('ping-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5.95 4.273a1.016 1.016 0 0 0 1.963-.527L7.11.754a1.016 1.016 0 1 0-1.964.526l.802 2.993zm4.101 7.455a1.016 1.016 0 0 0-1.963.526l.802 2.993a1.016 1.016 0 1 0 1.963-.526l-.802-2.993zM3.746 7.913a1.016 1.016 0 0 0 .527-1.964L1.28 5.147a1.016 1.016 0 1 0-.526 1.964l2.992.802zm8.508.175a1.016 1.016 0 1 0-.526 1.963l2.992.802a1.016 1.016 0 0 0 .527-1.963l-2.993-.802zM5.798 11.64a1.016 1.016 0 1 0-1.438-1.437l-2.19 2.19a1.016 1.016 0 1 0 1.436 1.438l2.192-2.19zm4.405-7.28a1.016 1.016 0 1 0 1.437 1.438l2.191-2.191a1.016 1.016 0 0 0-1.437-1.438L10.203 4.36z"></path>
  </svg>
  `,
});

ko.components.register('plus-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 7v2h7v7h2V9h7V7H9V0H7v7z"></path>
  </svg>
  `,
});

ko.components.register('profile-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zM2 8c0 1.5.56 2.88 1.47 3.94l.08-.46c.15-.82.93-1.48 1.76-1.48h5.38c.83 0 1.61.67 1.76 1.48l.08.46A6 6 0 1 0 2 8zm6 1a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5z"></path>
  </svg>
  `,
});

ko.components.register('reply-icon', {
  template: `
  <svg width="16" height="15" viewBox="0 0 16 15">
    <path d="M3.3 4h7.1C13.5 4 16 6.6 16 9.6c0 3-2.5 5.4-5.6 5.4H7a1 1 0 0 1 0-2h3.4c2 0 3.6-1.4 3.6-3.4S12.5 6 10.4 6h-7l2.4 2.4a1 1 0 0 1 0 1.3 1 1 0 0 1-1.4 0l-4.1-4a1 1 0 0 1-.2-.3 1 1 0 0 1 .2-1l4-4.1a1 1 0 0 1 1.5 0 1 1 0 0 1 0 1.3L3.3 4z"></path>
  </svg>
  `,
});

ko.components.register('screenshare-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M5 14h6v2H5v-2zM0 1c0-.6.4-1 1-1h14c.6 0 1 .4 1 1v11c0 .6-.4 1-1 1H1a1 1 0 0 1-1-1V1zm7 10h2V7h4L8 3 3 7h4v4z"></path>
  </svg>
  `,
});

ko.components.register('send-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M0 14.3c0 1.5 1 2.1 2.3 1.4L15 9.2c1.3-.7 1.3-1.7 0-2.4L2.3.3C1.1-.4 0 .3 0 1.7V8h12L0 10v4.3z"></path>
  </svg>
  `,
});

ko.components.register('service-icon', {
  template: `
  <svg width="32" height="32" viewBox="0 0 32 32">
    <path d="M10.5 12A6.5 6.5 0 0 0 4 18.5V24a1 1 0 0 0 1 1h22a1 1 0 0 0 1-1v-5.5a6.5 6.5 0 0 0-6.5-6.5h-11zm-7.12-1.22L.24 4.95a2 2 0 1 1 3.52-1.9L6.8 8.68C7.94 8.24 9.19 8 10.5 8h11C27.3 8 32 12.7 32 18.5V24a5 5 0 0 1-5 5H5a5 5 0 0 1-5-5v-5.5c0-3.05 1.3-5.8 3.38-7.72zM11 19a2 2 0 1 1-4 0 2 2 0 0 1 4 0m7 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0m5 2a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm5.26-9.55a2 2 0 0 1-3.52-1.9l3.5-6.5a2 2 0 0 1 3.52 1.9l-3.5 6.5z"></path>
  </svg>
`,
});

ko.components.register('settings-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2.8 11a6 6 0 0 1-.6-1.5H0v-3h2.2c.1-.6.3-1 .6-1.5L1.3 3.4l2.1-2.1L5 2.8a6 6 0 0 1 1.5-.6V0h3v2.2c.6.1 1 .3 1.5.6l1.6-1.5 2.1 2.1L13.2 5c.3.4.5 1 .6 1.5H16v3h-2.2a6 6 0 0 1-.6 1.5l1.5 1.6-2.1 2.1-1.6-1.5a6 6 0 0 1-1.5.6V16h-3v-2.2a6 6 0 0 1-1.5-.6l-1.6 1.5-2.1-2.1L2.8 11zM8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8z"></path>
  </svg>
  `,
});

ko.components.register('timer-icon', {
  template: `
  <svg width="15" height="16" viewBox="0 0 15 16">
    <path d="M7.44 2v1.08a6.48 6.48 0 0 1 5.45 6.42c0 3.59-2.89 6.5-6.45 6.5A6.47 6.47 0 0 1 0 9.5a6.48 6.48 0 0 1 5.45-6.42V2h-.5a1 1 0 0 1-.98-1 1 1 0 0 1 .99-1h2.97a1 1 0 0 1 1 1 1 1 0 0 1-1 1h-.5zm-1 12a4.48 4.48 0 0 0 4.47-4.5c0-2.49-2-4.5-4.47-4.5a4.48 4.48 0 0 0-4.46 4.5c0 2.49 2 4.5 4.46 4.5zm0-1a3.49 3.49 0 0 1-3.47-3.5C2.97 7.57 4.53 6 6.44 6v3.5l2.47 2.47A3.44 3.44 0 0 1 6.44 13zm6.57-10.3l.7.71a1 1 0 0 1 0 1.42.99.99 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.42.99.99 0 0 1 1.4 0z"></path>
  </svg>
  `,
});

ko.components.register('undo-icon', {
  template: `
  <svg width="16" height="16" viewBox="0 0 16 16">
    <path d="M2.3 2.3a8.3 8.3 0 0 1 4-2.1 8.2 8.2 0 0 1 7.4 2.1A8 8 0 1 1 .3 10h2a6.1 6.1 0 0 0 2.2 2.9A6 6 0 0 0 14 8a6 6 0 0 0-8.3-5.5c-.8.3-1.4.7-2 1.3L7 7H0V0l2.3 2.3z"></path>
  </svg>
  `,
});

ko.components.register('verified-icon', {
  template: `
  <svg width="14" height="16" viewBox="0 0 14 16">
    <path fill="#0097F8" d="M14 1.9L7 0 0 2v6c0 4 3 7.1 7 8 4-.9 7-4 7-8V1.9z"></path>
    <path fill="#0079B6" d="M14 1.9L7 0v16c4-.9 7-4 7-8V1.9z"></path>
  </svg>
  `,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

ko.components.register('wire-logo', {
  template: `
  <svg width="73" height="23" viewBox="0 0 73 23">
    <path d="M13.92 18.76a6.85 6.85 0 0 1-1.64-4.42V3.24a1.64 1.64 0 1 1 3.29 0V14.3a6.8 6.8 0 0 1-1.65 4.43v.04zm12.33-4.42a6.94 6.94 0 0 1-11.1 5.56 8.62 8.62 0 0 0 2.06-5.56V3.24A3.26 3.26 0 0 0 13.92 0a3.22 3.22 0 0 0-3.24 3.24V14.3c0 2.1.82 4.06 2.1 5.52A6.98 6.98 0 0 1 1.64 14.3V.87H0v13.47a8.63 8.63 0 0 0 13.97 6.7 8.78 8.78 0 0 0 5.34 1.83 8.52 8.52 0 0 0 8.54-8.53V.87H26.2v13.47h.04zm6.53 8.08h1.64V.82h-1.64v21.64-.04zm15.98-22A9.45 9.45 0 0 0 41 4.51V.82h-1.65v21.64H41V9.82a7.76 7.76 0 0 1 7.76-7.77V.41zm3.1 17.34a9.59 9.59 0 0 1 .55-12.92 9.68 9.68 0 0 1 13.01-.55L51.86 17.85v-.1zM67.75 4.29a11.32 11.32 0 0 0-16.48-.6 11.19 11.19 0 0 0 0 15.85 11.32 11.32 0 0 0 15.98 0l-1.19-1.14a9.68 9.68 0 0 1-13.01.55l6.76-6.71 7.94-7.9v-.05zm2.56-2.87V1.1h-1.74v.36h.69v1.78h.36V1.42h.73-.04zM73 3.24V1.1h-.55l-.6 1.68-.63-1.68h-.55v2.14h.37V1.51l.64 1.73H72l.63-1.73v1.73H73z"></path>
  </svg>
  `,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

class LoadingBar {
  constructor({progress, message}) {
    this.loadingMessage = message;
    this.loadingPercentage = ko.pureComputed(() => `${progress()}%`);
  }
}

ko.components.register('loading-bar', {
  template: `
    <div class="text-center">
      <div class="progress-console" data-bind="text: loadingMessage"></div>
      <div class="progress-bar"><div data-bind="style: {width: loadingPercentage}"></div></div>
    </div>
`,
  viewModel: LoadingBar,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AssetHeader = class AssetHeader {
  /**
   * Construct a new asset header.
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   */
  constructor(params) {
    this.message_et = params.message;
  }
};

ko.components.register('asset-header', {
  template: `
    <span class="asset-header-name" data-bind="text: message_et.user().first_name(), css: message_et.accent_color"></span>
    <span class="asset-header-time" data-bind="text: moment(message_et.timestamp()).format('D.M H:mm')"></span>
  `,
  viewModel: z.components.AssetHeader,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.VideoAssetComponent = class VideoAssetComponent {
  /**
   * Construct a new video asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.logger = new z.util.Logger('VideoAssetComponent', z.config.LOGGER.OPTIONS);

    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();

    this.preview_subscription = undefined;

    this.video_element = $(component_info.element).find('video')[0];
    this.video_src = ko.observable();
    this.video_time = ko.observable();

    this.video_playback_error = ko.observable(false);
    this.show_bottom_controls = ko.observable(false);

    this.video_time_rest = ko.pureComputed(() => this.video_element.duration - this.video_time());

    if (this.asset.preview_resource()) {
      this._load_video_preview();
    } else {
      this.preview_subscription = this.asset.preview_resource.subscribe(this._load_video_preview.bind(this));
    }

    this.onPlayButtonClicked = this.onPlayButtonClicked.bind(this);
    this.on_pause_button_clicked = this.on_pause_button_clicked.bind(this);
    this.displaySmall = ko.observable(!!params.isQuote);
  }

  _load_video_preview() {
    this.asset.load_preview().then(blob => {
      if (blob) {
        this.video_element.setAttribute('poster', window.URL.createObjectURL(blob));
        this.video_element.style.backgroundColor = '#000';
      }
    });
  }

  on_loadedmetadata() {
    this.video_time(this.video_element.duration);
  }

  on_timeupdate() {
    this.video_time(this.video_element.currentTime);
  }

  on_error(component, jquery_event) {
    this.video_playback_error(true);
    this.logger.error('Video cannot be played', jquery_event);
  }

  onPlayButtonClicked() {
    this.displaySmall(false);
    if (this.video_src()) {
      if (this.video_element) {
        this.video_element.play();
      }
    } else {
      this.asset
        .load()
        .then(blob => {
          this.video_src(window.URL.createObjectURL(blob));
          if (this.video_element) {
            this.video_element.play();
          }
          this.show_bottom_controls(true);
        })
        .catch(error => this.logger.error('Failed to load video asset ', error));
    }
  }

  on_pause_button_clicked() {
    if (this.video_element) {
      this.video_element.pause();
    }
  }

  on_video_playing() {
    this.video_element.style.backgroundColor = '#000';
  }

  dispose() {
    if (this.preview_subscription) {
      this.preview_subscription.dispose();
    }
    window.URL.revokeObjectURL(this.video_src());
  }
};

ko.components.register('video-asset', {
  template: `
    <!-- ko ifnot: message.isObfuscated() -->
      <div class="video-asset-container"
        data-bind="hide_controls: 2000,
                   attr: {'data-uie-value': asset.file_name},
                   css: {'video-asset-container--small': displaySmall()}"
        data-uie-name="video-asset">
        <video playsinline
               data-bind="attr: {src: video_src},
                          css: {hidden: asset.status() === z.assets.AssetTransferState.UPLOADING},
                          event: {loadedmetadata: on_loadedmetadata,
                                  timeupdate: on_timeupdate,
                                  error: on_error,
                                  playing: on_video_playing}">
        </video>
        <!-- ko if: video_playback_error -->
          <div class="video-playback-error label-xs" data-bind="l10n_text: z.string.conversationPlaybackError"></div>
        <!-- /ko -->
        <!-- ko ifnot: video_playback_error -->
          <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="asset-placeholder">
              <div class="three-dots">
                <span></span><span></span><span></span>
              </div>
            </div>
          <!-- /ko -->

          <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="video-controls-center">
              <!-- ko if: displaySmall() -->
                <media-button params="src: video_element,
                                      large: false,
                                      asset: asset,
                                      play: onPlayButtonClicked">
                </media-button>
              <!-- /ko -->
              <!-- ko ifnot: displaySmall() -->
                <media-button params="src: video_element,
                                      large: true,
                                      asset: asset,
                                      play: onPlayButtonClicked,
                                      pause: on_pause_button_clicked,
                                      cancel: () => asset.cancel(message)">
                </media-button>
              <!-- /ko -->
            </div>
            <div class='video-controls-bottom' data-bind='visible: show_bottom_controls()'>
              <seek-bar data-ui-name="status-video-seekbar" class="video-controls-seekbar" params="src: video_element"></seek-bar>
              <span class="video-controls-time label-xs" data-bind="text: z.util.TimeUtil.formatSeconds(video_time_rest())" data-uie-name="status-video-time"></span>
            </div>
          <!-- /ko -->
        <!-- /ko -->
      </div>
      <div class="video-asset-container__sizer"></div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.VideoAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AudioAssetComponent = class AudioAssetComponent {
  /**
   * Construct a new link preview asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.logger = new z.util.Logger('AudioAssetComponent', z.config.LOGGER.OPTIONS);

    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();
    this.header = params.header || false;

    this.audio_src = ko.observable();
    this.audio_element = $(component_info.element).find('audio')[0];
    this.audio_time = ko.observable(0);
    this.audio_is_loaded = ko.observable(false);

    this.show_loudness_preview = ko.pureComputed(() => {
      if (this.asset.meta && this.asset.meta.loudness) {
        return this.asset.meta.loudness.length > 0;
      }
    });

    if (this.asset.meta) {
      this.audio_time(this.asset.meta.duration);
    }

    $(component_info.element).attr({
      'data-uie-name': 'audio-asset',
      'data-uie-value': this.asset.file_name,
    });

    this.on_play_button_clicked = this.on_play_button_clicked.bind(this);
    this.on_pause_button_clicked = this.on_pause_button_clicked.bind(this);
  }

  on_timeupdate() {
    this.audio_time(this.audio_element.currentTime);
  }

  on_play_button_clicked() {
    Promise.resolve()
      .then(() => {
        if (!this.audio_src()) {
          return this.asset.load().then(blob => this.audio_src(window.URL.createObjectURL(blob)));
        }
      })
      .then(() => this.audio_element.play())
      .catch(error => this.logger.error('Failed to load audio asset ', error));
  }

  on_pause_button_clicked() {
    if (this.audio_element) {
      this.audio_element.pause();
    }
  }

  dispose() {
    window.URL.revokeObjectURL(this.audio_src());
  }
};

ko.components.register('audio-asset', {
  template: `
    <audio data-bind="attr: {src: audio_src}, event: {timeupdate: on_timeupdate}"></audio>
    <!-- ko ifnot: message.isObfuscated() -->
      <!-- ko if: header -->
        <asset-header params="message: message"></asset-header>
      <!-- /ko -->
      <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
        <div class="asset-placeholder">
          <div class="three-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      <!-- /ko -->
      <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
        <div class="audio-controls">
          <media-button params="src: audio_element,
                                asset: asset,
                                play: on_play_button_clicked,
                                pause: on_pause_button_clicked,
                                cancel: function() {asset.cancel(message)}">
          </media-button>
          <!-- ko if: asset.status() !== z.assets.AssetTransferState.UPLOADING -->
            <span class="audio-controls-time label-xs"
                  data-uie-name="status-audio-time"
                  data-bind="text: z.util.TimeUtil.formatSeconds(audio_time())">
            </span>
            <!-- ko if: show_loudness_preview -->
              <audio-seek-bar data-uie-name="status-audio-seekbar"
                              params="src: audio_element, asset: asset, disabled: !audio_src()"></audio-seek-bar>
            <!-- /ko -->
            <!-- ko ifnot: show_loudness_preview -->
              <seek-bar data-uie-name="status-audio-seekbar"
                        params="src: audio_element, dark: true, disabled: !audio_src()"></seek-bar>
            <!-- /ko -->
          <!-- /ko -->
        </div>
      <!-- /ko -->
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.AudioAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.FileAssetComponent = class FileAssetComponent {
  /**
   * Construct a new file asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   */
  constructor(params) {
    this.message = ko.unwrap(params.message);
    this.asset = this.message.get_first_asset();
    this.header = params.header || false;

    this.circle_upload_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.upload_progress() * 2} ${size}`;
    });

    this.circle_download_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.downloadProgress() * 2} ${size}`;
    });

    this.file_extension = ko.pureComputed(() => {
      const ext = z.util.getFileExtension(this.asset.file_name);
      return ext.length <= 3 ? ext : '';
    });
  }
};

ko.components.register('file-asset', {
  template: `\
    <!-- ko ifnot: message.isObfuscated() -->
      <!-- ko if: header -->
        <asset-header params="message: message"></asset-header>
      <!-- /ko -->
      <div class="file"
         data-uie-name="file"
         data-bind="attr: {'data-uie-value': asset.file_name},
                    click: asset.status() === z.assets.AssetTransferState.UPLOADED ? asset.download : null,
                    css: {'cursor-pointer': asset.status() === z.assets.AssetTransferState.UPLOADED}">
        <!-- ko if: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
          <div class="asset-placeholder">
            <div class="three-dots">
              <span></span><span></span><span></span>
            </div>
          </div>
        <!-- /ko -->
        <!-- ko ifnot: !asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADED -->
            <div class="file-icon icon-file" data-bind="click: asset.download, clickBubble: false" data-uie-name="file-icon">
              <span class="file-icon-ext icon-view"></span>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
            <div class="media-button icon-close" data-bind="click: asset.cancel_download, clickBubble: false">
              <div class='media-button-border-file-fill'></div>
              <div class='media-button-border-fill'></div>
              <svg class="svg-theme" viewBox="0 0 32 32">
                <circle data-bind="style: {'stroke-dasharray': circle_download_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
              </svg>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADING -->
            <div class="media-button icon-close" data-bind="click: function() {asset.cancel(message)}, clickBubble: false">
              <div class='media-button-border-file-fill'></div>
              <div class='media-button-border-fill'></div>
              <svg class="svg-theme" viewBox="0 0 32 32">
                <circle data-bind="style: {'stroke-dasharray': circle_upload_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
              </svg>
            </div>
          <!-- /ko -->
          <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOAD_FAILED -->
            <div class="media-button media-button-error"></div>
          <!-- /ko -->
          <div class="file-desc">
            <div data-uie-name="file-name"
                 data-bind="text: z.util.trimFileExtension(asset.file_name)"
                 class="label-bold-xs ellipsis"></div>
            <ul class="file-desc-meta label-xs text-graphite">
              <li data-bind="text: z.util.formatBytes(asset.file_size)" data-uie-name="file-size"></li>
              <!-- ko if: z.util.getFileExtension(asset.file_name) -->
                <li data-bind="text: z.util.getFileExtension(asset.file_name)" data-uie-name="file-type"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADING -->
                <li data-bind="l10n_text: z.string.conversationAssetUploading" data-uie-name="file-status"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOAD_FAILED -->
                <li data-bind="l10n_text: z.string.conversationAssetUploadFailed" class="text-red"  data-uie-name="file-status"></li>
              <!-- /ko -->
              <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
                <li data-bind="l10n_text: z.string.conversationAssetDownloading" data-uie-name="file-status"></li>
              <!-- /ko -->
            </ul>
          </div>
        <!-- /ko -->
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.FileAssetComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.LinkPreviewAssetComponent = class LinkPreviewAssetComponent {
  /**
   * Construct a new link preview asset.
   *
   * @param {Object} params - Component parameters
   * @param {z.entity.Message} params.message - Message entity
   * @param {Object} componentInfo - Component information
   */
  constructor(params, componentInfo) {
    this.dispose = this.dispose.bind(this);
    this.onClick = this.onClick.bind(this);

    this.messageEntity = ko.unwrap(params.message);
    this.header = params.header || false;

    const [firstPreview] = this.messageEntity.get_first_asset().previews();
    this.preview = firstPreview;
    this.element = componentInfo.element;

    const isTypeTweet = this.preview && this.preview.meta_data_type === z.links.LinkPreviewMetaDataType.TWEET;
    this.isTweet = isTypeTweet && z.util.ValidationUtil.urls.isTweet(this.preview.url);
    this.author = this.isTweet ? this.preview.meta_data.author.substring(0, 20) : '';

    if (!this.messageEntity.is_expired()) {
      this.element.addEventListener('click', this.onClick);
    }
  }

  onClick() {
    if (!this.messageEntity.is_expired()) {
      z.util.SanitizationUtil.safeWindowOpen(this.preview.url);
    }
  }

  dispose() {
    this.element.removeEventListener('click', this.onClick);
  }
};

ko.components.register('link-preview-asset', {
  template: `
    <!-- ko ifnot: messageEntity.isObfuscated() -->
      <div class="link-preview-image-container">
        <!-- ko if: !preview || !preview.image_resource() -->
          <div class="link-preview-image-placeholder icon-link"></div>
        <!-- /ko -->
        <!-- ko if: preview.image_resource() -->
          <image-component class="link-preview-image" params="asset: preview.image_resource" data-uie-name="link-preview-image"></image-component>
        <!-- /ko -->
      </div>

      <div class="link-preview-info">
        <!-- ko if: header -->
          <asset-header class="link-preview-info-header" params="message: messageEntity"></asset-header>
        <!-- /ko -->
        <!-- ko if: preview -->
          <!-- ko if: isTweet -->
            <div class="link-preview-info-title" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'" data-uie-name="link-preview-title"></div>
            <div class="link-preview-info-link text-graphite" data-bind="attr: {title: preview.url}" data-uie-name="link-preview-tweet-author">
              <span class="font-weight-bold link-preview-info-title-singleline" data-bind="text: author"></span>
              <span data-bind="l10n_text: z.string.conversationTweetAuthor"></span>
            </div>
          <!-- /ko -->
          <!-- ko ifnot: isTweet -->
            <div class="link-preview-info-title" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'" data-uie-name="link-preview-title"></div>
            <div class="link-preview-info-link text-graphite ellipsis" data-bind="text: z.util.URLUtil.getDomainName(preview.url), attr: {title: preview.url}" data-uie-name="link-preview-url"></div>
          <!-- /ko -->
        <!-- /ko -->
      </div>
    <!-- /ko -->

    <!-- ko if: messageEntity.isObfuscated() -->
      <div class="link-preview-image-container">
        <div class="link-preview-image-placeholder icon-link bg-color-ephemeral text-white"></div>
      </div>
      <div class="link-preview-info">
        <div class="link-preview-info-title ephemeral-message-obfuscated" data-bind="text: preview.title, css: header ? 'link-preview-info-title-singleline' : 'link-preview-info-title-multiline'"></div>
        <div class="link-preview-info-link ephemeral-message-obfuscated ellipsis" data-bind="text: preview.url"></div>
      </div>
    <!-- /ko -->
  `,
  viewModel: {
    createViewModel(params, componentInfo) {
      return new z.components.LinkPreviewAssetComponent(params, componentInfo);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.LocationAssetComponent = class LocationAssetComponent {
  /**
   * Construct a new audio asset.
   * @param {Object} params - Component parameters
   * @param {z.entity.Location} params.asset - Location asset
   */
  constructor(params) {
    this.asset = params.asset;
    this.locationRepository = params.locationRepository;
  }

  getMapsUrl(assetEntity) {
    const {latitude, longitude, name, zoom} = assetEntity;
    return this.locationRepository.getMapsUrl(latitude, longitude, name, zoom);
  }
};

ko.components.register('location-asset', {
  template: `
    <div class="location-asset-icon icon-location"></div>
    <div class="location-asset-title" data-bind="text: asset.name" data-uie-name="location-name"></div>
    <a target="_blank" rel="nofollow noopener noreferrer" class="label-xs text-theme" data-bind="attr: {href: getMapsUrl(asset)}, l10n_text: z.string.conversationLocationLink"></a>
  `,
  viewModel: z.components.LocationAssetComponent,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.AudioSeekBarComponent = class AudioSeekBarComponent {
  /**
   * Construct a audio seek bar that renders audio levels.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {z.entity.File} params.asset - Asset file
   * @param {boolean} params.disabled - Disabled seek bar
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.audio_element = params.src;
    this.asset = params.asset;

    this.element = component_info.element;
    this.loudness = [];

    this.disabled = ko.computed(() => {
      if (typeof params.disabled === 'function') {
        $(this.element).toggleClass('element-disabled', params.disabled());
      }
    });

    if (this.asset.meta !== null && this.asset.meta.loudness !== null) {
      this.loudness = this._normalize_loudness(this.asset.meta.loudness, component_info.element.clientHeight);
    }

    this._on_resize_fired = _.debounce(() => {
      this._render_levels();
      this._on_time_update();
    }, 500);

    this._render_levels();

    this._on_level_click = this._on_level_click.bind(this);
    this._on_time_update = this._on_time_update.bind(this);
    this._on_audio_ended = this._on_audio_ended.bind(this);
    this.audio_element.addEventListener('ended', this._on_audio_ended);
    this.audio_element.addEventListener('timeupdate', this._on_time_update);
    component_info.element.addEventListener('click', this._on_level_click);
    window.addEventListener('resize', this._on_resize_fired);
  }

  _render_levels() {
    const number_of_levels_fit_on_screen = Math.floor(this.element.clientWidth / 3); // 2px + 1px
    const scaled_loudness = z.util.ArrayUtil.interpolate(this.loudness, number_of_levels_fit_on_screen);

    // eslint-disable-next-line no-unsanitized/property
    this.element.innerHTML = scaled_loudness.map(level => `<span style="height: ${level}px"></span>`).join('');
  }

  _normalize_loudness(loudness, max) {
    const peak = Math.max(...loudness);
    const scale = max / peak;
    return peak > max ? loudness.map(level => level * scale) : loudness;
  }

  _on_level_click(event) {
    const mouse_x = event.pageX - $(event.currentTarget).offset().left;
    const calculatedTime = (this.audio_element.duration * mouse_x) / event.currentTarget.clientWidth;
    const currentTime = window.isNaN(calculatedTime) ? 0 : calculatedTime;

    this.audio_element.currentTime = z.util.NumberUtil.clamp(currentTime, 0, this.audio_element.duration);
    this._on_time_update();
  }

  _on_time_update() {
    const $levels = this._clear_theme();
    const index = Math.floor((this.audio_element.currentTime / this.audio_element.duration) * $levels.length);
    this._add_theme(index);
  }

  _on_audio_ended() {
    this._clear_theme();
  }

  _clear_theme() {
    return $(this.element)
      .children()
      .removeClass('bg-theme');
  }

  _add_theme(index) {
    $(this.element)
      .children()
      .eq(index)
      .prevAll()
      .addClass('bg-theme');
  }

  dispose() {
    this.disabled.dispose();
    this.audio_element.removeEventListener('ended', this._on_audio_ended);
    this.audio_element.removeEventListener('timeupdate', this._on_time_update);
    this.element.removeEventListener('click', this._on_level_click);
    window.removeEventListener('resize', this._on_resize_fired);
  }
};

ko.components.register('audio-seek-bar', {
  template: '<!-- content is generated -->',
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.AudioSeekBarComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.SeekBarComponent = class SeekBarComponent {
  /**
   * Construct a seek bar.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.media_element = params.src;
    this.dark_mode = params.dark;
    this.disabled = ko.pureComputed(() => {
      if (typeof params.disabled === 'function') {
        params.disabled();
      }
    });

    this.seek_bar = $(component_info.element).find('input')[0];
    this.seek_bar_mouse_over = ko.observable(false);
    this.seek_bar_thumb_dragged = ko.observable(false);
    this.show_seek_bar_thumb = ko.pureComputed(() => this.seek_bar_thumb_dragged() || this.seek_bar_mouse_over());

    this.on_mouse_down = this.on_mouse_down.bind(this);
    this.on_mouse_up = this.on_mouse_up.bind(this);
    this.on_mouse_enter = this.on_mouse_enter.bind(this);
    this.on_mouse_leave = this.on_mouse_leave.bind(this);
    this.on_change = this.on_change.bind(this);
    this.on_timeupdate = this.on_timeupdate.bind(this);
    this.on_ended = this.on_ended.bind(this);
    this.seek_bar.addEventListener('mousedown', this.on_mouse_down);
    this.seek_bar.addEventListener('mouseup', this.on_mouse_up);
    this.seek_bar.addEventListener('mouseenter', this.on_mouse_enter);
    this.seek_bar.addEventListener('mouseleave', this.on_mouse_leave);
    this.seek_bar.addEventListener('change', this.on_change);
    this.media_element.addEventListener('timeupdate', this.on_timeupdate);
    this.media_element.addEventListener('ended', this.on_ended);
    this._update_seek_bar_style(0);
  }

  on_mouse_down() {
    this.media_element.pause();
    this.seek_bar_thumb_dragged(true);
  }

  on_mouse_up() {
    this.media_element.play();
    this.seek_bar_thumb_dragged(false);
  }

  on_mouse_enter() {
    this.seek_bar_mouse_over(true);
  }

  on_mouse_leave() {
    this.seek_bar_mouse_over(false);
  }

  on_change() {
    const currentTime = this.media_element.duration * (this.seek_bar.value / 100);
    this.media_element.currentTime = z.util.NumberUtil.clamp(currentTime, 0, this.media_element.duration);
  }

  on_timeupdate() {
    const value = (100 / this.media_element.duration) * this.media_element.currentTime;
    this._update_seek_bar(value);
  }

  on_ended() {
    this._update_seek_bar(100);
  }

  _update_seek_bar(progress) {
    if (this.media_element.paused && progress < 100) {
      return;
    }

    this.seek_bar.value = progress;
    this._update_seek_bar_style(progress);
  }

  _update_seek_bar_style(progress) {
    // TODO check if we can find a css solution
    const color = this.dark_mode ? 'rgba(141,152,159,0.24)' : 'rgba(255,255,255,0.4)';
    this.seek_bar.style.backgroundImage = `linear-gradient(to right, currentColor ${progress}%, ${color} ${progress}%)`;
  }

  dispose() {
    this.seek_bar.removeEventListener('mousedown', this.on_mouse_down);
    this.seek_bar.removeEventListener('mouseup', this.on_mouse_up);
    this.seek_bar.removeEventListener('mouseenter', this.on_mouse_enter);
    this.seek_bar.removeEventListener('mouseleave', this.on_mouse_leave);
    this.seek_bar.removeEventListener('change', this.on_change);
    this.media_element.removeEventListener('timeupdate', this.on_timeupdate);
    this.media_element.removeEventListener('ended', this.on_ended);
  }
};

ko.components.register('seek-bar', {
  template: `
    <input type="range" value="0" max="100" data-bind="css: {'show-seek-bar-thumb': show_seek_bar_thumb, 'element-disabled': disabled}">
  `,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.SeekBarComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.MediaButtonComponent = class MediaButtonComponent {
  /**
   * Construct a media button.
   *
   * @param {Object} params - Component parameters
   * @param {HTMLElement} params.media_src - Media source
   * @param {boolean} params.large - Display large button
   * @param {z.entity.File} params.asset - Asset file
   * @param {Object} component_info - Component information
   */
  constructor(params, component_info) {
    this.dispose = this.dispose.bind(this);
    this.media_element = params.src;
    this.large = params.large;
    this.asset = params.asset;

    if (this.large) {
      component_info.element.classList.add('media-button-lg');
    }

    this.media_is_playing = ko.observable(false);

    this.svg_view_box = ko.pureComputed(() => {
      const size = this.large ? 64 : 32;
      return `0 0 ${size} ${size}`;
    });

    this.circle_upload_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.upload_progress() * 2} ${size}`;
    });

    this.circle_download_progress = ko.pureComputed(() => {
      const size = this.large ? '200' : '100';
      return `${this.asset.downloadProgress() * 2} ${size}`;
    });

    this.on_play_button_clicked = function() {
      if (typeof params.play === 'function') {
        params.play();
      }
    };
    this.on_pause_button_clicked = function() {
      if (typeof params.pause === 'function') {
        params.pause();
      }
    };
    this.on_cancel_button_clicked = function() {
      if (typeof params.cancel === 'function') {
        params.cancel();
      }
    };

    this.on_play = this.on_play.bind(this);
    this.on_pause = this.on_pause.bind(this);
    this.media_element.addEventListener('playing', this.on_play);
    this.media_element.addEventListener('pause', this.on_pause);
  }

  on_play() {
    this.media_is_playing(true);
  }

  on_pause() {
    this.media_is_playing(false);
  }

  dispose() {
    this.media_element.removeEventListener('playing', this.on_play);
    this.media_element.removeEventListener('pause', this.on_pause);
  }
};

ko.components.register('media-button', {
  template: `
    <!-- ko if: asset.status() === z.assets.AssetTransferState.UPLOADED -->
      <div class='media-button media-button-play icon-play' data-bind="click: on_play_button_clicked, visible: !media_is_playing()" data-uie-name="do-play-media"></div>
      <div class='media-button media-button-pause icon-pause' data-bind="click: on_pause_button_clicked, visible: media_is_playing()" data-uie-name="do-pause-media"></div>
    <!-- /ko -->
    <!-- ko if: asset.status() === z.assets.AssetTransferState.DOWNLOADING -->
      <div class="media-button icon-close" data-bind="click: asset.cancel_download" data-uie-name="status-loading-media">
        <div class='media-button-border-fill'></div>
        <svg class="svg-theme" data-bind="attr: {viewBox: svg_view_box}">
          <circle data-bind="style: {'stroke-dasharray': circle_download_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
        </svg>
      </div>
    <!-- /ko -->
    <!-- ko if: asset.uploaded_on_this_client() && asset.status() === z.assets.AssetTransferState.UPLOADING -->
      <div class="media-button icon-close" data-bind="click: on_cancel_button_clicked" data-uie-name="do-cancel-media">
        <div class='media-button-border-fill'></div>
        <svg class="svg-theme" data-bind="attr: {viewBox: svg_view_box}">
          <circle data-bind="style: {'stroke-dasharray': circle_upload_progress}" class="stroke-theme" r="50%" cx="50%" cy="50%"></circle>
        </svg>
      </div>
    <!-- /ko -->
`,
  viewModel: {
    createViewModel(params, component_info) {
      return new z.components.MediaButtonComponent(params, component_info);
    },
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ChooseScreen = class ChooseScreen {
  constructor(params) {
    this.on_cancel = params.cancel;
    this.on_choose = params.choose;
    this.screens = params.screens || [];
  }
};

ko.components.register('choose-screen', {
  template: `
    <div class="choose-screen-list" data-bind="foreach: screens">
      <div  class="choose-screen-list-item" data-bind="click: $parent.on_choose">
        <image class="choose-screen-list-image" data-bind="attr: {src: $data.thumbnail.toDataURL()}">
      </div>
    </div>
    <div class="label-xs text-white" data-bind="l10n_text: z.string.callChooseSharedScreen"></div>
    <div id="choose-screen-controls" class="choose-screen-controls">
      <div class="choose-screen-controls-button button-round button-round-dark button-round-md icon-close"
           data-uie-name="do-choose-screen-cancel"
           data-bind="click: on_cancel"></div>
    </div>
  `,
  viewModel: z.components.ChooseScreen,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.DeviceToggleButton = class DeviceToggleButton {
  constructor(params) {
    this.availableDevices = params.devices;
    this.currentDeviceIndex = params.index;
    this.numberOfDevices = ko.pureComputed(() => {
      return _.isArray(this.availableDevices()) ? this.availableDevices().length : 0;
    });
  }
};

ko.components.register('device-toggle-button', {
  template: `
    <div class="device-toggle-button-indicator" data-bind="foreach: ko.utils.range(0, numberOfDevices() - 1)">
      <span class="device-toggle-button-indicator-dot" data-bind="css: {'device-toggle-button-indicator-dot-active': $data == $parent.currentDeviceIndex()}"></span>
    </div>
  `,
  viewModel: z.components.DeviceToggleButton,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ConversationListCallingCell = class ConversationListCallingCell {
  constructor(params) {
    this.conversation = params.conversation;

    const callingRepository = params.callingRepository;
    const permissionRepository = params.permissionRepository;

    this.multitasking = params.multitasking;
    this.temporaryUserStyle = params.temporaryUserStyle;
    this.videoGridRepository = params.videoGridRepository;

    this.calls = callingRepository.calls;
    this.call = this.conversation.call;
    this.conversationParticipants = this.conversation.participating_user_ets;
    this.joinedCall = callingRepository.joinedCall;
    this.selfStreamState = callingRepository.selfStreamState;
    this.selfUser = this.conversation.selfUser();

    this.isConnected = this.call().isConnected;

    this.isConnecting = this.call().isConnecting;
    this.isDeclined = this.call().isDeclined;
    this.isIncoming = this.call().isIncoming;
    this.isOngoing = this.call().isOngoing;
    this.isOutgoing = this.call().isOutgoing;

    this.showParticipants = ko.observable(false);

    this.callParticipants = ko.pureComputed(() => {
      const callParticipants = this.call().participants();
      return callParticipants.slice().reverse();
    });

    this.isVideoCall = ko.pureComputed(() => this.call().isLocalVideoCall() || this.call().isRemoteVideoCall());

    this.canJoin = ko.pureComputed(() => {
      if (this.selfUser.isTemporaryGuest()) {
        const isOngoingCall = !this.call().selfUserJoined() && this.isOngoing();
        return this.call().isDeclined() || isOngoingCall;
      }
      return false;
    });
    this.showParticipantsButton = ko.pureComputed(() => this.isConnected() && this.conversation.isGroup());
    this.showVideoButton = ko.pureComputed(() => this.isVideoCall() || this.isConnected());

    this.disableVideoButton = ko.pureComputed(() => {
      const isOutgoingVideoCall = this.isOutgoing() && this.selfStreamState.videoSend();
      const isVideoUnsupported = !this.selfStreamState.videoSend() && !this.conversation.supportsVideoCall();
      return isOutgoingVideoCall || isVideoUnsupported;
    });
    this.disableScreenButton = ko.pureComputed(() => !z.calling.CallingRepository.supportsScreenSharing);

    this.participantsButtonLabel = ko.pureComputed(() => {
      return z.l10n.text(z.string.callParticipants, this.callParticipants().length);
    });

    this.showVideoPreview = ko.pureComputed(() => {
      const hasOtherOngoingCalls = this.calls().some(callEntity => {
        return callEntity.id !== this.call().id && callEntity.isOngoing();
      });

      const isInMinimizedState = this.multitasking.isMinimized() || !this.isConnected();
      const hasPreJoinVideo = !this.isConnected() && this.call().selfState.videoSend();
      const isOngoingVideoCall = this.isConnected() && this.isVideoCall() && !this.isDeclined();

      return !hasOtherOngoingCalls && isInMinimizedState && (hasPreJoinVideo || isOngoingVideoCall);
    });

    this.showNoCameraPreview = ko.computed(() => {
      const isNotGranted = permissionRepository.permissionState.camera() !== z.notification.PermissionState.GRANTED;
      return this.call().isRemoteVideoCall() && !this.showVideoPreview() && !this.isConnected() && isNotGranted;
    });

    this.showMaximize = ko.pureComputed(() => this.multitasking.isMinimized() && this.isConnected());

    this.shouldUpdateScrollbar = ko
      .pureComputed(() => this.callParticipants() && this.showParticipants())
      .extend({notify: 'always', rateLimit: 100});
  }

  onEndCall() {
    return this.isIncoming() ? this.onRejectCall() : this.onLeaveCall();
  }

  onJoinCall() {
    const isVideoCall = this.call().isRemoteVideoSend() && this.selfStreamState.videoSend();
    const mediaType = isVideoCall ? z.media.MediaType.AUDIO_VIDEO : z.media.MediaType.AUDIO;
    amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, mediaType);
  }

  onJoinDeclinedCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, z.media.MediaType.AUDIO);
  }

  onLeaveCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.LEAVE, this.conversation.id, z.calling.enum.TERMINATION_REASON.SELF_USER);
  }

  onMaximizeVideoGrid() {
    this.multitasking.autoMinimize(false);
    this.multitasking.isMinimized(false);
  }

  onParticipantsClick() {
    this.showParticipants(!this.showParticipants());

    // TODO: this is a very hacky way to get antiscroll to recalculate the height of the conversationlist.
    // Once there is a new solution to this, this needs to go.
    z.util.afterRender(() => window.dispatchEvent(new Event('resize')));
  }

  onRejectCall() {
    amplify.publish(z.event.WebApp.CALL.STATE.REJECT, this.conversation.id);
  }

  onToggleAudio() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.conversation.id, z.media.MediaType.AUDIO);
  }

  onToggleScreen() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.CHOOSE_SCREEN, this.conversation.id);
  }

  onToggleVideo() {
    amplify.publish(z.event.WebApp.CALL.MEDIA.TOGGLE, this.conversation.id, z.media.MediaType.VIDEO);
  }
};

ko.components.register('conversation-list-calling-cell', {
  template: `
    <div class="conversation-list-calling-cell conversation-list-cell">

      <!-- ko ifnot: temporaryUserStyle -->
        <div class="conversation-list-cell-left">
          <!-- ko if: conversation.isGroup() -->
            <group-avatar class="conversation-list-cell-avatar-arrow call-ui__avatar" params="users: conversationParticipants(), conversation: conversation"></group-avatar>
          <!-- /ko -->
          <!-- ko if: !conversation.isGroup() && conversationParticipants().length -->
            <participant-avatar params="participant: conversationParticipants()[0], size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
          <!-- /ko -->
        </div>
      <!-- /ko -->

      <div class="conversation-list-cell-center" data-bind="css: {'conversation-list-cell-center-no-left': temporaryUserStyle}">
        <span class="conversation-list-cell-name" data-bind="text: conversation.display_name()"></span>
        <!-- ko if: isIncoming() -->
          <!-- ko if: call().isGroup -->
            <span class="conversation-list-cell-description" data-bind="l10n_text: {id: z.string.callStateIncomingGroup, substitute: call().creatingUser.first_name()}" data-uie-name="call-label-incoming"></span>
          <!-- /ko -->
          <!-- ko ifnot: call().isGroup -->
            <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateIncoming" data-uie-name="call-label-incoming"></span>
          <!-- /ko -->
        <!-- /ko -->
        <!-- ko if: isOutgoing() -->
          <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateOutgoing" data-uie-name="call-label-outgoing"></span>
        <!-- /ko -->
        <!-- ko if: isConnecting() -->
          <span class="conversation-list-cell-description" data-bind="l10n_text: z.string.callStateConnecting" data-uie-name="call-label-connecting"></span>
        <!-- /ko -->
        <!-- ko if: isConnected() -->
          <span class="conversation-list-cell-description" data-bind="text: z.util.TimeUtil.formatSeconds(call().durationTime())" data-uie-name="call-duration"></span>
        <!-- /ko -->
      </div>

      <div class="conversation-list-cell-right">
        <!-- ko if: isConnecting() || isConnected() -->
          <div class="call-ui__button call-ui__button--red" data-bind="click: onLeaveCall" data-uie-name="do-call-controls-call-leave">
            <hangup-icon class="small-icon"></hangup-icon>
          </div>
        <!-- /ko -->
        <!-- ko if: canJoin() -->
          <div class="call-ui__button call-ui__button--join call-ui__button--green" data-bind="click: onJoinDeclinedCall, l10n_text: z.string.callJoin" data-uie-name="do-call-controls-call-join"></div>
        <!-- /ko -->
      </div>

    </div>

    <!-- ko if: showVideoPreview() -->
      <div class="group-video__minimized-wrapper" data-bind="click: onMaximizeVideoGrid">
        <group-video-grid params="minimized: true, videoGridRepository: videoGridRepository"></group-video-grid>
        <!-- ko if: showMaximize() -->
          <div class="group-video__minimized-wrapper__overlay" data-uie-name="do-maximize-call">
            <fullscreen-icon></fullscreen-icon>
          </div>
        <!-- /ko -->
      </div>
    <!-- /ko -->
    <!-- ko if: showNoCameraPreview() -->
      <div class="group-video__minimized-wrapper group-video__minimized-wrapper--no-camera-access" data-bind="l10n_text: z.string.callNoCameraAccess" data-uie-name="label-no-camera-access-preview"></div>
    <!-- /ko -->

    <!-- ko ifnot: canJoin() -->
      <div class="conversation-list-calling-cell-controls">
        <div class="conversation-list-calling-cell-controls-left">
          <div class="call-ui__button" data-bind="click: onToggleAudio, css: {'call-ui__button--active': !selfStreamState.audioSend()}, attr: {'data-uie-value': selfStreamState.audioSend() ? 'inactive' : 'active'}" data-uie-name="do-toggle-mute">
            <micoff-icon class="small-icon"></micoff-icon>
          </div>
          <!-- ko if: showVideoButton() -->
            <div class="call-ui__button" data-bind="click: onToggleVideo, css: {'call-ui__button--active': selfStreamState.videoSend(), 'call-ui__button--disabled': disableVideoButton()}, attr: {'data-uie-value': selfStreamState.videoSend() ? 'active' : 'inactive'}" data-uie-name="do-toggle-video">
              <camera-icon class="small-icon"></camera-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isConnected() -->
            <div class="call-ui__button" data-bind="tooltip: {text: z.string.videoCallScreenShareNotSupported, disabled: !disableScreenButton(), position: 'bottom'}, click: onToggleScreen, css: {'call-ui__button--active': selfStreamState.screenSend(), 'call-ui__button--disabled': disableScreenButton()}, attr: {'data-uie-value': selfStreamState.screenSend() ? 'active' : 'inactive', 'data-uie-enabled': disableScreenButton() ? 'false' : 'true'}" data-uie-name="do-call-controls-toggle-screenshare">
              <screenshare-icon class="small-icon"></screenshare-icon>
            </div>
          <!-- /ko -->
        </div>

        <div class="conversation-list-calling-cell-controls-right">
          <!-- ko if: showParticipantsButton() -->
            <div class="call-ui__button call-ui__button--participants" data-bind="click: onParticipantsClick, css: {'call-ui__button--active': showParticipants()}" data-uie-name="do-toggle-participants">
              <span data-bind="text: participantsButtonLabel"></span><chevron-icon></chevron-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isIncoming() || isOutgoing() -->
            <div class="call-ui__button call-ui__button--red call-ui__button--large" data-bind="click: onEndCall" data-uie-name="do-call-controls-call-decline">
              <hangup-icon class="small-icon"></hangup-icon>
            </div>
          <!-- /ko -->
          <!-- ko if: isIncoming() -->
            <div class="call-ui__button call-ui__button--green call-ui__button--large" data-bind="click: onJoinCall" data-uie-name="do-call-controls-call-accept">
              <pickup-icon class="small-icon"></pickup-icon>
            </div>
          <!-- /ko -->
        </div>

      </div>
      <div class="call-ui__participant-list__wrapper" data-bind="css: {'call-ui__participant-list__wrapper--active': showParticipants}">
        <div class="call-ui__participant-list" data-bind="foreach: callParticipants, antiscroll: shouldUpdateScrollbar" data-uie-name="list-call-ui-participants">
          <participant-item params="participant: $data.user, hideInfo: true, showCamera: $data.activeState.videoSend()" data-bind="css: {'no-underline': true}"></participant-item>
        </div>
      </div>
    <!-- /ko -->
 `,
  viewModel: z.components.ConversationListCallingCell,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.ConversationListCell = class ConversationListCell {
  constructor({conversation, is_selected = z.util.noop, click = z.util.noop}) {
    this.conversation = conversation;
    this.is_selected = is_selected;
    this.on_click = click;

    this.users = ko.pureComputed(() => this.conversation.participating_user_ets());

    this.cell_state = ko.observable('');
    this.cell_state_observable = ko
      .computed(() => this.cell_state(z.conversation.ConversationCellState.generate(this.conversation)))
      .extend({rateLimit: 500});

    this.showJoinButton = this.conversation.hasJoinableCall;

    this.onJoinCall = () => {
      amplify.publish(z.event.WebApp.CALL.STATE.JOIN, this.conversation.id, z.media.MediaType.AUDIO);
    };
  }

  destroy() {
    this.cell_state_observable.dispose();
  }
};

ko.components.register('conversation-list-cell', {
  template: `
    <div class="conversation-list-cell" data-bind="attr: {'data-uie-uid': conversation.id, 'data-uie-value': conversation.display_name}, css: {'conversation-list-cell-active': is_selected(conversation)}">
      <div class="conversation-list-cell-left" data-bind="css: {'conversation-list-cell-left-opaque': conversation.removed_from_conversation() || conversation.participating_user_ids().length === 0}">
        <!-- ko if: conversation.isGroup() -->
          <group-avatar class="conversation-list-cell-avatar-arrow" params="users: users(), conversation: conversation"></group-avatar>
        <!-- /ko -->
        <!-- ko if: !conversation.isGroup() && users().length -->
          <div class="avatar-halo">
            <participant-avatar params="participant: users()[0], size: z.components.ParticipantAvatar.SIZE.SMALL"></participant-avatar>
          </div>
        <!-- /ko -->
      </div>
      <div class="conversation-list-cell-center">
        <!-- ko if: conversation.is1to1() && conversation.selfUser().inTeam() -->
          <availability-state class="conversation-list-cell-availability"
                              data-uie-name="status-availability-item"
                              params="availability: conversation.availabilityOfUser, label: conversation.display_name(), theme: is_selected(conversation)">
          </availability-state>
        <!-- /ko -->
        <!-- ko ifnot: conversation.is1to1() && conversation.selfUser().inTeam() -->
          <span class="conversation-list-cell-name" data-bind="text: conversation.display_name(), css: {'text-theme': is_selected(conversation)}"></span>
        <!-- /ko -->
        <span class="conversation-list-cell-description" data-bind="text: cell_state().description" data-uie-name="secondary-line"></span>
      </div>
      <div class="conversation-list-cell-right">
        <span class="conversation-list-cell-context-menu" data-bind="click: function(data, event) {on_click(conversation, event)}" data-uie-name="go-options"></span>
        <!-- ko ifnot: showJoinButton -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.PENDING_CONNECTION -->
            <span class="conversation-list-cell-badge cell-badge-dark" data-uie-name="status-pending"><pending-icon class="svg-icon"></pending-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_MENTION -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-mention"><mention-icon class="svg-icon"></mention-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_REPLY -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-reply"><reply-icon class="svg-icon"></reply-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_PING -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-ping"><ping-icon class="svg-icon"></ping-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.MISSED_CALL -->
            <span class="conversation-list-cell-badge cell-badge-light" data-uie-name="status-missed-call"><hangup-icon class="svg-icon"></hangup-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.MUTED -->
            <span class="conversation-list-cell-badge cell-badge-dark conversation-muted" data-uie-name="status-silence"><mute-icon class="svg-icon"></mute-icon></span>
          <!-- /ko -->
          <!-- ko if: cell_state().icon === z.conversation.ConversationStatusIcon.UNREAD_MESSAGES && conversation.unreadState().allMessages.length > 0 -->
            <span class="conversation-list-cell-badge cell-badge-light" data-bind="text: conversation.unreadState().allMessages.length" data-uie-name="status-unread"></span>
          <!-- /ko -->
        <!-- /ko -->
        <!-- ko if: showJoinButton -->
          <div class="call-ui__button call-ui__button--green call-ui__button--join" data-bind="click: onJoinCall, l10n_text: z.string.callJoin" data-uie-name="do-call-controls-call-join"></div>
        <!-- /ko -->
      </div>
    </div>
  `,
  viewModel: z.components.ConversationListCell,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.components = z.components || {};

z.components.GroupAvatar = class GroupAvatar {
  constructor({users}) {
    this.users = ko.pureComputed(() => users().slice(0, 4));
  }
};

ko.components.register('group-avatar', {
  template: `
    <div class="group-avatar-box-wrapper" data-bind="foreach: users">
      <div class="group-avatar-box" data-bind="text: Array.from($data.initials())[0], style: {color: $data.accent_color()}"></div>
    </div>
  `,
  viewModel: z.components.GroupAvatar,
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('panel-user-details', {
  template: `
    <div class="panel-participant">

      <!-- ko if: isVerified() -->
        <verified-icon class="panel-participant__verified-icon" data-uie-name="status-verified-participant"></verified-icon>
      <!-- /ko -->

      <div class="panel-participant__name" data-bind="text: participant().name()" data-uie-name="status-name"></div>


      <!-- ko if: participant().username() -->
        <div class="panel-participant__user-name" data-bind="text: participant().username()" data-uie-name="status-username"></div>
      <!-- /ko -->

      <participant-avatar params="participant: participant, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>
      
      <!-- ko if: participant().isGuest() -->
        <div class="panel-participant__guest-label" data-uie-name="status-guest">
          <guest-icon></guest-icon>
          <span data-bind="l10n_text: z.string.conversationGuestIndicator"></span>
        </div>
      <!-- /ko -->
          
      <!-- ko if: participant().isTemporaryGuest () -->
        <div class="panel-participant__guest-expiration" data-bind="text: participant().expirationText" data-uie-name="status-expiration-text"></div>
      <!-- /ko -->
      
      <!-- ko if: participant().inTeam() -->
        <availability-state
          class="panel-participant__availability"
          data-uie-name="status-availability"
          params="availability: participant().availability(), label: availabilityLabel()">
        </availability-state>
      <!-- /ko -->
    </div>
  `,
  viewModel: class {
    constructor(params) {
      this.participant = params.participant;
      this.isVerified = params.hasOwnProperty('isVerified') ? params.isVerified : this.participant().is_verified;
      this.availabilityLabel = ko.pureComputed(() => {
        const availabilitySetToNone = this.participant().availability() === z.user.AvailabilityType.NONE;
        if (!availabilitySetToNone) {
          return z.user.AvailabilityMapper.nameFromType(this.participant().availability());
        }
      });
    }
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

ko.components.register('panel-service-details', {
  template: `
    <div class="panel-participant">
      <div class="panel-participant__name" data-bind="text: service().name" data-uie-name="status-service-name"></div>
      <div class="panel-participant__provider-name" data-bind="text: service().providerName()" data-uie-name="status-service-provider"></div>
      <participant-avatar params="participant: service, size: z.components.ParticipantAvatar.SIZE.X_LARGE" data-uie-name="status-profile-picture"></participant-avatar>    
      <div class="panel-participant__service-description" data-bind="text: service().description" data-uie-name="status-service-description"></div>
    </div>
  `,
  viewModel: class {
    constructor(params) {
      this.service = params.service;
    }
  },
});

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different call message types.
 * @returns {z.message.CALL_MESSAGE_TYPE} Enum of call message types
 */
z.message.CALL_MESSAGE_TYPE = {
  ACTIVATED: 'activated',
  DEACTIVATED: 'deactivated',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different message categories.
 * @returns {z.message.MessageCategory} Enum of message categories
 */
z.message.MessageCategory = {
  AUDIO: 1 << 10,
  EXCLUDED: 1 << 1,
  FILE: 1 << 9,
  GIF: 1 << 8,
  IMAGE: 1 << 7,
  KNOCK: 1 << 2,
  LIKED: 1 << 13,
  LINK: 1 << 5,
  LINK_PREVIEW: 1 << 6,
  LOCATION: 1 << 12,
  NONE: 0,
  SYSTEM: 1 << 3,
  TEXT: 1 << 4,
  UNDEFINED: 1 << 0,
  VIDEO: 1 << 11,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MessageCategorization = (() => {
  const _checkAsset = event => {
    const {data: eventData, type: eventType} = event;

    const isAssetAdd = eventType === z.event.Client.CONVERSATION.ASSET_ADD;
    if (isAssetAdd) {
      const isTagUndefined = eventData.info.tag === undefined;
      if (isTagUndefined) {
        return z.message.MessageCategory.FILE;
      }

      let category = z.message.MessageCategory.IMAGE;
      if (eventData.content_type === 'image/gif') {
        category = category | z.message.MessageCategory.GIF;
      }

      return category;
    }
  };

  const _checkLocation = event => {
    const isLocation = event.type === z.event.Client.CONVERSATION.LOCATION;
    if (isLocation) {
      return z.message.MessageCategory.LOCATION;
    }
  };

  const _checkPing = event => {
    const isPing = event.type === z.event.Client.CONVERSATION.KNOCK;
    if (isPing) {
      return z.message.MessageCategory.KNOCK;
    }
  };

  const _checkText = event => {
    const {data: eventData, type: eventType} = event;

    const isMessageAdd = eventType === z.event.Client.CONVERSATION.MESSAGE_ADD;
    if (isMessageAdd) {
      let category = z.message.MessageCategory.TEXT;

      const isLinkPreview = eventData.previews && !!eventData.previews.length;
      if (isLinkPreview) {
        category = category | z.message.MessageCategory.LINK | z.message.MessageCategory.LINK_PREVIEW;
      }

      return category;
    }
  };

  return {
    categoryFromEvent: event => {
      try {
        const eventReactions = event.reactions;
        let category = z.message.MessageCategory.NONE;

        const categoryChecks = [_checkText, _checkAsset, _checkPing, _checkLocation];
        for (const check of categoryChecks) {
          const matchedCategory = check(event);
          if (matchedCategory) {
            category = matchedCategory;
            break;
          }
        }

        const isReaction = _.isObject(eventReactions) && !!Object.keys(eventReactions).length;
        if (isReaction) {
          category = category | z.message.MessageCategory.LIKED;
        }

        return category;
      } catch (error) {
        return z.message.MessageCategory.UNDEFINED;
      }
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

const Long = window.dcodeIO.Long;
const crypto = window.crypto;

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MessageHasher = (() => {
  /**
   * @param {number[]} bytes - The array of bytes to hash
   * @returns {Promise<ArrayBuffer>} Promise with hashed string bytes
   * @private
   */
  const createSha256Hash = bytes => {
    const buffer = new Uint8Array(bytes).buffer;
    return crypto.subtle.digest('SHA-256', buffer);
  };

  /**
   * @param {Event} event - The event
   * @returns {number[]} Array of assetId bytes
   * @private
   */
  const getAssetBytes = event => z.util.StringUtil.utf8ToUtf16BE(event.data.key);

  /**
   * @param {Event} event - The event
   * @returns {number[]} Array of longitude bytes
   * @private
   */
  const getLocationBytes = event => {
    const {longitude, latitude} = event.data.location;
    const latitudeApproximate = Math.round(latitude * 1000);
    const longitudeApproximate = Math.round(longitude * 1000);

    const latitudeLong = Long.fromInt(latitudeApproximate).toBytesBE();
    const longitudeLong = Long.fromInt(longitudeApproximate).toBytesBE();

    return latitudeLong.concat(longitudeLong);
  };

  /**
   * @param {Event} event - The event
   * @returns {number[]} the timestamp as long endian bytes
   * @private
   */
  const getTimestampBytes = event => {
    const unixTimestamp = new Date(event.time).getTime();
    const timestampSeconds = Math.floor(unixTimestamp / 1e3);
    return Long.fromInt(timestampSeconds).toBytesBE();
  };

  const getTextBytes = event => z.util.StringUtil.utf8ToUtf16BE(event.data.content);

  /**
   * Creates a hash of the given event.
   *
   * @param {Event} event - the event to hash
   * @returns {ArrayBuffer} hashBuffer - buffer containing the bytes of the hash
   */
  const hashEvent = event => {
    const EventTypes = z.event.Client.CONVERSATION;
    const specificBytesGenerators = {
      [EventTypes.MESSAGE_ADD]: getTextBytes,
      [EventTypes.LOCATION]: getLocationBytes,
      [EventTypes.ASSET_ADD]: getAssetBytes,
    };

    const generator = specificBytesGenerators[event.type];
    if (!generator) {
      throw new Error(`Cannot generate hash for event of type "${event.type}"`);
    }

    const specificBytes = generator(event);
    const timeBytes = getTimestampBytes(event);
    const allBytes = specificBytes.concat(timeBytes);

    return createSha256Hash(allBytes);
  };

  /**
   * Validates that the quoteHash correspond to the given event.
   *
   * @param {Event} event - The event to match against the hash
   * @param {ArrayBuffer} hash - The hash
   * @returns {boolean} isValid - true if the event hash is equal to the given hash
   */
  const validateHash = (event, hash) => {
    return hashEvent(event).then(generatedHash => {
      if (hash.byteLength !== generatedHash.byteLength) {
        return false;
      }
      const generatedHashBytes = new Uint8Array(generatedHash);
      const hashBytes = new Uint8Array(hash);
      for (let i = 0; i !== generatedHash.byteLength; i++) {
        if (generatedHashBytes[i] !== hashBytes[i]) {
          return false;
        }
      }
      return true;
    });
  };

  return {
    hashEvent,
    validateHash,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum of different ephemeral status types.
 * @type {z.message.EphemeralStatusType} Enum of ephemeral status types
 */
z.message.EphemeralStatusType = {
  ACTIVE: 1,
  INACTIVE: 2,
  NONE: 0,
  TIMED_OUT: 3,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.MentionEntity = class MentionEntity {
  static get ERROR() {
    return {
      INVALID_LENGTH: 'Invalid mention: Invalid length',
      INVALID_START_CHAR: 'Invalid mention: Mention does not start with @',
      INVALID_START_INDEX: 'Invalid mention: Invalid startIndex',
      INVALID_USER_ID: 'Invalid mention: User ID is not a valid UUID',
      MISSING_LENGTH: 'Invalid mention: Missing length',
      MISSING_START_INDEX: 'Invalid mention: Missing startIndex',
      MISSING_USER_ID: 'Invalid mention: Missing user ID',
      OUT_OF_BOUNDS: 'Invalid mention: Length out of string boundary',
    };
  }

  constructor(startIndex, length, userId) {
    this.startIndex = startIndex;
    this.length = length;
    this.type = z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;

    this.userId = userId;
  }

  targetsUser(userId) {
    const isTypeUserId = this.type === z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;
    return isTypeUserId && this.userId === userId;
  }

  // Index of first char outside of mention
  get endIndex() {
    return this.startIndex + this.length;
  }

  validate(messageText = '') {
    const startIndexIsNumber = typeof this.startIndex === 'number';
    if (!startIndexIsNumber) {
      throw new Error(MentionEntity.ERROR.MISSING_START_INDEX);
    }

    const lengthIsNumber = typeof this.length === 'number';
    if (!lengthIsNumber) {
      throw new Error(MentionEntity.ERROR.MISSING_LENGTH);
    }

    const userIdIsString = typeof this.userId === 'string';
    if (!userIdIsString) {
      throw new Error(MentionEntity.ERROR.MISSING_USER_ID);
    }

    const isValidStartIndex = this.startIndex >= 0;
    if (!isValidStartIndex) {
      throw new Error(MentionEntity.ERROR.INVALID_START_INDEX);
    }

    const isValidLength = this.length >= 1;
    if (!isValidLength) {
      throw new Error(MentionEntity.ERROR.INVALID_LENGTH);
    }

    const isValidEnd = messageText.length && this.endIndex <= messageText.length;
    if (!isValidEnd) {
      throw new Error(MentionEntity.ERROR.OUT_OF_BOUNDS);
    }

    const isValidUserId = z.util.ValidationUtil.isUUID(this.userId);
    if (!isValidUserId) {
      throw new Error(MentionEntity.ERROR.INVALID_USER_ID);
    }

    const isValidMention = messageText.substr(this.startIndex, 1) === '@';
    if (!isValidMention) {
      throw new Error(MentionEntity.ERROR.INVALID_START_CHAR);
    }

    return true;
  }

  toJSON() {
    return {
      length: this.length,
      startIndex: this.startIndex,
      userId: this.userId,
    };
  }

  toProto() {
    const protoMention = new z.proto.Mention(this.startIndex, this.length);
    const isUserIdMention = this.type === z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID;
    if (isUserIdMention) {
      protoMention.set(z.cryptography.PROTO_MESSAGE_TYPE.MENTION_TYPE_USER_ID, this.userId);
    }
    return protoMention;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

z.message.QuoteEntity = class QuoteEntity {
  static get ERROR() {
    return {
      INVALID_HASH: 'INVALID_HASH',
      MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',
    };
  }

  constructor({error, hash, messageId, userId}) {
    this.messageId = messageId;
    this.hash = hash;
    this.userId = userId;
    this.error = error;
  }

  isQuoteFromUser(userId) {
    return this.userId === userId;
  }

  toJSON() {
    return {
      messageId: this.messageId,
      userId: this.userId,
    };
  }

  toProto() {
    return new z.proto.Quote(this.messageId, new Uint8Array(this.hash));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different confirmation types.
 * @type {z.message.StatusType} Enum of status types
 */
z.message.StatusType = {
  DELIVERED: 3,
  FAILED: 0,
  SEEN: 4,
  SENDING: 1,
  SENT: 2,
  UNSPECIFIED: -1,
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different reactions.
 * @returns {z.message.ReactionType} Enum of reactions
 */
z.message.ReactionType = {
  LIKE: '❤️',
  NONE: '',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different message super types.
 * @type {z.message.SuperType} Enum of super types
 */
z.message.SuperType = {
  CALL: 'call',
  CONTENT: 'normal',
  DELETE: 'delete',
  DEVICE: 'device',
  LOCATION: 'location',
  MEMBER: 'member',
  MISSED: 'missed',
  PING: 'ping',
  REACTION: 'reaction',
  SPECIAL: 'special',
  SYSTEM: 'system',
  UNABLE_TO_DECRYPT: 'unable-to-decrypt',
  VERIFICATION: 'verification',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different system message types.
 * @todo Refactor to use member-join and member-leave instead of normal. It duplicates "z.message.SuperType".
 * @type {z.message.SystemMessageType} Enum of system message types
 */
z.message.SystemMessageType = {
  CONNECTION_ACCEPTED: 'created-one-to-one',
  CONNECTION_CONNECTED: 'connected',
  CONNECTION_REQUEST: 'connecting',
  CONVERSATION_CREATE: 'created-group',
  CONVERSATION_MESSAGE_TIMER_UPDATE: 'message-timer-update',
  CONVERSATION_RENAME: 'rename',
  CONVERSATION_RESUME: 'resume',
  MEMBER_JOIN: 'join',
  MEMBER_LEAVE: 'leave',
  NORMAL: 'normal',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.message = z.message || {};

/**
 * Enum for different verification message types.
 * @type {z.message.VerificationMessageType} Enum of verification message types
 */
z.message.VerificationMessageType = {
  NEW_DEVICE: 'new-device',
  NEW_MEMBER: 'new-member',
  UNVERIFIED: 'unverified',
  VERIFIED: 'verified',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Asset = class Asset {
  constructor(id) {
    this.id = id;
    this.key = '';
    this.type = '';
  }

  /**
   * Check if asset is a medium image.
   * @returns {boolean} Is asset of type medium image
   */
  is_image() {
    return this.type === z.assets.AssetType.IMAGE;
  }

  /**
   * Check if asset is a text.
   * @returns {boolean} Is asset of type text
   */
  is_text() {
    return this.type === z.assets.AssetType.TEXT;
  }

  /**
   * Check if asset is a file.
   * @returns {boolean} Is asset of type file
   */
  is_file() {
    return this.type === z.assets.AssetType.FILE && !this.is_video() && !this.is_audio();
  }

  /**
   * Check if asset is a location.
   * @returns {boolean} Is asset of type location
   */
  is_location() {
    return this.type === z.assets.AssetType.LOCATION;
  }

  /**
   * Check if asset is a video.
   * @returns {boolean} Is asset of type video
   */
  is_video() {
    const is_video_asset =
      this.type === z.assets.AssetType.FILE && this.file_type && this.file_type.startsWith('video');
    if (is_video_asset) {
      const can_play = document.createElement('video').canPlayType(this.file_type);
      if (can_play !== '') {
        return true;
      }
    }
    return false;
  }

  /**
   * Check if asset is a audio.
   * @returns {boolean} Is asset of type audio
   */
  is_audio() {
    const is_audio_asset =
      this.type === z.assets.AssetType.FILE && this.file_type && this.file_type.startsWith('audio');
    if (is_audio_asset) {
      const can_play = document.createElement('audio').canPlayType(this.file_type);
      if (can_play !== '') {
        return true;
      }
    }
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Text = class Text extends z.entity.Asset {
  constructor(id, text = '') {
    super(id);
    this.type = z.assets.AssetType.TEXT;

    // Raw message text
    this.text = text;

    // Can be used to theme media embeds
    this.theme_color = undefined;

    // Array of z.message.MentionEntity instances
    this.mentions = ko.observableArray();

    // Array of z.entity.LinkPreview instances
    this.previews = ko.observableArray();

    this.should_render_text = ko.pureComputed(() => {
      if (this.text === null || this.text.length === 0) {
        return false;
      }
      const has_link_previews = this.previews().length > 0;
      return !has_link_previews || (has_link_previews && !z.links.LinkPreviewHelpers.containsOnlyLink(this.text));
    });
  }

  // Process text before rendering it
  render(selfId) {
    const message = z.util.renderMessage(this.text, selfId, this.mentions());
    return !this.previews().length ? z.media.MediaParser.renderMediaEmbeds(message, this.theme_color) : message;
  }

  isUserMentioned(userId) {
    return this.mentions().some(mentionEntity => mentionEntity.targetsUser(userId));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.LinkPreview = class LinkPreview {
  constructor(title, url) {
    this.title = title || '';
    this.url = url || '';

    this.image_resource = ko.observable();
    this.meta_data = undefined;
    this.meta_data_type = undefined;
  }

  obfuscate() {
    this.title = z.util.StringUtil.obfuscate(this.title);
    this.url = z.util.StringUtil.obfuscate(this.url);

    this.image_resource(undefined);
    this.meta_data = undefined;
    this.meta_data_type = undefined;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.File = class File extends z.entity.Asset {
  constructor(id) {
    super(id);
    this.cancel_download = this.cancel_download.bind(this);

    this.type = z.assets.AssetType.FILE;
    this.logger = new z.util.Logger('z.entity.File', z.config.LOGGER.OPTIONS);

    // z.assets.AssetTransferState
    this.status = ko.observable();

    this.file_name = '';
    this.file_size = '';
    this.file_type = '';

    // contains asset meta data as object
    this.meta = {};

    // asset url, instance of an otr asset this has to be decrypted
    this.original_resource = ko.observable();
    this.preview_resource = ko.observable();

    this.download = this.download.bind(this);
    this.downloadProgress = ko.pureComputed(() => {
      if (this.original_resource()) {
        return this.original_resource().downloadProgress();
      }

      return undefined;
    });

    this.upload_id = ko.observable();
    this.upload_progress = ko.observable();
    this.uploaded_on_this_client = ko.observable(false);
    this.upload_failed_reason = ko.observable();
    this.upload_cancel = undefined;
    this.pending_upload = ko.pureComputed(() => {
      return this.status() === z.assets.AssetTransferState.UPLOADING && this.uploaded_on_this_client();
    });

    // update progress
    this.upload_id.subscribe(upload_id => {
      if (upload_id) {
        return amplify.subscribe(`upload${upload_id}`, this.on_progress);
      }
    });

    this.status.subscribe(status => {
      if (status === z.assets.AssetTransferState.UPLOADED) {
        return amplify.unsubscribe(`upload${this.upload_id}`, this.on_progress);
      }
    });
  }

  on_progress(progress) {
    return this.upload_progress(progress);
  }

  /**
   * Loads and decrypts otr asset preview
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  load_preview() {
    return this.preview_resource().load();
  }

  /**
   * Loads and decrypts otr asset
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  load() {
    this.status(z.assets.AssetTransferState.DOWNLOADING);

    return this.original_resource()
      .load()
      .then(blob => {
        this.status(z.assets.AssetTransferState.UPLOADED);
        return blob;
      })
      .catch(error => {
        this.status(z.assets.AssetTransferState.UPLOADED);
        throw error;
      });
  }

  /**
   * Loads and decrypts otr asset as initiates download
   *
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  download() {
    if (this.status() !== z.assets.AssetTransferState.UPLOADED) {
      return Promise.resolve(undefined);
    }

    const download_started = Date.now();

    return this.load()
      .then(blob => z.util.downloadBlob(blob, this.file_name))
      .then(() => {
        const download_duration = (Date.now() - download_started) / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND;
        this.logger.info(`Downloaded asset in ${download_duration} seconds`);
      })
      .catch(error => this.logger.error('Failed to download asset', error));
  }

  cancel_download() {
    this.status(z.assets.AssetTransferState.UPLOADED);
    return this.original_resource().cancelDownload();
  }

  cancel(message_et) {
    if (typeof this.upload_cancel === 'function') {
      this.upload_cancel();
    }
    amplify.publish(z.event.WebApp.CONVERSATION.ASSET.CANCEL, message_et);
  }

  reload() {
    this.logger.info('Restart upload');
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Location = class Location extends z.entity.Asset {
  constructor() {
    super();

    this.latitude = '';
    this.longitude = '';
    this.name = '';
    this.type = z.assets.AssetType.LOCATION;
    this.zoom = '';
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MediumImage = class MediumImage extends z.entity.Asset {
  constructor(id) {
    super(id);

    this.correlation_id = '';
    this.type = z.assets.AssetType.IMAGE;

    this.width = '0px';
    this.height = '0px';

    this.file_name = '';
    this.file_size = '';
    this.file_type = '';

    // z.assets.AssetRemoteData
    this.resource = ko.observable();
  }

  /**
   * Loads and decrypts otr asset as initiates download
   * @param {string} filename - Filename
   * @returns {Promise} Returns a promise that resolves with the asset as blob
   */
  download(filename) {
    return this.resource()
      .load()
      .then(blob => z.util.downloadBlob(blob, filename))
      .catch(error => this.logger.error('Failed to download image', error));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Message = class Message {
  /**
   * Sort messages by timestamp
   * @param {Array<z.entity.Message>} message_ets - Message entities
   * @returns {boolean} Sorted message entities
   */
  static sort_by_timestamp(message_ets) {
    return message_ets.sort((m1, m2) => m1.timestamp() > m2.timestamp());
  }

  constructor(id = '0', super_type = '') {
    this.equals = this.equals.bind(this);
    this.is_expired = this.is_expired.bind(this);
    this.startMessageTimer = this.startMessageTimer.bind(this);
    this.id = id;
    this.super_type = super_type;
    this.ephemeral_caption = ko.pureComputed(() => {
      const remainingTime = this.ephemeral_remaining();
      return remainingTime ? z.util.TimeUtil.formatDurationCaption(remainingTime) : '';
    });
    this.ephemeral_duration = ko.observable(0);
    this.ephemeral_remaining = ko.observable(0);
    this.ephemeral_expires = ko.observable(false);
    this.ephemeral_started = ko.observable('0');
    this.ephemeral_status = ko.computed(() => {
      const isExpired = this.ephemeral_expires() === true;
      if (isExpired) {
        return z.message.EphemeralStatusType.TIMED_OUT;
      }

      if (_.isNumber(this.ephemeral_expires())) {
        return z.message.EphemeralStatusType.INACTIVE;
      }

      if (_.isString(this.ephemeral_expires())) {
        const isExpiring = Date.now() >= this.ephemeral_expires();
        return isExpiring ? z.message.EphemeralStatusType.TIMED_OUT : z.message.EphemeralStatusType.ACTIVE;
      }

      return z.message.EphemeralStatusType.NONE;
    });

    this.isObfuscated = ko.pureComputed(() => {
      const messageIsAtLeastSent = this.status() > z.message.StatusType.SENDING;
      const isEphemeralInactive = this.ephemeral_status() === z.message.EphemeralStatusType.INACTIVE;
      return messageIsAtLeastSent && (isEphemeralInactive || this.is_expired());
    });

    this.conversation_id = '';
    this.from = '';
    this.primary_key = undefined;
    this.status = ko.observable(z.message.StatusType.UNSPECIFIED);
    this.type = '';
    this.user = ko.observable(new z.entity.User());
    this.visible = ko.observable(true);
    this.version = 1;

    this.affect_order = ko.observable(true);
    this.timestamp = ko.observable(Date.now());
    this.timestamp_affects_order = ko.pureComputed(() => this.visible() && this.affect_order());

    // z.message.MessageCategory
    this.category = undefined;

    this.display_timestamp_short = () => {
      const date = moment.unix(this.timestamp() / z.util.TimeUtil.UNITS_IN_MILLIS.SECOND);
      return date.local().format('HH:mm');
    };

    this.unsafeSenderName = ko.pureComputed(() => z.util.SanitizationUtil.getFirstName(this.user(), undefined, true));
    this.headerSenderName = ko.pureComputed(() => {
      return this.user().isService ? this.user().name() : this.user().first_name();
    });

    this.accent_color = ko.pureComputed(() => `accent-color-${this.user().accent_id()}`);
  }

  equals(messageEntity) {
    return messageEntity && this.id ? this.id === messageEntity.id : false;
  }

  /**
   * Check if message contains an asset of type file.
   * @returns {boolean} Message contains any file type asset
   */
  has_asset() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.type === z.assets.AssetType.FILE) : false;
  }

  /**
   * Check if message contains a file asset.
   * @returns {boolean} Message contains a file
   */
  has_asset_file() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_file()) : false;
  }

  /**
   * Check if message contains any image asset.
   * @returns {boolean} Message contains any image
   */
  has_asset_image() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_image()) : false;
  }

  /**
   * Check if message contains a location asset.
   * @returns {boolean} Message contains a location
   */
  has_asset_location() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_location()) : false;
  }

  /**
   * Check if message contains a text asset.
   * @returns {boolean} Message contains text
   */
  has_asset_text() {
    return this.is_content() ? this.assets().some(assetEntity => assetEntity.is_text()) : false;
  }

  /**
   * Check if message is a call message.
   * @returns {boolean} Is message of type call
   */
  is_call() {
    return this.super_type === z.message.SuperType.CALL;
  }

  /**
   * Check if message is a content message.
   * @returns {boolean} Is message of type content
   */
  is_content() {
    return this.super_type === z.message.SuperType.CONTENT;
  }

  /**
   * Check if message can be deleted.
   * @returns {boolean} True, if message is deletable.
   */
  is_deletable() {
    return this.status() !== z.message.StatusType.SENDING;
  }

  /**
   * Check if the message content can be downloaded.
   * @returns {boolean} True, if the message has downloadable content.
   */
  is_downloadable() {
    const isExpiredEphemeral = this.ephemeral_status() === z.message.EphemeralStatusType.TIMED_OUT;
    if (isExpiredEphemeral) {
      return false;
    }

    if (this.hasUnavailableAsset()) {
      return false;
    }

    if (this.is_content()) {
      const assetEntity = this.get_first_asset();

      if (assetEntity && typeof assetEntity.download === 'function') {
        return true;
      }
    }
    return false;
  }

  isEdited() {
    return this.is_content() && this.was_edited();
  }

  isLinkPreview() {
    return (
      this.has_asset_text() && this.assets().some(assetEntity => assetEntity.is_text() && assetEntity.previews().length)
    );
  }

  /**
   * Check if message is a member message.
   * @returns {boolean} Is message of type member
   */
  is_member() {
    return this.super_type === z.message.SuperType.MEMBER;
  }

  /**
   * Check if message is a ping message.
   * @returns {boolean} Is message of type ping
   */
  is_ping() {
    return this.super_type === z.message.SuperType.PING;
  }

  /**
   * Check if message is a system message.
   * @returns {boolean} Is message of type system
   */
  is_system() {
    return this.super_type === z.message.SuperType.SYSTEM;
  }

  /**
   * Check if message is a e2ee message.
   * @returns {boolean} Is message of type system
   */
  is_unable_to_decrypt() {
    return this.super_type === z.message.SuperType.UNABLE_TO_DECRYPT;
  }

  /**
   * Check if message is a e2ee message.
   * @returns {boolean} Is message of type system
   */
  is_verification() {
    return this.super_type === z.message.SuperType.VERIFICATION;
  }

  /**
   * Check if message can be copied.
   * @returns {boolean} True, if message can be copied.
   */

  isCopyable() {
    return this.has_asset_text();
  }

  /**
   * Check if message can be edited.
   * @returns {boolean} True, if message can be edited.
   */
  is_editable() {
    return this.has_asset_text() && this.user().is_me && !this.is_ephemeral();
  }

  /**
   * Check if message is ephemeral.
   * @returns {boolean} True, if message is ephemeral.
   */
  is_ephemeral() {
    return this.ephemeral_expires() !== false;
  }

  /**
   * Check if ephemeral message is expired.
   * @returns {boolean} True, if message expired.
   */
  is_expired() {
    return this.ephemeral_expires() === true;
  }

  /**
   * Check if message has an unavailable (uploading or failed) asset.
   * @returns {boolean} True, if an asset is unavailable.
   */
  hasUnavailableAsset() {
    if (this.has_asset()) {
      return this.assets().some(asset => {
        const assetStatus = asset.status();
        return (
          assetStatus === z.assets.AssetTransferState.UPLOADING ||
          assetStatus === z.assets.AssetTransferState.UPLOAD_FAILED
        );
      });
    }
    return false;
  }

  /**
   * Check if message can be reacted to.
   * @returns {boolean} True, if message type supports reactions.
   */
  isReactable() {
    return (
      this.is_content() &&
      !this.is_ephemeral() &&
      this.status() !== z.message.StatusType.SENDING &&
      !this.hasUnavailableAsset()
    );
  }

  /**
   * Check if message can be replied to.
   * @returns {boolean} True, if message type supports replies.
   */
  isReplyable() {
    return (
      this.is_content() &&
      !this.is_ephemeral() &&
      this.status() !== z.message.StatusType.SENDING &&
      !this.hasUnavailableAsset()
    );
  }

  // Start the ephemeral timer for the message.
  startMessageTimer(timeOffset) {
    if (this.messageTimerStarted) {
      return;
    }

    if (this.ephemeral_status() === z.message.EphemeralStatusType.INACTIVE) {
      const startingTimestamp = this.user().is_me ? Math.min(this.timestamp() + timeOffset, Date.now()) : Date.now();
      const expirationTimestamp = `${startingTimestamp + this.ephemeral_expires()}`;
      this.ephemeral_expires(expirationTimestamp);
      this.ephemeral_started(`${startingTimestamp}`);
    }

    const remainingTime = this.ephemeral_expires() - this.ephemeral_started();
    this.ephemeral_remaining(remainingTime);
    this.messageTimerStarted = true;
  }

  /**
   * Update the status of a message.
   * @param {z.message.StatusType} updated_status - New status of message
   * @returns {z.message.StatusType|boolean} Returns the new status on a successful update, otherwise "false"
   */
  update_status(updated_status) {
    if (this.status() >= z.message.StatusType.SENT) {
      if (updated_status > this.status()) {
        return this.status(updated_status);
      }
    } else if (this.status() !== updated_status) {
      return this.status(updated_status);
    }
    return false;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.DeleteMessage = class DeleteMessage extends z.entity.Message {
  constructor() {
    super();

    this.super_type = z.message.SuperType.DELETE;
    this.deleted_timestamp = null;

    this.display_deleted_timestamp = () => {
      return z.l10n.text(z.string.conversationDeleteTimestamp, moment(this.deleted_timestamp).format('HH:mm'));
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.SystemMessage = class SystemMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.SYSTEM;
    this.system_message_type = z.message.SystemMessageType.NORMAL;
  }

  is_conversation_rename() {
    return this.system_message_type === z.message.SystemMessageType.CONVERSATION_RENAME;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MemberMessage = class MemberMessage extends z.entity.SystemMessage {
  static get CONFIG() {
    return {
      MAX_USERS_VISIBLE: 17,
      MAX_WHOLE_TEAM_USERS_VISIBLE: 10,
      REDUCED_USERS_COUNT: 15,
    };
  }

  constructor() {
    super();

    this.super_type = z.message.SuperType.MEMBER;
    this.memberMessageType = z.message.SystemMessageType.NORMAL;

    this.userEntities = ko.observableArray();
    this.userIds = ko.observableArray();
    this.name = ko.observable('');

    this.exceedsMaxVisibleUsers = ko.pureComputed(() => {
      return this.joinedUserEntities().length > MemberMessage.CONFIG.MAX_USERS_VISIBLE;
    });
    this.visibleUsers = ko.observable([]);
    this.hiddenUserCount = ko.pureComputed(() => this.joinedUserEntities().length - this.visibleUsers().length);
    this.highlightedUsers = ko.pureComputed(() => {
      return this.type === z.event.Backend.CONVERSATION.MEMBER_JOIN ? this.joinedUserEntities() : [];
    });

    this.hasUsers = ko.pureComputed(() => this.userEntities().length);
    this.allTeamMembers = undefined;
    this.showServicesWarning = false;

    // Users joined the conversation without sender
    this.joinedUserEntities = ko.pureComputed(() => {
      return this.userEntities()
        .filter(userEntity => !this.user() || this.user().id !== userEntity.id)
        .map(userEntity => userEntity);
    });

    this.joinedUserEntities.subscribe(joinedUserEntities => {
      const selfUser = joinedUserEntities.find(userEntity => userEntity.is_me);
      const visibleUsers = joinedUserEntities.filter(userEntity => !userEntity.is_me);
      if (this.exceedsMaxVisibleUsers()) {
        const spliceCount = MemberMessage.CONFIG.REDUCED_USERS_COUNT;
        visibleUsers.splice(selfUser ? spliceCount - 1 : spliceCount);
      }
      if (selfUser) {
        visibleUsers.push(selfUser);
      }
      this.visibleUsers(visibleUsers);
    });

    // Users joined the conversation without self
    this.remoteUserEntities = ko.pureComputed(() => {
      return this.userEntities()
        .filter(userEntity => !userEntity.is_me)
        .map(userEntity => userEntity);
    });

    this.senderName = ko.pureComputed(() => {
      const isTeamMemberLeave = this.type === z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE;
      return isTeamMemberLeave
        ? this.name()
        : z.util.SanitizationUtil.getFirstName(this.user(), z.string.Declension.NOMINATIVE, true);
    });

    this.showNamedCreation = ko.pureComputed(() => this.isConversationCreate() && this.name().length);

    this.otherUser = ko.pureComputed(() => (this.hasUsers() ? this.userEntities()[0] : new z.entity.User()));

    this.htmlCaption = ko.pureComputed(() => {
      if (!this.hasUsers()) {
        return '';
      }

      let substitutions;
      const replaceDangerously = {
        '/showmore': '</a>',
        showmore: '<a class="message-header-show-more" data-uie-name="do-show-more">',
      };

      switch (this.memberMessageType) {
        case z.message.SystemMessageType.CONNECTION_ACCEPTED:
        case z.message.SystemMessageType.CONNECTION_REQUEST: {
          if (this.otherUser()) {
            if (this.otherUser().isBlocked()) {
              return z.l10n.safeHtml(z.string.conversationConnectionBlocked);
            }

            if (this.otherUser().isOutgoingRequest()) {
              return '';
            }
          }

          return z.l10n.safeHtml(z.string.conversationConnectionAccepted);
        }

        case z.message.SystemMessageType.CONVERSATION_CREATE: {
          if (this.name().length) {
            const exceedsMaxTeam = this.joinedUserEntities().length > MemberMessage.CONFIG.MAX_WHOLE_TEAM_USERS_VISIBLE;
            if (this.allTeamMembers && exceedsMaxTeam) {
              const guestCount = this.joinedUserEntities().filter(userEntity => userEntity.isGuest()).length;
              substitutions = {replace: {count: guestCount}, replaceDangerously};
              if (!guestCount) {
                return z.l10n.safeHtml(z.string.conversationCreateTeam, substitutions);
              }

              const hasSingleGuest = guestCount === 1;
              const teamStringId = hasSingleGuest
                ? z.string.conversationCreateTeamGuest
                : z.string.conversationCreateTeamGuests;

              return z.l10n.safeHtml(teamStringId, substitutions);
            }

            const createStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationCreateWithMore
              : z.string.conversationCreateWith;

            substitutions = {
              replace: {
                count: this.hiddenUserCount(),
                users: this._generateNameString(this.exceedsMaxVisibleUsers(), z.string.Declension.DATIVE),
              },
              replaceDangerously,
            };

            return z.l10n.safeHtml(createStringId, substitutions);
          }

          if (this.user().is_me) {
            const createStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationCreatedYouMore
              : z.string.conversationCreatedYou;

            substitutions = {
              replace: {
                count: this.hiddenUserCount(),
                users: this._generateNameString(this.exceedsMaxVisibleUsers()),
              },
              replaceDangerously,
            };

            return z.l10n.safeHtml(createStringId, substitutions);
          }

          const createStringId = this.exceedsMaxVisibleUsers()
            ? z.string.conversationCreatedMore
            : z.string.conversationCreated;

          substitutions = {
            replace: {
              count: this.hiddenUserCount(),
              name: this.senderName(),
              users: this._generateNameString(this.exceedsMaxVisibleUsers(), z.string.Declension.DATIVE),
            },
            replaceDangerously,
          };

          return z.l10n.safeHtml(createStringId, substitutions);
        }

        case z.message.SystemMessageType.CONVERSATION_RESUME: {
          substitutions = {
            replace: {
              users: this._generateNameString(false, z.string.Declension.DATIVE),
            },
          };

          return z.l10n.safeHtml(z.string.conversationResume, substitutions);
        }

        default:
          break;
      }

      switch (this.type) {
        case z.event.Backend.CONVERSATION.MEMBER_JOIN: {
          const senderJoined = this.otherUser().id === this.user().id;
          if (senderJoined) {
            const userJoinedStringId = this.user().is_me
              ? z.string.conversationMemberJoinedSelfYou
              : z.string.conversationMemberJoinedSelf;
            return z.l10n.safeHtml(userJoinedStringId, this.senderName());
          }

          let userJoinedStringId = '';

          if (this.user().is_me) {
            userJoinedStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationMemberJoinedYouMore
              : z.string.conversationMemberJoinedYou;
          } else {
            userJoinedStringId = this.exceedsMaxVisibleUsers()
              ? z.string.conversationMemberJoinedMore
              : z.string.conversationMemberJoined;
          }

          substitutions = {
            replace: {
              count: this.hiddenUserCount(),
              name: this.senderName(),
              users: this._generateNameString(this.exceedsMaxVisibleUsers()),
            },
            replaceDangerously,
          };

          return z.l10n.safeHtml(userJoinedStringId, substitutions);
        }

        case z.event.Backend.CONVERSATION.MEMBER_LEAVE: {
          const temporaryGuestRemoval = this.otherUser().is_me && this.otherUser().isTemporaryGuest();
          if (temporaryGuestRemoval) {
            return z.l10n.safeHtml(z.string.temporaryGuestLeaveMessage);
          }

          const senderLeft = this.otherUser().id === this.user().id;
          if (senderLeft) {
            const userLeftStringId = this.user().is_me
              ? z.string.conversationMemberLeftYou
              : z.string.conversationMemberLeft;
            return z.l10n.safeHtml(userLeftStringId, this.senderName());
          }

          const userRemovedStringId = this.user().is_me
            ? z.string.conversationMemberRemovedYou
            : z.string.conversationMemberRemoved;

          substitutions = {replace: {name: this.senderName(), users: this._generateNameString()}};
          return z.l10n.safeHtml(userRemovedStringId, substitutions);
        }

        case z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE: {
          return z.l10n.safeHtml(z.string.conversationTeamLeft, this.senderName());
        }

        default:
          break;
      }
      return '';
    });

    this.htmlGroupCreationHeader = ko.pureComputed(() => {
      if (this.showNamedCreation()) {
        if (this.user().isTemporaryGuest()) {
          return z.l10n.safeHtml(z.string.conversationCreateTemporary);
        }

        const groupCreationStringId = this.user().is_me
          ? z.string.conversationCreatedNameYou
          : z.string.conversationCreatedName;
        return z.util.StringUtil.capitalizeFirstChar(z.l10n.safeHtml(groupCreationStringId, this.senderName()));
      }
      return '';
    });

    this.showLargeAvatar = () => {
      const largeAvatarTypes = [
        z.message.SystemMessageType.CONNECTION_ACCEPTED,
        z.message.SystemMessageType.CONNECTION_REQUEST,
      ];
      return largeAvatarTypes.includes(this.memberMessageType);
    };
  }

  _generateNameString(skipAnd = false, declension = z.string.Declension.ACCUSATIVE) {
    return z.util.LocalizerUtil.joinNames(this.visibleUsers(), declension, skipAnd, true);
  }

  isConnection() {
    const connectionMessageTypes = [
      z.message.SystemMessageType.CONNECTION_ACCEPTED,
      z.message.SystemMessageType.CONNECTION_REQUEST,
    ];

    return connectionMessageTypes.includes(this.memberMessageType);
  }

  isConnectionRequest() {
    return this.memberMessageType === z.message.SystemMessageType.CONNECTION_REQUEST;
  }

  isCreation() {
    return [
      z.message.SystemMessageType.CONNECTION_ACCEPTED,
      z.message.SystemMessageType.CONNECTION_REQUEST,
      z.message.SystemMessageType.CONVERSATION_CREATE,
      z.message.SystemMessageType.CONVERSATION_RESUME,
    ].includes(this.memberMessageType);
  }

  isConversationCreate() {
    return this.memberMessageType === z.message.SystemMessageType.CONVERSATION_CREATE;
  }

  isConversationResume() {
    return this.memberMessageType === z.message.SystemMessageType.CONVERSATION_RESUME;
  }

  isGroupCreation() {
    return this.isConversationCreate() || this.isConversationResume();
  }

  isMemberChange() {
    return this.isMemberJoin() || this.isMemberLeave() || this.isTeamMemberLeave();
  }

  isMemberJoin() {
    return this.type === z.event.Backend.CONVERSATION.MEMBER_JOIN;
  }

  isMemberLeave() {
    return this.type === z.event.Backend.CONVERSATION.MEMBER_LEAVE;
  }

  isTeamMemberLeave() {
    return this.type === z.event.Client.CONVERSATION.TEAM_MEMBER_LEAVE;
  }

  isMemberRemoval() {
    return this.isMemberLeave() || this.isTeamMemberLeave();
  }

  isUserAffected(userId) {
    return this.userIds().includes(userId);
  }

  guestCount() {
    return this.joinedUserEntities().filter(user => user.isGuest()).length;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MissedMessage = class MissedMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.MISSED;
    this.affect_order(false);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.ContentMessage = class ContentMessage extends z.entity.Message {
  constructor(id) {
    super(id);

    this.assets = ko.observableArray([]);
    this.super_type = z.message.SuperType.CONTENT;
    this.replacing_message_id = null;
    this.edited_timestamp = null;

    this.reactions = ko.observable({});
    this.reactions_user_ets = ko.observableArray();
    this.reactions_user_ids = ko.pureComputed(() => {
      this.reactions_user_ets()
        .map(user_et => user_et.first_name())
        .join(', ');
    });

    this.quote = ko.observable();

    this.display_edited_timestamp = () => {
      return z.l10n.text(z.string.conversationEditTimestamp, moment(this.edited_timestamp).format('HH:mm'));
    };

    this.is_liked_provisional = ko.observable();
    this.is_liked = ko.pureComputed({
      read: () => {
        if (this.is_liked_provisional() != null) {
          const is_liked_provisional = this.is_liked_provisional();
          this.is_liked_provisional(null);
          return is_liked_provisional;
        }
        const likes = this.reactions_user_ets().filter(user_et => user_et.is_me);
        return likes.length === 1;
      },
      write: value => {
        return this.is_liked_provisional(value);
      },
    });
    this.other_likes = ko.pureComputed(() => this.reactions_user_ets().filter(user_et => !user_et.is_me));

    this.like_caption = ko.pureComputed(() => {
      if (this.reactions_user_ets().length <= 5) {
        return this.reactions_user_ets()
          .map(user_et => user_et.first_name())
          .join(', ');
      }
      return z.l10n.text(z.string.conversationLikesCaption, this.reactions_user_ets().length);
    });
  }

  /**
   * Add another content asset to the message.
   * @param {z.entity.Asset} asset_et - New content asset
   * @returns {undefined} No return value
   */
  add_asset(asset_et) {
    this.assets.push(asset_et);
  }

  copy() {
    z.util.ClipboardUtil.copyText(this.get_first_asset().text);
  }

  /**
   * Get the first asset attached to the message.
   * @returns {z.entity.Asset} The first asset attached to the message
   */
  get_first_asset() {
    return this.assets()[0];
  }

  update_reactions({data: event_data, from}) {
    const reactions = this.reactions();

    if (event_data.reaction) {
      reactions[from] = event_data.reaction;
    } else {
      delete reactions[from];
    }

    if (reactions !== this.reactions) {
      this.reactions(reactions);
      this.version += 1;
      return {reactions: this.reactions(), version: this.version};
    }
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the message mentions the user.
   */
  isUserMentioned(userId) {
    return this.has_asset_text()
      ? this.assets().some(assetEntity => assetEntity.is_text() && assetEntity.isUserMentioned(userId))
      : false;
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the message quotes the user.
   */
  isUserQuoted(userId) {
    return this.quote() ? this.quote().isQuoteFromUser(userId) : false;
  }

  /**
   * @param {string} userId - The user id to check
   * @returns {boolean} True if the user was mentioned or quoted.
   */
  isUserTargeted(userId) {
    return this.isUserMentioned(userId) || this.isUserQuoted(userId);
  }

  /**
   * Check whether the message was edited.
   * @returns {boolean} True, if message has been edited.
   */
  was_edited() {
    return this.replacing_message_id != null;
  }

  /**
   * Download message content.
   * @returns {undefined} No return value
   */
  download() {
    const asset_et = this.get_first_asset();
    const file_name = this.get_content_name();
    asset_et.download(file_name);
  }

  /**
   * Get content name.
   * @returns {string} The content/file name.
   */
  get_content_name() {
    const asset_et = this.get_first_asset();
    let {file_name} = asset_et;

    if (!file_name) {
      const date = moment(this.timestamp());
      file_name = `Wire ${date.format('YYYY-MM-DD')} at ${date.format('H.mm.ss')}`;
    }

    if (asset_et.file_type) {
      const file_extension = asset_et.file_type.split('/').pop();
      file_name = `${file_name}.${file_extension}`;
    }

    return file_name;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.MessageTimerUpdateMessage = class MessageTimerUpdateMessage extends z.entity.SystemMessage {
  constructor(messageTimer) {
    super();

    this.type = z.event.Backend.CONVERSATION.MESSAGE_TIMER_UPDATE;
    this.system_message_type = z.message.SystemMessageType.CONVERSATION_MESSAGE_TIMER_UPDATE;

    this.message_timer = z.conversation.ConversationEphemeralHandler.validateTimer(messageTimer);

    this.caption = ko.pureComputed(() => {
      if (this.message_timer) {
        const timeString = z.util.TimeUtil.formatDuration(this.message_timer).text;
        const stringId = this.user().is_me ? z.string.conversationUpdatedTimerYou : z.string.conversationUpdatedTimer;
        return z.l10n.text(stringId, {time: timeString});
      }

      const stringId = this.user().is_me ? z.string.conversationResetTimerYou : z.string.conversationResetTimer;
      return z.l10n.text(stringId);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.RenameMessage = class RenameMessage extends z.entity.SystemMessage {
  constructor() {
    super();

    this.type = z.event.Backend.CONVERSATION.RENAME;
    this.system_message_type = z.message.SystemMessageType.CONVERSATION_RENAME;

    this.caption = ko.pureComputed(() => {
      const identifier = this.user().is_me ? z.string.conversationRenameYou : z.string.conversationRename;
      return z.l10n.text(identifier);
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.PingMessage = class PingMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.PING;

    this.caption = ko.pureComputed(() => {
      const stringId = this.user().is_me ? z.string.conversationPingYou : z.string.conversationPing;
      return z.l10n.text(stringId);
    });

    this.get_icon_classes = ko.pureComputed(() => {
      const show_ping_animation = Date.now() - this.timestamp() < 2000;
      let css_classes = this.accent_color();
      if (show_ping_animation) {
        css_classes += ' ping-animation ping-animation-soft';
      }
      return css_classes;
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.CallMessage = class CallMessage extends z.entity.Message {
  constructor() {
    super();
    this.super_type = z.message.SuperType.CALL;
    this.call_message_type = '';
    this.finished_reason = '';

    this.caption = ko.pureComputed(() => {
      const stringId = this.user().is_me
        ? z.string.conversationVoiceChannelDeactivateYou
        : z.string.conversationVoiceChannelDeactivate;

      return z.l10n.text(stringId);
    });
  }

  /**
   * Check if call message is call activation.
   * @returns {boolean} Is message of type activate
   */
  is_activation() {
    return this.call_message_type === z.message.CALL_MESSAGE_TYPE.ACTIVATED;
  }

  /**
   * Check if call message is call deactivation.
   * @returns {boolean} Is message of type deactivate
   */
  is_deactivation() {
    return this.call_message_type === z.message.CALL_MESSAGE_TYPE.DEACTIVATED;
  }

  was_completed() {
    return this.finished_reason === z.calling.enum.TERMINATION_REASON.COMPLETED;
  }

  was_missed() {
    return this.finished_reason === z.calling.enum.TERMINATION_REASON.MISSED;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.DecryptErrorMessage = class DecryptErrorMessage extends z.entity.Message {
  static get REMOTE_IDENTITY_CHANGED_ERROR() {
    return Proteus.errors.DecryptError.CODE.CASE_204.toString();
  }

  constructor() {
    super();
    this.super_type = z.message.SuperType.UNABLE_TO_DECRYPT;

    this.error_code = '';
    this.client_id = '';

    this.htmlCaption = ko.pureComputed(() => {
      const stringId = this.is_remote_identity_changed()
        ? z.string.conversationUnableToDecrypt2
        : z.string.conversationUnableToDecrypt1;

      const substitutions = {
        replace: {
          user: this.user().first_name(),
        },
        replaceDangerously: {
          '/highlight': '</span>',
          highlight: '<span class="label-bold-xs">',
        },
      };

      return z.l10n.safeHtml(stringId, substitutions);
    });

    this.link = ko.pureComputed(() => {
      const path = this.is_remote_identity_changed()
        ? z.config.URL_PATH.DECRYPT_ERROR_2
        : z.config.URL_PATH.DECRYPT_ERROR_1;
      return z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path);
    });

    this.is_recoverable = ko.pureComputed(() => {
      return this.error_code.toString().startsWith('2') && !this.is_remote_identity_changed();
    });
    this.is_remote_identity_changed = ko.pureComputed(() => {
      return this.error_code.toString() === DecryptErrorMessage.REMOTE_IDENTITY_CHANGED_ERROR;
    });
    this.is_resetting_session = ko.observable(false);

    this.error_message = ko.pureComputed(() => {
      const parts = [];

      if (this.error_code) {
        const error_text = z.l10n.text(z.string.conversationUnableToDecryptErrorMessage);
        parts.push(`${error_text}: <span class='label-bold-xs'>${this.error_code}</span> `);
      }

      if (this.client_id) {
        parts.push(`ID: ${z.util.printDevicesId(this.client_id)}`);
      }

      if (parts.length) {
        return `(${parts.join('')})`;
      }
    });

    this.htmlErrorMessage = this.error_message;
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.VerificationMessage = class VerificationMessage extends z.entity.Message {
  constructor() {
    super();

    this.super_type = z.message.SuperType.VERIFICATION;
    this.affect_order(false);
    this.verificationMessageType = ko.observable();

    this.userEntities = ko.observableArray();
    this.userIds = ko.observableArray();

    this.isSelfClient = ko.pureComputed(() => {
      return this.userIds().length === 1 && this.userIds()[0] === this.user().id;
    });

    this.isTypeNewDevice = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.NEW_DEVICE;
    });
    this.isTypeNewMember = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.NEW_MEMBER;
    });
    this.isTypeUnverified = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.UNVERIFIED;
    });
    this.isTypeVerified = ko.pureComputed(() => {
      return this.verificationMessageType() === z.message.VerificationMessageType.VERIFIED;
    });

    this.captionUser = ko.pureComputed(() => {
      const namesString = z.util.LocalizerUtil.joinNames(this.userEntities(), z.string.Declension.NOMINATIVE);
      return z.util.StringUtil.capitalizeFirstChar(namesString);
    });

    this.captionStartedUsing = ko.pureComputed(() => {
      const hasMultipleUsers = this.userIds().length > 1;
      const stringId = hasMultipleUsers
        ? z.string.conversationDeviceStartedUsingMany
        : z.string.conversationDeviceStartedUsingOne;

      return z.l10n.text(stringId);
    });

    this.captionNewDevice = ko.pureComputed(() => {
      const hasMultipleUsers = this.userIds().length > 1;
      const stringId = hasMultipleUsers
        ? z.string.conversationDeviceNewDeviceMany
        : z.string.conversationDeviceNewDeviceOne;

      return z.l10n.text(stringId);
    });

    this.captionUnverifiedDevice = ko.pureComputed(() => {
      const [firstUserEntity] = this.userEntities();
      const stringId = this.isSelfClient()
        ? z.string.conversationDeviceYourDevices
        : z.string.conversationDeviceUserDevices;

      return z.l10n.text(stringId, firstUserEntity.first_name());
    });
  }

  clickOnDevice() {
    const topic = this.isSelfClient() ? z.event.WebApp.PREFERENCES.MANAGE_DEVICES : z.event.WebApp.SHORTCUT.PEOPLE;
    amplify.publish(topic);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

// Please note: The own user has a "locale"
z.entity.User = class User {
  static get ACCENT_COLOR() {
    return {
      BLUE: '#2391d3',
      GREEN: '#00c800',
      ORANGE: '#ff8900',
      PINK: '#fe5ebd',
      PURPLE: '#9c00fe',
      RED: '#fb0807',
      YELLOW: '#febf02',
    };
  }

  static get CONFIG() {
    return {
      TEMPORARY_GUEST: {
        EXPIRATION_INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE,
        EXPIRATION_THRESHOLD: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
        LIFETIME: z.util.TimeUtil.UNITS_IN_MILLIS.DAY,
      },
    };
  }

  static get THEME() {
    return {
      BLUE: 'theme-blue',
      GREEN: 'theme-green',
      ORANGE: 'theme-orange',
      PINK: 'theme-pink',
      PURPLE: 'theme-purple',
      RED: 'theme-red',
      YELLOW: 'theme-yellow',
    };
  }

  constructor(id = '') {
    this.id = id;
    this.is_me = false;
    this.isService = false;
    this.isSingleSignOn = false;

    this.joaatHash = -1;

    this.accent_id = ko.observable(z.config.ACCENT_ID.BLUE);
    this.accent_theme = ko.pureComputed(
      () => {
        switch (this.accent_id()) {
          case z.config.ACCENT_ID.BLUE:
            return z.entity.User.THEME.BLUE;
          case z.config.ACCENT_ID.GREEN:
            return z.entity.User.THEME.GREEN;
          case z.config.ACCENT_ID.ORANGE:
            return z.entity.User.THEME.ORANGE;
          case z.config.ACCENT_ID.PINK:
            return z.entity.User.THEME.PINK;
          case z.config.ACCENT_ID.PURPLE:
            return z.entity.User.THEME.PURPLE;
          case z.config.ACCENT_ID.RED:
            return z.entity.User.THEME.RED;
          case z.config.ACCENT_ID.YELLOW:
            return z.entity.User.THEME.YELLOW;
          default:
            return z.entity.User.THEME.BLUE;
        }
      },
      this,
      {deferEvaluation: true}
    );

    this.accent_color = ko.pureComputed(
      () => {
        switch (this.accent_id()) {
          case z.config.ACCENT_ID.BLUE:
            return z.entity.User.ACCENT_COLOR.BLUE;
          case z.config.ACCENT_ID.GREEN:
            return z.entity.User.ACCENT_COLOR.GREEN;
          case z.config.ACCENT_ID.ORANGE:
            return z.entity.User.ACCENT_COLOR.ORANGE;
          case z.config.ACCENT_ID.PINK:
            return z.entity.User.ACCENT_COLOR.PINK;
          case z.config.ACCENT_ID.PURPLE:
            return z.entity.User.ACCENT_COLOR.PURPLE;
          case z.config.ACCENT_ID.RED:
            return z.entity.User.ACCENT_COLOR.RED;
          case z.config.ACCENT_ID.YELLOW:
            return z.entity.User.ACCENT_COLOR.YELLOW;
          default:
            return z.entity.User.ACCENT_COLOR.BLUE;
        }
      },
      this,
      {deferEvaluation: true}
    );

    this.email = ko.observable();
    this.phone = ko.observable();

    this.name = ko.observable('');
    this.first_name = ko.pureComputed(() => {
      const [firstName] = this.name().split(' ');
      return firstName || '';
    });

    this.last_name = ko.pureComputed(() => {
      const nameParts = this.name().split(' ');
      if (nameParts.length > 1) {
        return nameParts.pop();
      }
    });

    this.initials = ko.pureComputed(() => {
      let initials = '';
      if (this.first_name() && this.last_name()) {
        const first = z.util.StringUtil.getFirstChar(this.first_name());
        const last = z.util.StringUtil.getFirstChar(this.last_name());
        initials = `${first}${last}`;
      } else {
        initials = this.first_name().slice(0, 2);
      }
      return initials.toUpperCase();
    });

    this.username = ko.observable('');

    this.previewPictureResource = ko.observable();
    this.mediumPictureResource = ko.observable();

    this.connection = ko.observable(new z.connection.ConnectionEntity());

    this.isBlocked = ko.pureComputed(() => this.connection().isBlocked());
    this.isCanceled = ko.pureComputed(() => this.connection().isCanceled());
    this.isConnected = ko.pureComputed(() => this.connection().isConnected());
    this.isIgnored = ko.pureComputed(() => this.connection().isIgnored());
    this.isIncomingRequest = ko.pureComputed(() => this.connection().isIncomingRequest());
    this.isOutgoingRequest = ko.pureComputed(() => this.connection().isOutgoingRequest());
    this.isUnknown = ko.pureComputed(() => this.connection().isUnknown());

    this.inTeam = ko.observable(false);
    this.isGuest = ko.observable(false);
    this.isTemporaryGuest = ko.observable(false);
    this.isTeamMember = ko.observable(false);
    this.teamRole = ko.observable(z.team.TeamRole.ROLE.NONE);
    this.isTeamManager = ko.pureComputed(() => {
      return [z.team.TeamRole.ROLE.ADMIN, z.team.TeamRole.ROLE.OWNER].includes(this.teamRole());
    });
    this.isTeamOwner = ko.pureComputed(() => z.team.TeamRole.ROLE.OWNER === this.teamRole());
    this.teamId = undefined;

    this.isRequest = ko.pureComputed(() => this.connection().isRequest());

    this.devices = ko.observableArray(); // does not include current client/device
    this.is_verified = ko.pureComputed(() => {
      if (this.devices().length === 0 && !this.is_me) {
        return false;
      }
      return this.devices().every(client_et => client_et.meta.isVerified());
    });

    this.availability = ko.observable(z.user.AvailabilityType.NONE);

    this.expirationRemaining = ko.observable(0);
    this.expirationText = ko.observable('');
    this.expirationIsUrgent = ko.observable(false);
    this.expirationRemainingText = ko.observable('');
    this.expirationIntervalId = undefined;
    this.expirationTimeoutId = undefined;
    this.isExpired = ko.observable(false);
  }

  subscribeToChanges() {
    this.availability.subscribe(() => amplify.publish(z.event.WebApp.USER.PERSIST, this));
  }

  add_client(new_client_et) {
    for (const client_et of this.devices()) {
      if (client_et.id === new_client_et.id) {
        return false;
      }
    }

    this.devices.push(new_client_et);

    if (this.is_me) {
      this.devices.sort((client_a, client_b) => new Date(client_b.time) - new Date(client_a.time));
    }

    return true;
  }

  hasActivatedIdentity() {
    return this.email() || this.phone() || this.isSingleSignOn;
  }

  remove_client(client_id) {
    return this.devices.remove(client_et => client_et.id === client_id);
  }

  /**
   * Check whether handle or name matches the given query
   * @param {string} query - Query
   * @param {boolean} is_handle - Query string is handle
   * @param {array} excludedChars - list of chars to exclude from getSlug
   * @returns {undefined} No return value
   */
  matches(query, is_handle, excludedChars = []) {
    if (is_handle) {
      return z.util.StringUtil.startsWith(this.username(), query);
    }
    return z.util.StringUtil.compareTransliteration(this.name(), query, excludedChars) || this.username() === query;
  }

  serialize() {
    return {
      availability: this.availability(),
      id: this.id,
    };
  }

  setGuestExpiration(timestamp) {
    if (this.expirationIntervalId) {
      window.clearInterval(this.expirationIntervalId);
      this.expirationIntervalId = undefined;
    }

    this._setRemainingExpirationTime(timestamp);

    const expirationInterval = User.CONFIG.TEMPORARY_GUEST.EXPIRATION_INTERVAL;
    this.expirationIntervalId = window.setInterval(
      () => this._setRemainingExpirationTime(timestamp),
      expirationInterval
    );

    window.setTimeout(() => {
      this.isExpired(true);
      window.clearInterval(this.expirationIntervalId);
    }, this.expirationRemaining());
  }

  clearExpirationTimeout() {
    if (this.expirationTimeoutId) {
      window.clearTimeout(this.expirationTimeoutId);
      this.expirationTimeoutId = undefined;
    }
  }

  checkGuestExpiration() {
    const checkExpiration = this.isTemporaryGuest() && !this.expirationTimeoutId;
    if (checkExpiration) {
      if (this.isExpired()) {
        return amplify.publish(z.event.WebApp.USER.UPDATE, this.id);
      }

      const timeout = this.expirationRemaining() + User.CONFIG.TEMPORARY_GUEST.EXPIRATION_THRESHOLD;
      this.expirationTimeoutId = window.setTimeout(() => amplify.publish(z.event.WebApp.USER.UPDATE, this.id), timeout);
    }
  }

  _setRemainingExpirationTime(expirationTime) {
    const remainingTime = z.util.NumberUtil.clamp(expirationTime - Date.now(), 0, User.CONFIG.TEMPORARY_GUEST.LIFETIME);
    const remainingMinutes = Math.ceil(remainingTime / z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);

    let timeLeftText = z.string.userRemainingTimeHours;
    let timeValue = 0;

    if (remainingMinutes <= 45) {
      timeLeftText = z.string.userRemainingTimeMinutes;
      const remainingQuarters = Math.max(1, Math.ceil(remainingMinutes / 15));
      timeValue = remainingQuarters * 15;
      this.expirationRemaining(timeValue * z.util.TimeUtil.UNITS_IN_MILLIS.MINUTE);
      this.expirationRemainingText(`${timeValue}m`);
    } else {
      const showOneAndAHalf = remainingMinutes > 60 && remainingMinutes <= 90;
      timeValue = showOneAndAHalf ? 1.5 : Math.ceil(remainingMinutes / 60);
      this.expirationRemaining(timeValue * z.util.TimeUtil.UNITS_IN_MILLIS.HOUR);
      this.expirationRemainingText(`${timeValue}h`);
    }

    this.expirationIsUrgent(remainingMinutes < 120);
    this.expirationText(z.l10n.text(timeLeftText, timeValue));
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.entity = z.entity || {};

z.entity.Conversation = class Conversation {
  static get TIMESTAMP_TYPE() {
    return {
      ARCHIVED: 'archivedTimestamp',
      CLEARED: 'cleared_timestamp',
      LAST_EVENT: 'last_event_timestamp',
      LAST_READ: 'last_read_timestamp',
      LAST_SERVER: 'last_server_timestamp',
      MUTED: 'mutedTimestamp',
    };
  }

  /**
   * Constructs a new conversation entity.
   * @class z.entity.Conversation
   * @param {string} conversation_id - Conversation ID
   */
  constructor(conversation_id = '') {
    this.id = conversation_id;

    this.logger = new z.util.Logger(`z.entity.Conversation (${this.id})`, z.config.LOGGER.OPTIONS);

    this.accessState = ko.observable(z.conversation.ACCESS_STATE.UNKNOWN);
    this.accessCode = ko.observable();
    this.creator = undefined;
    this.name = ko.observable();
    this.team_id = undefined;
    this.type = ko.observable();

    this.is_loaded = ko.observable(false);
    this.is_pending = ko.observable(false);

    this.participating_user_ets = ko.observableArray([]); // Does not include self user
    this.participating_user_ids = ko.observableArray([]);
    this.selfUser = ko.observable();

    this.hasCreationMessage = false;

    this.firstUserEntity = ko.pureComputed(() => this.participating_user_ets()[0]);
    this.availabilityOfUser = ko.pureComputed(() => this.firstUserEntity() && this.firstUserEntity().availability());

    this.isGuest = ko.observable(false);
    this.isManaged = false;

    this.inTeam = ko.pureComputed(() => this.team_id && !this.isGuest());
    this.isGuestRoom = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.GUEST_ROOM);
    this.isTeamOnly = ko.pureComputed(() => this.accessState() === z.conversation.ACCESS_STATE.TEAM.TEAM_ONLY);
    this.withAllTeamMembers = ko.observable(undefined);

    this.isTeam1to1 = ko.pureComputed(() => {
      const isGroupConversation = this.type() === z.conversation.ConversationType.GROUP;
      const hasOneParticipant = this.participating_user_ids().length === 1;
      return isGroupConversation && hasOneParticipant && this.team_id && !this.name();
    });
    this.isGroup = ko.pureComputed(() => {
      const isGroupConversation = this.type() === z.conversation.ConversationType.GROUP;
      return isGroupConversation && !this.isTeam1to1();
    });
    this.is1to1 = ko.pureComputed(() => {
      const is1to1Conversation = this.type() === z.conversation.ConversationType.ONE2ONE;
      return is1to1Conversation || this.isTeam1to1();
    });
    this.isRequest = ko.pureComputed(() => this.type() === z.conversation.ConversationType.CONNECT);
    this.isSelf = ko.pureComputed(() => this.type() === z.conversation.ConversationType.SELF);

    this.hasGuest = ko.pureComputed(() => {
      const hasGuestUser = this.participating_user_ets().some(userEntity => userEntity.isGuest());
      return hasGuestUser && this.isGroup() && this.selfUser() && this.selfUser().inTeam();
    });
    this.hasService = ko.pureComputed(() => this.participating_user_ets().some(userEntity => userEntity.isService));

    // in case this is a one2one conversation this is the connection to that user
    this.connection = ko.observable(new z.connection.ConnectionEntity());
    this.connection.subscribe(connectionEntity => {
      const connectedUserId = connectionEntity && connectionEntity.userId;
      if (connectedUserId && !this.participating_user_ids().includes(connectedUserId)) {
        this.participating_user_ids.push(connectedUserId);
      }
    });

    // E2EE conversation states
    this.archivedState = ko.observable(false).extend({notify: 'always'});
    this.mutedState = ko.observable(z.conversation.NotificationSetting.STATE.EVERYTHING);
    this.verification_state = ko.observable(z.conversation.ConversationVerificationState.UNVERIFIED);

    this.archivedTimestamp = ko.observable(0);
    this.cleared_timestamp = ko.observable(0);
    this.last_event_timestamp = ko.observable(0);
    this.last_read_timestamp = ko.observable(0);
    this.last_server_timestamp = ko.observable(0);
    this.mutedTimestamp = ko.observable(0);

    // Conversation states for view
    this.notificationState = ko.pureComputed(() => {
      const NOTIIFCATION_STATE = z.conversation.NotificationSetting.STATE;
      if (!this.selfUser()) {
        return NOTIIFCATION_STATE.NOTHING;
      }

      const knownNotificationStates = Object.values(NOTIIFCATION_STATE);
      if (knownNotificationStates.includes(this.mutedState())) {
        const isStateMentionsAndReplies = this.mutedState() === NOTIIFCATION_STATE.MENTIONS_AND_REPLIES;
        const isInvalidState = isStateMentionsAndReplies && !this.selfUser().inTeam();

        return isInvalidState ? NOTIIFCATION_STATE.NOTHING : this.mutedState();
      }

      if (typeof this.mutedState() === 'boolean') {
        const migratedMutedState = this.selfUser().inTeam()
          ? NOTIIFCATION_STATE.MENTIONS_AND_REPLIES
          : NOTIIFCATION_STATE.NOTHING;
        return this.mutedState() ? migratedMutedState : NOTIIFCATION_STATE.EVERYTHING;
      }

      return NOTIIFCATION_STATE.EVERYTHING;
    });

    this.is_archived = this.archivedState;
    this.is_cleared = ko.pureComputed(() => this.last_event_timestamp() <= this.cleared_timestamp());
    this.is_verified = ko.pureComputed(() => {
      const hasMappedUsers = this.participating_user_ets().length || !this.participating_user_ids().length;
      const isInitialized = this.selfUser() && hasMappedUsers;
      if (!isInitialized) {
        return undefined;
      }

      const allUserEntities = [this.selfUser()].concat(this.participating_user_ets());
      return allUserEntities.every(userEntity => userEntity.is_verified());
    });

    this.showNotificationsEverything = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.EVERYTHING;
    });
    this.showNotificationsNothing = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.NOTHING;
    });
    this.showNotificationsMentionsAndReplies = ko.pureComputed(() => {
      return this.notificationState() === z.conversation.NotificationSetting.STATE.MENTIONS_AND_REPLIES;
    });

    this.status = ko.observable(z.conversation.ConversationStatus.CURRENT_MEMBER);
    this.removed_from_conversation = ko.pureComputed(() => {
      return this.status() === z.conversation.ConversationStatus.PAST_MEMBER;
    });
    this.isActiveParticipant = ko.pureComputed(() => !this.removed_from_conversation() && !this.isGuest());
    this.isClearable = ko.pureComputed(() => !this.isRequest() && !this.is_cleared());
    this.isLeavable = ko.pureComputed(() => this.isGroup() && !this.removed_from_conversation());
    this.isMutable = ko.pureComputed(() => !this.isRequest() && !this.removed_from_conversation());

    // Messages
    this.localMessageTimer = ko.observable(null);
    this.globalMessageTimer = ko.observable(null);

    this.messageTimer = ko.pureComputed(() => this.globalMessageTimer() || this.localMessageTimer());
    this.hasGlobalMessageTimer = ko.pureComputed(() => this.globalMessageTimer() > 0);

    this.messages_unordered = ko.observableArray();
    this.messages = ko.pureComputed(() =>
      this.messages_unordered().sort((message_a, message_b) => {
        return message_a.timestamp() - message_b.timestamp();
      })
    );

    this.hasAdditionalMessages = ko.observable(true);

    this.messages_visible = ko
      .pureComputed(() => (!this.id ? [] : this.messages().filter(messageEntity => messageEntity.visible())))
      .extend({trackArrayChanges: true});

    // Calling
    this.call = ko.observable(undefined);
    this.hasLocalCall = ko.pureComputed(() => !!this.call() && !this.call().isOngoingOnAnotherClient());

    this.hasActiveCall = ko.pureComputed(() => (this.hasLocalCall() ? this.call().isActiveState() : false));
    this.hasJoinableCall = ko.pureComputed(() => (this.hasLocalCall() ? this.call().canJoinState() : false));

    this.unreadState = ko.pureComputed(() => {
      const unreadState = {
        allEvents: [],
        allMessages: [],
        calls: [],
        otherMessages: [],
        pings: [],
        selfMentions: [],
        selfReplies: [],
      };

      for (let index = this.messages().length - 1; index >= 0; index--) {
        const messageEntity = this.messages()[index];
        if (messageEntity.visible()) {
          const isReadMessage = messageEntity.timestamp() <= this.last_read_timestamp() || messageEntity.user().is_me;
          if (isReadMessage) {
            break;
          }

          const isMissedCall = messageEntity.is_call() && messageEntity.was_missed();
          const isPing = messageEntity.is_ping();
          const isMessage = messageEntity.is_content();
          const isSelfMentioned = isMessage && this.selfUser() && messageEntity.isUserMentioned(this.selfUser().id);
          const isSelfQuoted = isMessage && this.selfUser() && messageEntity.isUserQuoted(this.selfUser().id);

          if (isMissedCall || isPing || isMessage) {
            unreadState.allMessages.push(messageEntity);
          }

          if (isSelfMentioned) {
            unreadState.selfMentions.push(messageEntity);
          } else if (isSelfQuoted) {
            unreadState.selfReplies.push(messageEntity);
          } else if (isMissedCall) {
            unreadState.calls.push(messageEntity);
          } else if (isPing) {
            unreadState.pings.push(messageEntity);
          } else if (isMessage) {
            unreadState.otherMessages.push(messageEntity);
          }

          unreadState.allEvents.push(messageEntity);
        }
      }

      return unreadState;
    });

    /**
     * Display name strategy:
     *
     * 'One-to-One Conversations' and 'Connection Requests':
     * We should not use the conversation name received from the backend as fallback as it will always contain the
     * name of the user who received the connection request initially
     *
     * - Name of the other participant
     * - Name of the other user of the associated connection
     * - "..." if neither of those has been attached yet
     *
     * 'Group Conversation':
     * - Conversation name received from backend
     * - If unnamed, we will create a name from the participant names
     * - Join the user's first names to a comma separated list or uses the user's first name if only one user participating
     * - "..." if the user entities have not yet been attached yet
     */
    this.display_name = ko.pureComputed(() => {
      if (this.isRequest() || this.is1to1()) {
        const [userEntity] = this.participating_user_ets();
        const userName = userEntity && userEntity.name();
        return userName ? userName : '…';
      }

      if (this.isGroup()) {
        if (this.name()) {
          return this.name();
        }

        const hasUserEntities = !!this.participating_user_ets().length;
        if (hasUserEntities) {
          const isJustServices = this.participating_user_ets().every(userEntity => userEntity.isService);
          const joinedNames = this.participating_user_ets()
            .filter(userEntity => isJustServices || !userEntity.isService)
            .map(userEntity => userEntity.first_name())
            .join(', ');

          const maxLength = z.conversation.ConversationRepository.CONFIG.GROUP.MAX_NAME_LENGTH;
          return z.util.StringUtil.truncate(joinedNames, maxLength, false);
        }

        const hasUserIds = !!this.participating_user_ids().length;
        if (!hasUserIds) {
          return z.l10n.text(z.string.conversationsEmptyConversation);
        }
      }

      return '…';
    });

    this.shouldPersistStateChanges = false;
    this.publishPersistState = _.debounce(() => amplify.publish(z.event.WebApp.CONVERSATION.PERSIST_STATE, this), 100);

    this._initSubscriptions();
  }

  _initSubscriptions() {
    [
      this.archivedState,
      this.archivedTimestamp,
      this.cleared_timestamp,
      this.messageTimer,
      this.isGuest,
      this.last_event_timestamp,
      this.last_read_timestamp,
      this.last_server_timestamp,
      this.mutedState,
      this.mutedTimestamp,
      this.name,
      this.participating_user_ids,
      this.status,
      this.type,
      this.verification_state,
    ].forEach(property => property.subscribe(this.persistState.bind(this)));
  }

  persistState() {
    if (this.shouldPersistStateChanges) {
      this.publishPersistState();
    }
  }

  setStateChangePersistence(persistChanges) {
    this.shouldPersistStateChanges = persistChanges;
  }

  /**
   * Remove all message from conversation unless there are unread messages.
   * @returns {undefined} No return value
   */
  release() {
    if (!this.unreadState().allEvents.length) {
      this.remove_messages();
      this.is_loaded(false);
      this.hasAdditionalMessages(true);
    }
  }

  /**
   * Set the timestamp of a given type.
   * @note This will only increment timestamps
   * @param {string|number} timestamp - Timestamp to be set
   * @param {Conversation.TIMESTAMP_TYPE} type - Type of timestamp to be updated
   * @param {boolean} forceUpdate - set the timestamp regardless of previous timestamp value (no checks)
   * @returns {boolean|number} Timestamp value which can be 'false' (boolean) if there is no timestamp
   */
  setTimestamp(timestamp, type, forceUpdate = false) {
    if (_.isString(timestamp)) {
      timestamp = window.parseInt(timestamp, 10);
    }

    const entityTimestamp = this[type];
    if (!entityTimestamp) {
      throw new z.error.ConversationError(z.error.ConversationError.TYPE.INVALID_PARAMETER);
    }

    const updatedTimestamp = forceUpdate ? timestamp : this._incrementTimeOnly(entityTimestamp(), timestamp);

    if (updatedTimestamp !== false) {
      entityTimestamp(updatedTimestamp);
    }
    return updatedTimestamp;
  }

  /**
   * Increment only on timestamp update
   * @param {number} currentTimestamp - Current timestamp
   * @param {number} updatedTimestamp - Timestamp from update
   * @returns {number|boolean} Updated timestamp or false if not increased
   */
  _incrementTimeOnly(currentTimestamp, updatedTimestamp) {
    const timestampIncreased = updatedTimestamp > currentTimestamp;
    return timestampIncreased ? updatedTimestamp : false;
  }

  /**
   * Adds a single message to the conversation.
   * @param {z.entity.Message} messageEntity - Message entity to be added to the conversation.
   * @param {boolean} replaceDuplicate - If a duplicate (or a message that should be replaced) already exists, replace it with the new entity.
   * @returns {z.entity.Message | undefined} replacedEntity - If a message was replaced in the conversation, returns the original message
   */
  add_message(messageEntity, replaceDuplicate = false) {
    if (messageEntity) {
      const messageWithLinkPreview = () => this._findDuplicate(messageEntity.id, messageEntity.from);
      const editedMessage = () => this._findDuplicate(messageEntity.replacing_message_id, messageEntity.from);
      const entityToReplace = messageWithLinkPreview() || editedMessage();
      this.update_timestamps(messageEntity);
      if (entityToReplace) {
        if (replaceDuplicate) {
          if (messageEntity.is_content()) {
            messageEntity.quote(entityToReplace.quote());
          }
          const duplicateIndex = this.messages_unordered.indexOf(entityToReplace);
          this.messages_unordered.splice(duplicateIndex, 1, messageEntity);
        }
        // The duplicated message has been treated (either replaced or ignored). Our job here is done.
        return entityToReplace;
      }
      this.messages_unordered.push(messageEntity);
      amplify.publish(z.event.WebApp.CONVERSATION.MESSAGE.ADDED, messageEntity);
    }
  }

  /**
   * Adds multiple messages to the conversation.
   * @param {Array<z.entity.Message>} message_ets - Array of message entities to be added to the conversation
   * @returns {undefined} No return value
   */
  add_messages(message_ets) {
    message_ets = message_ets.map(message_et => this._checkForDuplicate(message_et)).filter(message_et => message_et);

    // in order to avoid multiple db writes check the messages from the end and stop once
    // we found a message from self user
    for (let counter = message_ets.length - 1; counter >= 0; counter--) {
      const message_et = message_ets[counter];
      if (message_et.user() && message_et.user().is_me) {
        this.update_timestamps(message_et);
        break;
      }
    }

    z.util.koArrayPushAll(this.messages_unordered, message_ets);
  }

  getFirstUnreadSelfMention() {
    return this.unreadState()
      .selfMentions.slice()
      .pop();
  }

  get_last_known_timestamp(currentTimestamp) {
    const last_known_timestamp = Math.max(this.last_server_timestamp(), this.last_event_timestamp());
    return last_known_timestamp || currentTimestamp;
  }

  get_latest_timestamp(currentTimestamp) {
    return Math.max(this.last_server_timestamp(), this.last_event_timestamp(), currentTimestamp);
  }

  get_next_iso_date(currentTimestamp) {
    if (!_.isNumber(currentTimestamp)) {
      currentTimestamp = Date.now();
    }
    const timestamp = Math.max(this.last_server_timestamp() + 1, currentTimestamp);
    return new Date(timestamp).toISOString();
  }

  getNumberOfServices() {
    return this.participating_user_ets().filter(userEntity => userEntity.isService).length;
  }

  getNumberOfParticipants(countSelf = true, countServices = true) {
    const adjustCountForSelf = countSelf && !this.removed_from_conversation() ? 1 : 0;
    const adjustCountForServices = countServices ? 0 : this.getNumberOfServices();

    return this.participating_user_ids().length + adjustCountForSelf - adjustCountForServices;
  }

  getNumberOfClients() {
    const participantsMapped = this.participating_user_ids().length === this.participating_user_ets().length;
    if (participantsMapped) {
      return this.participating_user_ets().reduce((accumulator, userEntity) => {
        return userEntity.devices().length
          ? accumulator + userEntity.devices().length
          : accumulator + z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
      }, this.selfUser().devices().length);
    }

    return this.getNumberOfParticipants() * z.client.ClientRepository.CONFIG.AVERAGE_NUMBER_OF_CLIENTS;
  }

  /**
   * Prepends messages with new batch of messages.
   * @param {Array<z.entity.Message>} message_ets - Array of messages to be added to conversation
   * @returns {undefined} No return value
   */
  prepend_messages(message_ets) {
    message_ets = message_ets.map(message_et => this._checkForDuplicate(message_et)).filter(message_et => message_et);

    z.util.koArrayUnshiftAll(this.messages_unordered, message_ets);
  }

  /**
   * Removes message from the conversation by message id.
   * @param {string} message_id - ID of the message entity to be removed from the conversation
   * @returns {undefined} No return value
   */
  remove_message_by_id(message_id) {
    this.messages_unordered.remove(message_et => message_id && message_id === message_et.id);
  }

  /**
   * Removes messages from the conversation.
   * @param {number} [timestamp] - Optional timestamp which messages should be removed
   * @returns {undefined} No return value
   */
  remove_messages(timestamp) {
    if (timestamp && _.isNumber(timestamp)) {
      return this.messages_unordered.remove(message_et => timestamp >= message_et.timestamp());
    }
    this.messages_unordered.removeAll();
  }

  shouldUnarchive() {
    if (!this.archivedState() || this.showNotificationsNothing()) {
      return false;
    }

    const isNewerMessage = messageEntity => messageEntity.timestamp() > this.archivedTimestamp();

    const {allEvents, allMessages, selfMentions, selfReplies} = this.unreadState();
    if (this.showNotificationsMentionsAndReplies()) {
      const mentionsAndReplies = selfMentions.concat(selfReplies);
      return mentionsAndReplies.some(isNewerMessage);
    }

    const hasNewMessage = allMessages.some(isNewerMessage);
    if (hasNewMessage) {
      return true;
    }

    return allEvents.some(messageEntity => {
      if (!isNewerMessage(messageEntity)) {
        return false;
      }

      const isCallActivation = messageEntity.is_call() && messageEntity.is_activation();
      const isMemberJoin = messageEntity.is_member() && messageEntity.isMemberJoin();
      const wasSelfUserAdded = isMemberJoin && messageEntity.isUserAffected(this.selfUser().id);

      return isCallActivation || wasSelfUserAdded;
    });
  }

  /**
   * Checks for message duplicates.
   *
   * @private
   * @param {z.entity.Message} messageEntity - Message entity to be added to the conversation
   * @returns {z.entity.Message|undefined} Message if it is not a duplicate
   */
  _checkForDuplicate(messageEntity) {
    if (messageEntity) {
      const existingMessageEntity = this._findDuplicate(messageEntity.id, messageEntity.from);
      if (existingMessageEntity) {
        const logData = {additionalMessage: messageEntity, existingMessage: existingMessageEntity};
        this.logger.warn(`Filtered message '${messageEntity.id}' as duplicate in view`, logData);
        return undefined;
      }
      return messageEntity;
    }
  }

  _findDuplicate(messageId, from) {
    if (messageId) {
      return this.messages_unordered().find(messageEntity => {
        const sameId = messageEntity.id === messageId;
        const sameSender = messageEntity.from === from;
        return sameId && sameSender;
      });
    }
  }

  update_timestamp_server(time, is_backend_timestamp = false) {
    if (is_backend_timestamp) {
      const timestamp = new Date(time).getTime();

      if (!_.isNaN(timestamp)) {
        this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_SERVER);
      }
    }
  }

  /**
   * Update information about conversation activity from single message.
   *
   * @private
   * @param {z.entity.Message} message_et - Message to be added to conversation
   * @returns {undefined} No return value
   */
  update_timestamps(message_et) {
    if (message_et) {
      const timestamp = message_et.timestamp();

      if (timestamp <= this.last_server_timestamp()) {
        if (message_et.timestamp_affects_order()) {
          this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_EVENT);

          const from_self = message_et.user() && message_et.user().is_me;
          if (from_self) {
            this.setTimestamp(timestamp, z.entity.Conversation.TIMESTAMP_TYPE.LAST_READ);
          }
        }
      }
    }
  }

  /**
   * Get all messages.
   * @returns {Array<z.entity.Message>} Array of all message in the conversation
   */
  get_all_messages() {
    return this.messages();
  }

  /**
   * Get the first message of the conversation.
   * @returns {z.entity.Message|undefined} First message entity or undefined
   */
  getFirstMessage() {
    return this.messages()[0];
  }

  /**
   * Get the last message of the conversation.
   * @returns {z.entity.Message|undefined} Last message entity or undefined
   */
  getLastMessage() {
    return this.messages()[this.messages().length - 1];
  }

  /**
   * Get the message before a given message.
   * @param {z.entity.Message} message_et - Message to look up from
   * @returns {z.entity.Message | undefined} Previous message
   */
  get_previous_message(message_et) {
    const messages_visible = this.messages_visible();
    const message_index = messages_visible.indexOf(message_et);
    if (message_index > 0) {
      return messages_visible[message_index - 1];
    }
  }

  /**
   * Get the last text message that was added by self user.
   * @returns {z.entity.Message} Last message edited
   */
  get_last_editable_message() {
    const messages = this.messages();
    for (let index = messages.length - 1; index >= 0; index--) {
      const message_et = messages[index];
      if (message_et.is_editable()) {
        return message_et;
      }
    }
  }

  /**
   * Get the last delivered message.
   * @returns {z.entity.Message} Last delivered message
   */
  getLastDeliveredMessage() {
    return this.messages()
      .slice()
      .reverse()
      .find(messageEntity => {
        const isDelivered = messageEntity.status() === z.message.StatusType.DELIVERED;
        return isDelivered && messageEntity.user().is_me;
      });
  }

  /**
   * Get a message by it's unique ID.
   * Only lookup in the loaded message list which is a limited view of all the messages in DB.
   *
   * @param {string} messageId - ID of message to be retrieved
   * @returns {z.entity.Message|undefined} Message with ID or undefined
   */
  getMessage(messageId) {
    return this.messages().find(messageEntity => messageEntity.id === messageId);
  }

  /**
   * Get Number of pending uploads for this conversation.
   * @returns {number} Count of pending uploads
   */
  get_number_of_pending_uploads() {
    const pendingUploads = [];

    for (const messageEntity of this.messages()) {
      const [assetEntity] = (messageEntity.assets && messageEntity.assets()) || [];
      const isPendingUpload = assetEntity && assetEntity.pending_upload && assetEntity.pending_upload();
      if (isPendingUpload) {
        pendingUploads.push(messageEntity);
      }
    }

    return pendingUploads.length;
  }

  updateGuests() {
    this.getTemporaryGuests().forEach(userEntity => userEntity.checkGuestExpiration());
  }

  getTemporaryGuests() {
    const userEntities = this.selfUser()
      ? this.participating_user_ets().concat(this.selfUser())
      : this.participating_user_ets();
    return userEntities.filter(userEntity => userEntity.isTemporaryGuest());
  }

  getUsersWithUnverifiedClients() {
    const userEntities = this.selfUser()
      ? this.participating_user_ets().concat(this.selfUser())
      : this.participating_user_ets();
    return userEntities.filter(userEntity => !userEntity.is_verified());
  }

  supportsVideoCall(isCreatingUser = false) {
    if (this.is1to1()) {
      return true;
    }

    const participantCount = this.getNumberOfParticipants(true, false);
    const passesParticipantLimit = participantCount <= z.calling.CallingRepository.CONFIG.MAX_VIDEO_PARTICIPANTS;

    if (!passesParticipantLimit) {
      return false;
    }

    if (this.selfUser().inTeam()) {
      return true;
    }

    if (isCreatingUser) {
      return false;
    }

    return this.call() && this.call().isRemoteVideoCall();
  }

  serialize() {
    return {
      archived_state: this.archivedState(),
      archived_timestamp: this.archivedTimestamp(),
      cleared_timestamp: this.cleared_timestamp(),
      ephemeral_timer: this.localMessageTimer(),
      global_message_timer: this.globalMessageTimer(),
      id: this.id,
      is_guest: this.isGuest(),
      is_managed: this.isManaged,
      last_event_timestamp: this.last_event_timestamp(),
      last_read_timestamp: this.last_read_timestamp(),
      last_server_timestamp: this.last_server_timestamp(),
      muted_state: this.mutedState(),
      muted_timestamp: this.mutedTimestamp(),
      name: this.name(),
      others: this.participating_user_ids(),
      status: this.status(),
      team_id: this.team_id,
      type: this.type(),
      verification_state: this.verification_state(),
    };
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.AvailabilityContextMenu = {
  show: (event, method, elementName) => {
    const entries = [
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.NONE, method),
        label: z.l10n.text(z.string.userAvailabilityNone),
        title: z.l10n.text(z.string.userAvailabilityNone),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.AVAILABLE, method),
        label: z.l10n.text(z.string.userAvailabilityAvailable),
        title: z.l10n.text(z.string.userAvailabilityAvailable),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.BUSY, method),
        label: z.l10n.text(z.string.userAvailabilityBusy),
        title: z.l10n.text(z.string.userAvailabilityBusy),
      },
      {
        click: () => amplify.publish(z.event.WebApp.USER.SET_AVAILABILITY, z.user.AvailabilityType.AWAY, method),
        label: z.l10n.text(z.string.userAvailabilityAway),
        title: z.l10n.text(z.string.userAvailabilityAway),
      },
    ];

    z.ui.Context.from(event, entries, elementName);
  },
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Context = (() => {
  const _addListeners = () => {
    window.addEventListener('wheel', _onWheel);
    window.addEventListener('keydown', _onKeyDown);
    window.addEventListener('mousedown', _onMouseDown);
    window.addEventListener('resize', _cleanup);
  };

  const _onKeyDown = keyboardEvent => {
    keyboardEvent.preventDefault();

    if (z.util.KeyboardUtil.isEscapeKey(keyboardEvent)) {
      return _cleanup();
    }

    const expectedKeys = [z.util.KeyboardUtil.KEY.ARROW_UP, z.util.KeyboardUtil.KEY.ARROW_DOWN];

    if (z.util.KeyboardUtil.isOneOfKeys(keyboardEvent, expectedKeys)) {
      return _rotateItem(keyboardEvent.key);
    }

    if (z.util.KeyboardUtil.isEnterKey(keyboardEvent)) {
      _triggerItem();
    }
  };

  const _onMouseDown = event => {
    const entry = document.querySelector('.ctx-menu');
    const shouldCloseMenu = entry && !entry.contains(event.target);
    if (shouldCloseMenu) {
      _cleanup();
    }
  };

  const _onWheel = event => event.preventDefault();

  const _rotateItem = key => {
    const entries = Array.from(document.querySelectorAll('.ctx-menu-item'));
    const entry = document.querySelector('.ctx-menu-item.selected');

    if (entries.length) {
      if (!entry) {
        const index = key === z.util.KeyboardUtil.KEY.ARROW_UP ? entries.length - 1 : 0;
        return entries[index].classList.add('selected');
      }

      const direction = key === z.util.KeyboardUtil.KEY.ARROW_UP ? -1 : 1;
      const nextIndext = (entries.indexOf(entry) + direction + entries.length) % entries.length;
      const nextEntry = entries[nextIndext];

      nextEntry.classList.add('selected');
      entry.classList.remove('selected');
    }
  };

  const _removeListeners = () => {
    window.removeEventListener('wheel', _onWheel);
    window.removeEventListener('keydown', _onKeyDown);
    window.removeEventListener('mousedown', _onMouseDown);
    window.removeEventListener('resize', _cleanup);
  };

  const _triggerItem = () => {
    const entry = document.querySelector('.ctx-menu-item.selected');
    if (entry) {
      entry.click();
    }
  };

  const _cleanup = () => {
    Array.from(document.querySelectorAll('.ctx-menu')).forEach(menu => menu.remove());
    _removeListeners();
  };

  const _build = (entries, identifier) => {
    const menu = document.createElement('div');
    menu.classList.add('ctx-menu');

    entries.forEach(entry => {
      const element = document.createElement('div');
      element.setAttribute('data-uie-name', identifier || 'ctx-menu');
      element.setAttribute('title', entry.title || entry.label || '');
      element.classList.add('ctx-menu-item');
      element.innerText = entry.label;

      element.onclick = event => {
        event.stopPropagation();
        _cleanup();
        entry.click();
      };

      element.onmouseenter = () => {
        const selectedEntry = document.querySelector('.ctx-menu-item.selected');
        if (selectedEntry) {
          selectedEntry.classList.remove('selected');
        }
      };

      menu.appendChild(element);
    });

    return menu;
  };

  return {
    /**
     * Build and display custom context menu
     * @param {Event} event - menu will appear at currentTarget position
     * @param {Array} entries - configuration to build the menu {label: 'label', click: function() {}}
     * @param {string} identifier - data-uie-name added to all entries
     * @returns {undefined}
     */
    from: (event, entries, identifier) => {
      event.preventDefault();
      event.stopPropagation();

      _cleanup();

      const clickX = event.clientX;
      const clickY = event.clientY;

      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      const menu = _build(entries, identifier);
      menu.style.visibility = 'hidden';
      document.body.appendChild(menu);

      const menuWidth = menu.offsetWidth;
      const menuHeight = menu.offsetHeight;

      menu.style.left = `${windowWidth - clickX < menuWidth ? clickX - menuWidth : clickX}px`;
      menu.style.top = `${windowHeight - clickY < menuHeight ? clickY - menuHeight : clickY}px`;
      menu.style.visibility = '';

      _addListeners();
    },
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Modal = class Modal {
  static get CLASS() {
    return {
      FADE_IN: 'modal-fadein',
      SHOW: 'modal-show',
    };
  }

  constructor(modal, hideCallback, beforeHideCallback) {
    this._hide = this._hide.bind(this);
    this.handleClick = this.handleClick.bind(this);

    this.modal = typeof modal === 'string' ? document.querySelector(modal) : modal;
    this.hideCallback = hideCallback;
    this.beforeHideCallback = beforeHideCallback;

    this.autoclose = true;

    keyboardJS.bind('esc', this._hide);

    if (this.modal) {
      this.modal.addEventListener('click', this.handleClick);
    }
  }

  handleClick(event) {
    if (event.target === this.modal) {
      this._hide();
    }
  }

  _hide() {
    if (this.autoclose) {
      this.hide();
    }
  }

  show() {
    if (this.modal) {
      this.modal.classList.add(Modal.CLASS.SHOW);
      setTimeout(() => this.modal.classList.add(Modal.CLASS.FADE_IN), 50);
    }
  }

  hide(callback) {
    this.callOptional(this.beforeHideCallback);

    if (this.modal) {
      this.modal.classList.remove(Modal.CLASS.FADE_IN);
      const transitionendPromise = new Promise(resolve => this.modal.addEventListener('transitionend', resolve));
      const timeoutPromise = new Promise(resolve => {
        const {transitionDelay, transitionDuration} = getComputedStyle(this.modal, '::before');

        const delays = transitionDelay.split(',').map(parseFloat);
        const durations = transitionDuration.split(',').map(parseFloat);

        const totals = delays.map((delay, index) => delay + durations[index]);
        const longestDelay = Math.max(...totals);

        setTimeout(resolve, longestDelay * 1000);
      });

      Promise.race([transitionendPromise, timeoutPromise]).then(() => {
        if (this.modal) {
          this.modal.classList.remove(Modal.CLASS.SHOW);
        }
        this.callOptional(this.hideCallback);
        this.callOptional(callback);
      });
    }
  }

  callOptional(fn) {
    if (typeof fn === 'function') {
      return fn();
    }
  }

  toggle() {
    if (this.isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }

  isShown() {
    return !!this.modal && this.modal.classList.contains(Modal.CLASS.SHOW);
  }

  isHidden() {
    return !this.isShown();
  }

  setAutoclose(autoclose) {
    this.autoclose = autoclose;
  }

  destroy() {
    if (this.modal) {
      this.modal.removeEventListener('click', this.handleClick);
    }
    keyboardJS.unbind('esc', this._hide);
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

/**
 * Keeps track of elements that are overlayed by other elemenst (thus not visible on screen).
 *
 */
z.ui.OverlayedObserver = (() => {
  // keeps track of all the elements we need to check when there is a mutation
  const overlayedElements = new Map();

  const checkOverlayedElements = mutations => {
    mutations.forEach(({removedNodes}) => {
      if (removedNodes && removedNodes.length) {
        overlayedElements.forEach((onVisible, element) => {
          if (!isOverlayed(element)) {
            onVisible();
            removeElement(element);
          }
        });
      }
    });
  };

  const mutationObserver = new MutationObserver(checkOverlayedElements);

  /**
   * Returns true if an element is above the element being watched.
   *
   * @param {HTMLElement} domElement - the element we want to check.
   * @returns {boolean} Is the element overlayed.
   */
  const isOverlayed = domElement => {
    const box = domElement.getBoundingClientRect();
    const middlePointX = (box.right + box.left) / 2;
    const middlePointY = (box.bottom + box.top) / 2;
    const elementAtPoint = document.elementFromPoint(middlePointX, middlePointY);
    return elementAtPoint && domElement !== elementAtPoint && !domElement.contains(elementAtPoint);
  };

  const addElement = (element, onVisible) => {
    if (!isOverlayed(element)) {
      return onVisible();
    }
    if (overlayedElements.size === 0) {
      mutationObserver.observe(document.body, {childList: true, subtree: true});
    }
    overlayedElements.set(element, onVisible);
  };

  const removeElement = element => {
    overlayedElements.delete(element);
    if (overlayedElements.size < 1) {
      mutationObserver.disconnect();
    }
  };

  return {onElementVisible: addElement, removeElement};
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.ShortcutType = {
  ADD_PEOPLE: 'add_people',
  ARCHIVE: 'archive',
  CALL_MUTE: 'mute_call',
  CALL_REJECT: 'reject',
  DEBUG: 'debug',
  NEXT: 'next',
  NOTIFICATIONS: 'notifications',
  PEOPLE: 'people',
  PING: 'ping',
  PREV: 'prev',
  START: 'start',
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.Shortcut = (() => {
  const SHORTCUT_MAP = {
    [z.ui.ShortcutType.ADD_PEOPLE]: {
      event: z.event.WebApp.SHORTCUT.ADD_PEOPLE,
      shortcut: {
        electron: {
          macos: 'command + shift + k',
          menu: true,
          pc: 'ctrl + shift + k',
        },
        webapp: {
          macos: 'command + shift + k',
          pc: 'ctrl + shift + k',
        },
      },
    },
    [z.ui.ShortcutType.ARCHIVE]: {
      event: z.event.WebApp.SHORTCUT.ARCHIVE,
      shortcut: {
        electron: {
          macos: 'command + d',
          menu: true,
          pc: 'ctrl + d',
        },
        webapp: {
          macos: 'command + alt + shift + d',
          pc: 'ctrl + alt + d',
        },
      },
    },
    [z.ui.ShortcutType.PREV]: {
      event: z.event.WebApp.SHORTCUT.PREV,
      shortcut: {
        electron: {
          macos: 'command + alt + down',
          menu: true,
          pc: 'alt + shift + down',
        },
        webapp: {
          macos: 'command + alt + down',
          pc: 'alt + shift + down',
        },
      },
    },
    [z.ui.ShortcutType.NEXT]: {
      event: z.event.WebApp.SHORTCUT.NEXT,
      shortcut: {
        electron: {
          macos: 'command + alt + up',
          menu: true,
          pc: 'alt + shift + up',
        },
        webapp: {
          macos: 'command + alt + up',
          pc: 'alt + shift + up',
        },
      },
    },
    [z.ui.ShortcutType.NOTIFICATIONS]: {
      event: z.event.WebApp.SHORTCUT.SILENCE,
      shortcut: {
        electron: {
          macos: 'command + alt + m',
          menu: true,
          pc: 'ctrl + alt + m',
        },
        webapp: {
          macos: 'command + alt + m',
          pc: 'ctrl + alt + m',
        },
      },
    },
    [z.ui.ShortcutType.PING]: {
      event: z.event.WebApp.SHORTCUT.PING,
      shortcut: {
        electron: {
          macos: 'command + k',
          menu: true,
          pc: 'ctrl + k',
        },
        webapp: {
          macos: 'command + alt + k',
          pc: 'ctrl + alt + k',
        },
      },
    },
    [z.ui.ShortcutType.PEOPLE]: {
      event: z.event.WebApp.SHORTCUT.PEOPLE,
      shortcut: {
        electron: {
          macos: 'command + i',
          menu: true,
          pc: 'ctrl + i',
        },
        webapp: {
          macos: 'command + alt + shift + i',
          pc: 'ctrl + alt + i',
        },
      },
    },
    [z.ui.ShortcutType.START]: {
      event: z.event.WebApp.SHORTCUT.START,
      shortcut: {
        electron: {
          macos: 'command + n',
          menu: true,
          pc: 'ctrl + n',
        },
        webapp: {
          macos: 'command + alt + graveaccent', // KeyboardJS fires this when using cmd + alt + n
          pc: 'ctrl + alt + ,',
        },
      },
    },
  };

  const _registerEvent = (platformSpecificShortcut, event) => {
    // bind also 'command + alt + n' for start shortcut
    if (z.util.StringUtil.includes(platformSpecificShortcut, 'graveaccent')) {
      const replacedShortcut = platformSpecificShortcut.replace('graveaccent', 'n');
      _registerEvent(replacedShortcut, event);
    }

    return keyboardJS.on(platformSpecificShortcut, inputEvent => {
      keyboardJS.releaseKey(inputEvent.keyCode);

      // Hotfix WEBAPP-1916
      const ignoreEvent = z.util.StringUtil.includes(platformSpecificShortcut, 'command') && !inputEvent.metaKey;
      if (!ignoreEvent) {
        inputEvent.preventDefault();
        amplify.publish(event);
      }
    });
  };

  const _getBeautifiedShortcutMac = shortcut => {
    return shortcut
      .replace(/\+/g, '')
      .replace(/\s+/g, '')
      .replace('alt', '⌥')
      .replace('command', '⌘')
      .replace('shift', '⇧')
      .replace('up', '↑')
      .replace('down', '↓')
      .replace('graveaccent', 'n')
      .toUpperCase();
  };

  const _getBeautifiedShortcutWin = shortcut => {
    return shortcut
      .replace('up', '↑')
      .replace('down', '↓')
      .replace('graveaccent', 'n')
      .replace(/\w+/g, string => z.util.StringUtil.capitalizeFirstChar(string));
  };

  const _getShortcut = shortcutName => {
    const platform = z.util.Environment.desktop ? 'electron' : 'webapp';
    const platformShortcuts = SHORTCUT_MAP[shortcutName].shortcut[platform];
    return z.util.Environment.os.mac ? platformShortcuts.macos : platformShortcuts.pc;
  };

  const _getShortcutTooltip = shortcutName => {
    const shortcut = _getShortcut(shortcutName);
    if (shortcut) {
      return z.util.Environment.os.mac ? _getBeautifiedShortcutMac(shortcut) : _getBeautifiedShortcutWin(shortcut);
    }
  };

  const _init = () => {
    for (const shortcut in SHORTCUT_MAP) {
      const shortcutData = SHORTCUT_MAP[shortcut];
      const isMenuShortcut = z.util.Environment.desktop && shortcutData.shortcut.electron.menu;

      if (!isMenuShortcut) {
        _registerEvent(_getShortcut(shortcut), shortcutData.event);
      }
    }
  };

  _init();

  return {
    getBeautifiedShortcutMac: _getBeautifiedShortcutMac,
    getBeautifiedShortcutWin: _getBeautifiedShortcutWin,
    getShortcut: _getShortcut,
    getShortcutTooltip: _getShortcutTooltip,
    shortcutMap: SHORTCUT_MAP,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.ViewportObserver = (() => {
  const observedElements = new Map();
  const intersectionObserver = (() => {
    const onIntersect = entries => {
      entries.forEach(({isIntersecting, target: element}) => {
        if (isIntersecting) {
          intersectionObserver.unobserve(element);

          const onElementIntersects = observedElements.get(element);
          if (onElementIntersects) {
            onElementIntersects();
            _removeElement(element);
          }
        }
      });
    };

    const options = {root: null, rootMargin: '0px', threshold: 0.0};
    return new IntersectionObserver(onIntersect, options);
  })();

  const _addElement = (element, callback) => {
    observedElements.set(element, callback);
    intersectionObserver.observe(element);
  };

  const _removeElement = element => {
    observedElements.delete(element);
    intersectionObserver.unobserve(element);
  };

  return {
    addElement: _addElement,
    removeElement: _removeElement,
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.ui = z.ui || {};

z.ui.WindowHandler = class WindowHandler {
  constructor() {
    this.init = this.init.bind(this);
    this.logger = new z.util.Logger('z.ui.WindowHandler', z.config.LOGGER.OPTIONS);

    this.height = 0;
    this.width = 0;

    this.isVisible = true;

    return this;
  }

  init() {
    this.width = $(window).width();
    this.height = $(window).height();
    this._listenToUnhandledPromiseRejection();

    document.addEventListener('visibilitychange', () => {
      const isVisible = document.visibilityState === 'visible';
      this.logger.info(`Webapp is ${isVisible ? 'visible' : 'hidden'}`);
    });

    return this;
  }

  _listenToUnhandledPromiseRejection() {
    $(window).on('unhandledrejection', event => {
      const promiseRejectionEvent = event.originalEvent;
      const error = promiseRejectionEvent.reason || {};

      const isDegraded = error.type === z.error.ConversationError.TYPE.DEGRADED_CONVERSATION_CANCELLATION;
      if (isDegraded) {
        this.logger.log('User has canceled sending a message to a degraded conversation.');
        promiseRejectionEvent.preventDefault();
        promiseRejectionEvent.stopPropagation();
        return false;
      }
    });
  }
};

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

//@ts-check

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.SingleInstanceHandler = (() => {
  let checkIntervalId = undefined;

  const CONFIG = {
    COOKIE_NAME: 'app_opened',
    INTERVAL: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND,
  };

  return class SingleInstanceHandler {
    /**
     * Class responsible for checking that only the current instance of the app is running.
     *
     * @param {function=} onOtherInstanceStarted - A callback to be called if another instance starts.
     *    If provided, will also run an interval that checks the instance integrity once an instance is registrated
     */
    constructor(onOtherInstanceStarted) {
      this.instanceId = undefined;
      this.onOtherInstanceStarted = onOtherInstanceStarted;
    }

    /**
     * Set the cookie to verify we are running a single instace tab.
     * Returns true if the instance has been registered successfully.
     * Returns false if the app is already running in another instance.
     *
     * Side Effects: will also start the interval check if a callback was provided in the constructor
     *
     * @param {string} instanceId - The instance id to register.
     * @returns {boolean} - Has the app being registered successfully.
     */
    registerInstance(instanceId) {
      this.instanceId = instanceId;
      const cookieName = CONFIG.COOKIE_NAME;
      if (!!Cookies.get(cookieName)) {
        return false;
      }
      Cookies.set(cookieName, {appInstanceId: this.instanceId});
      if (this.onOtherInstanceStarted) {
        this._startSingleInstanceCheck();
      }
      return true;
    }

    /**
     * Removes the cookie that keeps track of the running instance.
     *
     * Side Effects: will also stop the interval check
     *
     * @param {boolean} forceRemoval - Do not check that the instance removing it is the current instance.
     * @returns {void} - Returns nothing.
     */
    deregisterInstance(forceRemoval = false) {
      const singleInstanceCookie = Cookies.getJSON(CONFIG.COOKIE_NAME);

      const isOwnInstanceId = singleInstanceCookie && singleInstanceCookie.appInstanceId === this.instanceId;
      if (forceRemoval || isOwnInstanceId) {
        Cookies.remove(CONFIG.COOKIE_NAME);
        this._stopSingleInstanceCheck();
      }
    }

    /**
     * Returns true if another instance is running.
     * Does not check for the id of the running instance and thus cannot be
     * invoked once the registering of the current instance has been done.
     *
     * @param {Function} listener - A listener to be removed.
     * @throws {Error} - When the current app has already been registered.
     * @returns {void} - Returns nothing.
     */
    hasOtherRunningInstance() {
      if (this.instanceId) {
        throw new Error('Current instance has been registered, cannot check other running instances');
      }

      return !!Cookies.get(CONFIG.COOKIE_NAME);
    }

    _isSingleRunningInstance() {
      if (z.util.Environment.electron) {
        return true;
      }
      const singleInstanceCookie = Cookies.getJSON(CONFIG.COOKIE_NAME);

      return singleInstanceCookie && singleInstanceCookie.appInstanceId === this.instanceId;
    }

    _checkSingleInstance() {
      if (!this._isSingleRunningInstance()) {
        // warn listeners if the app has started in another instance
        this.onOtherInstanceStarted();
      }
    }

    _startSingleInstanceCheck() {
      this._stopSingleInstanceCheck();
      checkIntervalId = window.setInterval(this._checkSingleInstance.bind(this), CONFIG.INTERVAL);
    }

    _stopSingleInstanceCheck() {
      if (checkIntervalId) {
        window.clearInterval(checkIntervalId);
      }
      checkIntervalId = undefined;
    }
  };
})();

/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */

'use strict';

window.z = window.z || {};
window.z.main = z.main || {};

z.main.App = class App {
  static get CONFIG() {
    return {
      COOKIES_CHECK: {
        COOKIE_NAME: 'cookies_enabled',
      },
      NOTIFICATION_CHECK: z.util.TimeUtil.UNITS_IN_MILLIS.SECOND * 10,
      SIGN_OUT_REASONS: {
        IMMEDIATE: [
          z.auth.SIGN_OUT_REASON.ACCOUNT_DELETED,
          z.auth.SIGN_OUT_REASON.CLIENT_REMOVED,
          z.auth.SIGN_OUT_REASON.SESSION_EXPIRED,
        ],
        TEMPORARY_GUEST: [
          z.auth.SIGN_OUT_REASON.MULTIPLE_TABS,
          z.auth.SIGN_OUT_REASON.SESSION_EXPIRED,
          z.auth.SIGN_OUT_REASON.USER_REQUESTED,
        ],
      },
    };
  }

  /**
   * Construct a new app.
   * @param {z.main.Auth} authComponent - Authentication component
   */
  constructor(authComponent) {
    this.backendClient = authComponent.backendClient;
    this.logger = new z.util.Logger('z.main.App', z.config.LOGGER.OPTIONS);

    this.telemetry = new z.telemetry.app_init.AppInitTelemetry();
    this.windowHandler = new z.ui.WindowHandler().init();

    this.service = this._setupServices(authComponent);
    this.repository = this._setupRepositories(authComponent);
    this.view = this._setupViewModels();
    this.util = this._setup_utils();

    this.instanceId = z.util.createRandomUuid();

    this._onExtraInstanceStarted = this._onExtraInstanceStarted.bind(this);
    this.singleInstanceHandler = new z.main.SingleInstanceHandler(this._onExtraInstanceStarted);

    this._subscribeToEvents();

    this.initDebugging();
    this.initApp();
    this.initServiceWorker();
  }

  //##############################################################################
  // Instantiation
  //##############################################################################

  /**
   * Create all app repositories.
   * @param {z.main.Auth} authComponent - Authentication component
   * @returns {Object} All repositories
   */
  _setupRepositories(authComponent) {
    const repositories = {};

    repositories.audio = authComponent.audio;
    repositories.auth = authComponent.repository;
    repositories.cache = new z.cache.CacheRepository();
    repositories.giphy = new z.extension.GiphyRepository(this.service.giphy);
    repositories.location = new z.location.LocationRepository(this.service.location);
    repositories.permission = new z.permission.PermissionRepository();
    repositories.serverTime = new z.time.ServerTimeRepository();
    repositories.storage = new z.storage.StorageRepository(this.service.storage);

    repositories.cryptography = new z.cryptography.CryptographyRepository(
      this.service.cryptography,
      repositories.storage
    );
    repositories.client = new z.client.ClientRepository(this.service.client, repositories.cryptography);
    repositories.media = new z.media.MediaRepository(repositories.permission);
    repositories.user = new z.user.UserRepository(
      this.service.user,
      this.service.asset,
      this.service.self,
      repositories.client,
      repositories.serverTime
    );
    repositories.connection = new z.connection.ConnectionRepository(this.service.connection, repositories.user);
    repositories.event = new z.event.EventRepository(
      this.service.event,
      this.service.notification,
      this.service.webSocket,
      this.service.conversation,
      repositories.cryptography,
      repositories.serverTime,
      repositories.user
    );
    repositories.properties = new z.properties.PropertiesRepository(this.service.properties);
    repositories.lifecycle = new z.lifecycle.LifecycleRepository(this.service.lifecycle, repositories.user);
    repositories.connect = new z.connect.ConnectRepository(this.service.connect, repositories.properties);
    repositories.links = new z.links.LinkPreviewRepository(this.service.asset, repositories.properties);
    repositories.search = new z.search.SearchRepository(this.service.search, repositories.user);
    repositories.team = new z.team.TeamRepository(this.service.team, repositories.user);
    repositories.eventTracker = new z.tracking.EventTrackingRepository(repositories.team, repositories.user);

    repositories.conversation = new z.conversation.ConversationRepository(
      this.service.conversation,
      this.service.asset,
      repositories.client,
      repositories.connection,
      repositories.cryptography,
      repositories.event,
      repositories.giphy,
      repositories.links,
      repositories.serverTime,
      repositories.team,
      repositories.user
    );

    const serviceMiddleware = new z.event.preprocessor.ServiceMiddleware(repositories.conversation, repositories.user);
    const quotedMessageMiddleware = new z.event.preprocessor.QuotedMessageMiddleware(
      this.service.event,
      z.message.MessageHasher
    );
    repositories.event.setEventProcessMiddlewares([
      serviceMiddleware.processEvent.bind(serviceMiddleware),
      quotedMessageMiddleware.processEvent.bind(quotedMessageMiddleware),
    ]);
    repositories.backup = new z.backup.BackupRepository(
      this.service.backup,
      repositories.client,
      repositories.connection,
      repositories.conversation,
      repositories.user
    );
    repositories.broadcast = new z.broadcast.BroadcastRepository(
      this.service.broadcast,
      repositories.client,
      repositories.conversation,
      repositories.cryptography,
      repositories.user
    );
    repositories.calling = new z.calling.CallingRepository(
      this.service.calling,
      repositories.client,
      repositories.conversation,
      repositories.event,
      repositories.media,
      repositories.serverTime,
      repositories.user
    );
    repositories.integration = new z.integration.IntegrationRepository(
      this.service.integration,
      repositories.conversation,
      repositories.team
    );
    repositories.notification = new z.notification.NotificationRepository(
      repositories.calling,
      repositories.conversation,
      repositories.permission,
      repositories.user
    );
    repositories.videoGrid = new z.calling.VideoGridRepository(repositories.calling, repositories.media);

    return repositories;
  }

  /**
   * Create all app services.
   * @param {z.main.Auth} authComponent - Authentication component
   * @returns {Object} All services
   */
  _setupServices(authComponent) {
    const storageService = new z.storage.StorageService();
    const eventService = z.util.Environment.browser.edge
      ? new z.event.EventServiceNoCompound(storageService)
      : new z.event.EventService(storageService);

    return {
      asset: new z.assets.AssetService(this.backendClient),
      auth: authComponent.service,
      backup: new z.backup.BackupService(storageService),
      broadcast: new z.broadcast.BroadcastService(this.backendClient),
      calling: new z.calling.CallingService(this.backendClient),
      client: new z.client.ClientService(this.backendClient, storageService),
      connect: new z.connect.ConnectService(this.backendClient),
      connection: new z.connection.ConnectionService(this.backendClient),
      conversation: new z.conversation.ConversationService(this.backendClient, eventService, storageService),
      cryptography: new z.cryptography.CryptographyService(this.backendClient),
      event: eventService,
      giphy: new z.extension.GiphyService(this.backendClient),
      integration: new z.integration.IntegrationService(this.backendClient),
      lifecycle: new z.lifecycle.LifecycleService(),
      location: new z.location.LocationService(this.backendClient),
      notification: new z.event.NotificationService(this.backendClient, storageService),
      properties: new z.properties.PropertiesService(this.backendClient),
      search: new z.search.SearchService(this.backendClient),
      self: new z.self.SelfService(this.backendClient),
      storage: storageService,
      team: new z.team.TeamService(this.backendClient),
      user: new z.user.UserService(this.backendClient, storageService),
      webSocket: new z.event.WebSocketService(this.backendClient),
    };
  }

  /**
   * Create all app utils.
   * @returns {Object} All utils
   */
  _setup_utils() {
    return window.wire.env.FEATURE.ENABLE_DEBUG ? {debug: new z.util.DebugUtil(this.repository)} : {};
  }

  /**
   * Create all app view models.
   * @returns {Object} All view models
   */
  _setupViewModels() {
    return new z.viewModel.MainViewModel(this.repository);
  }

  /**
   * Subscribe to amplify events.
   * @returns {undefined} No return value
   */
  _subscribeToEvents() {
    amplify.subscribe(z.event.WebApp.LIFECYCLE.REFRESH, this.refresh.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.SIGN_OUT, this.logout.bind(this));
    amplify.subscribe(z.event.WebApp.LIFECYCLE.UPDATE, this.update.bind(this));
  }

  //##############################################################################
  // Initialization
  //##############################################################################

  /**
   * Initialize the app.
   *
   * @note Locally known clients and sessions must not be touched until after the notification stream has been handled.
   *   Any failure in the Promise chain will result in a logout.
   * @todo Check if we really need to logout the user in all these error cases or how to recover from them
   *
   * @param {boolean} [isReload=_isReload()] - App init after page reload
   * @returns {undefined} No return value
   */
  initApp(isReload = this._isReload()) {
    z.util
      .checkIndexedDb()
      .then(() => this._registerSingleInstance())
      .then(() => this._loadAccessToken())
      .then(() => {
        this.view.loading.updateProgress(2.5);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_ACCESS_TOKEN);

        const protoFile = `ext/proto/@wireapp/protocol-messaging/messages.proto?${z.util.Environment.version(false)}`;
        return Promise.all([this._initiateSelfUser(), z.util.protobuf.loadProtos(protoFile)]);
      })
      .then(() => {
        this.view.loading.updateProgress(5, z.string.initReceivedSelfUser);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_SELF_USER);
        return this._initiateSelfUserClients();
      })
      .then(clientEntity => {
        this.view.loading.updateProgress(7.5, z.string.initValidatedClient);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.VALIDATED_CLIENT);
        this.telemetry.add_statistic(z.telemetry.app_init.AppInitStatisticsValue.CLIENT_TYPE, clientEntity.type);

        return this.repository.cryptography.loadCryptobox(this.service.storage.db);
      })
      .then(() => {
        this.view.loading.updateProgress(10);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.INITIALIZED_CRYPTOGRAPHY);

        this.repository.event.connectWebSocket();

        const promises = [this.repository.conversation.getConversations(), this.repository.connection.getConnections()];
        return Promise.all(promises);
      })
      .then(([conversationEntities, connectionEntities]) => {
        this.view.loading.updateProgress(25, z.string.initReceivedUserData);

        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.RECEIVED_USER_DATA);
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.CONVERSATIONS,
          conversationEntities.length,
          50
        );
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.CONNECTIONS,
          connectionEntities.length,
          50
        );

        this.repository.conversation.map_connections(this.repository.connection.connectionEntities());
        this._subscribeToUnloadEvents();

        return this.repository.team.getTeam();
      })
      .then(() => this.repository.user.loadUsers())
      .then(() => this.repository.event.initializeFromStream())
      .then(notificationsCount => {
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.UPDATED_FROM_NOTIFICATIONS);
        this.telemetry.add_statistic(
          z.telemetry.app_init.AppInitStatisticsValue.NOTIFICATIONS,
          notificationsCount,
          100
        );

        this.repository.eventTracker.init(this.repository.properties.properties.settings.privacy.improve_wire);
        return this.repository.conversation.initialize_conversations();
      })
      .then(() => {
        this.view.loading.updateProgress(97.5, z.string.initUpdatedFromNotifications);

        this._watchOnlineStatus();
        return this.repository.client.updateClientsForSelf();
      })
      .then(clientEntities => {
        this.view.loading.updateProgress(99);

        this.telemetry.add_statistic(z.telemetry.app_init.AppInitStatisticsValue.CLIENTS, clientEntities.length);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.APP_PRE_LOADED);

        this.repository.user.self().devices(clientEntities);
        this.logger.info('App pre-loading completed');
        return this._handleUrlParams();
      })
      .then(() => {
        this._showInterface();
        this.telemetry.report();
        amplify.publish(z.event.WebApp.LIFECYCLE.LOADED);
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.APP_LOADED);
        return this.repository.conversation.updateConversationsOnAppInit();
      })
      .then(() => {
        this.telemetry.time_step(z.telemetry.app_init.AppInitTimingsStep.UPDATED_CONVERSATIONS);
        this.repository.lifecycle.init();
        this.repository.audio.init(true);
        this.repository.conversation.cleanup_conversations();
        this.logger.info('App fully loaded');
      })
      .catch(error => this._appInitFailure(error, isReload));
  }

  /**
   * Initialize ServiceWorker if supported.
   * @returns {undefined} No return value
   */
  initServiceWorker() {
    if (navigator.serviceWorker) {
      navigator.serviceWorker
        .register(`/sw.js?${z.util.Environment.version(false)}`)
        .then(({scope}) => this.logger.info(`ServiceWorker registration successful with scope: ${scope}`));
    }
  }

  /**
   * Behavior when internet connection is re-established.
   * @returns {undefined} No return value
   */
  onInternetConnectionGained() {
    this.logger.info('Internet connection regained. Re-establishing WebSocket connection...');
    this.backendClient
      .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.CONNECTION_REGAINED)
      .then(() => {
        amplify.publish(z.event.WebApp.WARNING.DISMISS, z.viewModel.WarningsViewModel.TYPE.NO_INTERNET);
        amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.CONNECTIVITY_RECONNECT);
        this.repository.event.reconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.ONLINE);
      });
  }

  /**
   * Reflect internet connection loss in the UI.
   * @returns {undefined} No return value
   */
  onInternetConnectionLost() {
    this.logger.warn('Internet connection lost');
    this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.OFFLINE);
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.NO_INTERNET);
  }

  _appInitFailure(error, isReload) {
    let logMessage = `Could not initialize app version '${z.util.Environment.version(false)}'`;
    if (z.util.Environment.desktop) {
      logMessage = `${logMessage} - Electron '${platform.os.family}' '${z.util.Environment.version()}'`;
    }
    this.logger.info(logMessage, {error});

    const {message, type} = error;
    const isAuthError = error instanceof z.error.AuthError;
    if (isAuthError) {
      const isTypeMultipleTabs = type === z.error.AuthError.TYPE.MULTIPLE_TABS;
      const signOutReason = isTypeMultipleTabs
        ? z.auth.SIGN_OUT_REASON.MULTIPLE_TABS
        : z.auth.SIGN_OUT_REASON.INDEXED_DB;
      return this._redirectToLogin(signOutReason);
    }

    this.logger.debug(
      `App reload: '${isReload}', Document referrer: '${document.referrer}', Location: '${window.location.href}'`
    );
    if (isReload) {
      const isSessionExpired = [
        z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN,
        z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE,
      ];

      if (isSessionExpired.includes(type)) {
        this.logger.error(`Session expired on page reload: ${message}`, error);
        Raygun.send(new Error('Session expired on page reload', error));
        return this._redirectToLogin(z.auth.SIGN_OUT_REASON.SESSION_EXPIRED);
      }

      const isAccessTokenError = error instanceof z.error.AccessTokenError;
      const isInvalidClient = type === z.error.ClientError.TYPE.NO_VALID_CLIENT;

      if (isAccessTokenError || isInvalidClient) {
        this.logger.warn('Connectivity issues. Trigger reload on regained connectivity.', error);
        const triggerSource = isAccessTokenError
          ? z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.ACCESS_TOKEN_RETRIEVAL
          : z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.APP_INIT_RELOAD;
        return this.backendClient.executeOnConnectivity(triggerSource).then(() => window.location.reload(false));
      }
    }

    if (navigator.onLine) {
      switch (type) {
        case z.error.AccessTokenError.TYPE.NOT_FOUND_IN_CACHE:
        case z.error.AccessTokenError.TYPE.RETRIES_EXCEEDED:
        case z.error.AccessTokenError.TYPE.REQUEST_FORBIDDEN: {
          this.logger.warn(`Redirecting to login: ${error.message}`, error);
          return this._redirectToLogin(z.auth.SIGN_OUT_REASON.NOT_SIGNED_IN);
        }

        default: {
          this.logger.error(`Caused by: ${(error ? error.message : undefined) || error}`, error);

          const isAccessTokenError = error instanceof z.error.AccessTokenError;
          if (isAccessTokenError) {
            this.logger.error(`Could not get access token: ${error.message}. Logging out user.`, error);
          } else {
            Raygun.send(error);
          }

          return this.logout(z.auth.SIGN_OUT_REASON.APP_INIT);
        }
      }
    }

    this.logger.warn('No connectivity. Trigger reload on regained connectivity.', error);
    this._watchOnlineStatus();
  }

  /**
   * Check whether we need to set different user information (picture, username).
   * @param {z.entity.User} userEntity - Self user entity
   * @returns {z.entity.User} Checked user entity
   */
  _checkUserInformation(userEntity) {
    if (userEntity.hasActivatedIdentity()) {
      if (!userEntity.mediumPictureResource()) {
        this.repository.user.set_default_picture();
      }
      if (!userEntity.username()) {
        this.repository.user.get_username_suggestion();
      }
    }

    return userEntity;
  }

  /**
   * Initiate the self user by getting it from the backend.
   * @returns {Promise<z.entity.User>} Resolves with the self user entity
   */
  _initiateSelfUser() {
    return this.repository.user.getSelf().then(userEntity => {
      this.logger.info(`Loaded self user with ID '${userEntity.id}'`);

      if (!userEntity.hasActivatedIdentity()) {
        this.logger.info('User does not have an activated identity and seems to be a temporary guest');

        if (!userEntity.isTemporaryGuest()) {
          throw new Error('User does not have an activated identity');
        }
      }

      return this.service.storage
        .init(userEntity.id)
        .then(() => this.repository.client.init(userEntity))
        .then(() => this.repository.properties.init(userEntity))
        .then(() => this._checkUserInformation(userEntity));
    });
  }

  /**
   * Initiate the current client of the self user.
   * @returns {Promise<z.client.Client>} Resolves with the local client entity
   */
  _initiateSelfUserClients() {
    return this.repository.client
      .getValidLocalClient()
      .then(clientObservable => {
        this.repository.cryptography.currentClient = clientObservable;
        this.repository.event.currentClient = clientObservable;
        return this.repository.client.getClientsForSelf();
      })
      .then(() => this.repository.client.currentClient());
  }

  /**
   * Handle URL params.
   * @private
   * @returns {undefined} Not return value
   */
  _handleUrlParams() {
    // Currently no URL params to be handled
  }

  /**
   * Check whether the page has been reloaded.
   * @private
   * @returns {boolean}  True if it is a page refresh
   */
  _isReload() {
    const isReload = z.util.isSameLocation(document.referrer, window.location.href);
    const log = `App reload: '${isReload}', Referrer: '${document.referrer}', Location: '${window.location.href}'`;
    this.logger.debug(log);
    return isReload;
  }

  /**
   * Load the access token from cache or get one from the backend.
   * @returns {Promise} Resolves with the access token
   */
  _loadAccessToken() {
    const isLocalhost = z.util.Environment.frontend.isLocalhost();
    const referrer = document.referrer.toLowerCase();
    const isLoginRedirect = referrer.includes('/auth') || referrer.includes('/login');
    const getCachedToken = isLocalhost || isLoginRedirect;

    return getCachedToken ? this.repository.auth.getCachedAccessToken() : this.repository.auth.getAccessToken();
  }

  //##############################################################################
  // Multiple tabs check
  //##############################################################################

  /**
   * Check that this is the single instance tab of the app.
   * @returns {Promise} Resolves when page is the first tab
   */
  _registerSingleInstance() {
    if (this.singleInstanceHandler.registerInstance(this.instanceId)) {
      this._registerSingleInstanceCleaning();
      return Promise.resolve();
    }
    return Promise.reject(new z.error.AuthError(z.error.AuthError.TYPE.MULTIPLE_TABS));
  }

  _registerSingleInstanceCleaning(singleInstanceCheckIntervalId) {
    $(window).on('beforeunload', () => {
      this.singleInstanceHandler.deregisterInstance();
    });
  }

  /**
   * Hide the loading spinner and show the application UI.
   * @returns {undefined} No return value
   */
  _showInterface() {
    const conversationEntity = this.repository.conversation.getMostRecentConversation();
    this.logger.info('Showing application UI');
    if (this.repository.user.isTemporaryGuest()) {
      this.view.list.showTemporaryGuest();
    } else if (this.repository.user.shouldChangeUsername()) {
      this.view.list.showTakeover();
    } else if (conversationEntity) {
      amplify.publish(z.event.WebApp.CONVERSATION.SHOW, conversationEntity);
    } else if (this.repository.user.connect_requests().length) {
      amplify.publish(z.event.WebApp.CONTENT.SWITCH, z.viewModel.ContentViewModel.STATE.CONNECTION_REQUESTS);
    }

    this.view.loading.removeFromView();
    $('#wire-main').attr('data-uie-value', 'is-loaded');

    this.repository.properties.checkPrivacyPermission().then(() => {
      window.setTimeout(() => this.repository.notification.checkPermission(), App.CONFIG.NOTIFICATION_CHECK);
    });
  }

  /**
   * Subscribe to 'beforeunload' to stop calls and disconnect the WebSocket.
   * @returns {undefined} No return value
   */
  _subscribeToUnloadEvents() {
    $(window).on('unload', () => {
      this.logger.info("'window.onunload' was triggered, so we will disconnect from the backend.");
      this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.PAGE_NAVIGATION);
      this.repository.calling.leaveCallOnUnload();

      if (this.repository.user.isActivatedAccount()) {
        this.repository.storage.terminate('window.onunload');
      } else {
        this.repository.conversation.leaveGuestRoom();
        this.repository.storage.deleteDatabase();
      }

      this.repository.notification.clearNotifications();
    });
  }

  /**
   * Subscribe to 'navigator.onLine' related events.
   * @returns {undefined} No return value
   */
  _watchOnlineStatus() {
    this.logger.info('Watching internet connectivity status');
    $(window).on('offline', this.onInternetConnectionLost.bind(this));
    $(window).on('online', this.onInternetConnectionGained.bind(this));
  }

  //##############################################################################
  // Lifecycle
  //##############################################################################

  /**
   * Logs the user out on the backend and deletes cached data.
   *
   * @param {z.auth.SIGN_OUT_REASON} signOutReason - Cause for logout
   * @param {boolean} clearData - Keep data in database
   * @returns {undefined} No return value
   */
  logout(signOutReason, clearData = false) {
    const _redirectToLogin = () => {
      amplify.publish(z.event.WebApp.LIFECYCLE.SIGNED_OUT, clearData);
      this._redirectToLogin(signOutReason);
    };

    const _logout = () => {
      // Disconnect from our backend, end tracking and clear cached data
      this.repository.event.disconnectWebSocket(z.event.WebSocketService.CHANGE_TRIGGER.LOGOUT);

      // Clear Local Storage (but don't delete the cookie label if you were logged in with a permanent client)
      const keysToKeep = [z.storage.StorageKey.AUTH.SHOW_LOGIN];

      const keepPermanentDatabase = this.repository.client.isCurrentClientPermanent() && !clearData;
      if (keepPermanentDatabase) {
        keysToKeep.push(z.storage.StorageKey.AUTH.PERSIST);
      }

      // @todo remove on next iteration
      const selfUser = this.repository.user.self();
      if (selfUser) {
        const cookieLabelKey = this.repository.client.constructCookieLabelKey(selfUser.email() || selfUser.phone());

        Object.keys(amplify.store()).forEach(keyInAmplifyStore => {
          const isCookieLabelKey = keyInAmplifyStore === cookieLabelKey;
          const deleteLabelKey = isCookieLabelKey && clearData;
          const isCookieLabel = z.util.StringUtil.includes(keyInAmplifyStore, z.storage.StorageKey.AUTH.COOKIE_LABEL);

          if (!deleteLabelKey && isCookieLabel) {
            keysToKeep.push(keyInAmplifyStore);
          }
        });

        const keepConversationInput = signOutReason === z.auth.SIGN_OUT_REASON.SESSION_EXPIRED;
        this.repository.cache.clearCache(keepConversationInput, keysToKeep);
      }

      // Clear IndexedDB
      const clearDataPromise = clearData
        ? this.repository.storage
            .deleteDatabase()
            .catch(error => this.logger.error('Failed to delete database before logout', error))
        : Promise.resolve();

      return clearDataPromise.then(() => _redirectToLogin());
    };

    const _logoutOnBackend = () => {
      this.logger.info(`Logout triggered by '${signOutReason}': Disconnecting user from the backend.`);
      return this.repository.auth
        .logout()
        .then(() => _logout())
        .catch(() => _redirectToLogin());
    };

    if (App.CONFIG.SIGN_OUT_REASONS.IMMEDIATE.includes(signOutReason)) {
      return _logout();
    }

    if (navigator.onLine) {
      return _logoutOnBackend();
    }

    this.logger.warn('No internet access. Continuing when internet connectivity regained.');
    $(window).on('online', () => _logoutOnBackend());
  }

  /**
   * Refresh the web app or desktop wrapper
   * @returns {undefined} No return value
   */
  refresh() {
    this.logger.info(`Refresh to update started`);
    if (z.util.Environment.desktop) {
      // if we are in a desktop env, we just warn the wrapper that we need to reload. It then decide what should be done
      return amplify.publish(z.event.WebApp.LIFECYCLE.RESTART, z.lifecycle.UPDATE_SOURCE.WEBAPP);
    }

    window.location.reload(true);
    window.focus();
  }

  /**
   * Notify about found update
   * @returns {undefined} No return value
   */
  update() {
    amplify.publish(z.event.WebApp.WARNING.SHOW, z.viewModel.WarningsViewModel.TYPE.LIFECYCLE_UPDATE);
  }

  /**
   * Redirect to the login page after internet connectivity has been verified.
   * @param {z.auth.SIGN_OUT_REASON} signOutReason - Redirect triggered by session expiration
   * @returns {undefined} No return value
   */
  _redirectToLogin(signOutReason) {
    this.logger.info(`Redirecting to login after connectivity verification. Reason: ${signOutReason}`);
    this.backendClient
      .executeOnConnectivity(z.service.BackendClient.CONNECTIVITY_CHECK_TRIGGER.LOGIN_REDIRECT)
      .then(() => {
        const isTemporaryGuestReason = App.CONFIG.SIGN_OUT_REASONS.TEMPORARY_GUEST.includes(signOutReason);
        const isLeavingGuestRoom = isTemporaryGuestReason && this.repository.user.isTemporaryGuest();
        if (isLeavingGuestRoom) {
          const path = z.l10n.text(z.string.urlWebsiteRoot);
          const url = z.util.URLUtil.buildUrl(z.util.URLUtil.TYPE.WEBSITE, path);
          return window.location.replace(url);
        }

        let url = `/auth/${location.search}`;
        const isImmediateSignOutReason = App.CONFIG.SIGN_OUT_REASONS.IMMEDIATE.includes(signOutReason);
        if (isImmediateSignOutReason) {
          url = z.util.URLUtil.appendParameter(url, `${z.auth.URLParameter.REASON}=${signOutReason}`);
        }

        const redirectToLogin = signOutReason !== z.auth.SIGN_OUT_REASON.NOT_SIGNED_IN;
        if (redirectToLogin) {
          url = `${url}#login`;
        }

        window.location.replace(url);
      });
  }

  //##############################################################################
  // Debugging
  //##############################################################################

  /**
   * Disable debugging on any environment.
   * @returns {undefined} No return value
   */
  disableDebugging() {
    z.config.LOGGER.OPTIONS.domains['app.wire.com'] = () => 0;
    this.repository.properties.savePreference(z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING, false);
  }

  /**
   * Enable debugging on any environment.
   * @returns {undefined} No return value
   */
  enableDebugging() {
    z.config.LOGGER.OPTIONS.domains['app.wire.com'] = () => 300;
    this.repository.properties.savePreference(z.properties.PROPERTIES_TYPE.ENABLE_DEBUGGING, true);
  }

  /**
   * Initialize debugging features.
   * @returns {undefined} No return value
   */
  initDebugging() {
    if (z.util.Environment.frontend.isLocalhost()) {
      this._attachLiveReload();
    }
  }

  /**
   * Report call telemetry to Raygun for analysis.
   * @returns {undefined} No return value
   */
  reportCall() {
    this.repository.calling.reportCall();
  }

  /**
   * Attach live reload on localhost.
   * @returns {undefined} No return value
   */
  _attachLiveReload() {
    const liveReload = document.createElement('script');
    liveReload.id = 'liveReload';
    liveReload.src = 'http://localhost:32123/livereload.js';
    document.body.appendChild(liveReload);
    $('html').addClass('development');
  }

  _onExtraInstanceStarted() {
    return this._redirectToLogin(z.auth.SIGN_OUT_REASON.MULTIPLE_TABS);
  }
};

//##############################################################################
// Setting up the App
//##############################################################################

$(() => {
  if ($('#wire-main-app').length !== 0) {
    wire.app = new z.main.App(wire.auth);
  }
});

//# sourceMappingURL=wire-app.min.js.map